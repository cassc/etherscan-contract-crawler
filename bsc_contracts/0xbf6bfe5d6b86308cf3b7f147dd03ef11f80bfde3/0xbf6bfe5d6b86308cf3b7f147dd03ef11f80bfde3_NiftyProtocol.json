{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/NiftyProtocol.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Refundable.sol\\\";\\nimport \\\"./ExchangeCore.sol\\\";\\n\\ncontract NiftyProtocol is\\n    Ownable,\\n    Refundable,\\n    ExchangeCore\\n{\\n    string public name = \\\"Nifty Protocol\\\";\\n\\n    constructor (uint256 chainId) LibEIP712ExchangeDomain(chainId) {}\\n    \\n    /// @dev Fills the input order.\\n    /// @param order Order struct containing order specifications.\\n    /// @param signature Proof that order has been created by maker.\\n    /// @return fulfilled boolean\\n    function fillOrder(\\n        LibOrder.Order memory order,\\n        bytes memory signature,\\n        bytes32 marketplaceIdentifier\\n    )\\n        override\\n        external\\n        payable\\n        refundFinalBalanceNoReentry\\n        returns (bool fulfilled)\\n    {\\n        return _fillOrder(\\n            order,\\n            signature,\\n            msg.sender,\\n            marketplaceIdentifier\\n        );\\n    }\\n\\n    /// @dev Fills the input order.\\n    /// @param order Order struct containing order specifications.\\n    /// @param signature Proof that order has been created by maker.\\n    /// @param takerAddress address to fulfill the order for / gift.\\n    /// @return fulfilled boolean\\n    function fillOrderFor(\\n        LibOrder.Order memory order,\\n        bytes memory signature,\\n        bytes32 marketplaceIdentifier,\\n        address takerAddress\\n    )\\n        override\\n        external\\n        payable\\n        refundFinalBalanceNoReentry\\n        returns (bool fulfilled)\\n    {\\n        return _fillOrder(\\n            order,\\n            signature,\\n            takerAddress,\\n            marketplaceIdentifier\\n        );\\n    }\\n\\n    /// @dev After calling, the order can not be filled anymore.\\n    /// @param order Order struct containing order specifications.\\n    function cancelOrder(LibOrder.Order memory order)\\n        override\\n        external\\n    {\\n        _cancelOrder(order);\\n    }\\n\\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\\n        override\\n        external\\n    {\\n        address makerAddress = msg.sender;\\n        // orderEpoch is initialized to 0, so to cancelUpTo we need salt + 1\\n        uint256 newOrderEpoch = targetOrderEpoch + 1;\\n        uint256 oldOrderEpoch = orderEpoch[makerAddress];\\n\\n        // Ensure orderEpoch is monotonically increasing\\n        if (newOrderEpoch <= oldOrderEpoch) {\\n            revert('EXCHANGE: order epoch error');\\n        }\\n\\n        // Update orderEpoch\\n        orderEpoch[makerAddress] = newOrderEpoch;\\n        emit CancelUpTo(\\n            makerAddress,\\n            newOrderEpoch\\n        );\\n    }\\n\\n    /// @dev Gets information about an order: status, hash, and amount filled.\\n    /// @param order Order to gather information on.\\n    /// @return orderInfo Information about the order and its state.\\n    ///         See LibOrder.OrderInfo for a complete description.\\n    function getOrderInfo(LibOrder.Order memory order)\\n        override\\n        public\\n        view\\n        returns (LibOrder.OrderInfo memory orderInfo)\\n    {\\n        return _getOrderInfo(order);\\n    }\\n\\n    function returnAllETHToOwner() external payable onlyOwner {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function returnERC20ToOwner(address ERC20Token) external payable onlyOwner {\\n        IERC20 CustomToken = IERC20(ERC20Token);\\n        CustomToken.transferFrom(address(this), msg.sender, CustomToken.balanceOf(address(this)));\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/LibOrder.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"./LibEIP712.sol\\\";\\n\\n\\nlibrary LibOrder {\\n\\n    using LibOrder for Order;\\n\\n    // Hash for the EIP712 Order Schema:\\n    // keccak256(abi.encodePacked(\\n    //     \\\"Order(\\\",\\n    //     \\\"address makerAddress,\\\",\\n    //     \\\"address takerAddress,\\\",\\n    //     \\\"address royaltiesAddress,\\\",\\n    //     \\\"address senderAddress,\\\",\\n    //     \\\"uint256 makerAssetAmount,\\\",\\n    //     \\\"uint256 takerAssetAmount,\\\",\\n    //     \\\"uint256 royaltiesAmount,\\\",\\n    //     \\\"uint256 expirationTimeSeconds,\\\",\\n    //     \\\"uint256 salt,\\\",\\n    //     \\\"bytes makerAssetData,\\\",\\n    //     \\\"bytes takerAssetData\\\",\\n    //     \\\")\\\"\\n    // ))\\n    bytes32 constant internal _EIP712_ORDER_SCHEMA_HASH =\\n        0x85eeee70c9e228559a0ea5492e9915b70dab1efedd40807802f996020d88dc2e;\\n\\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\\n    // An order's status is unaffected by external factors, like account balances.\\n    enum OrderStatus {\\n        INVALID,                     // Default value\\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\\n        INVALID_ROYALTIES,           // Order does not have a valid royalties\\n        FILLABLE,                    // Order is fillable\\n        EXPIRED,                     // Order has already expired\\n        FILLED,                      // Order is fully filled\\n        CANCELLED                    // Order has been cancelled\\n    }\\n\\n    enum OrderType {\\n        INVALID,                     // Default value\\n        LIST,\\n        OFFER,\\n        SWAP\\n    }\\n\\n    // solhint-disable max-line-length\\n    /// @dev Canonical order structure.\\n    struct Order {\\n        address makerAddress;           // Address that created the order.\\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\\n        address royaltiesAddress;       // Address that will recieve fees when order is filled.\\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\\n        uint256 royaltiesAmount;        // Fee paid to royaltiesAddress when order is filled.\\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The leading bytes4 references the id of the asset proxy.\\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The leading bytes4 references the id of the asset proxy.\\n    }\\n    // solhint-enable max-line-length\\n\\n    /// @dev Order information returned by `getOrderInfo()`.\\n    struct OrderInfo {\\n        OrderStatus orderStatus;              // Status that describes order's validity and fillability.\\n        OrderType orderType;                  // type that describes order's side.\\n        bytes32 orderHash;                    // EIP712 typed data hash of the order (see LibOrder.getTypedDataHash).\\n        bool filled;                          // order has already been filled.\\n    }\\n\\n    /// @dev Calculates the EIP712 typed data hash of an order with a given domain separator.\\n    /// @param order The order structure.\\n    /// @return orderHash EIP712 typed data hash of the order.\\n    function getTypedDataHash(Order memory order, bytes32 eip712ExchangeDomainHash)\\n        internal\\n        pure\\n        returns (bytes32 orderHash)\\n    {\\n        orderHash = LibEIP712.hashMessage(\\n            eip712ExchangeDomainHash,\\n            order.getStructHash()\\n        );\\n        return orderHash;\\n    }\\n\\n    /// @dev Calculates EIP712 hash of the order struct.\\n    /// @param order The order structure.\\n    /// @return result EIP712 hash of the order struct.\\n    function getStructHash(Order memory order)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        bytes32 schemaHash = _EIP712_ORDER_SCHEMA_HASH;\\n        bytes memory makerAssetData = order.makerAssetData;\\n        bytes memory takerAssetData = order.takerAssetData;\\n\\n        // Assembly for more efficiently computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP712_ORDER_SCHEMA_HASH,\\n        //     uint256(order.makerAddress),\\n        //     uint256(order.takerAddress),\\n        //     uint256(order.royaltiesAddress),\\n        //     uint256(order.senderAddress),\\n        //     order.makerAssetAmount,\\n        //     order.takerAssetAmount,\\n        //     order.royaltiesAmount,\\n        //     order.expirationTimeSeconds,\\n        //     order.salt,\\n        //     keccak256(order.makerAssetData),\\n        //     keccak256(order.takerAssetData)\\n        // ));\\n\\n        assembly {\\n            // Assert order offset (this is an internal error that should never be triggered)\\n            if lt(order, 32) {\\n                invalid()\\n            }\\n\\n            // Calculate memory addresses that will be swapped out before hashing\\n            let pos1 := sub(order, 32)\\n            let pos2 := add(order, 288)\\n            let pos3 := add(order, 320)\\n\\n            // Backup\\n            let temp1 := mload(pos1)\\n            let temp2 := mload(pos2)\\n            let temp3 := mload(pos3)\\n\\n            // Hash in place\\n            mstore(pos1, schemaHash)\\n            mstore(pos2, keccak256(add(makerAssetData, 32), mload(makerAssetData)))        // store hash of makerAssetData\\n            mstore(pos3, keccak256(add(takerAssetData, 32), mload(takerAssetData)))        // store hash of takerAssetData\\n            result := keccak256(pos1, 384)\\n\\n            // Restore\\n            mstore(pos1, temp1)\\n            mstore(pos2, temp2)\\n            mstore(pos3, temp3)\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/LibEIP712.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n\\nlibrary LibEIP712 {\\n\\n    // Hash of the EIP712 Domain Separator Schema\\n    // keccak256(abi.encodePacked(\\n    //     \\\"EIP712Domain(\\\",\\n    //     \\\"string name,\\\",\\n    //     \\\"string version,\\\",\\n    //     \\\"uint256 chainId,\\\",\\n    //     \\\"address verifyingContract\\\",\\n    //     \\\")\\\"\\n    // ))\\n    bytes32 constant internal SCHEMA_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev Calculates a EIP712 domain separator.\\n    /// @param name The EIP712 domain name.\\n    /// @param version The EIP712 domain version.\\n    /// @param verifyingContract The EIP712 verifying contract.\\n    /// @return result EIP712 domain separator.\\n    function hashDomain(\\n        string memory name,\\n        string memory version,\\n        uint256 chainId,\\n        address verifyingContract\\n    )\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        bytes32 schemaHash = SCHEMA_HASH;\\n\\n        // Assembly for more efficient computing:\\n        // keccak256(abi.encodePacked(\\n        //     SCHEMA_HASH,\\n        //     keccak256(bytes(name)),\\n        //     keccak256(bytes(version)),\\n        //     chainId,\\n        //     uint256(verifyingContract)\\n        // ))\\n\\n        assembly {\\n            // Calculate hashes of dynamic data\\n            let nameHash := keccak256(add(name, 32), mload(name))\\n            let versionHash := keccak256(add(version, 32), mload(version))\\n\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            // Store params in memory\\n            mstore(memPtr, schemaHash)\\n            mstore(add(memPtr, 32), nameHash)\\n            mstore(add(memPtr, 64), versionHash)\\n            mstore(add(memPtr, 96), chainId)\\n            mstore(add(memPtr, 128), verifyingContract)\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 160)\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Calculates EIP712 encoding for a hash struct with a given domain hash.\\n    /// @param domainHash Hash of the domain domain separator data, computed\\n    ///                         with getDomainHash().\\n    /// @param hashStruct The EIP712 hash struct.\\n    /// @return result EIP712 hash applied to the given EIP712 Domain.\\n    function hashMessage(bytes32 domainHash, bytes32 hashStruct)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        // Assembly for more efficient computing:\\n        // keccak256(abi.encodePacked(\\n        //     EIP191_HEADER,\\n        //     EIP712_DOMAIN_HASH,\\n        //     hashStruct\\n        // ));\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\\n            mstore(add(memPtr, 2), domainHash)                                            // EIP712 domain hash\\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\\n\\n            // Compute hash\\n            result := keccak256(memPtr, 66)\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libs/LibBytes.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n\\nlibrary LibBytes {\\n\\n    using LibBytes for bytes;\\n\\n    /// @dev Returns a slice from a byte array without preserving the input.\\n    /// @param b The byte array to take a slice from. Will be destroyed in the process.\\n    /// @param from The starting index for the slice (inclusive).\\n    /// @param to The final index for the slice (exclusive).\\n    /// @return result The slice containing bytes at indices [from, to)\\n    /// @dev When `from == 0`, the original array will match the slice. In other cases its state will be corrupted.\\n    function sliceDestructive(\\n        bytes memory b,\\n        uint256 from,\\n        uint256 to\\n    )\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        // Ensure that the from and to positions are valid positions for a slice within\\n        // the byte array that is being used.\\n        if (from > to) {\\n            revert('LIB BYTES: from less than or equals to required');\\n        }\\n        if (to > b.length) {\\n            revert('LIB BYTES: to less than or equals length required');\\n        }\\n\\n        // Create a new bytes structure around [from, to) in-place.\\n        assembly {\\n            result := add(b, from)\\n            mstore(result, sub(to, from))\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Reads an address from a position in a byte array.\\n    /// @param b Byte array containing an address.\\n    /// @param index Index in byte array of address.\\n    /// @return result address from byte array.\\n    function readAddress(\\n        bytes memory b,\\n        uint256 index\\n    )\\n        internal\\n        pure\\n        returns (address result)\\n    {\\n        if (b.length < index + 20) {\\n            revert('LIB BYTES: length greater than or equals twenty required');\\n        }\\n\\n        // Add offset to index:\\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\\n        index += 20;\\n\\n        // Read address from array memory\\n        assembly {\\n            // 1. Add index to address of bytes array\\n            // 2. Load 32-byte word from memory\\n            // 3. Apply 20-byte mask to obtain address\\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Reads a bytes32 value from a position in a byte array.\\n    /// @param b Byte array containing a bytes32 value.\\n    /// @param index Index in byte array of bytes32 value.\\n    /// @return result bytes32 value from byte array.\\n    function readBytes32(\\n        bytes memory b,\\n        uint256 index\\n    )\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        if (b.length < index + 32) {\\n            revert('LIB BYTES: length greater than or equals thirty two required');\\n        }\\n\\n        // Arrays are prefixed by a 256 bit length parameter\\n        index += 32;\\n\\n        // Read the bytes32 from array memory\\n        assembly {\\n            result := mload(add(b, index))\\n        }\\n        return result;\\n    }\\n\\n    /// @dev Reads a uint256 value from a position in a byte array.\\n    /// @param b Byte array containing a uint256 value.\\n    /// @param index Index in byte array of uint256 value.\\n    /// @return result uint256 value from byte array.\\n    function readUint256(\\n        bytes memory b,\\n        uint256 index\\n    )\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = uint256(readBytes32(b, index));\\n        return result;\\n    }\\n\\n    /// @dev Reads an unpadded bytes4 value from a position in a byte array.\\n    /// @param b Byte array containing a bytes4 value.\\n    /// @param index Index in byte array of bytes4 value.\\n    /// @return result bytes4 value from byte array.\\n    function readBytes4(\\n        bytes memory b,\\n        uint256 index\\n    )\\n        internal\\n        pure\\n        returns (bytes4 result)\\n    {\\n        if (b.length < index + 4) {\\n            revert('LIB BYTES: length greater than or equals four required');\\n        }\\n\\n        // Arrays are prefixed by a 32 byte length field\\n        index += 32;\\n\\n        // Read the bytes4 from array memory\\n        assembly {\\n            result := mload(add(b, index))\\n            // Solidity does not require us to clean the trailing bytes.\\n            // We do it anyway\\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/ISignatureValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"../libs/LibOrder.sol\\\";\\n\\n\\ninterface ISignatureValidator {\\n\\n   // Allowed signature types.\\n    enum SignatureType {\\n        Illegal,                     // 0x00, default value\\n        Invalid,                     // 0x01\\n        EIP712,                      // 0x02\\n        EthSign,                     // 0x03\\n        NSignatureTypes              // 0x06, number of signature types. Always leave at end.\\n    }\\n\\n    /// @dev Verifies that a hash has been signed by the given signer.\\n    /// @param hash Any 32-byte hash.\\n    /// @param signature Proof that the hash has been signed by signer.\\n    /// @return isValid `true` if the signature is valid for the given hash and signer.\\n    function isValidHashSignature(\\n        bytes32 hash,\\n        address signerAddress,\\n        bytes memory signature\\n    )\\n        external\\n        view\\n        returns (bool isValid);\\n\\n    /// @dev Verifies that a signature for an order is valid.\\n    /// @param order The order.\\n    /// @param signature Proof that the order has been signed by signer.\\n    /// @return isValid true if the signature is valid for the given order and signer.\\n    function isValidOrderSignature(\\n        LibOrder.Order memory order,\\n        bytes memory signature\\n    )\\n        external\\n        view\\n        returns (bool isValid);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IProtocolFees.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n\\ninterface IProtocolFees {\\n\\n    // Logs updates to the protocol fee multiplier.\\n    event ProtocolFeeMultiplier(uint256 oldProtocolFeeMultiplier, uint256 updatedProtocolFeeMultiplier);\\n\\n    // Logs updates to the protocol fixed fee.\\n    event ProtocolFixedFee(uint256 oldProtocolFixedFee, uint256 updatedProtocolFixedFee);\\n\\n    // Logs updates to the protocolFeeCollector address.\\n    event ProtocolFeeCollectorAddress(address oldProtocolFeeCollector, address updatedProtocolFeeCollector);\\n\\n    /// @dev Allows the owner to update the protocol fee multiplier.\\n    /// @param updatedProtocolFeeMultiplier The updated protocol fee multiplier.\\n    function setProtocolFeeMultiplier(uint256 updatedProtocolFeeMultiplier) external;\\n\\n    /// @dev Allows the owner to update the protocol fixed fee.\\n    /// @param fixedProtocolFee The updated protocol fixed fee.\\n    function setProtocolFixedFee(uint256 fixedProtocolFee) external;\\n\\n    /// @dev Allows the owner to update the protocolFeeCollector address.\\n    /// @param updatedProtocolFeeCollector The updated protocolFeeCollector contract address.\\n    function setProtocolFeeCollectorAddress(address updatedProtocolFeeCollector) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IExchangeCore.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"../libs/LibOrder.sol\\\";\\n\\n\\nabstract contract IExchangeCore {\\n\\n    // Fill event is emitted whenever an order is filled.\\n    event Fill(\\n        address indexed makerAddress,         // Address that created the order.\\n        address indexed royaltiesAddress,     // Address that received fees.\\n        bytes makerAssetData,                 // Encoded data specific to makerAsset.\\n        bytes takerAssetData,                 // Encoded data specific to takerAsset.\\n        bytes32 indexed orderHash,            // EIP712 hash of order (see LibOrder.getTypedDataHash).\\n        address takerAddress,                 // Address that filled the order.\\n        address senderAddress,                // Address that called the Exchange contract (msg.sender).\\n        uint256 makerAssetAmount,             // Amount of makerAsset sold by maker and bought by taker.\\n        uint256 takerAssetAmount,             // Amount of takerAsset sold by taker and bought by maker.\\n        uint256 royaltiesAmount,              // Amount of royalties paid to royaltiesAddress.\\n        uint256 protocolFeePaid,              // Amount paid to the protocol.\\n        bytes32 marketplaceIdentifier,        // marketplace identifier.\\n        uint256 marketplaceFeePaid            // Amount paid to the marketplace brought the taker.\\n    );\\n\\n    // Cancel event is emitted whenever an individual order is cancelled.\\n    event Cancel(\\n        address indexed makerAddress,         // Address that created the order.\\n        bytes makerAssetData,                 // Encoded data specific to makerAsset.\\n        bytes takerAssetData,                 // Encoded data specific to takerAsset.\\n        address senderAddress,                // Address that called the Exchange contract (msg.sender).\\n        bytes32 indexed orderHash             // EIP712 hash of order (see LibOrder.getTypedDataHash).\\n    );\\n\\n    // CancelUpTo event is emitted whenever `cancelOrdersUpTo` is executed succesfully.\\n    event CancelUpTo(\\n        address indexed makerAddress,         // Orders cancelled must have been created by this address.\\n        uint256 orderEpoch                    // Orders with a salt less than this value are considered cancelled.\\n    );\\n\\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\\n        virtual\\n        external;\\n\\n    /// @dev Fills the input order.\\n    /// @param order Order struct containing order specifications.\\n    /// @param signature Proof that order has been created by maker.\\n    /// @return fulfilled boolean\\n    function fillOrder(\\n        LibOrder.Order memory order,\\n        bytes memory signature,\\n        bytes32 marketIdentifier\\n    )\\n        virtual\\n        external\\n        payable\\n        returns (bool fulfilled);\\n\\n    /// @dev Fills the input order.\\n    /// @param order Order struct containing order specifications.\\n    /// @param signature Proof that order has been created by maker.\\n    /// @param takerAddress address to fulfill the order for / gift.\\n    /// @return fulfilled boolean\\n    function fillOrderFor(\\n        LibOrder.Order memory order,\\n        bytes memory signature,\\n        bytes32 marketIdentifier,\\n        address takerAddress\\n    )\\n        virtual\\n        external\\n        payable\\n        returns (bool fulfilled);\\n\\n    /// @dev After calling, the order can not be filled anymore.\\n    /// @param order Order struct containing order specifications.\\n    function cancelOrder(LibOrder.Order memory order)\\n        virtual\\n        external;\\n\\n    /// @dev Gets information about an order: status, hash, and amount filled.\\n    /// @param order Order to gather information on.\\n    /// @return orderInfo Information about the order and its state.\\n    ///                   See LibOrder.OrderInfo for a complete description.\\n    function getOrderInfo(LibOrder.Order memory order)\\n        virtual\\n        external\\n        view\\n        returns (LibOrder.OrderInfo memory orderInfo);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IAssetProxyRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n\\nabstract contract IAssetProxyRegistry {\\n\\n    // Logs registration of new asset proxy\\n    event AssetProxyRegistered(\\n        bytes4 id,              // Id of new registered AssetProxy.\\n        address assetProxy      // Address of new registered AssetProxy.\\n    );\\n\\n    /// @dev Registers an asset proxy to its asset proxy id.\\n    ///      Once an asset proxy is registered, it cannot be unregistered.\\n    /// @param assetProxy Address of new asset proxy to register.\\n    function registerAssetProxy(address assetProxy)\\n        virtual external;\\n\\n    /// @dev Gets an asset proxy.\\n    /// @param assetProxyId Id of the asset proxy.\\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\\n    function getAssetProxy(bytes4 assetProxyId)\\n        virtual\\n        external\\n        view\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IAssetProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n\\ninterface IAssetProxy {\\n\\n    /// @dev Transfers assets. Either succeeds or throws.\\n    /// @param assetData Byte array encoded for the respective asset proxy.\\n    /// @param from Address to transfer asset from.\\n    /// @param to Address to transfer asset to.\\n    /// @param amount Amount of asset to transfer.\\n    function transferFrom(\\n        bytes calldata assetData,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        external;\\n    \\n    /// @dev Gets the proxy id associated with the proxy address.\\n    /// @return Proxy id.\\n    function getProxyId()\\n        external\\n        pure\\n        returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IAssetData.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n\\n/// @dev Interface of the asset proxy's assetData.\\n// The asset proxies take an ABI encoded `bytes assetData` as argument.\\n// This argument is ABI encoded as one of the methods of this interface.\\ninterface IAssetData {\\n\\n    /// @dev Function signature for encoding ERC20 assetData.\\n    /// @param tokenAddress Address of ERC20Token contract.\\n    function ERC20Token(address tokenAddress)\\n        external;\\n\\n    /// @dev Function signature for encoding ERC721 assetData.\\n    /// @param tokenAddress Address of ERC721 token contract.\\n    /// @param tokenId Id of ERC721 token to be transferred.\\n    function ERC721Token(\\n        address tokenAddress,\\n        uint256 tokenId\\n    )\\n        external;\\n\\n    /// @dev Function signature for encoding ERC1155 assetData.\\n    /// @param tokenAddress Address of ERC1155 token contract.\\n    /// @param tokenIds Array of ids of tokens to be transferred.\\n    /// @param values Array of values that correspond to each token id to be transferred.\\n    ///        Note that each value will be multiplied by the amount being filled in the order before transferring.\\n    /// @param callbackData Extra data to be passed to receiver's `onERC1155Received` callback function.\\n    function ERC1155Assets(\\n        address tokenAddress,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata values,\\n        bytes calldata callbackData\\n    )\\n        external;\\n\\n    /// @dev Function signature for encoding MultiAsset assetData.\\n    /// @param values Array of amounts that correspond to each asset to be transferred.\\n    ///        Note that each value will be multiplied by the amount being filled in the order before transferring.\\n    /// @param nestedAssetData Array of assetData fields that will be be dispatched to their correspnding AssetProxy contract.\\n    function MultiAsset(\\n        uint256[] calldata values,\\n        bytes[] calldata nestedAssetData\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"/contracts/SignatureValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"./libs/LibBytes.sol\\\";\\nimport \\\"./libs/LibOrder.sol\\\";\\nimport \\\"./EIP712Domain.sol\\\";\\nimport \\\"./interfaces/ISignatureValidator.sol\\\";\\n\\n\\nabstract contract SignatureValidator is\\n    LibEIP712ExchangeDomain,\\n    ISignatureValidator\\n{\\n    using LibBytes for bytes;\\n    using LibOrder for LibOrder.Order;\\n\\n    /// @dev Verifies that a hash has been signed by the given signer.\\n    /// @param hash Any 32-byte hash.\\n    /// @param signerAddress Address that should have signed the given hash.\\n    /// @param signature Proof that the hash has been signed by signer.\\n    /// @return isValid `true` if the signature is valid for the given hash and signer.\\n    function isValidHashSignature(\\n        bytes32 hash,\\n        address signerAddress,\\n        bytes memory signature\\n    )\\n        override\\n        public\\n        pure\\n        returns (bool isValid)\\n    {\\n        SignatureType signatureType = _readValidSignatureType(\\n            signerAddress,\\n            signature\\n        );\\n\\n        return _validateHashSignatureTypes(\\n            signatureType,\\n            hash,\\n            signerAddress,\\n            signature\\n        );\\n    }\\n\\n    /// @dev Verifies that a signature for an order is valid.\\n    /// @param order The order.\\n    /// @param signature Proof that the order has been signed by signer.\\n    /// @return isValid `true` if the signature is valid for the given order and signer.\\n    function isValidOrderSignature(\\n        LibOrder.Order memory order,\\n        bytes memory signature\\n    )\\n        override\\n        public\\n        view\\n        returns (bool isValid)\\n    {\\n        bytes32 orderHash = order.getTypedDataHash(DOMAIN_HASH);\\n        isValid = _isValidOrderWithHashSignature(\\n            order,\\n            orderHash,\\n            signature\\n        );\\n        return isValid;\\n    }\\n\\n    /// @dev Verifies that an order, with provided order hash, has been signed\\n    ///      by the given signer.\\n    /// @param order The order.\\n    /// @param orderHash The hash of the order.\\n    /// @param signature Proof that the hash has been signed by signer.\\n    /// @return isValid True if the signature is valid for the given order and signer.\\n    function _isValidOrderWithHashSignature(\\n        LibOrder.Order memory order,\\n        bytes32 orderHash,\\n        bytes memory signature\\n    )\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        address signerAddress = order.makerAddress;\\n        SignatureType signatureType = _readValidSignatureType(\\n            signerAddress,\\n            signature\\n        );\\n        \\n        return _validateHashSignatureTypes(\\n            signatureType,\\n            orderHash,\\n            signerAddress,\\n            signature\\n        );\\n    }\\n\\n    /// Validates a hash-only signature type\\n    /// (anything but `EIP1271Wallet`).\\n    function _validateHashSignatureTypes(\\n        SignatureType signatureType,\\n        bytes32 hash,\\n        address signerAddress,\\n        bytes memory signature\\n    )\\n        private\\n        pure\\n        returns (bool isValid)\\n    {\\n        // invalid signature.\\n        if (signatureType == SignatureType.Invalid) {\\n            if (signature.length != 1) {\\n                revert('SIGNATURE: invalid length');\\n            }\\n            isValid = false;\\n\\n        // Signature using EIP712\\n        } else if (signatureType == SignatureType.EIP712) {\\n            if (signature.length != 66) {\\n                revert('SIGNATURE: invalid length');\\n            }\\n            uint8 v = uint8(signature[0]);\\n            bytes32 r = signature.readBytes32(1);\\n            bytes32 s = signature.readBytes32(33);\\n            address recovered = ecrecover(\\n                hash,\\n                v,\\n                r,\\n                s\\n            );\\n            isValid = signerAddress == recovered;\\n\\n        // Signed using web3.eth_sign\\n        } else if (signatureType == SignatureType.EthSign) {\\n            if (signature.length != 66) {\\n                revert('SIGNATURE: invalid length');\\n            }\\n            uint8 v = uint8(signature[0]);\\n            bytes32 r = signature.readBytes32(1);\\n            bytes32 s = signature.readBytes32(33);\\n            address recovered = ecrecover(\\n                keccak256(abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    hash\\n                )),\\n                v,\\n                r,\\n                s\\n            );\\n            isValid = signerAddress == recovered;\\n        }\\n\\n        return isValid;\\n    }\\n\\n    /// @dev Reads the `SignatureType` from the end of a signature and validates it.\\n    function _readValidSignatureType(\\n        address signerAddress,\\n        bytes memory signature\\n    )\\n        private\\n        pure\\n        returns (SignatureType signatureType)\\n    {\\n        if (signature.length == 0) {\\n            revert('SIGNATURE: invalid length');\\n        }\\n        signatureType = SignatureType(uint8(signature[signature.length - 1]));\\n\\n        // Disallow address zero because ecrecover() returns zero on failure.\\n        if (signerAddress == address(0)) {\\n            revert('SIGNATURE: signerAddress cannot be null');\\n        }\\n\\n        // Ensure signature is supported\\n        if (uint8(signatureType) >= uint8(SignatureType.NSignatureTypes)) {\\n            revert('SIGNATURE: signature not supported');\\n        }\\n\\n        // illegal signature.\\n        if (signatureType == SignatureType.Illegal) {\\n            revert('SIGNATURE: illegal signature');\\n        }\\n\\n        return signatureType;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Refundable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\ncontract Refundable\\n{\\n\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier refundFinalBalanceNoReentry {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        _refundNonZeroBalance();\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function _refundNonZeroBalance()\\n        internal\\n    {\\n        uint256 balance = address(this).balance;\\n        if (balance > 0) {\\n            payable(msg.sender).transfer(balance);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ProtocolFees.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IProtocolFees.sol\\\";\\n\\n\\ncontract ProtocolFees is\\n    IProtocolFees,\\n    Ownable\\n{\\n    /// @dev The protocol fee multiplier -- the owner can update this field.\\n    /// @return 0 Gas multplier.\\n    uint256 public protocolFeeMultiplier;\\n\\n    /// @dev The protocol fixed fee multiplier -- the owner can update this field.\\n    /// @return 0 fixed fee.\\n    uint256 public protocolFixedFee;\\n\\n    /// @dev The address of the registered protocolFeeCollector contract -- the owner can update this field.\\n    /// @return 0 Contract to forward protocol fees to.\\n    address public protocolFeeCollector;\\n\\n    /// @dev Allows the owner to update the protocol fee multiplier.\\n    /// @param updatedProtocolFeeMultiplier The updated protocol fee multiplier.\\n    function setProtocolFeeMultiplier(uint256 updatedProtocolFeeMultiplier)\\n        override\\n        external\\n        onlyOwner\\n    {\\n        emit ProtocolFeeMultiplier(protocolFeeMultiplier, updatedProtocolFeeMultiplier);\\n        protocolFeeMultiplier = updatedProtocolFeeMultiplier;\\n    }\\n\\n    /// @dev Allows the owner to update the protocol fixed fee.\\n    /// @param updatedProtocolFixedFee The updated protocol fixed fee.\\n    function setProtocolFixedFee(uint256 updatedProtocolFixedFee)\\n        override\\n        external\\n        onlyOwner\\n    {\\n        emit ProtocolFixedFee(protocolFixedFee, updatedProtocolFixedFee);\\n        protocolFixedFee = updatedProtocolFixedFee;\\n    }\\n\\n    /// @dev Allows the owner to update the protocolFeeCollector address.\\n    /// @param updatedProtocolFeeCollector The updated protocolFeeCollector contract address.\\n    function setProtocolFeeCollectorAddress(address updatedProtocolFeeCollector)\\n        override\\n        external\\n        onlyOwner\\n    {\\n        emit ProtocolFeeCollectorAddress(protocolFeeCollector, updatedProtocolFeeCollector);\\n        protocolFeeCollector = updatedProtocolFeeCollector;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/MarketplaceRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract MarketplaceRegistry is Ownable {\\n    struct Marketplace {\\n        uint256 feeMultiplier;\\n        address feeCollector;\\n        bool isActive;\\n    }\\n\\n    event MarketplaceRegister(bytes32 identifier, uint256 feeMultiplier, address feeCollector);\\n    event MarketplaceUpdateStatus(bytes32 identifier, bool status);\\n    event MarketplaceSetFees(bytes32 identifier, uint256 feeMultiplier, address feeCollector);\\n\\n    bool public distributeMarketplaceFees = true;\\n\\n    mapping(bytes32 => Marketplace) marketplaces;\\n\\n    function marketplaceDistribution(bool _distributeMarketplaceFees)\\n        external\\n        onlyOwner\\n    {\\n        distributeMarketplaceFees = _distributeMarketplaceFees;\\n    }\\n\\n    function registerMarketplace(bytes32 identifier, uint256 feeMultiplier, address feeCollector) external onlyOwner {\\n        require(feeMultiplier <= 100, \\\"fee multiplier must be betwen 0 to 100\\\");\\n        marketplaces[identifier] = Marketplace(feeMultiplier, feeCollector, true);\\n        emit MarketplaceRegister(identifier, feeMultiplier, feeCollector);\\n    }\\n\\n    function setMarketplaceStatus(bytes32 identifier, bool isActive)\\n        external\\n        onlyOwner\\n    {\\n        marketplaces[identifier].isActive = isActive;\\n        emit MarketplaceUpdateStatus(identifier, isActive);\\n    }\\n\\n    function setMarketplaceFees(\\n        bytes32 identifier,\\n        uint256 feeMultiplier,\\n        address feeCollector\\n    ) external onlyOwner {\\n        require(feeMultiplier <= 100, \\\"fee multiplier must be betwen 0 to 100\\\");\\n        marketplaces[identifier].feeMultiplier = feeMultiplier;\\n        marketplaces[identifier].feeCollector = feeCollector;\\n        emit MarketplaceSetFees(identifier, feeMultiplier, feeCollector);\\n    }\\n}\"\r\n    },\r\n    \"/contracts/ExchangeCore.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./libs/LibBytes.sol\\\";\\nimport \\\"./libs/LibOrder.sol\\\";\\nimport \\\"./interfaces/IExchangeCore.sol\\\";\\nimport \\\"./interfaces/IAssetData.sol\\\";\\nimport \\\"./AssetProxyRegistry.sol\\\";\\nimport \\\"./EIP712Domain.sol\\\";\\nimport \\\"./ProtocolFees.sol\\\";\\nimport \\\"./SignatureValidator.sol\\\";\\nimport \\\"./MarketplaceRegistry.sol\\\";\\n\\nabstract contract ExchangeCore is\\n    IExchangeCore,\\n    AssetProxyRegistry,\\n    ProtocolFees,\\n    SignatureValidator,\\n    MarketplaceRegistry\\n{\\n    using LibOrder for LibOrder.Order;\\n    using SafeMath for uint256;\\n    using LibBytes for bytes;\\n\\n    /// @dev orderHash => filled\\n    /// @return boolean the order has been filled\\n    mapping (bytes32 => bool) public filled;\\n\\n    /// @dev orderHash => cancelled\\n    /// @return boolean the order has been cancelled\\n    mapping (bytes32 => bool) public cancelled;\\n\\n    /// @dev makerAddress => lowest salt an order can have in order to be fillable\\n    /// @return epoc Orders with a salt less than their epoch are considered cancelled\\n    mapping (address => uint256) public orderEpoch;\\n\\n    /// @dev Fills the input order.\\n    /// @param order Order struct containing order specifications.\\n    /// @param signature Proof that order has been created by maker.\\n    /// @param takerAddress orider fill for the taker.\\n    /// @return fulfilled boolean\\n    function _fillOrder(\\n        LibOrder.Order memory order,\\n        bytes memory signature,\\n        address takerAddress,\\n        bytes32 marketplaceIdentifier\\n    )\\n        internal\\n        returns (bool fulfilled)\\n    {\\n        // Fetch order info\\n        LibOrder.OrderInfo memory orderInfo = _getOrderInfo(order);\\n\\n        // Assert that the order is fillable by taker\\n        _assertFillable(\\n            order,\\n            orderInfo,\\n            takerAddress,\\n            signature\\n        );\\n\\n        bytes32 orderHash = orderInfo.orderHash;\\n\\n        // Update state\\n        filled[orderHash] = true;\\n\\n        Marketplace memory marketplace = marketplaces[marketplaceIdentifier];\\n\\n        // Settle order\\n        (uint256 protocolFee, uint256 marketplaceFee) = _settle(\\n            orderInfo,\\n            order,\\n            takerAddress,\\n            marketplace\\n        );\\n\\n        _notifyFill(order, orderHash, takerAddress, protocolFee, marketplaceIdentifier, marketplaceFee);\\n\\n        return filled[orderHash];\\n    }\\n\\n    function _notifyFill(\\n        LibOrder.Order memory order,\\n        bytes32 orderHash,\\n        address takerAddress,\\n        uint256 protocolFee,\\n        bytes32 marketplaceIdentifier,\\n        uint256 marketplaceFee\\n    ) internal {\\n        emit Fill(\\n            order.makerAddress,\\n            order.royaltiesAddress,\\n            order.makerAssetData,\\n            order.takerAssetData,\\n            orderHash,\\n            takerAddress,\\n            msg.sender,\\n            order.makerAssetAmount,\\n            order.takerAssetAmount,\\n            order.royaltiesAmount,\\n            protocolFee,\\n            marketplaceIdentifier,\\n            marketplaceFee\\n        );\\n    }\\n\\n    /// @dev After calling, the order can not be filled anymore.\\n    ///      Throws if order is invalid or sender does not have permission to cancel.\\n    /// @param order Order to cancel. Order must be OrderStatus.FILLABLE.\\n    function _cancelOrder(LibOrder.Order memory order)\\n        internal\\n    {\\n        // Fetch current order status\\n        LibOrder.OrderInfo memory orderInfo = _getOrderInfo(order);\\n\\n        // Validate context\\n        _assertValidCancel(order);\\n\\n        // Noop if order is already unfillable\\n        if (orderInfo.orderStatus != LibOrder.OrderStatus.FILLABLE) {\\n            return;\\n        }\\n\\n        // Perform cancel\\n        _updateCancelledState(order, orderInfo.orderHash);\\n    }\\n\\n    /// @dev Updates state with results of cancelling an order.\\n    ///      State is only updated if the order is currently fillable.\\n    ///      Otherwise, updating state would have no effect.\\n    /// @param order that was cancelled.\\n    /// @param orderHash Hash of order that was cancelled.\\n    function _updateCancelledState(\\n        LibOrder.Order memory order,\\n        bytes32 orderHash\\n    )\\n        internal\\n    {\\n        // Perform cancel\\n        cancelled[orderHash] = true;\\n\\n        // Log cancel\\n        emit Cancel(\\n            order.makerAddress,\\n            order.makerAssetData,\\n            order.takerAssetData,\\n            msg.sender,\\n            orderHash\\n        );\\n    }\\n\\n    /// @dev Validates context for fillOrder. Succeeds or throws.\\n    /// @param order to be filled.\\n    /// @param orderInfo OrderStatus, orderHash, and amount already filled of order.\\n    /// @param takerAddress Address of order taker.\\n    /// @param signature Proof that the orders was created by its maker.\\n    function _assertFillable(\\n        LibOrder.Order memory order,\\n        LibOrder.OrderInfo memory orderInfo,\\n        address takerAddress,\\n        bytes memory signature\\n    )\\n        internal\\n    {\\n        if (orderInfo.orderType == LibOrder.OrderType.INVALID) {\\n            revert('EXCHANGE: type illegal');\\n        }\\n\\n        if (orderInfo.orderType == LibOrder.OrderType.LIST) {\\n            address erc20TokenAddress = order.takerAssetData.readAddress(4);\\n            if (erc20TokenAddress == address(0) && msg.value < order.takerAssetAmount) {\\n                revert('EXCHANGE: wrong value sent');\\n            }\\n        }\\n\\n        if (orderInfo.orderType != LibOrder.OrderType.LIST && takerAddress != msg.sender) {\\n            revert('EXCHANGE: fill order for is only valid for buy now');\\n        }\\n\\n        if (orderInfo.orderType == LibOrder.OrderType.SWAP) {\\n            if (msg.value < protocolFixedFee) {\\n                revert('EXCHANGE: wrong value sent');\\n            }\\n        }\\n\\n        // An order can only be filled if its status is FILLABLE.\\n        if (orderInfo.orderStatus != LibOrder.OrderStatus.FILLABLE) {\\n            revert('EXCHANGE: status not fillable');\\n        }\\n\\n        // Validate sender is allowed to fill this order\\n        if (order.senderAddress != address(0)) {\\n            if (order.senderAddress != msg.sender) {\\n                revert('EXCHANGE: invalid sender');\\n            }\\n        }\\n\\n        // Validate taker is allowed to fill this order\\n        if (order.takerAddress != address(0)) {\\n            if (order.takerAddress != takerAddress) {\\n                revert('EXCHANGE: invalid taker');\\n            }\\n        }\\n\\n        // Validate signature\\n        if (!_isValidOrderWithHashSignature(\\n                order,\\n                orderInfo.orderHash,\\n                signature\\n            )\\n        ) {\\n            revert('EXCHANGE: invalid signature');\\n        }\\n    }\\n\\n    /// @dev Validates context for cancelOrder. Succeeds or throws.\\n    /// @param order to be cancelled.\\n    function _assertValidCancel(\\n        LibOrder.Order memory order\\n    )\\n        internal\\n        view\\n    {\\n        // Validate sender is allowed to cancel this order\\n        if (order.senderAddress != address(0)) {\\n            if (order.senderAddress != msg.sender) {\\n                revert('EXCHANGE: invalid sender');\\n            }\\n        }\\n\\n        // Validate transaction signed by maker\\n        address makerAddress = msg.sender;\\n        if (order.makerAddress != makerAddress) {\\n            revert('EXCHANGE: invalid maker');\\n        }\\n    }\\n\\n    /// @dev Gets information about an order: status, hash, and amount filled.\\n    /// @param order Order to gather information on.\\n    /// @return orderInfo Information about the order and its state.\\n    ///         See LibOrder.OrderInfo for a complete description.\\n    function _getOrderInfo(LibOrder.Order memory order)\\n        internal\\n        view\\n        returns (LibOrder.OrderInfo memory orderInfo)\\n    {\\n        // Compute the order hash\\n        orderInfo.orderHash = order.getTypedDataHash(DOMAIN_HASH);\\n\\n        bool isTakerAssetDataERC20 = _isERC20Proxy(order.takerAssetData);\\n        bool isMakerAssetDataERC20 = _isERC20Proxy(order.makerAssetData);\\n\\n        if (isTakerAssetDataERC20 && !isMakerAssetDataERC20) {\\n            orderInfo.orderType = LibOrder.OrderType.LIST;\\n        } else if (!isTakerAssetDataERC20 && isMakerAssetDataERC20) {\\n            orderInfo.orderType = LibOrder.OrderType.OFFER;\\n        } else if (!isTakerAssetDataERC20 && !isMakerAssetDataERC20) {\\n            orderInfo.orderType = LibOrder.OrderType.SWAP;\\n        } else {\\n            orderInfo.orderType = LibOrder.OrderType.INVALID;\\n        }\\n\\n        // If order.makerAssetAmount is zero the order is invalid\\n        if (order.makerAssetAmount == 0) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_MAKER_ASSET_AMOUNT;\\n            return orderInfo;\\n        }\\n\\n        // If order.takerAssetAmount is zero the order is invalid\\n        if (order.takerAssetAmount == 0) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_TAKER_ASSET_AMOUNT;\\n            return orderInfo;\\n        }\\n\\n        if (orderInfo.orderType == LibOrder.OrderType.LIST && order.royaltiesAmount > order.takerAssetAmount) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_ROYALTIES;\\n            return orderInfo;\\n        }\\n\\n        if (orderInfo.orderType == LibOrder.OrderType.OFFER && order.royaltiesAmount > order.makerAssetAmount) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.INVALID_ROYALTIES;\\n            return orderInfo;\\n        }\\n\\n        // Check if order has been filled\\n        if (filled[orderInfo.orderHash]) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.FILLED;\\n            return orderInfo;\\n        }\\n\\n        // Check if order has been cancelled\\n        if (cancelled[orderInfo.orderHash]) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.CANCELLED;\\n            return orderInfo;\\n        }\\n\\n        if (orderEpoch[order.makerAddress] > order.salt) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.CANCELLED;\\n            return orderInfo;\\n        }\\n\\n        // Validate order expiration\\n        if (block.timestamp >= order.expirationTimeSeconds) {\\n            orderInfo.orderStatus = LibOrder.OrderStatus.EXPIRED;\\n            return orderInfo;\\n        }\\n\\n        // All other statuses are ruled out: order is Fillable\\n        orderInfo.orderStatus = LibOrder.OrderStatus.FILLABLE;\\n        return orderInfo;\\n    }\\n\\n\\n    /// @dev Settles an order by transferring assets between counterparties.\\n    /// @param orderInfo The order info struct.\\n    /// @param order Order struct containing order specifications.\\n    /// @param takerAddress Address selling takerAsset and buying makerAsset.\\n    function _settle(\\n        LibOrder.OrderInfo memory orderInfo,\\n        LibOrder.Order memory order,\\n        address takerAddress,\\n        Marketplace memory marketplace\\n    )\\n        internal\\n        returns (uint256 protocolFee, uint256 marketplaceFee)\\n    {\\n        bytes memory payerAssetData;\\n        bytes memory sellerAssetData;\\n        address payerAddress;\\n        address sellerAddress;\\n        uint256 buyerPayment;\\n        uint256 sellerAmount;\\n\\n        if (orderInfo.orderType == LibOrder.OrderType.LIST) {\\n            payerAssetData = order.takerAssetData;\\n            sellerAssetData = order.makerAssetData;\\n            payerAddress = msg.sender;\\n            sellerAddress = order.makerAddress;\\n            buyerPayment = order.takerAssetAmount;\\n            sellerAmount = order.makerAssetAmount;\\n        }\\n\\n        if (orderInfo.orderType == LibOrder.OrderType.OFFER || orderInfo.orderType == LibOrder.OrderType.SWAP) {\\n            payerAssetData = order.makerAssetData;\\n            sellerAssetData = order.takerAssetData;\\n            payerAddress = order.makerAddress;\\n            sellerAddress = msg.sender;\\n            takerAddress = payerAddress;\\n            buyerPayment = order.makerAssetAmount;\\n            sellerAmount = order.takerAssetAmount;\\n        }\\n\\n\\n        // pay protocol fees\\n        if (protocolFeeCollector != address(0)) {\\n            bytes memory protocolAssetData = payerAssetData;\\n            if (orderInfo.orderType == LibOrder.OrderType.SWAP && protocolFixedFee > 0) {\\n                protocolFee = protocolFixedFee;\\n                protocolAssetData = abi.encodeWithSelector(IAssetData(address(0)).ERC20Token.selector, address(0));\\n            } else if (protocolFeeMultiplier > 0) {\\n                protocolFee = buyerPayment.mul(protocolFeeMultiplier).div(1000); // 10 times the fee to support decimals - 20 -> 2%\\n                buyerPayment = buyerPayment.sub(protocolFee);\\n            }\\n\\n            if (marketplace.isActive && marketplace.feeCollector != address(0) && marketplace.feeMultiplier > 0 && distributeMarketplaceFees) {\\n                marketplaceFee = protocolFee.mul(marketplace.feeMultiplier).div(100);\\n                protocolFee = protocolFee.sub(marketplaceFee);\\n                _dispatchTransfer(\\n                    protocolAssetData,\\n                    payerAddress,\\n                    marketplace.feeCollector,\\n                    marketplaceFee\\n                );\\n            }\\n\\n            _dispatchTransfer(\\n                protocolAssetData,\\n                payerAddress,\\n                protocolFeeCollector,\\n                protocolFee\\n            );\\n        }\\n\\n        // pay royalties\\n        if (order.royaltiesAddress != address(0) && order.royaltiesAmount > 0 ) {\\n            buyerPayment = buyerPayment.sub(order.royaltiesAmount);\\n            _dispatchTransfer(\\n                payerAssetData,\\n                payerAddress,\\n                order.royaltiesAddress,\\n                order.royaltiesAmount\\n            );\\n        }\\n\\n        // pay seller // erc20\\n        _dispatchTransfer(\\n            payerAssetData,\\n            payerAddress,\\n            sellerAddress,\\n            buyerPayment\\n        );\\n\\n        // Transfer seller -> buyer (nft / bundle)\\n        _dispatchTransfer(\\n            sellerAssetData,\\n            sellerAddress,\\n            takerAddress,\\n            sellerAmount\\n        );\\n\\n        return (protocolFee, marketplaceFee);\\n      \\n    }\\n}\"\r\n    },\r\n    \"/contracts/EIP712Domain.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"./libs/LibEIP712.sol\\\";\\n\\n\\ncontract LibEIP712ExchangeDomain {\\n\\n    // EIP712 Exchange Domain Name value\\n    string constant internal DOMAIN_NAME = \\\"Nifty Exchange\\\";\\n\\n    // EIP712 Exchange Domain Version value\\n    string constant internal DOMAIN_VERSION = \\\"2.0\\\";\\n\\n    // solhint-disable var-name-mixedcase\\n    /// @dev Hash of the EIP712 Domain Separator data\\n    /// @return 0 Domain hash.\\n    bytes32 public DOMAIN_HASH;\\n    // solhint-enable var-name-mixedcase\\n\\n    /// @param chainId Chain ID of the network this contract is deployed on.\\n    constructor (\\n        uint256 chainId\\n    )\\n    {\\n        DOMAIN_HASH = LibEIP712.hashDomain(\\n            DOMAIN_NAME,\\n            DOMAIN_VERSION,\\n            chainId,\\n            address(this)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/AssetProxyRegistry.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./libs/LibBytes.sol\\\";\\nimport \\\"./interfaces/IAssetData.sol\\\";\\nimport \\\"./interfaces/IAssetProxy.sol\\\";\\nimport \\\"./interfaces/IAssetProxyRegistry.sol\\\";\\n\\n\\ncontract AssetProxyRegistry is\\n    Ownable,\\n    IAssetProxyRegistry\\n{\\n    using LibBytes for bytes;\\n\\n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\\n    mapping (bytes4 => address) internal _assetProxies;\\n\\n    /// @dev Registers an asset proxy to its asset proxy id.\\n    /// @param assetProxy Address of new asset proxy to register.\\n    function registerAssetProxy(address assetProxy)\\n        override\\n        external\\n        onlyOwner\\n    {\\n        // Ensure that no asset proxy exists with current id.\\n        bytes4 assetProxyId = IAssetProxy(assetProxy).getProxyId();\\n        // Add asset proxy and log registration.\\n        _assetProxies[assetProxyId] = assetProxy;\\n        emit AssetProxyRegistered(\\n            assetProxyId,\\n            assetProxy\\n        );\\n    }\\n\\n    /// @dev Gets an asset proxy.\\n    /// @param assetProxyId Id of the asset proxy.\\n    /// @return assetProxy The asset proxy address registered to assetProxyId. Returns 0x0 if no proxy is registered.\\n    function getAssetProxy(bytes4 assetProxyId)\\n        override\\n        external\\n        view\\n        returns (address assetProxy)\\n    {\\n        return _assetProxies[assetProxyId];\\n    }\\n\\n    function _isERC20Proxy(bytes memory assetData)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bytes4 assetProxyId = assetData.readBytes4(0);\\n        bytes4 erc20ProxyId = IAssetData(address(0)).ERC20Token.selector;\\n\\n        return assetProxyId == erc20ProxyId;\\n    }\\n\\n    /// @dev Forwards arguments to assetProxy and calls `transferFrom`. Either succeeds or throws.\\n    /// @param assetData Byte array encoded for the asset.\\n    /// @param from Address to transfer token from.\\n    /// @param to Address to transfer token to.\\n    /// @param amount Amount of token to transfer.\\n    function _dispatchTransfer(\\n        bytes memory assetData,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        // Do nothing if no amount should be transferred.\\n        if (amount > 0) {\\n\\n            // Ensure assetData is padded to 32 bytes (excluding the id) and is at least 4 bytes long\\n            if (assetData.length % 32 != 4) {\\n                revert('ASSET PROXY: invalid length');\\n            }\\n\\n            // Lookup assetProxy.\\n            bytes4 assetProxyId = assetData.readBytes4(0);\\n            address assetProxy = _assetProxies[assetProxyId];\\n\\n            // Ensure that assetProxy exists\\n            if (assetProxy == address(0)) {\\n                revert('ASSET PROXY: unknown');\\n            }\\n\\n            bool ethPayment = false;\\n\\n            if (assetProxyId == IAssetData(address(0)).ERC20Token.selector) {\\n                address erc20TokenAddress = assetData.readAddress(4);\\n                ethPayment = erc20TokenAddress == address(0);\\n            }\\n\\n            if (ethPayment) {\\n                if (address(this).balance < amount) {\\n                    revert(\\\"ASSET PROXY: insufficient balance\\\");\\n                }\\n                (bool success, ) = to.call{value: amount}(\\\"\\\");\\n                require(success, \\\"ASSET PROXY: eth transfer failed\\\");\\n            } else {\\n                // Construct the calldata for the transferFrom call.\\n                bytes memory proxyCalldata = abi.encodeWithSelector(\\n                    IAssetProxy(address(0)).transferFrom.selector,\\n                    assetData,\\n                    from,\\n                    to,\\n                    amount\\n                );\\n\\n                // Call the asset proxy's transferFrom function with the constructed calldata.\\n                (bool didSucceed, ) = assetProxy.call(proxyCalldata);\\n\\n                // If the transaction did not succeed, revert with the returned data.\\n                if (!didSucceed) {\\n                    revert(\\\"ASSET PROXY: transfer failed\\\");\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetProxy\",\"type\":\"address\"}],\"name\":\"AssetProxyRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderEpoch\",\"type\":\"uint256\"}],\"name\":\"CancelUpTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeePaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"marketplaceIdentifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketplaceFeePaid\",\"type\":\"uint256\"}],\"name\":\"Fill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"MarketplaceRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"MarketplaceSetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"MarketplaceUpdateStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldProtocolFeeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"updatedProtocolFeeCollector\",\"type\":\"address\"}],\"name\":\"ProtocolFeeCollectorAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProtocolFeeMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedProtocolFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeMultiplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProtocolFixedFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedProtocolFixedFee\",\"type\":\"uint256\"}],\"name\":\"ProtocolFixedFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetOrderEpoch\",\"type\":\"uint256\"}],\"name\":\"cancelOrdersUpTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeMarketplaceFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"marketplaceIdentifier\",\"type\":\"bytes32\"}],\"name\":\"fillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"marketplaceIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"}],\"name\":\"fillOrderFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"filled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"assetProxyId\",\"type\":\"bytes4\"}],\"name\":\"getAssetProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"assetProxy\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"getOrderInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"enum LibOrder.OrderStatus\",\"name\":\"orderStatus\",\"type\":\"uint8\"},{\"internalType\":\"enum LibOrder.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"filled\",\"type\":\"bool\"}],\"internalType\":\"struct LibOrder.OrderInfo\",\"name\":\"orderInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidHashSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"takerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltiesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"senderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"takerAssetData\",\"type\":\"bytes\"}],\"internalType\":\"struct LibOrder.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidOrderSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_distributeMarketplaceFees\",\"type\":\"bool\"}],\"name\":\"marketplaceDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"orderEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFixedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetProxy\",\"type\":\"address\"}],\"name\":\"registerAssetProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"feeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"registerMarketplace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnAllETHToOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"}],\"name\":\"returnERC20ToOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"feeMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"setMarketplaceFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"identifier\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"setMarketplaceStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updatedProtocolFeeCollector\",\"type\":\"address\"}],\"name\":\"setProtocolFeeCollectorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedProtocolFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setProtocolFeeMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedProtocolFixedFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFixedFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NiftyProtocol", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000038", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}