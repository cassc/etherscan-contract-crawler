{"SourceCode": "{\"address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"EARTHfarm.sol\":{\"content\":\"/* \\r\\n      ,c::;;;:;.                   ;l\\u0027                  .::;:::::,.              \\u0027;;;:cc;;:,.            .,.        ,.                                             \\r\\n     .dl.......                   :dod\\u0027                 ;x;....\\u0027\\u0027:o;             ....;xl....             \\u0027d,       .d;                                             \\r\\n     .o:                         \\u0027d, lo.                ;d.       ,d.                .o;                 \\u0027d,       .d;                                             \\r\\n     .dl......                  .oc  .dc                ;d.      .cl.                .o;                 \\u0027d;       \\u0027d;                                             \\r\\n     .dd;;;;;;.                 lo.   \\u0027d,               ;kl;:cc::c;.                 .o;                 \\u0027xo,;;;;;,ck;                                             \\r\\n     .o:                       :d.     :d.              ;x;..:xkc                    .o;                 \\u0027d,       .d;                                             \\r\\n     .o:                      \\u0027d;       lo.             ;d.   \\u0027col.                  .o;                 \\u0027d,       .d;                                             \\r\\n     .do\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027.             .oc        .o:             ;d.     .cd,                 .o;                 \\u0027d,       .d;                                             \\r\\n      \\u0027;;;;;;;,.              .          ..             ..        ..                  ..                 ...        ..         \\r\\n      \\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.4;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./ownable.sol\\\";\\r\\nimport \\\"./EARTHtoken.sol\\\";\\r\\n\\r\\ncontract EARTHFarm is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    // Info of each user.\\r\\n    struct UserInfo {\\r\\n        uint256 amount; // How many LP tokens the user has provided.\\r\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\r\\n        //\\r\\n        // We do some fancy math here. Basically, any point in time, the amount of EARTH tokens\\r\\n        // entitled to a user but is pending to be distributed is:\\r\\n        //\\r\\n        //   pending reward = (user.amount * pool.accWorldPerShare) - user.rewardDebt\\r\\n        //\\r\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here\\u0027s what happens:\\r\\n        //   1. The pool\\u0027s `accWorldPerShare` (and `lastRewardBlock`) gets updated.\\r\\n        //   2. User receives the pending reward sent to his/her address.\\r\\n        //   3. User\\u0027s `amount` gets updated.\\r\\n        //   4. User\\u0027s `rewardDebt` gets updated.\\r\\n    }\\r\\n\\r\\n    // Info of each pool.\\r\\n    struct PoolInfo {\\r\\n        IERC20 lpToken; // Address of LP token contract.\\r\\n        uint256 allocPoint; // How many allocation points assigned to this pool. WORLD tokens to distribute per block.\\r\\n        uint256 lastRewardBlock; // Last block number that WORLD tokens distribution occurs.\\r\\n        uint256 accWorldPerShare; // Accumulated WORLD tokens per share, times 1e12. See below.\\r\\n    }\\r\\n\\r\\n    EARTHToken public immutable world; // The WORLD ERC-20 Token.\\r\\n    uint256 private worldPerBlock; // WORLD tokens distributed per block. Use getWorldPerBlock() to get the updated reward.\\r\\n\\r\\n    PoolInfo[] public poolInfo; // Info of each pool.\\r\\n    mapping(uint256 =\\u003e mapping(address =\\u003e UserInfo)) public userInfo; // Info of each user that stakes LP tokens.\\r\\n    uint256 public totalAllocPoint; // Total allocation points. Must be the sum of all allocation points in all pools.\\r\\n    uint256 public startBlock; // The block number when WORLD token mining starts.\\r\\n\\r\\n    uint256 public blockRewardUpdateCycle = 1 days; // The cycle in which the worldPerBlock gets updated.\\r\\n    uint256 public blockRewardLastUpdateTime = block.timestamp; // The timestamp when the block worldPerBlock was last updated.\\r\\n    uint256 public blocksPerDay = 28800; // The estimated number of mined blocks per day.\\r\\n    uint256 public blockRewardPercentage = 5; // The percentage used for worldPerBlock calculation.\\r\\n\\r\\n    mapping(address =\\u003e bool) public addedLpTokens; // Used for preventing LP tokens from being added twice in add().\\r\\n\\r\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\r\\n\\r\\n    constructor(\\r\\n        EARTHToken _world,\\r\\n        uint256 _startBlock\\r\\n    ) {\\r\\n        require(address(_world) != address(0), \\\"WORLD address is invalid\\\");\\r\\n        require(_startBlock \\u003e= block.number, \\\"startBlock is before current block\\\");\\r\\n\\r\\n        world = _world;\\r\\n        startBlock = _startBlock;\\r\\n    }\\r\\n\\r\\n    modifier updateWorldPerBlock() {\\r\\n        (uint256 blockReward, bool update) = getWorldPerBlock();\\r\\n        if (update) {\\r\\n            worldPerBlock = blockReward;\\r\\n            blockRewardLastUpdateTime = block.timestamp;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getWorldPerBlock() public view returns (uint256, bool) {\\r\\n        if (block.number \\u003c startBlock) {\\r\\n            return (0, false);\\r\\n        }\\r\\n\\r\\n        uint256 poolReward = world.balanceOf(address(this));\\r\\n        if (poolReward == 0) {\\r\\n            return (0, worldPerBlock != 0);\\r\\n        }\\r\\n\\r\\n        if (block.timestamp \\u003e= getWorldPerBlockUpdateTime() || worldPerBlock == 0) {\\r\\n            return (poolReward.mul(blockRewardPercentage).div(100).div(blocksPerDay), true);\\r\\n        }\\r\\n\\r\\n        return (worldPerBlock, false);\\r\\n    }\\r\\n\\r\\n    function getWorldPerBlockUpdateTime() public view returns (uint256) {\\r\\n        // if blockRewardUpdateCycle = 1 day then roundedUpdateTime = today\\u0027s UTC midnight\\r\\n        uint256 roundedUpdateTime = blockRewardLastUpdateTime - (blockRewardLastUpdateTime % blockRewardUpdateCycle);\\r\\n        // if blockRewardUpdateCycle = 1 day then calculateRewardTime = tomorrow\\u0027s UTC midnight\\r\\n        uint256 calculateRewardTime = roundedUpdateTime + blockRewardUpdateCycle;\\r\\n        return calculateRewardTime;\\r\\n    }\\r\\n\\r\\n    function poolLength() external view returns (uint256) {\\r\\n        return poolInfo.length;\\r\\n    }\\r\\n\\r\\n    // Add a new lp to the pool. Can only be called by the owner.\\r\\n    function add(\\r\\n        uint256 _allocPoint,\\r\\n        IERC20 _lpToken,\\r\\n        bool _withUpdate\\r\\n    ) public onlyOwner {\\r\\n        require(address(_lpToken) != address(0), \\\"LP token is invalid\\\");\\r\\n        require(!addedLpTokens[address(_lpToken)], \\\"LP token is already added\\\");\\r\\n\\r\\n        require(_allocPoint \\u003e= 5 \\u0026\\u0026 _allocPoint \\u003c= 10, \\\"_allocPoint is outside of range 5-10\\\");\\r\\n\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n        uint256 lastRewardBlock = block.number \\u003e startBlock ? block.number : startBlock;\\r\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\r\\n        poolInfo.push(PoolInfo({\\r\\n            lpToken : _lpToken,\\r\\n            allocPoint : _allocPoint,\\r\\n            lastRewardBlock : lastRewardBlock,\\r\\n            accWorldPerShare : 0\\r\\n        }));\\r\\n\\r\\n        addedLpTokens[address(_lpToken)] = true;\\r\\n    }\\r\\n\\r\\n    // Update the given pool\\u0027s WORLD token allocation point. Can only be called by the owner.\\r\\n    function set(\\r\\n        uint256 _pid,\\r\\n        uint256 _allocPoint,\\r\\n        bool _withUpdate\\r\\n    ) public onlyOwner {\\r\\n        require(_allocPoint \\u003e= 5 \\u0026\\u0026 _allocPoint \\u003c= 10, \\\"_allocPoint is outside of range 5-10\\\");\\r\\n\\r\\n        if (_withUpdate) {\\r\\n            massUpdatePools();\\r\\n        }\\r\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\r\\n        poolInfo[_pid].allocPoint = _allocPoint;\\r\\n    }\\r\\n\\r\\n    // View function to see pending WORLD tokens on frontend.\\r\\n    function pendingRewards(uint256 _pid, address _user) external view returns (uint256) {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][_user];\\r\\n        uint256 accWorldPerShare = pool.accWorldPerShare;\\r\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\r\\n        if (block.number \\u003e pool.lastRewardBlock \\u0026\\u0026 lpSupply != 0) {\\r\\n            uint256 multiplier = block.number.sub(pool.lastRewardBlock);\\r\\n            (uint256 blockReward, ) = getWorldPerBlock();\\r\\n            uint256 worldReward = multiplier.mul(blockReward).mul(pool.allocPoint).div(totalAllocPoint);\\r\\n            accWorldPerShare = accWorldPerShare.add(worldReward.mul(1e12).div(lpSupply));\\r\\n        }\\r\\n        return user.amount.mul(accWorldPerShare).div(1e12).sub(user.rewardDebt);\\r\\n    }\\r\\n\\r\\n    // Update reward variables for all pools. Be careful of gas spending!\\r\\n    function massUpdatePools() public {\\r\\n        uint256 length = poolInfo.length;\\r\\n        for (uint256 pid = 0; pid \\u003c length; ++pid) {\\r\\n            updatePool(pid);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Update reward variables of the given pool to be up-to-date when lpSupply changes\\r\\n    // For every deposit/withdraw pool recalculates accumulated token value\\r\\n    function updatePool(uint256 _pid) public updateWorldPerBlock {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        if (block.number \\u003c= pool.lastRewardBlock) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\r\\n        if (lpSupply == 0) {\\r\\n            pool.lastRewardBlock = block.number;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 multiplier = block.number.sub(pool.lastRewardBlock);\\r\\n        uint256 worldReward = multiplier.mul(worldPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\r\\n\\r\\n        // no minting is required, the contract should have WORLD token balance pre-allocated\\r\\n        // accumulated WORLD per share is stored multiplied by 10^12 to allow small \\u0027fractional\\u0027 values\\r\\n        pool.accWorldPerShare = pool.accWorldPerShare.add(worldReward.mul(1e12).div(lpSupply));\\r\\n        pool.lastRewardBlock = block.number;\\r\\n    }\\r\\n\\r\\n    // Deposit LP tokens to WorldFarming for WORLD token allocation.\\r\\n    function deposit(uint256 _pid, uint256 _amount) public {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n\\r\\n        updatePool(_pid);\\r\\n\\r\\n        if (user.amount \\u003e 0) {\\r\\n            uint256 pending = user.amount.mul(pool.accWorldPerShare).div(1e12).sub(user.rewardDebt);\\r\\n            if (pending \\u003e 0) {\\r\\n                safeTokenTransfer(msg.sender, pending);\\r\\n            }\\r\\n        }\\r\\n        if (_amount \\u003e 0) {\\r\\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\r\\n            user.amount = user.amount.add(_amount);\\r\\n        }\\r\\n        user.rewardDebt = user.amount.mul(pool.accWorldPerShare).div(1e12);\\r\\n        emit Deposit(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    // Withdraw LP tokens from WorldFarming\\r\\n    function withdraw(uint256 _pid, uint256 _amount) public {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n        require(user.amount \\u003e= _amount, \\\"Withdraw amount is greater than user amount\\\");\\r\\n\\r\\n        updatePool(_pid);\\r\\n\\r\\n        uint256 pending = user.amount.mul(pool.accWorldPerShare).div(1e12).sub(user.rewardDebt);\\r\\n        if (pending \\u003e 0) {\\r\\n            safeTokenTransfer(msg.sender, pending);\\r\\n        }\\r\\n        if (_amount \\u003e 0) {\\r\\n            user.amount = user.amount.sub(_amount);\\r\\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\\r\\n        }\\r\\n        user.rewardDebt = user.amount.mul(pool.accWorldPerShare).div(1e12);\\r\\n        emit Withdraw(msg.sender, _pid, _amount);\\r\\n    }\\r\\n\\r\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\r\\n    function emergencyWithdraw(uint256 _pid) public {\\r\\n        PoolInfo storage pool = poolInfo[_pid];\\r\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\r\\n\\r\\n        user.amount = 0;\\r\\n        user.rewardDebt = 0;\\r\\n\\r\\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\\r\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\r\\n    }\\r\\n\\r\\n    // Safe WORLD token transfer function, just in case if\\r\\n    // rounding error causes pool to not have enough WORLD tokens\\r\\n    function safeTokenTransfer(address _to, uint256 _amount) internal {\\r\\n        uint256 balance = world.balanceOf(address(this));\\r\\n        uint256 amount = _amount \\u003e balance ? balance : _amount;\\r\\n        world.transfer(_to, amount);\\r\\n    }\\r\\n\\r\\n    function setBlockRewardUpdateCycle(uint256 _blockRewardUpdateCycle) external onlyOwner {\\r\\n        require(_blockRewardUpdateCycle \\u003e 0, \\\"Value is zero\\\");\\r\\n        blockRewardUpdateCycle = _blockRewardUpdateCycle;\\r\\n    }\\r\\n\\r\\n    // Just in case an adjustment is needed since mined blocks per day\\r\\n    // changes constantly depending on the network\\r\\n    function setBlocksPerDay(uint256 _blocksPerDay) external onlyOwner {\\r\\n        require(_blocksPerDay \\u003e= 25200 \\u0026\\u0026 _blocksPerDay \\u003c= 36000, \\\"Value is outside of range 25200-36000\\\");\\r\\n        blocksPerDay = _blocksPerDay;\\r\\n    }\\r\\n\\r\\n    function setBlockRewardPercentage(uint256 _blockRewardPercentage) external onlyOwner {\\r\\n        require(_blockRewardPercentage \\u003e= 1 \\u0026\\u0026 _blockRewardPercentage \\u003c= 35, \\\"Value is outside of range 1-35\\\");\\r\\n        blockRewardPercentage = _blockRewardPercentage;\\r\\n    }\\r\\n}\"},\"EARTHtoken.sol\":{\"content\":\"/* \\n      ,c::;;;:;.                   ;l\\u0027                  .::;:::::,.              \\u0027;;;:cc;;:,.            .,.        ,.                                             \\n     .dl.......                   :dod\\u0027                 ;x;....\\u0027\\u0027:o;             ....;xl....             \\u0027d,       .d;                                             \\n     .o:                         \\u0027d, lo.                ;d.       ,d.                .o;                 \\u0027d,       .d;                                             \\n     .dl......                  .oc  .dc                ;d.      .cl.                .o;                 \\u0027d;       \\u0027d;                                             \\n     .dd;;;;;;.                 lo.   \\u0027d,               ;kl;:cc::c;.                 .o;                 \\u0027xo,;;;;;,ck;                                             \\n     .o:                       :d.     :d.              ;x;..:xkc                    .o;                 \\u0027d,       .d;                                             \\n     .o:                      \\u0027d;       lo.             ;d.   \\u0027col.                  .o;                 \\u0027d,       .d;                                             \\n     .do\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027\\u0027.             .oc        .o:             ;d.     .cd,                 .o;                 \\u0027d,       .d;                                             \\n      \\u0027;;;;;;;,.              .          ..             ..        ..                  ..                 ...        ..         \\n      \\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"./context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./safemath.sol\\\";\\nimport \\\"./address.sol\\\";\\nimport \\\"./ownable.sol\\\";\\n\\ncontract EARTHToken is Context, IERC20, Ownable {\\n  using SafeMath for uint256;\\n                     using Address for address;\\n\\n                                       string private constant NAME = \\\"EARTH Token\\\";\\n  string private constant SYMBOL = \\\"EARTH\\\";\\n  uint8 private constant DECIMALS = 18;\\n\\n  mapping(address =\\u003e uint256) private rewards;\\n  mapping(address =\\u003e uint256) private actual;\\n  mapping(address =\\u003e mapping(address =\\u003e uint256)) private allowances;\\n\\n  mapping(address =\\u003e bool) private excludedFromFees;\\n  mapping(address =\\u003e bool) private excludedFromRewards;\\n  address[] private rewardExcluded;\\n\\n  uint256 private constant MAX = ~uint256(0);\\n  uint256 private constant ACTUAL_TOTAL = 100_000_000 * 1e18;\\n  uint256 private rewardsTotal = (MAX - (MAX % ACTUAL_TOTAL));\\n  uint256 private holderFeeTotal;\\n  uint256 private marketingFeeTotal;\\n  uint256 private lpFeeTotal;\\n  uint256 private merchantFeeTotal;\\n\\n  bool public tradingEnabled;\\n\\n  uint256 public taxPercentage = 3;\\n  uint256 public holderTaxAlloc = 10;\\n  uint256 public marketingTaxAlloc = 10;\\n  uint256 public lpTaxAlloc = 10;\\n  uint256 public merchantTaxAlloc;\\n  uint256 public totalTaxAlloc = marketingTaxAlloc.add(holderTaxAlloc).add(lpTaxAlloc).add(merchantTaxAlloc);\\n\\n  address public marketingAddress;\\n  address public lpStakingAddress;\\n  address public merchantStakingAddress;\\n  address public currentPoolAddress;\\n  address public pancakeRouterAddress;\\n\\n  constructor(address _marketingAddress) {\\n    rewards[_marketingAddress] = rewardsTotal;\\n    emit Transfer(address(0), _marketingAddress, ACTUAL_TOTAL);\\n\\n    marketingAddress = _marketingAddress;\\n\\n    excludeFromRewards(_msgSender());\\n    excludeFromFees(_marketingAddress);\\n\\n    if (_marketingAddress != _msgSender()) {\\n      excludeFromRewards(_marketingAddress);\\n      excludeFromFees(_msgSender());\\n    }\\n\\n    excludeFromFees(address(0x000000000000000000000000000000000000dEaD));\\n  }\\n\\n  function name() external pure returns (string memory) {\\n    return NAME;\\n  }\\n\\n  function symbol() external pure returns (string memory) {\\n    return SYMBOL;\\n  }\\n\\n  function decimals() external pure returns (uint8) {\\n    return DECIMALS;\\n  }\\n\\n  function totalSupply() external pure override returns (uint256) {\\n    return ACTUAL_TOTAL;\\n  }\\n\\n  function balanceOf(address _account) public view override returns (uint256) {\\n    if (excludedFromRewards[_account]) {\\n      return actual[_account];\\n    }\\n    return tokenWithRewards(rewards[_account]);\\n  }\\n\\n  function transfer(address _recipient, uint256 _amount) public override returns (bool) {\\n    _transfer(_msgSender(), _recipient, _amount);\\n    return true;\\n  }\\n\\n  function allowance(address _owner, address _spender) public view override returns (uint256) {\\n    return allowances[_owner][_spender];\\n  }\\n\\n  function approve(address _spender, uint256 _amount) public override returns (bool) {\\n    _approve(_msgSender(), _spender, _amount);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address _sender,\\n    address _recipient,\\n    uint256 _amount\\n) public override returns (bool) {\\n    _transfer(_sender, _recipient, _amount);\\n\\n    _approve(\\n      _sender,\\n      _msgSender(),\\n      allowances[_sender][_msgSender()].sub(_amount, \\\"ERC20: transfer amount exceeds allowance\\\")\\n    );\\n\\n    return true;\\n  }\\n\\n  function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\\n    _approve(_msgSender(), _spender, allowances[_msgSender()][_spender].add(_addedValue));\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\\n    _approve(\\n      _msgSender(),\\n      _spender,\\n      allowances[_msgSender()][_spender].sub(_subtractedValue, \\\"ERC20: decreased allowance below zero\\\")\\n    );\\n    return true;\\n  }\\n\\n  function isExcludedFromRewards(address _account) external view returns (bool) {\\n    return excludedFromRewards[_account];\\n  }\\n\\n  function isExcludedFromFees(address _account) external view returns (bool) {\\n    return excludedFromFees[_account];\\n  }\\n\\n  function totalFees() external view returns (uint256) {\\n    return holderFeeTotal.add(marketingFeeTotal).add(lpFeeTotal).add(merchantFeeTotal);\\n  }\\n\\n  function totalHolderFees() external view returns (uint256) {\\n    return holderFeeTotal;\\n  }\\n\\n  function totalMarketingFees() external view returns (uint256) {\\n    return marketingFeeTotal;\\n  }\\n\\n  function totalLpFees() external view returns (uint256) {\\n    return lpFeeTotal;\\n  }\\n\\n  function totalMerchantFees() external view returns (uint256) {\\n    return merchantFeeTotal;\\n  }\\n\\n  function distribute(uint256 _actualAmount) public {\\n    address sender = _msgSender();\\n    require(!excludedFromRewards[sender], \\\"Excluded addresses cannot call this function\\\");\\n\\n    (uint256 rewardAmount, , , , ) = _getValues(_actualAmount);\\n    rewards[sender] = rewards[sender].sub(rewardAmount);\\n    rewardsTotal = rewardsTotal.sub(rewardAmount);\\n    holderFeeTotal = holderFeeTotal.add(_actualAmount);\\n  }\\n\\n    function excludeFromFees(address _account) public onlyOwner() {\\n      require(!excludedFromFees[_account], \\\"Account is already excluded from fee\\\");\\n      excludedFromFees[_account] = true;\\n    }\\n\\n    function includeInFees(address _account) public onlyOwner() {\\n      require(excludedFromFees[_account], \\\"Account is already included in fee\\\");\\n      excludedFromFees[_account] = false;\\n    }\\n\\n    function excludeFromRewards(address _account) public onlyOwner() {\\n      require(!excludedFromRewards[_account], \\\"Account is already excluded from reward\\\");\\n\\n      if (rewards[_account] \\u003e 0) {\\n        actual[_account] = tokenWithRewards(rewards[_account]);\\n      }\\n\\n      excludedFromRewards[_account] = true;\\n      rewardExcluded.push(_account);\\n    }\\n\\n    function includeInRewards(address _account) public onlyOwner() {\\n      require(excludedFromRewards[_account], \\\"Account is already included in rewards\\\");\\n\\n      for (uint256 i = 0; i \\u003c rewardExcluded.length; i++) {\\n        if (rewardExcluded[i] == _account) {\\n          rewardExcluded[i] = rewardExcluded[rewardExcluded.length - 1];\\n          actual[_account] = 0;\\n          excludedFromRewards[_account] = false;\\n          rewardExcluded.pop();\\n          break;\\n        }\\n      }\\n    }\\n\\n    function _approve(\\n      address _owner,\\n      address _spender,\\n      uint256 _amount\\n  ) private {\\n      require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n      require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n      allowances[_owner][_spender] = _amount;\\n      emit Approval(_owner, _spender, _amount);\\n    }\\n\\n      function _transfer(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) private {\\n        require(_sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(_recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(_amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\n        \\n        if((_msgSender() == currentPoolAddress || _msgSender() == address(pancakeRouterAddress)) \\u0026\\u0026 !tradingEnabled)\\n          require(false, \\\"EARTH: trading has not been enabled.\\\");\\n\\n        uint256 currentTaxPercentage = taxPercentage;\\n        if (excludedFromFees[_sender] || excludedFromFees[_recipient]) {\\n          taxPercentage = 0;\\n        } else {\\n          uint256 fee = _getFee(_amount);\\n          uint256 marketingFee = _getMarketingFee(fee);\\n          uint256 lpFee = _getLpFee(fee);\\n          uint256 merchantFee = _getMerchantFee(fee);\\n\\n          _updateMarketingFee(marketingFee);\\n          _updateLpFee(lpFee);\\n          _updateMerchantFee(merchantFee);\\n        }\\n\\n        if (excludedFromRewards[_sender] \\u0026\\u0026 !excludedFromRewards[_recipient]) {\\n          _transferWithoutSenderRewards(_sender, _recipient, _amount);\\n        } else if (!excludedFromRewards[_sender] \\u0026\\u0026 excludedFromRewards[_recipient]) {\\n          _transferWithRecipientRewards(_sender, _recipient, _amount);\\n        } else if (!excludedFromRewards[_sender] \\u0026\\u0026 !excludedFromRewards[_recipient]) {\\n          _transferWithRewards(_sender, _recipient, _amount);\\n        } else if (excludedFromRewards[_sender] \\u0026\\u0026 excludedFromRewards[_recipient]) {\\n          _transferWithoutRewards(_sender, _recipient, _amount);\\n        } else {\\n          _transferWithRewards(_sender, _recipient, _amount);\\n        }\\n\\n        if (currentTaxPercentage != taxPercentage) {\\n          taxPercentage = currentTaxPercentage;\\n        }\\n      }\\n\\n        function _transferWithRewards(\\n          address _sender,\\n          address _recipient,\\n          uint256 _actualAmount\\n      ) private {\\n          (\\n            uint256 rewardAmount,\\n            uint256 rewardTransferAmount,\\n            uint256 rewardFee,\\n            uint256 actualTransferAmount,\\n            uint256 actualFee\\n        ) = _getValues(_actualAmount);\\n\\n          rewards[_sender] = rewards[_sender].sub(rewardAmount);\\n          rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\\n          _updateHolderFee(rewardFee, actualFee);\\n          emit Transfer(_sender, _recipient, actualTransferAmount);\\n        }\\n\\n          function _transferWithRecipientRewards(\\n            address _sender,\\n            address _recipient,\\n            uint256 _actualAmount\\n        ) private {\\n            (\\n              uint256 rewardAmount,\\n              uint256 rewardTransferAmount,\\n              uint256 rewardFee,\\n              uint256 actualTransferAmount,\\n              uint256 actualFee\\n          ) = _getValues(_actualAmount);\\n\\n            rewards[_sender] = rewards[_sender].sub(rewardAmount);\\n            actual[_recipient] = actual[_recipient].add(actualTransferAmount);\\n            rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\\n            _updateHolderFee(rewardFee, actualFee);\\n            emit Transfer(_sender, _recipient, actualTransferAmount);\\n          }\\n\\n            function _transferWithoutSenderRewards(\\n              address _sender,\\n              address _recipient,\\n              uint256 _actualAmount\\n          ) private {\\n              (\\n                uint256 rewardAmount,\\n                uint256 rewardTransferAmount,\\n                uint256 rewardFee,\\n                uint256 actualTransferAmount,\\n                uint256 actualFee\\n            ) = _getValues(_actualAmount);\\n\\n              actual[_sender] = actual[_sender].sub(_actualAmount);\\n              rewards[_sender] = rewards[_sender].sub(rewardAmount);\\n              rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\\n              _updateHolderFee(rewardFee, actualFee);\\n              emit Transfer(_sender, _recipient, actualTransferAmount);\\n            }\\n\\n              function _transferWithoutRewards(\\n                address _sender,\\n                address _recipient,\\n                uint256 _actualAmount\\n            ) private {\\n                (\\n                  uint256 rewardAmount,\\n                  uint256 rewardTransferAmount,\\n                  uint256 rewardFee,\\n                  uint256 actualTransferAmount,\\n                  uint256 actualFee\\n              ) = _getValues(_actualAmount);\\n\\n                actual[_sender] = actual[_sender].sub(_actualAmount);\\n                rewards[_sender] = rewards[_sender].sub(rewardAmount);\\n                actual[_recipient] = actual[_recipient].add(actualTransferAmount);\\n                rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\\n                _updateHolderFee(rewardFee, actualFee);\\n                emit Transfer(_sender, _recipient, actualTransferAmount);\\n              }\\n\\n                function _updateHolderFee(uint256 _rewardFee, uint256 _actualFee) private {\\n                  rewardsTotal = rewardsTotal.sub(_rewardFee);\\n                  holderFeeTotal = holderFeeTotal.add(_actualFee);\\n                }\\n\\n                  function _updateMarketingFee(uint256 _marketingFee) private {\\n                    if (marketingAddress == address(0)) {\\n                      return;\\n                    }\\n\\n                    uint256 rewardsRate = _getRewardsRate();\\n                    uint256 rewardMarketingFee = _marketingFee.mul(rewardsRate);\\n                    marketingFeeTotal = marketingFeeTotal.add(_marketingFee);\\n\\n                    rewards[marketingAddress] = rewards[marketingAddress].add(rewardMarketingFee);\\n                    if (excludedFromRewards[marketingAddress]) {\\n                      actual[marketingAddress] = actual[marketingAddress].add(_marketingFee);\\n                    }\\n                  }\\n\\n                    function _updateLpFee(uint256 _lpFee) private {\\n                      if (lpStakingAddress == address(0)) {\\n                        return;\\n                      }\\n\\n                      uint256 rewardsRate = _getRewardsRate();\\n                      uint256 rewardLpFee = _lpFee.mul(rewardsRate);\\n                      lpFeeTotal = lpFeeTotal.add(_lpFee);\\n\\n                      rewards[lpStakingAddress] = rewards[lpStakingAddress].add(rewardLpFee);\\n                      if (excludedFromRewards[lpStakingAddress]) {\\n                        actual[lpStakingAddress] = actual[lpStakingAddress].add(_lpFee);\\n                      }\\n                    }\\n\\n                      function _updateMerchantFee(uint256 _merchantFee) private {\\n                        if (merchantStakingAddress == address(0)) {\\n                          return;\\n                        }\\n\\n                        uint256 rewardsRate = _getRewardsRate();\\n                        uint256 rewardMerchantFee = _merchantFee.mul(rewardsRate);\\n                        merchantFeeTotal = merchantFeeTotal.add(_merchantFee);\\n\\n                        rewards[merchantStakingAddress] = rewards[merchantStakingAddress].add(rewardMerchantFee);\\n                        if (excludedFromRewards[merchantStakingAddress]) {\\n                          actual[merchantStakingAddress] = actual[merchantStakingAddress].add(_merchantFee);\\n                        }\\n                      }\\n\\n                        function rewardsFromToken(uint256 _actualAmount, bool _deductTransferFee) public view returns (uint256) {\\n                          require(_actualAmount \\u003c= ACTUAL_TOTAL, \\\"Amount must be less than supply\\\");\\n                          if (!_deductTransferFee) {\\n                            (uint256 rewardAmount, , , , ) = _getValues(_actualAmount);\\n                            return rewardAmount;\\n                          } else {\\n                            (, uint256 rewardTransferAmount, , , ) = _getValues(_actualAmount);\\n                            return rewardTransferAmount;\\n                          }\\n                        }\\n\\n                        function tokenWithRewards(uint256 _rewardAmount) public view returns (uint256) {\\n                          require(_rewardAmount \\u003c= rewardsTotal, \\\"Amount must be less than total rewards\\\");\\n                          uint256 rewardsRate = _getRewardsRate();\\n                          return _rewardAmount.div(rewardsRate);\\n                        }\\n\\n                        function _getValues(uint256 _actualAmount)\\n                      private\\n                        view\\n                        returns (\\n                          uint256,\\n                          uint256,\\n                          uint256,\\n                          uint256,\\n                          uint256\\n                        )\\n                        {\\n                          (uint256 actualTransferAmount, uint256 actualFee) = _getActualValues(_actualAmount);\\n                          uint256 rewardsRate = _getRewardsRate();\\n                          (\\n                            uint256 rewardAmount,\\n                          uint256 rewardTransferAmount,\\n                          uint256 rewardFee\\n                        ) = _getRewardValues(_actualAmount, actualFee, rewardsRate);\\n\\n                          return (rewardAmount, rewardTransferAmount, rewardFee, actualTransferAmount, actualFee);\\n                        }\\n\\n                        function _getActualValues(uint256 _actualAmount) private view returns (uint256, uint256) {\\n                          uint256 actualFee = _getFee(_actualAmount);\\n                          uint256 actualHolderFee = _getHolderFee(actualFee);\\n                          uint256 actualTransferAmount = _actualAmount.sub(actualFee);\\n                          return (actualTransferAmount, actualHolderFee);\\n                        }\\n\\n                        function _getRewardValues(\\n                          uint256 _actualAmount,\\n                          uint256 _actualHolderFee,\\n                          uint256 _rewardsRate\\n                      )\\n                      private\\n                        view\\n                        returns (\\n                          uint256,\\n                          uint256,\\n                          uint256\\n                        )\\n                        {\\n                          uint256 actualFee = _getFee(_actualAmount).mul(_rewardsRate);\\n                          uint256 rewardAmount = _actualAmount.mul(_rewardsRate);\\n                          uint256 rewardTransferAmount = rewardAmount.sub(actualFee);\\n                          uint256 rewardFee = _actualHolderFee.mul(_rewardsRate);\\n                          return (rewardAmount, rewardTransferAmount, rewardFee);\\n                        }\\n\\n                        function _getRewardsRate() private view returns (uint256) {\\n                          (uint256 rewardsSupply, uint256 actualSupply) = _getCurrentSupply();\\n                          return rewardsSupply.div(actualSupply);\\n                        }\\n\\n                        function _getCurrentSupply() private view returns (uint256, uint256) {\\n                          uint256 rewardsSupply = rewardsTotal;\\n                          uint256 actualSupply = ACTUAL_TOTAL;\\n\\n                          for (uint256 i = 0; i \\u003c rewardExcluded.length; i++) {\\n                            if (rewards[rewardExcluded[i]] \\u003e rewardsSupply || actual[rewardExcluded[i]] \\u003e actualSupply) {\\n                              return (rewardsTotal, ACTUAL_TOTAL);\\n                            }\\n\\n                            rewardsSupply = rewardsSupply.sub(rewards[rewardExcluded[i]]);\\n                            actualSupply = actualSupply.sub(actual[rewardExcluded[i]]);\\n                          }\\n\\n                          if (rewardsSupply \\u003c rewardsTotal.div(ACTUAL_TOTAL)) {\\n                            return (rewardsTotal, ACTUAL_TOTAL);\\n                          }\\n\\n                          return (rewardsSupply, actualSupply);\\n                        }\\n\\n                        function _getFee(uint256 _amount) private view returns (uint256) {\\n                          return _amount.mul(taxPercentage).div(100);\\n                        }\\n\\n                        function _getHolderFee(uint256 _tax) private view returns (uint256) {\\n                          return _tax.mul(holderTaxAlloc).div(totalTaxAlloc);\\n                        }\\n\\n                        function _getMarketingFee(uint256 _tax) private view returns (uint256) {\\n                          return _tax.mul(marketingTaxAlloc).div(totalTaxAlloc);\\n                        }\\n\\n                        function _getLpFee(uint256 _tax) private view returns (uint256) {\\n                          return _tax.mul(lpTaxAlloc).div(totalTaxAlloc);\\n                        }\\n\\n                        function _getMerchantFee(uint256 _tax) private view returns (uint256) {\\n                          return _tax.mul(merchantTaxAlloc).div(totalTaxAlloc);\\n                        }\\n\\n                        function setTaxPercentage(uint256 _taxPercentage) external onlyOwner {\\n                          require(_taxPercentage \\u003e= 1 \\u0026\\u0026 _taxPercentage \\u003c= 10, \\\"Value is outside of range 1-10\\\");\\n                          taxPercentage = _taxPercentage;\\n                        }\\n\\n                        function setTaxAllocations(\\n                          uint256 _holderTaxAlloc,\\n                          uint256 _marketingTaxAlloc,\\n                          uint256 _lpTaxAlloc,\\n                          uint256 _merchantTaxAlloc\\n                      ) external onlyOwner {\\n                          totalTaxAlloc = _holderTaxAlloc.add(_marketingTaxAlloc).add(_lpTaxAlloc).add(_merchantTaxAlloc);\\n\\n                          require(_holderTaxAlloc \\u003e= 5 \\u0026\\u0026 _holderTaxAlloc \\u003c= 10, \\\"_holderTaxAlloc is outside of range 5-10\\\");\\n                          require(_lpTaxAlloc \\u003e= 5 \\u0026\\u0026 _lpTaxAlloc \\u003c= 10, \\\"_lpTaxAlloc is outside of range 5-10\\\");\\n                          require(_marketingTaxAlloc \\u003c= 10, \\\"_marketingTaxAlloc is greater than 10\\\");\\n                          require(_merchantTaxAlloc \\u003c= 10, \\\"_merchantTaxAlloc is greater than 10\\\");\\n\\n                          holderTaxAlloc = _holderTaxAlloc;\\n                          marketingTaxAlloc = _marketingTaxAlloc;\\n                          lpTaxAlloc = _lpTaxAlloc;\\n                          merchantTaxAlloc = _merchantTaxAlloc;\\n                        }\\n\\n                        function setMarketingAddress(address _marketingAddress) external onlyOwner {\\n                          marketingAddress = _marketingAddress;\\n                        }\\n\\n                        function setLpStakingAddress(address _lpStakingAddress) external onlyOwner {\\n                          lpStakingAddress = _lpStakingAddress;\\n                        }\\n\\n                        function setCurrentPoolAddress(address _currentPoolAddress) external onlyOwner {\\n                          currentPoolAddress = _currentPoolAddress;\\n                        }\\n\\n                        function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\\n                          pancakeRouterAddress = _pancakeRouterAddress;\\n                        }\\n\\n                        function _enableTrading() external onlyOwner() {\\n                          tradingEnabled = !tradingEnabled;\\n                        }\\n\\n                        function setMerchantStakingAddress(address _merchantStakingAddress) external onlyOwner {\\n                          merchantStakingAddress = _merchantStakingAddress;\\n                        }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\nimport \\\"./context.sol\\\";\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./safemath.sol\\\";\\r\\nimport \\\"./address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\"},\"safemath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        uint256 c = a + b;\\r\\n        if (c \\u003c a) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b \\u003e a) return (false, 0);\\r\\n        return (true, a - b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) return (true, 0);\\r\\n        uint256 c = a * b;\\r\\n        if (c / a != b) return (false, 0);\\r\\n        return (true, c);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a / b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        if (b == 0) return (false, 0);\\r\\n        return (true, a % b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) return 0;\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_actualAmount\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"excludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderTaxAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"includeInFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"includeInRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isExcludedFromRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpStakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTaxAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTaxAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merchantStakingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merchantTaxAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_actualAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_deductTransferFee\",\"type\":\"bool\"}],\"name\":\"rewardsFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currentPoolAddress\",\"type\":\"address\"}],\"name\":\"setCurrentPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpStakingAddress\",\"type\":\"address\"}],\"name\":\"setLpStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"}],\"name\":\"setMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchantStakingAddress\",\"type\":\"address\"}],\"name\":\"setMerchantStakingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pancakeRouterAddress\",\"type\":\"address\"}],\"name\":\"setPancakeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_holderTaxAlloc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingTaxAlloc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpTaxAlloc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_merchantTaxAlloc\",\"type\":\"uint256\"}],\"name\":\"setTaxAllocations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxPercentage\",\"type\":\"uint256\"}],\"name\":\"setTaxPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardAmount\",\"type\":\"uint256\"}],\"name\":\"tokenWithRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHolderFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLpFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMarketingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMerchantFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTaxAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EARTHToken", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002bbd7eb9e9fe0f96ecf57102e4047e9f48d13d4b", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9cce3201f475f6cc52b538b157721d954e20dadd9169b72aa3dfc78163f58a87"}