{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/base/RangoBaseInterchainMiddleware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\nimport \\\"../../libraries/LibDiamond.sol\\\";\\nimport \\\"../../libraries/LibInterchain.sol\\\";\\n\\n// @title The base contract to be used as a parent of middleware classes\\n// @author George\\n// @dev Note that this is not a facet and should be extended and deployed separately.\\ncontract RangoBaseInterchainMiddleware {\\n    /// @dev keccak256(\\\"exchange.rango.middleware.base\\\")\\n    bytes32 internal constant BASE_MIDDLEWARE_CONTRACT_NAMESPACE = hex\\\"ad914d4300c64e1902ca499875cd8a76ae717047bcfaa9e806ff7ea4f6911268\\\";\\n\\n    struct BaseInterchainMiddlewareStorage {\\n        address rangoDiamond;\\n        address owner;\\n    }\\n\\n    struct whitelistRequest {\\n        address contractAddress;\\n        bytes4[] methodIds;\\n    }\\n\\n    constructor(){updateOwnerInternal(tx.origin);}\\n\\n    function initBaseMiddleware(\\n        address _owner,\\n        address _rangoDiamond,\\n        address _weth\\n    ) public onlyOwner {\\n        require(_owner != address(0));\\n        updateOwnerInternal(_owner);\\n        updateRangoDiamondInternal(_rangoDiamond);\\n        LibSwapper.setWeth(_weth);\\n    }\\n\\n\\n    /// Events\\n    /// @notice Emits when the rango diamond address is updated\\n    /// @param oldAddress The previous address\\n    /// @param newAddress The new address\\n    event RangoDiamondAddressUpdated(address oldAddress, address newAddress);\\n    /// @notice Emits when the weth address is updated\\n    /// @param oldAddress The previous address\\n    /// @param newAddress The new address\\n    event WethAddressUpdated(address oldAddress, address newAddress);\\n    /// @notice Emits when the owner is updated\\n    /// @param previousOwner The previous owner\\n    /// @param newOwner The new owner\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    /// @notice Notifies that admin manually refunded some money\\n    /// @param _token The address of refunded token, 0x000..00 address for native token\\n    /// @param _amount The amount that is refunded\\n    event Refunded(address _token, uint _amount);\\n    /// @notice Notifies that a new contract is whitelisted\\n    /// @param _address The address of the contract\\n    event ContractWhitelisted(address _address);\\n    /// @notice Notifies that a new contract is whitelisted\\n    /// @param contractAddress The address of the contract\\n    /// @param methods The method signatures that are whitelisted for a contractAddress\\n    event ContractAndMethodsWhitelisted(address contractAddress, bytes4[] methods);\\n    /// @notice Notifies that a new contract is blacklisted\\n    /// @param _address The address of the contract\\n    event ContractBlacklisted(address _address);\\n    /// @notice Notifies that a contract is blacklisted and the given methods are removed\\n    /// @param contractAddress The address of the contract\\n    /// @param methods The method signatures that are blacklisted for the given contractAddress\\n    event ContractAndMethodsBlacklisted(address contractAddress, bytes4[] methods);\\n    /// @notice Notifies that a new contract is whitelisted\\n    /// @param _dapp The address of the contract\\n    event MessagingDAppWhitelisted(address _dapp);\\n    /// @notice Notifies that a new contract is blacklisted\\n    /// @param _dapp The address of the contract\\n    event MessagingDAppBlacklisted(address _dapp);\\n\\n    /// @notice used to limit access only to owner\\n    modifier onlyOwner() {\\n        require(msg.sender == getBaseInterchainMiddlewareStorage().owner, \\\"should be called only by owner\\\");\\n        _;\\n    }\\n\\n    /// @notice used to limit access only to rango diamond\\n    modifier onlyDiamond() {\\n        require(msg.sender == getBaseInterchainMiddlewareStorage().rangoDiamond, \\\"should be called only from diamond\\\");\\n        _;\\n    }\\n\\n    /// @notice Enables the contract to receive native ETH token from other contracts including WETH contract\\n    receive() external payable {}\\n\\n    /// Administration & Control\\n\\n    /// @notice Updates the address of rango diamond contract\\n    /// @param newAddress The new address of diamond contract\\n    function updateRangoDiamondAddress(address newAddress) external onlyOwner {\\n        updateRangoDiamondInternal(newAddress);\\n    }\\n    /// @notice Updates the address of weth contract\\n    /// @param newAddress The new address of weth contract\\n    function updateWethAddress(address newAddress) external onlyOwner {\\n        LibSwapper.setWeth(newAddress);\\n    }\\n    /// @notice Updates the address of owner\\n    /// @param newAddress The new address of owner\\n    function updateOwner(address newAddress) external onlyOwner {\\n        updateOwnerInternal(newAddress);\\n    }\\n\\n    /// @notice Transfers an ERC20 token from this contract to msg.sender\\n    /// @dev This endpoint is to return money to a user if we didn't handle failure correctly and the money is still in the contract\\n    /// @dev Currently the money goes to admin and they should manually transfer it to a wallet later\\n    /// @param _tokenAddress The address of ERC20 token to be transferred\\n    /// @param _amount The amount of money that should be transfered\\n    function refund(address _tokenAddress, uint256 _amount) external onlyOwner {\\n        IERC20 ercToken = IERC20(_tokenAddress);\\n        uint balance = ercToken.balanceOf(address(this));\\n        require(balance >= _amount, 'Insufficient balance');\\n\\n        SafeERC20.safeTransfer(IERC20(_tokenAddress), msg.sender, _amount);\\n        emit Refunded(_tokenAddress, _amount);\\n    }\\n\\n    /// @notice Transfers the native token from this contract to msg.sender\\n    /// @dev This endpoint is to return money to a user if we didn't handle failure correctly and the money is still in the contract\\n    /// @dev Currently the money goes to admin and they should manually transfer it to a wallet later\\n    /// @param _amount The amount of native token that should be transferred\\n    function refundNative(uint256 _amount) external onlyOwner {\\n        uint balance = address(this).balance;\\n        require(balance >= _amount, 'Insufficient balance');\\n\\n        (bool sent,) = msg.sender.call{value : _amount}(\\\"\\\");\\n        require(sent, \\\"failed to send native\\\");\\n\\n        emit Refunded(LibSwapper.ETH, _amount);\\n    }\\n\\n    /// @notice Adds a list of contracts to the whitelisted DEXes that can be called\\n    /// @param req The requests for whitelisting contracts and methods\\n    function addWhitelistContractMiddleWare(whitelistRequest[] calldata req) external onlyOwner {\\n        for (uint i = 0; i < req.length; i++) {\\n            LibSwapper.addMethodWhitelists(req[i].contractAddress, req[i].methodIds);\\n            emit ContractAndMethodsWhitelisted(req[i].contractAddress, req[i].methodIds);\\n            emit ContractWhitelisted(req[i].contractAddress);\\n        }\\n    }\\n\\n    /// @notice Removes a contract from the whitelisted DEXes\\n    /// @param contractAddress The address of the DEX or dApp\\n    function removeWhitelistMiddleWare(address contractAddress) external onlyOwner {\\n        LibSwapper.removeWhitelist(contractAddress);\\n        emit ContractBlacklisted(contractAddress);\\n    }\\n\\n    /// @notice Removes a contract and given method ids\\n    /// @param contractAddress The address of the contract\\n    /// @param methodIds The methods to be removed alongside the given contract\\n    function removeContractAndMethodIdsFromWhitelist(\\n        address contractAddress,\\n        bytes4[] calldata methodIds\\n    ) external onlyOwner {\\n        LibSwapper.removeWhitelist(contractAddress);\\n        emit ContractBlacklisted(contractAddress);\\n        for (uint i = 0; i < methodIds.length; i++) {\\n            LibSwapper.removeMethodWhitelist(contractAddress, methodIds[i]);\\n        }\\n        if (methodIds.length > 0) {\\n            emit ContractAndMethodsBlacklisted(contractAddress, methodIds);\\n        }\\n    }\\n\\n    /// @notice Adds a list of contracts to the whitelisted messaging dApps that can be called\\n    /// @param _dapps The addresses of dApps\\n    function addMessagingDAppsMiddleWare(address[] calldata _dapps) external onlyOwner {\\n        address dapp;\\n        for (uint i = 0; i < _dapps.length; i++) {\\n            dapp = _dapps[i];\\n            LibInterchain.addMessagingDApp(dapp);\\n            emit MessagingDAppWhitelisted(dapp);\\n        }\\n    }\\n\\n    /// @notice Removes a contract from dApps that can be called\\n    /// @param _dapp The address of dApp\\n    function removeMessagingDAppContractMiddleWare(address _dapp) external onlyOwner {\\n        LibInterchain.removeMessagingDApp(_dapp);\\n        emit MessagingDAppBlacklisted(_dapp);\\n    }\\n\\n\\n    /// Internal and Private functions\\n    function updateRangoDiamondInternal(address newAddress) private {\\n        BaseInterchainMiddlewareStorage storage s = getBaseInterchainMiddlewareStorage();\\n        address oldAddress = s.rangoDiamond;\\n        s.rangoDiamond = newAddress;\\n        emit RangoDiamondAddressUpdated(oldAddress, newAddress);\\n    }\\n\\n    function updateOwnerInternal(address newAddress) private {\\n        BaseInterchainMiddlewareStorage storage s = getBaseInterchainMiddlewareStorage();\\n        address oldAddress = s.owner;\\n        s.owner = newAddress;\\n        emit OwnershipTransferred(oldAddress, newAddress);\\n    }\\n\\n    /// @dev fetch local storage\\n    function getBaseInterchainMiddlewareStorage() private pure returns (BaseInterchainMiddlewareStorage storage s) {\\n        bytes32 namespace = BASE_MIDDLEWARE_CONTRACT_NAMESPACE;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            s.slot := namespace\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/facets/bridges/RangoStargateMiddleware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\nimport \\\"../../libraries/LibInterchain.sol\\\";\\nimport \\\"../../utils/ReentrancyGuard.sol\\\";\\nimport \\\"../base/RangoBaseInterchainMiddleware.sol\\\";\\n\\n/// @title The middleware contract that handles Rango's receive messages from stargate.\\n/// @author George\\n/// @dev Note that this is not a facet and should be deployed separately.\\ncontract RangoStargateMiddleware is ReentrancyGuard, IRango, IStargateReceiver, RangoBaseInterchainMiddleware {\\n\\n    /// @dev keccak256(\\\"exchange.rango.middleware.stargate\\\")\\n    bytes32 internal constant STARGATE_MIDDLEWARE_NAMESPACE = hex\\\"8f95700cb6d0d3fbe23970b0fed4ae8d3a19af1ff9db49b72f280b34bdf7bad8\\\";\\n\\n    struct RangoStargateMiddlewareStorage {\\n        address stargateRouter;\\n    }\\n\\n    function initStargateMiddleware(\\n        address _owner,\\n        address _stargateRouter,\\n        address _weth\\n    ) external onlyOwner {\\n        initBaseMiddleware(_owner, address(0), _weth);\\n        updateStargateRouterAddressInternal(_stargateRouter);\\n    }\\n\\n    /// Events\\n\\n    /// @notice Emits when the Stargate address is updated\\n    /// @param oldAddress The previous address\\n    /// @param newAddress The new address\\n    event StargateRouterAddressUpdated(address oldAddress, address newAddress);\\n\\n    /// External Functions\\n\\n    /// @notice Updates the address of stargateRouter\\n    /// @param newAddress The new address of owner\\n    function updateStargateRouter(address newAddress) external onlyOwner {\\n        updateStargateRouterAddressInternal(newAddress);\\n    }\\n\\n    // @param _chainId The remote chainId sending the tokens\\n    // @param _srcAddress The remote Bridge address\\n    // @param _nonce The message ordering nonce\\n    // @param _token The token contract on the local chain\\n    // @param amountLD The qty of local _token contract tokens\\n    // @param _payload The bytes containing the _tokenOut, _deadline, _amountOutMin, _toAddr\\n    function sgReceive(\\n        uint16,\\n        bytes memory,\\n        uint256,\\n        address _token,\\n        uint256 amountLD,\\n        bytes memory payload\\n    ) external payable override nonReentrant {\\n        require(msg.sender == getRangoStargateMiddlewareStorage().stargateRouter,\\n            \\\"sgReceive function can only be called by Stargate router\\\");\\n        Interchain.RangoInterChainMessage memory m = abi.decode((payload), (Interchain.RangoInterChainMessage));\\n        (address receivedToken, uint dstAmount, IRango.CrossChainOperationStatus status) = LibInterchain.handleDestinationMessage(_token, amountLD, m);\\n\\n        emit RangoBridgeCompleted(\\n            m.requestId,\\n            receivedToken,\\n            m.originalSender,\\n            m.recipient,\\n            dstAmount,\\n            status,\\n            m.dAppTag\\n        );\\n    }\\n\\n    /// Private and Internal\\n    function updateStargateRouterAddressInternal(address newAddress) private {\\n        require(newAddress != address(0), \\\"Invalid StargateRouter\\\");\\n        RangoStargateMiddlewareStorage storage s = getRangoStargateMiddlewareStorage();\\n        address oldAddress = s.stargateRouter;\\n        s.stargateRouter = newAddress;\\n        emit StargateRouterAddressUpdated(oldAddress, newAddress);\\n    }\\n\\n    /// @dev fetch local storage\\n    function getRangoStargateMiddlewareStorage() private pure returns (RangoStargateMiddlewareStorage storage s) {\\n        bytes32 namespace = STARGATE_MIDDLEWARE_NAMESPACE;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            s.slot := namespace\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Interchain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\n/// @title An interface to interchain message types\\n/// @author Uchiha Sasuke\\ninterface Interchain {\\n    enum ActionType { NO_ACTION, UNI_V2, UNI_V3, CALL }\\n    enum CallSubActionType { WRAP, UNWRAP, NO_ACTION }\\n\\n    struct RangoInterChainMessage {\\n        address requestId;\\n        uint64 dstChainId;\\n        // @dev bridgeRealOutput is only used to disambiguate receipt of WETH and ETH and SHOULD NOT be used anywhere else!\\n        address bridgeRealOutput;\\n        address toToken;\\n        address originalSender;\\n        address recipient;\\n        ActionType actionType;\\n        bytes action;\\n        CallSubActionType postAction;\\n        uint16 dAppTag;\\n\\n        // Extra message\\n        bytes dAppMessage;\\n        address dAppSourceContract;\\n        address dAppDestContract;\\n    }\\n\\n    struct UniswapV2Action {\\n        address dexAddress;\\n        uint amountOutMin;\\n        address[] path;\\n        uint deadline;\\n    }\\n\\n    struct UniswapV3ActionExactInputSingleParams {\\n        address dexAddress;\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        uint256 deadline;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice The requested call data which is computed off-chain and passed to the contract\\n    /// @param target The dex contract address that should be called\\n    /// @param callData The required data field that should be give to the dex contract to perform swap\\n    struct CallAction {\\n        address tokenIn;\\n        address spender;\\n        CallSubActionType preAction;\\n        address payable target;\\n        bytes callData;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRango.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\ninterface IRango {\\n    struct RangoBridgeRequest {\\n        address requestId;\\n        address token;\\n        uint amount;\\n        uint platformFee;\\n        uint affiliateFee;\\n        address payable affiliatorAddress;\\n        uint destinationExecutorFee;\\n        uint16 dAppTag;\\n    }\\n\\n    enum BridgeType {Across, CBridge, Hop, Hyphen, Multichain, Stargate, Synapse, Thorchain, Symbiosis, Axelar, Voyager, Poly, OptimismBridge, ArbitrumBridge, Wormhole, AllBridge}\\n\\n    /// @notice Status of cross-chain swap\\n    /// @param Succeeded The whole process is success and end-user received the desired token in the destination\\n    /// @param RefundInSource Bridge was out of liquidity and middle asset (ex: USDC) is returned to user on source chain\\n    /// @param RefundInDestination Our handler on dest chain this.executeMessageWithTransfer failed and we send middle asset (ex: USDC) to user on destination chain\\n    /// @param SwapFailedInDestination Everything was ok, but the final DEX on destination failed (ex: Market price change and slippage)\\n    enum CrossChainOperationStatus {\\n        Succeeded,\\n        RefundInSource,\\n        RefundInDestination,\\n        SwapFailedInDestination\\n    }\\n\\n    event RangoBridgeInitiated(\\n        address indexed requestId,\\n        address bridgeToken,\\n        uint256 bridgeAmount,\\n        address receiver,\\n        uint destinationChainId,\\n        bool hasInterchainMessage,\\n        bool hasDestinationSwap,\\n        uint8 indexed bridgeId,\\n        uint16 indexed dAppTag\\n    );\\n\\n    event RangoBridgeCompleted(\\n        address indexed requestId,\\n        address indexed token,\\n        address indexed originalSender,\\n        address receiver,\\n        uint amount,\\n        CrossChainOperationStatus status,\\n        uint16 dAppTag\\n    );\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRangoMessageReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\ninterface IRangoMessageReceiver {\\n    enum ProcessStatus { SUCCESS, REFUND_IN_SOURCE, REFUND_IN_DESTINATION }\\n\\n    function handleRangoMessage(\\n        address token,\\n        uint amount,\\n        ProcessStatus status,\\n        bytes memory message\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRangoStargate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\nimport \\\"./IStargateRouter.sol\\\";\\nimport \\\"./Interchain.sol\\\";\\nimport \\\"./IRango.sol\\\";\\nimport \\\"../libraries/LibSwapper.sol\\\";\\n\\n/// @title An interface to interact with RangoStargateFacet\\n/// @author Uchiha Sasuke\\ninterface IRangoStargate {\\n    enum StargateBridgeType {TRANSFER, TRANSFER_WITH_MESSAGE}\\n\\n    struct StargateRequest {\\n        StargateBridgeType bridgeType;\\n        uint16 dstChainId;\\n        uint256 srcPoolId;\\n        uint256 dstPoolId;\\n        address payable srcGasRefundAddress;\\n        uint256 minAmountLD;\\n\\n        uint256 dstGasForCall;\\n        uint256 dstNativeAmount;\\n        bytes dstNativeAddr;\\n\\n        bytes to;\\n        uint stgFee;\\n\\n        bytes imMessage;\\n    }\\n\\n    function stargateSwapAndBridge(\\n        LibSwapper.SwapRequest memory request,\\n        LibSwapper.Call[] calldata calls,\\n        IRangoStargate.StargateRequest memory stargateRequest\\n    ) external payable;\\n\\n    function stargateBridge(\\n        IRangoStargate.StargateRequest memory stargateRequest,\\n        IRango.RangoBridgeRequest memory bridgeRequest\\n    ) external payable;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStargateReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.16;\\n\\ninterface IStargateReceiver {\\n    function sgReceive(\\n        uint16 chainId,\\n        bytes memory srcAddress,\\n        uint256 nonce,\\n        address token,\\n        uint256 amountLD,\\n        bytes memory payload\\n    ) payable external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStargateRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.16;\\n\\ninterface IStargateRouter {\\n    struct lzTxObj {\\n        uint256 dstGasForCall;\\n        uint256 dstNativeAmount;\\n        bytes dstNativeAddr;\\n    }\\n\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable;\\n\\n    function swapETH(\\n        uint16 _dstChainId,\\n        address payable _refundAddress,\\n        bytes calldata _toAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD\\n    ) external payable;\\n\\n    function quoteLayerZeroFee(\\n        uint16 _dstChainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        lzTxObj memory _lzTxParams\\n    ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.16;\\n\\n/// @dev based on swap router of uniswap v2 https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02#swapexactethfortokens\\ninterface IUniswapV2 {\\n    function swapExactETHForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    // For pangolin and trader joe\\n    function swapExactAVAXForTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.16;\\n/// @dev based on IswapRouter of UniswapV3 https://docs.uniswap.org/protocol/reference/periphery/interfaces/ISwapRouter\\ninterface IUniswapV3 {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.16;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n/// Implementation of EIP-2535 Diamond Standard\\n/// https://eips.ethereum.org/EIPS/eip-2535\\nlibrary LibDiamond {\\n    /// @dev keccak256(\\\"diamond.standard.diamond.storage\\\");\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = hex\\\"c8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c\\\";\\n\\n    // Diamond specific errors\\n    error IncorrectFacetCutAction();\\n    error NoSelectorsInFacet();\\n    error FunctionAlreadyExists();\\n    error FacetAddressIsZero();\\n    error FacetAddressIsNotZero();\\n    error FacetContainsNoCode();\\n    error FunctionDoesNotExist();\\n    error FunctionIsImmutable();\\n    error InitZeroButCalldataNotEmpty();\\n    error CalldataEmptyButInitNotZero();\\n    error InitReverted();\\n    // ----------------\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert IncorrectFacetCutAction();\\n            }\\n            unchecked {\\n                ++facetIndex;\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        if (_facetAddress == address(0)) {\\n            revert FacetAddressIsZero();\\n        }\\n        if (_functionSelectors.length == 0) {\\n            revert NoSelectorsInFacet();\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            if (oldFacetAddress != address(0)) {\\n                revert FunctionAlreadyExists();\\n            }\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            unchecked {\\n                ++selectorPosition;\\n                ++selectorIndex;\\n            }\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        if (_functionSelectors.length == 0) {\\n            revert NoSelectorsInFacet();\\n        }\\n        if (_facetAddress == address(0)) {\\n            revert FacetAddressIsZero();\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            if (oldFacetAddress == _facetAddress) {\\n                revert FunctionAlreadyExists();\\n            }\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            unchecked {\\n                ++selectorPosition;\\n                ++selectorIndex;\\n            }\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        if (_functionSelectors.length == 0) {\\n            revert NoSelectorsInFacet();\\n        }\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        if (_facetAddress != address(0)) {\\n            revert FacetAddressIsNotZero();\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n            unchecked {\\n                ++selectorIndex;\\n            }\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress);\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        DiamondStorage storage ds,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        if (_facetAddress == address(0)) {\\n            revert FunctionDoesNotExist();\\n        }\\n        // an immutable function is a function defined directly in a diamond\\n        if (_facetAddress == address(this)) {\\n            revert FunctionIsImmutable();\\n        }\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            if (_calldata.length != 0) {\\n                revert InitZeroButCalldataNotEmpty();\\n            }\\n        } else {\\n            if (_calldata.length == 0) {\\n                revert CalldataEmptyButInitNotZero();\\n            }\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init);\\n            }\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert InitReverted();\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract) internal view {\\n        uint256 contractSize;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        if (contractSize == 0) {\\n            revert FacetContainsNoCode();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibInterchain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IUniswapV2.sol\\\";\\nimport \\\"../interfaces/IUniswapV3.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IRangoStargate.sol\\\";\\nimport \\\"../interfaces/IStargateReceiver.sol\\\";\\nimport \\\"../interfaces/IRangoMessageReceiver.sol\\\";\\nimport \\\"./LibSwapper.sol\\\";\\n\\nlibrary LibInterchain {\\n\\n    /// @dev keccak256(\\\"exchange.rango.library.interchain\\\")\\n    bytes32 internal constant BASE_MESSAGING_CONTRACT_NAMESPACE = hex\\\"ff95014231b901d2b22bd69b4e83dacd84ac05e8c2d1e9fba0c7e2f3ed0db0eb\\\";\\n\\n    struct BaseInterchainStorage {\\n        mapping (address => bool) whitelistMessagingContracts;\\n    }\\n\\n    // @notice Adds a contract to the whitelisted messaging dApps that can be called\\n    /// @param _dapp The address of dApp\\n    function addMessagingDApp(address _dapp) internal {\\n        BaseInterchainStorage storage baseStorage = getBaseMessagingContractStorage();\\n        baseStorage.whitelistMessagingContracts[_dapp] = true;\\n    }\\n\\n    /// @notice Removes a contract from dApps that can be called\\n    /// @param _dapp The address of dApp\\n    function removeMessagingDApp(address _dapp) internal {\\n        BaseInterchainStorage storage baseStorage = getBaseMessagingContractStorage();\\n\\n        require(baseStorage.whitelistMessagingContracts[_dapp], \\\"contract not whitelisted\\\");\\n        delete baseStorage.whitelistMessagingContracts[_dapp];\\n    }\\n\\n    /// @notice This event indicates that a dApp used Rango messaging (dAppMessage field) and we delivered the message to it\\n    /// @param _receiverContract The address of dApp's contract that was called\\n    /// @param _token The address of the token that is sent to the dApp, ETH for native token\\n    /// @param _amount The amount of the token sent to them\\n    /// @param _status The status of operation, informing the dApp that the whole process was a success or refund\\n    /// @param _appMessage The custom message that the dApp asked Rango to deliver\\n    /// @param success Indicates that the function call to the dApp encountered error or not\\n    /// @param failReason If success = false, failReason will be the string reason of the failure (aka message of require)\\n    event CrossChainMessageCalled(\\n        address _receiverContract,\\n        address _token,\\n        uint _amount,\\n        IRangoMessageReceiver.ProcessStatus _status,\\n        bytes _appMessage,\\n        bool success,\\n        string failReason\\n    );\\n\\n    event ActionDone(Interchain.ActionType actionType, address contractAddress, bool success, string reason);\\n    event SubActionDone(Interchain.CallSubActionType subActionType, address contractAddress, bool success, string reason);\\n\\n    function encodeIm(Interchain.RangoInterChainMessage memory im) external pure returns (bytes memory) {\\n        return abi.encode(im);\\n    }\\n\\n    function handleDestinationMessage(\\n        address _token,\\n        uint _amount,\\n        Interchain.RangoInterChainMessage memory m\\n    ) internal returns (address, uint256 dstAmount, IRango.CrossChainOperationStatus status) {\\n\\n        LibSwapper.BaseSwapperStorage storage baseStorage = LibSwapper.getBaseSwapperStorage();\\n        address sourceToken = m.bridgeRealOutput == LibSwapper.ETH && _token == baseStorage.WETH ? LibSwapper.ETH : _token;\\n\\n        bool ok = true;\\n        address receivedToken = sourceToken;\\n        dstAmount = _amount;\\n\\n        if (m.actionType == Interchain.ActionType.UNI_V2)\\n            (ok, dstAmount, receivedToken) = _handleUniswapV2(sourceToken, _amount, m, baseStorage);\\n        else if (m.actionType == Interchain.ActionType.UNI_V3)\\n            (ok, dstAmount, receivedToken) = _handleUniswapV3(sourceToken, _amount, m, baseStorage);\\n        else if (m.actionType == Interchain.ActionType.CALL)\\n            (ok, dstAmount, receivedToken) = _handleCall(sourceToken, _amount, m, baseStorage);\\n        else if (m.actionType != Interchain.ActionType.NO_ACTION)\\n            revert(\\\"Unsupported actionType\\\");\\n\\n        if (ok && m.postAction != Interchain.CallSubActionType.NO_ACTION) {\\n            (ok, dstAmount, receivedToken) = _handlePostAction(receivedToken, dstAmount, m.postAction, baseStorage);\\n        }\\n\\n        status = ok ? IRango.CrossChainOperationStatus.Succeeded : IRango.CrossChainOperationStatus.RefundInDestination;\\n        IRangoMessageReceiver.ProcessStatus dAppStatus = ok\\n            ? IRangoMessageReceiver.ProcessStatus.SUCCESS\\n            : IRangoMessageReceiver.ProcessStatus.REFUND_IN_DESTINATION;\\n\\n        _sendTokenWithDApp(receivedToken, dstAmount, m.recipient, m.dAppMessage, m.dAppDestContract, dAppStatus);\\n\\n        return (receivedToken, dstAmount, status);\\n    }\\n\\n    /// @notice Performs a uniswap-v2 operation\\n    /// @param _message The interchain message that contains the swap info\\n    /// @param _amount The amount of input token\\n    /// @return ok Indicates that the swap operation was success or fail\\n    /// @return amountOut If ok = true, amountOut is the output amount of the swap\\n    function _handleUniswapV2(\\n        address _token,\\n        uint _amount,\\n        Interchain.RangoInterChainMessage memory _message,\\n        LibSwapper.BaseSwapperStorage storage baseStorage\\n    ) private returns (bool ok, uint256 amountOut, address outToken) {\\n        Interchain.UniswapV2Action memory action = abi.decode((_message.action), (Interchain.UniswapV2Action));\\n        if (baseStorage.whitelistContracts[action.dexAddress] != true) {\\n            // \\\"Dex address is not whitelisted\\\"\\n            return (false, _amount, _token);\\n        }\\n        if (action.path.length < 2) {\\n            // \\\"Invalid uniswap-V2 path\\\"\\n            return (false, _amount, _token);\\n        }\\n\\n        bool shouldDeposit = _token == LibSwapper.ETH && action.path[0] == baseStorage.WETH;\\n        if (!shouldDeposit) {\\n            if (_token != action.path[0]) {\\n                // \\\"bridged token must be the same as the first token in destination swap path\\\"\\n                return (false, _amount, _token);\\n            }\\n        } else {\\n            IWETH(baseStorage.WETH).deposit{value : _amount}();\\n        }\\n\\n        LibSwapper.approve(action.path[0], action.dexAddress, _amount);\\n\\n        address toToken = action.path[action.path.length - 1];\\n        uint toBalanceBefore = LibSwapper.getBalanceOf(toToken);\\n\\n        try\\n            IUniswapV2(action.dexAddress).swapExactTokensForTokens(\\n                _amount,\\n                action.amountOutMin,\\n                action.path,\\n                address(this),\\n                action.deadline\\n            )\\n        returns (uint256[] memory) {\\n            emit ActionDone(Interchain.ActionType.UNI_V2, action.dexAddress, true, \\\"\\\");\\n            // Note: instead of using return amounts of swapExactTokensForTokens,\\n            //       we get the diff balance of before and after. This prevents errors for tokens with transfer fees\\n            uint toBalanceAfter = LibSwapper.getBalanceOf(toToken);\\n            SafeERC20.safeApprove(IERC20(action.path[0]), action.dexAddress, 0);\\n            return (true, toBalanceAfter - toBalanceBefore, toToken);\\n        } catch {\\n            emit ActionDone(Interchain.ActionType.UNI_V2, action.dexAddress, true, \\\"Uniswap-V2 call failed\\\");\\n            SafeERC20.safeApprove(IERC20(action.path[0]), action.dexAddress, 0);\\n            return (false, _amount, shouldDeposit ? baseStorage.WETH : _token);\\n        }\\n    }\\n\\n    /// @notice Performs a uniswap-v3 operation\\n    /// @param _message The interchain message that contains the swap info\\n    /// @param _amount The amount of input token\\n    /// @return ok Indicates that the swap operation was success or fail\\n    /// @return amountOut If ok = true, amountOut is the output amount of the swap\\n    function _handleUniswapV3(\\n        address _token,\\n        uint _amount,\\n        Interchain.RangoInterChainMessage memory _message,\\n        LibSwapper.BaseSwapperStorage storage baseStorage\\n    ) private returns (bool, uint256, address) {\\n        Interchain.UniswapV3ActionExactInputSingleParams memory action = abi\\n            .decode((_message.action), (Interchain.UniswapV3ActionExactInputSingleParams));\\n\\n        if (baseStorage.whitelistContracts[action.dexAddress] != true) {\\n            // \\\"Dex address is not whitelisted\\\"\\n            return (false, _amount, _token);\\n        }\\n\\n        bool shouldDeposit = _token == LibSwapper.ETH && action.tokenIn == baseStorage.WETH;\\n        if (!shouldDeposit) {\\n            if (_token != action.tokenIn) {\\n                // \\\"bridged token must be the same as the tokenIn in uniswapV3\\\"\\n                return (false, _amount, _token);\\n            }\\n        } else {\\n            IWETH(baseStorage.WETH).deposit{value : _amount}();\\n        }\\n\\n        LibSwapper.approve(action.tokenIn, action.dexAddress, _amount);\\n        uint toBalanceBefore = LibSwapper.getBalanceOf(action.tokenOut);\\n\\n        try\\n            IUniswapV3(action.dexAddress).exactInputSingle(IUniswapV3.ExactInputSingleParams({\\n                tokenIn : action.tokenIn,\\n                tokenOut : action.tokenOut,\\n                fee : action.fee,\\n                recipient : address(this),\\n                deadline : action.deadline,\\n                amountIn : _amount,\\n                amountOutMinimum : action.amountOutMinimum,\\n                sqrtPriceLimitX96 : action.sqrtPriceLimitX96\\n            }))\\n        returns (uint) {\\n            emit ActionDone(Interchain.ActionType.UNI_V3, action.dexAddress, true, \\\"\\\");\\n            // Note: instead of using return amounts of exactInputSingle,\\n            //       we get the diff balance of before and after. This prevents errors for tokens with transfer fees.\\n            uint toBalanceAfter = LibSwapper.getBalanceOf(action.tokenOut);\\n            SafeERC20.safeApprove(IERC20(action.tokenIn), action.dexAddress, 0);\\n            return (true, toBalanceAfter - toBalanceBefore, action.tokenOut);\\n        } catch {\\n            emit ActionDone(Interchain.ActionType.UNI_V3, action.dexAddress, false, \\\"Uniswap-V3 call failed\\\");\\n            SafeERC20.safeApprove(IERC20(action.tokenIn), action.dexAddress, 0);\\n            return (false, _amount, shouldDeposit ? baseStorage.WETH : _token);\\n        }\\n    }\\n\\n    /// @notice Performs a uniswap-v2 operation\\n    /// @param _message The interchain message that contains the swap info\\n    /// @param _amount The amount of input token\\n    /// @return ok Indicates that the swap operation was success or fail\\n    /// @return amountOut If ok = true, amountOut is the output amount of the swap\\n    function _handleCall(\\n        address _token,\\n        uint _amount,\\n        Interchain.RangoInterChainMessage memory _message,\\n        LibSwapper.BaseSwapperStorage storage baseStorage\\n    ) private returns (bool ok, uint256 amountOut, address outToken) {\\n        Interchain.CallAction memory action = abi.decode((_message.action), (Interchain.CallAction));\\n\\n        if (baseStorage.whitelistContracts[action.target] != true) {\\n            // \\\"Action.target is not whitelisted\\\"\\n            return (false, _amount, _token);\\n        }\\n        if (baseStorage.whitelistContracts[action.spender] != true) {\\n            // \\\"Action.spender is not whitelisted\\\"\\n            return (false, _amount, _token);\\n        }\\n\\n        address sourceToken = _token;\\n\\n        if (action.preAction == Interchain.CallSubActionType.WRAP) {\\n            if (_token != LibSwapper.ETH) {\\n                // \\\"Cannot wrap non-native\\\"\\n                return (false, _amount, _token);\\n            }\\n            if (action.tokenIn != baseStorage.WETH) {\\n                // \\\"action.tokenIn must be WETH\\\"\\n                return (false, _amount, _token);\\n            }\\n            (ok, amountOut, sourceToken) = _handleWrap(_token, _amount, baseStorage);\\n        } else if (action.preAction == Interchain.CallSubActionType.UNWRAP) {\\n            if (_token != baseStorage.WETH) {\\n                // \\\"Cannot unwrap non-WETH\\\"\\n                return (false, _amount, _token);\\n            }\\n            if (action.tokenIn != LibSwapper.ETH) {\\n                // \\\"action.tokenIn must be ETH\\\"\\n                return (false, _amount, _token);\\n            }\\n            (ok, amountOut, sourceToken) = _handleUnwrap(_token, _amount, baseStorage);\\n        } else {\\n            ok = true;\\n            if (action.tokenIn != _token) {\\n                // \\\"_message.tokenIn mismatch in call\\\"\\n                return (false, _amount, _token);\\n            }\\n        }\\n        if (!ok)\\n            return (false, _amount, _token);\\n\\n        if (sourceToken != LibSwapper.ETH)\\n            LibSwapper.approve(sourceToken, action.spender, _amount);\\n\\n        uint value = sourceToken == LibSwapper.ETH ? _amount : 0;\\n        uint toBalanceBefore = LibSwapper.getBalanceOf(_message.toToken);\\n\\n        (bool success, bytes memory ret) = action.target.call{value: value}(action.callData);\\n\\n        if (sourceToken != LibSwapper.ETH)\\n            SafeERC20.safeApprove(IERC20(sourceToken), action.spender, 0);\\n\\n        if (success) {\\n            emit ActionDone(Interchain.ActionType.CALL, action.target, true, \\\"\\\");\\n            uint toBalanceAfter = LibSwapper.getBalanceOf(_message.toToken);\\n            return (true, toBalanceAfter - toBalanceBefore, _message.toToken);\\n        } else {\\n            emit ActionDone(Interchain.ActionType.CALL, action.target, false, LibSwapper._getRevertMsg(ret));\\n            return (false, _amount, sourceToken);\\n        }\\n    }\\n\\n    /// @notice Performs a uniswap-v2 operation\\n    /// @param _postAction The type of action to perform such as WRAP, UNWRAP\\n    /// @param _amount The amount of input token\\n    /// @return ok Indicates that the swap operation was success or fail\\n    /// @return amountOut If ok = true, amountOut is the output amount of the swap\\n    function _handlePostAction(\\n        address _token,\\n        uint _amount,\\n        Interchain.CallSubActionType _postAction,\\n        LibSwapper.BaseSwapperStorage storage baseStorage\\n    ) private returns (bool ok, uint256 amountOut, address outToken) {\\n\\n        if (_postAction == Interchain.CallSubActionType.WRAP) {\\n            if (_token != LibSwapper.ETH) {\\n                // \\\"Cannot wrap non-native\\\"\\n                return (false, _amount, _token);\\n            }\\n            (ok, amountOut, outToken) = _handleWrap(_token, _amount, baseStorage);\\n        } else if (_postAction == Interchain.CallSubActionType.UNWRAP) {\\n            if (_token != baseStorage.WETH) {\\n                // \\\"Cannot unwrap non-WETH\\\"\\n                return (false, _amount, _token);\\n            }\\n            (ok, amountOut, outToken) = _handleUnwrap(_token, _amount, baseStorage);\\n        } else {\\n            // revert(\\\"Unsupported post-action\\\");\\n            return (false, _amount, _token);\\n        }\\n        if (!ok)\\n            return (false, _amount, _token);\\n        return (ok, amountOut, outToken);\\n    }\\n\\n    /// @notice Performs a WETH.deposit operation\\n    /// @param _amount The amount of input token\\n    /// @return ok Indicates that the swap operation was success or fail\\n    /// @return amountOut If ok = true, amountOut is the output amount of the swap\\n    function _handleWrap(\\n        address _token,\\n        uint _amount,\\n        LibSwapper.BaseSwapperStorage storage baseStorage\\n    ) private returns (bool ok, uint256 amountOut, address outToken) {\\n        if (_token != LibSwapper.ETH) {\\n            // \\\"Cannot wrap non-ETH tokens\\\"\\n            return (false, _amount, _token);\\n        }\\n\\n        IWETH(baseStorage.WETH).deposit{value: _amount}();\\n        emit SubActionDone(Interchain.CallSubActionType.WRAP, baseStorage.WETH, true, \\\"\\\");\\n\\n        return (true, _amount, baseStorage.WETH);\\n    }\\n\\n    /// @notice Performs a WETH.deposit operation\\n    /// @param _amount The amount of input token\\n    /// @return ok Indicates that the swap operation was success or fail\\n    /// @return amountOut If ok = true, amountOut is the output amount of the swap\\n    function _handleUnwrap(\\n        address _token,\\n        uint _amount,\\n        LibSwapper.BaseSwapperStorage storage baseStorage\\n    ) private returns (bool ok, uint256 amountOut, address outToken) {\\n        if (_token != baseStorage.WETH)\\n            // revert(\\\"Non-WETH tokens unwrapped\\\");\\n            return (false, _amount, _token);\\n\\n        IWETH(baseStorage.WETH).withdraw(_amount);\\n        emit SubActionDone(Interchain.CallSubActionType.UNWRAP, baseStorage.WETH, true, \\\"\\\");\\n\\n        return (true, _amount, LibSwapper.ETH);\\n    }\\n\\n    /// @notice An internal function to send a token from the current contract to another contract or wallet\\n    /// @dev This function also can convert WETH to ETH before sending if _withdraw flat is set to true\\n    /// @dev To send native token _nativeOut param should be set to true, otherwise we assume it's an ERC20 transfer\\n    /// @dev If there is a message from a dApp it sends the money to the contract instead of the end-user and calls its handleRangoMessage\\n    /// @param _token The token that is going to be sent to a wallet, ZERO address for native\\n    /// @param _amount The sent amount\\n    /// @param _receiver The receiver wallet address or contract\\n    function _sendTokenWithDApp(\\n        address _token,\\n        uint256 _amount,\\n        address _receiver,\\n        bytes memory _dAppMessage,\\n        address _dAppReceiverContract,\\n        IRangoMessageReceiver.ProcessStatus processStatus\\n    ) internal {\\n        bool thereIsAMessage = _dAppReceiverContract != LibSwapper.ETH;\\n        address immediateReceiver = thereIsAMessage ? _dAppReceiverContract : _receiver;\\n        BaseInterchainStorage storage messagingStorage = getBaseMessagingContractStorage();\\n        emit LibSwapper.SendToken(_token, _amount, immediateReceiver);\\n\\n        if (_token == LibSwapper.ETH) {\\n            LibSwapper._sendNative(immediateReceiver, _amount);\\n        } else {\\n            SafeERC20.safeTransfer(IERC20(_token), immediateReceiver, _amount);\\n        }\\n\\n        if (thereIsAMessage) {\\n            require(\\n                messagingStorage.whitelistMessagingContracts[_dAppReceiverContract],\\n                \\\"3rd-party contract not whitelisted\\\"\\n            );\\n\\n            try IRangoMessageReceiver(_dAppReceiverContract)\\n                .handleRangoMessage(_token, _amount, processStatus, _dAppMessage)\\n            {\\n                emit CrossChainMessageCalled(_dAppReceiverContract, _token, _amount, processStatus, _dAppMessage, true, \\\"\\\");\\n            } catch Error(string memory reason) {\\n                emit CrossChainMessageCalled(_dAppReceiverContract, _token, _amount, processStatus, _dAppMessage, false, reason);\\n            } catch (bytes memory lowLevelData) {\\n                emit CrossChainMessageCalled(_dAppReceiverContract, _token, _amount, processStatus, _dAppMessage, false, LibSwapper._getRevertMsg(lowLevelData));\\n            }\\n        }\\n    }\\n\\n    /// @notice A utility function to fetch storage from a predefined random slot using assembly\\n    /// @return s The storage object\\n    function getBaseMessagingContractStorage() internal pure returns (BaseInterchainStorage storage s) {\\n        bytes32 namespace = BASE_MESSAGING_CONTRACT_NAMESPACE;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            s.slot := namespace\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/LibSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IWETH.sol\\\";\\nimport \\\"../interfaces/IRango.sol\\\";\\n\\n/// @title BaseSwapper\\n/// @author 0xiden\\n/// @notice library to provide swap functionality\\nlibrary LibSwapper {\\n\\n    /// @dev keccak256(\\\"exchange.rango.library.swapper\\\")\\n    bytes32 internal constant BASE_SWAPPER_NAMESPACE = hex\\\"43da06808a8e54e76a41d6f7b48ddfb23969b1387a8710ef6241423a5aefe64a\\\";\\n\\n    address payable constant ETH = payable(0x0000000000000000000000000000000000000000);\\n\\n    struct BaseSwapperStorage {\\n        address payable feeContractAddress;\\n        address WETH;\\n        mapping(address => bool) whitelistContracts;\\n        mapping(address => mapping(bytes4 => bool)) whitelistMethods;\\n    }\\n\\n    /// @notice Emitted if any fee transfer was required\\n    /// @param token The address of received token, address(0) for native\\n    /// @param affiliatorAddress The address of affiliate wallet\\n    /// @param platformFee The amount received as platform fee\\n    /// @param destinationExecutorFee The amount received to execute transaction on destination (only for cross chain txs)\\n    /// @param affiliateFee The amount received by affiliate\\n    /// @param dAppTag Optional identifier to make tracking easier.\\n    event FeeInfo(\\n        address token,\\n        address indexed affiliatorAddress,\\n        uint platformFee,\\n        uint destinationExecutorFee,\\n        uint affiliateFee,\\n        uint16 indexed dAppTag\\n    );\\n\\n    /// @notice A call to another dex or contract done and here is the result\\n    /// @param target The address of dex or contract that is called\\n    /// @param success A boolean indicating that the call was success or not\\n    /// @param returnData The response of function call\\n    event CallResult(address target, bool success, bytes returnData);\\n\\n    /// @notice A swap request is done and we also emit the output\\n    /// @param requestId Optional parameter to make tracking of transaction easier\\n    /// @param fromToken Input token address to be swapped from\\n    /// @param toToken Output token address to be swapped to\\n    /// @param amountIn Input amount of fromToken that is being swapped\\n    /// @param dAppTag Optional identifier to make tracking easier\\n    /// @param outputAmount The output amount of the swap, measured by the balance change before and after the swap\\n    /// @param receiver The address to receive the output of swap. Can be address(0) when swap is before a bridge action\\n    event RangoSwap(\\n        address indexed requestId,\\n        address fromToken,\\n        address toToken,\\n        uint amountIn,\\n        uint minimumAmountExpected,\\n        uint16 indexed dAppTag,\\n        uint outputAmount,\\n        address receiver\\n    );\\n\\n    /// @notice Output amount of a dex calls is logged\\n    /// @param _token The address of output token, ZERO address for native\\n    /// @param amount The amount of output\\n    event DexOutput(address _token, uint amount);\\n\\n    /// @notice The output money (ERC20/Native) is sent to a wallet\\n    /// @param _token The token that is sent to a wallet, ZERO address for native\\n    /// @param _amount The sent amount\\n    /// @param _receiver The receiver wallet address\\n    event SendToken(address _token, uint256 _amount, address _receiver);\\n\\n\\n    /// @notice Notifies that Rango's fee receiver address updated\\n    /// @param _oldAddress The previous fee wallet address\\n    /// @param _newAddress The new fee wallet address\\n    event FeeContractAddressUpdated(address _oldAddress, address _newAddress);\\n\\n    /// @notice Notifies that WETH address is updated\\n    /// @param _oldAddress The previous weth address\\n    /// @param _newAddress The new weth address\\n    event WethContractAddressUpdated(address _oldAddress, address _newAddress);\\n\\n    /// @notice Notifies that admin manually refunded some money\\n    /// @param _token The address of refunded token, 0x000..00 address for native token\\n    /// @param _amount The amount that is refunded\\n    event Refunded(address _token, uint _amount);\\n\\n    /// @notice The requested call data which is computed off-chain and passed to the contract\\n    /// @dev swapFromToken and amount parameters are only helper params and the actual amount and\\n    /// token are set in callData\\n    /// @param spender The contract which the approval is given to if swapFromToken is not native.\\n    /// @param target The dex contract address that should be called\\n    /// @param swapFromToken Token address of to be used in the swap.\\n    /// @param amount The amount to be approved or native amount sent.\\n    /// @param callData The required data field that should be give to the dex contract to perform swap\\n    struct Call {\\n        address spender;\\n        address payable target;\\n        address swapFromToken;\\n        address swapToToken;\\n        bool needsTransferFromUser;\\n        uint amount;\\n        bytes callData;\\n    }\\n\\n    /// @notice General swap request which is given to us in all relevant functions\\n    /// @param requestId The request id passed to make tracking transactions easier\\n    /// @param fromToken The source token that is going to be swapped (in case of simple swap or swap + bridge) or the briding token (in case of solo bridge)\\n    /// @param toToken The output token of swapping. This is the output of DEX step and is also input of bridging step\\n    /// @param amountIn The amount of input token to be swapped\\n    /// @param platformFee The amount of fee charged by platform\\n    /// @param destinationExecutorFee The amount of fee required for relayer execution on the destination\\n    /// @param affiliateFee The amount of fee charged by affiliator dApp\\n    /// @param affiliatorAddress The wallet address that the affiliator fee should be sent to\\n    /// @param minimumAmountExpected The minimum amount of toToken expected after executing Calls\\n    /// @param dAppTag An optional parameter\\n    struct SwapRequest {\\n        address requestId;\\n        address fromToken;\\n        address toToken;\\n        uint amountIn;\\n        uint platformFee;\\n        uint destinationExecutorFee;\\n        uint affiliateFee;\\n        address payable affiliatorAddress;\\n        uint minimumAmountExpected;\\n        uint16 dAppTag;\\n    }\\n\\n    /// @notice initializes the base swapper and sets the init params (such as Wrapped token address)\\n    /// @param _weth Address of wrapped token (WETH, WBNB, etc.) on the current chain\\n    function setWeth(address _weth) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n        address oldAddress = baseStorage.WETH;\\n        baseStorage.WETH = _weth;\\n        require(_weth != address(0), \\\"Invalid WETH!\\\");\\n        emit WethContractAddressUpdated(oldAddress, _weth);\\n    }\\n\\n    /// @notice Sets the wallet that receives Rango's fees from now on\\n    /// @param _address The receiver wallet address\\n    function updateFeeContractAddress(address payable _address) internal {\\n        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();\\n\\n        address oldAddress = baseSwapperStorage.feeContractAddress;\\n        baseSwapperStorage.feeContractAddress = _address;\\n\\n        emit FeeContractAddressUpdated(oldAddress, _address);\\n    }\\n\\n    /// Whitelist ///\\n\\n    /// @notice Adds a contract to the whitelisted DEXes that can be called\\n    /// @param contractAddress The address of the DEX\\n    function addWhitelist(address contractAddress) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n        baseStorage.whitelistContracts[contractAddress] = true;\\n    }\\n\\n    /// @notice Adds a method of contract to the whitelisted DEXes that can be called\\n    /// @param contractAddress The address of the DEX\\n    /// @param methodIds The method of the DEX\\n    function addMethodWhitelists(address contractAddress, bytes4[] calldata methodIds) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n\\n        baseStorage.whitelistContracts[contractAddress] = true;\\n        for (uint i = 0; i < methodIds.length; i++)\\n            baseStorage.whitelistMethods[contractAddress][methodIds[i]] = true;\\n    }\\n\\n    /// @notice Adds a method of contract to the whitelisted DEXes that can be called\\n    /// @param contractAddress The address of the DEX\\n    /// @param methodId The method of the DEX\\n    function addMethodWhitelist(address contractAddress, bytes4 methodId) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n\\n        baseStorage.whitelistContracts[contractAddress] = true;\\n        baseStorage.whitelistMethods[contractAddress][methodId] = true;\\n    }\\n\\n    /// @notice Removes a contract from the whitelisted DEXes\\n    /// @param contractAddress The address of the DEX or dApp\\n    function removeWhitelist(address contractAddress) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n\\n        delete baseStorage.whitelistContracts[contractAddress];\\n    }\\n\\n    /// @notice Removes a method of contract from the whitelisted DEXes\\n    /// @param contractAddress The address of the DEX or dApp\\n    /// @param methodId The method of the DEX\\n    function removeMethodWhitelist(address contractAddress, bytes4 methodId) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n\\n        delete baseStorage.whitelistMethods[contractAddress][methodId];\\n    }\\n\\n    function onChainSwapsPreBridge(\\n        SwapRequest memory request,\\n        Call[] calldata calls,\\n        uint extraFee\\n    ) internal returns (uint out) {\\n\\n        bool isNative = request.fromToken == ETH;\\n        uint minimumRequiredValue = (isNative ? request.platformFee + request.affiliateFee + request.amountIn + request.destinationExecutorFee : 0) + extraFee;\\n        require(msg.value >= minimumRequiredValue, 'Send more ETH to cover input amount + fee');\\n\\n        (, out) = onChainSwapsInternal(request, calls, extraFee);\\n        // when there is a bridge after swap, set the receiver in swap event to address(0)\\n        emitSwapEvent(request, out, ETH);\\n\\n        return out;\\n    }\\n\\n    /// @notice Internal function to compute output amount of DEXes\\n    /// @param request The general swap request containing from/to token and fee/affiliate rewards\\n    /// @param calls The list of DEX calls\\n    /// @param extraNativeFee The amount of native tokens to keep and not return to user as excess amount.\\n    /// @return The response of all DEX calls and the output amount of the whole process\\n    function onChainSwapsInternal(\\n        SwapRequest memory request,\\n        Call[] calldata calls,\\n        uint256 extraNativeFee\\n    ) internal returns (bytes[] memory, uint) {\\n\\n        uint toBalanceBefore = getBalanceOf(request.toToken);\\n        uint fromBalanceBefore = getBalanceOf(request.fromToken);\\n        uint256[] memory initialBalancesList = getInitialBalancesList(calls);\\n\\n        // transfer tokens from user for SwapRequest and Calls that require transfer from user.\\n        transferTokensFromUserForSwapRequest(request);\\n        transferTokensFromUserForCalls(calls);\\n\\n        bytes[] memory result = callSwapsAndFees(request, calls);\\n\\n        // check if any extra tokens were taken from contract and return excess tokens if any.\\n        returnExcessAmounts(request, calls, initialBalancesList);\\n\\n        // get balance after returning excesses.\\n        uint fromBalanceAfter = getBalanceOf(request.fromToken);\\n\\n        // check over-expense of fromToken and return excess if any.\\n        if (request.fromToken != ETH) {\\n            require(fromBalanceAfter >= fromBalanceBefore, \\\"Source token balance on contract must not decrease after swap\\\");\\n            if (fromBalanceAfter > fromBalanceBefore)\\n                _sendToken(request.fromToken, fromBalanceAfter - fromBalanceBefore, msg.sender);\\n        }\\n        else {\\n            require(fromBalanceAfter >= fromBalanceBefore - msg.value, \\\"Source token balance on contract must not decrease after swap\\\");\\n            // When we are keeping extraNativeFee for bridgingFee, we should consider it in calculations.\\n            if (fromBalanceAfter > fromBalanceBefore - msg.value + extraNativeFee)\\n                _sendToken(request.fromToken, fromBalanceAfter + msg.value - fromBalanceBefore - extraNativeFee, msg.sender);\\n        }\\n\\n        uint toBalanceAfter = getBalanceOf(request.toToken);\\n\\n        uint secondaryBalance = toBalanceAfter - toBalanceBefore;\\n        require(secondaryBalance >= request.minimumAmountExpected, \\\"Output is less than minimum expected\\\");\\n\\n        return (result, secondaryBalance);\\n    }\\n\\n    /// @notice Private function to handle fetching money from wallet to contract, reduce fee/affiliate, perform DEX calls\\n    /// @param request The general swap request containing from/to token and fee/affiliate rewards\\n    /// @param calls The list of DEX calls\\n    /// @dev It checks the whitelisting of all DEX addresses + having enough msg.value as input\\n    /// @return The bytes of all DEX calls response\\n    function callSwapsAndFees(SwapRequest memory request, Call[] calldata calls) private returns (bytes[] memory) {\\n        bool isSourceNative = request.fromToken == ETH;\\n        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();\\n\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            require(baseSwapperStorage.whitelistContracts[calls[i].spender], \\\"Contract spender not whitelisted\\\");\\n            require(baseSwapperStorage.whitelistContracts[calls[i].target], \\\"Contract target not whitelisted\\\");\\n            bytes4 sig = bytes4(calls[i].callData[: 4]);\\n            require(baseSwapperStorage.whitelistMethods[calls[i].target][sig], \\\"Unauthorized call data!\\\");\\n        }\\n\\n        // Get Platform fee\\n        bool hasPlatformFee = request.platformFee > 0;\\n        bool hasDestExecutorFee = request.destinationExecutorFee > 0;\\n        bool hasAffiliateFee = request.affiliateFee > 0;\\n        if (hasPlatformFee || hasDestExecutorFee) {\\n            require(baseSwapperStorage.feeContractAddress != ETH, \\\"Fee contract address not set\\\");\\n            _sendToken(request.fromToken, request.platformFee + request.destinationExecutorFee, baseSwapperStorage.feeContractAddress, isSourceNative, false);\\n        }\\n\\n        // Get affiliate fee\\n        if (hasAffiliateFee) {\\n            require(request.affiliatorAddress != ETH, \\\"Invalid affiliatorAddress\\\");\\n            _sendToken(request.fromToken, request.affiliateFee, request.affiliatorAddress, isSourceNative, false);\\n        }\\n\\n        // emit Fee event\\n        if (hasPlatformFee || hasDestExecutorFee || hasAffiliateFee) {\\n            emit FeeInfo(\\n                request.fromToken,\\n                request.affiliatorAddress,\\n                request.platformFee,\\n                request.destinationExecutorFee,\\n                request.affiliateFee,\\n                request.dAppTag\\n            );\\n        }\\n\\n        // Execute swap Calls\\n        bytes[] memory returnData = new bytes[](calls.length);\\n        address tmpSwapFromToken;\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            tmpSwapFromToken = calls[i].swapFromToken;\\n            bool isTokenNative = tmpSwapFromToken == ETH;\\n            if (isTokenNative == false)\\n                approveMax(tmpSwapFromToken, calls[i].spender, calls[i].amount);\\n\\n            (bool success, bytes memory ret) = isTokenNative\\n            ? calls[i].target.call{value : calls[i].amount}(calls[i].callData)\\n            : calls[i].target.call(calls[i].callData);\\n\\n            emit CallResult(calls[i].target, success, ret);\\n            if (!success)\\n                revert(_getRevertMsg(ret));\\n            returnData[i] = ret;\\n        }\\n\\n        return returnData;\\n    }\\n\\n    /// @notice Approves an ERC20 token to a contract to transfer from the current contract\\n    /// @param token The address of an ERC20 token\\n    /// @param spender The contract address that should be approved\\n    /// @param value The amount that should be approved\\n    function approve(address token, address spender, uint value) internal {\\n        SafeERC20.safeApprove(IERC20(token), spender, 0);\\n        SafeERC20.safeIncreaseAllowance(IERC20(token), spender, value);\\n    }\\n\\n    /// @notice Approves an ERC20 token to a contract to transfer from the current contract, approves for inf value\\n    /// @param token The address of an ERC20 token\\n    /// @param spender The contract address that should be approved\\n    /// @param value The desired allowance. If current allowance is less than this value, infinite allowance will be given\\n    function approveMax(address token, address spender, uint value) internal {\\n        uint256 currentAllowance = IERC20(token).allowance(address(this), spender);\\n        if (currentAllowance < value) {\\n            if (currentAllowance != 0) {\\n                // We set allowance to 0 if not already. tokens such as USDT require zero allowance first.\\n                SafeERC20.safeApprove(IERC20(token), spender, 0);\\n            }\\n            SafeERC20.safeIncreaseAllowance(IERC20(token), spender, type(uint256).max);\\n        }\\n    }\\n\\n    function _sendToken(address _token, uint256 _amount, address _receiver) internal {\\n        (_token == ETH) ? _sendNative(_receiver, _amount) : SafeERC20.safeTransfer(IERC20(_token), _receiver, _amount);\\n    }\\n\\n    function sumFees(IRango.RangoBridgeRequest memory request) internal pure returns (uint256) {\\n        return request.platformFee + request.affiliateFee + request.destinationExecutorFee;\\n    }\\n\\n    function sumFees(SwapRequest memory request) internal pure returns (uint256) {\\n        return request.platformFee + request.affiliateFee + request.destinationExecutorFee;\\n    }\\n\\n    function collectFees(IRango.RangoBridgeRequest memory request) internal {\\n        // Get Platform fee\\n        bool hasPlatformFee = request.platformFee > 0;\\n        bool hasDestExecutorFee = request.destinationExecutorFee > 0;\\n        bool hasAffiliateFee = request.affiliateFee > 0;\\n        bool hasAnyFee = hasPlatformFee || hasDestExecutorFee || hasAffiliateFee;\\n        if (!hasAnyFee) {\\n            return;\\n        }\\n        bool isSourceNative = request.token == ETH;\\n        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();\\n\\n        if (hasPlatformFee || hasDestExecutorFee) {\\n            require(baseSwapperStorage.feeContractAddress != ETH, \\\"Fee contract address not set\\\");\\n            _sendToken(request.token, request.platformFee + request.destinationExecutorFee, baseSwapperStorage.feeContractAddress, isSourceNative, false);\\n        }\\n\\n        // Get affiliate fee\\n        if (hasAffiliateFee) {\\n            require(request.affiliatorAddress != ETH, \\\"Invalid affiliatorAddress\\\");\\n            _sendToken(request.token, request.affiliateFee, request.affiliatorAddress, isSourceNative, false);\\n        }\\n\\n        // emit Fee event\\n        emit FeeInfo(\\n            request.token,\\n            request.affiliatorAddress,\\n            request.platformFee,\\n            request.destinationExecutorFee,\\n            request.affiliateFee,\\n            request.dAppTag\\n        );\\n    }\\n\\n    function collectFeesFromSender(IRango.RangoBridgeRequest memory request) internal {\\n        // Get Platform fee\\n        bool hasPlatformFee = request.platformFee > 0;\\n        bool hasDestExecutorFee = request.destinationExecutorFee > 0;\\n        bool hasAffiliateFee = request.affiliateFee > 0;\\n        bool hasAnyFee = hasPlatformFee || hasDestExecutorFee || hasAffiliateFee;\\n        if (!hasAnyFee) {\\n            return;\\n        }\\n        bool isSourceNative = request.token == ETH;\\n        BaseSwapperStorage storage baseSwapperStorage = getBaseSwapperStorage();\\n\\n        if (hasPlatformFee || hasDestExecutorFee) {\\n            require(baseSwapperStorage.feeContractAddress != ETH, \\\"Fee contract address not set\\\");\\n            if (isSourceNative)\\n                _sendToken(request.token, request.platformFee + request.destinationExecutorFee, baseSwapperStorage.feeContractAddress, isSourceNative, false);\\n            else\\n                SafeERC20.safeTransferFrom(\\n                    IERC20(request.token),\\n                    msg.sender,\\n                    baseSwapperStorage.feeContractAddress,\\n                    request.platformFee + request.destinationExecutorFee\\n                );\\n        }\\n\\n        // Get affiliate fee\\n        if (hasAffiliateFee) {\\n            require(request.affiliatorAddress != ETH, \\\"Invalid affiliatorAddress\\\");\\n            if (isSourceNative)\\n                _sendToken(request.token, request.affiliateFee, request.affiliatorAddress, isSourceNative, false);\\n            else\\n                SafeERC20.safeTransferFrom(\\n                    IERC20(request.token),\\n                    msg.sender,\\n                    request.affiliatorAddress,\\n                    request.affiliateFee\\n                );\\n        }\\n\\n        // emit Fee event\\n        emit FeeInfo(\\n            request.token,\\n            request.affiliatorAddress,\\n            request.platformFee,\\n            request.destinationExecutorFee,\\n            request.affiliateFee,\\n            request.dAppTag\\n        );\\n    }\\n\\n    /// @notice An internal function to send a token from the current contract to another contract or wallet\\n    /// @dev This function also can convert WETH to ETH before sending if _withdraw flat is set to true\\n    /// @dev To send native token _nativeOut param should be set to true, otherwise we assume it's an ERC20 transfer\\n    /// @param _token The token that is going to be sent to a wallet, ZERO address for native\\n    /// @param _amount The sent amount\\n    /// @param _receiver The receiver wallet address or contract\\n    /// @param _nativeOut means the output is native token\\n    /// @param _withdraw If true, indicates that we should swap WETH to ETH before sending the money and _nativeOut must also be true\\n    function _sendToken(\\n        address _token,\\n        uint256 _amount,\\n        address _receiver,\\n        bool _nativeOut,\\n        bool _withdraw\\n    ) internal {\\n        BaseSwapperStorage storage baseStorage = getBaseSwapperStorage();\\n        emit SendToken(_token, _amount, _receiver);\\n\\n        if (_nativeOut) {\\n            if (_withdraw) {\\n                require(_token == baseStorage.WETH, \\\"token mismatch\\\");\\n                IWETH(baseStorage.WETH).withdraw(_amount);\\n            }\\n            _sendNative(_receiver, _amount);\\n        } else {\\n            SafeERC20.safeTransfer(IERC20(_token), _receiver, _amount);\\n        }\\n    }\\n\\n    /// @notice An internal function to send native token to a contract or wallet\\n    /// @param _receiver The address that will receive the native token\\n    /// @param _amount The amount of the native token that should be sent\\n    function _sendNative(address _receiver, uint _amount) internal {\\n        (bool sent,) = _receiver.call{value : _amount}(\\\"\\\");\\n        require(sent, \\\"failed to send native\\\");\\n    }\\n\\n\\n    /// @notice A utility function to fetch storage from a predefined random slot using assembly\\n    /// @return s The storage object\\n    function getBaseSwapperStorage() internal pure returns (BaseSwapperStorage storage s) {\\n        bytes32 namespace = BASE_SWAPPER_NAMESPACE;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            s.slot := namespace\\n        }\\n    }\\n\\n    /// @notice To extract revert message from a DEX/contract call to represent to the end-user in the blockchain\\n    /// @param _returnData The resulting bytes of a failed call to a DEX or contract\\n    /// @return A string that describes what was the error\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return 'Transaction reverted silently';\\n\\n        assembly {\\n        // Slice the sighash.\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string));\\n        // All that remains is the revert string\\n    }\\n\\n    function getBalanceOf(address token) internal view returns (uint) {\\n        return token == ETH ? address(this).balance : IERC20(token).balanceOf(address(this));\\n    }\\n\\n    /// @notice Fetches the balances of swapToTokens.\\n    /// @dev this fetches the balances for swapToToken of swap Calls. If native eth is received, the balance has already increased so we subtract msg.value.\\n    function getInitialBalancesList(Call[] calldata calls) internal view returns (uint256[] memory) {\\n        uint callsLength = calls.length;\\n        uint256[] memory balancesList = new uint256[](callsLength);\\n        address token;\\n        for (uint256 i = 0; i < callsLength; i++) {\\n            token = calls[i].swapToToken;\\n            balancesList[i] = getBalanceOf(token);\\n            if (token == ETH)\\n                balancesList[i] -= msg.value;\\n        }\\n        return balancesList;\\n    }\\n\\n    /// This function transfers tokens from users based on the SwapRequest, it transfers amountIn + fees.\\n    function transferTokensFromUserForSwapRequest(SwapRequest memory request) private {\\n        uint transferAmount = request.amountIn + sumFees(request);\\n        if (request.fromToken != ETH)\\n            SafeERC20.safeTransferFrom(IERC20(request.fromToken), msg.sender, address(this), transferAmount);\\n        else\\n            require(msg.value >= transferAmount);\\n    }\\n\\n    /// This function iterates on calls and if needsTransferFromUser, transfers tokens from user\\n    function transferTokensFromUserForCalls(Call[] calldata calls) private {\\n        uint callsLength = calls.length;\\n        Call calldata call;\\n        address token;\\n        for (uint256 i = 0; i < callsLength; i++) {\\n            call = calls[i];\\n            token = call.swapFromToken;\\n            if (call.needsTransferFromUser && token != ETH)\\n                SafeERC20.safeTransferFrom(IERC20(call.swapFromToken), msg.sender, address(this), call.amount);\\n        }\\n    }\\n\\n    /// @dev returns any excess token left by the contract.\\n    /// We iterate over `swapToToken`s because each swapToToken is either the request.toToken or is the output of\\n    /// another `Call` in the list of swaps which itself either has transferred tokens from user,\\n    /// or is a middle token that is the output of another `Call`.\\n    function returnExcessAmounts(\\n        SwapRequest memory request,\\n        Call[] calldata calls,\\n        uint256[] memory initialBalancesList) internal {\\n        uint excessAmountToToken;\\n        address tmpSwapToToken;\\n        uint currentBalanceTo;\\n        for (uint256 i = 0; i < calls.length; i++) {\\n            tmpSwapToToken = calls[i].swapToToken;\\n            currentBalanceTo = getBalanceOf(tmpSwapToToken);\\n            excessAmountToToken = currentBalanceTo - initialBalancesList[i];\\n            if (excessAmountToToken > 0 && tmpSwapToToken != request.toToken) {\\n                _sendToken(tmpSwapToToken, excessAmountToToken, msg.sender);\\n            }\\n        }\\n    }\\n\\n    function emitSwapEvent(SwapRequest memory request, uint output, address receiver) internal {\\n        emit RangoSwap(\\n            request.requestId,\\n            request.fromToken,\\n            request.toToken,\\n            request.amountIn,\\n            request.minimumAmountExpected,\\n            request.dAppTag,\\n            output,\\n            receiver\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.16;\\n\\n/// @title Reentrancy Guard\\n/// @author \\n/// @notice Abstract contract to provide protection against reentrancy\\nabstract contract ReentrancyGuard {\\n    /// Storage ///\\n\\n    /// @dev keccak256(\\\"exchange.rango.reentrancyguard\\\");\\n    bytes32 private constant NAMESPACE = hex\\\"4fe94118b1030ac5f570795d403ee5116fd91b8f0b5d11f2487377c2b0ab2559\\\";\\n\\n    /// Types ///\\n\\n    struct ReentrancyStorage {\\n        uint256 status;\\n    }\\n\\n    /// Errors ///\\n\\n    error ReentrancyError();\\n\\n    /// Constants ///\\n\\n    uint256 private constant _NOT_ENTERED = 0;\\n    uint256 private constant _ENTERED = 1;\\n\\n    /// Modifiers ///\\n\\n    modifier nonReentrant() {\\n        ReentrancyStorage storage s = reentrancyStorage();\\n        if (s.status == _ENTERED) revert ReentrancyError();\\n        s.status = _ENTERED;\\n        _;\\n        s.status = _NOT_ENTERED;\\n    }\\n\\n    /// Private Methods ///\\n\\n    /// @dev fetch local storage\\n    function reentrancyStorage() private pure returns (ReentrancyStorage storage data) {\\n        bytes32 position = NAMESPACE;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            data.slot := position\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ReentrancyError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"name\":\"ContractAndMethodsBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"methods\",\"type\":\"bytes4[]\"}],\"name\":\"ContractAndMethodsWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ContractBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ContractWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"MessagingDAppBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"MessagingDAppWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requestId\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IRango.CrossChainOperationStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dAppTag\",\"type\":\"uint16\"}],\"name\":\"RangoBridgeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requestId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bridgeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hasInterchainMessage\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hasDestinationSwap\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"bridgeId\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"dAppTag\",\"type\":\"uint16\"}],\"name\":\"RangoBridgeInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"RangoDiamondAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"StargateRouterAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"WethAddressUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_dapps\",\"type\":\"address[]\"}],\"name\":\"addMessagingDAppsMiddleWare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"methodIds\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct RangoBaseInterchainMiddleware.whitelistRequest[]\",\"name\":\"req\",\"type\":\"tuple[]\"}],\"name\":\"addWhitelistContractMiddleWare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rangoDiamond\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"initBaseMiddleware\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stargateRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"initStargateMiddleware\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"refundNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"methodIds\",\"type\":\"bytes4[]\"}],\"name\":\"removeContractAndMethodIdsFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"removeMessagingDAppContractMiddleWare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"removeWhitelistMiddleWare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountLD\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sgReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateRangoDiamondAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateStargateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateWethAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RangoStargateMiddleware", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}