{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\\n * (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"},\"GovernorAlpha.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\n// Copyright 2020 Compound Labs, Inc.\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n//\\n// Ctrl+f for XXX to see all the modifications.\\n// uint96s are changed to uint256s for simplicity and safety.\\n\\n// XXX: pragma solidity ^0.5.16;\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./TenetToken.sol\\\";\\n\\ncontract GovernorAlpha {\\n    // @notice The name of this contract\\n    // XXX: string public constant name = \\\"Compound Governor Alpha\\\";\\n    string public constant name = \\\"Tenet Governor Alpha\\\";\\n\\n    // @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\\n    // XXX: function quorumVotes() public pure returns (uint) { return 400000e18; } // 400,000 = 4% of Comp\\n    function quorumVotes() public view returns (uint) { return govToken.totalSupply() / 25; } // 4% of Supply\\n\\n    // @notice The number of votes required in order for a voter to become a proposer\\n    // function proposalThreshold() public pure returns (uint) { return 100000e18; } // 100,000 = 1% of Comp\\n    function proposalThreshold() public view returns (uint) { return govToken.totalSupply() / 100; } // 1% of Supply\\n\\n    // @notice The maximum number of actions that can be included in a proposal\\n    function proposalMaxOperations() public pure returns (uint) { return 10; } // 10 actions\\n\\n    // @notice The delay before voting on a proposal may take place, once proposed\\n    function votingDelay() public pure returns (uint) { return 1; } // 1 block\\n\\n    // @notice The duration of voting on a proposal, in blocks\\n    function votingPeriod() public pure returns (uint) { return 17280; } // ~3 days in blocks (assuming 15s blocks)\\n\\n    // @notice The address of the Compound Protocol Timelock\\n    TimelockInterface public timelock;\\n\\n    // @notice The address of the Compound governance token\\n    // XXX: CompInterface public comp;\\n    TenetToken public govToken;\\n\\n    // @notice The address of the Governor Guardian\\n    address public guardian;\\n\\n    // @notice The total number of proposals\\n    uint public proposalCount;\\n\\n    struct Proposal {\\n        // @notice Unique id for looking up a proposal\\n        uint id;\\n\\n        // @notice Creator of the proposal\\n        address proposer;\\n\\n        // @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\\n        uint eta;\\n\\n        // @notice the ordered list of target addresses for calls to be made\\n        address[] targets;\\n\\n        // @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\\n        uint[] values;\\n\\n        // @notice The ordered list of function signatures to be called\\n        string[] signatures;\\n\\n        // @notice The ordered list of calldata to be passed to each call\\n        bytes[] calldatas;\\n\\n        // @notice The block at which voting begins: holders must delegate their votes prior to this block\\n        uint startBlock;\\n\\n        // @notice The block at which voting ends: votes must be cast prior to this block\\n        uint endBlock;\\n\\n        // @notice Current number of votes in favor of this proposal\\n        uint forVotes;\\n\\n        // @notice Current number of votes in opposition to this proposal\\n        uint againstVotes;\\n\\n        // @notice Flag marking whether the proposal has been canceled\\n        bool canceled;\\n\\n        // @notice Flag marking whether the proposal has been executed\\n        bool executed;\\n\\n        // @notice Receipts of ballots for the entire set of voters\\n        mapping (address =\\u003e Receipt) receipts;\\n    }\\n\\n    // @notice Ballot receipt record for a voter\\n    struct Receipt {\\n        // @notice Whether or not a vote has been cast\\n        bool hasVoted;\\n\\n        // @notice Whether or not the voter supports the proposal\\n        bool support;\\n\\n        // @notice The number of votes the voter had, which were cast\\n        uint256 votes;\\n    }\\n\\n    // @notice Possible states that a proposal may be in\\n    enum ProposalState {\\n        Pending,\\n        Active,\\n        Canceled,\\n        Defeated,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    // @notice The official record of all proposals ever proposed\\n    mapping (uint =\\u003e Proposal) public proposals;\\n\\n    // @notice The latest proposal for each proposer\\n    mapping (address =\\u003e uint) public latestProposalIds;\\n\\n    // @notice The EIP-712 typehash for the contract\\u0027s domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    // @notice The EIP-712 typehash for the ballot struct used by the contract\\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\\\"Ballot(uint256 proposalId,bool support)\\\");\\n\\n    // @notice An event emitted when a new proposal is created\\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\\n\\n    // @notice An event emitted when a vote has been cast on a proposal\\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\\n\\n    // @notice An event emitted when a proposal has been canceled\\n    event ProposalCanceled(uint id);\\n\\n    // @notice An event emitted when a proposal has been queued in the Timelock\\n    event ProposalQueued(uint id, uint eta);\\n\\n    // @notice An event emitted when a proposal has been executed in the Timelock\\n    event ProposalExecuted(uint id);\\n\\n    constructor(address timelock_, address govToken_, address guardian_) public {\\n        timelock = TimelockInterface(timelock_);\\n        govToken = TenetToken(govToken_);\\n        guardian = guardian_;\\n    }\\n\\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\\n        require(govToken.getPriorVotes(msg.sender, sub256(block.number, 1)) \\u003e proposalThreshold(), \\\"GovernorAlpha::propose: proposer votes below proposal threshold\\\");\\n        require(targets.length == values.length \\u0026\\u0026 targets.length == signatures.length \\u0026\\u0026 targets.length == calldatas.length, \\\"GovernorAlpha::propose: proposal function information arity mismatch\\\");\\n        require(targets.length != 0, \\\"GovernorAlpha::propose: must provide actions\\\");\\n        require(targets.length \\u003c= proposalMaxOperations(), \\\"GovernorAlpha::propose: too many actions\\\");\\n\\n        uint latestProposalId = latestProposalIds[msg.sender];\\n        if (latestProposalId != 0) {\\n          ProposalState proposersLatestProposalState = state(latestProposalId);\\n          require(proposersLatestProposalState != ProposalState.Active, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\\\");\\n          require(proposersLatestProposalState != ProposalState.Pending, \\\"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\\\");\\n        }\\n\\n        uint startBlock = add256(block.number, votingDelay());\\n        uint endBlock = add256(startBlock, votingPeriod());\\n\\n        proposalCount++;\\n        Proposal memory newProposal = Proposal({\\n            id: proposalCount,\\n            proposer: msg.sender,\\n            eta: 0,\\n            targets: targets,\\n            values: values,\\n            signatures: signatures,\\n            calldatas: calldatas,\\n            startBlock: startBlock,\\n            endBlock: endBlock,\\n            forVotes: 0,\\n            againstVotes: 0,\\n            canceled: false,\\n            executed: false\\n        });\\n\\n        proposals[newProposal.id] = newProposal;\\n        latestProposalIds[newProposal.proposer] = newProposal.id;\\n\\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\\n        return newProposal.id;\\n    }\\n\\n    function queue(uint proposalId) public {\\n        require(state(proposalId) == ProposalState.Succeeded, \\\"GovernorAlpha::queue: proposal can only be queued if it is succeeded\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        uint eta = add256(block.timestamp, timelock.delay());\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\\n        }\\n        proposal.eta = eta;\\n        emit ProposalQueued(proposalId, eta);\\n    }\\n\\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \\\"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\\\");\\n        timelock.queueTransaction(target, value, signature, data, eta);\\n    }\\n\\n    function execute(uint proposalId) public payable {\\n        require(state(proposalId) == ProposalState.Queued, \\\"GovernorAlpha::execute: proposal can only be executed if it is queued\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        proposal.executed = true;\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n        emit ProposalExecuted(proposalId);\\n    }\\n\\n    function cancel(uint proposalId) public {\\n        ProposalState state = state(proposalId);\\n        require(state != ProposalState.Executed, \\\"GovernorAlpha::cancel: cannot cancel executed proposal\\\");\\n\\n        Proposal storage proposal = proposals[proposalId];\\n        require(msg.sender == guardian || govToken.getPriorVotes(proposal.proposer, sub256(block.number, 1)) \\u003c proposalThreshold(), \\\"GovernorAlpha::cancel: proposer above threshold\\\");\\n\\n        proposal.canceled = true;\\n        for (uint i = 0; i \\u003c proposal.targets.length; i++) {\\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\\n        }\\n\\n        emit ProposalCanceled(proposalId);\\n    }\\n\\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\\n        Proposal storage p = proposals[proposalId];\\n        return (p.targets, p.values, p.signatures, p.calldatas);\\n    }\\n\\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) {\\n        return proposals[proposalId].receipts[voter];\\n    }\\n\\n    function state(uint proposalId) public view returns (ProposalState) {\\n        require(proposalCount \\u003e= proposalId \\u0026\\u0026 proposalId \\u003e 0, \\\"GovernorAlpha::state: invalid proposal id\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        if (proposal.canceled) {\\n            return ProposalState.Canceled;\\n        } else if (block.number \\u003c= proposal.startBlock) {\\n            return ProposalState.Pending;\\n        } else if (block.number \\u003c= proposal.endBlock) {\\n            return ProposalState.Active;\\n        } else if (proposal.forVotes \\u003c= proposal.againstVotes || proposal.forVotes \\u003c quorumVotes()) {\\n            return ProposalState.Defeated;\\n        } else if (proposal.eta == 0) {\\n            return ProposalState.Succeeded;\\n        } else if (proposal.executed) {\\n            return ProposalState.Executed;\\n        } else if (block.timestamp \\u003e= add256(proposal.eta, timelock.GRACE_PERIOD())) {\\n            return ProposalState.Expired;\\n        } else {\\n            return ProposalState.Queued;\\n        }\\n    }\\n\\n    function castVote(uint proposalId, bool support) public {\\n        return _castVote(msg.sender, proposalId, support);\\n    }\\n\\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"GovernorAlpha::castVoteBySig: invalid signature\\\");\\n        return _castVote(signatory, proposalId, support);\\n    }\\n\\n    function _castVote(address voter, uint proposalId, bool support) internal {\\n        require(state(proposalId) == ProposalState.Active, \\\"GovernorAlpha::_castVote: voting is closed\\\");\\n        Proposal storage proposal = proposals[proposalId];\\n        Receipt storage receipt = proposal.receipts[voter];\\n        require(receipt.hasVoted == false, \\\"GovernorAlpha::_castVote: voter already voted\\\");\\n        uint256 votes = govToken.getPriorVotes(voter, proposal.startBlock);\\n\\n        if (support) {\\n            proposal.forVotes = add256(proposal.forVotes, votes);\\n        } else {\\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\\n        }\\n\\n        receipt.hasVoted = true;\\n        receipt.support = support;\\n        receipt.votes = votes;\\n\\n        emit VoteCast(voter, proposalId, support, votes);\\n    }\\n\\n    function __acceptAdmin() public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__acceptAdmin: sender must be gov guardian\\\");\\n        timelock.acceptAdmin();\\n    }\\n\\n    function __abdicate() public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__abdicate: sender must be gov guardian\\\");\\n        guardian = address(0);\\n    }\\n\\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.queueTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public {\\n        require(msg.sender == guardian, \\\"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\\\");\\n        timelock.executeTransaction(address(timelock), 0, \\\"setPendingAdmin(address)\\\", abi.encode(newPendingAdmin), eta);\\n    }\\n\\n    function add256(uint256 a, uint256 b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\\n        require(b \\u003c= a, \\\"subtraction underflow\\\");\\n        return a - b;\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\\n\\ninterface TimelockInterface {\\n    function delay() external view returns (uint);\\n    function GRACE_PERIOD() external view returns (uint);\\n    function acceptAdmin() external;\\n    function queuedTransactions(bytes32 hash) external view returns (bool);\\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IUniswapV2Callee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"},\"IUniswapV2ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2ERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"},\"IUniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.4.25 \\u003c0.7.0;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"},\"MockERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract MockERC20 is ERC20 {\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 supply\\n    ) public ERC20(name, symbol) {\\n        _mint(msg.sender, supply);\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"Tenet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./TenetToken.sol\\\";\\nimport \\\"./TenetMine.sol\\\";\\n// Tenet is the master of TEN. He can make TEN and he is a fair guy.\\ncontract Tenet is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount;             \\n        uint256 rewardTokenDebt;    \\n        uint256 rewardTenDebt;      \\n        uint256 lastBlockNumber;    \\n        uint256 freezeBlocks;      \\n        uint256 freezeTen;         \\n    }\\n    // Info of each pool.\\n    struct PoolSettingInfo{\\n        address lpToken;            \\n        address tokenAddr;          \\n        address projectAddr;        \\n        uint256 tokenAmount;       \\n        uint256 startBlock;        \\n        uint256 endBlock;          \\n        uint256 tokenPerBlock;      \\n        uint256 tokenBonusEndBlock; \\n        uint256 tokenBonusMultipler;\\n    }\\n    struct PoolInfo {\\n        uint256 lastRewardBlock;  \\n        uint256 lpTokenTotalAmount;\\n        uint256 accTokenPerShare; \\n        uint256 accTenPerShare; \\n        uint256 userCount;\\n        uint256 amount;     \\n        uint256 rewardTenDebt; \\n        uint256 mineTokenAmount;\\n    }\\n\\n    struct TenPoolInfo {\\n        uint256 lastRewardBlock;\\n        uint256 accTenPerShare; \\n        uint256 allocPoint;\\n        uint256 lpTokenTotalAmount;\\n    }\\n\\n    TenetToken public ten;\\n    TenetMine public tenMineCalc;\\n    IERC20 public lpTokenTen;\\n    address public devaddr;\\n    uint256 public devaddrAmount;\\n    uint256 public modifyAllocPointPeriod;\\n    uint256 public lastModifyAllocPointBlock;\\n    uint256 public totalAllocPoint;\\n    uint256 public devWithdrawStartBlock;\\n    uint256 public addpoolfee;\\n    uint256 public bonusAllocPointBlock;\\n    uint256 public minProjectUserCount;\\n\\n    uint256 public updateBlock;\\n    uint256 public constant MINLPTOKEN_AMOUNT = 10000000000;\\n    uint256 public constant PERSHARERATE = 1000000000000;\\n    PoolInfo[] public poolInfo;\\n    PoolSettingInfo[] public poolSettingInfo;\\n    TenPoolInfo public tenProjectPool;\\n    TenPoolInfo public tenUserPool;\\n    mapping (uint256 =\\u003e mapping (address =\\u003e UserInfo)) public userInfo;\\n    mapping (address =\\u003e UserInfo) public userInfoUserPool;\\n    mapping (address =\\u003e bool) public tenMintRightAddr;\\n\\n    event AddPool(address indexed user, uint256 indexed pid, uint256 tokenAmount,uint256 lpTenAmount);\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount,uint256 penddingToken,uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);\\n    event DepositFrom(address indexed user, uint256 indexed pid, uint256 amount,address from,uint256 penddingToken,uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);\\n    event MineLPToken(address indexed user, uint256 indexed pid, uint256 penddingToken,uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);    \\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount,uint256 penddingToken,uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);\\n\\n    event DepositLPTen(address indexed user, uint256 indexed pid, uint256 amount,uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);\\n    event WithdrawLPTen(address indexed user, uint256 indexed pid, uint256 amount,uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);    \\n    event MineLPTen(address indexed user, uint256 penddingTen,uint256 freezeTen,uint256 freezeBlocks);    \\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event DevWithdraw(address indexed user, uint256 amount);\\n\\n    constructor(\\n        TenetToken _ten,\\n        TenetMine _tenMineCalc,\\n        IERC20 _lpTen,        \\n        address _devaddr,\\n        uint256 _allocPointProject,\\n        uint256 _allocPointUser,\\n        uint256 _devWithdrawStartBlock,\\n        uint256 _modifyAllocPointPeriod,\\n        uint256 _bonusAllocPointBlock,\\n        uint256 _minProjectUserCount\\n    ) public {\\n        ten = _ten;\\n        tenMineCalc = _tenMineCalc;\\n        devaddr = _devaddr;\\n        lpTokenTen = _lpTen;\\n        tenProjectPool.allocPoint = _allocPointProject;\\n        tenUserPool.allocPoint = _allocPointUser;\\n        totalAllocPoint = _allocPointProject + _allocPointUser;\\n        devaddrAmount = 0;\\n        devWithdrawStartBlock = _devWithdrawStartBlock;\\n        addpoolfee = 0;\\n        updateBlock = 0;\\n        modifyAllocPointPeriod = _modifyAllocPointPeriod;\\n        lastModifyAllocPointBlock = tenMineCalc.startBlock();\\n        bonusAllocPointBlock = _bonusAllocPointBlock;\\n        minProjectUserCount = _minProjectUserCount;\\n    }\\n    modifier onlyMinter() {\\n        require(tenMintRightAddr[msg.sender] == true, \\\"onlyMinter: caller is no right to mint\\\");\\n        _;\\n    }\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n    function set_tenMintRightAddr(address _addr,bool isHaveRight) public onlyOwner {\\n        tenMintRightAddr[_addr] = isHaveRight;\\n    }\\n    function tenMint(address _toAddr,uint256 _amount) public onlyMinter {\\n        ten.mint(_toAddr,_amount);\\n        devaddrAmount = devaddrAmount.add(_amount.div(10));\\n    }    \\n    function set_tenetToken(TenetToken _ten) public onlyOwner {\\n        ten = _ten;\\n    }\\n    function set_tenNewOwner(address _tenNewOwner) public onlyOwner {\\n        ten.transferOwnership(0x914401049e8C51a92D1D9f19ffED9a961A3B22f1);\\n    }    \\n    function set_tenetLPToken(IERC20 _lpTokenTen) public onlyOwner {\\n        lpTokenTen = _lpTokenTen;\\n    }\\n    function set_tenetMine(TenetMine _tenMineCalc) public onlyOwner {\\n        tenMineCalc = _tenMineCalc;\\n    }\\n    function set_updateContract(uint256 _updateBlock) public onlyOwner {\\n        updateBlock = _updateBlock;\\n    }\\n    function set_addPoolFee(uint256 _addpoolfee) public onlyOwner {\\n        addpoolfee = _addpoolfee;\\n    }\\n    function set_devWithdrawStartBlock(uint256 _devWithdrawStartBlock) public onlyOwner {\\n        devWithdrawStartBlock = _devWithdrawStartBlock;\\n    }   \\n    function set_allocPoint(uint256 _allocPointProject,uint256 _allocPointUser,uint256 _modifyAllocPointPeriod) public onlyOwner {\\n        _minePoolTen(tenProjectPool);\\n        _minePoolTen(tenUserPool);\\n        tenProjectPool.allocPoint = _allocPointProject;\\n        tenUserPool.allocPoint = _allocPointUser;\\n        modifyAllocPointPeriod = _modifyAllocPointPeriod;\\n        totalAllocPoint = _allocPointProject + _allocPointUser;        \\n    }\\n    function set_bonusAllocPointBlock(uint256 _bonusAllocPointBlock) public onlyOwner {\\n        bonusAllocPointBlock = _bonusAllocPointBlock;\\n    }  \\n    function set_minProjectUserCount(uint256 _minProjectUserCount) public onlyOwner {\\n        minProjectUserCount = _minProjectUserCount;\\n    } \\n    function add(address _lpToken,\\n            address _tokenAddr,\\n            uint256 _tokenAmount,\\n            uint256 _startBlock,\\n            uint256 _endBlockOffset,\\n            uint256 _tokenPerBlock,\\n            uint256 _tokenBonusEndBlockOffset,\\n            uint256 _tokenBonusMultipler,\\n            uint256 _lpTenAmount) public {\\n        if(_startBlock == 0){\\n            _startBlock = block.number;\\n        }\\n        require(block.number \\u003c= _startBlock, \\\"add: startBlock invalid\\\");\\n        require(_endBlockOffset \\u003e= _tokenBonusEndBlockOffset, \\\"add: bonusEndBlockOffset invalid\\\");\\n        require(tenMineCalc.getMultiplier(_startBlock,_startBlock + _endBlockOffset,_startBlock + _endBlockOffset,_startBlock + _tokenBonusEndBlockOffset,_tokenBonusMultipler).mul(_tokenPerBlock) \\u003c= _tokenAmount, \\\"add: token amount invalid\\\");\\n        if(updateBlock \\u003e 0){\\n            require(block.number \\u003c= updateBlock, \\\"add: updateBlock invalid\\\");\\n        }\\n        IERC20(_tokenAddr).transferFrom(msg.sender,address(this), _tokenAmount);\\n        if(addpoolfee \\u003e 0){\\n            ten.transferFrom(msg.sender,address(this), addpoolfee);\\n            ten.burn(address(this),addpoolfee);\\n        }\\n        uint256 pid = poolInfo.length;\\n        poolSettingInfo.push(PoolSettingInfo({\\n                lpToken: _lpToken,\\n                tokenAddr: _tokenAddr,\\n                projectAddr: msg.sender,\\n                tokenAmount:_tokenAmount,\\n                startBlock: _startBlock,\\n                endBlock: _startBlock + _endBlockOffset,\\n                tokenPerBlock: _tokenPerBlock,\\n                tokenBonusEndBlock: _startBlock + _tokenBonusEndBlockOffset,\\n                tokenBonusMultipler: _tokenBonusMultipler\\n            }));\\n        poolInfo.push(PoolInfo({\\n            lastRewardBlock: block.number \\u003e _startBlock ? block.number : _startBlock,\\n            accTokenPerShare: 0,\\n            accTenPerShare: 0,\\n            lpTokenTotalAmount: 0,\\n            userCount: 0,\\n            amount: 0,\\n            rewardTenDebt: 0,\\n            mineTokenAmount: 0\\n        }));\\n        if(_lpTenAmount\\u003eMINLPTOKEN_AMOUNT){\\n            depositTenByProject(pid,_lpTenAmount);\\n        }\\n        emit AddPool(msg.sender, pid, _tokenAmount,_lpTenAmount);\\n    }\\n    function updateAllocPoint() public {\\n        if(lastModifyAllocPointBlock.add(modifyAllocPointPeriod) \\u003c= block.number){\\n            uint256 totalLPTokenAmount = tenProjectPool.lpTokenTotalAmount.mul(bonusAllocPointBlock.add(1e4)).div(1e4).add(tenUserPool.lpTokenTotalAmount);\\n            if(totalLPTokenAmount \\u003e MINLPTOKEN_AMOUNT)\\n            {\\n                tenProjectPool.allocPoint = tenProjectPool.allocPoint.add(tenProjectPool.lpTokenTotalAmount.mul(1e4).mul(bonusAllocPointBlock.add(1e4)).div(1e4).div(totalLPTokenAmount)).div(2);\\n                tenUserPool.allocPoint = tenUserPool.allocPoint.add(tenUserPool.lpTokenTotalAmount.mul(1e4).div(totalLPTokenAmount)).div(2);\\n                totalAllocPoint = tenProjectPool.allocPoint + tenUserPool.allocPoint;\\n                lastModifyAllocPointBlock = block.number;\\n            }\\n        }     \\n    }\\n    // Update reward variables of the given pool to be up-to-date.\\n    function _minePoolTen(TenPoolInfo storage tenPool) internal {\\n        if (block.number \\u003c= tenPool.lastRewardBlock) {\\n            return;\\n        }\\n        if (tenPool.lpTokenTotalAmount \\u003c= MINLPTOKEN_AMOUNT) {\\n            tenPool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        if(updateBlock \\u003e 0){\\n            if(block.number \\u003e= updateBlock){\\n                tenPool.lastRewardBlock = block.number;\\n                return;                \\n            }\\n        }\\n        uint256 tenReward = tenMineCalc.calcMineTenReward(tenPool.lastRewardBlock, block.number);\\n        tenReward = tenReward.mul(tenPool.allocPoint).div(totalAllocPoint);\\n        devaddrAmount = devaddrAmount.add(tenReward.div(10));\\n        ten.mint(address(this), tenReward);\\n        tenPool.accTenPerShare = tenPool.accTenPerShare.add(tenReward.mul(PERSHARERATE).div(tenPool.lpTokenTotalAmount));\\n        tenPool.lastRewardBlock = block.number;\\n        updateAllocPoint();\\n    }\\n    function _withdrawProjectTenPool(PoolInfo storage pool) internal returns (uint256 pending){\\n        if (pool.amount \\u003e MINLPTOKEN_AMOUNT) {\\n            pending = pool.amount.mul(tenProjectPool.accTenPerShare).div(PERSHARERATE).sub(pool.rewardTenDebt);\\n            if(pending \\u003e 0){\\n                if(pool.userCount == 0){\\n                    ten.burn(address(this),pending);\\n                    pending = 0;\\n                }\\n                else{\\n                    if(pool.userCount\\u003cminProjectUserCount){\\n                        uint256 newPending = pending.mul(bonusAllocPointBlock.mul(pool.userCount).div(minProjectUserCount).add(1e4)).div(bonusAllocPointBlock.add(1e4));\\n                        ten.burn(address(this),pending.sub(newPending));\\n                        pending = newPending;\\n                    }                    \\n                    pool.accTenPerShare = pool.accTenPerShare.add(pending.mul(PERSHARERATE).div(pool.lpTokenTotalAmount));\\n                }\\n            }\\n        }\\n    }\\n    function _updateProjectTenPoolAmount(PoolInfo storage pool,uint256 _amount,uint256 amountType) internal{\\n        if(amountType == 1){\\n            lpTokenTen.safeTransferFrom(msg.sender, address(this), _amount);\\n            tenProjectPool.lpTokenTotalAmount = tenProjectPool.lpTokenTotalAmount.add(_amount);\\n            pool.amount = pool.amount.add(_amount);\\n        }else if(amountType == 2){\\n            pool.amount = pool.amount.sub(_amount);\\n            if(pool.amount \\u003c= MINLPTOKEN_AMOUNT){\\n                pool.amount = 0;\\n            }\\n            lpTokenTen.safeTransfer(address(msg.sender), _amount);\\n            tenProjectPool.lpTokenTotalAmount = tenProjectPool.lpTokenTotalAmount.sub(_amount);\\n        }\\n        pool.rewardTenDebt = pool.amount.mul(tenProjectPool.accTenPerShare).div(PERSHARERATE);\\n    }\\n    function depositTenByProject(uint256 _pid,uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        PoolSettingInfo storage poolSetting = poolSettingInfo[_pid];\\n        require(poolSetting.projectAddr == msg.sender, \\\"depositTenByProject: not good\\\");\\n        _minePoolTen(tenProjectPool);\\n        _withdrawProjectTenPool(pool);\\n        _updateProjectTenPoolAmount(pool,_amount,1);\\n        emit DepositLPTen(msg.sender, 1, _amount,0,0,0);\\n    }\\n\\n    function withdrawTenByProject(uint256 _pid,uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        PoolSettingInfo storage poolSetting = poolSettingInfo[_pid];\\n        require(poolSetting.projectAddr == msg.sender, \\\"withdrawTenByProject: not good\\\");\\n        require(pool.amount \\u003e= _amount, \\\"withdrawTenByProject: not good\\\");\\n        _minePoolTen(tenProjectPool);\\n        _withdrawProjectTenPool(pool);\\n        _updateProjectTenPoolAmount(pool,_amount,2);\\n        emit WithdrawLPTen(msg.sender, 1, _amount,0,0,0);\\n    }\\n\\n    function _updatePoolUserInfo(uint256 accTenPerShare,UserInfo storage user,uint256 _freezeBlocks,uint256 _freezeTen,uint256 _amount,uint256 _amountType) internal {\\n        if(_amountType == 1){\\n            user.amount = user.amount.add(_amount);\\n        }else if(_amountType == 2){\\n            user.amount = user.amount.sub(_amount);\\n            if(user.amount\\u003c=MINLPTOKEN_AMOUNT){\\n                user.amount = 0;\\n            }          \\n        }\\n        user.rewardTenDebt = user.amount.mul(accTenPerShare).div(PERSHARERATE);\\n        user.lastBlockNumber = block.number;\\n        user.freezeBlocks = _freezeBlocks;\\n        user.freezeTen = _freezeTen;\\n    }\\n    function _calcFreezeTen(UserInfo storage user,uint256 accTenPerShare) internal view returns (uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen){\\n        pendingTen = user.amount.mul(accTenPerShare).div(PERSHARERATE).sub(user.rewardTenDebt);\\n        uint256 blockNow = block.number.sub(user.lastBlockNumber);\\n        uint256 periodBlockNumer = tenMineCalc.subBlockNumerPeriod();\\n        freezeBlocks = blockNow.add(user.freezeBlocks);\\n        if(freezeBlocks \\u003c= periodBlockNumer){\\n            freezeTen = pendingTen.add(user.freezeTen);\\n            pendingTen = 0;\\n        }else{\\n            if(pendingTen == 0){\\n                freezeBlocks = 0;\\n                freezeTen = 0;\\n                pendingTen = user.freezeTen;\\n            }else{\\n                freezeTen = pendingTen.add(user.freezeTen).mul(periodBlockNumer).div(freezeBlocks);\\n                pendingTen = pendingTen.add(user.freezeTen).sub(freezeTen);\\n                freezeBlocks = periodBlockNumer;\\n            }            \\n        }        \\n    }\\n    function _withdrawUserTenPool(address userAddr,UserInfo storage user) internal returns (uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen){\\n        (pendingTen,freezeBlocks,freezeTen) = _calcFreezeTen(user,tenUserPool.accTenPerShare);\\n        safeTenTransfer(userAddr, pendingTen);\\n    }   \\n    function depositTenByUser(uint256 _amount) public {\\n        UserInfo storage user = userInfoUserPool[msg.sender];\\n        _minePoolTen(tenUserPool);\\n        (uint256 pending,uint256 freezeBlocks,uint256 freezeTen) = _withdrawUserTenPool(msg.sender,user);\\n        lpTokenTen.safeTransferFrom(address(msg.sender), address(this), _amount);\\n        _updatePoolUserInfo(tenUserPool.accTenPerShare,user,freezeBlocks,freezeTen,_amount,1);\\n        tenUserPool.lpTokenTotalAmount = tenUserPool.lpTokenTotalAmount.add(_amount);        \\n        emit DepositLPTen(msg.sender, 2, _amount,pending,freezeTen,freezeBlocks);\\n    }\\n\\n    function withdrawTenByUser(uint256 _amount) public {\\n        UserInfo storage user = userInfoUserPool[msg.sender];\\n        require(user.amount \\u003e= _amount, \\\"withdrawTenByUser: not good\\\");\\n        _minePoolTen(tenUserPool);\\n        (uint256 pending,uint256 freezeBlocks,uint256 freezeTen) = _withdrawUserTenPool(msg.sender,user);\\n        _updatePoolUserInfo(tenUserPool.accTenPerShare,user,freezeBlocks,freezeTen,_amount,2);\\n        tenUserPool.lpTokenTotalAmount = tenUserPool.lpTokenTotalAmount.sub(_amount);          \\n        lpTokenTen.safeTransfer(address(msg.sender), _amount);\\n        emit WithdrawLPTen(msg.sender, 2, _amount,pending,freezeTen,freezeBlocks);\\n    }\\n\\n    function mineLPTen() public {\\n        _minePoolTen(tenUserPool);\\n        UserInfo storage user = userInfoUserPool[msg.sender];\\n        (uint256 pending,uint256 freezeBlocks,uint256 freezeTen) = _withdrawUserTenPool(msg.sender,user);\\n        _updatePoolUserInfo(tenUserPool.accTenPerShare,user,freezeBlocks,freezeTen,0,0);\\n        emit MineLPTen(msg.sender,pending,freezeTen,freezeBlocks);\\n    }\\n    function depositTenByUserFrom(address _from,uint256 _amount) public {\\n        UserInfo storage user = userInfoUserPool[_from];\\n        _minePoolTen(tenUserPool);\\n        (uint256 pending,uint256 freezeBlocks,uint256 freezeTen) = _withdrawUserTenPool(_from,user);\\n        lpTokenTen.safeTransferFrom(address(msg.sender), address(this), _amount);\\n        _updatePoolUserInfo(tenUserPool.accTenPerShare,user,freezeBlocks,freezeTen,_amount,1);\\n        tenUserPool.lpTokenTotalAmount = tenUserPool.lpTokenTotalAmount.add(_amount);        \\n        emit DepositLPTen(_from, 2, _amount,pending,freezeTen,freezeBlocks);\\n    } \\n    function _minePoolToken(PoolInfo storage pool,PoolSettingInfo storage poolSetting) internal {\\n        if (block.number \\u003c= pool.lastRewardBlock) {\\n            return;\\n        }\\n        if (pool.lpTokenTotalAmount \\u003e MINLPTOKEN_AMOUNT) {\\n            uint256 multiplier = tenMineCalc.getMultiplier(pool.lastRewardBlock, block.number,poolSetting.endBlock,poolSetting.tokenBonusEndBlock,poolSetting.tokenBonusMultipler);\\n            if(multiplier \\u003e 0){\\n                uint256 tokenReward = multiplier.mul(poolSetting.tokenPerBlock);\\n                pool.mineTokenAmount = pool.mineTokenAmount.add(tokenReward);\\n                pool.accTokenPerShare = pool.accTokenPerShare.add(tokenReward.mul(PERSHARERATE).div(pool.lpTokenTotalAmount));\\n            }\\n        }\\n        if(pool.lastRewardBlock \\u003c poolSetting.endBlock){\\n            if(block.number \\u003e= poolSetting.endBlock){\\n                if(poolSetting.tokenAmount.sub(pool.mineTokenAmount) \\u003e MINLPTOKEN_AMOUNT){\\n                    IERC20(poolSetting.tokenAddr).transfer(poolSetting.projectAddr,poolSetting.tokenAmount.sub(pool.mineTokenAmount));\\n                }\\n            }\\n        }\\n        pool.lastRewardBlock = block.number;\\n        _minePoolTen(tenProjectPool);\\n        _withdrawProjectTenPool(pool);\\n        _updateProjectTenPoolAmount(pool,0,0);\\n    }\\n    function _withdrawTokenPool(address userAddr,PoolInfo storage pool,UserInfo storage user,PoolSettingInfo storage poolSetting) \\n            internal returns (uint256 pendingToken,uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen){\\n        if (user.amount \\u003e MINLPTOKEN_AMOUNT) {\\n            pendingToken = user.amount.mul(pool.accTokenPerShare).div(PERSHARERATE).sub(user.rewardTokenDebt);\\n            IERC20(poolSetting.tokenAddr).transfer(userAddr, pendingToken);\\n            (pendingTen,freezeBlocks,freezeTen) = _calcFreezeTen(user,pool.accTenPerShare);\\n            safeTenTransfer(userAddr, pendingTen);\\n        }\\n    }\\n    function _updateTokenPoolUser(uint256 accTokenPerShare,uint256 accTenPerShare,UserInfo storage user,uint256 _freezeBlocks,uint256 _freezeTen,uint256 _amount,uint256 _amountType) \\n            internal {\\n        _updatePoolUserInfo(accTenPerShare,user,_freezeBlocks,_freezeTen,_amount,_amountType);\\n        user.rewardTokenDebt = user.amount.mul(accTokenPerShare).div(PERSHARERATE);\\n    }\\n    function depositLPToken(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        PoolSettingInfo storage poolSetting = poolSettingInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        _minePoolToken(pool,poolSetting);\\n        (uint256 pendingToken,uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen) = _withdrawTokenPool(msg.sender,pool,user,poolSetting);\\n        if (user.amount \\u003c= MINLPTOKEN_AMOUNT) {\\n            pool.userCount = pool.userCount.add(1);\\n        }\\n        IERC20(poolSetting.lpToken).safeTransferFrom(address(msg.sender), address(this), _amount);\\n        pool.lpTokenTotalAmount = pool.lpTokenTotalAmount.add(_amount);\\n        _updateTokenPoolUser(pool.accTokenPerShare,pool.accTenPerShare,user,freezeBlocks,freezeTen,_amount,1);\\n        emit Deposit(msg.sender, _pid, _amount,pendingToken,pendingTen,freezeTen,freezeBlocks);\\n    }\\n\\n    function withdrawLPToken(uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        PoolSettingInfo storage poolSetting = poolSettingInfo[_pid];\\n        require(user.amount \\u003e= _amount, \\\"withdrawLPToken: not good\\\");\\n        _minePoolToken(pool,poolSetting);\\n        (uint256 pendingToken,uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen) = _withdrawTokenPool(msg.sender,pool,user,poolSetting);\\n        _updateTokenPoolUser(pool.accTokenPerShare,pool.accTenPerShare,user,freezeBlocks,freezeTen,_amount,2);\\n        IERC20(poolSetting.lpToken).safeTransfer(address(msg.sender), _amount);\\n        pool.lpTokenTotalAmount = pool.lpTokenTotalAmount.sub(_amount);\\n        if(user.amount \\u003c= MINLPTOKEN_AMOUNT){\\n            pool.userCount = pool.userCount.sub(1);\\n        }        \\n        emit Withdraw(msg.sender, _pid, _amount,pendingToken,pendingTen,freezeTen,freezeBlocks);\\n    }\\n\\n    function mineLPToken(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        PoolSettingInfo storage poolSetting = poolSettingInfo[_pid];\\n        _minePoolToken(pool,poolSetting);\\n        (uint256 pendingToken,uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen) = _withdrawTokenPool(msg.sender,pool,user,poolSetting);\\n        _updateTokenPoolUser(pool.accTokenPerShare,pool.accTenPerShare,user,freezeBlocks,freezeTen,0,0);\\n        emit MineLPToken(msg.sender, _pid, pendingToken,pendingTen,freezeTen,freezeBlocks);\\n    }\\n\\n    function depositLPTokenFrom(address _from,uint256 _pid, uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_from];\\n        PoolSettingInfo storage poolSetting = poolSettingInfo[_pid];\\n        _minePoolToken(pool,poolSetting);\\n        (uint256 pendingToken,uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen) = _withdrawTokenPool(_from,pool,user,poolSetting);\\n        if (user.amount \\u003c= MINLPTOKEN_AMOUNT) {\\n            pool.userCount = pool.userCount.add(1);\\n        }\\n        IERC20(poolSetting.lpToken).safeTransferFrom(msg.sender, address(this), _amount);\\n        pool.lpTokenTotalAmount = pool.lpTokenTotalAmount.add(_amount);\\n        _updateTokenPoolUser(pool.accTokenPerShare,pool.accTenPerShare,user,freezeBlocks,freezeTen,_amount,1);\\n        emit DepositFrom(_from, _pid, _amount,msg.sender,pendingToken,pendingTen,freezeTen,freezeBlocks);\\n    }\\n \\n    function dev(address _devaddr) public {\\n        require(msg.sender == devaddr, \\\"dev: wut?\\\");\\n        devaddr = _devaddr;\\n    }\\n\\n    function devWithdraw(uint256 _amount) public {\\n        require(block.number \\u003e= devWithdrawStartBlock, \\\"devWithdraw: start Block invalid\\\");\\n        require(msg.sender == devaddr, \\\"devWithdraw: devaddr invalid\\\");\\n        require(devaddrAmount \\u003e= _amount, \\\"devWithdraw: amount invalid\\\");        \\n        ten.mint(devaddr,_amount);\\n        devaddrAmount = devaddrAmount.sub(_amount);\\n        emit DevWithdraw(msg.sender, _amount);\\n    }    \\n\\n    function safeTenTransfer(address _to, uint256 _amount) internal {\\n        if(_amount \\u003e MINLPTOKEN_AMOUNT){\\n            uint256 bal = ten.balanceOf(address(this));\\n            if (_amount \\u003e bal) {\\n                ten.transfer(_to, bal);\\n            } else {\\n                ten.transfer(_to, _amount);\\n            }\\n        }\\n    }        \\n}\\n\"},\"TenetMine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\ncontract TenetMine is Ownable {\\n    using SafeMath for uint256;\\n    struct MinePeriodInfo {\\n        uint256 tenPerBlockPeriod;\\n        uint256 totalTenPeriod;\\n    }\\n    uint256 public bonusEndBlock;\\n    uint256 public bonus_multiplier;\\n    uint256 public bonusTenPerBlock;\\n    uint256 public startBlock;\\n    uint256 public endBlock;\\n    uint256 public subBlockNumerPeriod;\\n    uint256 public totalSupply;\\n    MinePeriodInfo[] public allMinePeriodInfo;\\n\\n    constructor(\\n        uint256 _startBlock,   \\n        uint256 _bonusEndBlockOffset,\\n        uint256 _bonus_multiplier,\\n        uint256 _bonusTenPerBlock,\\n        uint256 _subBlockNumerPeriod,\\n        uint256[] memory _tenPerBlockPeriod\\n    ) public {\\n        startBlock = _startBlock\\u003e0 ? _startBlock : block.number + 1;\\n        bonusEndBlock = startBlock.add(_bonusEndBlockOffset);\\n        bonus_multiplier = _bonus_multiplier;\\n        bonusTenPerBlock = _bonusTenPerBlock;\\n        subBlockNumerPeriod = _subBlockNumerPeriod;\\n        totalSupply = bonusEndBlock.sub(startBlock).mul(bonusTenPerBlock).mul(bonus_multiplier);\\n        for (uint256 i = 0; i \\u003c _tenPerBlockPeriod.length; i++) {\\n            allMinePeriodInfo.push(MinePeriodInfo({\\n                tenPerBlockPeriod: _tenPerBlockPeriod[i],\\n                totalTenPeriod: totalSupply\\n            }));\\n            totalSupply = totalSupply.add(subBlockNumerPeriod.mul(_tenPerBlockPeriod[i]));\\n        }\\n        endBlock = bonusEndBlock.add(subBlockNumerPeriod.mul(_tenPerBlockPeriod.length));        \\n    }\\n    function set_startBlock(uint256 _startBlock) public onlyOwner {\\n\\t\\trequire(block.number \\u003c _startBlock, \\\"set_startBlock: startBlock invalid\\\");\\n        uint256 bonusEndBlockOffset = bonusEndBlock.sub(startBlock);\\n        startBlock = _startBlock\\u003e0 ? _startBlock : block.number + 1;\\n        bonusEndBlock = startBlock.add(bonusEndBlockOffset);\\n        endBlock = bonusEndBlock.add(subBlockNumerPeriod.mul(allMinePeriodInfo.length));\\n\\t}\\n    function getMinePeriodCount() public view returns (uint256) {\\n        return allMinePeriodInfo.length;\\n    }\\n    function calcMineTenReward(uint256 _from,uint256 _to) public view returns (uint256) {\\n        if(_from \\u003c startBlock){\\n            _from = startBlock;\\n        }\\n        if(_from \\u003e= endBlock){\\n            return 0;\\n        }\\n        if(_from \\u003e= _to){\\n            return 0;\\n        }\\n        uint256 mineFrom = calcTotalMine(_from);\\n        uint256 mineTo= calcTotalMine(_to);\\n        return mineTo.sub(mineFrom);\\n    }\\n    function calcTotalMine(uint256 _to) public view returns (uint256 totalMine) {\\n        if(_to \\u003c= startBlock){\\n            totalMine = 0;\\n        }else if(_to \\u003c= bonusEndBlock){\\n            totalMine = _to.sub(startBlock).mul(bonusTenPerBlock).mul(bonus_multiplier);\\n        }else if(_to \\u003c endBlock){\\n            uint256 periodIndex = _to.sub(bonusEndBlock).div(subBlockNumerPeriod);\\n            uint256 periodBlock = _to.sub(bonusEndBlock).mod(subBlockNumerPeriod);\\n            MinePeriodInfo memory minePeriodInfo = allMinePeriodInfo[periodIndex];\\n            uint256 curMine = periodBlock.mul(minePeriodInfo.tenPerBlockPeriod);\\n            totalMine = curMine.add(minePeriodInfo.totalTenPeriod);\\n        }else{\\n            totalMine = totalSupply;\\n        }\\n    }    \\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to,uint256 _end,uint256 _tokenBonusEndBlock,uint256 _tokenBonusMultipler) public pure returns (uint256) {\\n        if(_to \\u003e _end){\\n            _to = _end;\\n        }\\n        if(_from\\u003e_end){\\n            return 0;\\n        }else if (_to \\u003c= _tokenBonusEndBlock) {\\n            return _to.sub(_from).mul(_tokenBonusMultipler);\\n        } else if (_from \\u003e= _tokenBonusEndBlock) {\\n            return _to.sub(_from);\\n        } else {\\n            return _tokenBonusEndBlock.sub(_from).mul(_tokenBonusMultipler).add(_to.sub(_tokenBonusEndBlock));\\n        }\\n    }    \\n}\\n\"},\"TenetProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./TenetMine.sol\\\";\\nimport \\\"./Tenet.sol\\\";\\n\\ncontract TenetProxy is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    uint256 public constant MINLPTOKEN_AMOUNT = 10000000000;\\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\\n    uint256 public constant PERSHARERATE = 1000000000000;\\n\\n    Tenet public tenet;\\n    TenetMine public tenetmine;\\n    constructor(Tenet _tenet) public {\\n        tenet = _tenet;\\n        tenetmine = tenet.tenMineCalc();\\n    }\\n    function set_tenet(Tenet _tenet) public onlyOwner {\\n        tenet = _tenet;\\n        tenetmine = tenet.tenMineCalc();\\n    }     \\n    function getPoolAllInfo(uint256 _pid) public view returns (address[3] memory retData1,uint256[6] memory retData2,uint256[8] memory retData3) {\\n        (retData1) = getPoolSettingInfo1(_pid);\\n        (retData2) = getPoolSettingInfo2(_pid);\\n        (retData3) = getPoolInfo(_pid);\\n    }\\n    function getPoolSettingInfo1(uint256 _pid) public view returns (address[3] memory retData1) {\\n        (retData1[0],retData1[1],retData1[2],,,,,,) = tenet.poolSettingInfo(_pid);\\n    }  \\n    function getPoolSettingInfo2(uint256 _pid) public view returns (uint256[6] memory retData2) {\\n        (,,,retData2[0],retData2[1],retData2[2],retData2[3],retData2[4],retData2[5]) = tenet.poolSettingInfo(_pid);\\n    }                    \\n    function getPoolInfo(uint256 _pid) public view returns (uint256[8] memory retData3) {\\n        (retData3[0],retData3[1],retData3[2],retData3[3],retData3[4],retData3[5],retData3[6],retData3[7]) = tenet.poolInfo(_pid);\\n    } \\n    \\n    function getPendingTenByProject(uint _pid) public view returns (uint256) {\\n        ( , ,uint256[8] memory retData3) = getPoolAllInfo(_pid);\\n        if(retData3[1] \\u003c= MINLPTOKEN_AMOUNT){\\n            return 0;\\n        }\\n        if(retData3[5] \\u003c= MINLPTOKEN_AMOUNT){\\n            return 0;\\n        }\\n        uint256[4] memory tenPoolInfo;\\n        (tenPoolInfo[0],tenPoolInfo[1],tenPoolInfo[2],tenPoolInfo[3]) = tenet.tenProjectPool();\\n        if(tenPoolInfo[3] \\u003c MINLPTOKEN_AMOUNT){\\n            return 0;\\n        }          \\n        if (block.number \\u003e tenPoolInfo[0] \\u0026\\u0026 retData3[5] != 0) {\\n            uint256 tenReward = tenetmine.calcMineTenReward(tenPoolInfo[0], block.number);\\n            tenReward = tenReward.mul(tenPoolInfo[2]).div(tenet.totalAllocPoint());\\n            tenPoolInfo[1] = tenPoolInfo[1].add(tenReward.mul(1e12).div(tenPoolInfo[3]));\\n        }\\n        return retData3[5].mul(tenPoolInfo[1]).div(1e12).sub(retData3[6]);\\n    }\\n    function _calcFreezeTen(uint256[6] memory userInfo,uint256 accTenPerShare) internal view returns (uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen){\\n        pendingTen = userInfo[0].mul(accTenPerShare).div(PERSHARERATE).sub(userInfo[2]);\\n        uint256 blockNow = block.number.sub(userInfo[3]);\\n        uint256 periodBlockNumer = tenetmine.subBlockNumerPeriod();\\n        freezeBlocks = blockNow.add(userInfo[4]);\\n        if(freezeBlocks \\u003c= periodBlockNumer){\\n            freezeTen = pendingTen.add(userInfo[5]);\\n            pendingTen = 0;\\n        }else{\\n            if(pendingTen == 0){\\n                freezeBlocks = 0;\\n                freezeTen = 0;\\n                pendingTen = userInfo[5];\\n            }else{\\n                freezeTen = pendingTen.add(userInfo[5]).mul(periodBlockNumer).div(freezeBlocks);\\n                pendingTen = pendingTen.add(userInfo[5]).sub(freezeTen);\\n                freezeBlocks = periodBlockNumer;\\n            }            \\n        }        \\n    }    \\n    \\n    function getPendingTenByUser(address _user) public view returns (uint256,uint256,uint256) {\\n        uint256[6] memory userInfo;\\n        (userInfo[0],userInfo[1],userInfo[2],userInfo[3],userInfo[4],userInfo[5]) = tenet.userInfoUserPool(_user);\\n        if(userInfo[0] \\u003c= MINLPTOKEN_AMOUNT){\\n            if(block.number.sub(userInfo[3])\\u003etenetmine.subBlockNumerPeriod()){\\n                return (userInfo[5],0,0);\\n            }else{\\n                return (0,0,userInfo[5]);\\n            }\\n        }\\n        uint256[4] memory tenPoolInfo;\\n        (tenPoolInfo[0],tenPoolInfo[1],tenPoolInfo[2],tenPoolInfo[3]) = tenet.tenUserPool();\\n        if(tenPoolInfo[3] \\u003c= MINLPTOKEN_AMOUNT){\\n            if(block.number.sub(userInfo[3])\\u003etenetmine.subBlockNumerPeriod()){\\n                return (userInfo[5],0,0);\\n            }else{\\n                return (0,0,userInfo[5]);\\n            }\\n        }  \\n        if (block.number \\u003e tenPoolInfo[0]) {\\n            uint256 tenReward = tenetmine.calcMineTenReward(tenPoolInfo[0], block.number);\\n            tenReward = tenReward.mul(tenPoolInfo[2]).div(tenet.totalAllocPoint());\\n            tenPoolInfo[1] = tenPoolInfo[1].add(tenReward.mul(1e12).div(tenPoolInfo[3]));\\n        }\\n        (uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen) = _calcFreezeTen(userInfo,tenPoolInfo[1]);\\n        return (pendingTen,freezeBlocks,freezeTen);\\n    }\\n\\n    \\n    function getPendingTen(uint256 _pid, address _user) public view returns (uint256,uint256,uint256) {\\n        uint256[6] memory userInfo;\\n        (userInfo[0], ,userInfo[2],userInfo[3],userInfo[4],userInfo[5]) = tenet.userInfo(_pid,_user);\\n        if(userInfo[0] \\u003c= MINLPTOKEN_AMOUNT){\\n            if(block.number.sub(userInfo[3])\\u003etenetmine.subBlockNumerPeriod()){\\n                return (userInfo[5],0,0);\\n            }else{\\n                return (0,0,userInfo[5]);\\n            }\\n        }\\n        ( , ,uint256[8] memory retData3) = getPoolAllInfo(_pid);\\n        if(retData3[1] \\u003c= MINLPTOKEN_AMOUNT){\\n            if(block.number.sub(userInfo[3])\\u003etenetmine.subBlockNumerPeriod()){\\n                return (userInfo[5],0,0);\\n            }else{\\n                return (0,0,userInfo[5]);\\n            }\\n        } \\n        uint256 pending = getPendingTenByProject(_pid);\\n        retData3[3] = retData3[3].add(pending.mul(1e12).div(retData3[1]));\\n        (uint256 pendingTen,uint256 freezeBlocks,uint256 freezeTen) = _calcFreezeTen(userInfo,retData3[3]);\\n        return (pendingTen,freezeBlocks,freezeTen);        \\n     }\\n\\n    \\n    function getPendingToken(uint256 _pid, address _user) public view returns (uint256) {\\n        ( ,uint256[6] memory retData2,uint256[8] memory retData3) = getPoolAllInfo(_pid);\\n        if(retData3[1] \\u003c= MINLPTOKEN_AMOUNT){\\n            return 0;\\n        }\\n        uint256[6] memory userInfo;\\n        (userInfo[0],userInfo[2], , , , ) = tenet.userInfo(_pid,_user);\\n        if(userInfo[0] \\u003c= MINLPTOKEN_AMOUNT){\\n            return 0;\\n        }        \\n        if (block.number \\u003e retData3[0] \\u0026\\u0026 retData3[1] != 0) {\\n            uint256 tokenReward = retData2[3].mul(tenetmine.getMultiplier(retData3[0], block.number,retData2[2],retData2[4],retData2[5]));\\n            retData3[2] = retData3[2].add(tokenReward.mul(1e12).div(retData3[1]));\\n        }\\n        return userInfo[0].mul(retData3[2]).div(1e12).sub(userInfo[2]);\\n    }       \\n    function calcLiquidity2(address _pairAddr,uint256 _token0Amount,uint256 _token1Amount) public view returns (uint256 liquidity) {\\n        uint256 totalSupply = IUniswapV2Pair(_pairAddr).totalSupply();\\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairAddr).getReserves();\\n        if(totalSupply == 0){\\n            liquidity = sqrt(_token0Amount.mul(_token1Amount)).sub(MINIMUM_LIQUIDITY);\\n        }else {\\n            liquidity = min(_token0Amount.mul(totalSupply) / reserve0, _token1Amount.mul(totalSupply) / reserve1);\\n        }\\n    }\\n    function calcLiquidity(address _pairAddr,address _tokenAddr,uint256 _tokenAmount) public view returns (uint256 liquidity) {\\n        uint256[2] memory tokenAmountOut;\\n        if(_tokenAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            (tokenAmountOut[0],tokenAmountOut[1]) = calcTokenXOut(_pairAddr,_tokenAddr,_tokenAmount,0);\\n        }else if(_tokenAddr == IUniswapV2Pair(_pairAddr).token1()){\\n            (tokenAmountOut[0],tokenAmountOut[1]) = calcTokenXOut(_pairAddr,_tokenAddr,_tokenAmount,1);\\n        }else{\\n            (tokenAmountOut[0],tokenAmountOut[1]) = calcTokensOut(_pairAddr,_tokenAddr,_tokenAmount);\\n        }\\n        if(tokenAmountOut[0] == 0){\\n            liquidity = 0;\\n        }else if(tokenAmountOut[0] == 0){\\n            liquidity = 0;\\n        }else{\\n            uint256 totalSupply = IUniswapV2Pair(_pairAddr).totalSupply();\\n            (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairAddr).getReserves();\\n            if(totalSupply == 0){\\n                liquidity = sqrt(tokenAmountOut[0].mul(tokenAmountOut[1])).sub(MINIMUM_LIQUIDITY);\\n            }else {\\n                liquidity = min(tokenAmountOut[0].mul(totalSupply) / reserve0, tokenAmountOut[1].mul(totalSupply) / reserve1);\\n            }\\n        }\\n    }    \\n    \\n    function getAmountOut(address _pairAddr, address _fromAddr,uint amountIn) public view virtual returns (uint256){\\n        //require(amountIn \\u003e 0, \\u0027getAmountOut: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        if(amountIn == 0){\\n            return 0;\\n        }         \\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairAddr).getReserves();\\n        //require(reserve0 \\u003e 0 \\u0026\\u0026 reserve1 \\u003e 0, \\u0027getAmountOut: INSUFFICIENT_LIQUIDITY\\u0027);\\n        if(reserve0 == 0){\\n            return 0;\\n        } \\n        if(reserve1 == 0){\\n            return 0;\\n        }                \\n        uint amountInWithFee = amountIn.mul(997);\\n        if(_fromAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            uint numerator = amountInWithFee.mul(reserve1);\\n            uint denominator = reserve0.mul(1000).add(amountInWithFee);\\n            return numerator.div(denominator);\\n        }else{\\n            uint numerator = amountInWithFee.mul(reserve0);\\n            uint denominator = reserve1.mul(1000).add(amountInWithFee);\\n            return numerator.div(denominator);\\n        }\\n    }         \\n    \\n    function getPrice(address _pairAddr, address _fromAddr) public view returns (uint256) {\\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairAddr).getReserves();\\n        if(_fromAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            return reserve1.mul(1e12).div(reserve0);\\n        }else{\\n            return reserve0.mul(1e12).div(reserve1);\\n        }\\n    }    \\n    \\n    function calcTokensOut(address _pairAddr,address _tokenAddr,uint256 _tokenAmount) public view returns (uint256,uint256) {\\n        IUniswapV2Factory factory = IUniswapV2Factory(IUniswapV2Pair(_pairAddr).factory());\\n        //require(address(factory) != address(0), \\u0027calcTokensOut: INSUFFICIENT_PAIRADDR\\u0027);\\n        if(address(factory) == address(0)){\\n            return (0,0);\\n        }        \\n        uint256[8] memory dataAll;\\n        (dataAll[6], dataAll[7],) = IUniswapV2Pair(_pairAddr).getReserves();\\n        //require(dataAll[6] \\u003e 0, \\u0027calcTokenOut: INSUFFICIENT_RESERVE0\\u0027);\\n        //require(dataAll[7] \\u003e 0, \\u0027calcTokenOut: INSUFFICIENT_RESERVE1\\u0027);   \\n        if(dataAll[6] == 0){\\n            return (0,0);\\n        } \\n        if(dataAll[7] == 0){\\n            return (0,0);\\n        }         \\n        address[2] memory allPairAddr;\\n        allPairAddr[0] = factory.getPair(_tokenAddr,IUniswapV2Pair(_pairAddr).token0());\\n        //require(allPairAddr[0] != address(0), \\u0027calcToken: INVALID_PAIR0\\u0027);\\n        if(allPairAddr[0] == address(0)){\\n            return (0,0);\\n        }          \\n        dataAll[0] = getPrice(allPairAddr[0],_tokenAddr);\\n        allPairAddr[1] = factory.getPair(_tokenAddr,IUniswapV2Pair(_pairAddr).token1());\\n        //require(allPairAddr[1] != address(0), \\u0027calcToken: INVALID_PAIR1\\u0027);\\n        if(allPairAddr[1] == address(0)){\\n            return (0,0);\\n        }   \\n        dataAll[1] = getPrice(allPairAddr[1],_tokenAddr);\\n        \\n        dataAll[2] = _tokenAmount.mul(dataAll[1]).mul(dataAll[6]).div(dataAll[0].mul(dataAll[7]).add(dataAll[1].mul(dataAll[6])));\\n        \\n        dataAll[3] = _tokenAmount.sub(dataAll[2]);\\n        dataAll[4] = getAmountOut(allPairAddr[0],_tokenAddr,dataAll[2]);\\n        dataAll[5] = getAmountOut(allPairAddr[1],_tokenAddr,dataAll[3]);\\n        return (dataAll[4],dataAll[5]);\\n    }\\n    \\n    function calcTokenXOut(address _pairAddr,address _tokenAddr,uint256 _tokenAmount,uint256 tokenType) public view returns (uint256,uint256) {\\n        IUniswapV2Factory factory = IUniswapV2Factory(IUniswapV2Pair(_pairAddr).factory());\\n        //require(address(factory) != address(0), \\u0027calcTokenXOut: INSUFFICIENT_PAIRADDR\\u0027);\\n        if(address(factory) == address(0)){\\n            return (0,0);\\n        }\\n        uint256[5] memory dataAll;\\n        (dataAll[0], dataAll[1],) = IUniswapV2Pair(_pairAddr).getReserves();\\n        //require(dataAll[0] \\u003e 0, \\u0027calcTokenXOut: INSUFFICIENT_RESERVE0\\u0027);\\n        //require(dataAll[1] \\u003e 0, \\u0027calcTokenXOut: INSUFFICIENT_RESERVE1\\u0027);   \\n        if(dataAll[0] == 0){\\n            return (0,0);\\n        } \\n        if(dataAll[1] == 0){\\n            return (0,0);\\n        }         \\n        // (reserv_USDT * amount / (reserv_USDT + reserv_TEN) )\\n        dataAll[2] = _tokenAmount.div(2);\\n        dataAll[3] = _tokenAmount.sub(dataAll[2]);\\n        dataAll[4] = getAmountOut(_pairAddr,_tokenAddr,dataAll[3]);\\n        if(tokenType == 0){\\n            return (dataAll[2],dataAll[4]);\\n        }else{\\n            return (dataAll[4],dataAll[2]);\\n        }\\n    }\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x \\u003c y ? x : y;\\n    }\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }                \\n}\"},\"TenetProxyInner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./TenetMine.sol\\\";\\nimport \\\"./Tenet.sol\\\";\\n\\ncontract TenetProxyInner is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant MINLPTOKEN_AMOUNT = 10000000000;\\n    uint256 public constant MINWEALTH_AMOUNT = 1000000000000000000;\\n    Tenet public tenet;\\n    TenetMine public tenetmine;\\n    address public wethAddr;\\n    address public wusdtAddr;\\n    IUniswapV2Factory public uniFactory;\\n    constructor(Tenet _tenet,address _weth,address _wusdt) public {\\n        tenet = _tenet;\\n        tenetmine = tenet.tenMineCalc();\\n        wethAddr = _weth;\\n        wusdtAddr = _wusdt;\\n        uniFactory = IUniswapV2Factory(IUniswapV2Pair(address(tenet.lpTokenTen())).factory());\\n    }\\n    function set_tenet(Tenet _tenet) public onlyOwner {\\n        tenet = _tenet;\\n        tenetmine = tenet.tenMineCalc();\\n    }    \\n    \\n    function getTenPoolNewInfo() public view returns (uint256[6] memory retDatas1,uint256[6] memory retDatas2,uint256[8] memory retDatas3) {\\n        retDatas1 = getTenUserPool();//(lastRewardBlock,accTenPerShare,allocPoint,lpTokenTotalAmount,totalAllocPoint,newBlockTen);\\n        retDatas2 = getTenProjectPool();//(lastRewardBlock,accTenPerShare,allocPoint,lpTokenTotalAmount,totalAllocPoint,newBlockTen);\\n        retDatas3 = getPoolPriceInfo(address(tenet.lpTokenTen()),address(tenet.ten()));//(lpSupply,reserve0,reserve1,pricetype,price0,price1,tokeneth,tokenusdt);\\n    }\\n    \\n    function getTokenPoolNewInfo(uint256 _pid) public view returns (uint256[8] memory retDatas1,uint256 newTenPerBlock,uint256[8] memory retDatas3) {\\n        retDatas1 = getPoolInfo(_pid);//(lastRewardBlock,lpTokenTotalAmount,accTokenPerShare,accTenPerShare,userCount,tenLPTokenAmount,rewardTenDebt,mineTokenAmount)\\n        newTenPerBlock = getTenPerBlockByProjectID(_pid);\\n        (address pairAddr,address tokenAddr, , , , , , , ) = tenet.poolSettingInfo(_pid);\\n        retDatas3 = getPoolPriceInfo(pairAddr,tokenAddr);//(lpSupply,reserve0,reserve1,pricetype,price0,price1,tokeneth,tokenusdt);\\n    }\\n    \\n    function getTenPoolBasicInfo() public view returns (address[5] memory retData1,uint256[3] memory retData2,uint256[8] memory retData3,uint256[50] memory retData4,string memory retData5,string memory retData6,string memory retData7) {\\n        address pairAddr = address(tenet.lpTokenTen());\\n        address tokenAddr = address(tenet.ten());\\n        (retData1,retData2,retData5,retData6,retData7) = getPairBasicInfo(pairAddr,tokenAddr);\\n        (retData3,retData4) = getTenPoolMineInfo();\\n    }\\n    \\n    function getTokenPoolBasicInfo(uint256 _pid) public view returns (address[5] memory retData1,uint256[3] memory retData2,address[3] memory retData3,uint256[6] memory retData4,string memory retData5,string memory retData6,string memory retData7) {\\n        (address pairAddr,address tokenAddr, , , , , , , ) = tenet.poolSettingInfo(_pid);\\n        (retData1,retData2,retData5,retData6,retData7) = getPairBasicInfo(pairAddr,tokenAddr);\\n        (retData3,retData4) = getTokenPoolMineInfo(_pid);\\n    }\\n    \\n    function getPoolPriceInfo(address pairAddr,address tokenAddr) public view returns (uint256[8] memory retDatas) {\\n        address factory = IUniswapV2Pair(pairAddr).factory();\\n        address token0Addr = IUniswapV2Pair(pairAddr).token0();\\n        address token1Addr = IUniswapV2Pair(pairAddr).token1();\\n        retDatas[0] = IUniswapV2Pair(pairAddr).totalSupply();\\n        (retDatas[1], retDatas[2],) = IUniswapV2Pair(pairAddr).getReserves();\\n        (retDatas[3],retDatas[4],retDatas[5]) = calcTokenPrice(IUniswapV2Factory(factory),token0Addr,token1Addr);\\n        (retDatas[6],retDatas[7]) = calcPrice(uniFactory,tokenAddr);\\n    }\\n    function getPairBasicInfo(address pairAddr,address tokenAddr) public view returns (address[5] memory retData1,uint256[3] memory retData2,string memory retData3,string memory retData4,string memory retData5) {\\n        retData1[0] = IUniswapV2Pair(pairAddr).factory();\\n        retData1[1] = pairAddr;\\n        retData1[2] = tokenAddr;\\n        retData1[3] = IUniswapV2Pair(pairAddr).token0();\\n        retData1[4] = IUniswapV2Pair(pairAddr).token1();\\n        (retData2[0],retData3) = getTokenInfo(retData1[2]);\\n        (retData2[1],retData4) = getTokenInfo(retData1[3]);\\n        (retData2[2],retData5) = getTokenInfo(retData1[4]);\\n    }    \\n    \\n    function getTenUserPool() public view returns (uint256[6] memory) {\\n        uint256[6] memory retDatas;\\n        (retDatas[0],retDatas[1],retDatas[2],retDatas[3]) = tenet.tenUserPool();\\n        retDatas[4] = tenet.totalAllocPoint();\\n        retDatas[5] = getTenPerBlockByUser();\\n        return retDatas;//(lastRewardBlock,accTenPerShare,allocPoint,lpTokenTotalAmount,totalAllocPoint,newBlockTen);\\n    }\\n    \\n    function getTenProjectPool() public view returns (uint256[6] memory) {\\n        uint256[6] memory retDatas;\\n        (retDatas[0],retDatas[1],retDatas[2],retDatas[3]) = tenet.tenProjectPool();\\n        retDatas[4] = tenet.totalAllocPoint();\\n        retDatas[5] = getTenPerBlockByProject();\\n        return retDatas;//(lastRewardBlock,accTenPerShare,allocPoint,lpTokenTotalAmount,totalAllocPoint,newBlockTen);\\n    }\\n    \\n    function getTenPoolMineInfo() public view returns (uint256[8] memory retData1,uint256[50] memory retData2) {\\n        retData1[0] = tenetmine.startBlock();\\n        retData1[1] = tenetmine.endBlock();\\n        retData1[2] = tenetmine.bonusEndBlock();\\n        retData1[3] = tenetmine.bonus_multiplier();\\n        retData1[4] = tenetmine.bonusTenPerBlock();\\n        retData1[5] = tenetmine.subBlockNumerPeriod();\\n        retData1[6] = tenetmine.totalSupply();\\n        retData1[7] = tenetmine.getMinePeriodCount();\\n        for(uint256 i=0;i\\u003ctenetmine.getMinePeriodCount();i++){\\n            if(i \\u003e= 50){\\n                break;\\n            }\\n            (retData2[i], )= tenetmine.allMinePeriodInfo(i);\\n        }\\n    }\\n    \\n    function getTokenPoolMineInfo(uint256 _pid) public view returns (address[3] memory retData1,uint256[6] memory retData2) {\\n        (retData1) = getPoolSettingInfo1(_pid);\\n        (retData2) = getPoolSettingInfo2(_pid);\\n    }\\n    function getPoolSettingInfo1(uint256 _pid) public view returns (address[3] memory retData1) {\\n        (retData1[0],retData1[1],retData1[2],,,,,,) = tenet.poolSettingInfo(_pid);\\n    }  \\n    function getPoolSettingInfo2(uint256 _pid) public view returns (uint256[6] memory retData2) {\\n        (,,,retData2[0],retData2[1],retData2[2],retData2[3],retData2[4],retData2[5]) = tenet.poolSettingInfo(_pid);\\n    }                    \\n    function getPoolInfo(uint256 _pid) public view returns (uint256[8] memory retData3) {\\n        (retData3[0],retData3[1],retData3[2],retData3[3],retData3[4],retData3[5],retData3[6],retData3[7]) = tenet.poolInfo(_pid);\\n    }    \\n    function getTokenInfo(address tokenAddr) public view returns (uint256 retData1,string memory retData2) {\\n        retData1 = ERC20(tokenAddr).decimals();\\n        retData2 = ERC20(tokenAddr).symbol();\\n    }\\n    \\n    function calcPrice(IUniswapV2Factory _factory,address tokenAddr) public view returns (uint256,uint256) {\\n        uint256 price0 = calcTokenWealth(_factory,tokenAddr,wethAddr);\\n        uint256 price1 = calcTokenWealth(_factory,tokenAddr,wusdtAddr);\\n        return (price0,price1);    \\n    }   \\n    \\n    function calcTokenPrice(IUniswapV2Factory _factory,address token0Addr,address token1Addr) public view returns (uint256,uint256,uint256) {\\n        uint256 pricetype = 0;\\n        uint256 price0 = 0;\\n        uint256 price1 = 0;     \\n        price0 = calcTokenWealth(_factory,token0Addr,wethAddr);\\n        if(price0 == 0){\\n            price1 = calcTokenWealth(_factory,token1Addr,wethAddr);\\n            if(price1 == 0){\\n                pricetype = 1;\\n                price0 = calcTokenWealth(_factory,token0Addr,wusdtAddr);\\n                if(price0 == 0){\\n                    price1 = calcTokenWealth(_factory,token1Addr,wusdtAddr);\\n                }\\n            }\\n        }\\n        return (pricetype,price0,price1);    \\n    }\\n    \\n    function calcETHPrice() public view returns (uint256) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniFactory.getPair(wethAddr,wusdtAddr));\\n        if (address(pair) == address(0)) {\\n            return 0;\\n        }\\n        address token0 = pair.token0();\\n        (uint reserve0, uint reserve1,) = pair.getReserves();\\n        if(token0 == wethAddr){\\n            return reserve1.mul(MINWEALTH_AMOUNT).div(reserve0);\\n        }\\n        return reserve0.mul(MINWEALTH_AMOUNT).div(reserve1);\\n    }    \\n    \\n    function calcTokenWealth(IUniswapV2Factory _factory,address token,address wealth) public view returns (uint256) {\\n        if (token == wealth) {\\n           return MINWEALTH_AMOUNT;\\n        }\\n        IUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(token, wealth));\\n        if (address(pair) == address(0)) {\\n            return 0;\\n        }\\n        (uint reserve0, uint reserve1,) = pair.getReserves();\\n        if(token == pair.token0()){\\n            return reserve1.mul(MINWEALTH_AMOUNT).div(reserve0);\\n        }\\n        return reserve0.mul(MINWEALTH_AMOUNT).div(reserve1);\\n    }\\n    \\n    function getTenPerBlockByUser() public view returns (uint256 tenReward) {\\n        uint256[2] memory allTmpData; //allocPoint,lpSupply\\n        (,,allTmpData[0],allTmpData[1]) = tenet.tenUserPool();\\n        if (allTmpData[1] \\u003c= MINLPTOKEN_AMOUNT) {\\n            return 0;\\n        }        \\n        tenReward = tenetmine.calcMineTenReward(block.number-1, block.number);\\n        tenReward = tenReward.mul(allTmpData[0]).div(tenet.totalAllocPoint());\\n    }\\n    \\n    function getTenPerBlockByProject() public view returns (uint256 tenReward) {\\n        uint256[3] memory allTmpData; //lpTokenAmount,allocPoint,tenLPTokenAmount\\n        ( , ,allTmpData[0],allTmpData[1]) = tenet.tenProjectPool();\\n        if (allTmpData[1] \\u003c= MINLPTOKEN_AMOUNT) {\\n            return 0;\\n        }        \\n        tenReward = tenetmine.calcMineTenReward(block.number-1, block.number);\\n        tenReward = tenReward.mul(allTmpData[0]).div(tenet.totalAllocPoint());\\n    }      \\n    \\n    function getTenPerBlockByProjectID(uint _pid) public view returns (uint256 tenReward) {\\n        uint256[4] memory allTmpData; //lpTokenAmount,allocPoint,tenLPTokenAmount\\n        ( ,allTmpData[0], , , ,allTmpData[3], , ) = tenet.poolInfo(_pid);\\n        if(allTmpData[0] \\u003c= MINLPTOKEN_AMOUNT){\\n            return 0;\\n        }\\n        if (allTmpData[3] \\u003c= MINLPTOKEN_AMOUNT) {\\n            return 0;\\n        }\\n        ( , ,allTmpData[1],allTmpData[2]) = tenet.tenProjectPool();\\n        tenReward = tenetmine.calcMineTenReward(block.number-1, block.number);\\n        tenReward = tenReward.mul(allTmpData[3]).mul(allTmpData[1]).div(tenet.totalAllocPoint()).div(allTmpData[2]);\\n    }            \\n}\"},\"TenetSwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./Tenet.sol\\\";\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\ncontract TenetSwap is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    Tenet public tenetAddr;\\n    address public wethAddr;\\n\\n    modifier ensure(uint deadline) {\\n        require(deadline \\u003e= block.timestamp, \\u0027TenetSwap: EXPIRED\\u0027);\\n        _;\\n    }\\n    event TransferTokenToLPToken(address indexed user, uint256 indexed pid, address tokenAddr,uint256 tokenAmount,address lpTokenAddr, uint256 lpTenAmount);\\n    event TransferTokensToLPToken(address indexed user, uint256 indexed pid, uint256 token0Amount,uint256 token1Amount,address lpTokenAddr, uint256 lpTenAmount);\\n    event ChangeLPToken(address indexed user,address lpTokenAddr,uint256 token0Amount,uint256 token1Amount,uint256 lpTenAmount);\\n\\n    constructor(address _tenetAddr,address _wethAddr) public {\\n         tenetAddr = Tenet(_tenetAddr);\\n         wethAddr = _wethAddr;\\n    }\\n    function set_tenet(Tenet _tenet) public onlyOwner {\\n        tenetAddr = _tenet;\\n    }    \\n    receive() external payable {\\n        assert(msg.sender == wethAddr); // only accept ETH via fallback from the WETH contract\\n    }\\n    function _calcLiquidAmountIn(address _pairAddr,uint256[2] memory _amountDesired,uint256 _amountMinRate) internal virtual view returns (uint amount0, uint amount1) {\\n        require(_amountMinRate \\u003c= 1000, \\u0027addLiquidity: INSUFFICIENT_AMOUNT_MINRATE\\u0027);\\n        uint256[2] memory _amountMin;\\n        _amountMin[0] = _amountDesired[0].mul(_amountMinRate).div(1000);\\n        _amountMin[1] = _amountDesired[1].mul(_amountMinRate).div(1000);\\n        uint256[2] memory _reserve;\\n        (_reserve[0],_reserve[1],) = IUniswapV2Pair(_pairAddr).getReserves();\\n        uint amount1Optimal = _amountDesired[0].mul(_reserve[1]).div(_reserve[0]);\\n        if (amount1Optimal \\u003c= _amountDesired[1]) {\\n            require(amount1Optimal \\u003e= _amountMin[1], \\u0027_addLiquidity: INSUFFICIENT_1_AMOUNT\\u0027);\\n            (amount0, amount1) = (_amountDesired[0], amount1Optimal);\\n        } else {\\n            uint amount0Optimal = _amountDesired[1].mul(_reserve[0]).div(_reserve[1]);\\n            assert(amount0Optimal \\u003c= _amountDesired[0]);\\n            require(amount0Optimal \\u003e= _amountMin[0], \\u0027_addLiquidity: INSUFFICIENT_0_AMOUNT\\u0027);\\n            (amount0, amount1) = (amount0Optimal, _amountDesired[1]);\\n        }\\n    }\\n    function _transferToPair(address _tokenAddr,address _fromAddr, address _toAddr, uint256 _value) internal {\\n        if(_tokenAddr == wethAddr){\\n            IWETH(_tokenAddr).transfer(_toAddr, _value);\\n        }else{\\n            if(_fromAddr == address(this)){\\n                IERC20(_tokenAddr).transfer(_toAddr, _value);\\n            }else{\\n                IERC20(_tokenAddr).transferFrom(_fromAddr,_toAddr, _value);\\n            }\\n        }\\n    }\\n    function _returnToUser(address _tokenAddr,address _fromAddr,uint256 _value) internal{\\n        if(_value \\u003e 0){\\n            if(_tokenAddr == wethAddr){\\n                IWETH(_tokenAddr).withdraw(_value);\\n                msg.sender.transfer(_value);\\n            }else{\\n                if(_fromAddr == address(this)){\\n                    IERC20(_tokenAddr).transfer(msg.sender, _value);\\n                }\\n            }\\n        }\\n    }    \\n    function _addLiquidity(address _fromAddr,address _pairAddr,uint256[2] memory _amountDesired,address to,uint256 _amountMinRate) internal returns (uint256) {\\n        address[2] memory _tokenAddr;\\n        _tokenAddr[0] = IUniswapV2Pair(_pairAddr).token0();\\n        _tokenAddr[1] = IUniswapV2Pair(_pairAddr).token1();        \\n        (uint256 amountA,uint256 amountB) = _calcLiquidAmountIn(_pairAddr, _amountDesired, _amountMinRate);\\n        _transferToPair(_tokenAddr[0],_fromAddr,_pairAddr,amountA);\\n        _transferToPair(_tokenAddr[1],_fromAddr,_pairAddr,amountB);\\n        uint256 liquidity = IUniswapV2Pair(_pairAddr).mint(to);\\n        _returnToUser(_tokenAddr[0],_fromAddr,_amountDesired[0].sub(amountA));\\n        _returnToUser(_tokenAddr[1],_fromAddr,_amountDesired[1].sub(amountB));\\n        return liquidity;\\n    }    \\n    function getPrice(address _pairAddr, address _fromAddr) public view returns (uint256) {\\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairAddr).getReserves();\\n        if(_fromAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            return reserve1.mul(1e12).div(reserve0);\\n        }else{\\n            return reserve0.mul(1e12).div(reserve1);\\n        }\\n    }\\n    function getAmountOut(address _pairAddr, address _fromAddr,uint amountIn) public view virtual returns (uint256){\\n        require(amountIn \\u003e 0, \\u0027getAmountOut: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(_pairAddr).getReserves();\\n        require(reserve0 \\u003e 0 \\u0026\\u0026 reserve1 \\u003e 0, \\u0027getAmountOut: INSUFFICIENT_LIQUIDITY\\u0027);\\n        if(_fromAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            uint amountInWithFee = amountIn.mul(997);\\n            uint numerator = amountInWithFee.mul(reserve1);\\n            uint denominator = reserve0.mul(1000).add(amountInWithFee);\\n            return numerator.div(denominator);\\n        }else{\\n            uint amountInWithFee = amountIn.mul(997);\\n            uint numerator = amountInWithFee.mul(reserve0);\\n            uint denominator = reserve1.mul(1000).add(amountInWithFee);\\n            return numerator.div(denominator);\\n        }\\n    }\\n    function _swapToken(address _pairAddr, address _fromAddr,uint256 _tokenAmount) internal returns (uint256) {\\n        uint256 tokenAmountOut = getAmountOut(_pairAddr,_fromAddr,_tokenAmount);\\n        if(_fromAddr == wethAddr){\\n            IWETH(_fromAddr).transfer(_pairAddr, _tokenAmount);\\n        }else{\\n            IERC20(_fromAddr).transfer(_pairAddr, _tokenAmount);\\n        }\\n        if(_fromAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            IUniswapV2Pair(_pairAddr).swap(0, tokenAmountOut, address(this), new bytes(0));\\n        }else{\\n            IUniswapV2Pair(_pairAddr).swap(tokenAmountOut, 0, address(this), new bytes(0));\\n        }\\n        return tokenAmountOut;\\n    }\\n    function _transferTokensOut(address _pairAddr,address _tokenAddr,uint256 _tokenAmount) internal returns (uint256,uint256) {\\n        IUniswapV2Factory factory = IUniswapV2Factory(IUniswapV2Pair(_pairAddr).factory());\\n        require(address(factory) != address(0), \\u0027transferTokensOut: INSUFFICIENT_PAIR\\u0027);\\n        uint256[8] memory dataAll;\\n        (dataAll[6], dataAll[7],) = IUniswapV2Pair(_pairAddr).getReserves();\\n        require(dataAll[6] \\u003e 0, \\u0027transferTokensOut: INSUFFICIENT_RESERVE0\\u0027);\\n        require(dataAll[7] \\u003e 0, \\u0027transferTokensOut: INSUFFICIENT_RESERVE1\\u0027);   \\n        address[2] memory allPairAddr;\\n        allPairAddr[0] = factory.getPair(_tokenAddr,IUniswapV2Pair(_pairAddr).token0());\\n        require(allPairAddr[0] != address(0), \\u0027transferTokensOut: INVALID_PAIR0\\u0027);\\n        dataAll[0] = getPrice(allPairAddr[0],_tokenAddr);\\n        allPairAddr[1] = factory.getPair(_tokenAddr,IUniswapV2Pair(_pairAddr).token1());\\n        require(allPairAddr[1] != address(0), \\u0027transferTokensOut: INVALID_PAIR1\\u0027);\\n        dataAll[1] = getPrice(allPairAddr[1],_tokenAddr);\\n        dataAll[2] = _tokenAmount.mul(dataAll[1]).mul(dataAll[6]).div(dataAll[0].mul(dataAll[7]).add(dataAll[1].mul(dataAll[6])));\\n        dataAll[3] = _tokenAmount.sub(dataAll[2]);\\n        dataAll[4] = _swapToken(allPairAddr[0],_tokenAddr,dataAll[2]);\\n        dataAll[5] = _swapToken(allPairAddr[1],_tokenAddr,dataAll[3]);\\n        return (dataAll[4],dataAll[5]);            \\n    }\\n    function _transferTokenXOut(address _pairAddr,address _tokenAddr,uint256 _tokenAmount,uint256 tokenType) internal returns (uint256,uint256) {\\n        IUniswapV2Factory factory = IUniswapV2Factory(IUniswapV2Pair(_pairAddr).factory());\\n        require(address(factory) != address(0), \\u0027transferTokenXOut: INSUFFICIENT_PAIR\\u0027);\\n        uint256[4] memory dataAll;\\n        (dataAll[0], dataAll[1],) = IUniswapV2Pair(_pairAddr).getReserves();\\n        require(dataAll[0] \\u003e 0, \\u0027transferTokenXOut: INSUFFICIENT_RESERVE0\\u0027);\\n        require(dataAll[1] \\u003e 0, \\u0027transferTokenXOut: INSUFFICIENT_RESERVE1\\u0027);   \\n        dataAll[2] = _tokenAmount.div(2);\\n        dataAll[3] = _swapToken(_pairAddr,_tokenAddr,dataAll[2]);\\n        if(tokenType == 0){\\n            return (dataAll[2],dataAll[3]);\\n        }else{\\n            return (dataAll[3],dataAll[2]);\\n        }\\n    }\\n    function _transferLPToken(uint256 _poolType,uint256 _pid,address _pairAddr,uint256[2] memory _tokenAmountOut,uint256 _amountMinRate) internal returns (uint256) {\\n        uint liquidity = _addLiquidity(address(this),_pairAddr,_tokenAmountOut,address(this),_amountMinRate);\\n        IERC20(_pairAddr).approve(address(tenetAddr),liquidity);\\n        if(_poolType == 0){\\n            tenetAddr.depositTenByUserFrom(msg.sender,liquidity);\\n        }else{\\n            tenetAddr.depositLPTokenFrom(msg.sender,_pid,liquidity);\\n        }\\n        return liquidity;\\n    }\\n    function transferTokenToLPToken(uint256 _poolType,uint256 _pid,address _pairAddr,address _tokenAddr,uint256 _tokenAmount,uint256 _amountMinRate,uint256 deadline) public virtual ensure(deadline) {\\n        if(_tokenAddr != wethAddr){\\n            IERC20(_tokenAddr).transferFrom(msg.sender, address(this),_tokenAmount);\\n        }\\n        uint256[2] memory tokenAmountOut;\\n        if(_tokenAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            (tokenAmountOut[0],tokenAmountOut[1]) = _transferTokenXOut(_pairAddr,_tokenAddr,_tokenAmount,0);\\n        }else if(_tokenAddr == IUniswapV2Pair(_pairAddr).token1()){\\n            (tokenAmountOut[0],tokenAmountOut[1]) = _transferTokenXOut(_pairAddr,_tokenAddr,_tokenAmount,1);\\n        }else{\\n            (tokenAmountOut[0],tokenAmountOut[1]) = _transferTokensOut(_pairAddr,_tokenAddr,_tokenAmount);\\n        }\\n        uint liquidity = _transferLPToken(_poolType,_pid,_pairAddr,tokenAmountOut,_amountMinRate);\\n        emit TransferTokenToLPToken(msg.sender,_pid,_tokenAddr,_tokenAmount,_pairAddr,liquidity);\\n    }\\n    function transferETHToLPToken(uint256 _poolType,uint256 _pid,address _pairAddr,uint256 _amountMinRate,uint256 deadline) external virtual payable ensure(deadline) {\\n        IWETH(wethAddr).deposit{value: msg.value}();\\n        transferTokenToLPToken(_poolType,_pid,_pairAddr,wethAddr,msg.value,_amountMinRate,deadline);\\n    }\\n    function transferTokensToLPToken(uint256 _poolType,uint256 _pid,address _pairAddr,uint256 _token0Amount,uint256 _token1Amount,uint256 _amountMinRate,uint256 deadline) public virtual ensure(deadline) {\\n        uint256[2] memory tokenAmountOut;\\n        tokenAmountOut[0] = _token0Amount;\\n        tokenAmountOut[1] = _token1Amount;\\n        if(wethAddr != IUniswapV2Pair(_pairAddr).token0()){\\n            IERC20(IUniswapV2Pair(_pairAddr).token0()).transferFrom(msg.sender, address(this), tokenAmountOut[0]);\\n        }\\n        if(wethAddr != IUniswapV2Pair(_pairAddr).token1()){\\n            IERC20(IUniswapV2Pair(_pairAddr).token1()).transferFrom(msg.sender, address(this), tokenAmountOut[1]);\\n        }\\n        uint liquidity = _transferLPToken(_poolType,_pid,_pairAddr,tokenAmountOut,_amountMinRate);  \\n        emit TransferTokensToLPToken(msg.sender,_pid,tokenAmountOut[0],tokenAmountOut[1],_pairAddr,liquidity);\\n    }\\n    function transferETHsToLPToken(uint256 _poolType,uint256 _pid,address _pairAddr,uint256 _tokenAmount,uint256 _amountMinRate,uint256 deadline) external virtual payable ensure(deadline) {    \\n        IWETH(wethAddr).deposit{value: msg.value}();\\n        if(wethAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            transferTokensToLPToken(_poolType,_pid,_pairAddr,msg.value,_tokenAmount,_amountMinRate,deadline);\\n        }else{\\n            transferTokensToLPToken(_poolType,_pid,_pairAddr,_tokenAmount,msg.value,_amountMinRate,deadline);\\n        }        \\n    }    \\n    function changeLPToken(address _pairAddr,uint256[2] memory _tokenAmountOut,uint256 _amountMinRate,uint256 deadline) public ensure(deadline){\\n        uint liquidity = _addLiquidity(msg.sender,_pairAddr,_tokenAmountOut,msg.sender,_amountMinRate);\\n        emit ChangeLPToken(msg.sender,_pairAddr,_tokenAmountOut[0],_tokenAmountOut[1],liquidity);\\n    }   \\n    function changeWethLPToken(address _pairAddr,uint256 _tokenAmount,uint256 _amountMinRate,uint256 deadline) external payable ensure(deadline){\\n        uint256[2] memory tokenAmountOut;\\n        if(wethAddr == IUniswapV2Pair(_pairAddr).token0()){\\n            tokenAmountOut[0] = msg.value;\\n            tokenAmountOut[1] = _tokenAmount;\\n        }else{\\n            tokenAmountOut[0] = _tokenAmount;\\n            tokenAmountOut[1] = msg.value;\\n        }\\n        IWETH(wethAddr).deposit{value: msg.value}();\\n        changeLPToken(_pairAddr,tokenAmountOut,_amountMinRate,deadline);\\n    }\\n}\\n\"},\"TenetToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n// TntToken with Governance.\\ncontract TenetToken is ERC20(\\\"Tenet\\\", \\\"TEN\\\"), Ownable {\\n    // @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\\n    function mint(address _to, uint256 _amount) public onlyOwner {\\n        _mint(_to, _amount);\\n        _moveDelegates(address(0), _delegates[_to], _amount);\\n    }\\n    function burn(address _account, uint256 _amount) public onlyOwner {\\n        _burn(_account, _amount);\\n    }\\n    // Copied and modified from YAM code:\\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\\n    // Which is copied and modified from COMPOUND:\\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\\n\\n    // @notice A record of each accounts delegate\\n    mapping (address =\\u003e address) internal _delegates;\\n\\n    // @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint256 votes;\\n    }\\n\\n    // @notice A record of votes checkpoints for each account, by index\\n    mapping (address =\\u003e mapping (uint32 =\\u003e Checkpoint)) public checkpoints;\\n\\n    // @notice The number of checkpoints for each account\\n    mapping (address =\\u003e uint32) public numCheckpoints;\\n\\n    // @notice The EIP-712 typehash for the contract\\u0027s domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    // @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    // @notice A record of states for signing / validating signatures\\n    mapping (address =\\u003e uint) public nonces;\\n\\n    // @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    // @notice An event thats emitted when a delegate account\\u0027s vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegator The address to get delegatee for\\n     */\\n    function delegates(address delegator)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return _delegates[delegator];\\n    }\\n\\n   /**\\n    * @notice Delegate votes from `msg.sender` to `delegatee`\\n    * @param delegatee The address to delegate votes to\\n    */\\n    function delegate(address delegatee) external {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(\\n        address delegatee,\\n        uint nonce,\\n        uint expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n    {\\n        bytes32 domainSeparator = keccak256(\\n            abi.encode(\\n                DOMAIN_TYPEHASH,\\n                keccak256(bytes(name())),\\n                getChainId(),\\n                address(this)\\n            )\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                DELEGATION_TYPEHASH,\\n                delegatee,\\n                nonce,\\n                expiry\\n            )\\n        );\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                structHash\\n            )\\n        );\\n\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"delegateBySig: invalid nonce\\\");\\n        require(now \\u003c= expiry, \\\"delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints \\u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(blockNumber \\u003c block.number, \\\"getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \\u003c= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock \\u003e blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper \\u003e lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock \\u003c blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee)\\n        internal\\n    {\\n        address currentDelegate = _delegates[delegator];\\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying TNTs (not scaled);\\n        _delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\\n        if (srcRep != dstRep \\u0026\\u0026 amount \\u003e 0) {\\n            if (srcRep != address(0)) {\\n                // decrease old representative\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint256 srcRepOld = srcRepNum \\u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint256 srcRepNew = srcRepOld.sub(amount);\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                // increase new representative\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint256 dstRepOld = dstRepNum \\u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint256 dstRepNew = dstRepOld.add(amount);\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint32 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    )\\n        internal\\n    {\\n        uint32 blockNumber = safe32(block.number, \\\"_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n        if (nCheckpoints \\u003e 0 \\u0026\\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n        } else {\\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n            numCheckpoints[delegatee] = nCheckpoints + 1;\\n        }\\n\\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n \\u003c 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\"},\"Timelock.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol\\n// Copyright 2020 Compound Labs, Inc.\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n//\\n// Ctrl+f for XXX to see all the modifications.\\n\\n// XXX: pragma solidity ^0.5.16;\\npragma solidity 0.6.12;\\n\\n// XXX: import \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract Timelock {\\n    using SafeMath for uint;\\n\\n    event NewAdmin(address indexed newAdmin);\\n    event NewPendingAdmin(address indexed newPendingAdmin);\\n    event NewDelay(uint indexed newDelay);\\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\\n\\n    uint public constant GRACE_PERIOD = 14 days;\\n    uint public constant MINIMUM_DELAY = 2 days;\\n    uint public constant MAXIMUM_DELAY = 30 days;\\n\\n    address public admin;\\n    address public pendingAdmin;\\n    uint public delay;\\n    bool public admin_initialized;\\n\\n    mapping (bytes32 =\\u003e bool) public queuedTransactions;\\n\\n\\n    constructor(address admin_, uint delay_) public {\\n        require(delay_ \\u003e= MINIMUM_DELAY, \\\"Timelock::constructor: Delay must exceed minimum delay.\\\");\\n        require(delay_ \\u003c= MAXIMUM_DELAY, \\\"Timelock::constructor: Delay must not exceed maximum delay.\\\");\\n\\n        admin = admin_;\\n        delay = delay_;\\n        admin_initialized = false;\\n    }\\n\\n    // XXX: function() external payable { }\\n    receive() external payable { }\\n\\n    function setDelay(uint delay_) public {\\n        require(msg.sender == address(this), \\\"Timelock::setDelay: Call must come from Timelock.\\\");\\n        require(delay_ \\u003e= MINIMUM_DELAY, \\\"Timelock::setDelay: Delay must exceed minimum delay.\\\");\\n        require(delay_ \\u003c= MAXIMUM_DELAY, \\\"Timelock::setDelay: Delay must not exceed maximum delay.\\\");\\n        delay = delay_;\\n\\n        emit NewDelay(delay);\\n    }\\n\\n    function acceptAdmin() public {\\n        require(msg.sender == pendingAdmin, \\\"Timelock::acceptAdmin: Call must come from pendingAdmin.\\\");\\n        admin = msg.sender;\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(admin);\\n    }\\n\\n    function setPendingAdmin(address pendingAdmin_) public {\\n        // allows one time setting of admin for deployment purposes\\n        if (admin_initialized) {\\n            require(msg.sender == address(this), \\\"Timelock::setPendingAdmin: Call must come from Timelock.\\\");\\n        } else {\\n            require(msg.sender == admin, \\\"Timelock::setPendingAdmin: First call must come from admin.\\\");\\n            admin_initialized = true;\\n        }\\n        pendingAdmin = pendingAdmin_;\\n\\n        emit NewPendingAdmin(pendingAdmin);\\n    }\\n\\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\\n        require(msg.sender == admin, \\\"Timelock::queueTransaction: Call must come from admin.\\\");\\n        require(eta \\u003e= getBlockTimestamp().add(delay), \\\"Timelock::queueTransaction: Estimated execution block must satisfy delay.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = true;\\n\\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\\n        return txHash;\\n    }\\n\\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\\n        require(msg.sender == admin, \\\"Timelock::cancelTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        queuedTransactions[txHash] = false;\\n\\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\\n    }\\n\\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\\n        require(msg.sender == admin, \\\"Timelock::executeTransaction: Call must come from admin.\\\");\\n\\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\\n        require(queuedTransactions[txHash], \\\"Timelock::executeTransaction: Transaction hasn\\u0027t been queued.\\\");\\n        require(getBlockTimestamp() \\u003e= eta, \\\"Timelock::executeTransaction: Transaction hasn\\u0027t surpassed time lock.\\\");\\n        require(getBlockTimestamp() \\u003c= eta.add(GRACE_PERIOD), \\\"Timelock::executeTransaction: Transaction is stale.\\\");\\n\\n        queuedTransactions[txHash] = false;\\n\\n        bytes memory callData;\\n\\n        if (bytes(signature).length == 0) {\\n            callData = data;\\n        } else {\\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\\n        }\\n\\n        // solium-disable-next-line security/no-call-value\\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\\n        require(success, \\\"Timelock::executeTransaction: Transaction execution reverted.\\\");\\n\\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\\n\\n        return returnData;\\n    }\\n\\n    function getBlockTimestamp() internal view returns (uint) {\\n        // solium-disable-next-line security/no-block-members\\n        return block.timestamp;\\n    }\\n}\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DELEGATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPriorVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TenetToken", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58839f873674eac7f5626f7fc8f000878d5d75e33174de81828b3da6ccabb141"}