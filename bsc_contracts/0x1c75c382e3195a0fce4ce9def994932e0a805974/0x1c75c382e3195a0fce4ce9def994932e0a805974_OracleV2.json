{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/swap-fee-reward/contracts/OracleV2.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\n\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/FixedPoint.sol\\\";\\nimport \\\"./libs/OracleLibrary.sol\\\";\\n\\ncontract OracleV2 {\\n    using FixedPoint for *;\\n    using SafeMath for uint;\\n\\n    struct Observation {\\n        uint timestamp;\\n        uint price0Cumulative;\\n        uint price1Cumulative;\\n    }\\n\\n    address public immutable factory;\\n    address public priceUpdater;\\n    uint public constant CYCLE = 15 minutes;\\n\\n    bytes32 INIT_CODE_HASH;\\n\\n    // mapping from pair address to a list of price observations of that pair\\n    mapping(address => Observation) public pairObservations;\\n\\n    event NotUpdate(address pair);\\n\\n    constructor(address factory_, bytes32 INIT_CODE_HASH_, address priceUpdater_) public {\\n        factory = factory_;\\n        INIT_CODE_HASH = INIT_CODE_HASH_;\\n        priceUpdater = priceUpdater_;\\n    }\\n\\n    function sortTokens(address tokenA, address tokenB) public pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'BSWSwapFactory: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'BSWSwapFactory: ZERO_ADDRESS');\\n    }\\n\\n    function pairFor(address tokenA, address tokenB) public view returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                INIT_CODE_HASH\\n            ))));\\n    }\\n\\n    function setNewPriceUpdater(address _priceUpdater) external {\\n        require(msg.sender == priceUpdater, 'BSWOracle: Price can update only price updater address');\\n        priceUpdater = _priceUpdater;\\n    }\\n\\n    function updateBulk(address[] calldata pairs) external {\\n        require(msg.sender == priceUpdater, 'BSWOracle: Price can update only price updater address');\\n\\n        for(uint i = 0; i < pairs.length; i++){\\n            Observation storage observation = pairObservations[pairs[i]];\\n            uint timeElapsed = block.timestamp - observation.timestamp;\\n            if(timeElapsed >= CYCLE){\\n                (uint price0Cumulative, uint price1Cumulative,) = BSWOracleLibrary.currentCumulativePrices(pairs[i]);\\n                observation.timestamp = block.timestamp;\\n                observation.price0Cumulative = price0Cumulative;// IBiswapPair(pairs[i]).price0CumulativeLast();\\n                observation.price1Cumulative = price1Cumulative; //IBiswapPair(pairs[i]).price1CumulativeLast();\\n            } else {\\n                emit NotUpdate(pairs[i]);\\n            }\\n        }\\n    }\\n\\n    function update(address tokenA, address tokenB) public {\\n        require(msg.sender == priceUpdater, 'BSWOracle: Price can update only price updater address');\\n        address pair = pairFor(tokenA, tokenB);\\n\\n        Observation storage observation = pairObservations[pair];\\n        uint timeElapsed = block.timestamp - observation.timestamp;\\n        require(timeElapsed >= CYCLE, 'BSWOracle: PERIOD_NOT_ELAPSED');\\n        (uint price0Cumulative, uint price1Cumulative,) = BSWOracleLibrary.currentCumulativePrices(pair);\\n        observation.timestamp = block.timestamp;\\n        observation.price0Cumulative = price0Cumulative;\\n        observation.price1Cumulative = price1Cumulative;\\n    }\\n\\n\\n    function computeAmountOut(\\n        uint priceCumulativeStart, uint priceCumulativeEnd,\\n        uint timeElapsed, uint amountIn\\n    ) private pure returns (uint amountOut) {\\n        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(\\n            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\\n        );\\n        amountOut = priceAverage.mul(amountIn).decode144();\\n    }\\n\\n\\n    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {\\n        address pair = pairFor(tokenIn, tokenOut);\\n        Observation storage observation = pairObservations[pair];\\n\\n        if (pairObservations[pair].price0Cumulative == 0 || pairObservations[pair].price1Cumulative == 0){\\n            return 0;\\n        }\\n\\n        uint timeElapsed = block.timestamp - observation.timestamp;\\n        (uint price0Cumulative, uint price1Cumulative,) = BSWOracleLibrary.currentCumulativePrices(pair);\\n        (address token0,) = sortTokens(tokenIn, tokenOut);\\n\\n        if (token0 == tokenIn) {\\n            return computeAmountOut(observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\\n        } else {\\n            return computeAmountOut(observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap-fee-reward/contracts/libs/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\nlibrary SafeMath {\\n    uint256 constant WAD = 10 ** 18;\\n    uint256 constant RAY = 10 ** 27;\\n\\n    function wad() public pure returns (uint256) {\\n        return WAD;\\n    }\\n\\n    function ray() public pure returns (uint256) {\\n        return RAY;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function sqrt(uint256 a) internal pure returns (uint256 b) {\\n        if (a > 3) {\\n            b = a;\\n            uint256 x = a / 2 + 1;\\n            while (x < b) {\\n                b = x;\\n                x = (a / x + x) / 2;\\n            }\\n        } else if (a != 0) {\\n            b = 1;\\n        }\\n    }\\n\\n    function wmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul(a, b) / WAD;\\n    }\\n\\n    function wmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, b), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul(a, b) / RAY;\\n    }\\n\\n    function rmulRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, b), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(mul(a, WAD), b);\\n    }\\n\\n    function wdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, WAD), b / 2) / b;\\n    }\\n\\n    function rdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(mul(a, RAY), b);\\n    }\\n\\n    function rdivRound(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add(mul(a, RAY), b / 2) / b;\\n    }\\n\\n    function wpow(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 result = WAD;\\n        while (n > 0) {\\n            if (n % 2 != 0) {\\n                result = wmul(result, x);\\n            }\\n            x = wmul(x, x);\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256) {\\n        uint256 result = RAY;\\n        while (n > 0) {\\n            if (n % 2 != 0) {\\n                result = rmul(result, x);\\n            }\\n            x = rmul(x, x);\\n            n /= 2;\\n        }\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/swap-fee-reward/contracts/libs/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\"\r\n    },\r\n    \"contracts/swap-fee-reward/contracts/libs/OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity 0.6.6;\\n\\nimport \\\"./FixedPoint.sol\\\";\\ninterface IBiswapPair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function swapFee() external view returns (uint32);\\n    function devFee() external view returns (uint32);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n    function setSwapFee(uint32) external;\\n    function setDevFee(uint32) external;\\n}\\n\\nlibrary BSWOracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IBiswapPair(pair).price0CumulativeLast();\\n        price1Cumulative = IBiswapPair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IBiswapPair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"INIT_CODE_HASH_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"priceUpdater_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"NotUpdate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CYCLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"consult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"pairFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairObservations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1Cumulative\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceUpdater\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceUpdater\",\"type\":\"address\"}],\"name\":\"setNewPriceUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"sortTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pairs\",\"type\":\"address[]\"}],\"name\":\"updateBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OracleV2", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000858e3312ed3a876947ea49d572a7c42de08af7eefea293c909d87cd4153593f077b76bb7e94340200f4ee84211ae8e4f9bd7ffdf000000000000000000000000d3a70caa19d72d9ed09520594cae4eea7812ab51", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}