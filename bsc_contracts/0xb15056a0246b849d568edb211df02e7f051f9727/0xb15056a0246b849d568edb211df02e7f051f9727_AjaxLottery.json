{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.18;\r\n\r\n\r\ncontract Callable {\r\n\r\n    address payable private _context;\r\n    address private _creator;\r\n\r\n    constructor() { \r\n        _context = payable(address(this));\r\n        _creator = msg.sender;\r\n        emit CreateContext(_context, _creator);\r\n    }\r\n\r\n    function _contextAddress() internal view returns (address payable) {\r\n        return _context;\r\n    }\r\n\r\n    function _contextCreator() internal view returns (address) {\r\n        return _creator;\r\n    }\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n\r\n    function _msgTimestamp() internal view returns (uint256) {\r\n        this;\r\n        return block.timestamp;\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    event CreateContext(address contextAddress, address contextCreator);\r\n}\r\n\r\ncontract Manageable is Callable {\r\n    address private _executiveManager;\r\n    mapping(address => bool) private _isManager;\r\n    address[] private _managers;\r\n\r\n    bool private _managementIsLocked = false;\r\n    uint256 private _managementUnlockTime = 0;\r\n    uint256 private _maxNumberOfManagers = 10;\r\n\r\n    constructor () {\r\n        _executiveManager = _contextCreator();\r\n        _isManager[_executiveManager] = true;\r\n        _managers.push(_executiveManager);\r\n\r\n        emit ManagerAdded(_executiveManager);\r\n        emit ExecutiveManagerChanged(address(0), _executiveManager);\r\n    }\r\n\r\n    function executiveManager() public view returns (address) {\r\n        return _executiveManager;\r\n    }\r\n\r\n    function isManager(address account) public view returns (bool) {\r\n        return _isManager[account];\r\n    }\r\n\r\n    function managementIsLocked() public view returns (bool) {\r\n        return _managementIsLocked;\r\n    }\r\n\r\n    function timeToManagementUnlock() public view returns (uint256) {\r\n        return block.timestamp >= _managementUnlockTime ? 0 : _managementUnlockTime - block.timestamp;\r\n    }\r\n    \r\n    function addManager(address newManager) public onlyExecutive() returns (bool) {\r\n        require(!_isManager[newManager], \"Account is already a manager\");\r\n        require(newManager != address(0), \"0 address cannot be made manager\");\r\n        require(_managers.length <= _maxNumberOfManagers, \"max number of managers reached\");\r\n\r\n        _isManager[newManager] = true;\r\n        _managers.push(newManager);\r\n\r\n        emit ManagerAdded(newManager);\r\n\r\n        return true;\r\n    }\r\n\r\n    function removeManager(address managerToRemove) public onlyExecutive() returns (bool) {\r\n        require(_isManager[managerToRemove], \"Account is already not a manager\");\r\n        require(managerToRemove != _executiveManager, \"Executive manager cannot be removed\");\r\n\r\n        _isManager[managerToRemove] = false;\r\n        for(uint256 i = 0; i < _managers.length; i++) {\r\n            if(_managers[i] == managerToRemove){\r\n                _managers[i] = _managers[_managers.length - 1];\r\n                _managers.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit ManagerRemoved(managerToRemove);\r\n\r\n        return true;\r\n    }\r\n\r\n    function changeExecutiveManager(address newExecutiveManager) public onlyExecutive() returns (bool) {\r\n        require(newExecutiveManager != _executiveManager, \"Manager is already the executive\");\r\n\r\n        if(!_isManager[newExecutiveManager]){\r\n            _isManager[newExecutiveManager] = true;\r\n            emit ManagerAdded(newExecutiveManager);\r\n        }\r\n        _executiveManager = newExecutiveManager;\r\n\r\n        emit ExecutiveManagerChanged(_executiveManager, newExecutiveManager);\r\n\r\n        return true;\r\n    }\r\n\r\n    function lockManagement(uint256 lockDuration) public onlyExecutive() returns (bool) {\r\n        _managementIsLocked = true;\r\n        _managementUnlockTime = block.timestamp + lockDuration;\r\n\r\n        emit ManagementLocked(lockDuration);\r\n\r\n        return true;\r\n    }\r\n\r\n    function unlockManagement() public onlyExecutive() returns (bool) {\r\n        _managementIsLocked = false;\r\n        _managementUnlockTime = 0;\r\n\r\n        emit ManagementUnlocked();\r\n\r\n        return true;\r\n    }\r\n\r\n    function renounceManagement() public onlyExecutive() returns (bool) {\r\n        while(_managers.length > 0) {\r\n            _isManager[_managers[_managers.length - 1]] = false;\r\n\r\n            emit ManagerRemoved(_managers[_managers.length - 1]);\r\n\r\n            if(_managers[_managers.length - 1] == _executiveManager){\r\n                emit ExecutiveManagerChanged(_executiveManager, address(0));\r\n                _executiveManager = address(0);\r\n            }\r\n\r\n            _managers.pop();\r\n        }\r\n\r\n        emit ManagementRenounced();\r\n\r\n        return true;\r\n    }\r\n\r\n    event ManagerAdded(address addedManager);\r\n    event ManagerRemoved(address removedManager);\r\n    event ExecutiveManagerChanged(address indexed previousExecutiveManager, address indexed newExecutiveManager);\r\n    event ManagementLocked(uint256 lockDuration);\r\n    event ManagementUnlocked();\r\n    event ManagementRenounced();\r\n\r\n    modifier onlyExecutive() {\r\n        require(_msgSender() == _executiveManager, \"Caller is not the executive manager\");\r\n        require(!_managementIsLocked || block.timestamp >= _managementUnlockTime, \"Management is locked\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyManagement() {\r\n        require(_isManager[_msgSender()], \"Caller is not a manager\");\r\n        require(!_managementIsLocked, \"Management is locked\");\r\n        _;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function burn(uint256 amount) external;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if(b >= a){\r\n            return 0;\r\n        }\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\ncontract AjaxLottery is Manageable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n    address public _deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    uint256 private lotteryNumber;\r\n    mapping (uint256 => mapping(uint8 => address[])) private winners;\r\n    mapping (uint8 => uint256) public prizeBaskets;\r\n\r\n    address private bigPrizeWinner;\r\n    address private prevBigPrizeWinner;\r\n\r\n    uint256 private currWinnerTicket;\r\n\r\n    uint256[] private prevTickets;\r\n    uint256 private maxNumberOfPrevTicketSave;\r\n\r\n    mapping (uint256 => mapping(uint256 => bool)) private usedTicketNumbers;\r\n    uint256 private numOfPastBigPrizeWinners;\r\n\r\n    uint256 public totalCurrentPrize;\r\n\r\n    uint256 private numberOfPrevParticipants;\r\n\r\n    address private AJAXContractAddress = 0xD574E79B38923d51ff5Bf5bccb97E5b8aDe45182;\r\n\r\n    address private ownerAddress;\r\n\r\n    bool public isLotteryUnderway;\r\n\r\n    uint8 public hardness;\r\n\r\n    uint8 private numberOfBaskets;\r\n    uint256[] private winnerPercentages;\r\n\r\n    uint256 public burnAndReferralsPercentage;\r\n\r\n    constructor() {\r\n        ownerAddress = _msgSender();\r\n        totalCurrentPrize = 0;\r\n        bigPrizeWinner = _deadAddress;\r\n        numberOfPrevParticipants = 0;\r\n        maxNumberOfPrevTicketSave = 20;\r\n        numOfPastBigPrizeWinners = 0;\r\n        isLotteryUnderway = false;\r\n        hardness = 5;\r\n        numberOfBaskets = 3;\r\n        winnerPercentages.push(30);\r\n        winnerPercentages.push(20);\r\n        winnerPercentages.push(10);\r\n        lotteryNumber = 0;\r\n        burnAndReferralsPercentage = 40;\r\n    }\r\n\r\n    function insertInPrevTickets(uint256 ticketNumber) internal {\r\n        if (prevTickets.length == maxNumberOfPrevTicketSave) {\r\n            for (uint8 i = 1; i < maxNumberOfPrevTicketSave; i++)\r\n                prevTickets[i - 1] = prevTickets[i];\r\n            prevTickets[maxNumberOfPrevTicketSave - 1] = ticketNumber;\r\n        }\r\n        else {\r\n            prevTickets.push(ticketNumber);\r\n        }\r\n        usedTicketNumbers[numOfPastBigPrizeWinners][ticketNumber] = true;\r\n    }\r\n\r\n    function random() private view returns (uint) {\r\n        uint256 randNum = uint(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, numberOfBaskets, lotteryNumber, numberOfPrevParticipants))) % 10 ** hardness;\r\n        while (randNum < 10 ** (hardness - 1))\r\n            randNum *= 10;\r\n        \r\n        uint8 salt = 0;\r\n        while (usedTicketNumbers[numOfPastBigPrizeWinners][randNum]) {\r\n            randNum = uint(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, numberOfBaskets, lotteryNumber, numberOfPrevParticipants, salt))) % 10 ** hardness;\r\n            while (randNum < 10 ** (hardness - 1))\r\n                randNum *= 10;\r\n            salt += 1;\r\n        }\r\n        return randNum;\r\n    }\r\n\r\n    function createNewLottery() public onlyManagement() {\r\n        require(!isLotteryUnderway, 'There is an active lottery.');\r\n\r\n        uint256 newRand = random();\r\n\r\n        totalCurrentPrize = 0;\r\n\r\n        bigPrizeWinner = _deadAddress;\r\n\r\n        currWinnerTicket = newRand;\r\n        isLotteryUnderway = true;\r\n\r\n        emit LotteryStarted();\r\n    }\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = SafeMath.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), \"0123456789abcdef\"))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    function getNumberOfSimilarities(uint256 num1, uint256 num2) internal view returns(uint8) {\r\n        bytes memory num1Str = bytes(toString(num1));\r\n        bytes memory num2Str = bytes(toString(num2));\r\n\r\n        uint8 totalSim = 0;\r\n        for (uint8 i = 0; i < hardness; i++) {\r\n            if (num1Str[i] == num2Str[i])\r\n                totalSim += 1;\r\n        }\r\n\r\n        return totalSim;\r\n    }\r\n\r\n    function addParticipant(address participant, uint256 amount, uint256 ticketNumber) public onlyManagement() {\r\n        require(isLotteryUnderway, 'No active lottery.');\r\n        require(ticketNumber >= 10 ** (hardness - 1), 'Ticket does not have valid number of digits. Check hardness.');\r\n        require(ticketNumber < 10 ** hardness, 'Ticket does not have valid number of digits. Check hardness.');\r\n\r\n        uint8 simsWithWinTicket = getNumberOfSimilarities(currWinnerTicket, ticketNumber);\r\n\r\n        for (uint8 i = 0; i < numberOfBaskets; i++) {\r\n            if (i == 0) {\r\n                if (simsWithWinTicket == hardness) {\r\n                    bigPrizeWinner = participant;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                if (simsWithWinTicket == (hardness - i)) {\r\n                    winners[lotteryNumber][i].push(participant);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        totalCurrentPrize = totalCurrentPrize.add(amount);\r\n        numberOfPrevParticipants += 1;\r\n\r\n        emit ParticipantAdded(participant, amount, ticketNumber);\r\n    }\r\n\r\n    function endLottery() public onlyManagement() {\r\n        require(isLotteryUnderway, 'No active lottery');\r\n\r\n        IBEP20 AjaxInterface = IBEP20(AJAXContractAddress);\r\n\r\n        for (uint8 i = 0; i < numberOfBaskets; i++) {\r\n            uint256 prizeShare = uint256(totalCurrentPrize.mul(winnerPercentages[i]).div(100));\r\n            uint256 totalPrize = prizeShare.add(prizeBaskets[i]);\r\n\r\n            if (i == 0) {\r\n                if (bigPrizeWinner != _deadAddress) {\r\n                    AjaxInterface.transfer(bigPrizeWinner, totalPrize);\r\n\r\n                    prizeBaskets[i] = 0;\r\n                    numOfPastBigPrizeWinners += 1;\r\n                }\r\n                else {\r\n                    prizeBaskets[i] += prizeShare;\r\n                }\r\n            }\r\n            else {\r\n                if (winners[lotteryNumber][i].length != 0) {\r\n                    uint256 participantBite = uint256(totalPrize.div(winners[lotteryNumber][i].length));\r\n\r\n                    for (uint8 j = 0; j < winners[lotteryNumber][i].length; j++) {\r\n                        AjaxInterface.transfer(winners[lotteryNumber][i][j], participantBite);\r\n                    }\r\n\r\n                    prizeBaskets[i] = 0;\r\n                }\r\n                else {\r\n                    prizeBaskets[i] = prizeBaskets[i].add(prizeShare);\r\n                }\r\n            }\r\n        }\r\n\r\n        prevBigPrizeWinner = bigPrizeWinner;\r\n\r\n        insertInPrevTickets(currWinnerTicket);\r\n\r\n        isLotteryUnderway = false;\r\n        lotteryNumber += 1;\r\n\r\n        emit LotteryEnded(currWinnerTicket);\r\n    }\r\n\r\n    function getPrevWinnerTickets() public view returns(uint256[] memory){\r\n        return prevTickets;\r\n    }\r\n\r\n    function getPrevBigPrizeWinner() public view returns(address){\r\n        return prevBigPrizeWinner;\r\n    }\r\n\r\n    function getPrevFirstPrizeWinners(uint8 dissimilarity) public view returns(address[] memory){\r\n        require(dissimilarity > 1, \"Dissimalirty must be higher than 1. For big prize winner use getPrevBigPrizeWinner\");\r\n        return winners[lotteryNumber - 1][dissimilarity];\r\n    }\r\n\r\n    function setHardness(uint8 newHardness) public onlyManagement() {\r\n        require(!isLotteryUnderway, 'There is an active lottery.');\r\n        require(newHardness > 0, \"Length of winner number cannot be less than 1\");\r\n        hardness = newHardness;\r\n    }\r\n\r\n    function setPercentages(uint256[] calldata newPercentages) public onlyManagement() {\r\n        require(!isLotteryUnderway, 'There is an active lottery.');\r\n        require (newPercentages.length > 1, \"At least two shares must be specified\");\r\n        uint256 sharesSum = 0;\r\n        for (uint8 i = 0; i < newPercentages.length; i++)\r\n            sharesSum += newPercentages[i];\r\n\r\n        require (sharesSum == 100, \"Total shares must add to 100.\");\r\n\r\n        burnAndReferralsPercentage = newPercentages[newPercentages.length - 1];\r\n\r\n        uint8 newBasketNum = uint8(newPercentages.length - 1);\r\n        if (newBasketNum < numberOfBaskets) {\r\n            for (uint8 i = newBasketNum; i < numberOfBaskets; i++) {\r\n                uint256 distributeAmount = uint256(prizeBaskets[i].div(newBasketNum));\r\n\r\n                for (uint8 j = 0; j < newBasketNum; j++)\r\n                    prizeBaskets[j] = prizeBaskets[j].add(distributeAmount);\r\n                \r\n                prizeBaskets[i] = 0;\r\n            }\r\n        }\r\n\r\n        numberOfBaskets = newBasketNum;\r\n\r\n        delete winnerPercentages;\r\n        for (uint8 i = 0; i < numberOfBaskets; i++) \r\n            winnerPercentages.push(newPercentages[i]);\r\n    }\r\n\r\n    event LotteryStarted();\r\n    event LotteryEnded(uint256 winningNumber);\r\n    event ParticipantAdded(address participant, uint256 amount, uint256 ticketNumber);\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contextAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contextCreator\",\"type\":\"address\"}],\"name\":\"CreateContext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutiveManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutiveManager\",\"type\":\"address\"}],\"name\":\"ExecutiveManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningNumber\",\"type\":\"uint256\"}],\"name\":\"LotteryEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LotteryStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"name\":\"ManagementLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManagementRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManagementUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addedManager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedManager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ticketNumber\",\"type\":\"uint256\"}],\"name\":\"ParticipantAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketNumber\",\"type\":\"uint256\"}],\"name\":\"addParticipant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAndReferralsPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExecutiveManager\",\"type\":\"address\"}],\"name\":\"changeExecutiveManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createNewLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executiveManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrevBigPrizeWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"dissimilarity\",\"type\":\"uint8\"}],\"name\":\"getPrevFirstPrizeWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrevWinnerTickets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardness\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLotteryUnderway\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"name\":\"lockManagement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"prizeBaskets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerToRemove\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newHardness\",\"type\":\"uint8\"}],\"name\":\"setHardness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newPercentages\",\"type\":\"uint256[]\"}],\"name\":\"setPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToManagementUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCurrentPrize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockManagement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AjaxLottery", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9cd47c22d8f430542e8a19272544ada5d40889db8e90ec4599ddf071d7f9af87"}