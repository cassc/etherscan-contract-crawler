{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.3;\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n}\r\nlibrary RoundPool{\r\n    using SafeMath for uint256;\r\n    struct RoundBalance{\r\n        uint8 status;\r\n        uint256 claim;\r\n        uint256 total;\r\n    }\r\n    struct RoundTime{\r\n        uint256 timeStart;\r\n        uint256 timeEnd;\r\n        uint256 timeUnlockStart;\r\n        uint256 timeUnlockEnd;\r\n        uint256 timeUnlockVesting;\r\n        uint256 price;\r\n    }\r\n    function inc(RoundBalance storage round,uint256 amount)internal returns(uint256){\r\n        round.total = round.total.add(amount);\r\n        if(round.status!=1){\r\n            round.status = 1;\r\n        }\r\n        return round.total;\r\n    }\r\n    function getReflection(RoundBalance storage round,RoundTime memory roundTime)internal view returns(uint256){\r\n        uint256 balance = 0;\r\n        if(round.status==1 && block.timestamp > roundTime.timeUnlockStart){\r\n            uint256 sec = 0;\r\n            uint256 end = roundTime.timeUnlockEnd - roundTime.timeUnlockStart;\r\n            if(end<=0){\r\n                return balance;\r\n            }\r\n            if(block.timestamp >= roundTime.timeUnlockEnd){\r\n                sec = roundTime.timeUnlockEnd - roundTime.timeUnlockStart;\r\n            }else{\r\n                sec = block.timestamp - roundTime.timeUnlockStart;\r\n            }\r\n            if(sec>0 && sec<end){\r\n                balance = round.total.mul(sec).div(end);\r\n                for(uint256 i=0; i < roundTime.timeUnlockVesting; i++){\r\n                    if(round.total.mul(i).div(roundTime.timeUnlockVesting) < balance \r\n                        && balance <= round.total.mul(i+1).div(roundTime.timeUnlockVesting)){\r\n                        balance = round.total.mul(i+1).div(roundTime.timeUnlockVesting);\r\n                    }\r\n                }\r\n                if(balance > round.claim){\r\n                    balance = balance.sub(round.claim);\r\n                }else{\r\n                    balance = 0;\r\n                }\r\n            }else if(sec>0 && sec>=end && round.total>round.claim){\r\n                balance = round.total.sub(round.claim);\r\n            }\r\n        }\r\n        return balance;\r\n    }\r\n    function settle(RoundBalance storage round,RoundTime memory roundTime,uint256 amount)internal returns(uint256 surplus){\r\n        surplus = 0;\r\n        if(amount > 0 && round.status == 1 && block.timestamp >= roundTime.timeEnd){\r\n            uint256 balance = getReflection(round,roundTime);\r\n            if(amount>balance){\r\n                surplus = amount.sub(balance);\r\n                round.claim = round.claim.add(balance);\r\n            }else{\r\n                surplus = 0;\r\n                round.claim = round.claim.add(amount);\r\n            }\r\n            if(round.claim>=round.total){\r\n                round.status=0;\r\n            }\r\n        }else{\r\n            surplus = amount;\r\n        }\r\n    }\r\n}\r\ninterface IPancakeSwapPair {\r\n\t\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\t\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\t\tfunction name() external pure returns (string memory);\r\n\t\tfunction symbol() external pure returns (string memory);\r\n\t\tfunction decimals() external pure returns (uint8);\r\n\t\tfunction totalSupply() external view returns (uint);\r\n\t\tfunction balanceOf(address owner) external view returns (uint);\r\n\t\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\r\n\t\tfunction approve(address spender, uint value) external returns (bool);\r\n\t\tfunction transfer(address to, uint value) external returns (bool);\r\n\t\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n\t\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\t\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\t\tfunction nonces(address owner) external view returns (uint);\r\n\t\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\t\tevent Mint(address indexed sender, uint amount0, uint amount1);\r\n\t\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n\t\tevent Swap(\r\n\t\t\t\taddress indexed sender,\r\n\t\t\t\tuint amount0In,\r\n\t\t\t\tuint amount1In,\r\n\t\t\t\tuint amount0Out,\r\n\t\t\t\tuint amount1Out,\r\n\t\t\t\taddress indexed to\r\n\t\t);\r\n\t\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\t\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\t\tfunction factory() external view returns (address);\r\n\t\tfunction token0() external view returns (address);\r\n\t\tfunction token1() external view returns (address);\r\n\t\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\t\tfunction price0CumulativeLast() external view returns (uint);\r\n\t\tfunction price1CumulativeLast() external view returns (uint);\r\n\t\tfunction kLast() external view returns (uint);\r\n\t\tfunction mint(address to) external returns (uint liquidity);\r\n\t\tfunction burn(address to) external returns (uint amount0, uint amount1);\r\n\t\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\t\tfunction skim(address to) external;\r\n\t\tfunction sync() external;\r\n\t\tfunction initialize(address, address) external;\r\n}\r\ninterface IPancakeSwapRouter{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n            address tokenA,\r\n            address tokenB,\r\n            uint amountADesired,\r\n            uint amountBDesired,\r\n            uint amountAMin,\r\n            uint amountBMin,\r\n            address to,\r\n            uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n            address token,\r\n            uint amountTokenDesired,\r\n            uint amountTokenMin,\r\n            uint amountETHMin,\r\n            address to,\r\n            uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n            address tokenA,\r\n            address tokenB,\r\n            uint liquidity,\r\n            uint amountAMin,\r\n            uint amountBMin,\r\n            address to,\r\n            uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n            address token,\r\n            uint liquidity,\r\n            uint amountTokenMin,\r\n            uint amountETHMin,\r\n            address to,\r\n            uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n            address tokenA,\r\n            address tokenB,\r\n            uint liquidity,\r\n            uint amountAMin,\r\n            uint amountBMin,\r\n            address to,\r\n            uint deadline,\r\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n            address token,\r\n            uint liquidity,\r\n            uint amountTokenMin,\r\n            uint amountETHMin,\r\n            address to,\r\n            uint deadline,\r\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n            uint amountIn,\r\n            uint amountOutMin,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n            uint amountOut,\r\n            uint amountInMax,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n            external\r\n            payable\r\n            returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n            external\r\n            returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n            external\r\n            returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n            external\r\n            payable\r\n            returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IPancakeSwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\ncontract PooPad {\r\n    using SafeMath for uint256;\r\n    using RoundPool for RoundPool.RoundBalance;\r\n    uint256 public totalSupply = 10000000000 ether; //10b\r\n    string public name = \"PooPad\";\r\n    string public symbol = \"POOPAD\";\r\n    uint8 public decimals = 18;\r\n    address public owner;\r\n    uint256 public cap = 0;\r\n    uint256 private _roundRate = 5000; //price x2 each round\r\n    uint256 private _roundCycle = 2592000; //30 days\r\n    uint256 private _roundUnlockStart = 10368000; //120 days\r\n    uint256 private _roundUnlockEnd = 25920000; //300 days, 10 months\r\n    uint256 public saleMin = 0.001 ether;\r\n    bool public swSale = true;\r\n    uint256 public _refRate = 10; //0%\r\n    address private _liquidity;\r\n    address public airdrop;   \r\n    mapping (address => RoundPool.RoundBalance) private _roundBalances;\r\n    RoundPool.RoundTime private _roundTime;\r\n    mapping (address => uint256) private _balances;   \r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    ////////////////////////////////////////////////\r\n    IPancakeSwapPair public pairContract;\r\n    mapping(address => bool) _isFeeExempt;\r\n\r\n    uint256 public liquidityFee = 40;\r\n    uint256 public treasuryFee = 45;\r\n    uint256 public insuranceFundFee = 50;\r\n    uint256 public blackHoleFee = 25;\r\n    uint256 public totalFee = liquidityFee.add(treasuryFee).add(insuranceFundFee).add(blackHoleFee);\r\n    uint256 public feeDenominator = 1000;\r\n    address public autoLiquidityReceiver;\r\n    address public treasuryReceiver;\r\n    address public insuranceFundReceiver;\r\n    address public blackHole;\r\n    address public pairAddress;\r\n    IPancakeSwapRouter public router;\r\n    address public pair;\r\n    bool public inSwap = false;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    bool public _autoAddLiquidity;\r\n    uint256 public _lastAddLiquidityTime;\r\n\r\n    mapping(address => bool) public blacklist;\r\n    mapping(address => bool) public whitelist;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        //price 1bnb = 1,000,000 token\r\n        _roundTime = RoundPool.RoundTime(\r\n            block.timestamp,\r\n            block.timestamp + _roundCycle,\r\n            block.timestamp + _roundCycle + _roundUnlockStart,\r\n            block.timestamp + _roundCycle + _roundUnlockStart + _roundUnlockEnd,\r\n            12,\r\n            1000000);\r\n        _setRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);      \r\n        autoLiquidityReceiver = 0x092fE0eFeE0C0E20C485852f43dBDB00104Cb66e;\r\n        treasuryReceiver = 0xC16e55d06aC7aCe4A2a4BC6087eB4dAb6bfBf86B; \r\n        insuranceFundReceiver = 0xBAD0acDa8E63af585b9E19935f588068bAbE224c;\r\n        blackHole = 0x000000000000000000000000000000000000dEaD;\r\n        _liquidity = treasuryReceiver;\r\n        _allowances[address(this)][address(router)] = type(uint128).max;\r\n        pairAddress = pair;\r\n        pairContract = IPancakeSwapPair(pair);          \r\n        _autoAddLiquidity = true;\r\n        _isFeeExempt[treasuryReceiver] = true;\r\n        _isFeeExempt[address(this)] = true;\r\n        _isFeeExempt[owner] = true;\r\n        whitelist[pair] = true;\r\n        whitelist[treasuryReceiver] = true;\r\n        whitelist[address(this)] = true;\r\n        whitelist[owner] = true;\r\n        _mint(owner, totalSupply.div(20));   \r\n    }\r\n\r\n    function _setRouter(address _router) private  {\r\n        router = IPancakeSwapRouter(_router);\r\n        pair = IPancakeSwapFactory(router.factory()).createPair(\r\n            router.WETH(),\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    function setRouter(address _router) public onlyOwner {\r\n        _setRouter(_router);\r\n    }\r\n\r\n    fallback() external {}\r\n    receive() payable external {}\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account] + getRoundTotal(account);\r\n    }\r\n\r\n    function allowance(address owner_, address spender) public view returns (uint256) {\r\n        return _allowances[owner_][spender];\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner{\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setLiquidity(address liquidity_) public onlyOwner returns(bool){\r\n        require(liquidity_ != address(0), \"Liquidity: new liquidity is the zero address\");\r\n        _liquidity = liquidity_;\r\n        return true;\r\n    }\r\n\r\n    function setAirdrop(address airdrop_) public onlyOwner returns(bool){\r\n        require(airdrop_ != address(0), \"Airdrop: new Airdrop is the zero address\");\r\n        airdrop = airdrop_;\r\n        return true;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        cap = cap.add(amount);\r\n        if(cap>totalSupply){\r\n            totalSupply=cap;\r\n        }\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(this), account, amount);\r\n    }\r\n\r\n    function incRoundBalance(address account, uint256 amount)private returns(bool){\r\n        cap = cap.add(amount);\r\n        if(cap>totalSupply){\r\n            totalSupply=cap;\r\n        }\r\n        _roundBalances[account].inc(amount);\r\n        return true;\r\n    }\r\n\r\n    function spend(address account, uint256 amount) private{\r\n        require(_balances[account].add(getRoundBalance(account)) >= amount,\"ERC20: Insufficient balance\");\r\n        uint256 balance = amount;\r\n        \r\n        if(_roundBalances[msg.sender].status==1){\r\n            balance = _roundBalances[msg.sender].settle(_roundTime,balance);\r\n        }\r\n        \r\n        if(balance>0){\r\n            _balances[account] = _balances[account].sub(balance, \"ERC20: Insufficient balance\");\r\n        }\r\n    }\r\n\r\n    function getRoundBalance(address addr)public view returns(uint256 balance){\r\n        balance = 0;\r\n        if(_roundBalances[addr].status==1){\r\n            balance = balance.add(_roundBalances[addr].getReflection(_roundTime));\r\n        }\r\n    }\r\n\r\n    function getRoundTotal(address addr)public view returns(uint256 balance){\r\n        balance = 0;\r\n        if(_roundBalances[addr].status==1){\r\n            balance = balance.add(_roundBalances[addr].total.sub(_roundBalances[addr].claim));\r\n        }\r\n    }\r\n\r\n    function _approve(address owner_, address spender, uint256 amount) internal {\r\n        require(owner_ != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner_][spender] = amount;\r\n        emit Approval(owner_, spender, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function clear() public onlyOwner {        \r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function update(uint256 tag, uint256 value)public onlyOwner returns(bool){        \r\n        if(tag==1){\r\n            swSale = (value == 1);\r\n        }else if(tag==2){\r\n            _roundRate = value;\r\n        }else if(tag==3){\r\n            _roundCycle = value;\r\n        }else if(tag==4){\r\n            saleMin = value;\r\n        }else if(tag==5 && _liquidity!=address(0)){\r\n            _mint(_liquidity, value);              \r\n        }else if(tag==6){\r\n            _refRate = value;\r\n        }else if(tag==7){           \r\n            _autoAddLiquidity = (value == 1);\r\n        }else if(tag==10){\r\n            _roundTime.timeStart = value;\r\n        }else if(tag==11){\r\n            _roundTime.timeEnd = value;\r\n        }else if(tag==12){\r\n            _roundTime.timeUnlockStart = value;\r\n        }else if(tag==13){\r\n            _roundTime.timeUnlockEnd = value;\r\n        }else if(tag==14){\r\n            _roundTime.price = value;\r\n        }else if(tag==15){\r\n           _roundTime.timeUnlockVesting = value;\r\n        }\r\n        return true;\r\n    }\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal {       \r\n        require(!blacklist[sender], \"in_blacklist\");        \r\n\r\n        if (inSwap) {\r\n            _balances[sender] = _balances[sender].sub(amount);\r\n            _balances[recipient] = _balances[recipient].add(amount);\r\n            emit Transfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n        if(sender == airdrop){\r\n            _balances[sender] = _balances[sender].sub(amount);\r\n            _roundBalances[recipient].inc(amount);\r\n            emit Transfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n        if (shouldAddLiquidity()) {\r\n            addLiquidity();\r\n        }\r\n        if (shouldSwapBack()) {\r\n            swapBack();\r\n        }\r\n        \r\n        uint256 amountReceived = shouldTakeFee(sender, recipient)? takeFee(sender, amount): amount;        \r\n        spend(sender, amount);\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);        \r\n        emit Transfer(sender, recipient, amountReceived);\r\n    }\r\n    function buyToken(address _refer) payable public returns(bool){\r\n        require(_liquidity != address(0),\"Empty liquidity\");\r\n        require(msg.value >= saleMin,\"The amount is too small\");\r\n        require(swSale,\"End of this round\");\r\n        uint256 _msgValue = msg.value;\r\n        uint256 _token = _msgValue.mul(_roundTime.price);        \r\n        payable(address(uint160(_liquidity))).transfer(_msgValue);        \r\n        if(_token>0){\r\n            incRoundBalance(msg.sender,_token);\r\n            emit Transfer(address(this), msg.sender, _token);\r\n            if(_refRate > 0 && msg.sender != _refer){                        \r\n                uint256 _refToken = _token.mul(_refRate).div(100);\r\n                incRoundBalance(_refer,_refToken);\r\n                emit Transfer(address(this), _refer, _refToken);\r\n            }\r\n        }        \r\n        return true;\r\n    }\r\n    function takeFee(\r\n        address sender,\r\n        uint256 amount\r\n    ) internal  returns (uint256) {        \r\n        uint256 feeAmount = amount.div(feeDenominator).mul(totalFee);\r\n\r\n        uint256 blackHoleFeeAmount = amount.div(feeDenominator).mul(blackHoleFee);      \r\n        _balances[blackHole] = _balances[blackHole].add(blackHoleFeeAmount);\r\n        emit Transfer(sender, blackHole, blackHoleFeeAmount);\r\n\r\n        uint256 itFeeAmount = amount.div(feeDenominator).mul(treasuryFee.add(insuranceFundFee)); \r\n        _balances[address(this)] = _balances[address(this)].add(itFeeAmount);\r\n        emit Transfer(sender, address(this), itFeeAmount);\r\n\r\n        uint256 liquidityFeeAmount = amount.div(feeDenominator).mul(liquidityFee); \r\n        _balances[autoLiquidityReceiver] = _balances[autoLiquidityReceiver].add(liquidityFeeAmount);\r\n        emit Transfer(sender, autoLiquidityReceiver, liquidityFeeAmount);\r\n        \r\n        return amount.sub(feeAmount);\r\n    }\r\n    function addLiquidity() internal swapping {\r\n        uint256 autoLiquidityAmount = _balances[autoLiquidityReceiver];\r\n        _balances[address(this)] = _balances[address(this)].add(\r\n            _balances[autoLiquidityReceiver]\r\n        );\r\n        _balances[autoLiquidityReceiver] = 0;\r\n        uint256 amountToLiquify = autoLiquidityAmount.div(2);\r\n        uint256 amountToSwap = autoLiquidityAmount.sub(amountToLiquify);\r\n\r\n        if( amountToSwap == 0 ) {\r\n            return;\r\n        }\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETHLiquidity = address(this).balance.sub(balanceBefore);\r\n\r\n        if (amountToLiquify > 0 && amountETHLiquidity > 0) {\r\n            router.addLiquidityETH{value: amountETHLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            );\r\n        }\r\n        _lastAddLiquidityTime = block.timestamp;\r\n    }\r\n    function swapBack() internal swapping {\r\n\r\n        uint256 amountToSwap = _balances[address(this)];\r\n\r\n        if( amountToSwap == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        \r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETHToTreasuryAndIF = address(this).balance.sub(\r\n            balanceBefore\r\n        );\r\n\r\n        (bool success, ) = payable(treasuryReceiver).call{\r\n            value: amountETHToTreasuryAndIF.mul(treasuryFee).div(\r\n                treasuryFee.add(insuranceFundFee)\r\n            ),\r\n            gas: 30000\r\n        }(\"\");\r\n        (success, ) = payable(insuranceFundReceiver).call{\r\n            value: amountETHToTreasuryAndIF.mul(insuranceFundFee).div(\r\n                treasuryFee.add(insuranceFundFee)\r\n            ),\r\n            gas: 30000\r\n        }(\"\");\r\n    }\r\n    function withdrawAllToTreasury() external swapping onlyOwner {\r\n\r\n        uint256 amountToSwap = _balances[address(this)];\r\n        require( amountToSwap > 0,\"There is no token deposited in token contract\");\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            treasuryReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n    function shouldTakeFee(address from, address to) internal  view returns (bool){\r\n        return \r\n            pair == to && !_isFeeExempt[from];\r\n    }\r\n    function shouldAddLiquidity() internal view returns (bool) {\r\n        return\r\n            _autoAddLiquidity && \r\n            !inSwap && \r\n            msg.sender != pair &&\r\n            block.timestamp >= (_lastAddLiquidityTime + 2 days);\r\n    }\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return \r\n            !inSwap &&\r\n            msg.sender != pair  ; \r\n    }\r\n    function checkFeeExempt(address _addr) external view returns (bool) {\r\n        return _isFeeExempt[_addr];\r\n    }\r\n    function manualSync() external {\r\n        IPancakeSwapPair(pair).sync();\r\n    }\r\n    function setFeeReceivers(\r\n        address _autoLiquidityReceiver,\r\n        address _treasuryReceiver,\r\n        address _insuranceFundReceiver,\r\n        address _blackHole\r\n    ) external onlyOwner {\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        treasuryReceiver = _treasuryReceiver;\r\n        insuranceFundReceiver = _insuranceFundReceiver;\r\n        blackHole = _blackHole;\r\n    }\r\n    function setFeeExempt(address _addr, bool _flag) external onlyOwner {\r\n        _isFeeExempt[_addr] = _flag;\r\n    }   \r\n    function setWhitelist(address _addr, bool _flag) external onlyOwner {\r\n        whitelist[_addr] = _flag;\r\n    }\r\n    function setBlacklist(address _botAddress, bool _flag) external onlyOwner {        \r\n        blacklist[_botAddress] = _flag;    \r\n    }\r\n    function setPairAddress(address _pairAddress) public onlyOwner {\r\n        pairAddress = _pairAddress;\r\n    }\r\n    function setLP(address _address) external onlyOwner {\r\n        pairContract = IPancakeSwapPair(_address);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAddLiquidityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_refRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackHole\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackHoleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refer\",\"type\":\"address\"}],\"name\":\"buyToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getRoundBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getRoundTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceFundReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairContract\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airdrop_\",\"type\":\"address\"}],\"name\":\"setAirdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_botAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_insuranceFundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_blackHole\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidity_\",\"type\":\"address\"}],\"name\":\"setLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pairAddress\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tag\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PooPad", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8cbf8460a32e0caf3d872669917008db27313f03c4faa44a4eb5c0b1787fba4a"}