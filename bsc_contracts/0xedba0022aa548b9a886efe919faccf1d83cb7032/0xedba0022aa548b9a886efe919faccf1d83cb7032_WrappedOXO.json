{"SourceCode": "// File: contracts/ITrustedPayToken.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// Interfaces of ERC20 USD Tokens\r\ninterface ITrustedPayToken {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/IERC20Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor() {\r\n        _name = \"Wrapped OXO Coin\";\r\n        _symbol = \"wOXO\";\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _mintFromSales(address account, uint256 amount) internal virtual {\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _burnForBuyBack(address account, uint256 amount) internal virtual {\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20: insufficient allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: contracts/ERC20Burnable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\n// File: contracts/WrappedOXO.sol\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract WrappedOXO is ERC20, ERC20Burnable, Pausable, Ownable {\r\n    uint256 public _version = 4;\r\n\r\n    address private SAFE_WALLET = 0x3edF93dc2e32fD796c108118f73fa2ae585C66B6;\r\n\r\n    uint256 private _transferableByFoundation;\r\n    uint256 public buyBackFund;\r\n    uint256 private _totalTranferredToFoundation;\r\n\r\n    mapping(address => bool) private contractManagers;\r\n\r\n    struct TransferChain {\r\n        address user;\r\n        uint256 chainId;\r\n        uint256 amount;\r\n        uint256 nonce;\r\n    }\r\n\r\n    TransferChain[] public TransferToChain;\r\n    uint256 public TransferToChainLatest = 0;\r\n\r\n    // User Info\r\n    struct UserInfo {\r\n        address user;\r\n        bool buyBackGuarantee;\r\n        uint256 totalCoinsFromSales;\r\n        uint256 totalBuyBackCoins;\r\n        uint256 totalBuyBackUSD;\r\n        uint256 balanceUSD;\r\n        uint256 totalDeposits;\r\n        uint256 totalPurchases;\r\n        uint256 totalWithdrawns;\r\n    }\r\n\r\n    address[] private allUsers;\r\n\r\n    mapping(address => uint256) private _userIndex;\r\n\r\n    mapping(address => UserInfo) public _userInfoByAddress;\r\n\r\n    struct Deposit {\r\n        address user;\r\n        address payToken;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping(address => Deposit[]) private _userDeposits;\r\n\r\n    // Total Deposit Amount\r\n    uint256 private _totalDepositedUSD;\r\n\r\n    // PayTokens\r\n    struct PayToken {\r\n        string name;\r\n        address contractAddress;\r\n        uint256 totalDeposit;\r\n        uint256 totalWithdrawn;\r\n        bool valid;\r\n    }\r\n\r\n    PayToken[] public _payTokens;\r\n\r\n    mapping(address => uint256) private _payTokenIndex;\r\n\r\n    // Sales Information\r\n    struct PreSale {\r\n        uint256 price;\r\n        uint256 totalCoins;\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 saleStartTime;\r\n        uint256 saleEndTime;\r\n        uint256 unlockTime;\r\n        uint256 totalSales;\r\n    }\r\n\r\n    PreSale[] public preSales;\r\n\r\n    struct PublicSale {\r\n        uint256 price;\r\n        uint256 totalCoins;\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 saleStartTime;\r\n        uint256 saleEndTime;\r\n        uint256 unlockTime;\r\n        uint256 totalSales;\r\n    }\r\n\r\n    PublicSale[] public publicSales;\r\n\r\n    enum SalesType {\r\n        PRESALE,\r\n        PUBLIC\r\n    }\r\n\r\n    // Purchases\r\n    struct Purchase {\r\n        address user;\r\n        uint256 userPurchaseNonce;\r\n        uint256 orderTime;\r\n        uint256 orderBlock;\r\n        SalesType salesType;\r\n        uint8 stage;\r\n        uint256 coinPrice;\r\n        uint256 totalCoin;\r\n        uint256 totalUSD;\r\n        bool buyBack;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    mapping(address => Purchase[]) private _userPurchases;\r\n\r\n    mapping(address => mapping(SalesType => mapping(uint256 => uint256)))\r\n        public _purchasedAtThisStage;\r\n\r\n    struct UserSummary {\r\n        address user;\r\n        Deposit[] userDeposits;\r\n        Purchase[] userPurchases;\r\n        BuyBack[] userBuyBacks;\r\n        Withdrawn[] userWithdrawns;\r\n    }\r\n\r\n    // Buy Back Records\r\n    struct BuyBack {\r\n        address user;\r\n        uint256 buyBackTime;\r\n        uint256 orderTime;\r\n        SalesType salesType;\r\n        uint8 stage;\r\n        uint256 totalCoin;\r\n        uint256 totalUSD;\r\n    }\r\n\r\n    mapping(address => BuyBack[]) private _userBuyBacks;\r\n\r\n    // Withdrawns\r\n    struct Withdrawn {\r\n        address user;\r\n        uint256 withdrawnTime;\r\n        address payToken;\r\n        uint256 amount;\r\n    }\r\n    mapping(address => Withdrawn[]) private _userWithdrawns;\r\n\r\n    constructor() {\r\n        //_initPayTokens();\r\n        _payTokens.push();\r\n        TransferToChain.push();\r\n        contractManagers[msg.sender] = true;\r\n    }\r\n\r\n    modifier onlyContractManagers() {\r\n        require(contractManagers[msg.sender], \"?\");\r\n        _;\r\n    }\r\n\r\n    function setManager(address managerAddress, bool status)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(managerAddress != msg.sender, \"??\");\r\n        contractManagers[managerAddress] = status;\r\n        return true;\r\n    }\r\n\r\n    function setPayToken(\r\n        address tokenAddress,\r\n        string memory name,\r\n        bool valid\r\n    ) external onlyContractManagers returns (bool) {\r\n        require(_isContract(address(tokenAddress)), \"!!!\");\r\n\r\n        ITrustedPayToken trustedPayToken = ITrustedPayToken(\r\n            address(tokenAddress)\r\n        );\r\n        require(trustedPayToken.decimals() == 18, \"1e18\");\r\n\r\n        uint256 ptIndex = _payTokenIndex[tokenAddress];\r\n        if (ptIndex == 0) {\r\n            _payTokens.push(PayToken(name, tokenAddress, 0, 0, valid));\r\n            _payTokenIndex[tokenAddress] = _payTokens.length - 1;\r\n        } else {\r\n            _payTokens[ptIndex].name = name;\r\n            _payTokens[ptIndex].valid = valid;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getPayTokens() public view returns (PayToken[] memory) {\r\n        return _payTokens;\r\n    }\r\n\r\n    struct ActiveStageSummary {\r\n        uint256 timestamp;\r\n        bool preSale;\r\n        bool publicSale;\r\n        uint256 totalCoins;\r\n        uint256 totalSales;\r\n    }\r\n\r\n    function getActiveStageSummary()\r\n        public\r\n        view\r\n        returns (ActiveStageSummary memory)\r\n    {\r\n        bool _preSale = false;\r\n        bool _publicSale = false;\r\n        uint256 _stage = 0;\r\n        uint256 _totalCoinsInSale = 0;\r\n        uint256 _totalSalesInSale = 0;\r\n\r\n        if (\r\n            preSales[0].saleStartTime <= getBlockTimeStamp() &&\r\n            getBlockTimeStamp() <= preSales[2].saleEndTime\r\n        ) {\r\n            _preSale = true;\r\n            for (uint256 i = 0; i <= 2; i++) {\r\n                _totalCoinsInSale += preSales[i].totalCoins;\r\n                _totalSalesInSale += preSales[i].totalSales;\r\n            }\r\n        }\r\n\r\n        if (\r\n            publicSales[0].saleStartTime <= getBlockTimeStamp() &&\r\n            getBlockTimeStamp() <= publicSales[20].saleEndTime\r\n        ) {\r\n            _publicSale = true;\r\n            for (uint256 i = 0; i <= 20; i++) {\r\n                if (\r\n                    publicSales[i].saleStartTime <= getBlockTimeStamp() &&\r\n                    getBlockTimeStamp() <= publicSales[i].saleEndTime\r\n                ) {\r\n                    _stage = i;\r\n                }\r\n                _totalCoinsInSale += publicSales[i].totalCoins;\r\n                _totalSalesInSale += publicSales[i].totalSales;\r\n            }\r\n        }\r\n\r\n        ActiveStageSummary memory ass = ActiveStageSummary(\r\n            getBlockTimeStamp(),\r\n            _preSale,\r\n            _publicSale,\r\n            _totalCoinsInSale,\r\n            _totalSalesInSale\r\n        );\r\n\r\n        return ass;\r\n    }\r\n\r\n    function setPreSaleDetails(uint256 _startTime) public onlyOwner {\r\n        require(preSales.length == 0, \"Already\");\r\n\r\n        uint256 _endTime = _startTime + 30 days;\r\n        //if (totalCoins == 0) totalCoins = 4_800_000;\r\n        uint256 totalCoins = 4_800_000;\r\n\r\n        preSales.push(\r\n            PreSale(\r\n                0.040 * 1e18,\r\n                totalCoins * 1e18,\r\n                20_000 * 1e18,\r\n                400_000 * 1e18,\r\n                _startTime,\r\n                _endTime - 1,\r\n                _endTime + 360 days,\r\n                0\r\n            )\r\n        );\r\n\r\n        preSales.push(\r\n            PreSale(\r\n                0.055 * 1e18,\r\n                totalCoins * 1e18,\r\n                5_000 * 1e18,\r\n                200_000 * 1e18,\r\n                _startTime,\r\n                _endTime - 1,\r\n                _endTime + 270 days,\r\n                0\r\n            )\r\n        );\r\n\r\n        preSales.push(\r\n            PreSale({\r\n                price: 0.070 * 1e18,\r\n                totalCoins: totalCoins * 1e18,\r\n                min: 2_000 * 1e18,\r\n                max: 100_000 * 1e18,\r\n                saleStartTime: _startTime,\r\n                saleEndTime: _endTime - 1,\r\n                unlockTime: _endTime + 180 days,\r\n                totalSales: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    function setPublicSaleDetails(uint256 _startTime) public onlyOwner {\r\n        require(publicSales.length == 0, \"Already\");\r\n\r\n        uint256 stage0Coins = 9_600_000;\r\n        uint256 stage1Coins = 5_000_000;\r\n\r\n        publicSales.push(\r\n            PublicSale({\r\n                price: 0.10 * 1e18,\r\n                totalCoins: stage0Coins * 1e18,\r\n                min: 500 * 1e18,\r\n                max: 500_000 * 1e18,\r\n                saleStartTime: _startTime,\r\n                saleEndTime: _startTime + 14 days - 1,\r\n                unlockTime: 0, //_startTime + 161 days,\r\n                totalSales: 0\r\n            })\r\n        );\r\n\r\n        // stage 1-20\r\n        for (uint256 i = 1; i <= 20; i++) {\r\n            uint256 _totalCoins = stage1Coins * 1e18; //_totalCoins = (stage1Coins - ((i - 1) * coinReduction)) *  1e18;\r\n            uint256 _price = (0.13 * 1e18) + ((i - 1) * (0.02 * 1e18));\r\n\r\n            if (i >= 5) {\r\n                _price += (0.02 * 1e18);\r\n            }\r\n\r\n            if (i >= 9) {\r\n                _price += (0.03 * 1e18);\r\n            }\r\n\r\n            if (i >= 13) {\r\n                _price += (0.04 * 1e18);\r\n            }\r\n\r\n            if (i >= 17) {\r\n                _price += (0.05 * 1e18);\r\n            }\r\n\r\n            uint256 startTime = _startTime + ((i + 1) * 7 days);\r\n\r\n            publicSales.push(\r\n                PublicSale(\r\n                    _price,\r\n                    _totalCoins,\r\n                    100 * 1e18,\r\n                    500_000 * 1e18,\r\n                    startTime,\r\n                    startTime + 7 days - 1,\r\n                    0,\r\n                    0\r\n                )\r\n            );\r\n        }\r\n\r\n        uint256 stage20EndTime = publicSales[20].saleEndTime;\r\n        for (uint8 i = 0; i <= 20; i++) {\r\n            publicSales[i].unlockTime = stage20EndTime + ((21 - i) * 1 days);\r\n        }\r\n    }\r\n\r\n    function setEndTimeOfStage(uint8 stage, uint256 endTime)\r\n        public\r\n        onlyContractManagers\r\n    {\r\n        _setEndTimeOfStage(stage, endTime);\r\n    }\r\n\r\n    function _setEndTimeOfStage(uint8 _stage, uint256 _endTime) internal {\r\n        require(0 <= _stage && _stage <= 20, \"invalid\");\r\n        require(\r\n            publicSales[_stage].saleEndTime < _endTime &&\r\n                _endTime > publicSales[_stage].saleStartTime,\r\n            \"Wrong!\"\r\n        );\r\n        publicSales[_stage].saleEndTime = _endTime;\r\n        if (_stage != 20) _setStageTime(_stage + 1);\r\n    }\r\n\r\n    // Set stage start and end time after stage 2\r\n    function _setStageTime(uint8 _stage) internal {\r\n        require(_stage >= 1 && _stage <= 20, \"invalid\");\r\n\r\n        uint256 previousStageStartTime = publicSales[_stage - 1].saleStartTime;\r\n        uint256 previousStageEndTime = publicSales[_stage - 1].saleEndTime;\r\n\r\n        uint256 previousStageDays = 7 days;\r\n        if (_stage == 1) previousStageDays = 14 days;\r\n\r\n        uint256 fixStageTime = previousStageDays -\r\n            (previousStageEndTime - previousStageStartTime);\r\n\r\n        fixStageTime -= 1 minutes; // 1 minutes break time :)\r\n\r\n        for (uint8 i = _stage; i <= 20; i++) {\r\n            // change start time\r\n            publicSales[i].saleStartTime =\r\n                publicSales[i].saleStartTime -\r\n                fixStageTime;\r\n\r\n            // change end time\r\n            publicSales[i].saleEndTime =\r\n                publicSales[i].saleEndTime -\r\n                fixStageTime;\r\n        }\r\n    }\r\n\r\n    function depositMoney(uint256 amount, address tokenAddress) external {\r\n        require(_userDeposits[msg.sender].length < 20, \"20\");\r\n        uint256 blockTimeStamp = getBlockTimeStamp();\r\n        require(blockTimeStamp < publicSales[20].saleEndTime, \"??\");\r\n        uint256 ptIndex = _payTokenIndex[tokenAddress];\r\n        require(_payTokens[ptIndex].valid, \"Dont accept!\");\r\n\r\n        ITrustedPayToken trustedPayToken = ITrustedPayToken(\r\n            address(tokenAddress)\r\n        );\r\n\r\n        require(\r\n            trustedPayToken.allowance(msg.sender, address(this)) >= amount,\r\n            \"Allowance!\"\r\n        );\r\n\r\n        uint256 tokenBalance = trustedPayToken.balanceOf(msg.sender);\r\n\r\n        require(tokenBalance >= amount, \"no money!\");\r\n\r\n        trustedPayToken.transferFrom(msg.sender, address(this), amount);\r\n\r\n        _getUserIndex(msg.sender); // Get (or Create) UserId\r\n\r\n        _totalDepositedUSD += amount; //  All USD token Deposits\r\n\r\n        _payTokens[ptIndex].totalDeposit += amount;\r\n\r\n        _userInfoByAddress[msg.sender].totalDeposits += amount;\r\n\r\n        _userInfoByAddress[msg.sender].balanceUSD += amount; // User USD Balance\r\n\r\n        _userDeposits[msg.sender].push(\r\n            Deposit({\r\n                user: msg.sender,\r\n                payToken: tokenAddress,\r\n                amount: amount,\r\n                timestamp: blockTimeStamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function buyCoins(\r\n        SalesType salesType,\r\n        uint8 stage,\r\n        uint256 totalUSD\r\n    ) public {\r\n        require(_userInfoByAddress[msg.sender].totalDeposits != 0, \"Deposit\");\r\n        require(_userPurchases[msg.sender].length < 20, \"20\");\r\n        require(totalUSD > 1 * 1e18, \"Airdrop?\");\r\n        require(\r\n            _userInfoByAddress[msg.sender].balanceUSD >= totalUSD,\r\n            \"Balance!\"\r\n        );\r\n\r\n        uint256 blockTimeStamp = getBlockTimeStamp();\r\n        uint256 requestedCoins = 0;\r\n        uint256 coinPrice = 0;\r\n        uint256 unlockTime = 0;\r\n        uint256 purchasedAtThisStage = _purchasedAtThisStage[msg.sender][\r\n            salesType\r\n        ][stage];\r\n\r\n        if (salesType == SalesType.PRESALE) {\r\n            // 0 - 1 - 2\r\n            require(0 <= stage && stage <= 2, \"wrong\");\r\n\r\n            PreSale memory pss = preSales[stage];\r\n\r\n            // is stage active?\r\n            require(\r\n                pss.saleStartTime <= blockTimeStamp &&\r\n                    blockTimeStamp <= pss.saleEndTime,\r\n                \"not active\"\r\n            );\r\n\r\n            // calculate OXOs for that USD\r\n            // requestedCoins = ((totalUSD * 1e4) / p.price) * 1e14;\r\n            requestedCoins = ((totalUSD) / pss.price) * 1e18;\r\n\r\n            totalUSD = (requestedCoins * pss.price) / 1e18;\r\n            // is there enough OXOs?\r\n            require(\r\n                pss.totalCoins - pss.totalSales >= requestedCoins,\r\n                \"Not enough\"\r\n            );\r\n\r\n            // check user's purchases for min/max limits\r\n            require(\r\n                pss.min <= purchasedAtThisStage + requestedCoins &&\r\n                    pss.max >= purchasedAtThisStage + requestedCoins,\r\n                \"limits\"\r\n            );\r\n\r\n            // update preSales Stage purchased OXOs\r\n            preSales[stage].totalSales += requestedCoins;\r\n\r\n            coinPrice = pss.price;\r\n            unlockTime = pss.unlockTime;\r\n\r\n            _transferableByFoundation += totalUSD;\r\n            buyBackFund += (totalUSD * 80) / 100;\r\n        }\r\n\r\n        if (salesType == SalesType.PUBLIC) {\r\n            require(0 <= stage && stage <= 20, \"Wrong\");\r\n\r\n            PublicSale memory pss = publicSales[stage];\r\n\r\n            // is stage active?\r\n            require(\r\n                pss.saleStartTime <= blockTimeStamp &&\r\n                    blockTimeStamp <= pss.saleEndTime,\r\n                \"not active\"\r\n            );\r\n\r\n            // calculate OXOs for that USD\r\n            //requestedCoins = ((totalUSD * 1e2) / p.price) * 1e16;\r\n            requestedCoins = ((totalUSD) / pss.price) * 1e18;\r\n            totalUSD = (requestedCoins * pss.price) / 1e18;\r\n\r\n            // is there enough OXOs?\r\n            require(\r\n                pss.totalCoins - pss.totalSales >= requestedCoins,\r\n                \"Not enough\"\r\n            );\r\n\r\n            // check user's purchases for min/max limits\r\n            require(\r\n                pss.min <= purchasedAtThisStage + requestedCoins &&\r\n                    purchasedAtThisStage + requestedCoins <= pss.max,\r\n                \"limits\"\r\n            );\r\n\r\n            // update preSales Stage purchased OXOs\r\n            publicSales[stage].totalSales += requestedCoins;\r\n\r\n            coinPrice = pss.price;\r\n            unlockTime = pss.unlockTime;\r\n\r\n            // %80 for BuyBack - %20 Transferable\r\n            _transferableByFoundation += (totalUSD * 20) / 100;\r\n            buyBackFund += (totalUSD * 80) / 100;\r\n        }\r\n\r\n        // Get User Purchases Count\r\n        uint256 userPurchaseCount = _userPurchases[msg.sender].length;\r\n\r\n        /// New Purchase Record\r\n        _userPurchases[msg.sender].push(\r\n            Purchase({\r\n                user: msg.sender,\r\n                userPurchaseNonce: userPurchaseCount,\r\n                orderTime: blockTimeStamp,\r\n                orderBlock: block.number,\r\n                salesType: salesType,\r\n                stage: stage,\r\n                coinPrice: coinPrice,\r\n                totalCoin: requestedCoins,\r\n                totalUSD: totalUSD,\r\n                buyBack: false,\r\n                unlockTime: unlockTime\r\n            })\r\n        );\r\n\r\n        //_totalSales += totalUSD;\r\n\r\n        _userInfoByAddress[msg.sender].totalCoinsFromSales += requestedCoins;\r\n\r\n        // UserBalance change\r\n        _userInfoByAddress[msg.sender].balanceUSD -= totalUSD;\r\n\r\n        _userInfoByAddress[msg.sender].totalPurchases += totalUSD;\r\n\r\n        // Update user's OXOs count for stage\r\n        _purchasedAtThisStage[msg.sender][salesType][stage] =\r\n            purchasedAtThisStage +\r\n            requestedCoins;\r\n\r\n        // Mint Tokens\r\n        _mintFromSales(msg.sender, requestedCoins);\r\n\r\n        // check available coin amount for stage\r\n        if (salesType == SalesType.PUBLIC) {\r\n            if (\r\n                publicSales[stage].totalCoins - publicSales[stage].totalSales <\r\n                publicSales[stage].min\r\n            ) {\r\n                _setEndTimeOfStage(stage, (blockTimeStamp + 1));\r\n            }\r\n        }\r\n\r\n        //emit Purchased(msg.sender, salesType, stage, requestedCoins, totalUSD);\r\n\r\n        //return true;\r\n    }\r\n\r\n    function requestBuyBack(uint256 userPurchaseNonce) public {\r\n        require(\r\n            _userInfoByAddress[msg.sender].buyBackGuarantee,\r\n            \"can not BuyBack!\"\r\n        );\r\n\r\n        uint256 blockTimeStamp = getBlockTimeStamp();\r\n\r\n        require(\r\n            publicSales[20].unlockTime <= blockTimeStamp &&\r\n                blockTimeStamp <= publicSales[20].unlockTime + 90 days,\r\n            \"wrong dates!\"\r\n        );\r\n\r\n        require(\r\n            !_userPurchases[msg.sender][userPurchaseNonce].buyBack &&\r\n                _userPurchases[msg.sender][userPurchaseNonce].totalUSD > 0,\r\n            \"???\"\r\n        );\r\n\r\n        uint256 totalBuyBackCoins = _userPurchases[msg.sender][\r\n            userPurchaseNonce\r\n        ].totalCoin;\r\n\r\n        // Calculate USD\r\n        uint256 totalBuyBackUSD = (_userPurchases[msg.sender][userPurchaseNonce]\r\n            .totalUSD * 80) / 100;\r\n\r\n        // BuyBacks for User\r\n        _userBuyBacks[msg.sender].push(\r\n            BuyBack({\r\n                user: msg.sender,\r\n                buyBackTime: blockTimeStamp,\r\n                orderTime: _userPurchases[msg.sender][userPurchaseNonce]\r\n                    .orderTime,\r\n                salesType: _userPurchases[msg.sender][userPurchaseNonce]\r\n                    .salesType,\r\n                stage: _userPurchases[msg.sender][userPurchaseNonce].stage,\r\n                totalCoin: totalBuyBackCoins,\r\n                totalUSD: totalBuyBackUSD\r\n            })\r\n        );\r\n\r\n        _userPurchases[msg.sender][userPurchaseNonce].buyBack = true;\r\n\r\n        _userInfoByAddress[msg.sender].totalBuyBackUSD += totalBuyBackUSD;\r\n\r\n        _userInfoByAddress[msg.sender].balanceUSD += totalBuyBackUSD;\r\n\r\n        _userInfoByAddress[msg.sender].totalCoinsFromSales -= totalBuyBackCoins;\r\n\r\n        _userInfoByAddress[msg.sender].totalBuyBackCoins += totalBuyBackCoins;\r\n\r\n        _burnForBuyBack(msg.sender, totalBuyBackCoins);\r\n    }\r\n\r\n    function withdrawnMoney() public returns (bool) {\r\n        uint256 amount = _userInfoByAddress[msg.sender].balanceUSD;\r\n        require(amount > 0, \"can not Withdrawn!\");\r\n\r\n        uint256 blockTimeStamp = getBlockTimeStamp();\r\n        bool transfered = false;\r\n        for (uint256 i = 1; i < _payTokens.length; i++) {\r\n            if (!transfered && _payTokens[i].valid) {\r\n                ITrustedPayToken trustedPayToken = ITrustedPayToken(\r\n                    address(_payTokens[i].contractAddress)\r\n                );\r\n                uint256 tokenBalance = trustedPayToken.balanceOf(address(this));\r\n                if (tokenBalance >= amount) {\r\n                    _userInfoByAddress[msg.sender].balanceUSD -= amount;\r\n\r\n                    _userInfoByAddress[msg.sender].totalWithdrawns += amount;\r\n\r\n                    _userWithdrawns[msg.sender].push(\r\n                        Withdrawn({\r\n                            user: msg.sender,\r\n                            withdrawnTime: blockTimeStamp,\r\n                            payToken: _payTokens[i].contractAddress,\r\n                            amount: amount\r\n                        })\r\n                    );\r\n\r\n                    uint256 ptIndex = _payTokenIndex[\r\n                        _payTokens[i].contractAddress\r\n                    ];\r\n\r\n                    _payTokens[ptIndex].totalWithdrawn += amount;\r\n\r\n                    trustedPayToken.transfer(msg.sender, amount);\r\n\r\n                    transfered = true;\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return transfered;\r\n    }\r\n\r\n    function getUserSummary(address user)\r\n        public\r\n        view\r\n        returns (UserSummary memory)\r\n    {\r\n        UserSummary memory userSummary = UserSummary({\r\n            user: user,\r\n            userDeposits: _userDeposits[user],\r\n            userPurchases: _userPurchases[user],\r\n            userBuyBacks: _userBuyBacks[user],\r\n            userWithdrawns: _userWithdrawns[user]\r\n        });\r\n        return userSummary;\r\n    }\r\n\r\n    function _blockTimeStamp() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    uint256 private testingTimeStamp = 0;\r\n\r\n    // function forTesting_BlockTimeStamp(uint256 _testingTimeStamp)\r\n    //     public\r\n    //     onlyContractManagers\r\n    // {\r\n    //     testingTimeStamp = _testingTimeStamp;\r\n    // }\r\n\r\n    function getBlockTimeStamp() public view returns (uint256) {\r\n        if (testingTimeStamp != 0) return testingTimeStamp;\r\n        return block.timestamp;\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function transferToChain(uint256 chainId, uint256 amount) public {\r\n        uint256 balance = balanceOf(msg.sender);\r\n        require(amount <= balance, \"Houston!\");\r\n        _burn(msg.sender, amount);\r\n        uint256 nonce = TransferToChain.length;\r\n        TransferToChain.push(\r\n            TransferChain({\r\n                user: msg.sender,\r\n                chainId: chainId,\r\n                amount: amount,\r\n                nonce: nonce\r\n            })\r\n        );\r\n        TransferToChainLatest = nonce;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) public onlyContractManagers {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        // Check Locked Coins\r\n        require(amount <= balanceOf(msg.sender), \"Houston!\");\r\n        _cancelBuyBackGuarantee();\r\n        return super.transfer(to, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        // Check Locked Coins\r\n        require(amount <= balanceOf(from), \"Houston!\");\r\n        _cancelBuyBackGuarantee();\r\n        return super.transferFrom(from, to, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal override whenNotPaused {\r\n        require(balanceOf(_from) >= _amount, \"balance is not enough!\");\r\n        super._beforeTokenTransfer(_from, _to, _amount);\r\n    }\r\n\r\n    function _cancelBuyBackGuarantee() internal {\r\n        if (_userInfoByAddress[msg.sender].buyBackGuarantee) {\r\n            _userInfoByAddress[msg.sender].buyBackGuarantee = false;\r\n\r\n            if (\r\n                publicSales[20].unlockTime < getBlockTimeStamp() &&\r\n                getBlockTimeStamp() <= publicSales[20].unlockTime + 90 days\r\n            ) {\r\n                Purchase[] memory up = _userPurchases[msg.sender];\r\n                for (uint256 i = 0; i < up.length; i++) {\r\n                    if (up[i].salesType == SalesType.PUBLIC && !up[i].buyBack) {\r\n                        _transferableByFoundation +=\r\n                            (up[i].totalUSD * 80) /\r\n                            100;\r\n                        buyBackFund -= (up[i].totalUSD * 80) / 100;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function balanceOf(address who) public view override returns (uint256) {\r\n        return\r\n            super.balanceOf(who) - _checkLockedCoins(who, getBlockTimeStamp());\r\n    }\r\n\r\n    function balanceOfAt(address who, uint256 blockTimeStamp)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return super.balanceOf(who) - _checkLockedCoins(who, blockTimeStamp);\r\n    }\r\n\r\n    /** Calculate */\r\n    function _checkLockedCoins(address _who, uint256 blockTimeStamp)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 uIndex = _userIndex[_who];\r\n        if (uIndex == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // /// All coins free\r\n        if (preSales[0].unlockTime + 10 days < blockTimeStamp) {\r\n            return 0;\r\n        }\r\n\r\n        // /// All coins locked before end of Public Sales\r\n        if (blockTimeStamp <= publicSales[20].unlockTime) {\r\n            return _userInfoByAddress[_who].totalCoinsFromSales;\r\n        }\r\n\r\n        // Check user purchases history\r\n        Purchase[] memory userPurchases = _userPurchases[_who];\r\n        uint256 lockedCoins = 0;\r\n        for (uint256 i = 0; i < userPurchases.length; i++) {\r\n            if (!userPurchases[i].buyBack) {\r\n                // unlock time has not pass\r\n                if (\r\n                    userPurchases[i].salesType == SalesType.PRESALE &&\r\n                    blockTimeStamp < preSales[userPurchases[i].stage].unlockTime\r\n                ) {\r\n                    lockedCoins += userPurchases[i].totalCoin;\r\n                }\r\n\r\n                // unlock time has not pass\r\n                if (\r\n                    userPurchases[i].salesType == SalesType.PUBLIC &&\r\n                    blockTimeStamp <\r\n                    publicSales[userPurchases[i].stage].unlockTime\r\n                ) {\r\n                    lockedCoins += userPurchases[i].totalCoin;\r\n                }\r\n\r\n                // 10 days vesting for PreSale\r\n                if (\r\n                    userPurchases[i].salesType == SalesType.PRESALE &&\r\n                    (preSales[userPurchases[i].stage].unlockTime <\r\n                        blockTimeStamp &&\r\n                        blockTimeStamp <\r\n                        preSales[userPurchases[i].stage].unlockTime + 10 days)\r\n                ) {\r\n                    lockedCoins += _vestingCalculator(\r\n                        preSales[userPurchases[i].stage].unlockTime,\r\n                        userPurchases[i].totalCoin,\r\n                        10,\r\n                        blockTimeStamp\r\n                    );\r\n                }\r\n\r\n                // 25 days vesting for PublicSale\r\n                if (\r\n                    userPurchases[i].salesType == SalesType.PUBLIC &&\r\n                    (publicSales[userPurchases[i].stage].unlockTime <\r\n                        blockTimeStamp &&\r\n                        blockTimeStamp <\r\n                        publicSales[userPurchases[i].stage].unlockTime +\r\n                            25 days)\r\n                ) {\r\n                    lockedCoins += _vestingCalculator(\r\n                        publicSales[userPurchases[i].stage].unlockTime,\r\n                        userPurchases[i].totalCoin,\r\n                        25,\r\n                        blockTimeStamp\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return lockedCoins;\r\n    }\r\n\r\n    function _vestingCalculator(\r\n        uint256 _unlockTime,\r\n        uint256 _totalCoin,\r\n        uint256 _vestingDays,\r\n        uint256 blockTimeStamp\r\n    ) internal pure returns (uint256) {\r\n        uint256 pastDays = 0;\r\n        uint256 _lockedCoins = 0;\r\n        uint256 pastTime = blockTimeStamp - _unlockTime;\r\n\r\n        if (pastTime <= 1 days) {\r\n            pastDays = 1;\r\n        } else {\r\n            pastDays = ((pastTime - (pastTime % 1 days)) / 1 days) + 1;\r\n            if (pastTime % 1 days == 0) {\r\n                pastDays -= 1;\r\n            }\r\n        }\r\n\r\n        if (pastDays >= 1 && pastDays <= _vestingDays) {\r\n            _lockedCoins +=\r\n                (_totalCoin * (_vestingDays - pastDays)) /\r\n                _vestingDays;\r\n        }\r\n\r\n        return _lockedCoins;\r\n    }\r\n\r\n    function changeSafeWallet(address walletAddress) public onlyOwner {\r\n        SAFE_WALLET = walletAddress;\r\n    }\r\n\r\n    function transferTokensToSafeWallet(address tokenAddress)\r\n        external\r\n        onlyContractManagers\r\n    {\r\n        require(_isContract(address(tokenAddress)), \"Houston!\");\r\n\r\n        uint256 blockTimeStamp = getBlockTimeStamp();\r\n\r\n        ITrustedPayToken trustedPayToken = ITrustedPayToken(\r\n            address(tokenAddress)\r\n        );\r\n\r\n        uint256 tokenBalance = trustedPayToken.balanceOf(address(this));\r\n\r\n        uint256 transferable = tokenBalance;\r\n        uint256 ptIndex = _payTokenIndex[tokenAddress];\r\n\r\n        if (_payTokens[ptIndex].valid) {\r\n            transferable =\r\n                _transferableByFoundation -\r\n                _totalTranferredToFoundation;\r\n\r\n            if (publicSales[20].unlockTime + 90 days < blockTimeStamp) {\r\n                transferable = tokenBalance;\r\n            }\r\n\r\n            if (tokenBalance < transferable) transferable = tokenBalance;\r\n            _totalTranferredToFoundation += transferable;\r\n\r\n            _payTokens[ptIndex].totalWithdrawn =\r\n                _payTokens[ptIndex].totalWithdrawn +\r\n                transferable;\r\n        }\r\n\r\n        trustedPayToken.transfer(SAFE_WALLET, transferable);\r\n    }\r\n\r\n    function transferCoinsToSafeWallet() external onlyContractManagers {\r\n        payable(SAFE_WALLET).transfer(address(this).balance);\r\n    }\r\n\r\n    function _getUserIndex(address _user) internal returns (uint256) {\r\n        uint256 uIndex = _userIndex[_user];\r\n        if (uIndex == 0) {\r\n            allUsers.push(_user);\r\n            uIndex = allUsers.length;\r\n            _userIndex[_user] = uIndex;\r\n            _userInfoByAddress[_user].user = _user;\r\n            _userInfoByAddress[_user].buyBackGuarantee = true;\r\n        }\r\n        return uIndex;\r\n    }\r\n\r\n    function _isContract(address _account) internal view returns (bool) {\r\n        return _account.code.length > 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TransferToChain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TransferToChainLatest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_blockTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_payTokens\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"enum WrappedOXO.SalesType\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_purchasedAtThisStage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userInfoByAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"buyBackGuarantee\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalCoinsFromSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBuyBackCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBuyBackUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPurchases\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawns\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeStamp\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum WrappedOXO.SalesType\",\"name\":\"salesType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalUSD\",\"type\":\"uint256\"}],\"name\":\"buyCoins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"changeSafeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"depositMoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveStageSummary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"preSale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"publicSale\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSales\",\"type\":\"uint256\"}],\"internalType\":\"struct WrappedOXO.ActiveStageSummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPayTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"internalType\":\"struct WrappedOXO.PayToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserSummary\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct WrappedOXO.Deposit[]\",\"name\":\"userDeposits\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userPurchaseNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderBlock\",\"type\":\"uint256\"},{\"internalType\":\"enum WrappedOXO.SalesType\",\"name\":\"salesType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"coinPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCoin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUSD\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buyBack\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct WrappedOXO.Purchase[]\",\"name\":\"userPurchases\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyBackTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderTime\",\"type\":\"uint256\"},{\"internalType\":\"enum WrappedOXO.SalesType\",\"name\":\"salesType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalCoin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUSD\",\"type\":\"uint256\"}],\"internalType\":\"struct WrappedOXO.BuyBack[]\",\"name\":\"userBuyBacks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"payToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct WrappedOXO.Withdrawn[]\",\"name\":\"userWithdrawns\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WrappedOXO.UserSummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"preSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSales\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"publicSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSales\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userPurchaseNonce\",\"type\":\"uint256\"}],\"name\":\"requestBuyBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"stage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"setEndTimeOfStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"setPayToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setPreSaleDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setPublicSaleDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferCoinsToSafeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"transferTokensToSafeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawnMoney\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WrappedOXO", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dcc913ac039891e18cdadfa64d4d294bd500217e0de59056d3c58e2d1bd354fd"}