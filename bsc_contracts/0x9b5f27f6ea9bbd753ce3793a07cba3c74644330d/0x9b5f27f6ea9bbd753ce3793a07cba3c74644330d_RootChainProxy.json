{"SourceCode": "{{\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"runs\": 200,\r\n      \"enabled\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/common/misc/ProxyStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\nimport {Ownable} from \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\n\\ncontract ProxyStorage is Ownable {\\n    address internal proxyTo;\\n}\\n\"\r\n    },\r\n    \"contracts/common/mixin/ChainIdMixin.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract ChainIdMixin {\\n  bytes constant public networkId = \\\"199\\\";\\n  uint256 constant public CHAINID = 199;\\n}\\n\"\r\n    },\r\n    \"contracts/common/Registry.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {Governable} from \\\"./governance/Governable.sol\\\";\\nimport {IWithdrawManager} from \\\"../root/withdrawManager/IWithdrawManager.sol\\\";\\n\\n\\ncontract Registry is Governable {\\n    // @todo hardcode constants\\n    bytes32 private constant WETH_TOKEN = keccak256(\\\"wethToken\\\");\\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\\\"depositManager\\\");\\n    bytes32 private constant STAKE_MANAGER = keccak256(\\\"stakeManager\\\");\\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\\\"validatorShare\\\");\\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\\\"withdrawManager\\\");\\n    bytes32 private constant CHILD_CHAIN = keccak256(\\\"childChain\\\");\\n    bytes32 private constant STATE_SENDER = keccak256(\\\"stateSender\\\");\\n    bytes32 private constant SLASHING_MANAGER = keccak256(\\\"slashingManager\\\");\\n\\n    address public erc20Predicate;\\n    address public erc721Predicate;\\n\\n    mapping(bytes32 => address) public contractMap;\\n    mapping(address => address) public rootToChildToken;\\n    mapping(address => address) public childToRootToken;\\n    mapping(address => bool) public proofValidatorContracts;\\n    mapping(address => bool) public isERC721;\\n\\n    enum Type {Invalid, ERC20, ERC721, Custom}\\n    struct Predicate {\\n        Type _type;\\n    }\\n    mapping(address => Predicate) public predicates;\\n\\n    event TokenMapped(address indexed rootToken, address indexed childToken);\\n    event ProofValidatorAdded(address indexed validator, address indexed from);\\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\\n    event PredicateAdded(address indexed predicate, address indexed from);\\n    event PredicateRemoved(address indexed predicate, address indexed from);\\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\\n\\n    constructor(address _governance) public Governable(_governance) {}\\n\\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\\n        contractMap[_key] = _address;\\n    }\\n\\n    /**\\n     * @dev Map root token to child token\\n     * @param _rootToken Token address on the root chain\\n     * @param _childToken Token address on the child chain\\n     * @param _isERC721 Is the token being mapped ERC721\\n     */\\n    function mapToken(\\n        address _rootToken,\\n        address _childToken,\\n        bool _isERC721\\n    ) external onlyGovernance {\\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \\\"INVALID_TOKEN_ADDRESS\\\");\\n        rootToChildToken[_rootToken] = _childToken;\\n        childToRootToken[_childToken] = _rootToken;\\n        isERC721[_rootToken] = _isERC721;\\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\\n        emit TokenMapped(_rootToken, _childToken);\\n    }\\n\\n    function addErc20Predicate(address predicate) public onlyGovernance {\\n        require(predicate != address(0x0), \\\"Can not add null address as predicate\\\");\\n        erc20Predicate = predicate;\\n        addPredicate(predicate, Type.ERC20);\\n    }\\n\\n    function addErc721Predicate(address predicate) public onlyGovernance {\\n        erc721Predicate = predicate;\\n        addPredicate(predicate, Type.ERC721);\\n    }\\n\\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\\n        require(predicates[predicate]._type == Type.Invalid, \\\"Predicate already added\\\");\\n        predicates[predicate]._type = _type;\\n        emit PredicateAdded(predicate, msg.sender);\\n    }\\n\\n    function removePredicate(address predicate) public onlyGovernance {\\n        require(predicates[predicate]._type != Type.Invalid, \\\"Predicate does not exist\\\");\\n        delete predicates[predicate];\\n        emit PredicateRemoved(predicate, msg.sender);\\n    }\\n\\n    function getValidatorShareAddress() public view returns (address) {\\n        return contractMap[VALIDATOR_SHARE];\\n    }\\n\\n    function getWethTokenAddress() public view returns (address) {\\n        return contractMap[WETH_TOKEN];\\n    }\\n\\n    function getDepositManagerAddress() public view returns (address) {\\n        return contractMap[DEPOSIT_MANAGER];\\n    }\\n\\n    function getStakeManagerAddress() public view returns (address) {\\n        return contractMap[STAKE_MANAGER];\\n    }\\n\\n    function getSlashingManagerAddress() public view returns (address) {\\n        return contractMap[SLASHING_MANAGER];\\n    }\\n\\n    function getWithdrawManagerAddress() public view returns (address) {\\n        return contractMap[WITHDRAW_MANAGER];\\n    }\\n\\n    function getChildChainAndStateSender() public view returns (address, address) {\\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\\n    }\\n\\n    function isTokenMapped(address _token) public view returns (bool) {\\n        return rootToChildToken[_token] != address(0x0);\\n    }\\n\\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\\n        require(isTokenMapped(_token), \\\"TOKEN_NOT_MAPPED\\\");\\n        return isERC721[_token];\\n    }\\n\\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\\n        if (isTokenMappedAndIsErc721(_token)) {\\n            return erc721Predicate;\\n        }\\n        return erc20Predicate;\\n    }\\n\\n    function isChildTokenErc721(address childToken) public view returns (bool) {\\n        address rootToken = childToRootToken[childToken];\\n        require(rootToken != address(0x0), \\\"Child token is not mapped\\\");\\n        return isERC721[rootToken];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/governance/Governable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {IGovernance} from \\\"./IGovernance.sol\\\";\\n\\ncontract Governable {\\n    IGovernance public governance;\\n\\n    constructor(address _governance) public {\\n        governance = IGovernance(_governance);\\n    }\\n\\n    modifier onlyGovernance() {\\n        _assertGovernance();\\n        _;\\n    }\\n\\n    function _assertGovernance() private view {\\n        require(\\n            msg.sender == address(governance),\\n            \\\"Only governance contract is authorized\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/misc/ERCProxy.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identitifer:    MIT\\n */\\n\\npragma solidity ^0.5.2;\\n\\n// See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-897.md\\n\\ninterface ERCProxy {\\n    function proxyType() external pure returns (uint256 proxyTypeId);\\n    function implementation() external view returns (address codeAddr);\\n}\\n\"\r\n    },\r\n    \"contracts/root/RootChainProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {RootChainStorage} from \\\"./RootChainStorage.sol\\\";\\nimport {Proxy} from \\\"../common/misc/Proxy.sol\\\";\\nimport {Registry} from \\\"../common/Registry.sol\\\";\\n\\ncontract RootChainProxy is Proxy, RootChainStorage {\\n  constructor(address _proxyTo, address _registry, string memory _heimdallId)\\n    public\\n    Proxy(_proxyTo)\\n  {\\n    registry = Registry(_registry);\\n    heimdallId = keccak256(abi.encodePacked(_heimdallId));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/common/governance/IGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ninterface IGovernance {\\n    function update(address target, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/common/misc/DelegateProxyForwarder.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract DelegateProxyForwarder {\\n    function delegatedFwd(address _dst, bytes memory _calldata) internal {\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            let result := delegatecall(\\n                sub(gas, 10000),\\n                _dst,\\n                add(_calldata, 0x20),\\n                mload(_calldata),\\n                0,\\n                0\\n            )\\n            let size := returndatasize\\n\\n            let ptr := mload(0x40)\\n            returndatacopy(ptr, 0, size)\\n\\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\\n            // if the call returned error data, forward it\\n            switch result\\n                case 0 {\\n                    revert(ptr, size)\\n                }\\n                default {\\n                    return(ptr, size)\\n                }\\n        }\\n    }\\n    \\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_target)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/misc/DelegateProxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {ERCProxy} from \\\"./ERCProxy.sol\\\";\\nimport {DelegateProxyForwarder} from \\\"./DelegateProxyForwarder.sol\\\";\\n\\ncontract DelegateProxy is ERCProxy, DelegateProxyForwarder {\\n    function proxyType() external pure returns (uint256 proxyTypeId) {\\n        // Upgradeable proxy\\n        proxyTypeId = 2;\\n    }\\n\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/root/RootChainStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {Registry} from \\\"../common/Registry.sol\\\";\\nimport {ProxyStorage} from \\\"../common/misc/ProxyStorage.sol\\\";\\nimport {ChainIdMixin} from \\\"../common/mixin/ChainIdMixin.sol\\\";\\n\\n\\ncontract RootChainHeader {\\n    event NewHeaderBlock(\\n        address indexed proposer,\\n        uint256 indexed headerBlockId,\\n        uint256 indexed reward,\\n        uint256 start,\\n        uint256 end,\\n        bytes32 root\\n    );\\n    // housekeeping event\\n    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n}\\n\\n\\ncontract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {\\n    bytes32 public heimdallId;\\n    uint8 public constant VOTE_TYPE = 2;\\n\\n    uint16 internal constant MAX_DEPOSITS = 10000;\\n    uint256 public _nextHeaderBlock = MAX_DEPOSITS;\\n    uint256 internal _blockDepositId = 1;\\n    mapping(uint256 => HeaderBlock) public headerBlocks;\\n    Registry internal registry;\\n}\\n\"\r\n    },\r\n    \"contracts/common/misc/Proxy.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\nimport {DelegateProxy} from \\\"./DelegateProxy.sol\\\";\\nimport {ProxyStorage} from \\\"./ProxyStorage.sol\\\";\\n\\n\\ncontract Proxy is ProxyStorage, DelegateProxy {\\n    event ProxyUpdated(address indexed _new, address indexed _old);\\n    event OwnerUpdate(address _prevOwner, address _newOwner);\\n\\n    constructor(address _proxyTo) public {\\n        updateImplementation(_proxyTo);\\n    }\\n\\n    function() external payable {\\n        // require(currentContract != 0, \\\"If app code has not been set yet, do not call\\\");\\n        // Todo: filter out some calls or handle in the end fallback\\n        delegatedFwd(proxyTo, msg.data);\\n    }\\n\\n    function implementation() external view returns (address) {\\n        return proxyTo;\\n    }\\n\\n    function updateImplementation(address _newProxyTo) public onlyOwner {\\n        require(_newProxyTo != address(0x0), \\\"INVALID_PROXY_ADDRESS\\\");\\n        require(isContract(_newProxyTo), \\\"DESTINATION_ADDRESS_IS_NOT_A_CONTRACT\\\");\\n        emit ProxyUpdated(_newProxyTo, proxyTo);\\n        proxyTo = _newProxyTo;\\n    }\\n\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_target)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/root/withdrawManager/IWithdrawManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract IWithdrawManager {\\n    function createExitQueue(address token) external;\\n\\n    function verifyInclusion(\\n        bytes calldata data,\\n        uint8 offset,\\n        bool verifyTxInclusion\\n    ) external view returns (uint256 age);\\n\\n    function addExitToQueue(\\n        address exitor,\\n        address childToken,\\n        address rootToken,\\n        uint256 exitAmountOrTokenId,\\n        bytes32 txHash,\\n        bool isRegularExit,\\n        uint256 priority\\n    ) external;\\n\\n    function addInput(\\n        uint256 exitId,\\n        uint256 age,\\n        address utxoOwner,\\n        address token\\n    ) external;\\n\\n    function challengeExit(\\n        uint256 exitId,\\n        uint256 inputId,\\n        bytes calldata challengeData,\\n        address adjudicatorPredicate\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     * @notice Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_heimdallId\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"headerBlockId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"NewHeaderBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"headerBlockId\",\"type\":\"uint256\"}],\"name\":\"ResetHeaderBlock\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTE_TYPE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_nextHeaderBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"headerBlocks\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heimdallId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"networkId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"proxyTypeId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newProxyTo\",\"type\":\"address\"}],\"name\":\"updateImplementation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RootChainProxy", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000185a4091027e2db459a2433f85f894dc3013aeb50000000000000000000000002255686dff7bcc3aee7277ee751647261e75afb400000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000010226865696d64616c6c2d31353030312200000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "1", "Implementation": "0x185a4091027e2db459a2433f85f894dc3013aeb5", "SwarmSource": ""}