{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/automation/GelatoJobAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {Job} from \\\"./Job.sol\\\";\\nimport {IResolver} from \\\"./gelato/IResolver.sol\\\";\\nimport {OpsReady, IOps} from \\\"./gelato/OpsReady.sol\\\";\\n\\n/// @notice Contract expect work will be prepayd, so it cannot pay for work\\nerror PayableWorkNotAllowed();\\n\\n/// @title Implementation of the mixin that adds support for Gelato (keepers operator)\\nabstract contract GelatoJobAdapter is Job, IResolver, OpsReady {\\n    /// @notice If job is prepaid, then it not will try to pay on executed work.\\n    bool public isPrepaid;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    // ------------------------------------------ Constructors ------------------------------------------\\n\\n    /**\\n     * @notice Constructor of Job adapter contract.\\n     * @param _ops - address of the Ops contract.\\n     * @param _minimumBetweenExecutions - required time which must pass between executions of the job in seconds.\\n     * @param _isPrepaid - If job is prepaid, then it not will try to pay on executed work\\n     */\\n    function __GelatoJobAdapter_init(\\n        IOps _ops,\\n        uint256 _minimumBetweenExecutions,\\n        bool _isPrepaid\\n    ) internal onlyInitializing {\\n        __OpsReady_init(_ops);\\n        __Job_init(_minimumBetweenExecutions);\\n\\n        __GelatoJobAdapter_init_unchained(_isPrepaid);\\n    }\\n\\n    /**\\n     * @notice Unchained constructor of Job adapter contract without rest of the contracts init\\n     * @param _isPrepaid - If job is prepaid, then it not will try to pay on executed work\\n     */\\n    function __GelatoJobAdapter_init_unchained(bool _isPrepaid)\\n        internal\\n        onlyInitializing\\n    {\\n        isPrepaid = _isPrepaid;\\n    }\\n\\n    /// @notice Resolver checker that says if the work can be performed and with what params.\\n    function checker()\\n        public\\n        view\\n        returns (bool canExec, bytes memory execPayload)\\n    {\\n        canExec = canWork();\\n\\n        execPayload = abi.encodeWithSelector(\\n            isPrepaid ? this.work.selector : this.payableWork.selector\\n        );\\n    }\\n\\n    /// @notice Bot will call this method when `checker` returns `true`.\\n    /// Will pay caller\\n    /// `_doWork` method stay as it is, to allow a call off-chain\\n    function payableWork() public nonReentrant onlyOps {\\n        if (isPrepaid) {\\n            revert PayableWorkNotAllowed();\\n        }\\n\\n        _doWork();\\n\\n        // Check -> Effect -> Interaction\\n        // To prevent exploits pay only at the end of operations\\n        _payGalatoFee();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/automation/Job.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {ReentrancyGuardUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {ContextUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\n\\nimport {SafeInitializable} from \\\"../upgradeable/SafeInitializable.sol\\\";\\n\\n/// Someone tried to execute work function while `canWork` is `false`\\nerror CannotWorkNow();\\n\\n/// Given time minimum between execution must be greater then 1000\\nerror TimeMinimumBetweenExecutionsIncorrect(uint256 _givenTime);\\n\\n/// @title Abstract contract by implementation of which\\n///  possible to make child contract support of one of keeper providers.\\n/// @notice This contract is only define interface,\\n///  for add support of specific provider need add specific mixin contract.\\nabstract contract Job is\\n    SafeInitializable,\\n    ContextUpgradeable,\\n    ReentrancyGuardUpgradeable\\n{\\n    /// Job work function was executed by worker bot\\n    event Worked(address indexed worker);\\n\\n    /// @notice Timestamp of last work execution block in seconds.\\n    /// @dev Logic of checking and manupulating execution must be only in this contract (not in child)\\n    ///  to control timestamp dependce vularability.\\n    /// Important: Expect all timestamp can be adgasted by miners.\\n    /// More info at: https://www.getsecureworld.com/blog/what-is-timestamp-dependence-vulnerability/\\n    uint256 public lastWorkTime;\\n\\n    /// @notice Mininmal time which must pass between executions of the job in seconds.\\n    /// Better set hours, but at least set to greater then 900 seconds,\\n    /// node opperators able to manipulate timestamp in 900 seconds range, on some blockchains maybe bigger.\\n    uint256 public minimumBetweenExecutions;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    // ------------------------------------------ Constructors ------------------------------------------\\n\\n    /**\\n     * @notice Constructor of Job contract.\\n     * @param _minimumBetweenExecutions - required time which must pass between executions of the job in seconds.\\n     *  Set in hours to prevent block timestamp vularability\\n     */\\n    function __Job_init(uint256 _minimumBetweenExecutions)\\n        internal\\n        onlyInitializing\\n    {\\n        __Context_init();\\n        __ReentrancyGuard_init();\\n\\n        __Job_init_unchained(_minimumBetweenExecutions);\\n    }\\n\\n    /**\\n     * @notice Unchained constructor of Job contract without rest of the contracts init\\n     * @param _minimumBetweenExecutions - required time which must pass between executions of the job in seconds.\\n     *  Set in hours to prevent block timestamp vularability\\n     */\\n    function __Job_init_unchained(uint256 _minimumBetweenExecutions)\\n        internal\\n        onlyInitializing\\n    {\\n        _setMinimumBetweenExecutions(_minimumBetweenExecutions);\\n        // Not will set lastWorkTime to allow first work immediately after contract deploy\\n    }\\n\\n    // ------------------------------------------ Public methods  ------------------------------------------\\n\\n    /// @notice If work can be executed by keeper at this moment returns true\\n    /// @dev Will be executed by keeper and before `work` method execution.\\n    function canWork() public view returns (bool) {\\n        // TODO: Check the maximum delay between job executions (?)\\n        return\\n            isTimePassFromLastExecution(minimumBetweenExecutions) && _canWork();\\n    }\\n\\n    /// @notice allow execution only if `canWork` return true\\n    modifier onlyWhenCanWork() {\\n        if (!canWork()) {\\n            revert CannotWorkNow();\\n        }\\n        _;\\n    }\\n\\n    /// @notice A handle that allows the `_doWork` function to be invoked externally by everyone.\\n    /// Perform a `canWork` check to avoid unnecessary and (maybe) malicious calls.\\n    /// @dev `nonReentrant` modifier might be excess there, since we have `isTimePassFromLastExecution` check\\n    /// and `refreshLastWorkTime` at start (see `onlyWhenCanWork` modifier). Let's keep it, as `canWork` can be overridden.\\n    function work() public nonReentrant onlyWhenCanWork {\\n        _doWork();\\n    }\\n\\n    /// @notice Performs `_work` call and refreshes the last execution time.\\n    function _doWork() internal {\\n        // Refresh execution works like `nonReentrant` modifier if we have a `isTimePassFromLastExecution` check inside `canWork`.\\n        _refreshLastWorkTime();\\n\\n        // An important work that is meant to be executed by the keeper.\\n        _work();\\n\\n        emit Worked(msg.sender);\\n    }\\n\\n    // ------------------------------------------ Time check logic ------------------------------------------\\n\\n    /// @notice Set minimum time between executions.\\n    /// @param time - required time which must pass between executions of the job in seconds.\\n    /// Set in hours to prevent block timestamp vulnerability\\n    function _setMinimumBetweenExecutions(uint256 time) internal {\\n        if (time <= 1000) {\\n            revert TimeMinimumBetweenExecutionsIncorrect(time);\\n        }\\n\\n        minimumBetweenExecutions = time;\\n    }\\n\\n    /// @notice Time that passed since the last exection\\n    /// @return seconds from last execution in a range of 900 seconds\\n    function timeFromLastExecution() public view returns (uint256) {\\n        // lastWorkTime will be zero before first execution\\n        return block.timestamp - lastWorkTime; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /// @notice Set time of last execution to current block\\n    function _refreshLastWorkTime() internal {\\n        lastWorkTime = block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /// @notice Check if given time from last execution is passed\\n    /// @param second - amount of time which mast pass from last execution\\n    /// @return true if enough time pass\\n    function isTimePassFromLastExecution(uint256 second)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return timeFromLastExecution() > second;\\n    }\\n\\n    // ------------------------------------------ Busines methods to override  ------------------------------\\n\\n    /// @notice Method which will be executed by keeper\\n    function _work() internal virtual;\\n\\n    /// @notice Method which identify if work can be executed at this moment.\\n    /// @dev Will be executed by keeper and before `work` method execution.\\n    /// @return true if `work` method can be called.\\n    function _canWork() internal view virtual returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/automation/gelato/BackCombatibleTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// @notice Library that adding support for ERC20 and native tokens transfers.\\n/// @dev Based of https://github.com/gelatodigital/ops/blob/9a9cde6ab2f1b132b949f9244fd59a1de4da4123/contracts/vendor/gelato/FGelato.sol\\nlibrary BackCombatibleTransfer {\\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Backcombatible transfer to given address, will use ERC20 transfer if given token is ERC20.\\n    function backCombatibleTransfer(\\n        address payable to,\\n        address paymentToken,\\n        uint256 amount\\n    ) internal {\\n        if (paymentToken == ETH) {\\n            safeNativeTransfer(to, amount);\\n            return;\\n        }\\n\\n        SafeERC20.safeTransfer(IERC20(paymentToken), to, amount);\\n    }\\n\\n    /// @notice Native token transfer that checks `call` result.\\n    function safeNativeTransfer(address payable to, uint256 amount) internal {\\n        // We don't use `transfer` or `send`, as they are considered bad practices after the Istanbul hardfork.\\n        (bool success, ) = to.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Native transfer failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/automation/gelato/IOps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\n/// @dev Based on https://github.com/gelatodigital/ops\\ninterface IOps {\\n    function gelato() external view returns (address payable);\\n\\n    function getFeeDetails() external view returns (uint256, address);\\n}\\n\"\r\n    },\r\n    \"src/automation/gelato/IResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\n/// @dev Copy of https://github.com/gelatodigital/ops/blob/9a9cde6ab2f1b132b949f9244fd59a1de4da4123/contracts/interfaces/IResolver.sol\\ninterface IResolver {\\n    function checker()\\n        external\\n        view\\n        returns (bool canExec, bytes memory execPayload);\\n}\\n\"\r\n    },\r\n    \"src/automation/gelato/OpsReady.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport {IOps} from \\\"./IOps.sol\\\";\\nimport {BackCombatibleTransfer} from \\\"./BackCombatibleTransfer.sol\\\";\\n\\nimport {SafeInitializable} from \\\"../../upgradeable/SafeInitializable.sol\\\";\\n\\n/// Based on https://github.com/gelatodigital/ops/blob/9a9cde6ab2f1b132b949f9244fd59a1de4da4123/contracts/vendor/gelato/OpsReady.sol\\n/// @notice Give basic methods to pay for Gelato operations.\\nabstract contract OpsReady is SafeInitializable {\\n    IOps public ops;\\n    address payable public gelato;\\n\\n    using BackCombatibleTransfer for address payable;\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    modifier onlyOps() {\\n        require(msg.sender == address(ops), \\\"OpsReady: onlyOps\\\");\\n        _;\\n    }\\n \\n    /**\\n     * Contructor of contract which will be able to communicate with Gelato protocol\\n     * @param _ops - address of the Ops contract.\\n     * @dev addresses can be found at https://docs.gelato.network/developer-products/gelato-ops-smart-contract-automation-hub/contract-addresses\\n     */\\n    function __OpsReady_init(IOps _ops) internal onlyInitializing {\\n        ops = _ops;\\n        gelato = ops.gelato();\\n    }\\n\\n    /// @notice Will pay bot for executed task through galato\\n    function _payGalatoFee() internal {\\n        (uint256 fee, address feeToken) = ops.getFeeDetails();\\n\\n        gelato.backCombatibleTransfer(feeToken, fee);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/healthcheck/HealthChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport {IHealthCheck, ACCEPTABLE_LOSS, SIGNIFICANT_LOSS} from \\\"./IHealthCheck.sol\\\";\\nimport {SafeInitializable} from \\\"../upgradeable/SafeInitializable.sol\\\";\\n\\nerror HealthCheckFailed();\\n\\nabstract contract HealthChecker is SafeInitializable, OwnableUpgradeable {\\n    event HealthCheckChanged(address healthCheck);\\n    event HealthCheckEnabledChanged(bool enabled);\\n    event HealthCheckTriggered(uint8 result);\\n\\n    // represents 100%\\n    uint256 public constant MAX_BPS = 10_000;\\n\\n    IHealthCheck public healthCheck;\\n    bool public healthCheckEnabled;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    // ------------------------------------------ Constructors ------------------------------------------\\n\\n    function __HealthChecker_init(address _healthCheck)\\n        internal\\n        onlyInitializing\\n    {\\n        __Ownable_init();\\n        __HealthChecker_init_unchained(_healthCheck);\\n    }\\n\\n    function __HealthChecker_init_unchained(address _healthCheck)\\n        internal\\n        onlyInitializing\\n    {\\n        setHealthCheck(_healthCheck);\\n        setHealthCheckEnabled(true);\\n    }\\n\\n    /// @notice Sets the health check implementation contract.\\n    /// @param _healthCheck A new health check contract address.\\n    /// @dev Emits the \\\"HealthCheckChanged\\\" event.\\n    function setHealthCheck(address _healthCheck) public onlyOwner {\\n        healthCheck = IHealthCheck(_healthCheck);\\n        emit HealthCheckChanged(_healthCheck);\\n    }\\n\\n    /// @notice Enables or disables the health check.\\n    /// @param _healthCheckEnabled If \\\"true\\\" - health check will be disabled.\\n    /// @dev Emits the \\\"HealthCheckEnabledChanged\\\" event.\\n    /// Do not disable the health check, unless you need to perform \\\"report\\\" in an emergency.\\n    function setHealthCheckEnabled(bool _healthCheckEnabled) public onlyOwner {\\n        healthCheckEnabled = _healthCheckEnabled;\\n        emit HealthCheckEnabledChanged(_healthCheckEnabled);\\n    }\\n\\n    /// @notice Performs the health check by calling external contract.\\n    /// @param strategy Address of the strategy to be checked.\\n    /// @param profit The amount of funds that the strategy realised as profit.\\n    /// @param loss The amount of funds that the strategy realised as loss.\\n    /// @param debtPayment The amount of funds that the strategy spent to pay the debt.\\n    /// @param debtOutstanding Outstanding strategy debt.\\n    /// @param totalDebt The total amount of funds borrowed by the strategy from the vault.\\n    function performHealthCheck(\\n        address strategy,\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 debtOutstanding,\\n        uint256 totalDebt,\\n        uint256 gasCost\\n    ) internal virtual {\\n        // No health check implementation provided, skip the execution.\\n        if (address(healthCheck) == address(0)) {\\n            return;\\n        }\\n\\n        // There is usually no reason to turn off health checks.\\n        // But sometimes it may be necessary if we need to call a \\\"report\\\" manually.\\n        // If this happens, we should turn it on again.\\n        if (!healthCheckEnabled) {\\n            setHealthCheckEnabled(true);\\n            return;\\n        }\\n\\n        // If no custom health check implementation provided, call default one.\\n        uint8 checkResult = healthCheck.check(\\n            strategy,\\n            profit,\\n            loss,\\n            debtPayment,\\n            debtOutstanding,\\n            totalDebt,\\n            gasCost\\n        );\\n        emit HealthCheckTriggered(checkResult);\\n\\n        if(checkResult == SIGNIFICANT_LOSS) { // call fallback if loss to big\\n            healthCheckFailedFallback();\\n        } else if(checkResult == ACCEPTABLE_LOSS) { // call secondary fallback if loss is acceptable\\n            acceptableLossFallback();\\n        }\\n        // just allow to run normally in case of transaction is profitable\\n    }\\n\\n    /// @dev Fallback function that is called when the health check fails.\\n    function healthCheckFailedFallback() internal virtual {\\n        revert HealthCheckFailed();\\n    }\\n\\n    /// @dev Fallback function that is called when the health check fails but loss is acceptable.\\n    /* solhint-disable no-empty-blocks */\\n    function acceptableLossFallback() internal virtual {\\n        // do nothing by default but can be overridden\\n    }\\n    /* solhint-disable no-empty-blocks */\\n}\\n\"\r\n    },\r\n    \"src/healthcheck/IHealthCheck.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nuint8 constant PASS = 0;\\nuint8 constant ACCEPTABLE_LOSS = 1;\\nuint8 constant SIGNIFICANT_LOSS = 2;\\n\\ninterface IHealthCheck {\\n    /// @notice Checks the overall state of the strategy\\n    /// @param strategy Address of the strategy to be checked.\\n    /// @param profit The amount of funds that the strategy realised as profit.\\n    /// @param loss The amount of funds that the strategy realised as loss.\\n    /// @param debtPayment The amount of funds that the strategy spent to pay the debt.\\n    /// @param debtOutstanding Outstanding strategy debt.\\n    /// @param totalDebt The total amount of funds borrowed by the strategy from the vault.\\n    /// @param gasCost cost of transaction for strategy\\n    /// @return The status of a completed health check as enumerated. 0 is strategy is healthy and profitable,\\n    /// 1 is strategy is healthy but cost of transaction bigger than profit so it shouldn't be collected,\\n    /// 2 is strategy is unhealthy\\n    function check(\\n        address strategy,\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 debtOutstanding,\\n        uint256 totalDebt,\\n        uint256 gasCost\\n    ) external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/lending/ILender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\n/// Base contract for lending protocols, can be used for colletaralized and not colletaralized lending.\\ninterface ILender {\\n\\n    /// @notice Returns the number of tokens the borrower (caller of this function) can take from the lender\\n    /// @return Available credit as amount of tokens\\n    function availableCredit() external view returns (uint256);\\n\\n    /// @notice Returns the outstanding debt that the borrower (caller of this function) must repay\\n    /// @return Outstanding debt as amount of tokens\\n    function outstandingDebt() external view returns (uint256);\\n\\n    /// @notice Returns the amount of funds taken by the borrower (caller of this function).\\n    /// @return Debt as amount of tokens\\n    function currentDebt() external view returns (uint256);\\n\\n    /// @notice Returns the debt ratio of the borrower (caller of this function).\\n    function currentDebtRatio() external view returns (uint256);\\n\\n    /// @notice Returns the last report timestamp of the borrower (caller of this function).\\n    function lastReport() external view returns (uint256);\\n\\n    /// @notice Returns the activation status of the borrower (caller of this function).\\n    /// @return \\\"true\\\" if the borrower is active\\n    function isActivated() external view returns (bool);\\n\\n    /// @notice Indicates if the vault was shutted down or not.\\n    /// @return \\\"true\\\" if the contract is paused, and \\\"false\\\" otherwise.\\n    function paused() external view returns (bool);\\n\\n    /// @notice Reports a positive result of the borrower's debt management.\\n    ///         Borrower must call this function if he has made any profit\\n    ///         or/and has a free funds available to repay the outstanding debt (if any).\\n    /// @param extraFreeFunds an extra amount of free funds borrower's contract has.\\n    ///                       This reporting amount must be greater than the borrower's outstanding debt.\\n    /// @param debtPayment is the funds that the borrower must release in order to pay off his outstanding debt (if any).\\n    function reportPositiveDebtManagement(\\n        uint256 extraFreeFunds,\\n        uint256 debtPayment\\n    ) external;\\n\\n    /// @notice Reports a negative result of the borrower's debt management.\\n    ///         The borrower must call this function if he is unable to cover his outstanding debt or if he has incurred any losses.\\n    /// @param loss a number of tokens by which the borrower's balance has decreased since the last report.\\n    ///        May include a portion of the outstanding debt that the borrower was unable to repay.\\n    /// @param debtPayment is the funds that the borrower must release in order to pay off his outstanding debt (if any).\\n    function reportNegativeDebtManagement(uint256 loss, uint256 debtPayment)\\n        external;\\n}\\n\"\r\n    },\r\n    \"src/lending/IStrategiesLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {ILender} from \\\"./ILender.sol\\\";\\n\\n/// Lender contract which targeted to lend specifically for investments strategies.\\n/// Basically represent specific case of implementation of whitelist not colletaraized lending contract.\\ninterface IStrategiesLender is ILender {\\n\\n    /// @notice Arranged list of addresses of strategies, which defines the order for withdrawal.\\n    function withdrawalQueue(uint256 index) external view returns (address);\\n\\n    /// @notice Revokes a strategy from the vault.\\n    ///         Sets strategy's dept ratio to zero, so that the strategy cannot take funds from the vault.\\n    /// @param strategy a strategy to revoke.\\n    function revokeStrategy(address strategy) external;\\n\\n    /// @notice Returns average interst rate of lender per block. \\n    ///         Based on last report utilization rate and possibly cached interest rate of each strategy.\\n    ///         Can be outadated, but close enough to real state for on chain calculations.\\n    ///         Calculate average by combining utilisation rate of each strategy with its interest rate.\\n    ///         Returns additional total utilisation rate of lender, as additional product of calculation, usefull to safe gas.\\n    /// @return interstRate - The interest rate per block, scaled by 1e18\\n    /// @return utilisationRate - The utilisation rate of the lender, in BPS (scaled by 1e4)\\n    function interestRatePerBlock() external view returns (uint256 interstRate, uint256 utilisationRate);\\n}\\n\"\r\n    },\r\n    \"src/strategies/ApeLendingStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {MathUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport {BaseStrategy} from \\\"./BaseStrategy.sol\\\";\\nimport {CTokenBaseStrategy, IOps} from \\\"./CTokenBaseStrategy.sol\\\";\\nimport {ICToken} from \\\"./protocols/ICToken.sol\\\";\\nimport {IPancakeRouter} from  \\\"./protocols/IPancakeRouter.sol\\\";\\nimport {IRainMaker} from \\\"./protocols/IRainMaker.sol\\\";\\nimport {IStrategy} from \\\"./IStrategy.sol\\\";\\nimport {IStrategiesLender} from \\\"../lending/IStrategiesLender.sol\\\";\\n\\nimport {IVersionable} from \\\"../upgradeable/IVersionable.sol\\\";\\nimport {SafeInitializable} from \\\"../upgradeable/SafeInitializable.sol\\\";\\nimport {SafeUUPSUpgradeable} from \\\"../upgradeable/SafeUUPSUpgradeable.sol\\\";\\n\\n\\ncontract ApeLendingStrategy is SafeUUPSUpgradeable, CTokenBaseStrategy {\\n    uint256 public constant SECONDS_PER_BLOCK = 3; // for BSC only\\n    uint256 public constant REWARD_ESTIMATION_ACCURACY = 90;\\n\\n    address public constant BANANA = 0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95;\\n    address public constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public constant RAIN_MAKER = 0x5CB93C0AdE6B7F2760Ec4389833B0cCcb5e4efDa;\\n    address public constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n\\n    /// @notice Minimum BANANA token amount to sell.\\n    uint256 public minBananaToSell;\\n\\n    IPancakeRouter public pancakeRouter;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    /// @inheritdoc IVersionable\\n    function version() external pure override returns (string memory) {\\n        return \\\"0.4.3\\\";\\n    }\\n\\n    // ------------------------------------------ Constructors ------------------------------------------\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(bool needDisableInitializers) SafeInitializable(needDisableInitializers) {} // solhint-disable-line no-empty-blocks\\n\\n    function initialize(\\n        address _vault,\\n        address _asset,\\n        address _cToken,\\n        address _ops,\\n        address _nativeTokenPriceFeed,\\n        address _assetPriceFeed,\\n        uint256 _minReportInterval,\\n        bool _isPrepaid,\\n        address _healthCheck\\n    ) public initializer {\\n        __SafeUUPSUpgradeable_init_direct();\\n        __CTokenBaseStrategy_init(\\n            IStrategiesLender(_vault),\\n            IERC20Upgradeable(_asset),\\n            ICToken(_cToken),\\n            IRainMaker(RAIN_MAKER), \\n            IERC20Upgradeable(BANANA),\\n            IOps(_ops),\\n            AggregatorV3Interface(_nativeTokenPriceFeed),\\n            AggregatorV3Interface(_assetPriceFeed),\\n            _minReportInterval,\\n            _isPrepaid,\\n            _healthCheck\\n        ); // ownable under the hood\\n\\n        __ApeLendingStrategy_init_unchained(IERC20Upgradeable(BANANA), IPancakeRouter(PANCAKE_ROUTER));\\n    }\\n\\n    function __ApeLendingStrategy_init_unchained(IERC20Upgradeable _bananaToken, IPancakeRouter _pancakeRouter) internal onlyInitializing {\\n        pancakeRouter = _pancakeRouter;\\n\\n        minBananaToSell = 0.1 ether;\\n\\n        approveTokenMax(address(_bananaToken), address(_pancakeRouter));\\n    }\\n\\n    /// @notice Sets the minimum number of BANANA tokens that must be on the contract to sell.\\n    function setMinBananaToSell(uint256 _minBananaToSell) external onlyOwner {\\n        minBananaToSell = _minBananaToSell;\\n    }\\n\\n    /// @inheritdoc IStrategy\\n    function name() external view returns (string memory) {\\n        return\\n            string.concat(\\n                IERC20MetadataUpgradeable(address(asset)).symbol(),\\n                \\\" ApeLending Strategy\\\"\\n            );\\n    }\\n\\n    /// @inheritdoc BaseStrategy\\n    function estimatedTotalAssets() public view override returns (uint256) {\\n        (, uint256 underlyingAmount) = depositedBalanceSnapshot();\\n        return asset.balanceOf(address(this)) + underlyingAmount + _totalBananaBalanceInAsset();\\n    }\\n\\n    /// @notice This function makes a prediction on how much BANANA is accrued per block.\\n    /// @dev It is not completely accurate because it uses the current protocol balance to predict into the past.\\n    function _estimatedAccruedBananaPerBlock() internal view returns (uint256) {\\n        (, uint256 _depositedBalance) = depositedBalanceSnapshot();\\n        if (_depositedBalance == 0) {\\n            return 0; // should be impossible to have 0 balance and positive comp accrued\\n        }\\n        uint256 distributionPerBlock = rainMaker.compSupplySpeeds(\\n            address(cToken)\\n        );\\n        uint256 totalSupply = (cToken.totalSupply() *\\n            cToken.exchangeRateStored()) / 1e18;\\n        return\\n            totalSupply > 0\\n                ? (_depositedBalance * distributionPerBlock) / totalSupply\\n                : 0;\\n    }\\n\\n    /// @notice This function makes a prediction on how much BANANA is accrued.\\n    /// @dev It is not completely accurate because it uses the current protocol balance to predict into the past.\\n    function _estimatedAccruedBanana() internal view returns (uint256) {\\n        uint256 bananaPerBlock = _estimatedAccruedBananaPerBlock();\\n        if (bananaPerBlock == 0) {\\n            return 0;\\n        }\\n        // TODO: remove call to vault, need decrease gas usage\\n        // TODO: use block.number instead of block.timestamp\\n        // can use block dependent operation in this case\\n        // this logic is criticial only for cases when strategy need make harvest\\n        // but Job contract check minimum blocks interval between harvests\\n        // which decrease change of manipulation with block data by miners\\n        uint256 blocksSinceLastHarvest = (block.timestamp - lender.lastReport()) / SECONDS_PER_BLOCK; // solhint-disable-line not-rely-on-time\\n        return blocksSinceLastHarvest * bananaPerBlock;\\n    }\\n\\n    /// @notice Returns the current (and estimated accrued) banana balance of the strategy contract (in asset).\\n    /// @dev Constant REWARD_ESTIMATION_ACCURACY is used to match accuracy expectations.\\n    function _totalBananaBalanceInAsset() internal view returns (uint256) {\\n        uint256 balance = _currentBananaBalance() + _estimatedAccruedBanana();\\n        if (balance == 0) {\\n            return 0;\\n        }\\n        uint256[] memory amounts = pancakeRouter.getAmountsOut(\\n            balance,\\n            _tokenSwapPath(BANANA, address(asset))\\n        );\\n        uint256 amount = amounts[amounts.length - 1];\\n        return (amount * REWARD_ESTIMATION_ACCURACY) / 100;\\n    }\\n\\n    /// @notice Prepares a chain of tokens (pair or triplet) to pass it into the router contract.\\n    function _tokenSwapPath(address tokenIn, address tokenOut)\\n        internal\\n        pure\\n        returns (address[] memory path)\\n    {\\n        bool isWBNB = tokenIn == address(WBNB) || tokenOut == address(WBNB);\\n        path = new address[](isWBNB ? 2 : 3);\\n        path[0] = tokenIn;\\n\\n        if (isWBNB) {\\n            path[1] = tokenOut;\\n        } else {\\n            path[1] = address(WBNB);\\n            path[2] = tokenOut;\\n        }\\n    }\\n\\n    /// @notice Changes the existing BANANA on the contract to an asset token.\\n    function _swapBananaToAsset() internal {\\n        uint256 bananaBalance = compToken.balanceOf(\\n            address(this)\\n        );\\n        if (bananaBalance < minBananaToSell) {\\n            return;\\n        }\\n\\n        pancakeRouter.swapExactTokensForTokens(\\n            bananaBalance,\\n            0,\\n            _tokenSwapPath(address(compToken), address(asset)),\\n            address(this),\\n            block.timestamp // solhint-disable-line not-rely-on-time\\n        );\\n    }\\n\\n    /// @inheritdoc BaseStrategy\\n    function _harvest(uint256 outstandingDebt)\\n        internal\\n        override\\n        returns (\\n            uint256 profit,\\n            uint256 loss,\\n            uint256 debtPayment\\n        )\\n    {\\n        profit = 0;\\n        loss = 0;\\n\\n        // No positions to harvest, allocate available funds to pay the debt (if any)\\n        if (cToken.balanceOf(address(this)) == 0) {\\n            debtPayment = MathUpgradeable.min(\\n                asset.balanceOf(address(this)),\\n                outstandingDebt\\n            );\\n            return (profit, loss, debtPayment);\\n        }\\n\\n        uint256 deposits = depositedBalance();\\n\\n        _claimBanana();\\n        _swapBananaToAsset();\\n\\n        uint256 assetBalance = asset.balanceOf(address(this));\\n        uint256 balance = deposits + assetBalance;\\n\\n        uint256 debt = lender.currentDebt();\\n\\n        if (balance <= debt) {        \\n            loss = debt - balance;\\n            debtPayment = MathUpgradeable.min(assetBalance, outstandingDebt);\\n            return (profit, loss, debtPayment);\\n        }\\n\\n        profit = balance - debt;\\n        if (assetBalance < profit) {\\n            // if profit will be not need, we will reinvest it back\\n            return _prepareFreeFunds(profit - assetBalance, outstandingDebt);\\n        } \\n        \\n        if (assetBalance > profit + outstandingDebt) {\\n            debtPayment = outstandingDebt;\\n\\n            return (profit, loss, debtPayment);\\n        } \\n        \\n        debtPayment = assetBalance - profit;\\n        return (profit, loss, debtPayment);\\n    }\\n\\n    /// Withdraw some funds from protocol to give Vault ability to withdraw them on report\\n    function _prepareFreeFunds(uint256 needWithdraw, uint256 outstandingDebt) \\n        internal \\n        returns (\\n            uint256 profit,\\n            uint256 loss,\\n            uint256 debtPayment\\n        ) \\n    {\\n        // we need take funds from protocol\\n        // to give Vault ability withdraw this profit on report\\n        withdrawFromProtocol(needWithdraw);\\n        // expect that assets balance grown from last call\\n        uint256 assetBalance = asset.balanceOf(address(this));\\n\\n        debtPayment = MathUpgradeable.min(\\n            assetBalance,\\n            outstandingDebt\\n        );\\n        profit = assetBalance - debtPayment;\\n\\n        // if profit will be not need, we will reinvest it back\\n        return (profit, loss, debtPayment);\\n    }\\n\\n    /// @inheritdoc BaseStrategy\\n    function _adjustPosition(uint256 outstandingDebt) internal override {\\n        if (paused()) {\\n            return;\\n        }\\n\\n        uint256 assetBalance = asset.balanceOf(address(this));\\n        if (assetBalance < outstandingDebt) {\\n            // We compare the balance with 1 because of rounding error\\n            if (cToken.balanceOf(address(this)) > 1) {\\n                _liquidatePosition(outstandingDebt - assetBalance);\\n            }\\n            return;\\n        }\\n\\n        uint256 freeBalance = assetBalance - outstandingDebt;\\n        if (freeBalance > 0) {\\n            depositToProtocol(freeBalance);\\n        }\\n    }\\n\\n    /// @inheritdoc BaseStrategy\\n    /// @dev Tagged with the keyword \\\"virtual\\\" for testing purposes.\\n    function _liquidatePosition(uint256 assets)\\n        internal\\n        virtual\\n        override\\n        returns (uint256 liquidatedAmount, uint256 loss)\\n    {\\n        uint256 assetBalance = asset.balanceOf(address(this));\\n        if (assetBalance < assets) {\\n            liquidatedAmount = withdrawFromProtocol(assets);\\n            loss = assets - liquidatedAmount;\\n        } else {\\n            liquidatedAmount = assets;\\n        }\\n    }\\n\\n    /// @inheritdoc BaseStrategy\\n    function _liquidateAllPositions()\\n        internal\\n        override\\n        returns (uint256 amountFreed)\\n    {\\n        amountFreed = withdrawFromProtocol(type(uint256).max);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {PausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport {IStrategy} from \\\"./IStrategy.sol\\\";\\nimport {IStrategiesLender} from \\\"../lending/IStrategiesLender.sol\\\";\\nimport {GelatoJobAdapter, IOps} from \\\"../automation/GelatoJobAdapter.sol\\\";\\nimport {Job} from \\\"../automation/Job.sol\\\";\\nimport {HealthChecker} from \\\"../healthcheck/HealthChecker.sol\\\";\\nimport {PriceConverter} from \\\"../structures/PriceConverter.sol\\\";\\n\\nimport {SafeInitializable} from \\\"../upgradeable/SafeInitializable.sol\\\";\\n\\nerror CallerIsNotALender();\\nerror IncompatiblePriceFeeds();\\n\\nabstract contract BaseStrategy is\\n    IStrategy,\\n    SafeInitializable,\\n    GelatoJobAdapter,\\n    HealthChecker,\\n    PausableUpgradeable\\n{\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using PriceConverter for AggregatorV3Interface;\\n\\n    IStrategiesLender public lender;\\n    IERC20Upgradeable public asset;\\n\\n    /// @notice Use this to adjust the threshold at which running a debt causes a work trigger.\\n    uint256 public debtThreshold;\\n\\n    /// @notice The estimated amount of gas required for the \\\"work\\\" execution.\\n    uint256 public estimatedWorkGas;\\n\\n    /// @notice Shows how many times the gas price spent for the \\\"work\\\" function should be lower than the profit to trigger.\\n    uint256 public profitFactor;\\n\\n    /// @notice The USD price feed for the native token of the network on which this strategy works.\\n    AggregatorV3Interface internal _nativeTokenPriceFeed;\\n\\n    /// @notice The USD price feed for the strategy asset.\\n    AggregatorV3Interface internal _assetPriceFeed;\\n\\n    /// @notice The underlying asset's decimals.\\n    uint256 internal _assetDecimals;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    event Harvested(\\n        uint256 profit,\\n        uint256 loss,\\n        uint256 debtPayment,\\n        uint256 outstandingDebt\\n    );\\n\\n    event DebtThresholdUpdated(uint256 debtThreshold);\\n\\n    event EstimatedWorkGasUpdated(uint256 estimatedWorkGas);\\n\\n    event UpdatedProfitFactor(uint256 profitFactor);\\n\\n    modifier onlyLender() {\\n        if (msg.sender != address(lender)) {\\n            revert CallerIsNotALender();\\n        }\\n        _;\\n    }\\n\\n    // ------------------------------------------ Constructors ------------------------------------------\\n\\n    function __BaseStrategy_init(\\n        IStrategiesLender _lender,\\n        IERC20Upgradeable _asset,\\n        IOps _ops,\\n        uint256 _minReportInterval,\\n        bool _isPrepaid,\\n        AggregatorV3Interface __nativeTokenPriceFeed,\\n        AggregatorV3Interface __assetPriceFeed,\\n        address _healthCheck\\n    ) internal onlyInitializing {\\n        __HealthChecker_init(_healthCheck); // ownable under the hood\\n        __Pausable_init();\\n        __GelatoJobAdapter_init(_ops, _minReportInterval, _isPrepaid);\\n\\n        __BaseStrategy_init_unchained(\\n            _lender,\\n            _asset,\\n            __nativeTokenPriceFeed,\\n            __assetPriceFeed\\n        );\\n    }\\n\\n    function __BaseStrategy_init_unchained(\\n        IStrategiesLender _lender,\\n        IERC20Upgradeable _asset,\\n        AggregatorV3Interface __nativeTokenPriceFeed,\\n        AggregatorV3Interface __assetPriceFeed\\n    ) internal onlyInitializing {\\n        lender = _lender;\\n        asset = _asset;\\n\\n        debtThreshold = 0;\\n        estimatedWorkGas = 0;\\n        profitFactor = 100;\\n\\n        _nativeTokenPriceFeed = __nativeTokenPriceFeed;\\n        _assetPriceFeed = __assetPriceFeed;\\n        if (_nativeTokenPriceFeed.decimals() != _assetPriceFeed.decimals()) {\\n            revert IncompatiblePriceFeeds();\\n        }\\n\\n        _assetDecimals = IERC20MetadataUpgradeable(address(asset)).decimals();\\n\\n        approveTokenMax(address(asset), address(_lender));\\n    }\\n\\n    /// @notice Harvests the strategy, recognizing any profits or losses and adjusting the strategy's investments.\\n    /// @inheritdoc Job\\n    function _work() internal override {\\n        uint256 profit = 0;\\n        uint256 loss = 0;\\n        uint256 debtPayment = 0;\\n\\n        uint256 outstandingDebt = lender.outstandingDebt();\\n        if (paused()) {\\n            (profit, loss, debtPayment) = _harvestAfterShutdown(\\n                outstandingDebt\\n            );\\n        } else {\\n            (profit, loss, debtPayment) = _harvest(outstandingDebt);\\n        }\\n\\n        if (profit > 0) {\\n            lender.reportPositiveDebtManagement(profit, debtPayment);\\n        } else {\\n            lender.reportNegativeDebtManagement(loss, debtPayment);\\n        }\\n\\n        // If the strategy needs to repay the entire debt, we need to take all available funds.\\n        // We will take the current debt in the report above, but we still need to free up whatever is left.\\n        // This can happen, if the ratio is reduced to 0 or if the vault has been shutted down.\\n        outstandingDebt = lender.outstandingDebt();\\n        outstandingDebt = lender.currentDebtRatio() == 0 || lender.paused()\\n            ? estimatedTotalAssets()\\n            : outstandingDebt;\\n\\n        _adjustPosition(outstandingDebt);\\n\\n        uint256 totalDebt = lender.currentDebt();\\n        uint256 gasCost = _gasCost();\\n\\n        emit Harvested(profit, loss, debtPayment, outstandingDebt);\\n\\n        performHealthCheck(\\n            address(this),\\n            profit,\\n            loss,\\n            debtPayment,\\n            outstandingDebt,\\n            totalDebt,\\n            gasCost\\n        );\\n    }\\n\\n    /// @inheritdoc Job\\n    function _canWork() internal view override returns (bool) {\\n        if (!lender.isActivated()) {\\n            return false;\\n        }\\n\\n        // Trigger this job if the strategy has the outstanding debt to repay\\n        uint256 outstanding = lender.outstandingDebt();\\n        if (outstanding > debtThreshold) {\\n            return true;\\n        }\\n\\n        // Trigger this job if the strategy has some loss to report\\n        uint256 total = estimatedTotalAssets();\\n        uint256 debt = lender.currentDebt();\\n        if (total + debtThreshold < debt) {\\n            return true;\\n        }\\n\\n        // Estimate accumulated profit\\n        uint256 profit = 0;\\n        if (total > debt) {\\n            profit = total - debt;\\n        }\\n\\n        // Check the gas cost againts the profit and available credit.\\n        // There is no sense to call the \\\"work\\\" function, if we don't have decent amount of funds to move.\\n        return _checkGasPriceAgainstProfit(profit);\\n    }\\n\\n    /// @notice Calculates the gas price of this transaction and compares it againts the specified profit.\\n    /// @param profit Profit to be compared to the cost of gas.\\n    /// @return \\\"true\\\" if the gas price (mult. to \\\"profitFactor\\\" is lower than the strategy profit, in USD).\\n    function _checkGasPriceAgainstProfit(uint256 profit) internal view returns (bool) {\\n        uint256 credit = lender.availableCredit();\\n        uint256 gasCost = _gasCost();\\n        return profitFactor * gasCost < _convertAmountToUSD(credit + profit);\\n    }\\n\\n    /// @notice Calculates the gas cost for this transaction based on gas price and work\\n    /// @return gas price\\n    function _gasCost() internal view returns  (uint256) {\\n        return _gasPriceUSD() * estimatedWorkGas;\\n    }\\n\\n    /// @inheritdoc IStrategy\\n    function withdraw(uint256 assets) external override onlyLender returns (uint256 loss) { // Vault already have nonReentrant modifier check\\n        // Liquidate the requested amount of tokens\\n        uint256 amountFreed;\\n        (amountFreed, loss) = _liquidatePosition(assets);\\n\\n        // Send it directly back to the vault\\n        IERC20Upgradeable(asset).safeTransfer(msg.sender, amountFreed);\\n    }\\n\\n    /// @notice Shutdown the strategy and revoke it form the lender.\\n    function shutdown() public nonReentrant onlyOwner { // need check nonReentrant to avoid cyclic call\\n        _pause();\\n        lender.revokeStrategy(address(this));\\n    }\\n\\n    /// @notice Sets the debt threshold.\\n    /// @param _debtThreshold The new debt threshold value.\\n    function setDebtThreshold(uint256 _debtThreshold) external onlyOwner {\\n        debtThreshold = _debtThreshold;\\n        emit DebtThresholdUpdated(_debtThreshold);\\n    }\\n\\n    /// @notice Sets the estimated gas that will be required for \\\"work\\\" function.\\n    /// @param _estimatedWorkGas The estimated \\\"work\\\" gas value.\\n    function setEstimatedWorkGas(uint256 _estimatedWorkGas) external onlyOwner {\\n        estimatedWorkGas = _estimatedWorkGas;\\n        emit EstimatedWorkGasUpdated(_estimatedWorkGas);\\n    }\\n\\n    /// @notice Sets the profit factor.\\n    /// @param _profitFactor The new profit factor value.\\n    function setProfitFactor(uint256 _profitFactor) external onlyOwner {\\n        profitFactor = _profitFactor;\\n        emit UpdatedProfitFactor(_profitFactor);\\n    }\\n\\n    /// @notice Frees up as much funds of the base protocol as possible.\\n    /// @dev This function is called on harvest if the strategy was shutted down.\\n    /// @param outstandingDebt The outstanding debt of the strategy.\\n    function _harvestAfterShutdown(uint256 outstandingDebt)\\n        internal\\n        virtual\\n        returns (\\n            uint256 profit,\\n            uint256 loss,\\n            uint256 debtPayment\\n        )\\n    {\\n        _liquidateAllPositions();\\n        uint256 freeBalance = _freeAssets();\\n\\n        if (freeBalance < outstandingDebt) {\\n            loss = outstandingDebt - freeBalance;\\n        } else if (freeBalance > outstandingDebt) {\\n            profit = freeBalance - outstandingDebt;\\n        }\\n        debtPayment = outstandingDebt - loss;\\n    }\\n\\n    /// @notice Calculates the gas price of the current transaction (in USD).\\n    function _gasPriceUSD() internal view returns (uint256) {\\n        return _nativeTokenPriceFeed.convertAmount(tx.gasprice, 18);\\n    }\\n\\n    /// @notice Calculates the pice of the specified amount of \\\"asset\\\" (in USD).\\n    function _convertAmountToUSD(uint256 amount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _assetPriceFeed.convertAmount(amount, _assetDecimals);\\n    }\\n\\n    /// @notice Sets the max token allowance for the specified spender.\\n    function approveTokenMax(address token, address spender) internal {\\n        IERC20Upgradeable(token).safeApprove(spender, type(uint256).max);\\n    }\\n\\n    /// @notice Set minimum time between executions.\\n    /// @param time - required time which must pass between executions of the job in seconds.\\n    /// Set in hours to prevent block timestamp vulnerability\\n    function setMinimumBetweenExecutions(uint256 time) public onlyOwner {\\n        _setMinimumBetweenExecutions(time);\\n    }\\n\\n    /// @notice Estimates the total amount of strategy funds (including those invested in the base protocol).\\n    function estimatedTotalAssets() public view virtual returns (uint256);\\n\\n    /// @notice The main function of the strategy.\\n    /// By calling this function, the strategy must realize (take out) the possible profits from the underlying protocol.\\n    function _harvest(uint256 outstandingDebt)\\n        internal\\n        virtual\\n        returns (\\n            uint256 profit,\\n            uint256 loss,\\n            uint256 debtPayment\\n        );\\n\\n    /// @notice Performs the deposit of the free funds to the underlying protocol.\\n    function _adjustPosition(uint256 outstandingDebt) internal virtual;\\n\\n    /// @notice Withdraws the specific amount of \\\"asset\\\" from the underlying protocol.\\n    /// @param assets The amount of token to withdraw.\\n    /// @return liquidatedAmount Withdrawn amount\\n    /// @return loss The amount that could not be withdrawn\\n    function _liquidatePosition(uint256 assets)\\n        internal\\n        virtual\\n        returns (uint256 liquidatedAmount, uint256 loss);\\n\\n    /// @notice Withdraws the entire invested amount from the underlying protocol.\\n    function _liquidateAllPositions()\\n        internal\\n        virtual\\n        returns (uint256 amountFreed);\\n\\n    /// @dev Fallback function that is called when the health check fails.\\n    function healthCheckFailedFallback() internal virtual override{\\n        // Prevent cycle of failed health checks on shutdown\\n        if (!paused()) {\\n            shutdown();\\n            _work();\\n        }\\n    }\\n\\n    /// @notice Returns free balance of the strategy.\\n    function _freeAssets()\\n        internal\\n        virtual\\n        returns(uint256)\\n    {\\n        return asset.balanceOf(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/strategies/CTokenBaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {MathUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport {ICInterestRate} from \\\"./protocols/ICInterestRate.sol\\\";\\nimport {BaseStrategy, IOps} from \\\"./BaseStrategy.sol\\\";\\nimport {ICToken} from \\\"./protocols/ICToken.sol\\\";\\nimport {IRainMaker} from \\\"./protocols/IRainMaker.sol\\\";\\nimport {IStrategy} from \\\"./IStrategy.sol\\\";\\nimport {IStrategiesLender} from \\\"../lending/IStrategiesLender.sol\\\";\\n\\nerror IncompatibleCTokenContract();\\nerror UnsupportedDecimals();\\nerror MintError(uint256 code);\\nerror RedeemError(uint256 code);\\n\\n/** Base for implementation of strategy on top of CToken (Compound-like market)  */\\nabstract contract CTokenBaseStrategy is ICInterestRate, BaseStrategy {\\n\\n    /** Market on top of which strategy operates */\\n    ICToken public cToken;\\n    /** Contract which allow claim compToken reward */\\n    IRainMaker public rainMaker;\\n    /** Token which is used for reward, COMP for Compund */\\n    IERC20Upgradeable public compToken;\\n\\n    /** Required for mapping of interest rate calculated per second to rate calculated per block */\\n    uint256 public secondPerBlock;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    /** Emitted when assets are moved to the protocol */\\n    event DepositedToProtocol(uint256 amount, uint256 sharesBefore, uint256 underlyingBefore, uint256 sharesAfter, uint256 underlyingAfter);\\n\\n    /** Emitted when assets are moved from the protocol */\\n    event WithdrawnFromProtocol(uint256 amount, uint256 sharesBefore, uint256 underlyingBefore, uint256 sharesAfter, uint256 underlyingAfter, uint256 redeemedAmount);\\n\\n    // ------------------------------------------ Constructors ------------------------------------------\\n\\n    function __CTokenBaseStrategy_init(\\n        IStrategiesLender _lender,\\n        IERC20Upgradeable _asset,\\n        ICToken _cToken,\\n        IRainMaker _rainMaker,\\n        IERC20Upgradeable _compToken,\\n        IOps _ops,\\n        AggregatorV3Interface _nativeTokenPriceFeed,\\n        AggregatorV3Interface _assetPriceFeed,\\n        uint256 _minReportInterval,\\n        bool _isPrepaid,\\n        address _healthCheck\\n    ) public onlyInitializing {\\n        __BaseStrategy_init(\\n            _lender,\\n            _asset,\\n            _ops,\\n            _minReportInterval,\\n            _isPrepaid,\\n            _nativeTokenPriceFeed,\\n            _assetPriceFeed,\\n            _healthCheck\\n        ); // Ownable is under the hood\\n\\n        __CTokenBaseStrategyinit_unchained(_cToken, _rainMaker, _compToken);\\n    }\\n\\n    function __CTokenBaseStrategyinit_unchained(ICToken _cToken, IRainMaker _rainMaker, IERC20Upgradeable _compToken) internal onlyInitializing {\\n        secondPerBlock = 3; // 3.01 seconds avarage for BSC\\n        cToken = _cToken;\\n        rainMaker = _rainMaker;\\n        compToken = _compToken;\\n\\n        if (cToken.decimals() != 8 || _assetDecimals != 18) {\\n            revert UnsupportedDecimals();\\n        }\\n\\n        if (cToken.underlying() != address(asset)) {\\n            revert IncompatibleCTokenContract();\\n        }\\n\\n        approveTokenMax(address(asset), address(_cToken));\\n    }\\n\\n    /// @notice Returns the current banana balance of the strategy contract.\\n    function _currentBananaBalance() internal view returns (uint256) {\\n        return compToken.balanceOf(address(this));\\n    }\\n\\n    /// @notice Retrieves accrued BANANA from the protocol.\\n    function _claimBanana() internal {\\n        ICToken[] memory tokens = new ICToken[](1);\\n        tokens[0] = cToken;\\n        rainMaker.claimComp(address(this), tokens);\\n    }\\n\\n    /// @inheritdoc IStrategy\\n    function interestRatePerBlock() public view returns (uint256) {\\n        return supplyRatePerBlock();\\n    }\\n\\n    /// @notice Returns current deposited balance (in asset).\\n    /// @dev Unlike the snapshot function, this function recalculates the value of the deposit.\\n    function depositedBalance() public returns (uint256) {\\n        return cToken.balanceOfUnderlying(address(this));\\n    }\\n\\n    /// @notice Returns current deposited balance (in shares, in asset).\\n    /// @dev The exchange rate is recalculated at the last time someone touched the cToken contract.\\n    ///      Transactions are not performed too often on this contract, perhaps we should consider recalculating the rate ourselves.\\n    function depositedBalanceSnapshot() public view returns (uint256, uint256) {\\n        (, uint256 cTokenBalance, , uint256 exchangeRate) = cToken.getAccountSnapshot(address(this));\\n\\n        // ApeSwap's cToken has 8 decimals and the exchange rate has 28 decimals (see why: https://docs.compound.finance/v2/ctokens/#exchange-rate).\\n        // To convert cTokens to assets, we need to scale down the multiplication of these numbers by 1e18 to get underlying decimals (which are 18).\\n        return (cTokenBalance, (cTokenBalance * exchangeRate) / 1e18);\\n    }\\n\\n    /// @notice Deposits the assets into the protocol.\\n    /// @param amount Amount to deposit\\n    function depositToProtocol(uint256 amount) internal {\\n        (uint256 sharesBefore, uint256 underlyingBefore) = depositedBalanceSnapshot();\\n\\n        uint256 result = cToken.mint(amount);\\n        if (result > 0) {\\n            revert MintError(result);\\n        }\\n\\n        (uint256 sharesAfter, uint256 underlyingAfter) = depositedBalanceSnapshot();\\n        emit DepositedToProtocol(amount, sharesBefore, underlyingBefore, sharesAfter, underlyingAfter);\\n    }\\n\\n    /// @notice Takes the assets out of the protocol.\\n    /// @param amount Amount to withdraw\\n    /// @return The amount that has been withdrawn.\\n    function withdrawFromProtocol(uint256 amount) internal returns (uint256) {\\n        (uint256 sharesBefore,) = depositedBalanceSnapshot();\\n\\n        uint256 balanceBefore = _freeAssets();\\n        uint256 deposits = depositedBalance();\\n        uint256 amountToRedeem = MathUpgradeable.min(deposits, amount);\\n        uint256 result = cToken.redeemUnderlying(amountToRedeem);\\n        if (result > 0) {\\n            revert RedeemError(result);\\n        }\\n\\n        (uint256 sharesAfter, uint256 underlyingAfter) = depositedBalanceSnapshot();\\n\\n        // underlying protocol can return less than calculated above, so this check is required to avoid manipulations\\n        uint256 balanceAfter = _freeAssets();\\n        uint256 redeemedAmount = balanceAfter - balanceBefore;\\n\\n        emit WithdrawnFromProtocol(amountToRedeem, sharesBefore, deposits, sharesAfter, underlyingAfter, redeemedAmount);\\n\\n        return redeemedAmount;\\n    }\\n\\n\\n    // ------------------------------------------ Pass interest-related methods from cToken ------------------------------------------\\n    // Methods must be overridden by the strategy contract if they change the interest rate model\\n\\n    /// @inheritdoc ICInterestRate\\n    function borrowRatePerBlock() public view returns (uint256) {\\n        if (cToken.blocksBased()) {\\n            return cToken.borrowRatePerBlock();\\n        }\\n\\n        // in this case \\\"PerBlock\\\" actually means \\\"PerSecond\\\"\\n        return cToken.borrowRatePerBlock() * secondPerBlock;\\n    }\\n\\n    /// @inheritdoc ICInterestRate\\n    function supplyRatePerBlock() public view returns (uint256) {\\n        if (cToken.blocksBased()) {\\n            return cToken.supplyRatePerBlock();\\n        }\\n\\n        // in this case \\\"PerBlock\\\" actually means \\\"PerSecond\\\"\\n        return cToken.supplyRatePerBlock() * secondPerBlock;\\n    }\\n\\n    /// @inheritdoc ICInterestRate\\n    function exchangeRateCurrent() public returns (uint256) {\\n        return cToken.exchangeRateCurrent();\\n    }\\n\\n    /// @inheritdoc ICInterestRate\\n    function exchangeRateStored() public view returns (uint256) {\\n        return cToken.exchangeRateStored();\\n    }\\n\\n    /// @inheritdoc ICInterestRate\\n    function accrueInterest() public returns (uint256) {\\n        return cToken.accrueInterest();\\n    }\\n}\"\r\n    },\r\n    \"src/strategies/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IStrategiesLender} from \\\"../lending/IStrategiesLender.sol\\\";\\n\\ninterface IStrategy {\\n    /// @notice Returns the name of this strategy.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the contract address of the underlying asset of this strategy.\\n    function asset() external view returns (IERC20Upgradeable);\\n\\n    /// @notice Returns the contract address of the Lender to which this strategy is connected.\\n    function lender() external view returns (IStrategiesLender);\\n\\n    /// @notice Transfers a specified amount of tokens to the vault.\\n    /// @param assets A amount of tokens to withdraw.\\n    /// @return loss A number of tokens that the strategy could not return.\\n    function withdraw(uint256 assets) external returns (uint256 loss);\\n\\n    /// @notice Returns interst rate of strategy per block, for current block or block prior to this one.\\n    /// @dev Can be calculated not for all strategies and usally not such accurate as sliding window averages,\\n    ///  but still can be usafull for on chain calculations and as fallback method.\\n    /// @return The interest rate per block, scaled by 1e18\\n    function interestRatePerBlock() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/strategies/protocols/ICInterestRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\n/// @notice Interest related CToken methods of Compound-like market (or vault in common terms), that allows current APY/APR related meth.\\ninterface ICInterestRate {\\n    /**\\n     * @notice Returns the current per-block borrow interest rate for this cToken\\n     * @return The borrow interest rate per block, scaled by 1e18\\n     */\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the current per-block supply interest rate for this cToken\\n     * @return The supply interest rate per block, scaled by 1e18\\n     */\\n    function supplyRatePerBlock() external view returns (uint256);\\n\\n    /**\\n     * @notice Accrue interest then return the up-to-date exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    /**\\n     * @notice Calculates the exchange rate from the underlying to the CToken\\n     * @dev This function does not accrue interest before calculating the exchange rate\\n     * @return Calculated exchange rate scaled by 1e18\\n     */\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    /**\\n     * @notice Applies accrued interest to total borrows and reserves\\n     * @dev This calculates interest accrued from the last checkpointed block\\n     *   up to the current block and writes new checkpoint to storage.\\n     */\\n    function accrueInterest() external returns (uint256);\\n}\"\r\n    },\r\n    \"src/strategies/protocols/ICToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {ICInterestRate} from \\\"./ICInterestRate.sol\\\";\\n\\n/// @notice Interface for Compound-like market (or vault in common terms), that allows to deposit and borrow tokens.\\ninterface ICToken is ICInterestRate {\\n\\n    /** \\n     * Indicates if the calculations should be blocks or time based\\n     * @notice Specific for Ola Finance\\n     */\\n    function blocksBased() external view returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function underlying() external view returns (address);\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function totalBorrowsCurrent() external returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external returns (uint256);\\n\\n    function borrowBalanceStored(address account)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCash() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external returns (uint256);\\n\\n    function mint(uint256 mintAmount) external returns (uint256);\\n\\n    function redeem(uint256 redeemTokens) external returns (uint256);\\n\\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\\n\\n    function borrow(uint256 borrowAmount) external returns (uint256);\\n\\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\\n        external\\n        returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        ICToken cTokenCollateral\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/strategies/protocols/IPancakeRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\n/// @notice Interface for Uniswap-like exchange router.\\ninterface IPancakeRouter {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/strategies/protocols/IRainMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {ICToken} from \\\"./ICToken.sol\\\";\\n\\n/// @notice Interface for a compound-like controller used to control incentivized tokens received during interaction with the protocol.\\ninterface IRainMaker {\\n    struct CompMarketState {\\n        /// @notice The market's last updated compBorrowIndex or compSupplyIndex\\n        uint224 index;\\n        /// @notice The block number the index was last updated at\\n        uint32 block;\\n    }\\n\\n    function compSupplierIndex(address, address)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function compSpeeds(address cToken) external view returns (uint256);\\n\\n    function compSupplySpeeds(address cToken) external view returns (uint256);\\n\\n    function compBorrowSpeeds(address cToken) external view returns (uint256);\\n\\n    function claimComp(address holder, ICToken[] memory cTokens) external;\\n\\n    function claimComp(address holder) external;\\n\\n    function compAccrued(address holder) external view returns (uint256);\\n\\n    function compSupplyState(address cToken)\\n        external\\n        view\\n        returns (CompMarketState memory);\\n}\\n\"\r\n    },\r\n    \"src/structures/PriceConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {AggregatorV3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport {SafeMathUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol\\\";\\n\\nerror NegativePrice();\\n\\nlibrary PriceConverter {\\n    using SafeMathUpgradeable for uint256;\\n\\n    uint256 public constant UP_TO_DECIMALS = 18;\\n\\n    /// @notice Calculates the price of the specified number of tokens.\\n    /// @dev This function converts the specified number of tokens to their price (scaled to 18 decimal places).\\n    /// @param priceFeed The Chainlink's price feed aggregator.\\n    /// @param amount Number of tokens, the value of which needs to be calculated.\\n    /// @param decimals Decimals of the specified token.\\n    /// @return The calculated price of the tokens.\\n    function convertAmount(\\n        AggregatorV3Interface priceFeed,\\n        uint256 amount,\\n        uint256 decimals\\n    ) internal view returns (uint256) {\\n        (, int256 price, , , ) = priceFeed.latestRoundData();\\n        if (price < 0) {\\n            revert NegativePrice();\\n        }\\n\\n        // Scaling decimals up to 18 places to increase accuracy.\\n        // For example, the \\\"USD\\\" price feed has 8 decimal places, so the calculation may result in zeros if a small [amount] is passed.\\n        uint256 priceDecimals = priceFeed.decimals();\\n        (, uint256 priceScaledDecimals) = UP_TO_DECIMALS.trySub(priceDecimals);\\n        uint256 scaledPrice = uint256(price) * 10**priceScaledDecimals;\\n\\n        return amount * scaledPrice / 10**decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/upgradeable/IVersionable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\n/** \\n * Allow properly identify different versions of the same contract \\n * and track upgrades results \\n * */\\ninterface IVersionable  {\\n    /// @notice Returns the current version of this contract\\n    /// @return a version in semantic versioning format\\n    function version() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/upgradeable/SafeInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {IVersionable} from \\\"./IVersionable.sol\\\";\\n\\n/** Implement best practices for initializable contracts */\\nabstract contract SafeInitializable is IVersionable, Initializable {\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    /**\\n     * This constructor prevents UUPS Uninitialized Proxies Vulnerability in all contracts which inherit from it.\\n     * More info about vulnerability: https://medium.com/immunefi/wormhole-uninitialized-proxy-bugfix-review-90250c41a43a\\n     * \\n     * @dev Initial fix for this vulnerability was suggested as using `_disableInitializers()` function in constructor,\\n     *  but later, in version 4.3.2, OpenZeppelin implemented `onlyProxy` modifier for UUPS upgradable contracts,\\n     *  which fixed this vulnerability. Still, `_disableInitializers()` is a best practice which prevents unintended access \\n     *  to implementation contracts that can be used maliciously.\\n     *  \\n     *  More info: https://forum.openzeppelin.com/t/how-to-test-upgradeability-for-proxies/33436/7 \\n     *      and https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680\\n     * \\n     * To prevent code duplication of constructor, this contract can be used. On the other hand, \\n     * it can be used as a marker for contracts that are safe from this vulnerability.\\n     * Additionally, `needDisableInitializers` parameter can be used to enable initializers in mocks and unit tests.\\n     *\\n     * @param needDisableInitializers - if true, initializers will be disabled\\n     */\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(bool needDisableInitializers) {\\n        if(needDisableInitializers) {\\n            _disableInitializers();\\n        }\\n    }\\n}\"\r\n    },\r\n    \"src/upgradeable/SafeUUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.19;\\n\\nimport {UUPSUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport {SafeInitializable} from \\\"./SafeInitializable.sol\\\";\\n\\n/** \\n * Implement basic safety mechanism for UUPS proxy\\n * based on owner authorization for upgrades\\n * */\\nabstract contract SafeUUPSUpgradeable is UUPSUpgradeable, SafeInitializable, OwnableUpgradeable {\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n\\n    /** Init all required constructors, including ownable */\\n    function __SafeUUPSUpgradeable_init() internal onlyInitializing {\\n        __SafeUUPSUpgradeable_init_direct();\\n\\n        __Ownable_init();\\n    }\\n\\n    /** Init only direct constructors, UUPS only */\\n    function __SafeUUPSUpgradeable_init_direct() internal onlyInitializing {\\n        __UUPSUpgradeable_init();\\n    }\\n\\n    /** Authorise that upgrades can do only owner */\\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {} // solhint-disable-line no-empty-blocks\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"needDisableInitializers\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerIsNotALender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotWorkNow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncompatibleCTokenContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncompatiblePriceFeeds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"MintError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NegativePrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PayableWorkNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"RedeemError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_givenTime\",\"type\":\"uint256\"}],\"name\":\"TimeMinimumBetweenExecutionsIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedDecimals\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtThreshold\",\"type\":\"uint256\"}],\"name\":\"DebtThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAfter\",\"type\":\"uint256\"}],\"name\":\"DepositedToProtocol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedWorkGas\",\"type\":\"uint256\"}],\"name\":\"EstimatedWorkGasUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtPayment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outstandingDebt\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"healthCheck\",\"type\":\"address\"}],\"name\":\"HealthCheckChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"HealthCheckEnabledChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"result\",\"type\":\"uint8\"}],\"name\":\"HealthCheckTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitFactor\",\"type\":\"uint256\"}],\"name\":\"UpdatedProfitFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemedAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawnFromProtocol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"worker\",\"type\":\"address\"}],\"name\":\"Worked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BANANA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAIN_MAKER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_ESTIMATION_ACCURACY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStrategiesLender\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract ICToken\",\"name\":\"_cToken\",\"type\":\"address\"},{\"internalType\":\"contract IRainMaker\",\"name\":\"_rainMaker\",\"type\":\"address\"},{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"_compToken\",\"type\":\"address\"},{\"internalType\":\"contract IOps\",\"name\":\"_ops\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"_nativeTokenPriceFeed\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"_assetPriceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReportInterval\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPrepaid\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_healthCheck\",\"type\":\"address\"}],\"name\":\"__CTokenBaseStrategy_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cToken\",\"outputs\":[{\"internalType\":\"contract ICToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canWork\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canExec\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"execPayload\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compToken\",\"outputs\":[{\"internalType\":\"contract IERC20Upgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositedBalanceSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedTotalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedWorkGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gelato\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"healthCheck\",\"outputs\":[{\"internalType\":\"contract IHealthCheck\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"healthCheckEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ops\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeTokenPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetPriceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minReportInterval\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isPrepaid\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_healthCheck\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPrepaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWorkTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"internalType\":\"contract IStrategiesLender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBananaToSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumBetweenExecutions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ops\",\"outputs\":[{\"internalType\":\"contract IOps\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableWork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rainMaker\",\"outputs\":[{\"internalType\":\"contract IRainMaker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debtThreshold\",\"type\":\"uint256\"}],\"name\":\"setDebtThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_estimatedWorkGas\",\"type\":\"uint256\"}],\"name\":\"setEstimatedWorkGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_healthCheck\",\"type\":\"address\"}],\"name\":\"setHealthCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_healthCheckEnabled\",\"type\":\"bool\"}],\"name\":\"setHealthCheckEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBananaToSell\",\"type\":\"uint256\"}],\"name\":\"setMinBananaToSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setMinimumBetweenExecutions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_profitFactor\",\"type\":\"uint256\"}],\"name\":\"setProfitFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyRatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeFromLastExecution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"work\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ApeLendingStrategy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "5", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "paris", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}