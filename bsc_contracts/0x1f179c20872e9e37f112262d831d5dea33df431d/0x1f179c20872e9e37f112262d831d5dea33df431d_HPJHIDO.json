{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.19;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 { \r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\nIERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n\r\ncontract HPJHIDO is Ownable{\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() \r\n    {\r\n        require(unlocked == 1, 'upline: locked');\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    uint256 total_v;\r\n\r\n    uint256 public totalHpjhV;\r\n\r\n     function editTotalV(uint256 v)\r\n        public  checkEdit\r\n    {\r\n        total_v = v;\r\n    } \r\n\r\n    function selectAmount()\r\n        public  view  returns (uint256)\r\n    {\r\n        return total_v;\r\n    }\r\n   \r\n    uint256  startPrice = 200;\r\n\r\n    function editStartPrice(uint256 p)\r\n        public checkEdit\r\n    {\r\n        startPrice = p;\r\n    }\r\n\r\n    function selectPrice()\r\n        public view returns(uint256)\r\n    {\r\n        return startPrice;\r\n    }\r\n\r\n    function amountNum(uint256 a)\r\n        public  view returns(uint256)\r\n    {\r\n        return   ((a / startPrice) / 1e15 ) * 1 ether;\r\n    }\r\n   \r\n    address public su =0xE71606e5B60E142D87E7F14c3aF5DF3186B23B42;\r\n\r\n    function editSu(address addrSu)\r\n        public checkEdit\r\n    {\r\n        su = addrSu;\r\n    }\r\n    uint256 public numberOfHolders = 1;\r\n    function editNumberOfHokders(uint256 num)\r\n    public checkEdit\r\n    {\r\n        numberOfHolders = num;\r\n    }\r\n\r\n    function selectDarrs()\r\n        public view returns (uint256[] memory)\r\n    {\r\n        return d_arrs;\r\n    }\r\n\r\n    struct user\r\n    {        \r\n        uint256 amount;\r\n        uint256 hpjh_amount;\r\n        uint256 hpjh_output;\r\n\r\n        address upline;\r\n        uint256 upline_one_count;\r\n        uint256 upline_one_reward;\r\n\r\n        uint256 one_count;\r\n        uint256 three_count;\r\n        uint256 five_count;\r\n\r\n        uint256 total_output;\r\n        bool once;\r\n        uint256 create_time;    \r\n    }\r\n\r\n    function editOncerCount1(address _a ,uint256 _b)\r\n        public checkEdit\r\n    {\r\n        users[_a].one_count = _b;\r\n    }\r\n      function editOncerCoun3(address _a ,uint256 _b)\r\n        public checkEdit\r\n    {\r\n        users[_a].three_count = _b;\r\n    }\r\n      function editOncerCount5(address _a ,uint256 _b)\r\n        public checkEdit\r\n    {\r\n        users[_a].five_count = _b;\r\n    }\r\n\r\n    uint256[]  d_arrs =[5,3,2];\r\n\r\n    function selectCount(uint256 a)\r\n        private \r\n    {\r\n        if(a == amountArr[0])\r\n        {\r\n            require(users[_msgSender()].once == false,\"subscribed_er\");\r\n            users[_msgSender()].once = true;\r\n        }else if(a == amountArr[1])\r\n        {\r\n            require(users[_msgSender()].one_count >= d_arrs[0],\"one_people_er\");\r\n            users[_msgSender()].one_count -= d_arrs[0];\r\n        }else if(a == amountArr[2])\r\n        {\r\n            require(users[_msgSender()].three_count >= d_arrs[1],\"three_people_er\");\r\n            users[_msgSender()].three_count-=d_arrs[1];\r\n        }else if(a == amountArr[3])\r\n        {\r\n            require(users[_msgSender()].five_count >= d_arrs[2],\"five_people_er\");\r\n            users[_msgSender()].five_count-=d_arrs[2];\r\n        }\r\n    }\r\n\r\n    function edituplieOneCount(address a,uint256 v)\r\n        public  checkEdit\r\n    {\r\n        users[a].upline_one_count = v;\r\n    } \r\n\r\n    mapping(address => user)   users;\r\n    mapping(address => address[])   users_upline;\r\n\r\n    struct Rv\r\n    {\r\n        address addr;\r\n        uint256 amount;\r\n        uint256 times;\r\n    }\r\n\r\n    function selectUpineOne(address addr,uint256 index,uint256 pageSize)\r\n        public view returns(Rv[] memory)\r\n    {\r\n        uint256  onelength = users_upline[addr].length;\r\n        if(pageSize < onelength){\r\n            onelength = pageSize;\r\n        }\r\n        if(onelength < index){\r\n            index = 0;\r\n        }\r\n        uint256 j = 0;\r\n        Rv[] memory  rv = new Rv[](onelength - index); \r\n        for(uint256 i = index; i < onelength; ++i)\r\n        {\r\n            address Rvv= users_upline[addr][i];\r\n            rv[j].addr = Rvv;\r\n            rv[j].amount= users[Rvv].hpjh_amount;\r\n            rv[j].times = users[Rvv].create_time;\r\n            j++;\r\n        }\r\n        return rv;\r\n    }\r\n\r\n    uint256[] amountArr  =[100 ether,300 ether, 500 ether,1000 ether];\r\n\r\n    mapping(address=>bool) public ist;\r\n    event Deplay(address,uint256,uint256);\r\n  \r\n    function deplay(uint256 amount) \r\n        external lock\r\n    {        \r\n        require(amount == amountArr[0]  || amount == amountArr[1]\r\n                || amount == amountArr[2]  || amount == amountArr[3],\"amount_er\");\r\n\r\n        selectCount(amount);\r\n\r\n        users[_msgSender()].amount += amount;\r\n\r\n        uint256 u_h = amountNum (amount);\r\n        \r\n        users[_msgSender()].hpjh_amount += u_h;\r\n      \r\n        users[_msgSender()].create_time = block.timestamp;\r\n\r\n        if(ist[_msgSender()] == false) {\r\n            numberOfHolders +=1;\r\n            ist[_msgSender()] = true;\r\n        }\r\n\r\n        totalHpjhV += u_h;\r\n        total_v += amount;\r\n        uplineShare(amount,u_h);\r\n        USDT.transferFrom(_msgSender(),su,amount);\r\n        emit Deplay(_msgSender(),amount,u_h);\r\n    }\r\n\r\n    function uplineShare(uint256 a,uint256 b)\r\n        private   \r\n    {\r\n       address addr =  users[_msgSender()].upline;\r\n        if(addr != address(0))\r\n        {\r\n            users[addr].upline_one_reward += b / 10;\r\n            if(a == amountArr[0])\r\n            {\r\n                users[addr].one_count+=1;\r\n            }else if(a == amountArr[1])\r\n            {\r\n               users[addr].three_count+=1;\r\n            } else if(a == amountArr[2])\r\n            {\r\n                users[addr].five_count+=1;\r\n            }  \r\n        }\r\n    }\r\n\r\n    address public HPGToken;\r\n\r\n    function editHpgToken(address addr)\r\n        public checkEdit\r\n    {\r\n        HPGToken = addr;\r\n    }    \r\n\r\n    event WD(address,uint256);\r\n    function wd(uint256 a)\r\n        external  lock\r\n    {\r\n        require(HPGToken != address(0),\"token_err\");\r\n        require(users[_msgSender()].amount > 0,\"deply_err\");\r\n       uint256 hpjh_output =  users[_msgSender()].hpjh_amount - users[_msgSender()].hpjh_output;\r\n        \r\n        if(hpjh_output >= a )\r\n        {\r\n            users[_msgSender()].hpjh_output += a;\r\n        }else{\r\n            hpjh_output += users[_msgSender()].upline_one_reward;\r\n            \r\n            if(hpjh_output  >= a )\r\n            {\r\n                users[_msgSender()].upline_one_reward = hpjh_output - a;\r\n            }else{\r\n                hpjh_output = 0;\r\n            }\r\n        }\r\n        require(hpjh_output > 0 ,\"wd_err\"); \r\n        users[_msgSender()].total_output += a;      \r\n        IERC20(HPGToken).transfer(_msgSender(),a);\r\n        emit WD(_msgSender(),a);\r\n    }\r\n\r\n    function upline(address addr) \r\n        external lock\r\n    {\r\n        require(users[addr].amount > 0 ,\"upline_amount_er\");\r\n        require(users[_msgSender()].upline == address(0),\"upline_zero_er\");\r\n        require(_msgSender() != addr,\"upline_err\");\r\n        users[_msgSender()].upline = addr;\r\n        users[addr].upline_one_count += 1;\r\n        users_upline[addr].push(_msgSender());    \r\n    }\r\n\r\n    function selectUsersInfo(address addr)\r\n        public view  \r\n        returns(user memory)\r\n    {        \r\n        return users[addr];\r\n    }\r\n\r\n    function selectUpline(address addr)\r\n        public view  \r\n        returns(address)\r\n    {        \r\n        return (users[addr].upline);\r\n\r\n    }\r\n\r\n    function addEditApprove(address addr,bool qd)\r\n    public onlyOwner\r\n    {\r\n        editApprove[addr] = qd;\r\n    }\r\n\r\n    function selectEditApprove(address addr)\r\n    public view returns(bool)\r\n    {\r\n        return editApprove[addr];\r\n    }\r\n\r\n    mapping(address => bool) editApprove;\r\n\r\n    modifier checkEdit()\r\n    {\r\n        require(editApprove[_msgSender()] || owner() == _msgSender(),\"edit_err\");\r\n        _;\r\n    }\r\n\r\n    function editUpline(address addr,address upAddr)\r\n        external checkEdit  \r\n    {        \r\n        users[addr].upline = upAddr;\r\n    }  \r\n\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) public  onlyOwner\r\n    {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"HPG::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Deplay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WD\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HPGToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"qd\",\"type\":\"bool\"}],\"name\":\"addEditApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"amountNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deplay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"editHpgToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"editNumberOfHokders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"editOncerCoun3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"editOncerCount1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"editOncerCount5\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"p\",\"type\":\"uint256\"}],\"name\":\"editStartPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addrSu\",\"type\":\"address\"}],\"name\":\"editSu\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"editTotalV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"upAddr\",\"type\":\"address\"}],\"name\":\"editUpline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"edituplieOneCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"safeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectDarrs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"selectEditApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selectPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"selectUpineOne\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"internalType\":\"struct HPJHIDO.Rv[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"selectUpline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"selectUsersInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hpjh_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hpjh_output\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"upline_one_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upline_one_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"one_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"three_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"five_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_output\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"once\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"create_time\",\"type\":\"uint256\"}],\"internalType\":\"struct HPJHIDO.user\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"su\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHpjhV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"upline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"wd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HPJHIDO", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://95b65bec0bc675d68cf323793b8143db9ca750ed614899827999490e25f7ec52"}