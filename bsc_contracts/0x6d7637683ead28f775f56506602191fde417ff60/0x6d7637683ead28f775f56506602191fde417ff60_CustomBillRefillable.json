{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@ape.swap/contracts/contracts/v0.8/access/PendingOwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract PendingOwnableUpgradeable is OwnableUpgradeable {\\n    address private _pendingOwner;\\n\\n    event SetPendingOwner(address indexed pendingOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev This function is disabled to in place of setPendingOwner()\\n     */\\n    function transferOwnership(\\n        address /*newOwner*/\\n    ) public view override onlyOwner {\\n        revert(\\\"PendingOwnable: MUST setPendingOwner()\\\");\\n    }\\n\\n    /**\\n     * @dev Sets an account as the pending owner (`newPendingOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function setPendingOwner(address newPendingOwner) public virtual onlyOwner {\\n        _pendingOwner = newPendingOwner;\\n        emit SetPendingOwner(_pendingOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership to the pending owner\\n     * Can only be called by the pending owner.\\n     */\\n    function acceptOwnership() public virtual {\\n        require(msg.sender == _pendingOwner, \\\"PendingOwnable: MUST be pendingOwner\\\");\\n        _pendingOwner = address(0);\\n        _transferOwnership(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"./AccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\\n    function __AccessControlEnumerable_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\\n    }\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        super._grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        super._revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/curves/LinearVestingCurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/*\\n  ______                     ______                                 \\n /      \\\\                   /      \\\\                                \\n|  \u2593\u2593\u2593\u2593\u2593\u2593\\\\ ______   ______ |  \u2593\u2593\u2593\u2593\u2593\u2593\\\\__   __   __  ______   ______  \\n| \u2593\u2593__| \u2593\u2593/      \\\\ /      \\\\| \u2593\u2593___\\\\\u2593\u2593  \\\\ |  \\\\ |  \\\\|      \\\\ /      \\\\ \\n| \u2593\u2593    \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\\\\  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\\\\u2593\u2593    \\\\| \u2593\u2593 | \u2593\u2593 | \u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\n| \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593    \u2593\u2593_\\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\ \u2593\u2593 | \u2593\u2593 | \u2593\u2593/      \u2593\u2593 \u2593\u2593  | \u2593\u2593\\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593__/ \u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\\__| \u2593\u2593 \u2593\u2593_/ \u2593\u2593_/ \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593__/ \u2593\u2593\\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593    \u2593\u2593\\\\\u2593\u2593     \\\\\\\\\u2593\u2593    \u2593\u2593\\\\\u2593\u2593   \u2593\u2593   \u2593\u2593\\\\\u2593\u2593    \u2593\u2593 \u2593\u2593    \u2593\u2593\\n \\\\\u2593\u2593   \\\\\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\n         | \u2593\u2593                                             | \u2593\u2593      \\n         | \u2593\u2593                                             | \u2593\u2593      \\n          \\\\\u2593\u2593                                              \\\\\u2593\u2593         \\n * App:             https://ApeSwap.finance\\n * Medium:          https://ape-swap.medium.com\\n * Twitter:         https://twitter.com/ape_swap\\n * Telegram:        https://t.me/ape_swap\\n * Announcements:   https://t.me/ape_swap_news\\n * Discord:         https://ApeSwap.click/discord\\n * Reddit:          https://reddit.com/r/ApeSwap\\n * Instagram:       https://instagram.com/ApeSwap.finance\\n * GitHub:          https://github.com/ApeSwapFinance\\n */\\n\\nimport \\\"../interfaces/IVestingCurve.sol\\\";\\n\\ncontract LinearVestingCurve is IVestingCurve {\\n    /**\\n     * @dev See {IVestingCurve-getVestedPayoutAtTime}.\\n     */\\n    function getVestedPayoutAtTime(\\n        uint256 totalPayout,\\n        uint256 vestingTerm,\\n        uint256 startTimestamp,\\n        uint256 checkTimestamp\\n    ) external pure returns (uint256 vestedPayout) {\\n        if (checkTimestamp <= startTimestamp) {\\n            vestedPayout = 0;\\n        } else if (checkTimestamp >= (startTimestamp + vestingTerm)) {\\n            vestedPayout = totalPayout;\\n        } else {\\n            /// @dev This is where custom vesting curves can be implemented.\\n            vestedPayout = (totalPayout * (checkTimestamp - startTimestamp)) / vestingTerm;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CustomBill.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/*\\n  ______                     ______                                 \\n /      \\\\                   /      \\\\                                \\n|  \u2593\u2593\u2593\u2593\u2593\u2593\\\\ ______   ______ |  \u2593\u2593\u2593\u2593\u2593\u2593\\\\__   __   __  ______   ______  \\n| \u2593\u2593__| \u2593\u2593/      \\\\ /      \\\\| \u2593\u2593___\\\\\u2593\u2593  \\\\ |  \\\\ |  \\\\|      \\\\ /      \\\\ \\n| \u2593\u2593    \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\\\\  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\\\\u2593\u2593    \\\\| \u2593\u2593 | \u2593\u2593 | \u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\n| \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593    \u2593\u2593_\\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\ \u2593\u2593 | \u2593\u2593 | \u2593\u2593/      \u2593\u2593 \u2593\u2593  | \u2593\u2593\\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593__/ \u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\\__| \u2593\u2593 \u2593\u2593_/ \u2593\u2593_/ \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593__/ \u2593\u2593\\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593    \u2593\u2593\\\\\u2593\u2593     \\\\\\\\\u2593\u2593    \u2593\u2593\\\\\u2593\u2593   \u2593\u2593   \u2593\u2593\\\\\u2593\u2593    \u2593\u2593 \u2593\u2593    \u2593\u2593\\n \\\\\u2593\u2593   \\\\\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\n         | \u2593\u2593                                             | \u2593\u2593      \\n         | \u2593\u2593                                             | \u2593\u2593      \\n          \\\\\u2593\u2593                                              \\\\\u2593\u2593         \\n * App:             https://ApeSwap.finance\\n * Medium:          https://ape-swap.medium.com\\n * Twitter:         https://twitter.com/ape_swap\\n * Telegram:        https://t.me/ape_swap\\n * Announcements:   https://t.me/ape_swap_news\\n * Discord:         https://ApeSwap.click/discord\\n * Reddit:          https://reddit.com/r/ApeSwap\\n * Instagram:       https://instagram.com/ApeSwap.finance\\n * GitHub:          https://github.com/ApeSwapFinance\\n */\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@ape.swap/contracts/contracts/v0.8/access/PendingOwnableUpgradeable.sol\\\";\\nimport \\\"./interfaces/ICustomBill.sol\\\";\\nimport \\\"./interfaces/ICustomTreasury.sol\\\";\\nimport \\\"./interfaces/IBillNft.sol\\\";\\nimport \\\"./curves/LinearVestingCurve.sol\\\";\\n\\n/**\\n * @title CustomBill (ApeSwap Treasury Bill)\\n * @author ApeSwap\\n * @custom:version 2.1.0 \\n * @notice \\n * - Control Variable is scaled up by 100x compared to v1.X.X.\\n * - principalToken MUST NOT be a fee-on-transfer token\\n * - payoutToken MAY be a fee-on-transfer, but it is HIGHLY recommended that \\n *     the CustomBill and CustomTreasury contracts are whitelisted from the \\n *     fee-on-transfer. This is because the payoutToken makes multiple hops \\n *     between contracts.\\n */\\ncontract CustomBill is Initializable, PendingOwnableUpgradeable, ICustomBill, ReentrancyGuard {\\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n\\n    /* ======== EVENTS ======== */\\n\\n    event FeeToChanged(address indexed newFeeTo);\\n    event MaxTotalPayoutChanged(uint256 newMaxTotalPayout);\\n    event UpdateClaimApproval(address indexed owner, address indexed approvedAccount, bool approved);\\n    event BillCreated(uint256 deposit, uint256 payout, uint256 expires, uint256 indexed billId);\\n    event BillClaimed(uint256 indexed billId, address indexed recipient, uint256 payout, uint256 remaining);\\n    event BillPriceChanged(uint256 internalPrice, uint256 debtRatio);\\n    event ControlVariableAdjustment(\\n        uint256 initialBCV,\\n        uint256 newBCV,\\n        uint256 adjustment\\n    );\\n    event SetFees(\\n        uint256[] fees,\\n        uint256[] tierCeilings\\n    );\\n    event SetAdjustment(\\n        uint256 currentBCV,\\n        uint256 increment,\\n        uint256 targetBCV,\\n        uint256 buffer\\n    );\\n    event BillInitialized(BillTerms billTerms, uint256 lastDecay);\\n    event TermsSet(PARAMETER parameter, uint input);\\n\\n    /* ======== STRUCTS ======== */\\n\\n    struct FeeTiers {\\n        uint256 tierCeilings; // principal billed till next tier\\n        uint256 fees; // in millionths (i.e. 1e4 = 1%)\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        uint256 rate; // increment\\n        uint256 target; // BCV when adjustment finished\\n        uint256 buffer; // minimum length (in seconds) between adjustments\\n        uint256 lastAdjustmentTimestamp; // timestamp when last adjustment made\\n    }\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    IERC20MetadataUpgradeable public payoutToken; // token paid for principal\\n    IERC20MetadataUpgradeable public principalToken; // inflow token\\n    ICustomTreasury public customTreasury; // pays for and receives principal\\n    address public feeTo; // receives fee\\n    address public DAO; // change feeTo address\\n    IBillNft public billNft;\\n    EnumerableSetUpgradeable.UintSet private billIssuedIds;\\n    IVestingCurve public vestingCurve;\\n\\n    uint256 public totalPrincipalBilled;\\n    uint256 public totalPayoutGiven;\\n\\n    BillTerms public terms; // stores terms for new bills\\n    Adjust public adjustment; // stores adjustment to BCV data\\n    FeeTiers[] public feeTiers; // stores fee tiers\\n\\n    mapping(uint256 => Bill) public billInfo; // stores bill information for nfts\\n    mapping(address => mapping(address => bool)) public redeemerApproved; // Stores user approved redeemers\\n\\n    uint256 public totalDebt; // total value of outstanding bills; used for pricing\\n    uint256 public lastDecay; // reference block for debt decay\\n\\n    bool public feeInPayout;\\n    uint256 public constant MAX_FEE = 1e6;\\n    uint256 public startVestingTimestamp;\\n\\n    /**\\n     * \\\"Storage gaps are a convention for reserving storage slots in a base contract, allowing future \\n     *  versions of that contract to use up those slots without affecting the storage layout of child contracts.\\\"\\n     *\\n     *  For more info, see \\\"Storage Gaps\\\" at https://docs.openzeppelin.com/ \\n     */\\n    uint256[50] private __gap;\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    function initialize(\\n        ICustomTreasury _customTreasury,\\n        BillCreationDetails memory _billCreationDetails,\\n        BillTerms memory _billTerms,\\n        BillAccounts memory _billAccounts\\n    ) public initializer {\\n        require(address(_customTreasury) != address(0), \\\"customTreasury cannot be zero\\\");\\n        customTreasury = _customTreasury;\\n        require(_billCreationDetails.payoutToken == _customTreasury.payoutToken());\\n        payoutToken = IERC20MetadataUpgradeable(_billCreationDetails.payoutToken);\\n        require(_billCreationDetails.principalToken != address(0), \\\"principalToken cannot be zero\\\");\\n        principalToken = IERC20MetadataUpgradeable(_billCreationDetails.principalToken);\\n        uint256 currentTimestamp = block.timestamp;\\n        if(address(_billCreationDetails.vestingCurve) == address(0)) {\\n            vestingCurve = new LinearVestingCurve();\\n        } else {\\n            /// @dev Validate vesting curve\\n            _billCreationDetails.vestingCurve.getVestedPayoutAtTime(1e18, 4000, currentTimestamp - 2000, currentTimestamp);\\n            vestingCurve = _billCreationDetails.vestingCurve;\\n        }\\n        require(_billAccounts.feeTo != address(0), \\\"feeTo cannot be zero\\\");\\n        feeTo = _billAccounts.feeTo;\\n        require(_billAccounts.DAO != address(0), \\\"DAO cannot be zero\\\");\\n        DAO = _billAccounts.DAO;\\n\\n        require(_billAccounts.billNft != address(0), \\\"billNft cannot be zero\\\");\\n        billNft = IBillNft(_billAccounts.billNft);\\n        require(_billCreationDetails.initialOwner != address(0), \\\"owner cannot be zero\\\");\\n        __Ownable_init();\\n        _transferOwnership(_billCreationDetails.initialOwner);\\n\\n        _setFeeTiers(_billCreationDetails.fees, _billCreationDetails.tierCeilings);\\n        feeInPayout = _billCreationDetails.feeInPayout;\\n\\n        require(\\n            _billCreationDetails.startVestingTimestamp > block.timestamp ||\\n                _billCreationDetails.startVestingTimestamp == 0,\\n            \\\"startVestingTimestamp cannot be in the past\\\"\\n        );\\n\\n        startVestingTimestamp = _billCreationDetails.startVestingTimestamp;\\n\\n        // Check and set billTerms\\n        require(currentDebt() == 0, \\\"Debt must be 0\\\" );\\n        require(_billTerms.vestingTerm >= 129600, \\\"Vesting must be >= 36 hours\\\");\\n        require(_billTerms.maxPayout <= 1000, \\\"Payout cannot be above 1 percent\\\");\\n        require(_billTerms.controlVariable > 0, \\\"CV must be above 1\\\");\\n\\n        terms = _billTerms;\\n\\n        totalDebt = _billTerms.initialDebt;\\n        lastDecay = currentTimestamp;\\n        emit BillInitialized(_billTerms, currentTimestamp);\\n    }\\n    \\n    /* ======== OWNER FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, MAX_PAYOUT, MAX_DEBT, MIN_PRICE, MAX_TOTAL_PAYOUT }\\n    /**\\n     *  @notice set parameters for new bills\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBillTerms(PARAMETER _parameter, uint256 _input)\\n        external\\n        onlyOwner\\n    {\\n        if (_parameter == PARAMETER.VESTING) {\\n            // 0\\n            require(_input >= 129600, \\\"Vesting must be >= 36 hours\\\");\\n            terms.vestingTerm = _input;\\n        } else if (_parameter == PARAMETER.MAX_PAYOUT) {\\n            // 1\\n            require(_input <= 1000, \\\"Payout cannot be above 1 percent\\\");\\n            terms.maxPayout = _input;\\n        } else if (_parameter == PARAMETER.MAX_DEBT) {\\n            // 2\\n            terms.maxDebt = _input;\\n        } else if (_parameter == PARAMETER.MIN_PRICE) {\\n            // 3\\n            terms.minimumPrice = _input;\\n        } else if (_parameter == PARAMETER.MAX_TOTAL_PAYOUT) {\\n            // 4\\n            require(_input >= totalPayoutGiven, \\\"maxTotalPayout cannot be below totalPayoutGiven\\\");\\n            terms.maxTotalPayout = _input;\\n        }\\n        emit TermsSet(_parameter, _input);\\n    }\\n\\n    /**\\n     *  @notice helper function to view the maxTotalPayout\\n     *  @dev backward compatibility for V1\\n     *  @return uint256 max amount of payoutTokens to offer\\n     */\\n    function getMaxTotalPayout() external view returns (uint256) {\\n        return terms.maxTotalPayout;\\n    }\\n\\n    /**\\n     *  @notice set the maxTotalPayout of payoutTokens\\n     *  @param _maxTotalPayout uint256 max amount of payoutTokens to offer\\n     */\\n    function setMaxTotalPayout(uint256 _maxTotalPayout) external onlyOwner {\\n        require(_maxTotalPayout >= totalPayoutGiven, \\\"maxTotalPayout <= totalPayout\\\");\\n        terms.maxTotalPayout = _maxTotalPayout;\\n        emit MaxTotalPayoutChanged(_maxTotalPayout);\\n    }\\n\\n    /**\\n     *  @notice Set fees based on totalPrincipalBilled\\n     *  @param fees Fee settings which corelate to the tierCeilings\\n     *  @param tierCeilings totalPrincipalBilled amount used to determine when to move to the next fee\\n     *\\n     *  Requirements\\n     *\\n     *  - tierCeilings MUST be in ascending order\\n     */\\n    function setFeeTiers(uint256[] memory fees, uint256[] memory tierCeilings) external onlyOwner {\\n        _setFeeTiers(fees, tierCeilings);\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _rate Amount to add to/subtract from the BCV to reach the target on each adjustment\\n     *  @param _target Final BCV to be adjusted to\\n     *  @param _buffer Time in seconds which must pass before the next incremental adjustment\\n     */\\n    function setAdjustment(\\n        uint256 _rate,\\n        uint256 _target,\\n        uint256 _buffer\\n    ) external onlyOwner {\\n        require(_target > 0, \\\"Target must be above 0\\\");\\n        /// @dev This is allowing a max price change of 3% per adjustment\\n        uint256 maxRate = (terms.controlVariable * 30) / 1000;\\n        if(maxRate == 0) maxRate = 1;\\n        require(\\n            _rate <= maxRate,\\n            \\\"Increment too large\\\"\\n        );\\n\\n        adjustment = Adjust({\\n            rate: _rate,\\n            target: _target,\\n            buffer: _buffer,\\n            /// @dev Subtracting _buffer to be able to run adjustment on next tx\\n            lastAdjustmentTimestamp: block.timestamp - _buffer\\n        });\\n        emit SetAdjustment(terms.controlVariable, _rate, _target, _buffer);\\n    }\\n\\n    /**\\n     *  @notice change address of Treasury\\n     *  @param _feeTo address\\n     */\\n    function changeFeeTo(address _feeTo) external {\\n        require(msg.sender == DAO, \\\"Only DAO\\\");\\n        require(_feeTo != address(0), \\\"Cannot be address(0)\\\");\\n        feeTo = _feeTo;\\n        emit FeeToChanged(feeTo);\\n    }\\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice Purchase a bill by depositing principalTokens\\n     *  @param _amount Amount of principalTokens to deposit/purchase a bill\\n     *  @param _maxPrice Max price willing to pay for for this deposit\\n     *  @param _depositor Address which will own the bill\\n     *  @return uint256 payout amount in payoutTokens\\n     * \\n     * Requirements\\n     * - Only Contracts can deposit on behalf of other accounts. Otherwise msg.sender MUST == _depositor.\\n     * - principalToken MUST NOT be a reflect token\\n     */\\n    function deposit(\\n        uint256 _amount,\\n        uint256 _maxPrice,\\n        address _depositor\\n    ) external nonReentrant returns (uint256) {\\n        require(_depositor != address(0), \\\"Invalid address\\\");\\n        require(msg.sender == _depositor || AddressUpgradeable.isContract(msg.sender), \\\"no deposits to other address\\\");\\n\\n        _decayDebt();\\n        uint256 truePrice = trueBillPrice();\\n        require(_maxPrice >= truePrice, \\\"Slippage more than max price\\\"); // slippage protection\\n        // Calculate payout and fee\\n        uint256 depositAmount = _amount;\\n        uint256 payout; \\n        uint256 fee;\\n        if(feeInPayout) {\\n            (payout, fee) = payoutFor(_amount); // payout and fee is computed\\n        } else {\\n            (payout, fee) = payoutFor(_amount); // payout and fee is computed\\n            depositAmount -= fee;\\n        }\\n        // Increase totalDebt by amount deposited\\n        totalDebt += _amount;\\n        require(totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\");\\n        require(payout >= 10 ** payoutToken.decimals() / 10000, \\\"Bill too small\\\" ); // must be > 0.0001 payout token ( underflow protection )\\n        require(payout <= maxPayout(), \\\"Bill too large\\\"); // size protection because there is no slippage\\n        totalPayoutGiven += payout; // total payout increased\\n        require(totalPayoutGiven <= terms.maxTotalPayout, \\\"Max total payout exceeded\\\");\\n        totalPrincipalBilled += depositAmount; // total billed increased\\n        // Transfer principal token to BillContract\\n        principalToken.safeTransferFrom(msg.sender, address(this), _amount);\\n        principalToken.approve(address(customTreasury), depositAmount);\\n        uint256 payoutBalanceBefore = payoutToken.balanceOf(address(this));\\n        if(feeInPayout) {\\n            // Deposits principal and receives payout tokens\\n            customTreasury.deposit_FeeInPayout(address(principalToken), depositAmount, payout, fee, feeTo);\\n        } else {\\n            // Deposits principal and receives payout tokens\\n            customTreasury.deposit(address(principalToken), depositAmount, payout);\\n            if(fee != 0) { // if fee, send to treasury\\n                principalToken.safeTransfer(feeTo, fee);\\n            }\\n        }\\n        uint256 payoutBalanceAdded = payoutToken.balanceOf(address(this)) - payoutBalanceBefore;\\n        // Create BillNFT\\n        uint256 billId = billNft.mint(_depositor, address(this));\\n\\n        uint256 vestingStartTimestamp = \\n        (startVestingTimestamp < block.timestamp)\\n            ? block.timestamp\\n            : startVestingTimestamp;\\n\\n        billInfo[billId] = Bill({\\n            payout: payoutBalanceAdded,\\n            payoutClaimed: 0,\\n            vesting: terms.vestingTerm,\\n            vestingTerm: terms.vestingTerm,\\n            vestingStartTimestamp: vestingStartTimestamp,\\n            lastClaimTimestamp: vestingStartTimestamp,\\n            truePricePaid: truePrice\\n        });\\n        billIssuedIds.add(billId);\\n        emit BillCreated(_amount, payoutBalanceAdded, block.timestamp + terms.vestingTerm, billId);\\n        // Adjust control variable\\n        _adjust();\\n        emit BillPriceChanged(_billPrice(), debtRatio());\\n        return payout;\\n    }\\n\\n    /**\\n     *  @notice Claim bill for user\\n     *  @dev Can only be redeemed by: Owner, BillNft or Approved Redeemer\\n     *  @param _billId uint256\\n     *  @return uint\\n     *\\n     * Requirements:\\n     *\\n     * - billId MUST be valid\\n     * - bill for billId MUST have a claimablePayout \\n     * - MUST be called by Owner, Approved Claimer of BillNft\\n     */\\n    function claim(uint256 _billId) external nonReentrant returns (uint256) {\\n        return _claim(_billId);\\n    }\\n\\n    /**\\n     *  @notice Claim multiple bills for user\\n     *  @param _billIds Array of billIds to claim\\n     *  @return payout Total payout claimed\\n     */\\n    function batchClaim(uint256[] calldata _billIds) public nonReentrant returns (uint256 payout) { \\n        uint256 length = _billIds.length;\\n        for (uint i = 0; i < length; i++) { \\n            payout += _claim(_billIds[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim bill for user\\n     *\\n     * See {CustomBill-claim}.\\n     */\\n    function _claim(uint256 _billId) internal returns (uint256) {\\n        Bill storage bill = billInfo[_billId];\\n        require(bill.lastClaimTimestamp > 0, \\\"not a valid bill id\\\");\\n        // verify claim approval\\n        address owner = billNft.ownerOf(_billId);\\n        require(msg.sender == owner || msg.sender == address(billNft) || redeemerApproved[owner][msg.sender], \\\"not approved\\\");\\n        // verify payout\\n        uint256 payout = claimablePayout(_billId);\\n        require(payout > 0, \\\"nothing to claim\\\");\\n        // adjust payout values\\n        bill.payoutClaimed += payout;\\n        // adjust vesting timestamps\\n        uint256 timeElapsed = block.timestamp - bill.lastClaimTimestamp;\\n        bill.vesting = timeElapsed >= bill.vesting ? 0 : bill.vesting - timeElapsed;\\n        bill.lastClaimTimestamp = block.timestamp;\\n        // transfer, emit and return payout\\n        payoutToken.safeTransfer(owner, payout);\\n        emit BillClaimed(_billId, owner, payout, bill.payout);\\n        return payout;\\n    }\\n\\n    /** \\n     *  @notice Allows or disallows a third party address to claim bills on behalf of user\\n     *  @dev Claims are ALWAYS sent to the owner, regardless of which account redeems \\n     *  @param approvedAccount Address of account which can claim on behalf of msg.sender\\n     *  @param approved Set approval state to true or false\\n     */\\n    function setClaimApproval(address approvedAccount, bool approved) external {\\n        redeemerApproved[msg.sender][approvedAccount] = approved;\\n        emit UpdateClaimApproval(msg.sender, approvedAccount, approved);\\n    }\\n\\n    /**\\n     * @dev See {CustomBill-claim}.\\n     * @notice Leaving for backward compatibility for V1\\n     */\\n    function redeem(uint256 _billId) external nonReentrant returns (uint256) {\\n        return _claim(_billId);\\n    }\\n\\n    /**\\n     * @dev See {CustomBill-batchClaim}.\\n     * @notice Leaving for backward compatibility for V1\\n     */\\n    function batchRedeem(uint256[] calldata _billIds) external returns (uint256 payout) { \\n        return batchClaim(_billIds);\\n    }\\n\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function _adjust() internal {\\n        uint256 timestampCanAdjust = adjustment.lastAdjustmentTimestamp + adjustment.buffer;\\n        if(adjustment.rate != 0 && block.timestamp >= timestampCanAdjust) {\\n            uint256 initial = terms.controlVariable;\\n            uint256 bcv = terms.controlVariable;\\n            uint256 rate = adjustment.rate;\\n            uint256 target = adjustment.target;\\n            if(bcv > target) {\\n                // Pulling bcv DOWN to target\\n                uint256 diff = bcv - target;\\n                if(diff > rate) {\\n                    bcv -= rate;\\n                } else {\\n                    bcv = target;\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                // Pulling bcv UP to target\\n                uint256 diff = target - bcv;\\n                if(diff > rate) {\\n                    bcv += rate;\\n                } else {\\n                    bcv = target;\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastAdjustmentTimestamp = block.timestamp;\\n            terms.controlVariable = bcv;\\n            emit ControlVariableAdjustment(initial, bcv, adjustment.rate);\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function _decayDebt() internal {\\n        totalDebt -= debtDecay();\\n        lastDecay = block.timestamp;\\n    }\\n\\n    /**\\n     *  @notice calculate current bill price and remove floor if above\\n     *  @return price_ uint Price is denominated with 18 decimals\\n     */\\n    function _billPrice() internal returns (uint256 price_) {\\n        price_ = billPrice();\\n        if (price_ > terms.minimumPrice && terms.minimumPrice != 0) {\\n            /// @dev minimumPrice is set to zero as it assumes that market equilibrium has been found at this point.\\n            /// Moving forward the price should find balance through natural market forces such as demand, arbitrage and others\\n            terms.minimumPrice = 0;\\n        } \\n    }\\n\\n    /**\\n     *  @notice Set fees based on totalPrincipalBilled\\n     *  @param fees Fee settings which corelate to the tierCeilings\\n     *  @param tierCeilings totalPrincipalBilled amount used to determine when to move to the next fee\\n     *\\n     *  Requirements\\n     *\\n     *  - tierCeilings MUST be in ascending order\\n     */\\n    function _setFeeTiers(uint256[] memory fees, uint256[] memory tierCeilings) internal {\\n        require(tierCeilings.length == fees.length, \\\"tier length != fee length\\\");\\n        // Remove old fees\\n        uint feeTiersLength = feeTiers.length;\\n        if(feeTiersLength > 0) {\\n            for (uint256 j; j < feeTiersLength; j++) {\\n                feeTiers.pop();\\n            }\\n        }\\n        // Validate and setup new FeeTiers\\n        uint256 previousCeiling;\\n        for (uint256 i; i < tierCeilings.length; i++) {\\n            require(fees[i] < MAX_FEE, \\\"Invalid fee\\\");\\n            require(i == 0 || previousCeiling < tierCeilings[i], \\\"only increasing order\\\");\\n            previousCeiling = tierCeilings[i];\\n            if(getFeeTierLength() > i) {\\n                /// @dev feeTiers.pop() appears to leave the first element\\n                feeTiers[i] = FeeTiers({tierCeilings: tierCeilings[i], fees: fees[i]});\\n            } else {\\n                feeTiers.push(FeeTiers({tierCeilings: tierCeilings[i], fees: fees[i]}));\\n            }\\n        }\\n        require(fees.length == getFeeTierLength(), \\\"feeTier mismatch\\\");\\n        emit SetFees(fees, tierCeilings);\\n    }\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice get bill info for given billId\\n     *  @param billId Id of the bill NFT\\n     *  @return Bill bill details\\n     */\\n    function getBillInfo(uint256 billId) external view returns (Bill memory) {\\n        return billInfo[billId];\\n    }\\n\\n    /**\\n     *  @notice calculate current bill premium\\n     *  @return price_ uint Price is denominated using 18 decimals\\n     */\\n    function billPrice() public view returns (uint256 price_) {\\n        /// @dev 1e2 * 1e(principalTokenDecimals) * 1e16 / 1e(principalTokenDecimals) = 1e18\\n        price_ = terms.controlVariable * debtRatio() * 1e16 / 10 ** principalToken.decimals();\\n        if (price_ < terms.minimumPrice) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate true bill price a user pays including the fee\\n     *  @return price_ uint\\n     */\\n    function trueBillPrice() public view returns (uint256 price_) {\\n        price_ = (billPrice() * MAX_FEE) / (MAX_FEE - currentFee());\\n    }\\n\\n    /**\\n     *  @notice determine maximum bill size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns (uint256) {\\n        return (payoutToken.totalSupply() * terms.maxPayout) / 100000;\\n    }\\n\\n    /**\\n     *  @notice calculate user's expected payout for given principal amount. \\n     *  @dev If feeInPayout flag is set, the _fee will be returned in payout tokens\\n     *  If feeInPayout flag is NOT set, the _fee will be returned in principal tokens  \\n     *  @param _amount uint Amount of principal tokens to deposit\\n     *  @return _payout uint Amount of payoutTokens given principal tokens \\n     *  @return _fee uint Fee is payout or principal tokens depending on feeInPayout flag\\n     */\\n    function payoutFor(uint256 _amount) public view returns (uint256 _payout, uint256 _fee) {\\n        if(feeInPayout) {\\n            // Using amount of principalTokens, find the amount of payout tokens by dividing by billPrice.\\n            uint256 total = customTreasury.valueOfToken(address(principalToken), _amount * 1e18) / billPrice();\\n            // _fee is denominated in payoutToken decimals\\n            _fee = total * currentFee() / MAX_FEE;\\n            _payout = total - _fee;\\n        } else { // feeInPrincipal\\n            // _fee is denominated in principalToken decimals\\n            _fee = _amount * currentFee() / MAX_FEE;\\n            // Using amount of principalTokens - _fee, find the amount of payout tokens by dividing by billPrice.\\n            _payout = customTreasury.valueOfToken(address(principalToken), (_amount - _fee) * 1e18) / billPrice();\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current ratio of debt to payout token supply\\n     *  @notice protocols using this system should be careful when quickly adding large %s to total supply\\n     *  @return debtRatio_ uint debtRatio denominated in principalToken decimals\\n     */\\n    function debtRatio() public view returns (uint256 debtRatio_) {\\n            debtRatio_ = currentDebt() * 10 ** payoutToken.decimals() / payoutToken.totalSupply();\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint currentDebt denominated in principalToken decimals\\n     */\\n    function currentDebt() public view returns (uint256) {\\n        return totalDebt - debtDecay();\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint debtDecay denominated in principalToken decimals\\n     */\\n    function debtDecay() public view returns (uint256 decay_) {\\n        if (terms.vestingTerm == 0)\\n            return totalDebt;\\n        uint256 timestampSinceLast = block.timestamp - lastDecay;\\n        decay_ = (totalDebt * timestampSinceLast) / terms.vestingTerm;\\n        if (decay_ > totalDebt) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n    /**\\n     *  @notice Returns the number of seconds left until fully vested.\\n     *  @dev backward compatibility for V1\\n     *  @param _billId ID of Bill\\n     *  @return pendingVesting_ Number of seconds until vestingEnd timestamp\\n     */\\n    function pendingVesting(uint256 _billId) external view returns (uint256 pendingVesting_) {\\n        ( , uint256 vestingEnd, ) = _billTimestamps(_billId);\\n        pendingVesting_ = 0;\\n        if(vestingEnd > block.timestamp) {\\n            pendingVesting_ = vestingEnd - block.timestamp;\\n        }\\n    }\\n\\n    /**\\n     *  @notice Returns the total payout left for the billId passed. (i.e. claimablePayout + vestingPayout)\\n     *  @dev backward compatibility for V1\\n     *  @param _billId ID of Bill \\n     *  @return pendingPayout_ uint Payout value still remaining in bill\\n     */\\n    function pendingPayout(uint256 _billId) external view returns (uint256 pendingPayout_) {\\n        ( , uint256 vestingPayoutCurrent, uint256 claimablePayoutCurrent) = _payoutsCurrent(_billId);\\n        pendingPayout_ = vestingPayoutCurrent + claimablePayoutCurrent;\\n    }\\n\\n    /**\\n     *  @notice Return the vesting start and end times for a Bill by ID\\n     *  @dev Helper function for ERC5725\\n     *  @param _billId ID of Bill\\n     */\\n    function vestingPeriod(uint256 _billId) public view returns (uint256 vestingStart_, uint256 vestingEnd_) {\\n        (vestingStart_, vestingEnd_, ) = _billTimestamps(_billId);\\n    }\\n\\n    /**\\n     *  @notice Return the amount of tokens locked in a Bill at the current block.timestamp\\n     *  @dev Helper function for ERC5725\\n     *  @param _billId ID of Bill\\n     */\\n    function vestingPayout(uint256 _billId) external view returns (uint256 vestingPayout_) {\\n        ( , vestingPayout_, ) = _payoutsCurrent(_billId);\\n    }\\n\\n    /**\\n     *  @notice Return the amount of tokens unlocked at a specific timestamp. Includes claimed tokens.\\n     *  @dev Helper function for ERC5725. \\n     *  @param _billId ID of Bill\\n     *  @param _timestamp timestamp to check\\n     */\\n    function vestedPayoutAtTime(uint256 _billId, uint256 _timestamp) external view returns (uint256 vestedPayout_) {\\n        (vestedPayout_, ,) = _payoutsAtTime(_billId, _timestamp);\\n    }\\n\\n    /**\\n     *  @notice Return the amount of payout tokens which are available to be claimed for a Bill.\\n     *  @dev Helper function for ERC5725. \\n     *  @param _billId ID of Bill\\n     */\\n    function claimablePayout(uint256 _billId) public view returns (uint256 claimablePayout_) {\\n        (,,claimablePayout_) = _payoutsCurrent(_billId);\\n    }\\n\\n    /**\\n     * @notice Calculate payoutsAtTime with current timestamp\\n     * @dev See {CustomBill-_payoutsAtTime}.\\n     */\\n    function _payoutsCurrent(uint256 _billId) internal view returns (uint256 vestedPayout_, uint256 vestingPayout_, uint256 claimablePayout_) {\\n        return _payoutsAtTime(_billId, block.timestamp);\\n    }\\n    \\n    /**\\n     *  @notice Return the amount of tokens unlocked at a specific timestamp. Includes claimed tokens.\\n     *  @dev Helper function for ERC5725. \\n     *  @param _billId ID of Bill\\n     *  @param _timestamp timestamp to check\\n     */\\n    function _payoutsAtTime(uint256 _billId, uint256 _timestamp) \\n        internal \\n        view\\n        returns (uint256 vestedPayout_, uint256 vestingPayout_, uint256 claimablePayout_) \\n    {\\n        Bill memory bill = billInfo[_billId];\\n        // Calculate vestedPayout\\n        uint256 fullPayout = bill.payout;\\n        vestedPayout_ = vestingCurve.getVestedPayoutAtTime(\\n            fullPayout, \\n            bill.vestingTerm, \\n            bill.vestingStartTimestamp, \\n            _timestamp\\n        );\\n        // Calculate vestingPayout\\n        vestingPayout_ = fullPayout - vestedPayout_;\\n        // Calculate claimablePayout\\n        uint256 payoutClaimed = bill.payoutClaimed;\\n        claimablePayout_ = 0;\\n        if(payoutClaimed < vestedPayout_) {\\n            claimablePayout_ = vestedPayout_ - payoutClaimed;\\n        }\\n    }\\n\\n    function _billTimestamps(uint256 _billId) internal view returns (uint256 vestingStart_, uint256 vestingEnd_, uint256 lastClaimTimestamp_) {\\n        Bill memory bill = billInfo[_billId];\\n        vestingStart_ = bill.vestingStartTimestamp;\\n        vestingEnd_ = vestingStart_ + bill.vestingTerm;\\n        lastClaimTimestamp_ = bill.lastClaimTimestamp;\\n    }\\n\\n    /**\\n     *  @notice calculate all billNft ids for sender\\n     *  @return billNftIds uint[]\\n     */\\n    function userBillIds()\\n        external\\n        view\\n        returns (uint[] memory)\\n    {\\n        return getBillIds(msg.sender);\\n    }\\n\\n    /**\\n     *  @notice calculate all billNft ids for user\\n     *  @return billNftIds uint[]\\n     */\\n    function getBillIds(address user)\\n        public\\n        view\\n        returns (uint[] memory)\\n    {\\n        uint balance = billNft.balanceOf(user);\\n        return getBillIdsInRange(user, 0, balance);\\n    }\\n\\n    /**\\n     *  @notice calculate billNft ids in range for user\\n     *  @return billNftIds uint[]\\n     */\\n    function getBillIdsInRange(address user, uint256 start, uint256 end)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory result = new uint[](end - start);\\n        uint256 resultIndex = 0;\\n        for (uint256 i = start; i < end; i++) {\\n            uint256 tokenId = billNft.tokenOfOwnerByIndex(user, i);\\n            if (billIssuedIds.contains(tokenId)) {\\n                result[resultIndex] = tokenId;\\n                resultIndex++;\\n            }\\n        }\\n        // Prune results into condensed array\\n        uint256[] memory prunedResult = new uint256[](resultIndex);\\n        for (uint256 j = 0; j < resultIndex; j++) {\\n            prunedResult[j] = result[j];\\n        }\\n        return prunedResult;\\n    }\\n\\n    /**\\n     *  @notice current fee taken of each bill\\n     *  @return currentFee_ uint\\n     */\\n    function currentFee() public view returns (uint256 currentFee_) {\\n        uint256 tierLength = feeTiers.length;\\n        for (uint256 i; i < tierLength; i++) {\\n            if (\\n                totalPrincipalBilled <= feeTiers[i].tierCeilings ||\\n                i == tierLength - 1\\n            ) {\\n                return feeTiers[i].fees;\\n            }\\n        }\\n    }\\n\\n    /**\\n     *  @notice Get the number of fee tiers configured\\n     *  @return tierLength_ uint\\n     */\\n    function getFeeTierLength() public view returns (uint256 tierLength_) {\\n        tierLength_ = feeTiers.length;\\n    }\\n\\n    /**\\n     * From EnumerableSetUpgradeable...\\n     * \\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function allIssuedBillIds() external view returns (uint256[] memory) {\\n        return billIssuedIds.values();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CustomBillRefillable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/*\\n  ______                     ______                                 \\n /      \\\\                   /      \\\\                                \\n|  \u2593\u2593\u2593\u2593\u2593\u2593\\\\ ______   ______ |  \u2593\u2593\u2593\u2593\u2593\u2593\\\\__   __   __  ______   ______  \\n| \u2593\u2593__| \u2593\u2593/      \\\\ /      \\\\| \u2593\u2593___\\\\\u2593\u2593  \\\\ |  \\\\ |  \\\\|      \\\\ /      \\\\ \\n| \u2593\u2593    \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\\\\  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\\\\u2593\u2593    \\\\| \u2593\u2593 | \u2593\u2593 | \u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\  \u2593\u2593\u2593\u2593\u2593\u2593\\\\\\n| \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593  | \u2593\u2593 \u2593\u2593    \u2593\u2593_\\\\\u2593\u2593\u2593\u2593\u2593\u2593\\\\ \u2593\u2593 | \u2593\u2593 | \u2593\u2593/      \u2593\u2593 \u2593\u2593  | \u2593\u2593\\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593__/ \u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\\__| \u2593\u2593 \u2593\u2593_/ \u2593\u2593_/ \u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593__/ \u2593\u2593\\n| \u2593\u2593  | \u2593\u2593 \u2593\u2593    \u2593\u2593\\\\\u2593\u2593     \\\\\\\\\u2593\u2593    \u2593\u2593\\\\\u2593\u2593   \u2593\u2593   \u2593\u2593\\\\\u2593\u2593    \u2593\u2593 \u2593\u2593    \u2593\u2593\\n \\\\\u2593\u2593   \\\\\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\\\\u2593\u2593\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\\\\\u2593\u2593\u2593\u2593  \\\\\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593 \\n         | \u2593\u2593                                             | \u2593\u2593      \\n         | \u2593\u2593                                             | \u2593\u2593      \\n          \\\\\u2593\u2593                                              \\\\\u2593\u2593         \\n * App:             https://ApeSwap.finance\\n * Medium:          https://ape-swap.medium.com\\n * Twitter:         https://twitter.com/ape_swap\\n * Telegram:        https://t.me/ape_swap\\n * Announcements:   https://t.me/ape_swap_news\\n * Discord:         https://ApeSwap.click/discord\\n * Reddit:          https://reddit.com/r/ApeSwap\\n * Instagram:       https://instagram.com/ApeSwap.finance\\n * GitHub:          https://github.com/ApeSwapFinance\\n */\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\\\";\\nimport \\\"./interfaces/ICustomBillRefillable.sol\\\";\\nimport \\\"./CustomBill.sol\\\";\\n\\n/// @title CustomBillRefillable\\n/// @author ApeSwap.Finance\\n/// @notice Provides a method of refilling CustomBill contracts without needing owner rights\\n/// @dev Extends CustomBill\\ncontract CustomBillRefillable is ICustomBillRefillable, CustomBill, AccessControlEnumerableUpgradeable {\\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\\n    \\n    event BillRefilled(address payoutToken, uint256 amountAdded);\\n\\n    bytes32 public constant REFILL_ROLE = keccak256(\\\"REFILL_ROLE\\\");\\n\\n    function initialize(\\n        ICustomTreasury _customTreasury,\\n        BillCreationDetails memory _billCreationDetails,\\n        BillTerms memory _billTerms,\\n        BillAccounts memory _billAccounts,\\n        address[] memory _billRefillers\\n    ) external {\\n        super.initialize(\\n            _customTreasury,\\n            _billCreationDetails,\\n            _billTerms,\\n            _billAccounts\\n        );\\n\\n        for (uint i = 0; i < _billRefillers.length; i++) {\\n            _grantRole(REFILL_ROLE, _billRefillers[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Grant the ability to refill the CustomBill to whitelisted addresses\\n     * @param _billRefillers Array of addresses to whitelist as bill refillers\\n     */\\n    function grantRefillRole(address[] calldata _billRefillers) external override onlyOwner {\\n        for (uint i = 0; i < _billRefillers.length; i++) {\\n            _grantRole(REFILL_ROLE, _billRefillers[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Revoke the ability to refill the CustomBill to whitelisted addresses\\n     * @param _billRefillers Array of addresses to revoke as bill refillers\\n     */\\n    function revokeRefillRole(address[] calldata _billRefillers) external override onlyOwner {\\n        for (uint i = 0; i < _billRefillers.length; i++) {\\n            _revokeRole(REFILL_ROLE, _billRefillers[i]);\\n        }\\n    }\\n\\n    /**\\n     *  @notice Transfer payoutTokens from sender to customTreasury and update maxTotalPayout\\n     *  @param _refillAmount amount of payoutTokens to refill the CustomBill with \\n     */\\n    function refillPayoutToken(uint256 _refillAmount) external override nonReentrant onlyRole(REFILL_ROLE) {\\n        require(_refillAmount > 0, \\\"Amount is 0\\\");\\n        require(customTreasury.billContract(address(this)), \\\"Bill is disabled\\\");\\n        uint256 balanceBefore = payoutToken.balanceOf(address(customTreasury));\\n        payoutToken.safeTransferFrom(msg.sender, address(customTreasury), _refillAmount);\\n        uint256 refillAmount = payoutToken.balanceOf(address(customTreasury)) - balanceBefore;\\n        require(refillAmount > 0, \\\"No refill made\\\");\\n        uint256 maxTotalPayout = terms.maxTotalPayout + refillAmount;\\n        terms.maxTotalPayout = maxTotalPayout;\\n        emit BillRefilled(address(payoutToken), refillAmount);\\n        emit MaxTotalPayoutChanged(maxTotalPayout);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBillNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\nimport \\\"./IERC5725.sol\\\";\\n\\ninterface IBillNft is IERC5725, IERC721EnumerableUpgradeable {\\n    struct TokenData {\\n        uint256 tokenId;\\n        address billAddress;\\n    }\\n\\n    function addMinter(address minter) external;\\n\\n    function mint(address to, address billAddress) external returns (uint256);\\n\\n    function mintMany(uint256 amount, address to, address billAddress) external;\\n\\n    function lockURI() external;\\n\\n    function setTokenURI(uint256 tokenId, string memory _tokenURI) external;\\n\\n    function claimMany(uint256[] calldata _tokenIds) external;\\n\\n    function pendingPayout(uint256 tokenId) external view returns (uint256 pendingPayoutAmount);\\n\\n    function pendingVesting(uint256 tokenId) external view returns (uint256 pendingSeconds);\\n\\n    function allTokensDataOfOwner(address owner) external view returns (TokenData[] memory);\\n\\n    function getTokensOfOwnerByIndexes(address owner, uint256 start, uint256 end) external view returns (TokenData[] memory);\\n\\n    function tokenDataOfOwnerByIndex(address owner, uint256 index) external view returns (TokenData memory tokenData);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICustomBill.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"./ICustomTreasury.sol\\\";\\nimport \\\"./IVestingCurve.sol\\\";\\n\\ninterface ICustomBill {\\n    /// @notice Info for bill holder\\n    /// @param payout Total payout value\\n    /// @param payoutClaimed Amount of payout claimed\\n    /// @param vesting Seconds left until vesting is complete\\n    /// @param vestingTerm Length of vesting in seconds\\n    /// @param vestingStartTimestamp Timestamp at start of vesting\\n    /// @param lastClaimTimestamp Last timestamp interaction\\n    /// @param truePricePaid Price paid (principal tokens per payout token) in ten-millionths - 4000000 = 0.4\\n    struct Bill {\\n        uint256 payout; \\n        uint256 payoutClaimed;\\n        uint256 vesting;\\n        uint256 vestingTerm; \\n        uint256 vestingStartTimestamp;\\n        uint256 lastClaimTimestamp; \\n        uint256 truePricePaid; \\n    }\\n\\n    struct BillCreationDetails {\\n        address payoutToken;\\n        address principalToken;\\n        address initialOwner;\\n        IVestingCurve vestingCurve;\\n        uint256[] tierCeilings;\\n        uint256[] fees;\\n        uint256 startVestingTimestamp;\\n        bool feeInPayout;\\n    }\\n\\n    struct BillTerms {\\n        uint256 controlVariable;\\n        uint256 vestingTerm;\\n        uint256 minimumPrice;\\n        uint256 maxPayout;\\n        uint256 maxDebt;\\n        uint256 maxTotalPayout;\\n        uint256 initialDebt;\\n    }\\n\\n    /// @notice Important accounts related to a CustomBill \\n    /// @param feeTo Account which receives the bill fees\\n    /// @param DAO Account used to change the treasury address\\n    /// @param billNft BillNFT contract which mints the NFTs\\n    struct BillAccounts {\\n        address feeTo;\\n        address DAO;\\n        address billNft;\\n    }\\n\\n    function initialize(\\n        ICustomTreasury _customTreasury,\\n        BillCreationDetails memory _billCreationDetails,\\n        BillTerms memory _billTerms,\\n        BillAccounts memory _billAccounts\\n    ) external;\\n\\n    function customTreasury() external returns (ICustomTreasury);\\n\\n    function claim(uint256 billId) external returns (uint256);\\n\\n    function pendingVesting(uint256 billId) external view returns (uint256);\\n\\n    function pendingPayout(uint256 billId) external view returns (uint256);\\n\\n    function vestingPeriod(uint256 billId) external view returns (uint256 vestingStart_, uint256 vestingEnd_);\\n\\n    function vestingPayout(uint256 billId) external view returns (uint256 vestingPayout_);\\n\\n    function vestedPayoutAtTime(uint256 billId, uint256 timestamp) external view returns (uint256 vestedPayout_);\\n\\n    function claimablePayout(uint256 billId) external view returns (uint256 claimablePayout_);\\n\\n    function payoutToken() external view returns (IERC20MetadataUpgradeable);\\n    \\n    function principalToken() external view returns (IERC20MetadataUpgradeable);\\n\\n    function getBillInfo(uint256 billId) external view returns (Bill memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICustomBillRefillable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./ICustomBill.sol\\\";\\n\\ninterface ICustomBillRefillable is ICustomBill {\\n    function initialize(\\n        ICustomTreasury _customTreasury,\\n        BillCreationDetails memory _billCreationDetails,\\n        BillTerms memory _billTerms,\\n        BillAccounts memory _billAccounts,\\n        address[] memory _billRefillers\\n    ) external;\\n\\n    function refillPayoutToken(uint256 _refillAmount) external;\\n\\n    function grantRefillRole(address[] calldata _billRefillers) external;\\n\\n    function revokeRefillRole(address[] calldata _billRefillers) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICustomTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\ninterface ICustomTreasury {\\n    function deposit(\\n        address _principalTokenAddress,\\n        uint256 _amountPrincipalToken,\\n        uint256 _amountPayoutToken\\n    ) external;\\n\\n    function deposit_FeeInPayout(\\n        address _principalTokenAddress,\\n        uint256 _amountPrincipalToken,\\n        uint256 _amountPayoutToken,\\n        uint256 _feePayoutToken,\\n        address _feeReceiver\\n    ) external;\\n\\n    function initialize(address _payoutToken, address _initialOwner, address _payoutAddress) external;\\n\\n    function valueOfToken(address _principalTokenAddress, uint256 _amount)\\n        external\\n        view\\n        returns (uint256 value_);\\n\\n   function payoutToken()\\n        external\\n        view\\n        returns (address token);\\n    \\n    function sendPayoutTokens(uint _amountPayoutToken) external;\\n\\n    function billContract(address _billContract) external returns (bool _isEnabled);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC5725.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Non-Fungible Vesting Token Standard\\n * @notice A non-fungible token standard used to vest ERC-20 tokens over a vesting release curve\\n *  scheduled using timestamps.\\n * @dev Because this standard relies on timestamps for the vesting schedule, it's important to keep track of the\\n *  tokens claimed per Vesting NFT so that a user cannot withdraw more tokens than alloted for a specific Vesting NFT.\\n */\\ninterface IERC5725 {\\n    /**\\n     *  This event is emitted when the payout is claimed through the claim function\\n     *  @param tokenId the NFT tokenId of the assets being claimed.\\n     *  @param recipient The address which is receiving the payout.\\n     *  @param claimAmount The amount of tokens being claimed.\\n     */\\n    event PayoutClaimed(uint256 indexed tokenId, address indexed recipient, uint256 claimAmount);\\n\\n    /**\\n     * @notice Claim the pending payout for the NFT\\n     * @dev MUST grant the claimablePayout value at the time of claim being called\\n     * MUST revert if not called by the token owner or approved users\\n     * MUST emit PayoutClaimed\\n     * SHOULD revert if there is nothing to claim\\n     * @param tokenId The NFT token id\\n     */\\n    function claim(uint256 tokenId) external;\\n\\n    /**\\n     * @notice Number of tokens for the NFT which have been claimed at the current timestamp\\n     * @param tokenId The NFT token id\\n     * @return payout The total amount of payout tokens claimed for this NFT\\n     */\\n    function claimedPayout(uint256 tokenId) external view returns (uint256 payout);\\n\\n    /**\\n     * @notice Number of tokens for the NFT which can be claimed at the current timestamp\\n     * @dev It is RECOMMENDED that this is calculated as the `vestedPayout()` subtracted from `payoutClaimed()`.\\n     * @param tokenId The NFT token id\\n     * @return payout The amount of unlocked payout tokens for the NFT which have not yet been claimed\\n     */\\n    function claimablePayout(uint256 tokenId) external view returns (uint256 payout);\\n\\n    /**\\n     * @notice Total amount of tokens which have been vested at the current timestamp.\\n     *   This number also includes vested tokens which have been claimed.\\n     * @dev It is RECOMMENDED that this function calls `vestedPayoutAtTime` with\\n     *   `block.timestamp` as the `timestamp` parameter.\\n     * @param tokenId The NFT token id\\n     * @return payout Total amount of tokens which have been vested at the current timestamp.\\n     */\\n    function vestedPayout(uint256 tokenId) external view returns (uint256 payout);\\n\\n    /**\\n     * @notice Total amount of vested tokens at the provided timestamp.\\n     *   This number also includes vested tokens which have been claimed.\\n     * @dev `timestamp` MAY be both in the future and in the past.\\n     * Zero MUST be returned if the timestamp is before the token was minted.\\n     * @param tokenId The NFT token id\\n     * @param timestamp The timestamp to check on, can be both in the past and the future\\n     * @return payout Total amount of tokens which have been vested at the provided timestamp\\n     */\\n    function vestedPayoutAtTime(uint256 tokenId, uint256 timestamp) external view returns (uint256 payout);\\n\\n    /**\\n     * @notice Number of tokens for an NFT which are currently vesting.\\n     * @dev The sum of vestedPayout and vestingPayout SHOULD always be the total payout.\\n     * @param tokenId The NFT token id\\n     * @return payout The number of tokens for the NFT which are vesting until a future date.\\n     */\\n    function vestingPayout(uint256 tokenId) external view returns (uint256 payout);\\n\\n    /**\\n     * @notice The start and end timestamps for the vesting of the provided NFT\\n     * MUST return the timestamp where no further increase in vestedPayout occurs for `vestingEnd`.\\n     * @param tokenId The NFT token id\\n     * @return vestingStart The beginning of the vesting as a unix timestamp\\n     * @return vestingEnd The ending of the vesting as a unix timestamp\\n     */\\n    function vestingPeriod(uint256 tokenId) external view returns (uint256 vestingStart, uint256 vestingEnd);\\n\\n    /**\\n     * @notice Token which is used to pay out the vesting claims\\n     * @param tokenId The NFT token id\\n     * @return token The token which is used to pay out the vesting claims\\n     */\\n    function payoutToken(uint256 tokenId) external view returns (address token);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVestingCurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.17;\\n\\n/// @notice VestingCurve interface to allow for simple updates of vesting release schedules.\\ninterface IVestingCurve {\\n    /**\\n     * @notice Returns the vested token amount given the inputs below.\\n     * @param totalPayout Total payout vested once the vestingTerm is up\\n     * @param vestingTerm Length of time in seconds that tokens are vesting for\\n     * @param startTimestamp The timestamp of when vesting starts\\n     * @param checkTimestamp The timestamp to calculate vested tokens\\n     * @return vestedPayout Total payoutTokens vested at checkTimestamp\\n     *\\n     * Requirements\\n     * - MUST return 0 if checkTimestamp is less than startTimestamp\\n     * - MUST return totalPayout if checkTimestamp is greater than startTimestamp + vestingTerm,\\n     * - MUST return a value including or between 0 and totalPayout\\n     */\\n    function getVestedPayoutAtTime(\\n        uint256 totalPayout,\\n        uint256 vestingTerm,\\n        uint256 startTimestamp,\\n        uint256 checkTimestamp\\n    ) external view returns (uint256 vestedPayout);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"billId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"BillClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"billId\",\"type\":\"uint256\"}],\"name\":\"BillCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialDebt\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ICustomBill.BillTerms\",\"name\":\"billTerms\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastDecay\",\"type\":\"uint256\"}],\"name\":\"BillInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"internalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debtRatio\",\"type\":\"uint256\"}],\"name\":\"BillPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"}],\"name\":\"BillRefilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"name\":\"ControlVariableAdjustment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"FeeToChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxTotalPayout\",\"type\":\"uint256\"}],\"name\":\"MaxTotalPayoutChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buffer\",\"type\":\"uint256\"}],\"name\":\"SetAdjustment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tierCeilings\",\"type\":\"uint256[]\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"SetPendingOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum CustomBill.PARAMETER\",\"name\":\"parameter\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"TermsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approvedAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"UpdateClaimApproval\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFILL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjustment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAdjustmentTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allIssuedBillIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_billIds\",\"type\":\"uint256[]\"}],\"name\":\"batchClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_billIds\",\"type\":\"uint256[]\"}],\"name\":\"batchRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"billInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"truePricePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"billNft\",\"outputs\":[{\"internalType\":\"contract IBillNft\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"billPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"changeFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"claimablePayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimablePayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentFee_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customTreasury\",\"outputs\":[{\"internalType\":\"contract ICustomTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"decay_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInPayout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeTiers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tierCeilings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBillIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getBillIdsInRange\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"billId\",\"type\":\"uint256\"}],\"name\":\"getBillInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"truePricePaid\",\"type\":\"uint256\"}],\"internalType\":\"struct ICustomBill.Bill\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeTierLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tierLength_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTotalPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_billRefillers\",\"type\":\"address[]\"}],\"name\":\"grantRefillRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICustomTreasury\",\"name\":\"_customTreasury\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"contract IVestingCurve\",\"name\":\"vestingCurve\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tierCeilings\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"startVestingTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"feeInPayout\",\"type\":\"bool\"}],\"internalType\":\"struct ICustomBill.BillCreationDetails\",\"name\":\"_billCreationDetails\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct ICustomBill.BillTerms\",\"name\":\"_billTerms\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"DAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"billNft\",\"type\":\"address\"}],\"internalType\":\"struct ICustomBill.BillAccounts\",\"name\":\"_billAccounts\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICustomTreasury\",\"name\":\"_customTreasury\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"payoutToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"principalToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"contract IVestingCurve\",\"name\":\"vestingCurve\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tierCeilings\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"startVestingTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"feeInPayout\",\"type\":\"bool\"}],\"internalType\":\"struct ICustomBill.BillCreationDetails\",\"name\":\"_billCreationDetails\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialDebt\",\"type\":\"uint256\"}],\"internalType\":\"struct ICustomBill.BillTerms\",\"name\":\"_billTerms\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"DAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"billNft\",\"type\":\"address\"}],\"internalType\":\"struct ICustomBill.BillAccounts\",\"name\":\"_billAccounts\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_billRefillers\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"payoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutToken\",\"outputs\":[{\"internalType\":\"contract IERC20MetadataUpgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"pendingPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingPayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"pendingVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingVesting_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalToken\",\"outputs\":[{\"internalType\":\"contract IERC20MetadataUpgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemerApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refillAmount\",\"type\":\"uint256\"}],\"name\":\"refillPayoutToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_billRefillers\",\"type\":\"address[]\"}],\"name\":\"revokeRefillRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"setAdjustment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CustomBill.PARAMETER\",\"name\":\"_parameter\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"setBillTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approvedAccount\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setClaimApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tierCeilings\",\"type\":\"uint256[]\"}],\"name\":\"setFeeTiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTotalPayout\",\"type\":\"uint256\"}],\"name\":\"setMaxTotalPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startVestingTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTotalPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayoutGiven\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPrincipalBilled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trueBillPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userBillIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"vestedPayoutAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestedPayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingCurve\",\"outputs\":[{\"internalType\":\"contract IVestingCurve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"vestingPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingPayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_billId\",\"type\":\"uint256\"}],\"name\":\"vestingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vestingStart_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingEnd_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CustomBillRefillable", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}