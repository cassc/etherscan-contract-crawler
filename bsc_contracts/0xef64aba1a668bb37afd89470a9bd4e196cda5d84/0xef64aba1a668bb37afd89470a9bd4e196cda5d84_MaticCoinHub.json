{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n \r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n         require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\r\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\r\n * be specified by overriding the virtual {_implementation} function.\r\n * \r\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\r\n * different contract through the {_delegate} function.\r\n * \r\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Delegates the current call to `implementation`.\r\n     * \r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\r\n     * and {_fallback} should delegate.\r\n     */\r\n    function _implementation() internal virtual view returns (address);\r\n\r\n    /**\r\n     * @dev Delegates the current call to the address returned by `_implementation()`.\r\n     * \r\n     * This function does not return to its internall call site, it will return directly to the external caller.\r\n     */\r\n    function _fallback() internal {\r\n        _beforeFallback();\r\n        _delegate(_implementation());\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\r\n     * function in the contract matches the call data.\r\n     */\r\n    fallback () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\r\n     * is empty.\r\n     */\r\n    receive () payable external {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\r\n     * call, or as part of the Solidity `fallback` or `receive` functions.\r\n     * \r\n     * If overriden should call `super._beforeFallback()`.\r\n     */\r\n    function _beforeFallback() internal virtual {\r\n    }\r\n}\r\n\r\ncontract MaticCoinHub is Proxy {\r\n    \r\n    address public impl;\r\n    address public contractOwner;\r\n\r\n    modifier onlyContractOwner() { \r\n        require(msg.sender == contractOwner); \r\n        _; \r\n    }\r\n\r\n    constructor(address _impl) public {\r\n        impl = _impl;\r\n        contractOwner = msg.sender;\r\n    }\r\n    \r\n    function update(address newImpl) public onlyContractOwner {\r\n        impl = newImpl;\r\n    }\r\n\r\n    function removeOwnership() public onlyContractOwner {\r\n        contractOwner = address(0);\r\n    }\r\n    \r\n    function _implementation() internal override view returns (address) {\r\n        return impl;\r\n    }\r\n}\r\n\r\n\r\ncontract SmartMaticCoinHubBasic {\r\n\r\n    address public impl;\r\n    address public contractOwner;\r\n    uint256 public Joining_amount;\r\n    uint256 public cycleDays;\r\n    uint256 public enableTrigger;\r\n     \r\n\r\n    struct UserInfo {\r\n        uint256 id;\r\n        address sponsor;\r\n        uint256 directs;\r\n        uint256 directBusiness;\r\n        uint256 totalDeposit;\r\n        uint256 maxDeposit;\r\n        uint256 openLevel;\r\n        uint256 teamNum;\r\n        uint256 teamBusiness;\r\n        uint256 balance;  \r\n        uint256 wallet70;  \r\n        uint256 wallet30;  \r\n        uint256 orderCount;\r\n              \r\n        bool status;        \r\n\r\n    }\r\n    struct teamBusiness{\r\n        uint256 maxLeg;\r\n    }\r\n    \r\n    uint256 public total_orders;\r\n\r\n    struct order {\r\n        uint256 id;        \r\n        uint256 amount;\r\n        uint256 cycle;\r\n        uint256 lastClaim;\r\n        uint256 nextClaim;\r\n        uint256 claimed;\r\n        bool status;\r\n    }\r\n\r\n    struct reward{\r\n        bool leader;\r\n        bool grand;\r\n        bool DLeader;\r\n        uint32 timestamp;\r\n    }\r\n    struct income{\r\n        uint256 roi;\r\n        uint256 level;\r\n        uint256 thclub;\r\n        uint256 leader;\r\n        uint256 grand;\r\n        uint256 DLeader;\r\n        uint256 freeze;\r\n        uint256 minor;\r\n        bool income_status; \r\n\r\n    }\r\n\r\n    struct Trigger{\r\n        uint256 max_val;\r\n        uint256 min_val;\r\n        uint256 active_amnt;\r\n        bool status;\r\n        bool isHit;    \r\n    }\r\n\r\n    struct UserTrigger{\r\n\r\n        uint256 directBusins;\r\n        uint256 direct1Busins;\r\n        bool trigger_status;\r\n    }\r\n\r\n\r\n    mapping(address=>teamBusiness) public business;\r\n    mapping(address=>income) public incomes;\r\n    mapping(address=>reward) public rewardStatus;\r\n    mapping(uint256=>Trigger) public triggers;\r\n    mapping(address=>mapping(uint256=>UserTrigger)) public usertriggers;\r\n\r\n    address[] public leader;\r\n    uint256 public leader_payout;\r\n    address[] public grand;\r\n    uint256 public grand_payout;\r\n    address[] public DLeader;\r\n    uint256 public DLeader_payout;\r\n    //address[] public thclub;\r\n    uint256 public thclub_payout;\r\n\r\n\r\n    mapping(uint256=>address[]) public thclub;\r\n    mapping(address=>mapping(uint256=>order)) public orders;\r\n\r\n    mapping(address=>UserInfo) public userInfo;    \r\n    mapping(address => address[]) public directTeam;     \r\n    mapping(address => mapping(uint256 =>address[])) public genTeam;       \r\n    mapping(uint => address) public idToAddress;    \r\n\r\n    uint public total_users;     \r\n    \r\n    IERC20 public depositToken;\r\n\r\n    uint256[] public level_income;\r\n\r\n    uint256 public baseDiv;\r\n\r\n    // Each member will have a unique ID assigned to them\r\n    //uint256 public memberCount = 0;\r\n    struct dailyBusiness{\r\n        uint256 business;\r\n        uint256 directs;\r\n        bool status;\r\n    }\r\n\r\n    uint256 public  baseDivider;\r\n    uint256[] public balDown ;\r\n    uint256[] public balDownRate ; \r\n    uint256[] public balRecover ;\r\n    mapping(uint256=>bool) public balStatus; \r\n    bool public isFreezeReward;\r\n    address[] public creaters; \r\n\r\n    mapping(address=>uint256) public createrWallet;\r\n    mapping(address => mapping(uint256=>dailyBusiness)) public daily;\r\n\r\n    event TeamAdd(address indexed user,address indexed added_user,uint256 indexed level);\r\n    event Withdrawal(address indexed user,uint256 indexed amount);\r\n    event Income(address indexed user,string indexed incometype,uint256 amount);\r\n    event Statics(address indexed user,address indexed tx_user,string indexed tx_type,uint256 amount,uint256 level);\r\n\r\n}\r\n\r\ncontract SmartMaticCoinHub is SmartMaticCoinHubBasic {\r\n    \r\n    \r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    modifier onlyContractOwner() { \r\n        require(msg.sender == contractOwner, \"onlyOwner\"); \r\n        _; \r\n    }\r\n    modifier notRegistered() { \r\n        require(userInfo[msg.sender].id == 0, \"Already Registered\"); \r\n        _; \r\n    }\r\n    \r\n    modifier Registered() { \r\n        require(userInfo[msg.sender].id > 0, \"Not Registered\"); \r\n        _; \r\n    }\r\n    uint256 public thdays;\r\n    uint256 public startTime;\r\n    \r\n    function init(IERC20 _tkn,address[] memory createrss) public onlyContractOwner {\r\n        startTime = uint256(block.timestamp);\r\n        Joining_amount = 25e18;\r\n        depositToken = _tkn;\r\n        cycleDays = 10 days;\r\n        thdays = 1 days;\r\n        \r\n        creaters.push(createrss[0]); \r\n        creaters.push(createrss[1]); \r\n        creaters.push(createrss[2]); \r\n\r\n        level_income = [800,200,200,200,200,100,100,100,100,100,75,75,75,75,75,50,50,50,50,50,50,50,50,50,50];\r\n        baseDiv = 10000;\r\n        baseDivider = 10000;\r\n        total_users++;\r\n        idToAddress[total_users] =msg.sender;\r\n        userInfo[msg.sender].id=total_users;        \r\n        userInfo[msg.sender].sponsor=address(this);\r\n        userInfo[msg.sender].maxDeposit = 2500e18;\r\n        userInfo[msg.sender].totalDeposit = 2500e18;\r\n        userInfo[msg.sender].status = true;\r\n        incomes[msg.sender].income_status = true;\r\n\r\n        leader.push(msg.sender);\r\n        grand.push(msg.sender);\r\n        DLeader.push(msg.sender);\r\n       \r\n        triggers[1]  = Trigger(105000e18,90000e18,100000e18,false,false);\r\n        triggers[2]  = Trigger(210000e18,180000e18,200000e18,false,false);\r\n        triggers[3]  = Trigger(315000e18,270000e18,300000e18,false,false);\r\n        triggers[4]  = Trigger(525000e18,450000e18,500000e18,false,false);\r\n        triggers[5]  = Trigger(1500000e18,900000e18,1000000e18,false,false);\r\n        triggers[6]  = Trigger(1500000e18,900000e18,1000000e18,false,false);\r\n        triggers[7]  = Trigger(2100000e18,1800000e18,2000000e18,false,false);\r\n        triggers[8]  = Trigger(5250000e18,4500000e18,5000000e18,false,false);\r\n        triggers[9]  = Trigger(10500000e18,9000000e18,10000000e18,false,false);\r\n        triggers[10] = Trigger(15750000e18,13500000e18,15000000e18,false,false);\r\n        triggers[11] = Trigger(21000000e18,18000000e18,20000000e18,false,false);\r\n        \r\n\r\n        rewardStatus[msg.sender].leader = true;\r\n        rewardStatus[msg.sender].grand = true;\r\n        rewardStatus[msg.sender].DLeader = true;\r\n        rewardStatus[msg.sender].timestamp = uint32(block.timestamp);\r\n        userInfo[msg.sender].openLevel=25;\r\n         \r\n        balDown = [10e22,20e22, 30e22,50e22, 100e22, 200e22, 500e22,1000e22,1500e22,2000e22];\r\n        balDownRate = [1000,1000,1000,1000, 1000, 1000, 1000,1000,1000,1000]; \r\n        balRecover = [105e21,210e21,315e21,525e21,110e22,200e22,500e22, 1000e22,1500e22,2000e22];\r\n        //dwn = [90e21,180e21,270e21,450e21,110e22,200e22,500e22, 1000e22,1500e22,2000e22];\r\n\r\n\r\n        emit Registration(msg.sender,address(this),total_users,0);\r\n    }\r\n\r\n    // function currentTrigger() public returns(uint256){\r\n    //     uint256 balnce =depositToken.balanceOf(address(this));\r\n    //     enableTrigger = 1;\r\n    //    for(uint8 i = 1;i<=11;i++){\r\n    //       if(balnce >=triggers[i].max_val){\r\n    //           enableTrigger++;\r\n    //       } \r\n    //    }\r\n    //     if(triggers[enableTrigger].status != true){\r\n    //         if(triggers[enableTrigger].isHit == true){\r\n    //             if(balnce <=triggers[enableTrigger].min_val){\r\n    //                 triggers[enableTrigger].status = true;\r\n    //             }\r\n    //         }else{\r\n    //             if(balnce >=triggers[enableTrigger].active_amnt){\r\n    //                  triggers[enableTrigger].isHit = true;\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //    return enableTrigger;\r\n    // }\r\n\r\n    \r\n\r\n    function getCurrDay()public view returns(uint256){\r\n        uint256 tm = uint256(block.timestamp)-startTime;\r\n        return tm/thdays;\r\n    }\r\n    function update1000(address addse)public {\r\n        uint256 tdy = getCurrDay();\r\n        if(daily[addse][tdy].status==false){\r\n            if(daily[addse][tdy].business>=1000e18 && daily[addse][tdy].directs>=2){\r\n                daily[addse][tdy].status=true;\r\n                thclub[tdy].push(addse);\r\n            }\r\n        }     \r\n\r\n    }\r\n    function getMaxLegUpdate(address addr)internal{\r\n        uint256 maxleg;\r\n        address myaddr;\r\n        uint256 sm;\r\n        for(uint256 l = 0;l<userInfo[addr].directs;l++){\r\n            myaddr = directTeam[addr][l];\r\n            sm = userInfo[myaddr].teamBusiness.add(userInfo[myaddr].totalDeposit);\r\n            if(maxleg<sm){\r\n                maxleg = sm;\r\n            }\r\n        }\r\n        business[addr].maxLeg = maxleg;\r\n    }\r\n    function register(address sponsor) public notRegistered(){\r\n       // address sponsor = idToAddress[sp];\r\n        \r\n        require(userInfo[sponsor].id!=0,\"Referrer Not Exists.\");\r\n        require(userInfo[sponsor].totalDeposit>0,\"Referrer Not Active.\");\r\n        \r\n        total_users++;\r\n        userInfo[msg.sender].id=total_users;\r\n        userInfo[msg.sender].sponsor=sponsor;        \r\n        idToAddress[total_users] =msg.sender;\r\n       // userInfo[sponsor].directs++; \r\n       // rewardStatus[msg.sender].timestamp=uint32(block.timestamp);\r\n        //upgrade(amount);\r\n       // triggers[total_users].status = true;\r\n        //uint256 tdy = getCurrDay();\r\n        //daily[sponsor][tdy].business += amount;\r\n        //daily[sponsor][tdy].directs ++;\r\n\r\n        //directTeam[sponsor].push(msg.sender);         \r\n        //updateTeam(msg.sender);\r\n        //updateUserTrigger(msg.sender);\r\n        //directBusness(sponsor,amount);\r\n       // userInfo[msg.sender].orderCount =1;\r\n        //total_orders++;\r\n        //uint256 neworder = userInfo[msg.sender].orderCount;\r\n       // orders[msg.sender][neworder].id=total_orders;\r\n        //orders[msg.sender][neworder].amount=amount;\r\n        //orders[msg.sender][neworder].nextClaim= uint256(block.timestamp).add(cycleDays);\r\n        userInfo[msg.sender].openLevel=0;\r\n        //incomes[msg.sender].income_status=true;\r\n        //community_dis(amount);\r\n        //updateLevel(msg.sender);\r\n       // updateTeamBusiness(msg.sender,amount);\r\n        emit Registration(msg.sender,sponsor,total_users,userInfo[sponsor].id);\r\n        \r\n    }\r\n    function changeTriggerStatus(bool stat,uint8 tr, bool isht)public onlyContractOwner{\r\n        triggers[tr].status = stat;\r\n        triggers[tr].isHit = isht;\r\n    }\r\n\r\n    function upgrade(uint256 amount)public Registered(){\r\n        require(amount>=Joining_amount,\"Amount Invalid\");\r\n         require(depositToken.balanceOf(msg.sender)>=amount,\"Insufficient Balance.\"); \r\n        \r\n         depositToken.safeTransferFrom(msg.sender,address(this),amount);\r\n        //currentTrigger();\r\n        uint256 bal = depositToken.balanceOf(address(this));\r\n        _balActived(bal);\r\n        if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        }\r\n        _upgrade(amount,msg.sender);\r\n    }\r\n    function splitdeposit(address addr,uint256 amount)public{\r\n        require(amount % 25e18 == 0,\"Insufficient Fund.\");\r\n        require(userInfo[msg.sender].wallet30>=amount,\"Insufficient Fund.\");\r\n        require(userInfo[msg.sender].status==true,\"You can not withdraw.\");\r\n\r\n        _upgrade(amount,addr);\r\n        userInfo[msg.sender].wallet30 -= amount;\r\n    }\r\n    function freezedeposit(uint256 amount)public{\r\n        require(amount % 25e18 == 0,\"Insufficient Fund.\");\r\n        require(amount>=userInfo[msg.sender].maxDeposit,\"Insufficient Fund.\");\r\n        require(incomes[msg.sender].freeze>=amount,\"Insufficient Fund.\");\r\n        //require(userInfo[msg.sender].status==true,\"You can not withdraw.\");\r\n\r\n        _upgrade(amount,msg.sender);\r\n        incomes[msg.sender].freeze -= amount;\r\n    }\r\n    function _upgrade(uint256 amount,address usr) internal {\r\n        require(userInfo[usr].maxDeposit<=amount, \"Invalid Amount\" );\r\n\r\n        address spo = userInfo[usr].sponsor;\r\n        \r\n        uint256 tdy = getCurrDay();\r\n        daily[spo][tdy].business += amount;\r\n        if(userInfo[usr].totalDeposit == 0){\r\n                userInfo[spo].directs++; \r\n                rewardStatus[usr].timestamp=uint32(block.timestamp);\r\n                daily[spo][tdy].directs ++;\r\n\r\n                directTeam[spo].push(msg.sender);\r\n                updateTeam(usr);\r\n                \r\n                incomes[usr].minor=amount;\r\n                userInfo[usr].openLevel=1;                \r\n        }\r\n        incomes[usr].income_status=true;\r\n        userInfo[spo].directBusiness += amount;\r\n        userInfo[usr].maxDeposit = amount;\r\n        userInfo[usr].totalDeposit += amount;\r\n        updateUserTrigger(usr);\r\n        updateUserTrigger(spo);\r\n        userInfo[usr].orderCount++;\r\n        total_orders++;\r\n        uint256 neworder = userInfo[usr].orderCount;\r\n        orders[usr][neworder].id=total_orders;\r\n        orders[usr][neworder].amount=amount;\r\n        orders[usr][neworder].nextClaim= uint256(block.timestamp).add(cycleDays);\r\n        directBusness(spo,amount);\r\n        distributeLevel(usr,amount);\r\n        updateTeamBusiness(usr,amount);\r\n        updateLevel(usr);\r\n        community_dis(amount);\r\n        emit Statics(usr,usr,\"packageUpdate\",amount,0);\r\n    }\r\n\r\n    function _balActived(uint256 _bal) public {\r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n            if(_bal >= balDown[i - 1]){\r\n                balStatus[balDown[i - 1]] = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    uint public Look;\r\n\r\n    function _setFreezeReward(uint256 _bal) public {\r\n         \r\n        for(uint256 i = balDown.length; i > 0; i--){\r\n             \r\n            if(balStatus[balDown[i - 1]]){\r\n                uint256 maxDown = balDown[i - 1].mul(balDownRate[i - 1]).div(baseDivider);\r\n                \r\n                if(_bal < balDown[i - 1].sub(maxDown)){\r\n                      \r\n                    enableTrigger = i;\r\n                    isFreezeReward = true;\r\n                }else if(isFreezeReward && _bal >= balRecover[i - 1]){                     \r\n                    isFreezeReward = false;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    address private x;\r\n    function distributeLevel(address addr,uint256 amnt)internal{\r\n        x = userInfo[addr].sponsor;\r\n       uint256 inc;\r\n\r\n        for(uint256 i = 0;i < level_income.length;i++){\r\n             if(x != address(0)){\r\n                 \r\n                updateUserTrigger(x);\r\n                \r\n                if(userInfo[x].openLevel>i && ((usertriggers[x][enableTrigger].trigger_status == true && isFreezeReward==false) || incomes[x].income_status == true) ){\r\n                 \r\n            \r\n                    if(userInfo[x].maxDeposit>=amnt){\r\n                        inc= amnt.mul(level_income[i]).div(baseDiv);\r\n\r\n                    }else{\r\n                        inc= uint256(userInfo[x].maxDeposit).mul(level_income[i]).div(baseDiv);\r\n                    }                   \r\n                                       \r\n                    if(i>4){\r\n                        incomes[x].freeze += inc;\r\n                    }else{\r\n                        incomes[x].level += inc;\r\n\r\n                        userInfo[x].balance += inc; \r\n                        userInfo[x].wallet30 +=  (inc.mul(30)).div(100);    \r\n                        userInfo[x].wallet70 +=  (inc.mul(70)).div(100);    \r\n\r\n                        emit Statics(x,addr,\"LevelIncome\",inc,(i+1));\r\n                    }\r\n                     \r\n                }\r\n                updateUserTrigger(x);\r\n                   x = userInfo[x].sponsor;\r\n             }else{\r\n                 break;\r\n             }        \r\n              \r\n            //distributeIncome(x,amnt,pkgid);                      \r\n        }        \r\n    }\r\n    \r\n    function community_dis(uint256 withdrawalable)internal{\r\n        \r\n        createrWallet[creaters[0]] += withdrawalable*15/1000;\r\n        createrWallet[creaters[1]] += withdrawalable*15/1000;\r\n        createrWallet[creaters[2]] += withdrawalable*50/1000;\r\n        \r\n        leader_payout += withdrawalable*5/1000;\r\n        grand_payout += withdrawalable*5/1000;\r\n        DLeader_payout += withdrawalable*5/1000;      \r\n        thclub_payout += withdrawalable*5/1000;      \r\n\r\n        \r\n        //distributeIncome(user,withdrawalable,pkgid);\r\n    }\r\n   \r\n    function updateTeam(address usdrid)internal {\r\n        x = userInfo[usdrid].sponsor;\r\n        for(uint i = 0 ; i < 20 ; i++ ){\r\n            if(x != address(0)){ \r\n\r\n                    userInfo[x].teamNum++;                                               \r\n                    genTeam[x][i].push(usdrid);\r\n                    x = userInfo[x].sponsor;\r\n                    emit TeamAdd(x,usdrid,(i+1));\r\n            }else{\r\n                break;\r\n            }             \r\n        }\r\n    }\r\n    \r\n    function updateTeamBusiness(address usdrid,uint256 busienns)internal {\r\n        x = userInfo[usdrid].sponsor; \r\n        for(uint i = 0 ; i < 20 ; i++ ){\r\n            if(x != address(0)){  \r\n                    userInfo[x].teamBusiness +=busienns;\r\n                    getMaxLegUpdate(x);                    \r\n                    x = userInfo[x].sponsor;\r\n            }else{\r\n                break;\r\n            }            \r\n        }\r\n    }\r\n    function directBusness(address userid,uint256 busiens)internal {\r\n            if(isFreezeReward == true){\r\n                 if(userid != address(0)){  \r\n                    usertriggers[userid][enableTrigger].directBusins +=busiens;                \r\n                 }  \r\n            }\r\n            if(isFreezeReward == false){\r\n                    usertriggers[userid][enableTrigger].direct1Busins +=busiens;\r\n            }\r\n\r\n    }\r\n    \r\n\r\n    function claim(uint256 ind) public {\r\n        order storage myOrder = orders[msg.sender][ind];         \r\n        require(myOrder.nextClaim<=uint256(block.timestamp),\"Time Limit\");\r\n        require(myOrder.status == false,\"Disabled\");\r\n        myOrder.cycle++;\r\n        if(myOrder.cycle>10){\r\n            require(userInfo[msg.sender].status==true,\"You can not Claim.\");\r\n        }\r\n        updateUserTrigger(msg.sender);\r\n        if((usertriggers[msg.sender][enableTrigger].trigger_status == true && isFreezeReward==false) ||  incomes[msg.sender].income_status==true){\r\n            uint256 addtm = cycleDays.add(myOrder.cycle.mul(1 days));\r\n            myOrder.nextClaim = uint256(block.timestamp).add(addtm);\r\n            myOrder.lastClaim = uint256(block.timestamp);\r\n            uint256 claimAmnt = (myOrder.amount.mul(10)).div(100);\r\n            myOrder.claimed += claimAmnt;\r\n            distributeLevel(msg.sender,claimAmnt);\r\n            incomes[msg.sender].roi += claimAmnt;\r\n            uint256 svn = claimAmnt.mul(70).div(100);\r\n            uint256 thr = claimAmnt.mul(30).div(100);\r\n\r\n            userInfo[msg.sender].balance +=  claimAmnt;\r\n            userInfo[msg.sender].wallet70 +=  svn;\r\n            userInfo[msg.sender].wallet30 +=  thr;\r\n        }\r\n        updateUserTrigger(msg.sender);\r\n    }\r\n\r\n    function claim_p()public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.balance<user.totalDeposit,\"Already claimed\");\r\n        uint256 claimAmnt = user.totalDeposit.sub(user.balance);\r\n        user.balance += claimAmnt;\r\n\r\n        uint256 svn = claimAmnt.mul(70).div(100);\r\n        uint256 thr = claimAmnt.mul(30).div(100);\r\n\r\n        userInfo[msg.sender].wallet70 +=  svn;\r\n        userInfo[msg.sender].wallet30 +=  thr;\r\n        incomes[msg.sender].income_status = false;\r\n        for(uint256 i= 1 ; i<=user.orderCount;i++){\r\n            orders[msg.sender][i].status = true;\r\n            orders[msg.sender][i].claimed = orders[msg.sender][i].amount;\r\n        }\r\n        for(uint8 j = 0;j<10;j++){\r\n            usertriggers[msg.sender][j].trigger_status = false;\r\n        }\r\n    }\r\n\r\n    function transferSplit(address addr,uint256 amnt)public{\r\n        require(amnt % 25e18 == 0,\"Amount Should be multiple of 25.\");\r\n        require(userInfo[msg.sender].wallet30>=amnt,\"Insufficient Fund.\");\r\n        require(userInfo[msg.sender].status==true,\"You can not withdraw.\");\r\n\r\n        userInfo[msg.sender].wallet30 -= amnt;\r\n        userInfo[addr].wallet30 += amnt;         \r\n\r\n    }\r\n\r\n    function withdrawal_nonworking(uint256 amnt)public{\r\n      \r\n        require(userInfo[msg.sender].wallet70>=amnt,\"Insufficient Fund.\");\r\n        \r\n         depositToken.safeTransfer(msg.sender,amnt);\r\n         \r\n        userInfo[msg.sender].wallet70 -=  amnt;\r\n       \r\n        uint256 bal = depositToken.balanceOf(address(this));\r\n        _balActived(bal);\r\n        //if(isFreezeReward){\r\n        _setFreezeReward(bal);\r\n\r\n    }\r\n    function withdrawal_facuet(uint256 amnt)public onlyContractOwner{\r\n      //  require(amnt % 5e18 == 0 && amnt>= 5e18,\"Amount Should be multiple of 5.\");\r\n       // require(userInfo[msg.sender].wallet70>=amnt,\"Insufficient Fund.\");\r\n        //require(userInfo[msg.sender].status==true,\"You can not withdraw.\");\r\n         depositToken.safeTransfer(msg.sender,amnt);  \r\n        //currentTrigger();\r\n        uint256 bal = depositToken.balanceOf(address(this));\r\n        _balActived(bal);\r\n        //if(isFreezeReward){\r\n            _setFreezeReward(bal);\r\n        //}\r\n    }\r\n\r\n    function depositWithFreeze(uint256 amnt)public{\r\n        require(incomes[msg.sender].freeze>=amnt,\"Insufficient Fund.\");\r\n        require(amnt>=userInfo[msg.sender].maxDeposit,\"Invalid Amount.\");\r\n        //require(userInfo[msg.sender].status==true,\"You can not withdraw.\");\r\n        //depositToken.safeTransfer(msg.sender,amnt);\r\n        _upgrade(amnt,msg.sender);\r\n        incomes[msg.sender].freeze -=  amnt;\r\n\r\n    }\r\n\r\n    function updateLevel(address user)public{\r\n         x = user;//userInfo[user].sponsor;\r\n         uint256 pretime;\r\n         uint256 ttn;\r\n        for(uint i = 0 ; i < 20 ; i++ ){\r\n            if(x != address(0)){ \r\n                if(userInfo[x].openLevel<3){\r\n                    if(userInfo[x].totalDeposit>=100e18){\r\n                        if(userInfo[x].directs>=3 && userInfo[x].directBusiness>=500e18){\r\n                            userInfo[x].openLevel=3;\r\n                        }\r\n                    }\r\n                }\r\n                ttn = userInfo[x].teamBusiness.sub(business[x].maxLeg);\r\n                if(userInfo[x].openLevel<5){\r\n                    if(userInfo[x].totalDeposit>=500e18){\r\n                        \r\n                        if(userInfo[x].directs>=5 && userInfo[x].directBusiness>=1000e18 && ttn>=5000e18 && business[x].maxLeg>=5000e18 && userInfo[x].teamNum>=50){\r\n                            userInfo[x].openLevel=5;\r\n                            leader.push(x);\r\n                            rewardStatus[x].leader=true;\r\n                        }\r\n                    }\r\n                }\r\n               \r\n                if(userInfo[x].openLevel<15){\r\n                    if(userInfo[x].totalDeposit>=1000e18){\r\n                        \r\n                        if(userInfo[x].directs>=10 && userInfo[x].directBusiness>=5000e18 && ttn>=50000e18 && business[x].maxLeg>=50000e18 && userInfo[x].teamNum>=100){\r\n                            userInfo[x].openLevel=15;\r\n                            grand.push(x);\r\n                            rewardStatus[x].grand=true;\r\n                        }\r\n                    }\r\n                }\r\n               \r\n                if(userInfo[x].openLevel<25){\r\n                    if(userInfo[x].totalDeposit>=2500e18){\r\n                        if(userInfo[x].directs>=20 && userInfo[x].directBusiness>=10000e18 && ttn>=100000e18 && business[x].maxLeg>=100000e18 && userInfo[x].teamNum>=300){\r\n                            userInfo[x].openLevel=25;\r\n                            DLeader.push(x);\r\n                            rewardStatus[x].DLeader=true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(userInfo[x].status==false){\r\n                    pretime = block.timestamp.sub(30 days);\r\n\r\n                    if(pretime>rewardStatus[x].timestamp){\r\n\r\n                        if(userInfo[x].directs>=2 && userInfo[x].directBusiness>=(userInfo[x].totalDeposit.mul(2))){\r\n                            userInfo[x].status =  true;\r\n                        }\r\n                    }else{\r\n                         if(userInfo[x].directs>=4 && userInfo[x].directBusiness>=(userInfo[x].totalDeposit.mul(4))){\r\n                            userInfo[x].status =  true;\r\n                        }\r\n                    }\r\n                }                      \r\n                x = userInfo[x].sponsor;\r\n            }else{\r\n                break;\r\n            }            \r\n        }\r\n    }\r\n\r\n    function updateUserTrigger(address userId)internal{\r\n        address sposner = userId;//userInfo[userId].sponsor;\r\n        if(isFreezeReward == true){\r\n\r\n            if(userInfo[sposner].balance >= userInfo[sposner].totalDeposit){\r\n                    uint256 requirAmnt = requireBusiness(userInfo[sposner].totalDeposit);\r\n                    if(usertriggers[sposner][enableTrigger].trigger_status == false){\r\n                        if(usertriggers[sposner][enableTrigger].directBusins >= requirAmnt){\r\n                            //incomes[sposner].income_status=true;\r\n                            usertriggers[sposner][enableTrigger].trigger_status = true;\r\n                        }else{\r\n                            incomes[sposner].income_status=false;\r\n                        }\r\n                    }\r\n\r\n            }else{\r\n                incomes[sposner].income_status=true;\r\n            }\r\n        }else{\r\n            if(usertriggers[sposner][enableTrigger].trigger_status == false){\r\n                if(usertriggers[sposner][enableTrigger].direct1Busins >= userInfo[sposner].totalDeposit.mul(2)){\r\n                    usertriggers[sposner][enableTrigger].trigger_status=true;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    function requireBusiness(uint256 amnt) public pure returns(uint256){\r\n            uint256 amunt = 0;\r\n            if(amnt >= 25e18 && amnt <= 500e18){\r\n                 amunt = 50e18;\r\n            }else if(amnt >= 525e18 && amnt <= 1000e18){\r\n                amunt = 100e18;\r\n            }else if(amnt >= 1025e18 && amnt <= 2000e18){\r\n                amunt = 200e18;\r\n            }else if(amnt >= 2025e18 && amnt <= 2500e18){\r\n                amunt = 500e18;\r\n            }\r\n            return amunt;\r\n    }\r\n     \r\n     function distribute_leader() public onlyContractOwner(){\r\n        uint256 amount = leader_payout/leader.length;\r\n         for(uint8 i=0;i<leader.length;i++){\r\n             address _id = leader[i];\r\n            if(incomes[_id].income_status == true){\r\n\r\n             \r\n             userInfo[_id].balance += amount;\r\n            // depositToken.safeTransfer(_id,amount);\r\n             incomes[_id].leader += amount;\r\n\r\n             userInfo[_id].wallet30 +=  amount.mul(30).div(100);\r\n             userInfo[_id].wallet70 +=  amount.mul(70).div(100);\r\n\r\n             emit Income(_id,'leader',amount);\r\n             emit Statics(_id,_id,\"leader\",amount,0);\r\n            }\r\n         }\r\n         leader_payout =0;\r\n    }\r\n     \r\n     function distribute_grand() public onlyContractOwner(){\r\n        uint256 amount = grand_payout/grand.length;\r\n         for(uint8 i=0;i<grand.length;i++){\r\n             address _id = grand[i];\r\n            if(incomes[_id].income_status == true){\r\n             userInfo[_id].balance += amount;\r\n             //depositToken.safeTransfer(_id,amount);\r\n             incomes[_id].grand += amount;\r\n\r\n                userInfo[_id].wallet30 +=  amount.mul(30).div(100);\r\n                userInfo[_id].wallet70 +=  amount.mul(70).div(100);\r\n             emit Income(_id,'grand',amount);\r\n             emit Statics(_id,_id,\"grand\",amount,0);\r\n            }\r\n         }\r\n         grand_payout = 0;\r\n    }\r\n     \r\n     function distribute_Dleader() public onlyContractOwner(){\r\n        uint256 amount = DLeader_payout/DLeader.length;\r\n         for(uint8 i=0;i<DLeader.length;i++){\r\n             address _id = DLeader[i];\r\n            if(incomes[_id].income_status == true){\r\n             userInfo[_id].balance += amount;\r\n            // depositToken.safeTransfer(_id,amount);\r\n             incomes[_id].DLeader += amount;\r\n              userInfo[_id].wallet30 +=  amount.mul(30).div(100);\r\n                userInfo[_id].wallet70 +=  amount.mul(70).div(100);\r\n             emit Income(_id,'DLeader',amount);\r\n             emit Statics(_id,_id,\"DLeader\",amount,0);\r\n            }\r\n         }\r\n         DLeader_payout =0;\r\n    }\r\n    \r\n     function distribute_thchub(uint256 day) public onlyContractOwner(){\r\n         \r\n        uint256 amount = thclub_payout/thclub[day].length;\r\n         for(uint8 i=0;i<thclub[day].length;i++){\r\n             address _id = thclub[day][i];\r\n            if(incomes[_id].income_status == true){\r\n             userInfo[_id].balance += amount;\r\n            // depositToken.safeTransfer(_id,amount);\r\n\r\n             incomes[_id].thclub += amount;\r\n              userInfo[_id].wallet30 +=  amount.mul(30).div(100);\r\n                userInfo[_id].wallet70 +=  amount.mul(70).div(100);\r\n             emit Income(_id,'1000 club',amount);\r\n             emit Statics(_id,_id,\"1000 club\",amount,0);\r\n            }\r\n         }\r\n         thclub_payout =0;\r\n    } \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImpl\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MaticCoinHub", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a9ceafce628554241a8cb81e877d5873dff3af22", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xa9ceafce628554241a8cb81e877d5873dff3af22", "SwarmSource": "ipfs://41d67d343dc84a3a7b6425963f16f8b0ca32d2dc0e67b5956aa03db0adbdc169"}