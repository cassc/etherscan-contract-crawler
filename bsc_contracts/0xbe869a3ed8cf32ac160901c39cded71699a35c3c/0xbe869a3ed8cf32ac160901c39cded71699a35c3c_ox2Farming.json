{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function burn(uint256 amount) external;\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: ox21.sol\r\npragma solidity ^0.8.0;\r\n\r\ncontract ox2Farming is Ownable, Pausable, ReentrancyGuard {\r\n    struct Package {\r\n        uint256 number;\r\n        uint256 duration;\r\n        uint256 apy;\r\n        uint256 monthly;\r\n        uint256 bonus;\r\n        uint256 allocation;\r\n        uint256 referral;\r\n        uint256 allocated;\r\n    }\r\n\r\n    struct Staking {\r\n        bytes32 id;\r\n        address user;\r\n        uint256 package;\r\n        uint256 value;\r\n        uint256 starttime;\r\n        uint256 endtime;\r\n        uint256 farmingreward;\r\n        uint256 claimedreward;\r\n        uint256 totalWithdrawals;\r\n        uint256 status; // 0 inactive 1 active\r\n    }\r\n\r\n    struct ExtraInfo {\r\n        bytes32 id;\r\n        uint256 rate;\r\n        uint256 monthly;\r\n        uint256 lastWithdrawalDays;\r\n    }\r\n\r\n    struct User {\r\n        address user;\r\n        address ref_address;\r\n        bytes32[] ids;\r\n        address[] referrers;\r\n        uint256 finalEndtime;\r\n        uint256 refIncome;\r\n        uint256 harvest;\r\n        uint256 deductions;\r\n        uint256 status;\r\n        uint256 activeUsers;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct Statement {\r\n        address from;\r\n        address user;\r\n        bytes32 id;\r\n        uint256 time;\r\n        uint256 _type; // 0 farm 1 unfarm 2 Staking Reward 3 Referral reward 4 burn\r\n        uint256 amount; // Stake amount use for Referral Reward\r\n        uint256 sper; // Staking reward %\r\n        uint256 refper; // Referral Reward %\r\n        uint256 credit;\r\n        uint256 debit;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct RefReward {\r\n        address from;\r\n        address to;\r\n        uint256 time;\r\n        uint256 value;\r\n        uint256 amount;\r\n        uint256 per;\r\n        bytes32 id;\r\n        uint256 duration;\r\n        uint256 burn;\r\n    }\r\n\r\n    struct StakingRew {\r\n        address user;\r\n        uint256 time;\r\n        uint256 value;\r\n        uint256 amount;\r\n        uint256 per;\r\n        bytes32 id;\r\n        uint256 burn;\r\n    }\r\n\r\n    struct Unstake {\r\n        address user;\r\n        bytes32 id;\r\n        uint256 timestamp;\r\n        uint256 value;\r\n        uint256 deduction;\r\n    }\r\n\r\n    mapping(uint256 => Package) public packages;\r\n    mapping(bytes32 => Staking) public staking;\r\n    mapping(address => User) public user;\r\n    mapping(bytes32 => ExtraInfo) public extraInfo;\r\n    Statement[] public statements;\r\n    Staking[] public stakeArray;\r\n    RefReward[] public refReward;\r\n    StakingRew[] public stakingReward;\r\n    address[] public farmersList;\r\n    Unstake[] public unstake;\r\n    address public defaultAddress = 0x0357625eB9fB384a425ff4AAaC30A7C346d5279B;\r\n    address public token = 0x53940D46a35162255511ff7cade811891d49533c;\r\n    uint256 public minValue = 50e18;\r\n    uint256 public unFarmCharge = 2e18;\r\n    uint256 public requireActive = 50;\r\n    uint256 public claimFee = 25e16;\r\n    uint256 public totalLockedToken;\r\n    uint256 public totalLockedUsd;\r\n    uint256 public totalActiveLockedToken;\r\n    uint256 public totalActiveLockedUsd;\r\n    uint256 public totalHarvest;\r\n    uint256 public totalRefReward;\r\n    uint256[5] public defaultAllocation = [7500000e18,12500000e18,15000000e18,17500000e18,27500000e18];\r\n\r\n    constructor() {\r\n        packages[1].number = 1;\r\n        packages[1].duration = 30;\r\n        packages[1].apy = 18e18;\r\n        packages[1].monthly = 15e17;\r\n        packages[1].bonus = 1e17;\r\n        packages[1].allocation = 7500000e18;\r\n        packages[1].referral = 35e16;\r\n\r\n        packages[2].number = 2;\r\n        packages[2].duration = 60;\r\n        packages[2].apy = 21e18;\r\n        packages[2].monthly = 175e16;\r\n        packages[2].bonus = 1e17;\r\n        packages[2].allocation = 12500000e18;\r\n        packages[2].referral = 45e16;\r\n\r\n        packages[3].number = 3;\r\n        packages[3].duration = 90;\r\n        packages[3].apy = 24e18;\r\n        packages[3].monthly = 2e18;\r\n        packages[3].bonus = 1e17;\r\n        packages[3].allocation = 15000000e18;\r\n        packages[3].referral = 60e16;\r\n\r\n        packages[4].number = 4;\r\n        packages[4].duration = 120;\r\n        packages[4].apy = 30e18;\r\n        packages[4].monthly = 25e17;\r\n        packages[4].bonus = 1e17;\r\n        packages[4].allocation = 17500000e18;\r\n        packages[4].referral = 75e16;\r\n\r\n        packages[5].number = 5;\r\n        packages[5].duration = 180;\r\n        packages[5].apy = 36e18;\r\n        packages[5].monthly = 3e18;\r\n        packages[5].bonus = 1e17;\r\n        packages[5].allocation = 27500000e18;\r\n        packages[5].referral = 1e18;\r\n    }\r\n    \r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function getMonthlyAPY(uint256 package, uint256 _token)\r\n        public\r\n        view\r\n        returns (uint256 monthly, uint256 daily)\r\n    {\r\n        monthly = (packages[package].monthly * _token) / 100e18;\r\n        daily = monthly / 30;\r\n    }\r\n\r\n    function changeClaimFee(uint256 value) public onlyOwner {\r\n        claimFee = value;\r\n    }\r\n\r\n    function changeAllocation(uint256 value, uint256 package) public onlyOwner {\r\n        require(value >= defaultAllocation[package-1],\"Value Must be greate then default allocation\");\r\n        packages[package].allocation = value;\r\n    }\r\n\r\n    function changeApy(uint256 year,uint256 month, uint256 package) public onlyOwner {\r\n        packages[package].apy = year;\r\n        packages[package].monthly = month;\r\n    }\r\n\r\n    function changeRefRewardPer(uint256 value, uint256 package)\r\n        public\r\n        onlyOwner\r\n    {\r\n        packages[package].referral = value;\r\n    }\r\n\r\n    function getUserIds(address u) public view returns (bytes32[] memory ids) {\r\n        ids = user[u].ids;\r\n    }\r\n\r\n    function getUsers() public view returns (address[] memory) {\r\n        return farmersList;\r\n    }\r\n\r\n    function getReferrers(address u)\r\n        public\r\n        view\r\n        returns (address[] memory referrers)\r\n    {\r\n        referrers = user[u].referrers;\r\n    }\r\n\r\n    // 0 inactive 1 active\r\n    function checkUser(address u) public view returns (uint256 status) {\r\n        if (u == defaultAddress) {\r\n            status = 1;\r\n        } else if (user[u].finalEndtime > block.timestamp) {\r\n            status = 1;\r\n        } else {\r\n            status = 0;\r\n        }\r\n    }\r\n\r\n    function checkTokenAllocation(uint256 package)\r\n        public\r\n        view\r\n        returns (uint256 remains)\r\n    {\r\n        uint256 totalAllocation = packages[package].allocation;\r\n        uint256 allocated = packages[package].allocated;\r\n        remains = totalAllocation - allocated;\r\n    }\r\n\r\n    function userExists(address ref, address u)\r\n        public\r\n        view\r\n        returns (uint256 exist)\r\n    {\r\n        for (uint256 i = 0; i < user[ref].referrers.length; i++) {\r\n            if (user[ref].referrers[i] == u) {\r\n                return 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function pushStatement(\r\n        address from,\r\n        address u,\r\n        bytes32 _sid,\r\n        uint256 _type,\r\n        uint256 amt,\r\n        uint256 sper,\r\n        uint256 rper,\r\n        uint256 credit,\r\n        uint256 debit,\r\n        uint256 balance\r\n    ) internal {\r\n        statements.push(\r\n            Statement({\r\n                from : from,\r\n                user: u,\r\n                id: _sid,\r\n                time: block.timestamp,\r\n                _type: _type,\r\n                amount: amt,\r\n                sper: sper,\r\n                refper: rper,\r\n                credit: credit,\r\n                debit: debit,\r\n                balance: balance\r\n            })\r\n        );\r\n    }\r\n\r\n    function readData()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 totalStakers,\r\n            uint256 totalActiveStakers,\r\n            uint256 totalLockedTokens,\r\n            uint256 totalLockedUsds,\r\n            uint256 totalActiveLockedTokens,\r\n            uint256 totalActiveLockedUsds,\r\n            uint256 totalHarvests,\r\n            uint256 totalRefRewards\r\n        )\r\n    {\r\n        totalStakers = stakeArray.length;\r\n        for (uint256 i = 0; i < totalStakers; i++) {\r\n            if (staking[stakeArray[i].id].status == 1) {\r\n                totalActiveStakers++;\r\n            }\r\n        }\r\n        totalLockedTokens = totalLockedToken;\r\n        totalLockedUsds = totalLockedUsd;\r\n        totalActiveLockedTokens = totalActiveLockedToken;\r\n        totalActiveLockedUsds = totalActiveLockedUsd;\r\n        totalHarvests = totalHarvest;\r\n        totalRefRewards = totalRefReward;\r\n    }\r\n\r\n    event Farm(\r\n        address farmer,\r\n        address ref,\r\n        uint256 value,\r\n        uint256 package,\r\n        bytes32 id\r\n    );\r\n\r\n    function farm(\r\n        address ref,\r\n        uint256 value,\r\n        uint256 package,\r\n        uint256 _type,\r\n        uint256 rate\r\n    ) public whenNotPaused {\r\n\r\n        Staking memory s;\r\n        ExtraInfo memory e;\r\n        s.user = msg.sender;\r\n        s.value = value;\r\n        if (_type == 1) {\r\n            require(\r\n                s.value >= user[msg.sender].deductions,\r\n                \"value must more than deducted value !\"\r\n            );\r\n            s.value += user[msg.sender].deductions;\r\n            user[msg.sender].deductions = 0;\r\n        }\r\n        require(s.value > minValue, \"Farming value is too less !\");\r\n        require(\r\n            checkTokenAllocation(package) >= s.value,\r\n            \"Value is more than allocation !\"\r\n        );\r\n        s.starttime = block.timestamp;\r\n        s.endtime = block.timestamp + (packages[package].duration * 86400);\r\n        e.rate = rate;\r\n        s.package = package;\r\n        s.status = 1;\r\n        (e.monthly, ) = getMonthlyAPY(package, s.value);\r\n        bytes32 _id = keccak256(abi.encodePacked(msg.sender, s.value, s.starttime));\r\n        s.id = _id;\r\n        staking[_id] = s;\r\n        if (user[msg.sender].user == address(0)) {\r\n            require(checkUser(ref) == 1, \"Referral address is not active\");\r\n            require(ref != msg.sender, \"You can not referr your self !\");\r\n            user[msg.sender].ref_address = ref;\r\n        }\r\n        user[msg.sender].user = msg.sender;\r\n        user[msg.sender].ids.push(_id);\r\n        user[msg.sender].finalEndtime = s.endtime;\r\n        user[msg.sender].status = 1;\r\n        packages[package].allocated += s.value;\r\n\r\n        if (userExists(ref, msg.sender) == 0) {\r\n            // code\r\n            user[ref].referrers.push(msg.sender);\r\n            user[ref].activeUsers++;\r\n        }\r\n        uint256 balance = user[msg.sender].balance + value;\r\n        pushStatement(ref,msg.sender, _id, 0, 0, 0, 0, value, 0, balance);\r\n        user[msg.sender].balance += value;\r\n\r\n        totalLockedToken += value;\r\n        totalLockedUsd += (value * rate) / 1e18;\r\n        totalActiveLockedToken += value;\r\n        totalActiveLockedUsd += (value * rate) / 1e18;\r\n\r\n        stakeArray.push(s);\r\n        farmersList.push(msg.sender);\r\n        //transfer token\r\n        IERC20(token).transferFrom(msg.sender, address(this), value);\r\n        emit Farm(msg.sender, ref, s.value, package, _id);\r\n    }\r\n\r\n    function getDays(bytes32 id, uint256 time)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 day,\r\n            uint256 half,\r\n            uint256 month\r\n        )\r\n    {\r\n        uint256 cTime = staking[id].endtime < time ? staking[id].endtime : time;\r\n        // uint256 cTime = staking[id].endtime < block.timestamp\r\n        //     ? staking[id].endtime\r\n        //     : block.timestamp;\r\n        day = (cTime - staking[id].starttime) / 60 / 60 / 24;\r\n        half = packages[staking[id].package].duration / 2;\r\n        month = (day / 30);\r\n    }\r\n\r\n    event Unfarm(bytes32 id, address farmer, uint256 value,uint time,uint totalWithdrawals,uint charge);\r\n\r\n    function unfarm(bytes32 id) public whenNotPaused {\r\n        require(\r\n            msg.sender == staking[id].user,\r\n            \"You are not owner of this staking !\"\r\n        );\r\n        address farmer = msg.sender;\r\n        require(staking[id].status == 1, \"staking is not active !\");\r\n        (uint256 day, uint256 half, ) = getDays(id, block.timestamp);\r\n        // (uint256 day, uint256 half,) = getDays(id, block.timestamp);\r\n        uint256 total = staking[id].value;\r\n        uint256 charge;\r\n        if (day < half && staking[id].package != 1) {\r\n            // code\r\n            charge = ((staking[id].value * unFarmCharge) / 100e18);\r\n            user[farmer].deductions += charge;\r\n            total = staking[id].value - (staking[id].totalWithdrawals + charge);\r\n        }\r\n        packages[staking[id].package].allocated -= staking[id].value;\r\n        staking[id].status = 0;\r\n\r\n        if (user[farmer].finalEndtime < block.timestamp) {\r\n            user[farmer].status = 0;\r\n            user[user[farmer].ref_address].activeUsers--;\r\n        }\r\n        uint256 balance = user[farmer].balance - staking[id].value;\r\n        pushStatement(address(0),farmer, id, 1, 0, 0, 0, 0, total, balance);\r\n        user[farmer].balance -= staking[id].value;\r\n        unstake.push(\r\n            Unstake({\r\n                user: farmer,\r\n                id: id,\r\n                timestamp: block.timestamp,\r\n                value: total,\r\n                deduction: charge\r\n            })\r\n        );\r\n        totalActiveLockedToken -= staking[id].value;\r\n        totalActiveLockedUsd -= (staking[id].value * extraInfo[id].rate) / 1e18;\r\n        IERC20(token).transfer(farmer, total);\r\n        //transfer token\r\n        emit Unfarm(id, msg.sender, total,block.timestamp,staking[id].totalWithdrawals , charge);\r\n    }\r\n\r\n    // function checkROIBalance(bytes32 id)\r\n    //     public\r\n    //     view\r\n    //     returns (\r\n    //         uint256 balance,\r\n    //         uint256 months,\r\n    //         uint256 duration\r\n    //     )\r\n    // {\r\n    //     duration = packages[staking[id].package].duration - extraInfo[id].lastWithdrawalDays;\r\n    //     months = duration / 30;\r\n    //     balance = extraInfo[id].monthly * months;\r\n    // }\r\n\r\n    function checkROIBalance(bytes32 id)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 balance,\r\n            uint256 months,\r\n            uint256 duration\r\n        )\r\n    {\r\n        duration =\r\n            packages[staking[id].package].duration -\r\n            extraInfo[id].lastWithdrawalDays;\r\n        months = duration / 30;\r\n        balance = extraInfo[id].monthly * months;\r\n    }\r\n\r\n    function checkuserbonus(address farmer)\r\n        public\r\n        view\r\n        returns (uint256 status)\r\n    {\r\n        status = ((user[farmer].finalEndtime > block.timestamp) &&\r\n            (user[farmer].activeUsers >= 50))\r\n            ? 1\r\n            : 0;\r\n    }\r\n\r\n    function checkrefbonus(bytes32 id) public view returns (uint refbinc) {\r\n        refbinc = ((user[user[staking[id].user].ref_address].activeUsers / requireActive) *\r\n            packages[staking[id].package].bonus);\r\n    }\r\n\r\n    function checkrefbonus(address u)\r\n        public\r\n        view\r\n        returns (uint[] memory bonus)\r\n    {\r\n        bonus =  new uint[](5);\r\n        for (uint i = 0; i < 5; i++) {\r\n            bonus[i] =  ((user[u].activeUsers / requireActive) * packages[i+1].bonus);\r\n        }\r\n    }\r\n\r\n    function checkreferral(bytes32 id) public view returns (uint256 reward) {\r\n        uint256 refper = checkuserbonus(user[staking[id].user].ref_address) == 1\r\n            ? (packages[staking[id].package].referral + checkrefbonus(id))\r\n            : packages[staking[id].package].referral;\r\n        reward = ((staking[id].value * refper) / 100e18);\r\n    }\r\n\r\n    function additionInfo(bytes32 id, address farmer)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 sreward,\r\n            uint256 refper,\r\n            uint256 refIncome\r\n        )\r\n    {\r\n        sreward = ((staking[id].value * packages[staking[id].package].monthly) /\r\n            100e18);\r\n        refper = checkuserbonus(farmer) == 1\r\n            ? (packages[staking[id].package].referral + checkrefbonus(id))\r\n            : packages[staking[id].package].referral;\r\n        refIncome = ((staking[id].value * refper) / 100e18);\r\n    }\r\n    \r\n    function Harvest (bytes32 id) public  whenNotPaused {\r\n        (,,uint month) = getDays(id,block.timestamp);\r\n        require(month -  staking[id].claimedreward > 0, \"time remains OR over\");\r\n        claimReward(id);\r\n    }\r\n    \r\n    event ClaimReward(bytes32 id, address farmer, uint256 value,uint refreward,address refaddress,uint time);\r\n\r\n    function claimReward(bytes32 id) internal  whenNotPaused {\r\n        require(user[msg.sender].status == 1, \"user is not active !\");\r\n\r\n        require(\r\n            ((packages[staking[id].package].duration / 30) -\r\n                staking[id].claimedreward) != 0,\r\n            \"all rewards are claimed\"\r\n        );\r\n\r\n        (uint256 sreward, uint256 refper, uint256 refIncome) = additionInfo(\r\n            id,\r\n            user[msg.sender].ref_address\r\n        );\r\n\r\n        uint256 finalSRew = sreward - ((sreward * claimFee) / 100e18);\r\n        uint256 finalRefIncome = refIncome - ((refIncome * claimFee) / 100e18);\r\n\r\n        staking[id].totalWithdrawals += sreward;\r\n        staking[id].claimedreward += 1;\r\n        user[msg.sender].harvest += finalSRew;\r\n        totalHarvest += finalSRew;\r\n        totalRefReward += refIncome;\r\n        //Staking Reward\r\n        pushStatement(\r\n            user[msg.sender].ref_address,\r\n            msg.sender,\r\n            id,\r\n            2,\r\n            staking[id].value,\r\n            packages[staking[id].package].monthly,\r\n            0,\r\n            finalSRew,\r\n            0,\r\n            user[msg.sender].balance + finalSRew\r\n        );\r\n        user[msg.sender].balance += finalSRew;\r\n        //Referral Reward\r\n        pushStatement(\r\n            msg.sender,\r\n            user[msg.sender].ref_address,\r\n            id,\r\n            3,\r\n            staking[id].value,\r\n            0,\r\n            refper,\r\n            finalRefIncome,\r\n            0,\r\n            user[user[msg.sender].ref_address].balance + finalRefIncome //refbalance\r\n        );\r\n\r\n        user[user[msg.sender].ref_address].balance += finalRefIncome;\r\n        user[user[msg.sender].ref_address].refIncome += finalRefIncome;\r\n\r\n        stakingReward.push(\r\n            StakingRew({\r\n                user: msg.sender,\r\n                time: block.timestamp,\r\n                value: sreward,\r\n                amount: staking[id].value,\r\n                per: packages[staking[id].package].monthly,\r\n                id: id,\r\n                burn: ((sreward * claimFee) / 100e18)\r\n            })\r\n        );\r\n\r\n        refReward.push(\r\n            RefReward({\r\n                from: msg.sender,\r\n                to: user[msg.sender].ref_address,\r\n                time: block.timestamp,\r\n                value: refIncome,\r\n                amount: staking[id].value,\r\n                per: refper,\r\n                id: id,\r\n                duration:packages[staking[id].package].duration,\r\n                burn: ((refIncome * claimFee) / 100e18)\r\n            })\r\n        );\r\n\r\n        IERC20(token).transfer(msg.sender, finalSRew);\r\n        IERC20(token).transfer(user[msg.sender].ref_address, finalRefIncome);\r\n        IERC20(token).burn(((sreward * claimFee) / 100e18) +  ((refIncome * claimFee) / 100e18));\r\n        //transfertoken and burn\r\n        emit ClaimReward(id, msg.sender, finalSRew,finalRefIncome,user[msg.sender].ref_address,block.timestamp);\r\n    }\r\n\r\n    function getStakings(address u)\r\n        public\r\n        view\r\n        returns (Staking[] memory filteredStaking)\r\n    {\r\n        Staking[] memory stakeTemp = new Staking[](stakeArray.length);\r\n        uint256 count;\r\n        for (uint256 i = 0; i < stakeArray.length; i++) {\r\n            if (stakeArray[i].user == u) {\r\n                stakeTemp[count] = stakeArray[i];\r\n                count += 1;\r\n            }\r\n        }\r\n        filteredStaking = new Staking[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            filteredStaking[i] = stakeTemp[i];\r\n        }\r\n    }\r\n\r\n    function getStakings()\r\n        public\r\n        view\r\n        returns (Staking[] memory filteredStaking)\r\n    {\r\n        filteredStaking = stakeArray;\r\n    }\r\n\r\n    function getRefReward(address u)\r\n        public\r\n        view\r\n        returns (RefReward[] memory filteredRefReward)\r\n    {\r\n        RefReward[] memory RefRewardTemp = new RefReward[](refReward.length);\r\n        uint256 count;\r\n        for (uint256 i = 0; i < refReward.length; i++) {\r\n            if (refReward[i].to == u) {\r\n                RefRewardTemp[count] = refReward[i];\r\n                count += 1;\r\n            }\r\n        }\r\n        filteredRefReward = new RefReward[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            filteredRefReward[i] = RefRewardTemp[i];\r\n        }\r\n    }\r\n\r\n    function getRefReward()\r\n        public\r\n        view\r\n        returns (RefReward[] memory filteredRefReward)\r\n    {\r\n        filteredRefReward = refReward;\r\n    }\r\n\r\n    function getStakeReward(address u)\r\n        public\r\n        view\r\n        returns (StakingRew[] memory filteredStakingRew)\r\n    {\r\n        StakingRew[] memory StakingRewTemp = new StakingRew[](\r\n            stakingReward.length\r\n        );\r\n        uint256 count;\r\n        for (uint256 i = 0; i < stakingReward.length; i++) {\r\n            if (stakingReward[i].user == u) {\r\n                StakingRewTemp[count] = stakingReward[i];\r\n                count += 1;\r\n            }\r\n        }\r\n        filteredStakingRew = new StakingRew[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            filteredStakingRew[i] = StakingRewTemp[i];\r\n        }\r\n    }\r\n\r\n    function getStakeReward()\r\n        public\r\n        view\r\n        returns (StakingRew[] memory filteredStakingRew)\r\n    {\r\n        filteredStakingRew = stakingReward;\r\n    }\r\n\r\n    function getUnstake(address u)\r\n        public\r\n        view\r\n        returns (Unstake[] memory filteredUnstake)\r\n    {\r\n        Unstake[] memory UnstakeTemp = new Unstake[](unstake.length);\r\n        uint256 count;\r\n        for (uint256 i = 0; i < unstake.length; i++) {\r\n            if (unstake[i].user == u) {\r\n                UnstakeTemp[count] = unstake[i];\r\n                count += 1;\r\n            }\r\n        }\r\n        filteredUnstake = new Unstake[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            filteredUnstake[i] = UnstakeTemp[i];\r\n        }\r\n    }\r\n\r\n    function getUnstake()\r\n        public\r\n        view\r\n        returns (Unstake[] memory filteredUnstake)\r\n    {\r\n        filteredUnstake = unstake;\r\n    }\r\n\r\n    function getStatement(address u)\r\n        public\r\n        view\r\n        returns (Statement[] memory filteredStatement)\r\n    {\r\n        Statement[] memory StatementTemp = new Statement[](statements.length);\r\n        uint256 count;\r\n        for (uint256 i = 0; i < statements.length; i++) {\r\n            if (statements[i].user == u) {\r\n                StatementTemp[count] = statements[i];\r\n                count += 1;\r\n            }\r\n        }\r\n        filteredStatement = new Statement[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            filteredStatement[i] = StatementTemp[i];\r\n        }\r\n    }\r\n\r\n    function withdrawlToken(address tokenAddress,uint256 value) public onlyOwner {\r\n        IERC20(tokenAddress).transfer(msg.sender,value);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refreward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refaddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Farm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWithdrawals\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"charge\",\"type\":\"uint256\"}],\"name\":\"Unfarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"changeAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"changeApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeClaimFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"changeRefRewardPer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"checkROIBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"months\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"checkTokenAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remains\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"checkUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"checkrefbonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"refbinc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"checkrefbonus\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bonus\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"checkreferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmer\",\"type\":\"address\"}],\"name\":\"checkuserbonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defaultAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"extraInfo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthly\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawalDays\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"farm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farmersList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"half\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"getMonthlyAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"monthly\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daily\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRefReward\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"per\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.RefReward[]\",\"name\":\"filteredRefReward\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getRefReward\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"per\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.RefReward[]\",\"name\":\"filteredRefReward\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getReferrers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"referrers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getStakeReward\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"per\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.StakingRew[]\",\"name\":\"filteredStakingRew\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeReward\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"per\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.StakingRew[]\",\"name\":\"filteredStakingRew\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getStakings\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmingreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.Staking[]\",\"name\":\"filteredStaking\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakings\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmingreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.Staking[]\",\"name\":\"filteredStaking\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getStatement\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.Statement[]\",\"name\":\"filteredStatement\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnstake\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deduction\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.Unstake[]\",\"name\":\"filteredUnstake\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getUnstake\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deduction\",\"type\":\"uint256\"}],\"internalType\":\"struct ox2Farming.Unstake[]\",\"name\":\"filteredUnstake\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"getUserIds\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"ids\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthly\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"readData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalActiveStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLockedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLockedUsds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalActiveLockedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalActiveLockedUsds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHarvests\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRefRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"per\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requireActive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeArray\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmingreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmingreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"per\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"statements\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refper\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalActiveLockedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalActiveLockedUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedUsd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRefReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unFarmCharge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"unfarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deduction\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ref_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"finalEndtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deductions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeUsers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"userExists\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"exist\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawlToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ox2Farming", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f24abf121797c5c25f7aee47ac7b538251b7aa458a117164039e1b4ed253b201"}