{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title \"Zap\" Depositer for permissionless factory metapools\r\n@notice Compatible with metapools using val3EPS and 3EPS as a base\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2021 - all rights reserved\r\n\"\"\"\r\n\r\ninterface ERC20:\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def transfer(_to: address, _amount: uint256) -> bool: nonpayable\r\n    def transferFrom(_from: address, _to: address, _amount: uint256) -> bool: nonpayable\r\n\r\ninterface CurveMeta:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) -> uint256: nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\r\n    def lp_token() -> address: view\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CurveBase:\r\n    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[BASE_N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[BASE_N_COINS], max_burn_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[BASE_N_COINS], deposit: bool) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def fee() -> uint256: view\r\n\r\n\r\nBASE_N_COINS: constant(int128) = 3\r\nBASE_COINS: constant(address[BASE_N_COINS]) = [\r\n    0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56,  # BUSD\r\n    0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d,  # USDC\r\n    0x55d398326f99059fF775485246999027B3197955,  # USDT\r\n]\r\nN_COINS: constant(int128) = 2\r\nMAX_COIN: constant(int128) = N_COINS-1\r\nN_ALL_COINS: constant(int128) = N_COINS + BASE_N_COINS - 1\r\n\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nFEE_IMPRECISION: constant(uint256) = 100 * 10 ** 8  # % of the fee\r\n\r\n# coin -> pool -> is approved to transfer?\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\n\r\nlp_token_to_base_pool: public(HashMap[address, address])\r\npool_to_base_pool: public(HashMap[address, address[2]])\r\n\r\nowner: public(address)\r\n\r\n\r\n@external\r\ndef __init__():\r\n    self.owner = msg.sender\r\n\r\n\r\n@external\r\ndef add_base_pool(_pool: address, _lp_token: address):\r\n    assert msg.sender == self.owner\r\n    self.lp_token_to_base_pool[_lp_token] = _pool\r\n\r\n\r\n@external\r\ndef recover_tokens(_token: address, _amount: uint256):\r\n    assert msg.sender == self.owner\r\n    response: Bytes[32] = raw_call(\r\n        _token,  # metapool coin 0\r\n        _abi_encode(\r\n            msg.sender,\r\n            _amount,\r\n            method_id=method_id(\"transfer(address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n\r\n\r\n@internal\r\ndef _get_base_pool(_pool: address) -> (address, address):\r\n    base_pool: address[2] = self.pool_to_base_pool[_pool]\r\n\r\n    if base_pool[0] == ZERO_ADDRESS:\r\n        base_pool[1] = CurveMeta(_pool).coins(1)\r\n        base_pool[0] = self.lp_token_to_base_pool[base_pool[1]]\r\n        assert base_pool[0] != ZERO_ADDRESS, \"Zap does not support this base pool\"\r\n        self.pool_to_base_pool[_pool] = base_pool\r\n        for coin in BASE_COINS:\r\n            ERC20(coin).approve(base_pool[0], MAX_UINT256)\r\n\r\n    return base_pool[0], base_pool[1]\r\n\r\n\r\n@external\r\ndef add_liquidity(\r\n    _pool: address,\r\n    _deposit_amounts: uint256[N_ALL_COINS],\r\n    _min_mint_amount: uint256,\r\n    _receiver: address = msg.sender,\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Wrap underlying coins and deposit them into `_pool`\r\n    @param _pool Address of the pool to deposit into\r\n    @param _deposit_amounts List of amounts of underlying coins to deposit\r\n    @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n\r\n    if _deposit_amounts[0] != 0:\r\n        coin: address = CurveMeta(_pool).coins(0)\r\n        if not self.is_approved[coin][_pool]:\r\n            ERC20(coin).approve(_pool, MAX_UINT256)\r\n            self.is_approved[coin][_pool] = True\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                msg.sender,\r\n                self,\r\n                _deposit_amounts[0],\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n        # hand fee on transfer\r\n        meta_amounts[0] = ERC20(coin).balanceOf(self)\r\n\r\n    for i in range(1, N_ALL_COINS):\r\n        amount: uint256 = _deposit_amounts[i]\r\n        if amount == 0:\r\n            continue\r\n        deposit_base = True\r\n        base_idx: uint256 = i - 1\r\n        coin: address = base_coins[base_idx]\r\n\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                msg.sender,\r\n                self,\r\n                amount,\r\n                method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n        # Handle potential transfer fees (i.e. Tether/renBTC)\r\n        base_amounts[base_idx] = ERC20(coin).balanceOf(self)\r\n\r\n    # Deposit to the base pool\r\n    if deposit_base:\r\n        base_pool: address = ZERO_ADDRESS\r\n        base_token: address = ZERO_ADDRESS\r\n        base_pool, base_token = self._get_base_pool(_pool)\r\n        CurveBase(base_pool).add_liquidity(base_amounts, 0)\r\n        meta_amounts[MAX_COIN] = ERC20(base_token).balanceOf(self)\r\n        if not self.is_approved[base_token][_pool]:\r\n            ERC20(base_token).approve(_pool, MAX_UINT256)\r\n            self.is_approved[base_token][_pool] = True\r\n\r\n    # Deposit to the meta pool\r\n    received: uint256 = CurveMeta(_pool).add_liquidity(meta_amounts, _min_mint_amount)\r\n    lp_token: address = CurveMeta(_pool).lp_token()\r\n    ERC20(lp_token).transfer(_receiver, received)\r\n    return received\r\n\r\n\r\n@external\r\ndef remove_liquidity(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    _min_amounts: uint256[N_ALL_COINS],\r\n    _receiver: address = msg.sender\r\n) -> uint256[N_ALL_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _pool Address of the pool to deposit into\r\n    @param _burn_amount Quantity of LP tokens to burn in the withdrawal\r\n    @param _min_amounts Minimum amounts of underlying coins to receive\r\n    @param _receiver Address that receives the LP tokens\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    lp_token: address = CurveMeta(_pool).lp_token()\r\n    ERC20(lp_token).transferFrom(msg.sender, self, _burn_amount)\r\n\r\n    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\r\n\r\n    # Withdraw from meta\r\n    meta_received: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    CurveMeta(_pool).remove_liquidity(_burn_amount, [_min_amounts[0], convert(0, uint256)])\r\n\r\n    coins: address[N_COINS] = empty(address[N_COINS])\r\n    for i in range(N_COINS):\r\n        coin: address = CurveMeta(_pool).coins(i)\r\n        coins[i] = coin\r\n        # Handle fee on transfer for the first coin\r\n        meta_received[i] = ERC20(coin).balanceOf(self)\r\n\r\n    # Withdraw from base\r\n    for i in range(BASE_N_COINS):\r\n        min_amounts_base[i] = _min_amounts[MAX_COIN+i]\r\n\r\n    base_pool: address = self._get_base_pool(_pool)[0]\r\n    CurveBase(base_pool).remove_liquidity(meta_received[MAX_COIN], min_amounts_base)\r\n\r\n    # Transfer all coins out\r\n    response: Bytes[32] = raw_call(\r\n        coins[0],  # metapool coin 0\r\n        _abi_encode(\r\n            _receiver,\r\n            meta_received[0],\r\n            method_id=method_id(\"transfer(address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    amounts[0] = meta_received[0]\r\n\r\n    base_coins: address[BASE_N_COINS] = BASE_COINS\r\n    for i in range(1, N_ALL_COINS):\r\n        coin: address = base_coins[i-1]\r\n        # handle potential fee on transfer\r\n        amounts[i] = ERC20(coin).balanceOf(self)\r\n        response = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                _receiver,\r\n                amounts[i],\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(\r\n    _pool: address,\r\n    _burn_amount: uint256,\r\n    i: int128,\r\n    _min_amount: uint256,\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap a single coin from the pool\r\n    @param _pool Address of the pool to deposit into\r\n    @param _burn_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of underlying coin to receive\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    lp_token: address = CurveMeta(_pool).lp_token()\r\n    response: Bytes[32] = raw_call(\r\n        lp_token,\r\n        _abi_encode(\r\n            msg.sender,\r\n            self,\r\n            _burn_amount,\r\n            method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n\r\n    coin_amount: uint256 = 0\r\n    coin: address = ZERO_ADDRESS\r\n    if i == 0:\r\n        coin_amount = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, i, _min_amount)\r\n        coin = CurveMeta(_pool).coins(0)\r\n    else:\r\n        base_coins: address[BASE_N_COINS] = BASE_COINS\r\n        coin = base_coins[i - MAX_COIN]\r\n        # Withdraw a base pool coin\r\n        coin_amount = CurveMeta(_pool).remove_liquidity_one_coin(_burn_amount, MAX_COIN, 0)\r\n        base_pool: address = self._get_base_pool(_pool)[0]\r\n        CurveBase(base_pool).remove_liquidity_one_coin(coin_amount, i-MAX_COIN, _min_amount)\r\n        coin_amount = ERC20(coin).balanceOf(self)\r\n\r\n    response = raw_call(\r\n        coin,\r\n        _abi_encode(\r\n            _receiver,\r\n            coin_amount,\r\n            method_id=method_id(\"transfer(address,uint256)\"),\r\n        ),\r\n        max_outsize=32\r\n    )\r\n    if len(response) != 0:\r\n        assert convert(response, bool)\r\n\r\n    return coin_amount\r\n\r\n\r\n@external\r\ndef remove_liquidity_imbalance(\r\n    _pool: address,\r\n    _amounts: uint256[N_ALL_COINS],\r\n    _max_burn_amount: uint256,\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts List of amounts of underlying coins to withdraw\r\n    @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal\r\n    @param _receiver Address that receives the LP tokens\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n    base_pool: address = ZERO_ADDRESS\r\n    base_token: address = ZERO_ADDRESS\r\n    base_pool, base_token = self._get_base_pool(_pool)\r\n    fee: uint256 = CurveBase(base_pool).fee() * BASE_N_COINS / (4 * (BASE_N_COINS - 1))\r\n    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\r\n    lp_token: address = CurveMeta(_pool).lp_token()\r\n    # Transfer the LP token in\r\n    ERC20(lp_token).transferFrom(msg.sender, self, _max_burn_amount)\r\n\r\n    withdraw_base: bool = False\r\n    amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    # determine amounts to withdraw from base pool\r\n    for i in range(BASE_N_COINS):\r\n        amount: uint256 = _amounts[MAX_COIN + i]\r\n        if amount != 0:\r\n            amounts_base[i] = amount\r\n            withdraw_base = True\r\n\r\n    # determine amounts to withdraw from metapool\r\n    amounts_meta[0] = _amounts[0]\r\n    if withdraw_base:\r\n        amounts_meta[MAX_COIN] = CurveBase(base_pool).calc_token_amount(amounts_base, False)\r\n        amounts_meta[MAX_COIN] += amounts_meta[MAX_COIN] * fee / FEE_DENOMINATOR + 1\r\n\r\n    # withdraw from metapool and return the remaining LP tokens\r\n    burn_amount: uint256 = CurveMeta(_pool).remove_liquidity_imbalance(amounts_meta, _max_burn_amount)\r\n    ERC20(lp_token).transfer(msg.sender, _max_burn_amount - burn_amount)\r\n\r\n    # withdraw from base pool\r\n    if withdraw_base:\r\n        CurveBase(base_pool).remove_liquidity_imbalance(amounts_base, amounts_meta[MAX_COIN])\r\n        leftover: uint256 = ERC20(base_token).balanceOf(self)\r\n\r\n        if leftover > 0:\r\n            # if some base pool LP tokens remain, re-deposit them for the caller\r\n            if not self.is_approved[base_token][_pool]:\r\n                ERC20(base_token).approve(_pool, MAX_UINT256)\r\n                self.is_approved[base_token][_pool] = True\r\n            burn_amount -= CurveMeta(_pool).add_liquidity([convert(0, uint256), leftover], 0)\r\n\r\n        # transfer withdrawn base pool tokens to caller\r\n        base_coins: address[BASE_N_COINS] = BASE_COINS\r\n        for i in range(BASE_N_COINS):\r\n            response: Bytes[32] = raw_call(\r\n                base_coins[i],\r\n                _abi_encode(\r\n                    _receiver,\r\n                    ERC20(base_coins[i]).balanceOf(self),  # handle potential transfer fees\r\n                    method_id=method_id(\"transfer(address,uint256)\"),\r\n                ),\r\n                max_outsize=32\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n\r\n\r\n    # transfer withdrawn metapool tokens to caller\r\n    if _amounts[0] > 0:\r\n        coin: address = CurveMeta(_pool).coins(0)\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            _abi_encode(\r\n                _receiver,\r\n                ERC20(coin).balanceOf(self),  # handle potential fees\r\n                method_id=method_id(\"transfer(address,uint256)\"),\r\n            ),\r\n            max_outsize=32\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n\r\n    return burn_amount\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_pool: address, _token_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing and unwrapping a single coin\r\n    @param _pool Address of the pool to deposit into\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the underlying coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    if i < MAX_COIN:\r\n        return CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, i)\r\n    else:\r\n        _base_tokens: uint256 = CurveMeta(_pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\r\n        base_pool: address = self.lp_token_to_base_pool[CurveMeta(_pool).coins(1)]\r\n        return CurveBase(base_pool).calc_withdraw_one_coin(_base_tokens, i-MAX_COIN)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(_pool: address, _amounts: uint256[N_ALL_COINS], _is_deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @dev This calculation accounts for slippage, but not fees.\r\n         Needed to prevent front-running, not for precise calculations!\r\n    @param _pool Address of the pool to deposit into\r\n    @param _amounts Amount of each underlying coin being deposited\r\n    @param _is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n\r\n    meta_amounts[0] = _amounts[0]\r\n    for i in range(BASE_N_COINS):\r\n        base_amounts[i] = _amounts[i + MAX_COIN]\r\n\r\n    base_pool: address = self.lp_token_to_base_pool[CurveMeta(_pool).coins(1)]\r\n    base_tokens: uint256 = CurveBase(base_pool).calc_token_amount(base_amounts, _is_deposit)\r\n    meta_amounts[MAX_COIN] = base_tokens\r\n\r\n    return CurveMeta(_pool).calc_token_amount(meta_amounts, _is_deposit)", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_base_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_lp_token\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37871},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover_tokens\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":7497},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":225523},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_deposit_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":225523},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"gas\":47599},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_min_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"gas\":47599},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":23725},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_burn_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":23725},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":202256},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_max_burn_amount\",\"type\":\"uint256\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":202256},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":10524},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_amounts\",\"type\":\"uint256[4]\"},{\"name\":\"_is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":11456},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_token_to_base_pool\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2966},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_to_base_pool\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3041},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2760}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}