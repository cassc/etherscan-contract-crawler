{"SourceCode": "/*\r\nSniperDAO (sDAO) - t.me/SniperDAO_official\r\n*/\r\n\r\n// SPDX-License-Identifier: none\r\npragma solidity ^0.8.19;\r\n\r\nlibrary SafeTransferLib {\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\r\n\r\n            success := and(\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function balanceOf(address token, address wallet) internal view returns (uint256 result) {\r\n        bool success;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // keccak256('balanceOf(address)') bitmasked to 4 bytes\r\n            mstore(freeMemoryPointer, 0x70a0823100000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), and(wallet, 0xffffffffffffffffffffffffffffffffffffffff))\r\n\r\n            success := staticcall(gas(), token, freeMemoryPointer, 36, freeMemoryPointer, 32)\r\n            if eq(success, 1) {\r\n                result := mload(freeMemoryPointer)\r\n            }\r\n        }\r\n\r\n        require(success, \"balanceOf_failed\");\r\n    }\r\n}\r\n\r\nabstract contract Auth {\r\n    event OwnershipTransferred(address owner);\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    address public owner;\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"!OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n}\r\n\r\ninterface IDexFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface V2Pair {\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n}\r\n\r\ncontract DEPLOY_WITH_LIQUIDITY {\r\n    constructor() payable {\r\n        require(msg.value >= 1000, \"minimum is 1000 wei\");\r\n\r\n        address router;\r\n        if (block.chainid == 56) {\r\n            router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;  // PancakeSwap\r\n        } else if (block.chainid == 1) {\r\n            router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;  // UniswapV2\r\n        } else revert();\r\n\r\n        // bytes memory bytecode = type(TEMPLATE_NAME).creationCode;\r\n        sDAO _contract = new sDAO();\r\n        uint256 liquidityAmount = SafeTransferLib.balanceOf(address(_contract), address(this));\r\n\r\n        (bool success,) = router.call{gas : gasleft(), value: msg.value}(\r\n            // addLiquidityETH(address,uint256,uint256,uint256,address,uint256)\r\n            abi.encodeWithSelector(\r\n                0xf305d719,\r\n                address(_contract),\r\n                liquidityAmount,\r\n                0,\r\n                0,\r\n                tx.origin,\r\n                block.timestamp\r\n            )\r\n        );\r\n\r\n        require(success, \"ADD_LIQUIDITY_ETH_FAILED\");\r\n    }\r\n}\r\n\r\ncontract sDAO is Auth {\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    address wrapped;\r\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address constant ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    uint8 constant public decimals = 4;\r\n    string public name = \"SniperDAO\";\r\n    string public symbol = \"sDAO\";\r\n\r\n    uint256 public totalSupply = 10_000_000 * (10 ** decimals);\r\n    uint256 public max_tx = totalSupply / 1000 * 10;     // 1% of total supply initially\r\n    uint256 public max_wallet = totalSupply / 1000 * 20; // 2% of total supply initially\r\n    \r\n    mapping (address => mapping(address => uint256)) public allowance;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => bool) public isPair;\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isLimitExempt;\r\n\r\n    uint256 constant public feeDenominator = 1000;  // 100%\r\n    uint256 public projectFee = 60;                 // 6% fee\r\n    address public feeReceiver;\r\n    uint256 clown = 1001;\r\n\r\n    bool private antiBot = true;\r\n\tuint256 private antiFeeBlocks = 1;\r\n    mapping (address => uint) private blockTime;\r\n\r\n    uint256 launchedAt = 0;\r\n    address public router;\r\n    address public factory;\r\n    address public mainPair;\r\n    address[] public pairs;\r\n\r\n    modifier swapping() { inContractSwap = true; _; inContractSwap = false; }\r\n    uint256 public smallSwapThreshold = totalSupply / 1000; // 0,1% of total supply\r\n    uint256 public largeSwapThreshold = totalSupply / 500;  // 0,2% of total supply\r\n    uint256 public swapThreshold = smallSwapThreshold;\r\n    bool public swapEnabled = true;\r\n    bool inContractSwap;\r\n\r\n    constructor() Auth(tx.origin) {\r\n        if (block.chainid == 56) {\r\n            // BSC Mainnet\r\n            wrapped = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; // WBNB\r\n            factory = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73; // PancakeSwap\r\n            router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;  // PancakeSwap\r\n        } else if (block.chainid == 1) {\r\n            // Ethereum Mainnet\r\n            wrapped = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; // WETH\r\n            factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // UniswapV2\r\n            router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;  // UniswapV2\r\n        } else revert();\r\n\r\n        address deployer = tx.origin;\r\n        address liquidityDeployer = msg.sender;\r\n        allowance[address(this)][address(router)] = type(uint256).max;\r\n        allowance[liquidityDeployer][address(router)] = type(uint256).max;\r\n\r\n        mainPair = IDexFactory(factory).createPair(wrapped, address(this));\r\n        isPair[mainPair] = true;\r\n        pairs.push(mainPair);\r\n        \r\n        feeReceiver = deployer;\r\n        isFeeExempt[router] = true;\r\n        isFeeExempt[deployer] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isLimitExempt[router] = true;\r\n        isLimitExempt[deployer] = true;\r\n        isLimitExempt[address(this)] = true;\r\n        isLimitExempt[DEAD] = true;\r\n        isLimitExempt[ZERO] = true;\r\n\r\n        if (liquidityDeployer != deployer) {\r\n            isFeeExempt[liquidityDeployer] = true;\r\n            isLimitExempt[liquidityDeployer] = true;\r\n            authorizations[liquidityDeployer] = true;\r\n\r\n            uint256 liquidityAmount = totalSupply / 100 * 95; // 95% of totalSupply in liquidity\r\n            uint256 deployerTokens = totalSupply - liquidityAmount;\r\n\r\n            unchecked {\r\n                balanceOf[deployer] += deployerTokens;\r\n                balanceOf[liquidityDeployer] += liquidityAmount;\r\n                emit Transfer(address(0), deployer, deployerTokens);\r\n                emit Transfer(address(0), liquidityDeployer, liquidityAmount);\r\n            }\r\n        } else {\r\n            unchecked {\r\n                balanceOf[deployer] += totalSupply;\r\n                emit Transfer(address(0), deployer, totalSupply);\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return totalSupply - balanceOf[DEAD] - balanceOf[ZERO];\r\n    }\r\n\r\n    function launched() internal view returns (bool) {\r\n        return launchedAt != 0;\r\n    }\r\n\r\n    function launch() internal {\r\n        launchedAt = block.number;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////// TRANSFER //////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool) {\r\n        uint256 allowed = allowance[sender][msg.sender];\r\n        if (allowed != type(uint256).max) allowance[sender][msg.sender] = allowed - amount;\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if (!launched() && isPair[recipient]) {\r\n            require(isAuthorized(sender), \"!OWNER\");\r\n            launch();\r\n        }\r\n        if (inContractSwap) return _basicTransfer(sender, recipient, amount);\r\n\r\n        checkTxLimit(sender, recipient, amount);\r\n        if (shouldSwapBack(recipient)) swapBack(recipient);\r\n\r\n        balanceOf[sender] -= amount;\r\n        uint256 amountReceived = amount;\r\n        \r\n        if (isPair[sender] || isPair[recipient]) {\r\n            amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\r\n        }\r\n\r\n        unchecked {\r\n            balanceOf[recipient] += amountReceived;\r\n            emit Transfer(sender, recipient, amountReceived);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        balanceOf[sender] -= amount;\r\n\r\n        unchecked {\r\n            balanceOf[recipient] += amount;\r\n            emit Transfer(msg.sender, recipient, amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////// LIMITS //////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function checkTxLimit(address sender, address recipient, uint256 amount) internal view {\r\n        // verify sender max_tx\r\n        require(amount <= max_tx || isPair[sender] && isLimitExempt[recipient] || isLimitExempt[sender], \"TRANSACTION_LIMIT_EXCEEDED\");\r\n\r\n        // verify recipient max_wallet\r\n        if (recipient != owner && !isLimitExempt[recipient] && !isPair[recipient]) {\r\n            uint256 newBalance = balanceOf[recipient] + amount;\r\n            require(newBalance <= max_wallet, \"WALLET_LIMIT_EXCEEDED\");\r\n        }\r\n    }\r\n\r\n    function changeMaxTx(uint256 percent, uint256 denominator) external authorized { \r\n        max_tx = totalSupply * percent / denominator;\r\n        require(max_tx >= totalSupply * 10 / 1000, \"Max tx must be greater than 1%\");\r\n    }\r\n    \r\n    function changeMaxWallet(uint256 percent, uint256 denominator) external authorized {\r\n        max_wallet = totalSupply * percent / denominator;\r\n        require(max_wallet >= totalSupply * 10 / 1000, \"Max wallet must be greater than 1%\");\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsLimitExempt(address holder, bool exempt) external authorized {\r\n        isLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////////////////////////////// FEE ///////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    \r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        return !isFeeExempt[sender] && !isFeeExempt[recipient] && projectFee > 0;\r\n    }\r\n\r\n    function takeFee(address sender, uint256 amount) internal returns (uint256) {\r\n        uint256 feeAmount = 0;\r\n\r\n        if (antiBot && isPair[sender] && !isLimitExempt[tx.origin] && amount >= totalSupply / 10000 * 11) {\r\n            if (blockTime[tx.origin] == block.timestamp || block.number - launchedAt <= antiFeeBlocks) {\r\n                // high fee to clowns\r\n                feeAmount = amount * feeDenominator / clown;\r\n            } else {\r\n                // normal fee\r\n                feeAmount = amount / feeDenominator * projectFee;\r\n            }\r\n            blockTime[tx.origin] = block.timestamp;\r\n        } else {\r\n            // normal fee\r\n            feeAmount = amount / feeDenominator * projectFee;\r\n        }\r\n        \r\n        unchecked {\r\n            balanceOf[address(this)] += feeAmount;\r\n            emit Transfer(sender, address(this), feeAmount);\r\n        }\r\n\r\n        return amount - feeAmount;\r\n    }\r\n\r\n    function adjustFees(uint256 _projectFee) external authorized {\r\n        require(_projectFee <= feeDenominator / 10); // projectFee must be less or equal 10%\r\n        projectFee = _projectFee;\r\n    }\r\n\r\n    function setFeeReceivers(address _feeReceiver) external authorized {\r\n        feeReceiver = _feeReceiver;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////// CONTRCT SWAP ////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function shouldSwapBack(address recipient) internal view returns (bool) {\r\n        return (\r\n            swapEnabled &&\r\n            projectFee > 0 &&\r\n            isPair[recipient] &&\r\n            balanceOf[address(this)] >= swapThreshold &&\r\n\r\n            // This is to avoid having a large impact if there is little token in liquidity\r\n            SafeTransferLib.balanceOf(address(this), recipient) > swapThreshold * 10\r\n        );\r\n    }\r\n\r\n    function swapBack(address pairSwap) internal swapping {\r\n        address[] memory path;\r\n        uint256 amountToSwap = swapThreshold;\r\n\r\n        if (pairSwap == mainPair) {\r\n            // THIS_TOKEN -> WRAPPED\r\n            path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = wrapped;\r\n        } else {\r\n            V2Pair pair = V2Pair(pairSwap);\r\n            address token0 = pair.token0();\r\n            address token1 = pair.token1();\r\n            \r\n            // THIS_TOKEN -> UNKNOWN_TOKEN -> WRAPPED\r\n            path = new address[](3);\r\n            path[0] = address(this);\r\n            // path[1] = UNKNOWN_TOKEN;\r\n            path[2] = wrapped;\r\n\r\n            if (token0 != address(this)) {\r\n                path[1] = token0;\r\n            } else {\r\n                path[1] = token1;\r\n            }\r\n        }\r\n\r\n        (bool success,) = router.call{gas : gasleft()}(\r\n            //swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)\r\n            abi.encodeWithSelector(\r\n                0x791ac947,\r\n                amountToSwap,\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            )\r\n        );\r\n        \r\n        if (pairSwap == mainPair) require(success, \"SWAPBACK_FAILED\");\r\n        SafeTransferLib.safeTransferETH(feeReceiver, address(this).balance);\r\n        swapThreshold = swapThreshold == smallSwapThreshold ? largeSwapThreshold : smallSwapThreshold;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _smallAmount, uint256 _largeAmount) external authorized {\r\n        require(_smallAmount <= totalSupply * 25 / 10000, \"Small swap threshold must be lower\"); // smallSwapThreshold  <= 0,25% of total supply\r\n        require(_largeAmount <= totalSupply * 5 / 1000, \"Large swap threshold must be lower\");   // largeSwapThreshold  <= 0,5% of total supply\r\n\r\n        swapEnabled = _enabled;\r\n        smallSwapThreshold = _smallAmount;\r\n        largeSwapThreshold = _largeAmount;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////////////////////////// OTHERS /////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function updateTokenDetails(string calldata newName, string calldata newSymbol) external authorized {\r\n        name = newName;\r\n        symbol = newSymbol;\r\n    }\r\n\r\n\tfunction rescue() external authorized {\r\n        SafeTransferLib.safeTransferETH(feeReceiver, address(this).balance);\r\n    }\r\n\r\n    function rescueToken(address _token, uint256 amount) external authorized {\r\n        require(_token != address(this), \"STOP\");\r\n        SafeTransferLib.safeTransfer(_token, feeReceiver, amount);\r\n    }\r\n\r\n    function burnContractTokens(uint256 amount) external authorized {\r\n        SafeTransferLib.safeTransfer(address(this), DEAD, amount);\r\n    }\r\n\r\n    function createNewPair(address token) external authorized {\r\n        address new_pair = IDexFactory(factory).createPair(token, address(this));\r\n        isPair[new_pair] = true;\r\n        pairs.push(new_pair);\r\n    }\r\n\r\n    function setNewPair(address pair) external authorized {\r\n        isPair[pair] = true;\r\n        pairs.push(pair);\r\n    }\r\n\r\n    function showPairList() public view returns(address[] memory){\r\n        return pairs;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n    //////////////////////////////////////////////////// ANTI-BOT /////////////////////////////////////////////////////////\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function disableAntiBot() external authorized {\r\n        antiBot = false;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"}],\"name\":\"adjustFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnContractTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"changeMaxTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"changeMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createNewPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAntiBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"largeSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_tx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_wallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setNewPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_smallAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_largeAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showPairList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smallSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"updateTokenDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "sDAO", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "25000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f245063ec33e4882e10fb7f41104fee1bf26b39ff0d500b3e72ff6c1131975d"}