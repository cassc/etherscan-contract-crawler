{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/OrderValidatorV2A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// LooksRare unopinionated libraries\\nimport {IERC165} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC165.sol\\\";\\nimport {IERC20} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\\\";\\nimport {IERC721} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC1155.sol\\\";\\nimport {IERC1271} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC1271.sol\\\";\\n\\n// Libraries\\nimport {OrderStructs} from \\\"../libraries/OrderStructs.sol\\\";\\nimport {MerkleProofCalldataWithNodes} from \\\"../libraries/OpenZeppelin/MerkleProofCalldataWithNodes.sol\\\";\\n\\n// Interfaces\\nimport {ICreatorFeeManager} from \\\"../interfaces/ICreatorFeeManager.sol\\\";\\nimport {IStrategy} from \\\"../interfaces/IStrategy.sol\\\";\\nimport {IRoyaltyFeeRegistry} from \\\"../interfaces/IRoyaltyFeeRegistry.sol\\\";\\n\\n// Shared errors\\nimport {OrderInvalid} from \\\"../errors/SharedErrors.sol\\\";\\n\\n// Other dependencies\\nimport {ExchangeProtocol} from \\\"../ExchangeProtocol.sol\\\";\\n\\n// Constants\\nimport \\\"../constants/ValidationCodeConstants.sol\\\";\\nimport {MAX_CALLDATA_PROOF_LENGTH, ONE_HUNDRED_PERCENT_IN_BP} from \\\"../constants/NumericConstants.sol\\\";\\n\\n// Enums\\nimport {CollectionType} from \\\"../enums/CollectionType.sol\\\";\\nimport {QuoteType} from \\\"../enums/QuoteType.sol\\\";\\n\\n/**\\n * @title OrderValidatorV2A\\n * @notice This contract is used to check the validity of maker ask/bid orders in the ExchangeProtocol (v2).\\n *         It performs checks for:\\n *         1. Protocol allowlist issues (i.e. currency or strategy not allowed)\\n *         2. Maker order-specific issues (e.g., order invalid due to format or other-strategy specific issues)\\n *         3. Nonce related issues (e.g., nonce executed or cancelled)\\n *         4. Signature related issues and merkle tree parameters\\n *         5. Timestamp related issues (e.g., order expired)\\n *         6. Asset-related issues for ERC20/ERC721/ERC1155 (approvals and balances)\\n *         7. Collection-type suggestions\\n *         8. Transfer manager related issues\\n *         9. Creator fee related issues (e.g., creator fee too high, ERC2981 bundles)\\n * @dev This version does not handle strategies with partial fills.\\n */\\ncontract OrderValidatorV2A {\\n    using OrderStructs for OrderStructs.Maker;\\n\\n    /**\\n     * @notice ERC721 potential interfaceId.\\n     */\\n    bytes4 public constant ERC721_INTERFACE_ID_1 = 0x5b5e139f;\\n\\n    /**\\n     * @notice ERC721 potential interfaceId.\\n     */\\n    bytes4 public constant ERC721_INTERFACE_ID_2 = 0x80ac58cd;\\n\\n    /**\\n     * @notice ERC1155 interfaceId.\\n     */\\n    bytes4 public constant ERC1155_INTERFACE_ID = 0xd9b67a26;\\n\\n    /**\\n     * @notice Magic value nonce returned if executed (or cancelled).\\n     */\\n    bytes32 public constant MAGIC_VALUE_ORDER_NONCE_EXECUTED = keccak256(\\\"ORDER_NONCE_EXECUTED\\\");\\n\\n    /**\\n     * @notice Number of distinct criteria groups checked to evaluate the validity of an order.\\n     */\\n    uint256 public constant CRITERIA_GROUPS = 9;\\n\\n    /**\\n     * @notice ExchangeProtocol domain separator.\\n     */\\n    bytes32 public domainSeparator;\\n\\n    /**\\n     * @notice Maximum creator fee (in basis point).\\n     */\\n    uint256 public maxCreatorFeeBp;\\n\\n    /**\\n     * @notice CreatorFeeManager.\\n     */\\n    ICreatorFeeManager public creatorFeeManager;\\n\\n    /**\\n     * @notice ExchangeProtocol.\\n     */\\n    ExchangeProtocol public exchangeProtocol;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _exchangeProtocol LooksRare protocol address\\n     * @dev It derives automatically other external variables such as the creator fee manager and domain separator.\\n     */\\n    constructor(address _exchangeProtocol) {\\n        exchangeProtocol = ExchangeProtocol(_exchangeProtocol);\\n\\n        _deriveProtocolParameters();\\n    }\\n\\n    /**\\n     * @notice Derive protocol parameters. Anyone can call this function.\\n     * @dev It allows adjusting if the domain separator or creator fee manager address were to change.\\n     */\\n    function deriveProtocolParameters() external {\\n        _deriveProtocolParameters();\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity of an array of maker orders.\\n     * @param makerOrders Array of maker orders\\n     * @param signatures Array of signatures\\n     * @param merkleTrees Array of merkle trees\\n     * @return validationCodes Arrays of validation codes\\n     */\\n    function checkMultipleMakerOrderValidities(\\n        OrderStructs.Maker[] calldata makerOrders,\\n        bytes[] calldata signatures,\\n        OrderStructs.MerkleTree[] calldata merkleTrees\\n    ) external view returns (uint256[9][] memory validationCodes) {\\n        uint256 length = makerOrders.length;\\n\\n        validationCodes = new uint256[CRITERIA_GROUPS][](length);\\n\\n        for (uint256 i; i < length; ) {\\n            validationCodes[i] = checkMakerOrderValidity(makerOrders[i], signatures[i], merkleTrees[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity of a maker order.\\n     * @param makerOrder Maker struct\\n     * @param signature Signature\\n     * @param merkleTree Merkle tree\\n     * @return validationCodes Array of validation codes\\n     */\\n    function checkMakerOrderValidity(\\n        OrderStructs.Maker calldata makerOrder,\\n        bytes calldata signature,\\n        OrderStructs.MerkleTree calldata merkleTree\\n    ) public view returns (uint256[9] memory validationCodes) {\\n        bytes32 orderHash = makerOrder.hash();\\n\\n        validationCodes[0] = _checkValidityCurrencyAndStrategy(\\n            makerOrder.quoteType,\\n            makerOrder.currency,\\n            makerOrder.strategyId\\n        );\\n\\n        // It will exit here if the strategy does not exist.\\n        // However, if the strategy is implemented but invalid (except if wrong quote type),\\n        // it can continue the validation process.\\n        if (validationCodes[0] == STRATEGY_NOT_IMPLEMENTED || validationCodes[0] == STRATEGY_INVALID_QUOTE_TYPE) {\\n            return validationCodes;\\n        }\\n\\n        uint256 validationCode1;\\n        uint256[] memory itemIds;\\n        uint256[] memory amounts;\\n        uint256 price;\\n\\n        if (makerOrder.quoteType == QuoteType.Ask) {\\n            (validationCode1, itemIds, amounts, price) = _checkValidityMakerAskItemIdsAndAmountsAndPrice(makerOrder);\\n        } else {\\n            (validationCode1, itemIds, , price) = _checkValidityMakerBidItemIdsAndAmountsAndPrice(makerOrder);\\n        }\\n\\n        validationCodes[1] = validationCode1;\\n\\n        validationCodes[2] = _checkValidityNonces(\\n            makerOrder.quoteType,\\n            makerOrder.signer,\\n            makerOrder.globalNonce,\\n            makerOrder.orderNonce,\\n            makerOrder.subsetNonce,\\n            orderHash\\n        );\\n\\n        validationCodes[3] = _checkValidityMerkleProofAndOrderHash(merkleTree, orderHash, signature, makerOrder.signer);\\n        validationCodes[4] = _checkValidityTimestamps(makerOrder.startTime, makerOrder.endTime);\\n\\n        validationCodes[3] = _checkValidityMerkleProofAndOrderHash(merkleTree, orderHash, signature, makerOrder.signer);\\n        validationCodes[4] = _checkValidityTimestamps(makerOrder.startTime, makerOrder.endTime);\\n\\n        if (makerOrder.quoteType == QuoteType.Bid) {\\n            validationCodes[5] = _checkValidityMakerBidERC20Assets(makerOrder.currency, makerOrder.signer, price);\\n        } else {\\n            validationCodes[5] = _checkValidityMakerAskNFTAssets(\\n                makerOrder.collection,\\n                makerOrder.collectionType,\\n                makerOrder.signer,\\n                itemIds,\\n                amounts\\n            );\\n        }\\n\\n        validationCodes[6] = _checkIfPotentialInvalidCollectionTypes(makerOrder.collection, makerOrder.collectionType);\\n\\n        if (makerOrder.quoteType == QuoteType.Bid) {\\n            validationCodes[7] = ORDER_EXPECTED_TO_BE_VALID;\\n        }\\n\\n        validationCodes[8] = _checkValidityCreatorFee(makerOrder.collection, price, itemIds);\\n    }\\n\\n    /**\\n     * @notice This function is private and is used to adjust the protocol parameters.\\n     */\\n    function _deriveProtocolParameters() private {\\n        domainSeparator = exchangeProtocol.domainSeparator();\\n        creatorFeeManager = exchangeProtocol.creatorFeeManager();\\n        maxCreatorFeeBp = exchangeProtocol.maxCreatorFeeBp();\\n    }\\n\\n    /**\\n     * @notice This function is private and verifies the validity of nonces for maker order.\\n     * @param makerSigner Address of the maker signer\\n     * @param globalNonce Global nonce\\n     * @param orderNonce Order nonce\\n     * @param subsetNonce Subset nonce\\n     * @param orderHash Order hash\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityNonces(\\n        QuoteType quoteType,\\n        address makerSigner,\\n        uint256 globalNonce,\\n        uint256 orderNonce,\\n        uint256 subsetNonce,\\n        bytes32 orderHash\\n    ) private view returns (uint256 validationCode) {\\n        // 1. Check subset nonce\\n        if (exchangeProtocol.userSubsetNonce(makerSigner, subsetNonce)) {\\n            return USER_SUBSET_NONCE_CANCELLED;\\n        }\\n\\n        // 2. Check order nonce\\n        bytes32 orderNonceStatus = exchangeProtocol.userOrderNonce(makerSigner, orderNonce);\\n\\n        if (orderNonceStatus == MAGIC_VALUE_ORDER_NONCE_EXECUTED) {\\n            return USER_ORDER_NONCE_EXECUTED_OR_CANCELLED;\\n        }\\n\\n        if (orderNonceStatus != bytes32(0) && orderNonceStatus != orderHash) {\\n            return USER_ORDER_NONCE_IN_EXECUTION_WITH_OTHER_HASH;\\n        }\\n\\n        // 3. Check global nonces\\n        (uint256 globalBidNonce, uint256 globalAskNonce) = exchangeProtocol.userBidAskNonces(makerSigner);\\n\\n        if (quoteType == QuoteType.Bid && globalNonce != globalBidNonce) {\\n            return INVALID_USER_GLOBAL_BID_NONCE;\\n        }\\n        if (quoteType == QuoteType.Ask && globalNonce != globalAskNonce) {\\n            return INVALID_USER_GLOBAL_ASK_NONCE;\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is private and verifies the validity of the currency and strategy.\\n     * @param quoteType Quote type\\n     * @param currency Address of the currency\\n     * @param strategyId Strategy id\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityCurrencyAndStrategy(\\n        QuoteType quoteType,\\n        address currency,\\n        uint256 strategyId\\n    ) private view returns (uint256 validationCode) {\\n        // 1. Verify whether the currency is allowed\\n        if (!exchangeProtocol.isCurrencyAllowed(currency)) {\\n            return CURRENCY_NOT_ALLOWED;\\n        }\\n\\n        if (currency == address(0) && quoteType == QuoteType.Bid) {\\n            return CURRENCY_NOT_ALLOWED;\\n        }\\n\\n        // 2. Verify whether the strategy is valid\\n        (bool strategyIsActive, , , , , bool strategyIsMakerBid, address strategyImplementation) = exchangeProtocol\\n            .strategyInfo(strategyId);\\n\\n        if (strategyId != 0 && strategyImplementation == address(0)) {\\n            return STRATEGY_NOT_IMPLEMENTED;\\n        }\\n\\n        if (strategyId != 0) {\\n            if (\\n                (strategyIsMakerBid && quoteType != QuoteType.Bid) ||\\n                (!strategyIsMakerBid && quoteType != QuoteType.Ask)\\n            ) {\\n                return STRATEGY_INVALID_QUOTE_TYPE;\\n            }\\n        }\\n\\n        if (!strategyIsActive) {\\n            return STRATEGY_NOT_ACTIVE;\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity for order timestamps.\\n     * @param startTime Start time\\n     * @param endTime End time\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityTimestamps(\\n        uint256 startTime,\\n        uint256 endTime\\n    ) private view returns (uint256 validationCode) {\\n        // @dev It is possible for startTime to be equal to endTime.\\n        // If so, the execution only succeeds when the startTime = endTime = block.timestamp.\\n        // For order invalidation, if the call succeeds, it is already too late for later execution since the\\n        // next block will have a greater timestamp than the current one.\\n        if (startTime >= endTime) {\\n            return START_TIME_GREATER_THAN_END_TIME;\\n        }\\n\\n        if (endTime <= block.timestamp) {\\n            return TOO_LATE_TO_EXECUTE_ORDER;\\n        }\\n        if (startTime >= block.timestamp + 5 minutes) {\\n            return TOO_EARLY_TO_EXECUTE_ORDER;\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is private and checks if the collection type may be potentially invalid.\\n     * @param collection Address of the collection\\n     * @param collectionType Collection type in the maker order\\n     * @return validationCode Validation code\\n     * @dev This function may return false positives.\\n     *      (i.e. collections that are tradable but do not implement the proper interfaceId).\\n     *      If ERC165 is not implemented, it will revert.\\n     */\\n    function _checkIfPotentialInvalidCollectionTypes(\\n        address collection,\\n        CollectionType collectionType\\n    ) private view returns (uint256 validationCode) {\\n        if (collectionType == CollectionType.ERC721) {\\n            bool isERC721 = IERC165(collection).supportsInterface(ERC721_INTERFACE_ID_1) ||\\n                IERC165(collection).supportsInterface(ERC721_INTERFACE_ID_2);\\n\\n            if (!isERC721) {\\n                return POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC721;\\n            }\\n        } else if (collectionType == CollectionType.ERC1155) {\\n            if (!IERC165(collection).supportsInterface(ERC1155_INTERFACE_ID)) {\\n                return POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC1155;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies that (1) ERC20 approvals\\n     *         and (2) balances are sufficient to process the maker bid order.\\n     * @param currency Currency address\\n     * @param user User address\\n     * @param price Price (defined by the maker order)\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityMakerBidERC20Assets(\\n        address currency,\\n        address user,\\n        uint256 price\\n    ) private view returns (uint256 validationCode) {\\n        if (currency != address(0)) {\\n            if (IERC20(currency).balanceOf(user) < price) {\\n                return ERC20_BALANCE_INFERIOR_TO_PRICE;\\n            }\\n\\n            if (IERC20(currency).allowance(user, address(exchangeProtocol)) < price) {\\n                return ERC20_APPROVAL_INFERIOR_TO_PRICE;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity of NFT assets (approvals, balances, and others).\\n     * @param collection Collection address\\n     * @param collectionType Collection type\\n     * @param user User address\\n     * @param itemIds Array of item ids\\n     * @param amounts Array of amounts\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityMakerAskNFTAssets(\\n        address collection,\\n        CollectionType collectionType,\\n        address user,\\n        uint256[] memory itemIds,\\n        uint256[] memory amounts\\n    ) private view returns (uint256 validationCode) {\\n        validationCode = _checkIfItemIdsDiffer(itemIds);\\n\\n        if (validationCode != ORDER_EXPECTED_TO_BE_VALID) {\\n            return validationCode;\\n        }\\n\\n        if (collectionType == CollectionType.ERC721) {\\n            validationCode = _checkValidityERC721AndEquivalents(collection, user, itemIds);\\n        } else if (collectionType == CollectionType.ERC1155) {\\n            validationCode = _checkValidityERC1155(collection, user, itemIds, amounts);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity of (1) ERC721 approvals\\n     *         and (2) balances to process the maker ask order.\\n     * @param collection Collection address\\n     * @param user User address\\n     * @param itemIds Array of item ids\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityERC721AndEquivalents(\\n        address collection,\\n        address user,\\n        uint256[] memory itemIds\\n    ) private view returns (uint256 validationCode) {\\n        // 1. Verify itemId is owned by user and catch revertion if ERC721 ownerOf fails\\n        uint256 length = itemIds.length;\\n\\n        bool success;\\n        bytes memory data;\\n\\n        for (uint256 i; i < length; ) {\\n            (success, data) = collection.staticcall(abi.encodeCall(IERC721.ownerOf, (itemIds[i])));\\n\\n            if (!success) {\\n                return ERC721_ITEM_ID_DOES_NOT_EXIST;\\n            }\\n\\n            if (abi.decode(data, (address)) != user) {\\n                return ERC721_ITEM_ID_NOT_IN_BALANCE;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // 2. Verify if collection is approved by transfer manager\\n        (success, data) = collection.staticcall(\\n            abi.encodeCall(IERC721.isApprovedForAll, (user, address(exchangeProtocol)))\\n        );\\n\\n        bool isApprovedAll;\\n        if (success) {\\n            isApprovedAll = abi.decode(data, (bool));\\n        }\\n\\n        if (!isApprovedAll) {\\n            for (uint256 i; i < length; ) {\\n                // 3. If collection is not approved by transfer manager, try to see if it is approved individually\\n                (success, data) = collection.staticcall(abi.encodeCall(IERC721.getApproved, (itemIds[i])));\\n\\n                address approvedAddress;\\n\\n                if (success) {\\n                    approvedAddress = abi.decode(data, (address));\\n                }\\n\\n                if (approvedAddress != address(exchangeProtocol)) {\\n                    return ERC721_NO_APPROVAL_FOR_ALL_OR_ITEM_ID;\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity of (1) ERC1155 approvals\\n     *         (2) and balances to process the maker ask order.\\n     * @param collection Collection address\\n     * @param user User address\\n     * @param itemIds Array of item ids\\n     * @param amounts Array of amounts\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityERC1155(\\n        address collection,\\n        address user,\\n        uint256[] memory itemIds,\\n        uint256[] memory amounts\\n    ) private view returns (uint256 validationCode) {\\n        // 1. Verify each itemId is owned by user and catch revertion if ERC1155 ownerOf fails\\n        address[] memory users = new address[](1);\\n        users[0] = user;\\n\\n        uint256 length = itemIds.length;\\n\\n        // 1.1 Use balanceOfBatch\\n        (bool success, bytes memory data) = collection.staticcall(\\n            abi.encodeCall(IERC1155.balanceOfBatch, (users, itemIds))\\n        );\\n\\n        if (success) {\\n            uint256[] memory balances = abi.decode(data, (uint256[]));\\n            for (uint256 i; i < length; ) {\\n                if (balances[i] < amounts[i]) {\\n                    return ERC1155_BALANCE_OF_ITEM_ID_INFERIOR_TO_AMOUNT;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else {\\n            // 1.2 If the balanceOfBatch does not work, use loop with balanceOf function\\n            for (uint256 i; i < length; ) {\\n                (success, data) = collection.staticcall(abi.encodeCall(IERC1155.balanceOf, (user, itemIds[i])));\\n\\n                if (!success) {\\n                    return ERC1155_BALANCE_OF_DOES_NOT_EXIST;\\n                }\\n\\n                if (abi.decode(data, (uint256)) < amounts[i]) {\\n                    return ERC1155_BALANCE_OF_ITEM_ID_INFERIOR_TO_AMOUNT;\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        // 2. Verify if collection is approved by transfer manager\\n        (success, data) = collection.staticcall(\\n            abi.encodeCall(IERC1155.isApprovedForAll, (user, address(exchangeProtocol)))\\n        );\\n\\n        if (!success) {\\n            return ERC1155_IS_APPROVED_FOR_ALL_DOES_NOT_EXIST;\\n        }\\n\\n        if (!abi.decode(data, (bool))) {\\n            return ERC1155_NO_APPROVAL_FOR_ALL;\\n        }\\n    }\\n\\n    /**\\n     * @notice This function verifies the validity of a Merkle proof and the order hash.\\n     * @param merkleTree Merkle tree struct\\n     * @param orderHash Order hash\\n     * @param signature Signature\\n     * @param signer Signer address\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityMerkleProofAndOrderHash(\\n        OrderStructs.MerkleTree calldata merkleTree,\\n        bytes32 orderHash,\\n        bytes calldata signature,\\n        address signer\\n    ) private view returns (uint256 validationCode) {\\n        if (merkleTree.proof.length != 0) {\\n            if (merkleTree.proof.length > MAX_CALLDATA_PROOF_LENGTH) {\\n                return MERKLE_PROOF_PROOF_TOO_LARGE;\\n            }\\n\\n            if (!MerkleProofCalldataWithNodes.verifyCalldata(merkleTree.proof, merkleTree.root, orderHash)) {\\n                return ORDER_HASH_PROOF_NOT_IN_MERKLE_TREE;\\n            }\\n\\n            bytes32 batchOrderHash = exchangeProtocol.hashBatchOrder(merkleTree.root, merkleTree.proof.length);\\n\\n            return _computeDigestAndVerify(batchOrderHash, signature, signer);\\n        } else {\\n            return _computeDigestAndVerify(orderHash, signature, signer);\\n        }\\n    }\\n\\n    /**\\n     * @notice Check the validity of creator fee\\n     * @param collection Collection address\\n     * @param itemIds Item ids\\n     * @return validationCode Validation code\\n     */\\n    function _checkValidityCreatorFee(\\n        address collection,\\n        uint256 price,\\n        uint256[] memory itemIds\\n    ) private view returns (uint256 validationCode) {\\n        if (address(creatorFeeManager) != address(0)) {\\n            (bool status, bytes memory data) = address(creatorFeeManager).staticcall(\\n                abi.encodeCall(ICreatorFeeManager.viewCreatorFeeInfo, (collection, price, itemIds))\\n            );\\n\\n            // The only path possible (to revert) in the fee manager is the bundle being not supported.\\n            if (!status) {\\n                return BUNDLE_ERC2981_NOT_SUPPORTED;\\n            }\\n\\n            (address creator, uint256 creatorFeeAmount) = abi.decode(data, (address, uint256));\\n\\n            if (creator != address(0)) {\\n                if (creatorFeeAmount * ONE_HUNDRED_PERCENT_IN_BP > (price * uint256(maxCreatorFeeBp))) {\\n                    return CREATOR_FEE_TOO_HIGH;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function computes the digest and verify the signature.\\n     * @param computedHash Hash of order or merkle root\\n     * @param makerSignature Signature of the maker\\n     * @param signer Signer address\\n     * @return validationCode Validation code\\n     */\\n    function _computeDigestAndVerify(\\n        bytes32 computedHash,\\n        bytes calldata makerSignature,\\n        address signer\\n    ) private view returns (uint256 validationCode) {\\n        return\\n            _validateSignature(\\n                keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, computedHash)),\\n                makerSignature,\\n                signer\\n            );\\n    }\\n\\n    /**\\n     * @notice This function checks the validity of the signature.\\n     * @param hash Message hash\\n     * @param signature A 64 or 65 bytes signature\\n     * @param signer Signer address\\n     * @return validationCode Validation code\\n     */\\n    function _validateSignature(\\n        bytes32 hash,\\n        bytes calldata signature,\\n        address signer\\n    ) private view returns (uint256 validationCode) {\\n        // Logic if EOA\\n        if (signer.code.length == 0) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n\\n            if (signature.length == 64) {\\n                bytes32 vs;\\n                assembly {\\n                    r := calldataload(signature.offset)\\n                    vs := calldataload(add(signature.offset, 0x20))\\n                    s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                    v := add(shr(255, vs), 27)\\n                }\\n            } else if (signature.length == 65) {\\n                assembly {\\n                    r := calldataload(signature.offset)\\n                    s := calldataload(add(signature.offset, 0x20))\\n                    v := byte(0, calldataload(add(signature.offset, 0x40)))\\n                }\\n            } else {\\n                return INVALID_SIGNATURE_LENGTH;\\n            }\\n\\n            if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n                return INVALID_S_PARAMETER_EOA;\\n            }\\n\\n            if (v != 27 && v != 28) {\\n                return INVALID_V_PARAMETER_EOA;\\n            }\\n\\n            address recoveredSigner = ecrecover(hash, v, r, s);\\n\\n            if (recoveredSigner == address(0)) {\\n                return NULL_SIGNER_EOA;\\n            }\\n\\n            if (signer != recoveredSigner) {\\n                return INVALID_SIGNER_EOA;\\n            }\\n        } else {\\n            // Logic if ERC1271\\n            (bool success, bytes memory data) = signer.staticcall(\\n                abi.encodeCall(IERC1271.isValidSignature, (hash, signature))\\n            );\\n\\n            if (!success) {\\n                return MISSING_IS_VALID_SIGNATURE_FUNCTION_EIP1271;\\n            }\\n\\n            if (abi.decode(data, (bytes4)) != IERC1271.isValidSignature.selector) {\\n                return SIGNATURE_INVALID_EIP1271;\\n            }\\n        }\\n    }\\n\\n    function _checkValidityMakerAskItemIdsAndAmountsAndPrice(\\n        OrderStructs.Maker memory makerAsk\\n    ) private view returns (uint256 validationCode, uint256[] memory itemIds, uint256[] memory amounts, uint256 price) {\\n        if (makerAsk.strategyId == 0) {\\n            itemIds = makerAsk.itemIds;\\n            amounts = makerAsk.amounts;\\n            price = makerAsk.price;\\n\\n            validationCode = _getOrderValidationCodeForStandardStrategy(\\n                makerAsk.collectionType,\\n                itemIds.length,\\n                amounts\\n            );\\n        } else {\\n            itemIds = makerAsk.itemIds;\\n            amounts = makerAsk.amounts;\\n            // @dev It should ideally be adjusted by real price\\n            price = makerAsk.price;\\n\\n            (, , , , bytes4 strategySelector, , address strategyImplementation) = exchangeProtocol.strategyInfo(\\n                makerAsk.strategyId\\n            );\\n\\n            (bool isValid, bytes4 errorSelector) = IStrategy(strategyImplementation).isMakerOrderValid(\\n                makerAsk,\\n                strategySelector\\n            );\\n\\n            validationCode = _getOrderValidationCodeForNonStandardStrategies(isValid, errorSelector);\\n        }\\n    }\\n\\n    function _checkValidityMakerBidItemIdsAndAmountsAndPrice(\\n        OrderStructs.Maker memory makerBid\\n    ) private view returns (uint256 validationCode, uint256[] memory itemIds, uint256[] memory amounts, uint256 price) {\\n        if (makerBid.strategyId == 0) {\\n            itemIds = makerBid.itemIds;\\n            amounts = makerBid.amounts;\\n            price = makerBid.price;\\n\\n            validationCode = _getOrderValidationCodeForStandardStrategy(\\n                makerBid.collectionType,\\n                itemIds.length,\\n                amounts\\n            );\\n        } else {\\n            // @dev It should ideally be adjusted by real price\\n            //      amounts and itemIds are not used since most non-native maker bids won't target a single item\\n            price = makerBid.price;\\n\\n            (, , , , bytes4 strategySelector, , address strategyImplementation) = exchangeProtocol.strategyInfo(\\n                makerBid.strategyId\\n            );\\n\\n            (bool isValid, bytes4 errorSelector) = IStrategy(strategyImplementation).isMakerOrderValid(\\n                makerBid,\\n                strategySelector\\n            );\\n\\n            validationCode = _getOrderValidationCodeForNonStandardStrategies(isValid, errorSelector);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function checks if the same itemId is repeated\\n     *         in an array of item ids.\\n     * @param itemIds Array of item ids\\n     * @dev This is for bundles.\\n     *      For example, if itemIds = [1,2,1], it will return SAME_ITEM_ID_IN_BUNDLE.\\n     * @return validationCode Validation code\\n     */\\n    function _checkIfItemIdsDiffer(uint256[] memory itemIds) private pure returns (uint256 validationCode) {\\n        uint256 length = itemIds.length;\\n\\n        // Only check if length of array is greater than 1\\n        if (length > 1) {\\n            for (uint256 i = 0; i < length - 1; ) {\\n                for (uint256 j = i + 1; j < length; ) {\\n                    if (itemIds[i] == itemIds[j]) {\\n                        return SAME_ITEM_ID_IN_BUNDLE;\\n                    }\\n\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getOrderValidationCodeForStandardStrategy(\\n        CollectionType collectionType,\\n        uint256 expectedLength,\\n        uint256[] memory amounts\\n    ) private pure returns (uint256 validationCode) {\\n        if (expectedLength == 0 || (amounts.length != expectedLength)) {\\n            validationCode = MAKER_ORDER_INVALID_STANDARD_SALE;\\n        } else {\\n            for (uint256 i; i < expectedLength; ) {\\n                uint256 amount = amounts[i];\\n\\n                if (amount == 0) {\\n                    validationCode = MAKER_ORDER_INVALID_STANDARD_SALE;\\n                }\\n\\n                if (collectionType == CollectionType.ERC721 && amount != 1) {\\n                    validationCode = MAKER_ORDER_INVALID_STANDARD_SALE;\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getOrderValidationCodeForNonStandardStrategies(\\n        bool isValid,\\n        bytes4 errorSelector\\n    ) private pure returns (uint256 validationCode) {\\n        if (isValid) {\\n            validationCode = ORDER_EXPECTED_TO_BE_VALID;\\n        } else {\\n            if (errorSelector == OrderInvalid.selector) {\\n                validationCode = MAKER_ORDER_PERMANENTLY_INVALID_NON_STANDARD_SALE;\\n            } else {\\n                validationCode = MAKER_ORDER_TEMPORARILY_INVALID_NON_STANDARD_SALE;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC721 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC1155 {\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC1271 {\\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OrderStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Enums\\nimport {CollectionType} from \\\"../enums/CollectionType.sol\\\";\\nimport {QuoteType} from \\\"../enums/QuoteType.sol\\\";\\n\\n/**\\n * @title OrderStructs\\n * @notice This library contains all order struct types for the LooksRare protocol (v2).\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nlibrary OrderStructs {\\n    /**\\n     * 1. Maker struct\\n     */\\n\\n    /**\\n     * @notice Maker is the struct for a maker order.\\n     * @param quoteType Quote type (i.e. 0 = BID, 1 = ASK)\\n     * @param globalNonce Global user order nonce for maker orders\\n     * @param subsetNonce Subset nonce (shared across bid/ask maker orders)\\n     * @param orderNonce Order nonce (it can be shared across bid/ask maker orders)\\n     * @param strategyId Strategy id\\n     * @param collectionType Collection type (i.e. 0 = ERC721, 1 = ERC1155)\\n     * @param collection Collection address\\n     * @param currency Currency address (@dev address(0) = ETH)\\n     * @param signer Signer address\\n     * @param startTime Start timestamp\\n     * @param endTime End timestamp\\n     * @param price Minimum price for maker ask, maximum price for maker bid\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     * @param additionalParameters Extra data specific for the order\\n     */\\n    struct Maker {\\n        QuoteType quoteType;\\n        uint256 globalNonce;\\n        uint256 subsetNonce;\\n        uint256 orderNonce;\\n        uint256 strategyId;\\n        CollectionType collectionType;\\n        address collection;\\n        address currency;\\n        address signer;\\n        uint256 startTime;\\n        uint256 endTime;\\n        uint256 price;\\n        uint256[] itemIds;\\n        uint256[] amounts;\\n        bytes additionalParameters;\\n    }\\n\\n    /**\\n     * 2. Taker struct\\n     */\\n\\n    /**\\n     * @notice Taker is the struct for a taker ask/bid order. It contains the parameters required for a direct purchase.\\n     * @dev Taker struct is matched against MakerAsk/MakerBid structs at the protocol level.\\n     * @param recipient Recipient address (to receive NFTs or non-fungible tokens)\\n     * @param additionalParameters Extra data specific for the order\\n     */\\n    struct Taker {\\n        address recipient;\\n        bytes additionalParameters;\\n    }\\n\\n    /**\\n     * 3. Merkle tree struct\\n     */\\n\\n    enum MerkleTreeNodePosition { Left, Right }\\n\\n    /**\\n     * @notice MerkleTreeNode is a MerkleTree's node.\\n     * @param value It can be an order hash or a proof\\n     * @param position The node's position in its branch.\\n     *                 It can be left or right or none\\n     *                 (before the tree is sorted).\\n     */\\n    struct MerkleTreeNode {\\n        bytes32 value;\\n        MerkleTreeNodePosition position;\\n    }\\n\\n    /**\\n     * @notice MerkleTree is the struct for a merkle tree of order hashes.\\n     * @dev A Merkle tree can be computed with order hashes.\\n     *      It can contain order hashes from both maker bid and maker ask structs.\\n     * @param root Merkle root\\n     * @param proof Array containing the merkle proof\\n     */\\n    struct MerkleTree {\\n        bytes32 root;\\n        MerkleTreeNode[] proof;\\n    }\\n\\n    /**\\n     * 4. Constants\\n     */\\n\\n    /**\\n     * @notice This is the type hash constant used to compute the maker order hash.\\n     */\\n    bytes32 internal constant _MAKER_TYPEHASH =\\n        keccak256(\\n            \\\"Maker(\\\"\\n                \\\"uint8 quoteType,\\\"\\n                \\\"uint256 globalNonce,\\\"\\n                \\\"uint256 subsetNonce,\\\"\\n                \\\"uint256 orderNonce,\\\"\\n                \\\"uint256 strategyId,\\\"\\n                \\\"uint8 collectionType,\\\"\\n                \\\"address collection,\\\"\\n                \\\"address currency,\\\"\\n                \\\"address signer,\\\"\\n                \\\"uint256 startTime,\\\"\\n                \\\"uint256 endTime,\\\"\\n                \\\"uint256 price,\\\"\\n                \\\"uint256[] itemIds,\\\"\\n                \\\"uint256[] amounts,\\\"\\n                \\\"bytes additionalParameters\\\"\\n            \\\")\\\"\\n        );\\n\\n    /**\\n     * 5. Hash functions\\n     */\\n\\n    /**\\n     * @notice This function is used to compute the order hash for a maker struct.\\n     * @param maker Maker order struct\\n     * @return makerHash Hash of the maker struct\\n     */\\n    function hash(Maker memory maker) internal pure returns (bytes32) {\\n        // Encoding is done into two parts to avoid stack too deep issues\\n        return\\n            keccak256(\\n                bytes.concat(\\n                    abi.encode(\\n                        _MAKER_TYPEHASH,\\n                        maker.quoteType,\\n                        maker.globalNonce,\\n                        maker.subsetNonce,\\n                        maker.orderNonce,\\n                        maker.strategyId,\\n                        maker.collectionType,\\n                        maker.collection,\\n                        maker.currency\\n                    ),\\n                    abi.encode(\\n                        maker.signer,\\n                        maker.startTime,\\n                        maker.endTime,\\n                        maker.price,\\n                        keccak256(abi.encodePacked(maker.itemIds)),\\n                        keccak256(abi.encodePacked(maker.amounts)),\\n                        keccak256(maker.additionalParameters)\\n                    )\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/OpenZeppelin/MerkleProofCalldataWithNodes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Libraries\\nimport {OrderStructs} from \\\"../../libraries/OrderStructs.sol\\\";\\n\\n/**\\n * @title MerkleProofCalldataWithNodes\\n * @notice This library is adjusted from the work of OpenZeppelin.\\n *         It is based on the 4.7.0 (utils/cryptography/MerkleProof.sol).\\n * @author OpenZeppelin (adjusted by LooksRare)\\n */\\nlibrary MerkleProofCalldataWithNodes {\\n    /**\\n     * @notice This returns true if a `leaf` can be proved to be a part of a Merkle tree defined by `root`.\\n     *         For this, a `proof` must be provided, containing sibling hashes on the branch from the leaf to the\\n     *         root of the tree. Each pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verifyCalldata(\\n        OrderStructs.MerkleTreeNode[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @notice This returns the rebuilt hash obtained by traversing a Merkle tree up from `leaf` using `proof`.\\n     *         A `proof` is valid if and only if the rebuilt hash matches the root of the tree.\\n     *         When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProofCalldata(\\n        OrderStructs.MerkleTreeNode[] calldata proof,\\n        bytes32 leaf\\n    ) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        uint256 length = proof.length;\\n\\n        for (uint256 i = 0; i < length; ) {\\n            if (proof[i].position == OrderStructs.MerkleTreeNodePosition.Left) {\\n                computedHash = _efficientHash(proof[i].value, computedHash);\\n            } else {\\n                computedHash = _efficientHash(computedHash, proof[i].value);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreatorFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Interfaces\\nimport {IRoyaltyFeeRegistry} from \\\"./IRoyaltyFeeRegistry.sol\\\";\\n\\n/**\\n * @title ICreatorFeeManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface ICreatorFeeManager {\\n    /**\\n     * @notice It is returned if the bundle contains multiple itemIds with different creator fee structure.\\n     */\\n    error BundleEIP2981NotAllowed(address collection);\\n\\n    /**\\n     * @notice It returns the royalty fee registry address/interface.\\n     * @return royaltyFeeRegistry Interface of the royalty fee registry\\n     */\\n    function royaltyFeeRegistry() external view returns (IRoyaltyFeeRegistry royaltyFeeRegistry);\\n\\n    /**\\n     * @notice This function returns the creator address and calculates the creator fee amount.\\n     * @param collection Collection address\\n     * @param price Transaction price\\n     * @param itemIds Array of item ids\\n     * @return creator Creator address\\n     * @return creatorFeeAmount Creator fee amount\\n     */\\n    function viewCreatorFeeInfo(\\n        address collection,\\n        uint256 price,\\n        uint256[] memory itemIds\\n    ) external view returns (address creator, uint256 creatorFeeAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Libraries\\nimport {OrderStructs} from \\\"../libraries/OrderStructs.sol\\\";\\n\\n/**\\n * @title IStrategy\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IStrategy {\\n    /**\\n     * @notice Validate *only the maker* order under the context of the chosen strategy. It does not revert if\\n     *         the maker order is invalid. Instead it returns false and the error's 4 bytes selector.\\n     * @param makerOrder Maker struct (maker specific parameters for the execution)\\n     * @param functionSelector Function selector for the strategy\\n     * @return isValid Whether the maker struct is valid\\n     * @return errorSelector If isValid is false, it returns the error's 4 bytes selector\\n     */\\n    function isMakerOrderValid(\\n        OrderStructs.Maker calldata makerOrder,\\n        bytes4 functionSelector\\n    ) external view returns (bool isValid, bytes4 errorSelector);\\n\\n    /**\\n     * @notice This function acts as a safety check for the protocol's owner when adding new execution strategies.\\n     * @return isStrategy Whether it is a LooksRare V2 protocol strategy\\n     */\\n    function isLooksRareV2Strategy() external pure returns (bool isStrategy);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoyaltyFeeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IRoyaltyFeeRegistry\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IRoyaltyFeeRegistry {\\n    /**\\n     * @notice This function returns the royalty information for a collection at a given transaction price.\\n     * @param collection Collection address\\n     * @param price Transaction price\\n     * @return receiver Receiver address\\n     * @return royaltyFee Royalty fee amount\\n     */\\n    function royaltyInfo(\\n        address collection,\\n        uint256 price\\n    ) external view returns (address receiver, uint256 royaltyFee);\\n}\\n\"\r\n    },\r\n    \"contracts/errors/SharedErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice It is returned if the amount is invalid.\\n *         For ERC721, any number that is not 1. For ERC1155, if amount is 0.\\n */\\nerror AmountInvalid();\\n\\n/**\\n * @notice It is returned if the ask price is too high for the bid user.\\n */\\nerror AskTooHigh();\\n\\n/**\\n * @notice It is returned if the bid price is too low for the ask user.\\n */\\nerror BidTooLow();\\n\\n/**\\n * @notice It is returned if the function cannot be called by the sender.\\n */\\nerror CallerInvalid();\\n\\n/**\\n * @notice It is returned if the currency is invalid.\\n */\\nerror CurrencyInvalid();\\n\\n/**\\n * @notice The function selector is invalid for this strategy implementation.\\n */\\nerror FunctionSelectorInvalid();\\n\\n/**\\n * @notice It is returned if there is either a mismatch or an error in the length of the array(s).\\n */\\nerror LengthsInvalid();\\n\\n/**\\n * @notice It is returned if the merkle proof provided is invalid.\\n */\\nerror MerkleProofInvalid();\\n\\n/**\\n * @notice It is returned if the length of the merkle proof provided is greater than tolerated.\\n * @param length Proof length\\n */\\nerror MerkleProofTooLarge(uint256 length);\\n\\n/**\\n * @notice It is returned if the order is permanently invalid.\\n *         There may be an issue with the order formatting.\\n */\\nerror OrderInvalid();\\n\\n/**\\n * @notice It is returned if the maker quote type is invalid.\\n */\\nerror QuoteTypeInvalid();\\n\"\r\n    },\r\n    \"contracts/ExchangeProtocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// LooksRare unopinionated libraries\\nimport {SignatureCheckerCalldata} from \\\"@looksrare/contracts-libs/contracts/SignatureCheckerCalldata.sol\\\";\\nimport {LowLevelETHReturnETHIfAnyExceptOneWei} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelETHReturnETHIfAnyExceptOneWei.sol\\\";\\nimport {LowLevelWETH} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\\\";\\nimport {LowLevelERC20Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\\\";\\n\\n// OpenZeppelin's library (adjusted) for verifying Merkle proofs\\nimport {MerkleProofCalldataWithNodes} from \\\"./libraries/OpenZeppelin/MerkleProofCalldataWithNodes.sol\\\";\\n\\n// Libraries\\nimport {OrderStructs} from \\\"./libraries/OrderStructs.sol\\\";\\n\\n// Interfaces\\nimport {IExchangeProtocol} from \\\"./interfaces/IExchangeProtocol.sol\\\";\\n\\n// Shared errors\\nimport {CallerInvalid, CurrencyInvalid, LengthsInvalid, MerkleProofInvalid, MerkleProofTooLarge, QuoteTypeInvalid} from \\\"./errors/SharedErrors.sol\\\";\\n\\n// Direct dependencies\\nimport {TransferSelectorNFT} from \\\"./TransferSelectorNFT.sol\\\";\\nimport {BatchOrderTypehashRegistry} from \\\"./BatchOrderTypehashRegistry.sol\\\";\\n\\n// Constants\\nimport {MAX_CALLDATA_PROOF_LENGTH, ONE_HUNDRED_PERCENT_IN_BP} from \\\"./constants/NumericConstants.sol\\\";\\n\\n// Enums\\nimport {QuoteType} from \\\"./enums/QuoteType.sol\\\";\\n\\n/**\\n * @title ExchangeProtocol\\n * @notice This code section includes a modification of code from LooksRare protocol team's contracts-exchange-v2.\\n *         Original code: https://github.com/LooksRare/contracts-exchange-v2\\n */\\ncontract ExchangeProtocol is\\n    IExchangeProtocol,\\n    TransferSelectorNFT,\\n    LowLevelETHReturnETHIfAnyExceptOneWei,\\n    LowLevelWETH,\\n    LowLevelERC20Transfer,\\n    BatchOrderTypehashRegistry\\n{\\n    using OrderStructs for OrderStructs.Maker;\\n\\n    /**\\n     * @notice Wrapped Native Token.\\n     */\\n    address public wrappedNativeToken;\\n\\n    /**\\n     * @notice Current chainId.\\n     */\\n    uint256 public chainId;\\n\\n    /**\\n     * @notice Current domain separator.\\n     */\\n    bytes32 public domainSeparator;\\n\\n    /**\\n     * @notice This variable is used as the gas limit for a ETH transfer.\\n     *         If a standard ETH transfer fails within this gas limit, ETH will get wrapped to WETH\\n     *         and transferred to the initial recipient.\\n     */\\n    uint256 private _gasLimitETHTransfer = 2_300;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     * @param _protocolFeeRecipient Protocol fee recipient address\\n     */\\n    constructor(address _owner, address _protocolFeeRecipient) TransferSelectorNFT(_owner, _protocolFeeRecipient) {\\n        _updateDomainSeparator();\\n    }\\n\\n    /**\\n     * @dev This function must be executed immediately after deployment to initialize the wrapped native token.\\n     * @param wrappedToken_ wrapped native token address (e.g. WETH, WBNB)\\n     */\\n    function initializeWrappedNativeToken(address wrappedToken_) external onlyOwner {\\n        if (wrappedNativeToken == address(0)) {\\n            wrappedNativeToken = wrappedToken_;\\n        } else {\\n            revert WrappedNativeTokenAlreadyInitialized();\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IExchangeProtocol\\n     */\\n    function executeTakerAsk(\\n        OrderStructs.Taker calldata takerAsk,\\n        OrderStructs.Maker calldata makerBid,\\n        bytes calldata makerSignature,\\n        OrderStructs.MerkleTree calldata merkleTree,\\n        address affiliate\\n    ) external nonReentrant {\\n        address currency = makerBid.currency;\\n\\n        // Verify whether the currency is allowed and is not ETH (address(0))\\n        if (!isCurrencyAllowed[currency] || currency == address(0)) {\\n            revert CurrencyInvalid();\\n        }\\n\\n        address signer = makerBid.signer;\\n        bytes32 orderHash = makerBid.hash();\\n        _verifyMerkleProofOrOrderHash(merkleTree, orderHash, makerSignature, signer);\\n\\n        // Execute the transaction and fetch protocol fee amount\\n        uint256 totalProtocolFeeAmount = _executeTakerAsk(takerAsk, makerBid, orderHash);\\n\\n        // Pay protocol fee (and affiliate fee if any)\\n        _payProtocolFeeAndAffiliateFee(currency, signer, affiliate, totalProtocolFeeAmount);\\n    }\\n\\n    /**\\n     * @inheritdoc IExchangeProtocol\\n     */\\n    function executeTakerBid(\\n        OrderStructs.Taker calldata takerBid,\\n        OrderStructs.Maker calldata makerAsk,\\n        bytes calldata makerSignature,\\n        OrderStructs.MerkleTree calldata merkleTree,\\n        address affiliate\\n    ) external payable nonReentrant {\\n        address currency = makerAsk.currency;\\n\\n        // Verify whether the currency is allowed for trading.\\n        if (!isCurrencyAllowed[currency]) {\\n            revert CurrencyInvalid();\\n        }\\n\\n        bytes32 orderHash = makerAsk.hash();\\n        _verifyMerkleProofOrOrderHash(merkleTree, orderHash, makerSignature, makerAsk.signer);\\n\\n        // Execute the transaction and fetch protocol fee amount\\n        uint256 totalProtocolFeeAmount = _executeTakerBid(takerBid, makerAsk, msg.sender, orderHash);\\n\\n        // Pay protocol fee amount (and affiliate fee if any)\\n        _payProtocolFeeAndAffiliateFee(currency, msg.sender, affiliate, totalProtocolFeeAmount);\\n\\n        // Return ETH if any\\n        _returnETHIfAnyWithOneWeiLeft();\\n    }\\n\\n    /**\\n     * @inheritdoc IExchangeProtocol\\n     */\\n    function executeMultipleTakerBids(\\n        OrderStructs.Taker[] calldata takerBids,\\n        OrderStructs.Maker[] calldata makerAsks,\\n        bytes[] calldata makerSignatures,\\n        OrderStructs.MerkleTree[] calldata merkleTrees,\\n        address affiliate,\\n        bool isAtomic\\n    ) external payable nonReentrant {\\n        uint256 length = takerBids.length;\\n        if (\\n            length == 0 ||\\n            (makerAsks.length ^ length) | (makerSignatures.length ^ length) | (merkleTrees.length ^ length) != 0\\n        ) {\\n            revert LengthsInvalid();\\n        }\\n\\n        // Verify whether the currency at index = 0 is allowed for trading\\n        address currency = makerAsks[0].currency;\\n        if (!isCurrencyAllowed[currency]) {\\n            revert CurrencyInvalid();\\n        }\\n\\n        {\\n            // Initialize protocol fee amount\\n            uint256 totalProtocolFeeAmount;\\n\\n            // If atomic, it uses the executeTakerBid function.\\n            // If not atomic, it uses a catch/revert pattern with external function.\\n            if (isAtomic) {\\n                for (uint256 i; i < length; ) {\\n                    OrderStructs.Maker calldata makerAsk = makerAsks[i];\\n\\n                    // Verify the currency is the same\\n                    if (i != 0) {\\n                        if (makerAsk.currency != currency) {\\n                            revert CurrencyInvalid();\\n                        }\\n                    }\\n\\n                    OrderStructs.Taker calldata takerBid = takerBids[i];\\n                    bytes32 orderHash = makerAsk.hash();\\n\\n                    {\\n                        _verifyMerkleProofOrOrderHash(merkleTrees[i], orderHash, makerSignatures[i], makerAsk.signer);\\n\\n                        // Execute the transaction and add protocol fee\\n                        totalProtocolFeeAmount += _executeTakerBid(takerBid, makerAsk, msg.sender, orderHash);\\n\\n                        unchecked {\\n                            ++i;\\n                        }\\n                    }\\n                }\\n            } else {\\n                for (uint256 i; i < length; ) {\\n                    OrderStructs.Maker calldata makerAsk = makerAsks[i];\\n\\n                    // Verify the currency is the same\\n                    if (i != 0) {\\n                        if (makerAsk.currency != currency) {\\n                            revert CurrencyInvalid();\\n                        }\\n                    }\\n\\n                    OrderStructs.Taker calldata takerBid = takerBids[i];\\n                    bytes32 orderHash = makerAsk.hash();\\n\\n                    {\\n                        _verifyMerkleProofOrOrderHash(merkleTrees[i], orderHash, makerSignatures[i], makerAsk.signer);\\n\\n                        try this.restrictedExecuteTakerBid(takerBid, makerAsk, msg.sender, orderHash) returns (\\n                            uint256 protocolFeeAmount\\n                        ) {\\n                            totalProtocolFeeAmount += protocolFeeAmount;\\n                        } catch {}\\n\\n                        unchecked {\\n                            ++i;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Pay protocol fee (and affiliate fee if any)\\n            _payProtocolFeeAndAffiliateFee(currency, msg.sender, affiliate, totalProtocolFeeAmount);\\n        }\\n\\n        // Return ETH if any\\n        _returnETHIfAnyWithOneWeiLeft();\\n    }\\n\\n    /**\\n     * @notice This function is used to do a non-atomic matching in the context of a batch taker bid.\\n     * @param takerBid Taker bid struct\\n     * @param makerAsk Maker ask struct\\n     * @param sender Sender address (i.e. the initial msg sender)\\n     * @param orderHash Hash of the maker ask order\\n     * @return protocolFeeAmount Protocol fee amount\\n     * @dev This function is only callable by this contract. It is used for non-atomic batch order matching.\\n     */\\n    function restrictedExecuteTakerBid(\\n        OrderStructs.Taker calldata takerBid,\\n        OrderStructs.Maker calldata makerAsk,\\n        address sender,\\n        bytes32 orderHash\\n    ) external returns (uint256 protocolFeeAmount) {\\n        if (msg.sender != address(this)) {\\n            revert CallerInvalid();\\n        }\\n\\n        protocolFeeAmount = _executeTakerBid(takerBid, makerAsk, sender, orderHash);\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the domain separator (if possible).\\n     * @dev Only callable by owner. If there is a fork of the network with a new chainId,\\n     *      it allows the owner to reset the domain separator for the new chain id.\\n     */\\n    function updateDomainSeparator() external onlyOwner {\\n        if (block.chainid != chainId) {\\n            _updateDomainSeparator();\\n            emit NewDomainSeparator();\\n        } else {\\n            revert SameDomainSeparator();\\n        }\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the maximum ETH gas limit for a standard transfer.\\n     * @param newGasLimitETHTransfer New gas limit for ETH transfer\\n     * @dev Only callable by owner.\\n     */\\n    function updateETHGasLimitForTransfer(uint256 newGasLimitETHTransfer) external onlyOwner {\\n        if (newGasLimitETHTransfer < 2_300) {\\n            revert NewGasLimitETHTransferTooLow();\\n        }\\n\\n        _gasLimitETHTransfer = newGasLimitETHTransfer;\\n\\n        emit NewGasLimitETHTransfer(newGasLimitETHTransfer);\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to execute a taker ask (against a maker bid).\\n     * @param takerAsk Taker ask order struct\\n     * @param makerBid Maker bid order struct\\n     * @param orderHash Hash of the maker bid order\\n     * @return protocolFeeAmount Protocol fee amount\\n     */\\n    function _executeTakerAsk(\\n        OrderStructs.Taker calldata takerAsk,\\n        OrderStructs.Maker calldata makerBid,\\n        bytes32 orderHash\\n    ) internal returns (uint256) {\\n        if (makerBid.quoteType != QuoteType.Bid) {\\n            revert QuoteTypeInvalid();\\n        }\\n\\n        address signer = makerBid.signer;\\n        {\\n            bytes32 userOrderNonceStatus = userOrderNonce[signer][makerBid.orderNonce];\\n            // Verify nonces\\n            if (\\n                userBidAskNonces[signer].bidNonce != makerBid.globalNonce ||\\n                userSubsetNonce[signer][makerBid.subsetNonce] ||\\n                (userOrderNonceStatus != bytes32(0) && userOrderNonceStatus != orderHash)\\n            ) {\\n                revert NoncesInvalid();\\n            }\\n        }\\n\\n        (\\n            uint256[] memory itemIds,\\n            uint256[] memory amounts,\\n            address[2] memory recipients,\\n            uint256[3] memory feeAmounts,\\n            bool isNonceInvalidated\\n        ) = _executeStrategyForTakerOrder(takerAsk, makerBid, msg.sender);\\n\\n        // Order nonce status is updated\\n        _updateUserOrderNonce(isNonceInvalidated, signer, makerBid.orderNonce, orderHash);\\n\\n        // Taker action goes first\\n        _transferNFT(makerBid.collection, makerBid.collectionType, msg.sender, signer, itemIds, amounts);\\n\\n        // Maker action goes second\\n        _transferToAskRecipientAndCreatorIfAny(recipients, feeAmounts, makerBid.currency, signer);\\n\\n        emit TakerAsk(\\n            NonceInvalidationParameters({\\n                orderHash: orderHash,\\n                orderNonce: makerBid.orderNonce,\\n                isNonceInvalidated: isNonceInvalidated\\n            }),\\n            msg.sender,\\n            signer,\\n            makerBid.strategyId,\\n            makerBid.currency,\\n            makerBid.collection,\\n            itemIds,\\n            amounts,\\n            recipients,\\n            feeAmounts\\n        );\\n\\n        // It returns the protocol fee amount\\n        return feeAmounts[2];\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to execute a taker bid (against a maker ask).\\n     * @param takerBid Taker bid order struct\\n     * @param makerAsk Maker ask order struct\\n     * @param sender Sender of the transaction (i.e. msg.sender)\\n     * @param orderHash Hash of the maker ask order\\n     * @return protocolFeeAmount Protocol fee amount\\n     */\\n    function _executeTakerBid(\\n        OrderStructs.Taker calldata takerBid,\\n        OrderStructs.Maker calldata makerAsk,\\n        address sender,\\n        bytes32 orderHash\\n    ) internal returns (uint256) {\\n        if (makerAsk.quoteType != QuoteType.Ask) {\\n            revert QuoteTypeInvalid();\\n        }\\n\\n        address signer = makerAsk.signer;\\n        {\\n            // Verify nonces\\n            bytes32 userOrderNonceStatus = userOrderNonce[signer][makerAsk.orderNonce];\\n\\n            if (\\n                userBidAskNonces[signer].askNonce != makerAsk.globalNonce ||\\n                userSubsetNonce[signer][makerAsk.subsetNonce] ||\\n                (userOrderNonceStatus != bytes32(0) && userOrderNonceStatus != orderHash)\\n            ) {\\n                revert NoncesInvalid();\\n            }\\n        }\\n\\n        (\\n            uint256[] memory itemIds,\\n            uint256[] memory amounts,\\n            address[2] memory recipients,\\n            uint256[3] memory feeAmounts,\\n            bool isNonceInvalidated\\n        ) = _executeStrategyForTakerOrder(takerBid, makerAsk, msg.sender);\\n\\n        // Order nonce status is updated\\n        _updateUserOrderNonce(isNonceInvalidated, signer, makerAsk.orderNonce, orderHash);\\n\\n        // Taker action goes first\\n        _transferToAskRecipientAndCreatorIfAny(recipients, feeAmounts, makerAsk.currency, sender);\\n\\n        // Maker action goes second\\n        _transferNFT(\\n            makerAsk.collection,\\n            makerAsk.collectionType,\\n            signer,\\n            takerBid.recipient == address(0) ? sender : takerBid.recipient,\\n            itemIds,\\n            amounts\\n        );\\n\\n        emit TakerBid(\\n            NonceInvalidationParameters({\\n                orderHash: orderHash,\\n                orderNonce: makerAsk.orderNonce,\\n                isNonceInvalidated: isNonceInvalidated\\n            }),\\n            sender,\\n            takerBid.recipient == address(0) ? sender : takerBid.recipient,\\n            makerAsk.strategyId,\\n            makerAsk.currency,\\n            makerAsk.collection,\\n            itemIds,\\n            amounts,\\n            recipients,\\n            feeAmounts\\n        );\\n\\n        // It returns the protocol fee amount\\n        return feeAmounts[2];\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to pay the protocol fee and affiliate fee (if any).\\n     * @param currency Currency address to transfer (address(0) is ETH)\\n     * @param bidUser Bid user address\\n     * @param affiliate Affiliate address (address(0) if none)\\n     * @param totalProtocolFeeAmount Total protocol fee amount (denominated in the currency)\\n     */\\n    function _payProtocolFeeAndAffiliateFee(\\n        address currency,\\n        address bidUser,\\n        address affiliate,\\n        uint256 totalProtocolFeeAmount\\n    ) internal {\\n        if (totalProtocolFeeAmount != 0) {\\n            if (affiliate != address(0)) {\\n                // Check whether affiliate program is active and whether to execute a affiliate logic\\n                // If so, it adjusts the protocol fee downward.\\n                if (isAffiliateProgramActive) {\\n                    uint256 totalAffiliateFeeAmount = (totalProtocolFeeAmount * affiliateRates[affiliate]) /\\n                        ONE_HUNDRED_PERCENT_IN_BP;\\n\\n                    if (totalAffiliateFeeAmount != 0) {\\n                        totalProtocolFeeAmount -= totalAffiliateFeeAmount;\\n\\n                        // If bid user isn't the affiliate, pay the affiliate.\\n                        // If currency is ETH, funds are returned to sender at the end of the execution.\\n                        // If currency is ERC20, funds are not transferred from bidder to bidder\\n                        // (since it uses transferFrom).\\n                        if (bidUser != affiliate) {\\n                            _transferFungibleTokens(currency, bidUser, affiliate, totalAffiliateFeeAmount);\\n                        }\\n\\n                        emit AffiliatePayment(affiliate, currency, totalAffiliateFeeAmount);\\n                    }\\n                }\\n            }\\n\\n            // Transfer remaining protocol fee to the protocol fee recipient\\n            _transferFungibleTokens(currency, bidUser, protocolFeeRecipient, totalProtocolFeeAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to transfer fungible tokens.\\n     * @param currency Currency address\\n     * @param sender Sender address\\n     * @param recipient Recipient address\\n     * @param amount Amount (in fungible tokens)\\n     */\\n    function _transferFungibleTokens(address currency, address sender, address recipient, uint256 amount) internal {\\n        if (currency == address(0)) {\\n            _transferETHAndWrapIfFailWithGasLimit(wrappedNativeToken, recipient, amount, _gasLimitETHTransfer);\\n        } else {\\n            _executeERC20TransferFrom(currency, sender, recipient, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is private and used to transfer funds to\\n     *         (1) creator recipient (if any)\\n     *         (2) ask recipient.\\n     * @param recipients Recipient addresses\\n     * @param feeAmounts Fees\\n     * @param currency Currency address\\n     * @param bidUser Bid user address\\n     * @dev It does not send to the 0-th element in the array since it is the protocol fee,\\n     *      which is paid later in the execution flow.\\n     */\\n    function _transferToAskRecipientAndCreatorIfAny(\\n        address[2] memory recipients,\\n        uint256[3] memory feeAmounts,\\n        address currency,\\n        address bidUser\\n    ) private {\\n        // @dev There is no check for address(0) since the ask recipient can never be address(0)\\n        // If ask recipient is the maker --> the signer cannot be the null address\\n        // If ask is the taker --> either it is the sender address or\\n        // if the recipient (in TakerAsk) is set to address(0), it is adjusted to the original taker address\\n        uint256 sellerProceed = feeAmounts[0];\\n        if (sellerProceed != 0) {\\n            _transferFungibleTokens(currency, bidUser, recipients[0], sellerProceed);\\n        }\\n\\n        // @dev There is no check for address(0), if the creator recipient is address(0), the fee is set to 0\\n        uint256 creatorFeeAmount = feeAmounts[1];\\n        if (creatorFeeAmount != 0) {\\n            _transferFungibleTokens(currency, bidUser, recipients[1], creatorFeeAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is private and used to compute the domain separator and store the current chain id.\\n     */\\n    function _updateDomainSeparator() private {\\n        domainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(\\\"ExchangeProtocol\\\"),\\n                keccak256(bytes(\\\"2\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        chainId = block.chainid;\\n    }\\n\\n    /**\\n     * @notice This function is internal and is called during the execution of a transaction to decide\\n     *         how to map the user's order nonce.\\n     * @param isNonceInvalidated Whether the nonce is being invalidated\\n     * @param signer Signer address\\n     * @param orderNonce Maker user order nonce\\n     * @param orderHash Hash of the order struct\\n     * @dev If isNonceInvalidated is true, this function invalidates the user order nonce for future execution.\\n     *      If it is equal to false, this function maps the order hash for this user order nonce\\n     *      to prevent other order structs sharing the same order nonce to be executed.\\n     */\\n    function _updateUserOrderNonce(\\n        bool isNonceInvalidated,\\n        address signer,\\n        uint256 orderNonce,\\n        bytes32 orderHash\\n    ) private {\\n        userOrderNonce[signer][orderNonce] = (isNonceInvalidated ? MAGIC_VALUE_ORDER_NONCE_EXECUTED : orderHash);\\n    }\\n\\n    /**\\n     * @notice This function is private and used to verify the chain id, compute the digest, and verify the signature.\\n     * @dev If chainId is not equal to the cached chain id, it would revert.\\n     * @param computedHash Hash of order (maker bid or maker ask) or merkle root\\n     * @param makerSignature Signature of the maker\\n     * @param signer Signer address\\n     */\\n    function _computeDigestAndVerify(bytes32 computedHash, bytes calldata makerSignature, address signer) private view {\\n        if (chainId == block.chainid) {\\n            // \\\\x19\\\\x01 is the standard encoding prefix\\n            SignatureCheckerCalldata.verify(\\n                keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, computedHash)),\\n                signer,\\n                makerSignature\\n            );\\n        } else {\\n            revert ChainIdInvalid();\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is private and called to verify whether the merkle proofs provided for the order hash\\n     *         are correct or verify the order hash if the order is not part of a merkle tree.\\n     * @param merkleTree Merkle tree\\n     * @param orderHash Order hash (can be maker bid hash or maker ask hash)\\n     * @param signature Maker order signature\\n     * @param signer Maker address\\n     * @dev It verifies (1) merkle proof (if necessary) (2) signature is from the expected signer\\n     */\\n    function _verifyMerkleProofOrOrderHash(\\n        OrderStructs.MerkleTree calldata merkleTree,\\n        bytes32 orderHash,\\n        bytes calldata signature,\\n        address signer\\n    ) private view {\\n        uint256 proofLength = merkleTree.proof.length;\\n\\n        if (proofLength != 0) {\\n            if (proofLength > MAX_CALLDATA_PROOF_LENGTH) {\\n                revert MerkleProofTooLarge(proofLength);\\n            }\\n\\n            if (!MerkleProofCalldataWithNodes.verifyCalldata(merkleTree.proof, merkleTree.root, orderHash)) {\\n                revert MerkleProofInvalid();\\n            }\\n\\n            orderHash = hashBatchOrder(merkleTree.root, proofLength);\\n        }\\n\\n        _computeDigestAndVerify(orderHash, signature, signer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants/ValidationCodeConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * 0. No error\\n */\\n\\n/**\\n * @dev The maker order is expected to be valid.\\n *      There can be other reasons that cause makers orders to be\\n *      invalid (e.g. trading restrictions for the protocol, fallbacks).\\n */\\nuint256 constant ORDER_EXPECTED_TO_BE_VALID = 0;\\n\\n/**\\n * 1. Strategy & currency-related codes\\n */\\n\\n/**\\n * @dev The currency is not allowed in the protocol.\\n *      This maker order could become valid only with owner action.\\n *      If the order is a maker bid and currency = address(0), it is permanently invalid.\\n */\\nuint256 constant CURRENCY_NOT_ALLOWED = 101;\\n\\n/**\\n * @dev The strategy is not implemented in the protocol.\\n *      This maker order can become valid only with owner action.\\n */\\nuint256 constant STRATEGY_NOT_IMPLEMENTED = 111;\\n\\n/**\\n * @dev The strategy is not for this quote type.\\n *      This maker order can never become valid.\\n */\\nuint256 constant STRATEGY_INVALID_QUOTE_TYPE = 112;\\n\\n/**\\n * @dev The strategy exists but is not currently active.\\n *      This maker order can become valid again only with owner action.\\n */\\nuint256 constant STRATEGY_NOT_ACTIVE = 113;\\n\\n/**\\n * 2. Maker order struct-related codes\\n */\\n\\n/**\\n * @dev The maker order is permanently invalid for a standard sale (e.g. invalid collection type or amounts)\\n *      This maker order cannot become valid again.\\n */\\nuint256 constant MAKER_ORDER_INVALID_STANDARD_SALE = 201;\\n\\n/**\\n * @dev The maker order is permanently invalid for a non-standard sale strategy.\\n *      This maker order cannot become valid again.\\n */\\nuint256 constant MAKER_ORDER_PERMANENTLY_INVALID_NON_STANDARD_SALE = 211;\\n\\n/**\\n * @dev The maker order is invalid due to a currency support.\\n *      This maker order may become valid in the future depending on the strategy's currency support.\\n *      Please refer to the strategy's implementation code.\\n */\\nuint256 constant MAKER_ORDER_INVALID_CURRENCY_NON_STANDARD_SALE = 212;\\n\\n/**\\n * @dev The maker order is temporarily invalid due to a strategy-specific reason.\\n *      This maker order may become valid in the future.\\n *      Please refer to the strategy's implementation code.\\n */\\nuint256 constant MAKER_ORDER_TEMPORARILY_INVALID_NON_STANDARD_SALE = 213;\\n\\n/**\\n * 3. Nonce-related codes\\n */\\n\\n/**\\n * @dev The signer's subset nonce is cancelled.\\n *      This maker order will not become valid again.\\n */\\nuint256 constant USER_SUBSET_NONCE_CANCELLED = 301;\\n\\n/**\\n * @dev The signer's order nonce is executed or cancelled.\\n *      This maker order will not become valid again.\\n */\\nuint256 constant USER_ORDER_NONCE_EXECUTED_OR_CANCELLED = 311;\\n\\n/**\\n * @dev The signer's order nonce is in partial fill status with an other order hash.\\n *      This maker order will not become valid again.\\n */\\nuint256 constant USER_ORDER_NONCE_IN_EXECUTION_WITH_OTHER_HASH = 312;\\n\\n/**\\n * @dev The signer's global bid nonce is not matching the order's bid nonce.\\n *      This maker order will not become valid again.\\n */\\nuint256 constant INVALID_USER_GLOBAL_BID_NONCE = 321;\\n\\n/**\\n * @dev The signer's global ask nonce is not matching the order's ask nonce.\\n *      This maker order will not become valid again.\\n */\\nuint256 constant INVALID_USER_GLOBAL_ASK_NONCE = 322;\\n\\n/**\\n * 4. Codes related to signatures (EOA, EIP-1271) and merkle tree computations\\n */\\n\\n/**\\n * @dev The order hash proof is not in the merkle tree.\\n *      This maker order is not valid with the set of merkle root and proofs.\\n *      It cannot become valid with the current merkle proof and root.\\n */\\nuint256 constant ORDER_HASH_PROOF_NOT_IN_MERKLE_TREE = 401;\\n\\n/**\\n * @dev The merkle proof is too large to be verified according.\\n *      There is a proof's size limit defined in the MerkleProofCalldataWithNodes.\\n *      It cannot become valid with the current merkle proof and root.\\n */\\nuint256 constant MERKLE_PROOF_PROOF_TOO_LARGE = 402;\\n\\n/**\\n * @dev The signature's length is invalid.\\n *      The signature's length must be either 64 or 65 bytes.\\n *      This maker order will never be valid.\\n */\\nuint256 constant INVALID_SIGNATURE_LENGTH = 411;\\n\\n/**\\n * @dev The signature's s parameter is invalid.\\n *      This maker order will never be valid.\\n */\\nuint256 constant INVALID_S_PARAMETER_EOA = 412;\\n\\n/**\\n * @dev The signature's v parameter is invalid.\\n *      It must be either equal to 27 or 28.\\n *      This maker order will never be valid with this signature.\\n */\\nuint256 constant INVALID_V_PARAMETER_EOA = 413;\\n\\n/**\\n * @dev The signer recovered (using ecrecover) is the null address.\\n *      This maker order will never be valid with this signature.\\n */\\nuint256 constant NULL_SIGNER_EOA = 414;\\n\\n/**\\n * @dev The recovered signer is not the target signer.\\n *      This maker order will never be valid with this signature.\\n */\\nuint256 constant INVALID_SIGNER_EOA = 415;\\n\\n/**\\n * @dev The signature is generated by a EIP1271 signer contract but the\\n *      contract does not implement the required function to verify the signature.\\n */\\nuint256 constant MISSING_IS_VALID_SIGNATURE_FUNCTION_EIP1271 = 421;\\n\\n/**\\n * @dev The signature by the EIP1271 signer contract is invalid.\\n *      This maker order may become valid again depending on the implementation of the\\n *      contract signing the order.\\n */\\nuint256 constant SIGNATURE_INVALID_EIP1271 = 422;\\n\\n/**\\n * 5. Timestamp-related codes\\n */\\n\\n/**\\n * @dev The start time is greater than the end time.\\n *      This maker order will never be valid.\\n */\\nuint256 constant START_TIME_GREATER_THAN_END_TIME = 501;\\n\\n/**\\n * @dev The block time is greater than the end time.\\n *      This maker order will never be valid.\\n */\\nuint256 constant TOO_LATE_TO_EXECUTE_ORDER = 502;\\n\\n/**\\n * @dev The block time is earlier than the start time.\\n *      A buffer of 5 minutes is included for orders that are about to be valid.\\n *      This maker order will become valid without any user action.\\n */\\nuint256 constant TOO_EARLY_TO_EXECUTE_ORDER = 503;\\n\\n/**\\n * 6. Transfer-related (ERC20, ERC721, ERC1155 tokens), including transfers and approvals, codes.\\n */\\n\\n/**\\n * @dev The same itemId is twice in the bundle.\\n *      This maker order can be valid for ERC1155 collections but will never be valid for ERC721.\\n */\\nuint256 constant SAME_ITEM_ID_IN_BUNDLE = 601;\\n\\n/**\\n * @dev The ERC20 balance of the signer (maker bid user) is inferior to the order bid price.\\n *      This maker order can become valid without any user's action.\\n */\\nuint256 constant ERC20_BALANCE_INFERIOR_TO_PRICE = 611;\\n\\n/**\\n * @dev The ERC20 approval amount of the signer (maker bid user) is inferior to the order bid price.\\n *      This maker order can become valid only with the user's action.\\n */\\nuint256 constant ERC20_APPROVAL_INFERIOR_TO_PRICE = 612;\\n\\n/**\\n * @dev The ERC721 itemId does not exist.\\n *      This maker order can become valid if the item is created later.\\n */\\nuint256 constant ERC721_ITEM_ID_DOES_NOT_EXIST = 621;\\n\\n/**\\n * @dev The ERC721 itemId is not owned by the signer (maker ask user).\\n *      This maker order can become valid without any user's action.\\n */\\nuint256 constant ERC721_ITEM_ID_NOT_IN_BALANCE = 622;\\n\\n/**\\n * @dev The transfer manager contract has not been approved by the ERC721 collection\\n *      contract, either for the entire collection or the itemId.\\n *      This maker order can become valid only with the user's action.\\n *      The collection may not follow the ERC721 standard.\\n */\\nuint256 constant ERC721_NO_APPROVAL_FOR_ALL_OR_ITEM_ID = 623;\\n\\n/**\\n * @dev The ERC1155 collection contract does not implement balanceOf.\\n */\\nuint256 constant ERC1155_BALANCE_OF_DOES_NOT_EXIST = 631;\\n\\n/**\\n * @dev The ERC20 balance of the signer (maker ask user) is inferior to the amount\\n *      required to be sold.\\n *      This maker order can become valid without any user's action.\\n */\\nuint256 constant ERC1155_BALANCE_OF_ITEM_ID_INFERIOR_TO_AMOUNT = 632;\\n\\n/**\\n * @dev The ERC1155 collection contract does not implement isApprovedForAll.\\n *      The collection may not follow the ERC1155 standard.\\n */\\nuint256 constant ERC1155_IS_APPROVED_FOR_ALL_DOES_NOT_EXIST = 633;\\n\\n/**\\n * @dev The transfer manager contract has not been approved by the ERC1155\\n *      collection contract.\\n *      This maker order can become valid only with the user's action.\\n */\\nuint256 constant ERC1155_NO_APPROVAL_FOR_ALL = 634;\\n\\n/**\\n * 7. Asset-type codes\\n */\\n\\n/**\\n * @dev The collection type specified in the order seems incorrect.\\n *      It is expected to be collectionType = 0.\\n */\\nuint256 constant POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC721 = 701;\\n\\n/**\\n * @dev The collection type specified in the order seems incorrect.\\n *      It is expected to be collectionType = 1.\\n */\\nuint256 constant POTENTIAL_INVALID_COLLECTION_TYPE_SHOULD_BE_ERC1155 = 702;\\n\\n/**\\n * 8. Transfer manager-related codes\\n */\\n\\n/**\\n * @dev The user has not approved the protocol to transfer NFTs on behalf\\n *      of the user.\\n *      This maker order can become valid only with the user's action.\\n */\\n// uint256 constant NO_TRANSFER_MANAGER_APPROVAL_BY_USER_FOR_EXCHANGE = 801;\\n\\n/**\\n * @dev The transfer manager's owner has revoked the ability to transfer NFTs\\n *      on behalf of all users that have also approved the protocol.\\n *      This maker order can become valid again only with owner action.\\n */\\n// uint256 constant TRANSFER_MANAGER_APPROVAL_REVOKED_BY_OWNER_FOR_EXCHANGE = 802;\\n\\n/**\\n * 9. Creator fee-related codes\\n */\\n\\n/**\\n * @dev The collection contract has a flexible royalty fee structure that\\n *      prevents this bundle to be traded.\\n *      It applies at the protocol level.\\n *      For instance, 2 items in a bundle have different creator recipients.\\n */\\nuint256 constant BUNDLE_ERC2981_NOT_SUPPORTED = 901;\\n\\n/**\\n * @dev The creator fee applied at the protocol is higher than the threshold\\n *      allowed. The transaction will revert.\\n *      It applies at the protocol level.\\n *      This maker order can become valid only with the creator's action.\\n */\\nuint256 constant CREATOR_FEE_TOO_HIGH = 902;\\n\"\r\n    },\r\n    \"contracts/constants/NumericConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev 100% represented in basis point is 10_000.\\n */\\nuint256 constant ONE_HUNDRED_PERCENT_IN_BP = 10_000;\\n\\n/**\\n * @dev The maximum length of a proof for a batch order is 10.\\n *      The maximum merkle tree that can used for signing has a height of\\n *      2**10 = 1_024.\\n */\\nuint256 constant MAX_CALLDATA_PROOF_LENGTH = 10;\\n\"\r\n    },\r\n    \"contracts/enums/CollectionType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice CollectionType is used in OrderStructs.Maker's collectionType to determine the collection type being traded.\\n */\\nenum CollectionType {\\n    ERC721,\\n    ERC1155\\n}\\n\"\r\n    },\r\n    \"contracts/enums/QuoteType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice QuoteType is used in OrderStructs.Maker's quoteType to determine whether the maker order is a bid or an ask.\\n */\\nenum QuoteType {\\n    Bid,\\n    Ask\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/SignatureCheckerCalldata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC1271} from \\\"./interfaces/generic/IERC1271.sol\\\";\\n\\n// Constants\\nimport {ERC1271_MAGIC_VALUE} from \\\"./constants/StandardConstants.sol\\\";\\n\\n// Errors\\nimport {SignatureParameterSInvalid, SignatureParameterVInvalid, SignatureERC1271Invalid, SignatureEOAInvalid, NullSignerAddress, SignatureLengthInvalid} from \\\"./errors/SignatureCheckerErrors.sol\\\";\\n\\n/**\\n * @title SignatureCheckerCalldata\\n * @notice This library is used to verify signatures for EOAs (with lengths of both 65 and 64 bytes)\\n *         and contracts (ERC1271).\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nlibrary SignatureCheckerCalldata {\\n    /**\\n     * @notice This function verifies whether the signer is valid for a hash and raw signature.\\n     * @param hash Data hash\\n     * @param signer Signer address (to confirm message validity)\\n     * @param signature Signature parameters encoded (v, r, s)\\n     * @dev For EIP-712 signatures, the hash must be the digest (computed with signature hash and domain separator)\\n     */\\n    function verify(bytes32 hash, address signer, bytes calldata signature) internal view {\\n        if (signer.code.length == 0) {\\n            if (_recoverEOASigner(hash, signature) == signer) return;\\n            revert SignatureEOAInvalid();\\n        } else {\\n            if (IERC1271(signer).isValidSignature(hash, signature) == ERC1271_MAGIC_VALUE) return;\\n            revert SignatureERC1271Invalid();\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is internal and splits a signature into r, s, v outputs.\\n     * @param signature A 64 or 65 bytes signature\\n     * @return r The r output of the signature\\n     * @return s The s output of the signature\\n     * @return v The recovery identifier, must be 27 or 28\\n     */\\n    function splitSignature(bytes calldata signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\\n        uint256 length = signature.length;\\n        if (length == 65) {\\n            assembly {\\n                r := calldataload(signature.offset)\\n                s := calldataload(add(signature.offset, 0x20))\\n                v := byte(0, calldataload(add(signature.offset, 0x40)))\\n            }\\n        } else if (length == 64) {\\n            assembly {\\n                r := calldataload(signature.offset)\\n                let vs := calldataload(add(signature.offset, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert SignatureLengthInvalid(length);\\n        }\\n\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            revert SignatureParameterSInvalid();\\n        }\\n\\n        if (v != 27 && v != 28) {\\n            revert SignatureParameterVInvalid(v);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is private and recovers the signer of a signature (for EOA only).\\n     * @param hash Hash of the signed message\\n     * @param signature Bytes containing the signature (64 or 65 bytes)\\n     * @return signer The address that signed the signature\\n     */\\n    function _recoverEOASigner(bytes32 hash, bytes calldata signature) private pure returns (address signer) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\\n\\n        // If the signature is valid (and not malleable), return the signer's address\\n        signer = ecrecover(hash, v, r, s);\\n\\n        if (signer == address(0)) {\\n            revert NullSignerAddress();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelETHReturnETHIfAnyExceptOneWei.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Assembly constants\\nimport {ETHTransferFail_error_selector, ETHTransferFail_error_length, Error_selector_offset} from \\\"../constants/AssemblyConstants.sol\\\";\\n\\n/**\\n * @title LowLevelETHReturnETHIfAnyExceptOneWei\\n * @notice This contract contains a function to return all ETH except 1 wei held.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelETHReturnETHIfAnyExceptOneWei {\\n    /**\\n     * @notice It returns ETH to the original sender if any is left in the payable call\\n     *         but this leaves 1 wei of ETH in the contract.\\n     * @dev It does not revert if self balance is equal to 1 or 0.\\n     */\\n    function _returnETHIfAnyWithOneWeiLeft() internal {\\n        assembly {\\n            let selfBalance := selfbalance()\\n            if gt(selfBalance, 1) {\\n                let status := call(gas(), caller(), sub(selfBalance, 1), 0, 0, 0, 0)\\n                if iszero(status) {\\n                    mstore(0x00, ETHTransferFail_error_selector)\\n                    revert(Error_selector_offset, ETHTransferFail_error_length)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IWETH} from \\\"../interfaces/generic/IWETH.sol\\\";\\n\\n/**\\n * @title LowLevelWETH\\n * @notice This contract contains a function to transfer ETH with an option to wrap to WETH.\\n *         If the ETH transfer fails within a gas limit, the amount in ETH is wrapped to WETH and then transferred.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelWETH {\\n    /**\\n     * @notice It transfers ETH to a recipient with a specified gas limit.\\n     *         If the original transfers fails, it wraps to WETH and transfers the WETH to recipient.\\n     * @param _WETH WETH address\\n     * @param _to Recipient address\\n     * @param _amount Amount to transfer\\n     * @param _gasLimit Gas limit to perform the ETH transfer\\n     */\\n    function _transferETHAndWrapIfFailWithGasLimit(\\n        address _WETH,\\n        address _to,\\n        uint256 _amount,\\n        uint256 _gasLimit\\n    ) internal {\\n        bool status;\\n\\n        assembly {\\n            status := call(_gasLimit, _to, _amount, 0, 0, 0, 0)\\n        }\\n\\n        if (!status) {\\n            IWETH(_WETH).deposit{value: _amount}();\\n            IWETH(_WETH).transfer(_to, _amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC20Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"../interfaces/generic/IERC20.sol\\\";\\n\\n// Errors\\nimport {ERC20TransferFail, ERC20TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC20Transfer\\n * @notice This contract contains low-level calls to transfer ERC20 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC20Transfer {\\n    /**\\n     * @notice Execute ERC20 transferFrom\\n     * @param currency Currency address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20TransferFrom(address currency, address from, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transferFrom, (from, to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFromFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFromFail();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC20 (direct) transfer\\n     * @param currency Currency address\\n     * @param to Recipient address\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC20DirectTransfer(address currency, address to, uint256 amount) internal {\\n        if (currency.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, bytes memory data) = currency.call(abi.encodeCall(IERC20.transfer, (to, amount)));\\n\\n        if (!status) {\\n            revert ERC20TransferFail();\\n        }\\n\\n        if (data.length > 0) {\\n            if (!abi.decode(data, (bool))) {\\n                revert ERC20TransferFail();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExchangeProtocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Libraries\\nimport {OrderStructs} from \\\"../libraries/OrderStructs.sol\\\";\\n\\n/**\\n * @title IExchangeProtocol\\n */\\ninterface IExchangeProtocol {\\n    /**\\n     * @notice This struct contains an order nonce's invalidation status\\n     *         and the order hash that triggered the status change.\\n     * @param orderHash Maker order hash\\n     * @param orderNonce Order nonce\\n     * @param isNonceInvalidated Whether this transaction invalidated the maker user's order nonce at the protocol level\\n     */\\n    struct NonceInvalidationParameters {\\n        bytes32 orderHash;\\n        uint256 orderNonce;\\n        bool isNonceInvalidated;\\n    }\\n\\n    /**\\n     * @notice It is emitted when there is an affiliate fee paid.\\n     * @param affiliate Affiliate address\\n     * @param currency Address of the currency\\n     * @param affiliateFee Affiliate fee (in the currency)\\n     */\\n    event AffiliatePayment(address affiliate, address currency, uint256 affiliateFee);\\n\\n    /**\\n     * @notice It is emitted if there is a change in the domain separator.\\n     */\\n    event NewDomainSeparator();\\n\\n    /**\\n     * @notice It is emitted when there is a new gas limit for a ETH transfer (before it is wrapped to WETH).\\n     * @param gasLimitETHTransfer Gas limit for an ETH transfer\\n     */\\n    event NewGasLimitETHTransfer(uint256 gasLimitETHTransfer);\\n\\n    /**\\n     * @notice It is emitted when a taker ask transaction is completed.\\n     * @param nonceInvalidationParameters Struct about nonce invalidation parameters\\n     * @param askUser Address of the ask user\\n     * @param bidUser Address of the bid user\\n     * @param strategyId Id of the strategy\\n     * @param currency Address of the currency\\n     * @param collection Address of the collection\\n     * @param itemIds Array of item ids\\n     * @param amounts Array of amounts (for item ids)\\n     * @param feeRecipients Array of fee recipients\\n     *        feeRecipients[0] User who receives the proceeds of the sale (it can be the taker ask user or different)\\n     *        feeRecipients[1] Creator fee recipient (if none, address(0))\\n     * @param feeAmounts Array of fee amounts\\n     *        feeAmounts[0] Fee amount for the user receiving sale proceeds\\n     *        feeAmounts[1] Creator fee amount\\n     *        feeAmounts[2] Protocol fee amount prior to adjustment for a potential affiliate payment\\n     */\\n    event TakerAsk(\\n        NonceInvalidationParameters nonceInvalidationParameters,\\n        address askUser, // taker (initiates the transaction)\\n        address bidUser, // maker (receives the NFT)\\n        uint256 strategyId,\\n        address currency,\\n        address collection,\\n        uint256[] itemIds,\\n        uint256[] amounts,\\n        address[2] feeRecipients,\\n        uint256[3] feeAmounts\\n    );\\n\\n    /**\\n     * @notice It is emitted when a taker bid transaction is completed.\\n     * @param nonceInvalidationParameters Struct about nonce invalidation parameters\\n     * @param bidUser Address of the bid user\\n     * @param bidRecipient Address of the recipient of the bid\\n     * @param strategyId Id of the strategy\\n     * @param currency Address of the currency\\n     * @param collection Address of the collection\\n     * @param itemIds Array of item ids\\n     * @param amounts Array of amounts (for item ids)\\n     * @param feeRecipients Array of fee recipients\\n     *        feeRecipients[0] User who receives the proceeds of the sale (it is the maker ask user)\\n     *        feeRecipients[1] Creator fee recipient (if none, address(0))\\n     * @param feeAmounts Array of fee amounts\\n     *        feeAmounts[0] Fee amount for the user receiving sale proceeds\\n     *        feeAmounts[1] Creator fee amount\\n     *        feeAmounts[2] Protocol fee amount prior to adjustment for a potential affiliate payment\\n     */\\n    event TakerBid(\\n        NonceInvalidationParameters nonceInvalidationParameters,\\n        address bidUser, // taker (initiates the transaction)\\n        address bidRecipient, // taker (receives the NFT)\\n        uint256 strategyId,\\n        address currency,\\n        address collection,\\n        uint256[] itemIds,\\n        uint256[] amounts,\\n        address[2] feeRecipients,\\n        uint256[3] feeAmounts\\n    );\\n\\n    /**\\n     * @notice It is returned if the gas limit for a standard ETH transfer is too low.\\n     */\\n    error NewGasLimitETHTransferTooLow();\\n\\n    /**\\n     * @notice It is returned if the domain separator cannot be updated (i.e. the chainId is the same).\\n     */\\n    error SameDomainSeparator();\\n\\n    /**\\n     * @notice It is returned if the domain separator should change.\\n     */\\n    error ChainIdInvalid();\\n\\n    /**\\n     * @notice It is returned if the nonces are invalid.\\n     */\\n    error NoncesInvalid();\\n\\n    /**\\n     * @notice It is returned if the wrapped native token is already set.\\n     */\\n    error WrappedNativeTokenAlreadyInitialized();\\n\\n    /**\\n     * @notice This function allows a user to execute a taker ask (against a maker bid).\\n     * @param takerAsk Taker ask struct\\n     * @param makerBid Maker bid struct\\n     * @param makerSignature Maker signature\\n     * @param merkleTree Merkle tree struct (if the signature contains multiple maker orders)\\n     * @param affiliate Affiliate address\\n     */\\n    function executeTakerAsk(\\n        OrderStructs.Taker calldata takerAsk,\\n        OrderStructs.Maker calldata makerBid,\\n        bytes calldata makerSignature,\\n        OrderStructs.MerkleTree calldata merkleTree,\\n        address affiliate\\n    ) external;\\n\\n    /**\\n     * @notice This function allows a user to execute a taker bid (against a maker ask).\\n     * @param takerBid Taker bid struct\\n     * @param makerAsk Maker ask struct\\n     * @param makerSignature Maker signature\\n     * @param merkleTree Merkle tree struct (if the signature contains multiple maker orders)\\n     * @param affiliate Affiliate address\\n     */\\n    function executeTakerBid(\\n        OrderStructs.Taker calldata takerBid,\\n        OrderStructs.Maker calldata makerAsk,\\n        bytes calldata makerSignature,\\n        OrderStructs.MerkleTree calldata merkleTree,\\n        address affiliate\\n    ) external payable;\\n\\n    /**\\n     * @notice This function allows a user to batch buy with an array of taker bids (against an array of maker asks).\\n     * @param takerBids Array of taker bid structs\\n     * @param makerAsks Array of maker ask structs\\n     * @param makerSignatures Array of maker signatures\\n     * @param merkleTrees Array of merkle tree structs if the signature contains multiple maker orders\\n     * @param affiliate Affiliate address\\n     * @param isAtomic Whether the execution should be atomic\\n     *        i.e. whether it should revert if 1 or more transactions fail\\n     */\\n    function executeMultipleTakerBids(\\n        OrderStructs.Taker[] calldata takerBids,\\n        OrderStructs.Maker[] calldata makerAsks,\\n        bytes[] calldata makerSignatures,\\n        OrderStructs.MerkleTree[] calldata merkleTrees,\\n        address affiliate,\\n        bool isAtomic\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/TransferSelectorNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Direct dependencies\\nimport {PackableReentrancyGuard} from \\\"@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\\\";\\nimport {ExecutionManager} from \\\"./ExecutionManager.sol\\\";\\nimport {TransferManager} from \\\"./TransferManager.sol\\\";\\n\\n// Libraries\\nimport {OrderStructs} from \\\"./libraries/OrderStructs.sol\\\";\\n\\n// Enums\\nimport {CollectionType} from \\\"./enums/CollectionType.sol\\\";\\n\\n/**\\n * @title TransferSelectorNFT\\n * @notice This contract handles the logic for transferring non-fungible items.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract TransferSelectorNFT is ExecutionManager, PackableReentrancyGuard, TransferManager {\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     * @param _protocolFeeRecipient Protocol fee recipient address\\n     */\\n    constructor(address _owner, address _protocolFeeRecipient) ExecutionManager(_owner, _protocolFeeRecipient) {}\\n\\n    /**\\n     * @notice This function is internal and used to transfer non-fungible tokens.\\n     * @param collection Collection address\\n     * @param collectionType Collection type (e.g. 0 = ERC721, 1 = ERC1155)\\n     * @param sender Sender address\\n     * @param recipient Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     */\\n    function _transferNFT(\\n        address collection,\\n        CollectionType collectionType,\\n        address sender,\\n        address recipient,\\n        uint256[] memory itemIds,\\n        uint256[] memory amounts\\n    ) internal {\\n        if (collectionType == CollectionType.ERC721) {\\n            _transferItemsERC721(collection, sender, recipient, itemIds, amounts);\\n        } else if (collectionType == CollectionType.ERC1155) {\\n            _transferItemsERC1155(collection, sender, recipient, itemIds, amounts);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BatchOrderTypehashRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Shared errors\\nimport {MerkleProofTooLarge} from \\\"./errors/SharedErrors.sol\\\";\\n\\n/**\\n * @title BatchOrderTypehashRegistry\\n * @notice The contract generates the batch order hash that is used to compute the digest for signature verification.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract BatchOrderTypehashRegistry {\\n    /**\\n     * @notice This function returns the hash of the concatenation of batch order type hash and merkle root.\\n     * @param root Merkle root\\n     * @param proofLength Merkle proof length\\n     * @return batchOrderHash The batch order hash\\n     */\\n    function hashBatchOrder(bytes32 root, uint256 proofLength) public pure returns (bytes32 batchOrderHash) {\\n        batchOrderHash = keccak256(abi.encode(_getBatchOrderTypehash(proofLength), root));\\n    }\\n\\n    /**\\n     * @dev It looks like this for each height\\n     *      height == 1: BatchOrder(Maker[2] tree)Maker(uint8 quoteType,uint256 globalNonce,uint256 subsetNonce,uint256 orderNonce,uint256 strategyId,uint8 collectionType,address collection,address currency,address signer,uint256 startTime,uint256 endTime,uint256 price,uint256[] itemIds,uint256[] amounts,bytes additionalParameters)\\n     *      height == 2: BatchOrder(Maker[2][2] tree)Maker(uint8 quoteType,uint256 globalNonce,uint256 subsetNonce,uint256 orderNonce,uint256 strategyId,uint8 collectionType,address collection,address currency,address signer,uint256 startTime,uint256 endTime,uint256 price,uint256[] itemIds,uint256[] amounts,bytes additionalParameters)\\n     *      height == n: BatchOrder(Maker[2]...[2] tree)Maker(uint8 quoteType,uint256 globalNonce,uint256 subsetNonce,uint256 orderNonce,uint256 strategyId,uint8 collectionType,address collection,address currency,address signer,uint256 startTime,uint256 endTime,uint256 price,uint256[] itemIds,uint256[] amounts,bytes additionalParameters)\\n     */\\n    function _getBatchOrderTypehash(uint256 height) internal pure returns (bytes32 typehash) {\\n        if (height == 1) {\\n            typehash = hex\\\"9661287f7a4aa4867db46a2453ee15bebac4e8fc25667a58718da658f15de643\\\";\\n        } else if (height == 2) {\\n            typehash = hex\\\"a54ab330ea9e1dfccee2b86f3666989e7fbd479704416c757c8de8e820142a08\\\";\\n        } else if (height == 3) {\\n            typehash = hex\\\"93390f5d45ede9dea305f16aec86b2472af4f823851637f1b7019ad0775cea49\\\";\\n        } else if (height == 4) {\\n            typehash = hex\\\"9dda2c8358da895e43d574bb15954ce5727b22e923a2d8f28261f297bce42f0b\\\";\\n        } else if (height == 5) {\\n            typehash = hex\\\"92dc717124e161262f9d10c7079e7d54dc51271893fba54aa4a0f270fecdcc98\\\";\\n        } else if (height == 6) {\\n            typehash = hex\\\"ce02aee5a7a35d40d974463c4c6e5534954fb07a7e7bc966fee268a15337bfd8\\\";\\n        } else if (height == 7) {\\n            typehash = hex\\\"f7a65efd167a18f7091b2bb929d687dd94503cf0a43620487055ed7d6b727559\\\";\\n        } else if (height == 8) {\\n            typehash = hex\\\"def24acacad1318b664520f7c10e8bc6d1e7f6f6f7c8b031e70624ceb42266a6\\\";\\n        } else if (height == 9) {\\n            typehash = hex\\\"4cb4080dc4e7bae88b4dc4307ad5117fa4f26195998a1b5f40368809d7f4c7f2\\\";\\n        } else if (height == 10) {\\n            typehash = hex\\\"f8b1f864164d8d6e0b45f1399bd711223117a4ab0b057a9c2d7779e86a7c88db\\\";\\n        } else {\\n            revert MerkleProofTooLarge(height);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/constants/StandardConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @dev ERC1271's magic value (bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))\\n */\\nbytes4 constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/SignatureCheckerErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the signer is null.\\n */\\nerror NullSignerAddress();\\n\\n/**\\n * @notice It is emitted if the signature is invalid for an EOA (the address recovered is not the expected one).\\n */\\nerror SignatureEOAInvalid();\\n\\n/**\\n * @notice It is emitted if the signature is invalid for a ERC1271 contract signer.\\n */\\nerror SignatureERC1271Invalid();\\n\\n/**\\n * @notice It is emitted if the signature's length is neither 64 nor 65 bytes.\\n */\\nerror SignatureLengthInvalid(uint256 length);\\n\\n/**\\n * @notice It is emitted if the signature is invalid due to S parameter.\\n */\\nerror SignatureParameterSInvalid();\\n\\n/**\\n * @notice It is emitted if the signature is invalid due to V parameter.\\n */\\nerror SignatureParameterVInvalid(uint8 v);\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/constants/AssemblyConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/*\\n * @dev error ETHTransferFail()\\n *      Memory layout:\\n *        - 0x00: Left-padded selector (data begins at 0x1c)\\n *      Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant ETHTransferFail_error_selector = 0x07246cf4;\\nuint256 constant ETHTransferFail_error_length = 0x04;\\nuint256 constant Error_selector_offset = 0x1c;\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/generic/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the ETH transfer fails.\\n */\\nerror ETHTransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 approval fails.\\n */\\nerror ERC20ApprovalFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transfer fails.\\n */\\nerror ERC20TransferFail();\\n\\n/**\\n * @notice It is emitted if the ERC20 transferFrom fails.\\n */\\nerror ERC20TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC721 transferFrom fails.\\n */\\nerror ERC721TransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeTransferFrom fails.\\n */\\nerror ERC1155SafeTransferFromFail();\\n\\n/**\\n * @notice It is emitted if the ERC1155 safeBatchTransferFrom fails.\\n */\\nerror ERC1155SafeBatchTransferFromFail();\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/errors/GenericErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @notice It is emitted if the call recipient is not a contract.\\n */\\nerror NotAContract();\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/PackableReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IReentrancyGuard} from \\\"./interfaces/IReentrancyGuard.sol\\\";\\n\\n/**\\n * @title PackableReentrancyGuard\\n * @notice This contract protects against reentrancy attacks.\\n *         It is adjusted from OpenZeppelin.\\n *         The only difference between this contract and ReentrancyGuard\\n *         is that _status is uint8 instead of uint256 so that it can be\\n *         packed with other contracts' storage variables.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract PackableReentrancyGuard is IReentrancyGuard {\\n    uint8 private _status;\\n\\n    /**\\n     * @notice Modifier to wrap functions to prevent reentrancy calls.\\n     */\\n    modifier nonReentrant() {\\n        if (_status == 2) {\\n            revert ReentrancyFail();\\n        }\\n\\n        _status = 2;\\n        _;\\n        _status = 1;\\n    }\\n\\n    constructor() {\\n        _status = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ExecutionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Libraries\\nimport {OrderStructs} from \\\"./libraries/OrderStructs.sol\\\";\\n\\n// Interfaces\\nimport {IExecutionManager} from \\\"./interfaces/IExecutionManager.sol\\\";\\nimport {ICreatorFeeManager} from \\\"./interfaces/ICreatorFeeManager.sol\\\";\\n\\n// Direct dependencies\\nimport {InheritedStrategy} from \\\"./InheritedStrategy.sol\\\";\\nimport {NonceManager} from \\\"./NonceManager.sol\\\";\\nimport {StrategyManager} from \\\"./StrategyManager.sol\\\";\\n\\n// Assembly\\nimport {NoSelectorForStrategy_error_selector, NoSelectorForStrategy_error_length, OutsideOfTimeRange_error_selector, OutsideOfTimeRange_error_length, Error_selector_offset} from \\\"./constants/AssemblyConstants.sol\\\";\\n\\n// Constants\\nimport {ONE_HUNDRED_PERCENT_IN_BP} from \\\"./constants/NumericConstants.sol\\\";\\n\\n// Enums\\nimport {QuoteType} from \\\"./enums/QuoteType.sol\\\";\\n\\n/**\\n * @title ExecutionManager\\n * @notice This contract handles the execution and resolution of transactions. A transaction is executed on-chain\\n *         when an off-chain maker order is matched by on-chain taker order of a different kind.\\n *         For instance, a taker ask is executed against a maker bid (or a taker bid against a maker ask).\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract ExecutionManager is InheritedStrategy, NonceManager, StrategyManager, IExecutionManager {\\n    /**\\n     * @notice Protocol fee recipient.\\n     */\\n    address public protocolFeeRecipient;\\n\\n    /**\\n     * @notice Maximum creator fee (in basis point).\\n     */\\n    uint16 public maxCreatorFeeBp = 1_000;\\n\\n    /**\\n     * @notice Creator fee manager.\\n     */\\n    ICreatorFeeManager public creatorFeeManager;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     * @param _protocolFeeRecipient Protocol fee recipient address\\n     */\\n    constructor(address _owner, address _protocolFeeRecipient) StrategyManager(_owner) {\\n        _updateProtocolFeeRecipient(_protocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the creator fee manager address.\\n     * @param newCreatorFeeManager Address of the creator fee manager\\n     * @dev Only callable by owner.\\n     */\\n    function updateCreatorFeeManager(address newCreatorFeeManager) external onlyOwner {\\n        creatorFeeManager = ICreatorFeeManager(newCreatorFeeManager);\\n        emit NewCreatorFeeManager(newCreatorFeeManager);\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the maximum creator fee (in basis point).\\n     * @param newMaxCreatorFeeBp New maximum creator fee (in basis point)\\n     * @dev The maximum value that can be set is 25%.\\n     *      Only callable by owner.\\n     */\\n    function updateMaxCreatorFeeBp(uint16 newMaxCreatorFeeBp) external onlyOwner {\\n        if (newMaxCreatorFeeBp > 2_500) {\\n            revert CreatorFeeBpTooHigh();\\n        }\\n\\n        maxCreatorFeeBp = newMaxCreatorFeeBp;\\n\\n        emit NewMaxCreatorFeeBp(newMaxCreatorFeeBp);\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the protocol fee recipient.\\n     * @param newProtocolFeeRecipient New protocol fee recipient address\\n     * @dev Only callable by owner.\\n     */\\n    function updateProtocolFeeRecipient(address newProtocolFeeRecipient) external onlyOwner {\\n        _updateProtocolFeeRecipient(newProtocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to execute a transaction initiated by a taker order.\\n     * @param takerOrder Taker order struct (taker specific parameters for the execution)\\n     * @param makerOrder Maker order struct (maker specific parameter for the execution)\\n     * @param sender The address that sent the transaction\\n     * @return itemIds Array of item ids to be traded\\n     * @return amounts Array of amounts for each item id\\n     * @return recipients Array of recipient addresses\\n     * @return feeAmounts Array of fee amounts\\n     * @return isNonceInvalidated Whether the order's nonce will be invalidated after executing the order\\n     */\\n    function _executeStrategyForTakerOrder(\\n        OrderStructs.Taker calldata takerOrder,\\n        OrderStructs.Maker calldata makerOrder,\\n        address sender\\n    )\\n        internal\\n        returns (\\n            uint256[] memory itemIds,\\n            uint256[] memory amounts,\\n            address[2] memory recipients,\\n            uint256[3] memory feeAmounts,\\n            bool isNonceInvalidated\\n        )\\n    {\\n        uint256 price;\\n\\n        // Verify the order validity for timestamps\\n        _verifyOrderTimestampValidity(makerOrder.startTime, makerOrder.endTime);\\n\\n        if (makerOrder.strategyId == 0) {\\n            _verifyItemIdsAndAmountsEqualLengthsAndValidAmounts(makerOrder.amounts, makerOrder.itemIds);\\n            (price, itemIds, amounts) = (makerOrder.price, makerOrder.itemIds, makerOrder.amounts);\\n            isNonceInvalidated = true;\\n        } else {\\n            if (strategyInfo[makerOrder.strategyId].isActive) {\\n                /**\\n                 * @dev This is equivalent to\\n                 *\\n                 * if (makerOrder.quoteType == QuoteType.Bid) {\\n                 *     if (!strategyInfo[makerOrder.strategyId].isMakerBid) {\\n                 *         revert NoSelectorForStrategy();\\n                 *     }\\n                 * } else {\\n                 *     if (strategyInfo[makerOrder.strategyId].isMakerBid) {\\n                 *         revert NoSelectorForStrategy();\\n                 *     }\\n                 * }\\n                 *\\n                 * because one must be 0 and another must be 1 for the function\\n                 * to not revert.\\n                 *\\n                 * Both quoteType (an enum with 2 values) and isMakerBid (a bool)\\n                 * can only be 0 or 1.\\n                 */\\n                QuoteType quoteType = makerOrder.quoteType;\\n                bool isMakerBid = strategyInfo[makerOrder.strategyId].isMakerBid;\\n                assembly {\\n                    if eq(quoteType, isMakerBid) {\\n                        mstore(0x00, NoSelectorForStrategy_error_selector)\\n                        revert(Error_selector_offset, NoSelectorForStrategy_error_length)\\n                    }\\n                }\\n\\n                (bool status, bytes memory data) = strategyInfo[makerOrder.strategyId].implementation.call(\\n                    abi.encodeWithSelector(strategyInfo[makerOrder.strategyId].selector, takerOrder, makerOrder)\\n                );\\n\\n                if (!status) {\\n                    // @dev It forwards the revertion message from the low-level call\\n                    assembly {\\n                        revert(add(data, 32), mload(data))\\n                    }\\n                }\\n\\n                (price, itemIds, amounts, isNonceInvalidated) = abi.decode(data, (uint256, uint256[], uint256[], bool));\\n            } else {\\n                revert StrategyNotAvailable(makerOrder.strategyId);\\n            }\\n        }\\n\\n        // Creator fee and adjustment of protocol fee\\n        (recipients[1], feeAmounts[1]) = _getCreatorRecipientAndCalculateFeeAmount(\\n            makerOrder.collection,\\n            price,\\n            itemIds\\n        );\\n        if (makerOrder.quoteType == QuoteType.Bid) {\\n            _setTheRestOfFeeAmountsAndRecipients(\\n                makerOrder.strategyId,\\n                price,\\n                takerOrder.recipient == address(0) ? sender : takerOrder.recipient,\\n                feeAmounts,\\n                recipients\\n            );\\n        } else {\\n            _setTheRestOfFeeAmountsAndRecipients(\\n                makerOrder.strategyId,\\n                price,\\n                makerOrder.signer,\\n                feeAmounts,\\n                recipients\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice This private function updates the protocol fee recipient.\\n     * @param newProtocolFeeRecipient New protocol fee recipient address\\n     */\\n    function _updateProtocolFeeRecipient(address newProtocolFeeRecipient) private {\\n        if (newProtocolFeeRecipient == address(0)) {\\n            revert NewProtocolFeeRecipientCannotBeNullAddress();\\n        }\\n\\n        protocolFeeRecipient = newProtocolFeeRecipient;\\n        emit NewProtocolFeeRecipient(newProtocolFeeRecipient);\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to calculate\\n     *         the protocol fee amount for a set of fee amounts.\\n     * @param price Transaction price\\n     * @param strategyId Strategy id\\n     * @param creatorFeeAmount Creator fee amount\\n     * @param minTotalFeeAmount Min total fee amount\\n     * @return protocolFeeAmount Protocol fee amount\\n     */\\n    function _calculateProtocolFeeAmount(\\n        uint256 price,\\n        uint256 strategyId,\\n        uint256 creatorFeeAmount,\\n        uint256 minTotalFeeAmount\\n    ) private view returns (uint256 protocolFeeAmount) {\\n        protocolFeeAmount = (price * strategyInfo[strategyId].standardProtocolFeeBp) / ONE_HUNDRED_PERCENT_IN_BP;\\n\\n        if (protocolFeeAmount + creatorFeeAmount < minTotalFeeAmount) {\\n            protocolFeeAmount = minTotalFeeAmount - creatorFeeAmount;\\n        }\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to get the creator fee address\\n     *         and calculate the creator fee amount.\\n     * @param collection Collection address\\n     * @param price Transaction price\\n     * @param itemIds Array of item ids\\n     * @return creator Creator recipient\\n     * @return creatorFeeAmount Creator fee amount\\n     */\\n    function _getCreatorRecipientAndCalculateFeeAmount(\\n        address collection,\\n        uint256 price,\\n        uint256[] memory itemIds\\n    ) private view returns (address creator, uint256 creatorFeeAmount) {\\n        if (address(creatorFeeManager) != address(0)) {\\n            (creator, creatorFeeAmount) = creatorFeeManager.viewCreatorFeeInfo(collection, price, itemIds);\\n\\n            if (creator == address(0)) {\\n                // If recipient is null address, creator fee is set to 0\\n                creatorFeeAmount = 0;\\n            } else if (creatorFeeAmount * ONE_HUNDRED_PERCENT_IN_BP > (price * uint256(maxCreatorFeeBp))) {\\n                // If creator fee is higher than tolerated, it reverts\\n                revert CreatorFeeBpTooHigh();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This function does not need to return feeAmounts and recipients as they are modified\\n     *      in memory.\\n     */\\n    function _setTheRestOfFeeAmountsAndRecipients(\\n        uint256 strategyId,\\n        uint256 price,\\n        address askRecipient,\\n        uint256[3] memory feeAmounts,\\n        address[2] memory recipients\\n    ) private view {\\n        // Compute minimum total fee amount\\n        uint256 minTotalFeeAmount = (price * strategyInfo[strategyId].minTotalFeeBp) / ONE_HUNDRED_PERCENT_IN_BP;\\n\\n        if (feeAmounts[1] == 0) {\\n            // If creator fee is null, protocol fee is set as the minimum total fee amount\\n            feeAmounts[2] = minTotalFeeAmount;\\n            // Net fee amount for seller\\n            feeAmounts[0] = price - feeAmounts[2];\\n        } else {\\n            // If there is a creator fee information, the protocol fee amount can be calculated\\n            feeAmounts[2] = _calculateProtocolFeeAmount(price, strategyId, feeAmounts[1], minTotalFeeAmount);\\n            // Net fee amount for seller\\n            feeAmounts[0] = price - feeAmounts[1] - feeAmounts[2];\\n        }\\n\\n        recipients[0] = askRecipient;\\n    }\\n\\n    /**\\n     * @notice This function is internal and is used to verify the validity of an order\\n     *         in the context of the current block timestamps.\\n     * @param startTime Start timestamp\\n     * @param endTime End timestamp\\n     */\\n    function _verifyOrderTimestampValidity(uint256 startTime, uint256 endTime) private view {\\n        // if (startTime > block.timestamp || endTime < block.timestamp) revert OutsideOfTimeRange();\\n        assembly {\\n            if or(gt(startTime, timestamp()), lt(endTime, timestamp())) {\\n                mstore(0x00, OutsideOfTimeRange_error_selector)\\n                revert(Error_selector_offset, OutsideOfTimeRange_error_length)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// LooksRare unopinionated libraries\\nimport {LowLevelERC721Transfer} from \\\"@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\\\";\\nimport {LowLevelERC1155Transfer} from \\\"./helpers/LowLevelERC1155Transfer.sol\\\";\\n\\n// Interfaces and errors\\nimport {ITransferManager} from \\\"./interfaces/ITransferManager.sol\\\";\\nimport {AmountInvalid, LengthsInvalid} from \\\"./errors/SharedErrors.sol\\\";\\n\\n// Libraries\\nimport {OrderStructs} from \\\"./libraries/OrderStructs.sol\\\";\\n\\n// Enums\\nimport {CollectionType} from \\\"./enums/CollectionType.sol\\\";\\n\\n/**\\n * @title TransferManager\\n * @notice This contract provides the transfer functions for ERC721/ERC1155 for contracts that require them.\\n *         Collection type \\\"0\\\" refers to ERC721 transfer functions.\\n *         Collection type \\\"1\\\" refers to ERC1155 transfer functions.\\n * @dev \\\"Safe\\\" transfer functions for ERC721 are not implemented since they come with added gas costs\\n *       to verify if the recipient is a contract as it requires verifying the receiver interface is valid.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract TransferManager is ITransferManager, LowLevelERC721Transfer, LowLevelERC1155Transfer {\\n    /**\\n     * @notice This function transfers items for a single ERC721 collection.\\n     * @param collection Collection address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     */\\n    function _transferItemsERC721(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256[] memory itemIds,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 length = itemIds.length;\\n        if (length == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        for (uint256 i; i < length; ) {\\n            if (amounts[i] != 1) {\\n                revert AmountInvalid();\\n            }\\n            _executeERC721TransferFrom(collection, from, to, itemIds[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice This function transfers items for a single ERC1155 collection.\\n     * @param collection Collection address\\n     * @param from Sender address\\n     * @param to Recipient address\\n     * @param itemIds Array of itemIds\\n     * @param amounts Array of amounts\\n     * @dev It does not allow batch transferring if from = msg.sender since native function should be used.\\n     */\\n    function _transferItemsERC1155(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256[] memory itemIds,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 length = itemIds.length;\\n\\n        if (length == 0 || amounts.length != length) {\\n            revert LengthsInvalid();\\n        }\\n\\n        if (length == 1) {\\n            if (amounts[0] == 0) {\\n                revert AmountInvalid();\\n            }\\n            _executeERC1155SafeTransferFrom(collection, from, to, itemIds[0], amounts[0]);\\n        } else {\\n            for (uint256 i; i < length; ) {\\n                if (amounts[i] == 0) {\\n                    revert AmountInvalid();\\n                }\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            _executeERC1155SafeBatchTransferFrom(collection, from, to, itemIds, amounts);\\n        }\\n    }\\n\\n    /**\\n     * @notice This function transfers items across an array of collections that can be both ERC721 and ERC1155.\\n     * @param items Array of BatchTransferItem\\n     * @param from Sender address\\n     * @param to Recipient address\\n     */\\n    function transferBatchItemsAcrossCollections(\\n        BatchTransferItem[] calldata items,\\n        address from,\\n        address to\\n    ) external {\\n        uint256 itemsLength = items.length;\\n\\n        if (itemsLength == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        if (from != msg.sender) {\\n            revert TransferCallerInvalid();\\n        }\\n\\n        for (uint256 i; i < itemsLength; ) {\\n            uint256[] calldata itemIds = items[i].itemIds;\\n            uint256 itemIdsLengthForSingleCollection = itemIds.length;\\n            uint256[] calldata amounts = items[i].amounts;\\n\\n            if (itemIdsLengthForSingleCollection == 0 || amounts.length != itemIdsLengthForSingleCollection) {\\n                revert LengthsInvalid();\\n            }\\n\\n            CollectionType collectionType = items[i].collectionType;\\n            if (collectionType == CollectionType.ERC721) {\\n                for (uint256 j; j < itemIdsLengthForSingleCollection; ) {\\n                    if (amounts[j] != 1) {\\n                        revert AmountInvalid();\\n                    }\\n                    _executeERC721TransferFrom(items[i].collection, from, to, itemIds[j]);\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n            } else if (collectionType == CollectionType.ERC1155) {\\n                for (uint256 j; j < itemIdsLengthForSingleCollection; ) {\\n                    if (amounts[j] == 0) {\\n                        revert AmountInvalid();\\n                    }\\n\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n                _executeERC1155SafeBatchTransferFrom(items[i].collection, from, to, itemIds, amounts);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/IReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IReentrancyGuard\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IReentrancyGuard {\\n    /**\\n     * @notice This is returned when there is a reentrant call.\\n     */\\n    error ReentrancyFail();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExecutionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IExecutionManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IExecutionManager {\\n    /**\\n     * @notice It is issued when there is a new creator fee manager.\\n     * @param creatorFeeManager Address of the new creator fee manager\\n     */\\n    event NewCreatorFeeManager(address creatorFeeManager);\\n\\n    /**\\n     * @notice It is issued when there is a new maximum creator fee (in basis point).\\n     * @param maxCreatorFeeBp New maximum creator fee (in basis point)\\n     */\\n    event NewMaxCreatorFeeBp(uint256 maxCreatorFeeBp);\\n\\n    /**\\n     * @notice It is issued when there is a new protocol fee recipient address.\\n     * @param protocolFeeRecipient Address of the new protocol fee recipient\\n     */\\n    event NewProtocolFeeRecipient(address protocolFeeRecipient);\\n\\n    /**\\n     * @notice It is returned if the creator fee (in basis point) is too high.\\n     */\\n    error CreatorFeeBpTooHigh();\\n\\n    /**\\n     * @notice It is returned if the new protocol fee recipient is set to address(0).\\n     */\\n    error NewProtocolFeeRecipientCannotBeNullAddress();\\n\\n    /**\\n     * @notice It is returned if there is no selector for maker ask/bid for a given strategyId,\\n     *         depending on the quote type.\\n     */\\n    error NoSelectorForStrategy();\\n\\n    /**\\n     * @notice It is returned if the current block timestamp is not between start and end times in the maker order.\\n     */\\n    error OutsideOfTimeRange();\\n\\n    /**\\n     * @notice It is returned if the strategy id has no implementation.\\n     * @dev It is returned if there is no implementation address and the strategyId is strictly greater than 0.\\n     */\\n    error StrategyNotAvailable(uint256 strategyId);\\n}\\n\"\r\n    },\r\n    \"contracts/InheritedStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Libraries\\nimport {OrderStructs} from \\\"./libraries/OrderStructs.sol\\\";\\n\\n// Shared errors\\nimport {OrderInvalid} from \\\"./errors/SharedErrors.sol\\\";\\n\\n// Assembly\\nimport {OrderInvalid_error_selector, OrderInvalid_error_length, Error_selector_offset, OneWord} from \\\"./constants/AssemblyConstants.sol\\\";\\n\\n/**\\n * @title InheritedStrategy\\n * @notice This contract handles the verification of parameters for standard transactions.\\n *         It does not verify the taker struct's itemIds and amounts array as well as\\n *         minPrice (taker ask) / maxPrice (taker bid) because before the taker executes the\\n *         transaction and the maker itemIds/amounts/price should have already been confirmed off-chain.\\n * @dev A standard transaction (bid or ask) is mapped to strategyId = 0.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract InheritedStrategy {\\n    /**\\n     * @notice This function is internal and is used to validate the parameters for a standard sale strategy\\n     *         when the standard transaction is initiated by a taker bid.\\n     * @param amounts Array of amounts\\n     * @param itemIds Array of item ids\\n     */\\n    function _verifyItemIdsAndAmountsEqualLengthsAndValidAmounts(\\n        uint256[] calldata amounts,\\n        uint256[] calldata itemIds\\n    ) internal pure {\\n        assembly {\\n            let end\\n            {\\n                /*\\n                 * @dev If A == B, then A XOR B == 0.\\n                 *\\n                 * if (amountsLength == 0 || amountsLength != itemIdsLength) {\\n                 *     revert OrderInvalid();\\n                 * }\\n                 */\\n                let amountsLength := amounts.length\\n                let itemIdsLength := itemIds.length\\n\\n                if or(iszero(amountsLength), xor(amountsLength, itemIdsLength)) {\\n                    mstore(0x00, OrderInvalid_error_selector)\\n                    revert(Error_selector_offset, OrderInvalid_error_length)\\n                }\\n\\n                /**\\n                 * @dev Shifting left 5 times is equivalent to amountsLength * 32 bytes\\n                 */\\n                end := shl(5, amountsLength)\\n            }\\n\\n            let amountsOffset := amounts.offset\\n\\n            for {\\n\\n            } end {\\n\\n            } {\\n                /**\\n                 * @dev Starting from the end of the array minus 32 bytes to load the last item,\\n                 *      ending with `end` equal to 0 to load the first item\\n                 *\\n                 * uint256 end = amountsLength;\\n                 *\\n                 * for (uint256 i = end - 1; i >= 0; i--) {\\n                 *   uint256 amount = amounts[i];\\n                 *   if (amount == 0) {\\n                 *      revert OrderInvalid();\\n                 *   }\\n                 * }\\n                 */\\n                end := sub(end, OneWord)\\n\\n                let amount := calldataload(add(amountsOffset, end))\\n\\n                if iszero(amount) {\\n                    mstore(0x00, OrderInvalid_error_selector)\\n                    revert(Error_selector_offset, OrderInvalid_error_length)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Interfaces and errors\\nimport {INonceManager} from \\\"./interfaces/INonceManager.sol\\\";\\nimport {LengthsInvalid} from \\\"./errors/SharedErrors.sol\\\";\\n\\n/**\\n * @title NonceManager\\n * @notice This contract handles the nonce logic that is used for invalidating maker orders that exist off-chain.\\n *         The nonce logic revolves around three parts at the user level:\\n *         - order nonce (orders sharing an order nonce are conditional, OCO-like)\\n *         - subset (orders can be grouped under a same subset)\\n *         - bid/ask (all orders can be executed only if the bid/ask nonce matches the user's one on-chain)\\n *         Only the order nonce is invalidated at the time of the execution of a maker order that contains it.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract NonceManager is INonceManager {\\n    /**\\n     * @notice Magic value nonce returned if executed (or cancelled).\\n     */\\n    bytes32 public constant MAGIC_VALUE_ORDER_NONCE_EXECUTED = keccak256(\\\"ORDER_NONCE_EXECUTED\\\");\\n\\n    /**\\n     * @notice This tracks the bid and ask nonces for a user address.\\n     */\\n    mapping(address => UserBidAskNonces) public userBidAskNonces;\\n\\n    /**\\n     * @notice This checks whether the order nonce for a user was executed or cancelled.\\n     */\\n    mapping(address => mapping(uint256 => bytes32)) public userOrderNonce;\\n\\n    /**\\n     * @notice This checks whether the subset nonce for a user was cancelled.\\n     */\\n    mapping(address => mapping(uint256 => bool)) public userSubsetNonce;\\n\\n    /**\\n     * @notice This function allows a user to cancel an array of order nonces.\\n     * @param orderNonces Array of order nonces\\n     * @dev It does not check the status of the nonces to save gas\\n     *      and to prevent revertion if one of the orders is filled in the same\\n     *      block.\\n     */\\n    function cancelOrderNonces(uint256[] calldata orderNonces) external {\\n        uint256 length = orderNonces.length;\\n        if (length == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        for (uint256 i; i < length; ) {\\n            userOrderNonce[msg.sender][orderNonces[i]] = MAGIC_VALUE_ORDER_NONCE_EXECUTED;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit OrderNoncesCancelled(msg.sender, orderNonces);\\n    }\\n\\n    /**\\n     * @notice This function allows a user to cancel an array of subset nonces.\\n     * @param subsetNonces Array of subset nonces\\n     * @dev It does not check the status of the nonces to save gas.\\n     */\\n    function cancelSubsetNonces(uint256[] calldata subsetNonces) external {\\n        uint256 length = subsetNonces.length;\\n\\n        if (length == 0) {\\n            revert LengthsInvalid();\\n        }\\n\\n        for (uint256 i; i < length; ) {\\n            userSubsetNonce[msg.sender][subsetNonces[i]] = true;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit SubsetNoncesCancelled(msg.sender, subsetNonces);\\n    }\\n\\n    /**\\n     * @notice This function increments a user's bid/ask nonces.\\n     * @param bid Whether to increment the user bid nonce\\n     * @param ask Whether to increment the user ask nonce\\n     * @dev The logic for computing the quasi-random number is inspired by Seaport v1.2.\\n     *      The pseudo-randomness allows non-deterministic computation of the next ask/bid nonce.\\n     *      A deterministic increment would make the cancel-all process non-effective in certain cases\\n     *      (orders signed with a greater ask/bid nonce).\\n     *      The same quasi-random number is used for incrementing both the bid and ask nonces if both values\\n     *      are incremented in the same transaction.\\n     *      If this function is used twice in the same block, it will return the same quasiRandomNumber\\n     *      but this will not impact the overall business logic.\\n     */\\n    function incrementBidAskNonces(bool bid, bool ask) external {\\n        // Use second half of the previous block hash as a quasi-random number\\n        uint256 quasiRandomNumber = uint256(blockhash(block.number - 1) >> 128);\\n        uint256 newBidNonce = userBidAskNonces[msg.sender].bidNonce;\\n        uint256 newAskNonce = userBidAskNonces[msg.sender].askNonce;\\n\\n        if (bid) {\\n            newBidNonce += quasiRandomNumber;\\n            userBidAskNonces[msg.sender].bidNonce = newBidNonce;\\n        }\\n\\n        if (ask) {\\n            newAskNonce += quasiRandomNumber;\\n            userBidAskNonces[msg.sender].askNonce = newAskNonce;\\n        }\\n\\n        emit NewBidAskNonces(msg.sender, newBidNonce, newAskNonce);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StrategyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// LooksRare unopinionated libraries\\nimport {CurrencyManager} from \\\"./CurrencyManager.sol\\\";\\n\\n// Interfaces\\nimport {IStrategy} from \\\"./interfaces/IStrategy.sol\\\";\\nimport {IStrategyManager} from \\\"./interfaces/IStrategyManager.sol\\\";\\n\\n/**\\n * @title StrategyManager\\n * @notice This contract handles the addition and the update of execution strategies.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract StrategyManager is IStrategyManager, CurrencyManager {\\n    /**\\n     * @notice This variable keeps the count of how many strategies exist.\\n     *         It includes strategies that have been removed.\\n     */\\n    uint256 private _countStrategies = 1;\\n\\n    /**\\n     * @notice This returns the strategy information for a strategy id.\\n     */\\n    mapping(uint256 => Strategy) public strategyInfo;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     */\\n    constructor(address _owner) CurrencyManager(_owner) {\\n        strategyInfo[0] = Strategy({\\n            isActive: true,\\n            standardProtocolFeeBp: 50,\\n            minTotalFeeBp: 50,\\n            maxProtocolFeeBp: 200,\\n            selector: bytes4(0),\\n            isMakerBid: false,\\n            implementation: address(0)\\n        });\\n\\n        emit NewStrategy(0, 50, 50, 200, bytes4(0), false, address(0));\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to add a new execution strategy to the protocol.\\n     * @param standardProtocolFeeBp Standard protocol fee (in basis point)\\n     * @param minTotalFeeBp Minimum total fee (in basis point)\\n     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)\\n     * @param selector Function selector for the strategy\\n     * @param isMakerBid Whether the function selector is for maker bid\\n     * @param implementation Implementation address\\n     * @dev Strategies have an id that is incremental.\\n     *      Only callable by owner.\\n     */\\n    function addStrategy(\\n        uint16 standardProtocolFeeBp,\\n        uint16 minTotalFeeBp,\\n        uint16 maxProtocolFeeBp,\\n        bytes4 selector,\\n        bool isMakerBid,\\n        address implementation\\n    ) external onlyOwner {\\n        if (minTotalFeeBp > maxProtocolFeeBp || standardProtocolFeeBp > minTotalFeeBp || maxProtocolFeeBp > 500) {\\n            revert StrategyProtocolFeeTooHigh();\\n        }\\n\\n        if (selector == bytes4(0)) {\\n            revert StrategyHasNoSelector();\\n        }\\n\\n        if (!IStrategy(implementation).isLooksRareV2Strategy()) {\\n            revert NotV2Strategy();\\n        }\\n\\n        strategyInfo[_countStrategies] = Strategy({\\n            isActive: true,\\n            standardProtocolFeeBp: standardProtocolFeeBp,\\n            minTotalFeeBp: minTotalFeeBp,\\n            maxProtocolFeeBp: maxProtocolFeeBp,\\n            selector: selector,\\n            isMakerBid: isMakerBid,\\n            implementation: implementation\\n        });\\n\\n        emit NewStrategy(\\n            _countStrategies++,\\n            standardProtocolFeeBp,\\n            minTotalFeeBp,\\n            maxProtocolFeeBp,\\n            selector,\\n            isMakerBid,\\n            implementation\\n        );\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update parameters for an existing execution strategy.\\n     * @param strategyId Strategy id\\n     * @param isActive Whether the strategy must be active\\n     * @param newStandardProtocolFee New standard protocol fee (in basis point)\\n     * @param newMinTotalFee New minimum total fee (in basis point)\\n     * @dev Only callable by owner.\\n     */\\n    function updateStrategy(\\n        uint256 strategyId,\\n        bool isActive,\\n        uint16 newStandardProtocolFee,\\n        uint16 newMinTotalFee\\n    ) external onlyOwner {\\n        if (strategyId >= _countStrategies) {\\n            revert StrategyNotUsed();\\n        }\\n\\n        if (newMinTotalFee > strategyInfo[strategyId].maxProtocolFeeBp || newStandardProtocolFee > newMinTotalFee) {\\n            revert StrategyProtocolFeeTooHigh();\\n        }\\n\\n        strategyInfo[strategyId].isActive = isActive;\\n        strategyInfo[strategyId].standardProtocolFeeBp = newStandardProtocolFee;\\n        strategyInfo[strategyId].minTotalFeeBp = newMinTotalFee;\\n\\n        emit StrategyUpdated(strategyId, isActive, newStandardProtocolFee, newMinTotalFee);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/constants/AssemblyConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/*\\n * @dev error OrderInvalid()\\n *      Memory layout:\\n *        - 0x00: Left-padded selector (data begins at 0x1c)\\n *      Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant OrderInvalid_error_selector = 0x2e0c0f71;\\nuint256 constant OrderInvalid_error_length = 0x04;\\n\\n/*\\n *  @dev error CurrencyInvalid()\\n *       Memory layout:\\n *         - 0x00: Left-padded selector (data begins at 0x1c)\\n *       Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant CurrencyInvalid_error_selector = 0x4f795487;\\nuint256 constant CurrencyInvalid_error_length = 0x04;\\n\\n/*\\n * @dev error OutsideOfTimeRange()\\n *      Memory layout:\\n *        - 0x00: Left-padded selector (data begins at 0x1c)\\n *      Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant OutsideOfTimeRange_error_selector = 0x7476320f;\\nuint256 constant OutsideOfTimeRange_error_length = 0x04;\\n\\n/*\\n * @dev error NoSelectorForStrategy()\\n *      Memory layout:\\n *        - 0x00: Left-padded selector (data begins at 0x1c)\\n *      Revert buffer is memory[0x1c:0x20]\\n */\\nuint256 constant NoSelectorForStrategy_error_selector = 0xab984846;\\nuint256 constant NoSelectorForStrategy_error_length = 0x04;\\n\\nuint256 constant Error_selector_offset = 0x1c;\\n\\nuint256 constant OneWord = 0x20;\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/lowLevelCallers/LowLevelERC721Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC721} from \\\"../interfaces/generic/IERC721.sol\\\";\\n\\n// Errors\\nimport {ERC721TransferFromFail} from \\\"../errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"../errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC721Transfer\\n * @notice This contract contains low-level calls to transfer ERC721 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC721Transfer {\\n    /**\\n     * @notice Execute ERC721 transferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenId tokenId to transfer\\n     */\\n    function _executeERC721TransferFrom(address collection, address from, address to, uint256 tokenId) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(abi.encodeCall(IERC721.transferFrom, (from, to, tokenId)));\\n\\n        if (!status) {\\n            revert ERC721TransferFromFail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/LowLevelERC1155Transfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC1155} from \\\"@looksrare/contracts-libs/contracts/interfaces/generic/IERC1155.sol\\\";\\n\\n// Errors\\nimport {ERC1155SafeTransferFromFail, ERC1155SafeBatchTransferFromFail} from \\\"@looksrare/contracts-libs/contracts/errors/LowLevelErrors.sol\\\";\\nimport {NotAContract} from \\\"@looksrare/contracts-libs/contracts/errors/GenericErrors.sol\\\";\\n\\n/**\\n * @title LowLevelERC1155Transfer\\n * @notice This contract contains low-level calls to transfer ERC1155 tokens.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract LowLevelERC1155Transfer {\\n    /**\\n     * @notice Execute ERC1155 safeTransferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenId tokenId to transfer\\n     * @param amount Amount to transfer\\n     */\\n    function _executeERC1155SafeTransferFrom(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(abi.encodeCall(IERC1155.safeTransferFrom, (from, to, tokenId, amount, \\\"\\\")));\\n\\n        if (!status) {\\n            revert ERC1155SafeTransferFromFail();\\n        }\\n    }\\n\\n    /**\\n     * @notice Execute ERC1155 safeBatchTransferFrom\\n     * @param collection Address of the collection\\n     * @param from Address of the sender\\n     * @param to Address of the recipient\\n     * @param tokenIds Array of tokenIds to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    function _executeERC1155SafeBatchTransferFrom(\\n        address collection,\\n        address from,\\n        address to,\\n        uint256[] memory tokenIds,\\n        uint256[] memory amounts\\n    ) internal {\\n        if (collection.code.length == 0) {\\n            revert NotAContract();\\n        }\\n\\n        (bool status, ) = collection.call(\\n            abi.encodeCall(IERC1155.safeBatchTransferFrom, (from, to, tokenIds, amounts, \\\"\\\"))\\n        );\\n\\n        if (!status) {\\n            revert ERC1155SafeBatchTransferFromFail();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITransferManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Libraries\\nimport {OrderStructs} from \\\"../libraries/OrderStructs.sol\\\";\\n\\n// Enums\\nimport {CollectionType} from \\\"../enums/CollectionType.sol\\\";\\n\\n/**\\n * @title ITransferManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface ITransferManager {\\n    /**\\n     * @notice This struct is only used for transferBatchItemsAcrossCollections.\\n     * @param collection Collection address\\n     * @param collectionType 0 for ERC721, 1 for ERC1155\\n     * @param itemIds Array of item ids to transfer\\n     * @param amounts Array of amounts to transfer\\n     */\\n    struct BatchTransferItem {\\n        address collection;\\n        CollectionType collectionType;\\n        uint256[] itemIds;\\n        uint256[] amounts;\\n    }\\n\\n    /**\\n     * @notice It is returned if the transfer caller is invalid.\\n     *         For a transfer called to be valid, the operator must be in the global allowlist and\\n     *         approved by the 'from' user.\\n     */\\n    error TransferCallerInvalid();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INonceManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title INonceManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface INonceManager {\\n    /**\\n     * @notice This struct contains the global bid and ask nonces of a user.\\n     * @param bidNonce Bid nonce\\n     * @param askNonce Ask nonce\\n     */\\n    struct UserBidAskNonces {\\n        uint256 bidNonce;\\n        uint256 askNonce;\\n    }\\n\\n    /**\\n     * @notice It is emitted when there is an update of the global bid/ask nonces for a user.\\n     * @param user Address of the user\\n     * @param bidNonce New bid nonce\\n     * @param askNonce New ask nonce\\n     */\\n    event NewBidAskNonces(address user, uint256 bidNonce, uint256 askNonce);\\n\\n    /**\\n     * @notice It is emitted when order nonces are cancelled for a user.\\n     * @param user Address of the user\\n     * @param orderNonces Array of order nonces cancelled\\n     */\\n    event OrderNoncesCancelled(address user, uint256[] orderNonces);\\n\\n    /**\\n     * @notice It is emitted when subset nonces are cancelled for a user.\\n     * @param user Address of the user\\n     * @param subsetNonces Array of subset nonces cancelled\\n     */\\n    event SubsetNoncesCancelled(address user, uint256[] subsetNonces);\\n}\\n\"\r\n    },\r\n    \"contracts/CurrencyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Interfaces\\nimport {ICurrencyManager} from \\\"./interfaces/ICurrencyManager.sol\\\";\\n\\n// Dependencies\\nimport {AffiliateManager} from \\\"./AffiliateManager.sol\\\";\\n\\n/**\\n * @title CurrencyManager\\n * @notice This contract manages the list of valid fungible currencies.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract CurrencyManager is ICurrencyManager, AffiliateManager {\\n    /**\\n     * @notice It checks whether the currency is allowed for transacting.\\n     */\\n    mapping(address => bool) public isCurrencyAllowed;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     */\\n    constructor(address _owner) AffiliateManager(_owner) {}\\n\\n    /**\\n     * @notice This function allows the owner to update the status of a currency.\\n     * @param currency Currency address (address(0) for ETH)\\n     * @param isAllowed Whether the currency should be allowed for trading\\n     * @dev Only callable by owner.\\n     */\\n    function updateCurrencyStatus(address currency, bool isAllowed) external onlyOwner {\\n        isCurrencyAllowed[currency] = isAllowed;\\n        emit CurrencyStatusUpdated(currency, isAllowed);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStrategyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IStrategyManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IStrategyManager {\\n    /**\\n     * @notice This struct contains the parameter of an execution strategy.\\n     * @param strategyId Id of the new strategy\\n     * @param standardProtocolFeeBp Standard protocol fee (in basis point)\\n     * @param minTotalFeeBp Minimum total fee (in basis point)\\n     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)\\n     * @param selector Function selector for the transaction to be executed\\n     * @param isMakerBid Whether the strategyId is for maker bid\\n     * @param implementation Address of the implementation of the strategy\\n     */\\n    struct Strategy {\\n        bool isActive;\\n        uint16 standardProtocolFeeBp;\\n        uint16 minTotalFeeBp;\\n        uint16 maxProtocolFeeBp;\\n        bytes4 selector;\\n        bool isMakerBid;\\n        address implementation;\\n    }\\n\\n    /**\\n     * @notice It is emitted when a new strategy is added.\\n     * @param strategyId Id of the new strategy\\n     * @param standardProtocolFeeBp Standard protocol fee (in basis point)\\n     * @param minTotalFeeBp Minimum total fee (in basis point)\\n     * @param maxProtocolFeeBp Maximum protocol fee (in basis point)\\n     * @param selector Function selector for the transaction to be executed\\n     * @param isMakerBid Whether the strategyId is for maker bid\\n     * @param implementation Address of the implementation of the strategy\\n     */\\n    event NewStrategy(\\n        uint256 strategyId,\\n        uint16 standardProtocolFeeBp,\\n        uint16 minTotalFeeBp,\\n        uint16 maxProtocolFeeBp,\\n        bytes4 selector,\\n        bool isMakerBid,\\n        address implementation\\n    );\\n\\n    /**\\n     * @notice It is emitted when an existing strategy is updated.\\n     * @param strategyId Id of the strategy\\n     * @param isActive Whether the strategy is active (or not) after the update\\n     * @param standardProtocolFeeBp Standard protocol fee (in basis point)\\n     * @param minTotalFeeBp Minimum total fee (in basis point)\\n     */\\n    event StrategyUpdated(uint256 strategyId, bool isActive, uint16 standardProtocolFeeBp, uint16 minTotalFeeBp);\\n\\n    /**\\n     * @notice If the strategy has not set properly its implementation contract.\\n     * @dev It can only be returned for owner operations.\\n     */\\n    error NotV2Strategy();\\n\\n    /**\\n     * @notice It is returned if the strategy has no selector.\\n     * @dev It can only be returned for owner operations.\\n     */\\n    error StrategyHasNoSelector();\\n\\n    /**\\n     * @notice It is returned if the strategyId is invalid.\\n     */\\n    error StrategyNotUsed();\\n\\n    /**\\n     * @notice It is returned if the strategy's protocol fee is too high.\\n     * @dev It can only be returned for owner operations.\\n     */\\n    error StrategyProtocolFeeTooHigh();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurrencyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title ICurrencyManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface ICurrencyManager {\\n    /**\\n     * @notice It is emitted if the currency status in the allowlist is updated.\\n     * @param currency Currency address (address(0) = ETH)\\n     * @param isAllowed Whether the currency is allowed\\n     */\\n    event CurrencyStatusUpdated(address currency, bool isAllowed);\\n}\\n\"\r\n    },\r\n    \"contracts/AffiliateManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// LooksRare unopinionated libraries\\nimport {OwnableTwoSteps} from \\\"@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\\\";\\n\\n// Interfaces\\nimport {IAffiliateManager} from \\\"./interfaces/IAffiliateManager.sol\\\";\\n\\n// Constants\\nimport {ONE_HUNDRED_PERCENT_IN_BP} from \\\"./constants/NumericConstants.sol\\\";\\n\\n/**\\n * @title AffiliateManager\\n * @notice This contract handles the management of affiliates for the LooksRare protocol.\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ncontract AffiliateManager is IAffiliateManager, OwnableTwoSteps {\\n    /**\\n     * @notice Whether the affiliate program is active.\\n     */\\n    bool public isAffiliateProgramActive;\\n\\n    /**\\n     * @notice Address of the affiliate controller.\\n     */\\n    address public affiliateController;\\n\\n    /**\\n     * @notice It tracks the affiliate rate (in basis point) for a given affiliate address.\\n     *         The basis point represents how much of the protocol fee will be shared to the affiliate.\\n     */\\n    mapping(address => uint256) public affiliateRates;\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner Owner address\\n     */\\n    constructor(address _owner) OwnableTwoSteps(_owner) {}\\n\\n    /**\\n     * @notice This function allows the affiliate controller to update the affiliate rate (in basis point).\\n     * @param affiliate Affiliate address\\n     * @param bp Rate (in basis point) to collect (e.g. 100 = 1%) per referred transaction\\n     */\\n    function updateAffiliateRate(address affiliate, uint256 bp) external {\\n        if (msg.sender != affiliateController) {\\n            revert NotAffiliateController();\\n        }\\n\\n        if (bp > ONE_HUNDRED_PERCENT_IN_BP) {\\n            revert PercentageTooHigh();\\n        }\\n\\n        affiliateRates[affiliate] = bp;\\n        emit NewAffiliateRate(affiliate, bp);\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the affiliate controller address.\\n     * @param newAffiliateController New affiliate controller address\\n     * @dev Only callable by owner.\\n     */\\n    function updateAffiliateController(address newAffiliateController) external onlyOwner {\\n        affiliateController = newAffiliateController;\\n        emit NewAffiliateController(newAffiliateController);\\n    }\\n\\n    /**\\n     * @notice This function allows the owner to update the affiliate program status.\\n     * @param isActive Whether the affiliate program is active\\n     * @dev Only callable by owner.\\n     */\\n    function updateAffiliateProgramStatus(bool isActive) external onlyOwner {\\n        isAffiliateProgramActive = isActive;\\n        emit NewAffiliateProgramStatus(isActive);\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/OwnableTwoSteps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IOwnableTwoSteps} from \\\"./interfaces/IOwnableTwoSteps.sol\\\";\\n\\n/**\\n * @title OwnableTwoSteps\\n * @notice This contract offers transfer of ownership in two steps with potential owner\\n *         having to confirm the transaction to become the owner.\\n *         Renouncement of the ownership is also a two-step process since the next potential owner is the address(0).\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\nabstract contract OwnableTwoSteps is IOwnableTwoSteps {\\n    /**\\n     * @notice Address of the current owner.\\n     */\\n    address public owner;\\n\\n    /**\\n     * @notice Address of the potential owner.\\n     */\\n    address public potentialOwner;\\n\\n    /**\\n     * @notice Ownership status.\\n     */\\n    Status public ownershipStatus;\\n\\n    /**\\n     * @notice Modifier to wrap functions for contracts that inherit this contract.\\n     */\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Constructor\\n     * @param _owner The contract's owner\\n     */\\n    constructor(address _owner) {\\n        owner = _owner;\\n        emit NewOwner(_owner);\\n    }\\n\\n    /**\\n     * @notice This function is used to cancel the ownership transfer.\\n     * @dev This function can be used for both cancelling a transfer to a new owner and\\n     *      cancelling the renouncement of the ownership.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        Status _ownershipStatus = ownershipStatus;\\n        if (_ownershipStatus == Status.NoOngoingTransfer) {\\n            revert NoOngoingTransferInProgress();\\n        }\\n\\n        if (_ownershipStatus == Status.TransferInProgress) {\\n            delete potentialOwner;\\n        }\\n\\n        delete ownershipStatus;\\n\\n        emit CancelOwnershipTransfer();\\n    }\\n\\n    /**\\n     * @notice This function is used to confirm the ownership renouncement.\\n     */\\n    function confirmOwnershipRenouncement() external onlyOwner {\\n        if (ownershipStatus != Status.RenouncementInProgress) {\\n            revert RenouncementNotInProgress();\\n        }\\n\\n        delete owner;\\n        delete ownershipStatus;\\n\\n        emit NewOwner(address(0));\\n    }\\n\\n    /**\\n     * @notice This function is used to confirm the ownership transfer.\\n     * @dev This function can only be called by the current potential owner.\\n     */\\n    function confirmOwnershipTransfer() external {\\n        if (ownershipStatus != Status.TransferInProgress) {\\n            revert TransferNotInProgress();\\n        }\\n\\n        if (msg.sender != potentialOwner) {\\n            revert WrongPotentialOwner();\\n        }\\n\\n        owner = msg.sender;\\n        delete ownershipStatus;\\n        delete potentialOwner;\\n\\n        emit NewOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @notice This function is used to initiate the transfer of ownership to a new owner.\\n     * @param newPotentialOwner New potential owner address\\n     */\\n    function initiateOwnershipTransfer(address newPotentialOwner) external onlyOwner {\\n        if (ownershipStatus != Status.NoOngoingTransfer) {\\n            revert TransferAlreadyInProgress();\\n        }\\n\\n        ownershipStatus = Status.TransferInProgress;\\n        potentialOwner = newPotentialOwner;\\n\\n        /**\\n         * @dev This function can only be called by the owner, so msg.sender is the owner.\\n         *      We don't have to SLOAD the owner again.\\n         */\\n        emit InitiateOwnershipTransfer(msg.sender, newPotentialOwner);\\n    }\\n\\n    /**\\n     * @notice This function is used to initiate the ownership renouncement.\\n     */\\n    function initiateOwnershipRenouncement() external onlyOwner {\\n        if (ownershipStatus != Status.NoOngoingTransfer) {\\n            revert TransferAlreadyInProgress();\\n        }\\n\\n        ownershipStatus = Status.RenouncementInProgress;\\n\\n        emit InitiateOwnershipRenouncement();\\n    }\\n\\n    function _onlyOwner() private view {\\n        if (msg.sender != owner) revert NotOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAffiliateManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IAffiliateManager\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IAffiliateManager {\\n    /**\\n     * @notice It is emitted when there is an update of affliate controller.\\n     * @param affiliateController Address of the new affiliate controller\\n     */\\n    event NewAffiliateController(address affiliateController);\\n\\n    /**\\n     * @notice It is emitted if the affiliate program is activated or deactivated.\\n     * @param isActive Whether the affiliate program is active after the update\\n     */\\n    event NewAffiliateProgramStatus(bool isActive);\\n\\n    /**\\n     * @notice It is emitted if there is a new affiliate and its associated rate (in basis point).\\n     * @param affiliate Address of the affiliate\\n     * @param rate Affiliate rate (in basis point)\\n     */\\n    event NewAffiliateRate(address affiliate, uint256 rate);\\n\\n    /**\\n     * @notice It is returned if the function is called by another address than the affiliate controller.\\n     */\\n    error NotAffiliateController();\\n\\n    /**\\n     * @notice It is returned if the affiliate controller is trying to set an affiliate rate higher than 10,000.\\n     */\\n    error PercentageTooHigh();\\n}\\n\"\r\n    },\r\n    \"node_modules/@looksrare/contracts-libs/contracts/interfaces/IOwnableTwoSteps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/**\\n * @title IOwnableTwoSteps\\n * @author LooksRare protocol team (\ud83d\udc40,\ud83d\udc8e)\\n */\\ninterface IOwnableTwoSteps {\\n    /**\\n     * @notice This enum keeps track of the ownership status.\\n     * @param NoOngoingTransfer The default status when the owner is set\\n     * @param TransferInProgress The status when a transfer to a new owner is initialized\\n     * @param RenouncementInProgress The status when a transfer to address(0) is initialized\\n     */\\n    enum Status {\\n        NoOngoingTransfer,\\n        TransferInProgress,\\n        RenouncementInProgress\\n    }\\n\\n    /**\\n     * @notice This is returned when there is no transfer of ownership in progress.\\n     */\\n    error NoOngoingTransferInProgress();\\n\\n    /**\\n     * @notice This is returned when the caller is not the owner.\\n     */\\n    error NotOwner();\\n\\n    /**\\n     * @notice This is returned when there is no renouncement in progress but\\n     *         the owner tries to validate the ownership renouncement.\\n     */\\n    error RenouncementNotInProgress();\\n\\n    /**\\n     * @notice This is returned when the transfer is already in progress but the owner tries\\n     *         initiate a new ownership transfer.\\n     */\\n    error TransferAlreadyInProgress();\\n\\n    /**\\n     * @notice This is returned when there is no ownership transfer in progress but the\\n     *         ownership change tries to be approved.\\n     */\\n    error TransferNotInProgress();\\n\\n    /**\\n     * @notice This is returned when the ownership transfer is attempted to be validated by the\\n     *         a caller that is not the potential owner.\\n     */\\n    error WrongPotentialOwner();\\n\\n    /**\\n     * @notice This is emitted if the ownership transfer is cancelled.\\n     */\\n    event CancelOwnershipTransfer();\\n\\n    /**\\n     * @notice This is emitted if the ownership renouncement is initiated.\\n     */\\n    event InitiateOwnershipRenouncement();\\n\\n    /**\\n     * @notice This is emitted if the ownership transfer is initiated.\\n     * @param previousOwner Previous/current owner\\n     * @param potentialOwner Potential/future owner\\n     */\\n    event InitiateOwnershipTransfer(address previousOwner, address potentialOwner);\\n\\n    /**\\n     * @notice This is emitted when there is a new owner.\\n     */\\n    event NewOwner(address newOwner);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@looksrare/=node_modules/@looksrare/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"solmate/=node_modules/solmate/\",\r\n      \"@chainlink/=node_modules/@chainlink/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 18000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeProtocol\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CRITERIA_GROUPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC1155_INTERFACE_ID\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC721_INTERFACE_ID_1\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC721_INTERFACE_ID_2\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAGIC_VALUE_ORDER_NONCE_EXECUTED\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum QuoteType\",\"name\":\"quoteType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"globalNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subsetNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"enum CollectionType\",\"name\":\"collectionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"additionalParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct OrderStructs.Maker\",\"name\":\"makerOrder\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"},{\"internalType\":\"enum OrderStructs.MerkleTreeNodePosition\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct OrderStructs.MerkleTreeNode[]\",\"name\":\"proof\",\"type\":\"tuple[]\"}],\"internalType\":\"struct OrderStructs.MerkleTree\",\"name\":\"merkleTree\",\"type\":\"tuple\"}],\"name\":\"checkMakerOrderValidity\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"validationCodes\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum QuoteType\",\"name\":\"quoteType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"globalNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subsetNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"enum CollectionType\",\"name\":\"collectionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"additionalParameters\",\"type\":\"bytes\"}],\"internalType\":\"struct OrderStructs.Maker[]\",\"name\":\"makerOrders\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"},{\"internalType\":\"enum OrderStructs.MerkleTreeNodePosition\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct OrderStructs.MerkleTreeNode[]\",\"name\":\"proof\",\"type\":\"tuple[]\"}],\"internalType\":\"struct OrderStructs.MerkleTree[]\",\"name\":\"merkleTrees\",\"type\":\"tuple[]\"}],\"name\":\"checkMultipleMakerOrderValidities\",\"outputs\":[{\"internalType\":\"uint256[9][]\",\"name\":\"validationCodes\",\"type\":\"uint256[9][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creatorFeeManager\",\"outputs\":[{\"internalType\":\"contract ICreatorFeeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deriveProtocolParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeProtocol\",\"outputs\":[{\"internalType\":\"contract ExchangeProtocol\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCreatorFeeBp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OrderValidatorV2A", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "18000", "ConstructorArguments": "0000000000000000000000006039a6483a702a05e5afd48cc8c63299006c1798", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}