{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DeFi/Spot/ERC20Spot.sol\": {\r\n      \"content\": \"pragma solidity 0.8.17;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../RDN/RDNOwnable.sol\\\";\\n\\n\\ncontract ERC20Spot is IERC20, RDNOwnable {\\n\\n    mapping(uint => uint) private _balances;\\n    mapping(address => mapping(address => uint)) private _allowances;\\n    uint private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n\\n    function initERC20Spot(address _registry, uint _ownerId) internal {\\n        _symbol = 'SPOT0';\\n        _name = \\\"SPOTv0 Share Token\\\";\\n\\n        initRDNOwnable(_registry, _ownerId);\\n\\n    }\\n\\n\\n    function balanceOf(address _account) public view returns (uint) {\\n        uint userId = IRDNRegistry(registry).getUserIdByAddress(_account);\\n        return _balances[userId];\\n    }\\n\\n    function allowance(address owner, address spender) public view returns (uint) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function transfer(address to, uint amount) external returns (bool) {\\n        return false;\\n    }\\n\\n    function approve(address spender, uint amount) external returns (bool) {\\n        return false;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint amount\\n    ) external returns (bool) {\\n        return false;\\n    }\\n\\n    function _mint(uint userId, uint amount) internal {\\n        address account = IRDNRegistry(registry).getUserAddress(userId);\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[userId] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(uint userId, uint amount) internal {\\n        address account = IRDNRegistry(registry).getUserAddress(userId);\\n        require(account != address(0), \\\"ERC20: burn from zero address\\\");\\n\\n        uint accountBalance = _balances[userId];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[userId] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/DeFi/Spot/IMasterChef2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.6;\\n\\ninterface IMasterChef2 {\\n  struct UserInfo {\\n    uint256 amount;\\n    uint256 rewardDebt;\\n    uint256 boostMultiplier;\\n  }\\n\\n  struct PoolInfo {\\n    uint256 accCakePerShare;\\n    uint256 lastRewardBlock;\\n    uint256 allocPoint;\\n    uint256 totalBoostedShare;\\n    bool isRegular;\\n  }\\n\\n  function totalRegularAllocPoint() external view returns (uint256);\\n\\n  function totalSpecialAllocPoint() external view returns (uint256);\\n\\n  function cakePerBlock(bool _isRegular) external view returns (uint256 amount);\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function CAKE() external view returns (address);\\n\\n  function poolLength() external view returns (uint256);\\n\\n  function poolInfo(uint256 pool) external view returns (PoolInfo memory);\\n\\n  function lpToken(uint256 pool) external view returns (address);\\n\\n  function userInfo(uint256 pool, address user) external view returns (UserInfo memory);\\n\\n  function pendingCake(uint256 pool, address user) external view returns (uint256);\\n\\n  function deposit(uint256 pool, uint256 amount) external;\\n\\n  function withdraw(uint256 pool, uint256 amount) external;\\n\\n  function emergencyWithdraw(uint256 pool) external;\\n}\"\r\n    },\r\n    \"contracts/DeFi/Spot/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n// solhint-disable func-name-mixedcase\\ninterface IUniswapV2Pair is IERC20 {\\n  function nonces(address owner) external view returns (uint256);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint256);\\n\\n  function price1CumulativeLast() external view returns (uint256);\\n\\n  function kLast() external view returns (uint256);\\n\\n  function mint(address to) external returns (uint256 liquidity);\\n\\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n  function swap(\\n    uint256 amount0Out,\\n    uint256 amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n}\"\r\n    },\r\n    \"contracts/DeFi/Spot/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface IUniswapV2Router {\\n  function factory() external view returns (address);\\n\\n  function WETH() external view returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 amountADesired,\\n    uint256 amountBDesired,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    returns (\\n      uint256 amountA,\\n      uint256 amountB,\\n      uint256 liquidity\\n    );\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint256 amountTokenDesired,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    returns (\\n      uint256 amountToken,\\n      uint256 amountETH,\\n      uint256 liquidity\\n    );\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 liquidity,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountA, uint256 amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint256 liquidity,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountA, uint256 amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint256 amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable returns (uint256[] memory amounts);\\n\\n  function quote(\\n    uint256 amountA,\\n    uint256 reserveA,\\n    uint256 reserveB\\n  ) external pure returns (uint256 amountB);\\n\\n  function getAmountOut(\\n    uint256 amountIn,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) external pure returns (uint256 amountOut);\\n\\n  function getAmountIn(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) external pure returns (uint256 amountIn);\\n\\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external;\\n}\"\r\n    },\r\n    \"contracts/DeFi/Spot/IWrap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWrap is IERC20 {\\n  event Deposit(address indexed dst, uint256 wad);\\n  event Withdrawal(address indexed src, uint256 wad);\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n}\"\r\n    },\r\n    \"contracts/DeFi/Spot/SpotV1.sol\": {\r\n      \"content\": \"pragma solidity 0.8.17;\\n// SPDX-License-Identifier: MIT\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./IMasterChef2.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./IUniswapV2Router.sol\\\";\\nimport \\\"./ERC20Spot.sol\\\";\\nimport \\\"./IWrap.sol\\\";\\n\\ncontract SpotV1 is ERC20Spot {\\n    using SafeERC20 for IERC20;\\n\\n    struct Swap {\\n        address[] path;\\n        uint outMin;\\n    }\\n\\n    event SpotLog(\\n        uint8 indexed operationType, // 0 - deposit, 1 - withdrawal, 2 - restake\\n        address indexed token, // deposit or withdrawal token\\n        uint tokenAmount,\\n        uint lpAmount, // amount of LP deposited or withdrawn\\n        uint lpToken0Amount,\\n        uint lpToken1Amount\\n    );\\n\\n    address public pool;\\n    address public router;\\n    address public stakingToken;\\n    address public rewardToken;\\n    uint public poolIndex;\\n    uint public totalEarned;\\n\\n    address public factory;\\n\\n    address public wrapper;\\n\\n    constructor() {\\n\\n    }\\n\\n    function init(\\n        address _wrapper,\\n        address _pool,\\n        address _router,\\n        address _stakingToken,\\n        address _rewardToken,\\n        uint _poolIndex,\\n        uint _ownerId,\\n        address _registry,\\n        address _factory\\n    ) external {\\n        require(wrapper == address(0), \\\"Already initialized\\\");\\n\\n        wrapper = _wrapper;\\n        pool = _pool;\\n        router = _router;\\n        stakingToken = _stakingToken;\\n        rewardToken = _rewardToken;\\n        poolIndex = _poolIndex;\\n\\n        initERC20Spot(_registry, _ownerId);\\n\\n        factory = _factory;\\n    }\\n\\n    function deposit(\\n        uint amount,\\n        Swap memory swap0,\\n        Swap memory swap1,\\n        Swap memory swapReward0,\\n        Swap memory swapReward1,\\n        uint deadline\\n    ) public payable {\\n        require(isActiveRDNOwner(msg.sender) || msg.sender == factory, \\\"Access denied\\\");\\n        address _stakingToken = stakingToken; // gas savings\\n        address _pool = pool; // gas savings\\n        uint _poolIndex = poolIndex; //gas savings\\n\\n        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {\\n            _restake(deadline, swapReward0, swapReward1);\\n        }\\n\\n        // prepare to mint\\n        uint beforeDepositSupply = totalSupply();\\n        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));\\n        uint beforeDepositBalance = userInfo.amount;\\n\\n        // buy liquidity and stake\\n        if (msg.value > 0) {\\n            require(swap0.path[0] == wrapper, \\\"wrong path\\\");\\n            amount = msg.value;\\n            IWrap(wrapper).deposit{value: amount}();\\n        } else {\\n            IERC20(swap0.path[0]).safeTransferFrom(msg.sender, address(this), amount);\\n            amount = IERC20(swap0.path[0]).balanceOf(address(this));\\n        }\\n        \\n        _buyLiquidity(amount, swap0, swap1, deadline);\\n        uint stakingTokenAmount = IERC20(_stakingToken).balanceOf(address(this));\\n        _log(0, swap0.path[0], amount, stakingTokenAmount);\\n        _stake(stakingTokenAmount);\\n\\n        // mint\\n        userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));\\n        uint afterDepositBalance = userInfo.amount;\\n        uint amountToMint;\\n        if (beforeDepositBalance == 0) {\\n            amountToMint = afterDepositBalance;\\n        } else {\\n            amountToMint = ((afterDepositBalance - beforeDepositBalance) * beforeDepositSupply) / beforeDepositBalance;\\n        }\\n\\n        _mint(ownerId, amountToMint);\\n\\n        // _returnRemainder(swap0.path[0]);\\n    }\\n\\n    function withdraw(\\n        uint amountToBurn,\\n        Swap memory swap0,\\n        Swap memory swap1,\\n        Swap memory swapReward0,\\n        Swap memory swapReward1,\\n        uint deadline\\n    ) public onlyActiveRDNOwner(msg.sender) {\\n        address _pool = pool; // gas savings\\n        uint _poolIndex = poolIndex; //gas savings\\n        address tokenToWithdraw = swap0.path[swap0.path.length - 1];\\n\\n        if (IMasterChef2(pool).pendingCake(poolIndex, address(this)) > 0) {\\n            _restake(deadline, swapReward0, swapReward1);\\n        }\\n\\n        // prepare to burn\\n        uint beforeWithdrawSupply = totalSupply();\\n        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));\\n        uint beforeWithdrawBalance = userInfo.amount;\\n\\n        // sell liquidity\\n        uint amountToWithdraw = ((amountToBurn * beforeWithdrawBalance)) / beforeWithdrawSupply;\\n        _unStake(amountToWithdraw);\\n\\n        _sellLiquidity(amountToWithdraw, swap0, swap1, deadline);\\n\\n        \\n\\n        // withdraw tokens tokenToWithdraw\\n        if (tokenToWithdraw == wrapper) {\\n            IWrap(wrapper).withdraw(IWrap(wrapper).balanceOf(address(this)));\\n            _log(1, tokenToWithdraw, address(this).balance, amountToWithdraw);\\n            (bool sentRecipient, ) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n            require(sentRecipient, \\\"transfer BNB to recipeint failed\\\");\\n        } else {\\n            uint withdrawTokenAmount = IERC20(tokenToWithdraw).balanceOf(address(this));\\n            _log(1, tokenToWithdraw, withdrawTokenAmount, amountToWithdraw);\\n            IERC20(tokenToWithdraw).safeTransfer(msg.sender, withdrawTokenAmount);\\n        }\\n\\n        //burn\\n        _burn(ownerId, amountToBurn);\\n\\n        // _returnRemainder(swap0.path[swap0.path.length - 1]);\\n    }\\n\\n    function callAny(address payable _addr, bytes memory _data) public payable onlyRDNOwner(msg.sender) returns(bool success, bytes memory data){\\n        (success, data) = _addr.call{value: msg.value}(_data);\\n    }\\n    \\n    function restake(\\n        Swap memory swapReward0,\\n        Swap memory swapReward1,\\n        uint deadline\\n    ) public onlyActiveRDNOwner(msg.sender) {\\n        _restake(deadline, swapReward0, swapReward1);\\n        // _returnRemainder(swapReward0.path[0]);\\n    }\\n\\n    function info() public view returns (uint, address, uint, uint, uint) {\\n        address _pool = pool; // gas savings\\n        uint _poolIndex = poolIndex; //gas savings\\n\\n        uint reward = IMasterChef2(_pool).pendingCake(_poolIndex, address(this));\\n        IMasterChef2.UserInfo memory userInfo = IMasterChef2(_pool).userInfo(_poolIndex, address(this));\\n        uint staking = userInfo.amount;\\n\\n        return (poolIndex, stakingToken, reward, staking, totalEarned+reward);\\n    }\\n\\n    function _log(uint8 operationType, address token, uint tokenAmount, uint lpAmount) internal {\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(stakingToken).getReserves();\\n        uint totalLpSupply = IERC20(stakingToken).totalSupply();\\n        uint lpToken0Amount = (lpAmount * reserve0)/totalLpSupply;\\n        uint lpToken1Amount = (lpAmount * reserve1)/totalLpSupply;\\n        emit SpotLog(operationType, token, tokenAmount, lpAmount, lpToken0Amount, lpToken1Amount);\\n    }\\n\\n    function _restake(\\n        uint deadline,\\n        Swap memory swap0,\\n        Swap memory swap1\\n    ) internal returns(address token0, address token1) {\\n        IMasterChef2 _pool = IMasterChef2(pool); // gas savings\\n        IERC20 _rewardToken = IERC20(rewardToken); // gas savings\\n\\n        require(_pool.pendingCake(poolIndex, address(this)) > 0, \\\"nothing to claim\\\");\\n\\n        totalEarned += _pool.pendingCake(poolIndex, address(this));\\n        _pool.deposit(poolIndex, 0); // get all reward\\n        uint amount = _rewardToken.balanceOf(address(this));\\n        (token0, token1) = _buyLiquidity(amount, swap0, swap1, deadline);\\n        uint stakingTokenAmount = IERC20(stakingToken).balanceOf(address(this));\\n        _log(2, rewardToken, amount, stakingTokenAmount);\\n        _stake(stakingTokenAmount);\\n    }\\n\\n    function _buyLiquidity(\\n        uint amount,\\n        Swap memory swap0,\\n        Swap memory swap1,\\n        uint deadline\\n    ) internal returns(address token0, address token1) {\\n        require(swap0.path[0] == swap1.path[0], \\\"start tokens should be equal\\\");\\n        \\n        IUniswapV2Pair to = IUniswapV2Pair(stakingToken);\\n\\n        // prepare tokens\\n        token0 = to.token0();\\n        token1 = to.token1();\\n        require(swap0.path[swap0.path.length - 1] == token0, \\\"token0 is invalid\\\");\\n        require(swap1.path[swap1.path.length - 1] == token1, \\\"token1 is invalid\\\");\\n\\n        // swap input tokens\\n        _approve(IERC20(swap0.path[0]), address(router), amount);\\n        uint amount0In = amount / 2;\\n        _swap(amount0In, swap0.outMin, swap0.path, deadline);\\n        uint amount1In = amount - amount0In;\\n        _swap(amount1In, swap1.outMin, swap1.path, deadline);\\n\\n        _addLiquidity(token0, token1, deadline);\\n\\n    }\\n\\n    function _sellLiquidity(\\n        uint amount,\\n        Swap memory swap0,\\n        Swap memory swap1,\\n        uint deadline\\n    ) internal returns(address token0, address token1) {\\n        require(swap0.path[swap0.path.length-1] == swap1.path[swap1.path.length-1], \\\"end tokens should be equal\\\");\\n        \\n        IUniswapV2Pair from = IUniswapV2Pair(stakingToken);\\n\\n        // prepare tokens / remove liquidity\\n        token0 = from.token0();\\n        token1 = from.token1();\\n        _removeLiquidity(amount, token0, token1, deadline);\\n        require(swap0.path[0] == token0, \\\"token0 is invalid\\\");\\n        require(swap1.path[0] == token1, \\\"token1 is invalid\\\");\\n        uint amount0 = IERC20(token0).balanceOf(address(this));\\n        uint amount1 = IERC20(token1).balanceOf(address(this));\\n\\n        // swap from tokens\\n        _approve(IERC20(token0), address(router), amount0);\\n        _approve(IERC20(token1), address(router), amount1);\\n        _swap(amount0, swap0.outMin, swap0.path, deadline);\\n        _swap(amount1, swap1.outMin, swap1.path, deadline);\\n\\n\\n    }\\n\\n    function _addLiquidity(\\n        address token0,\\n        address token1,\\n        uint deadline\\n    ) internal {\\n        address _router = router; // gas savings\\n        uint amountIn0 = IERC20(token0).balanceOf(address(this));\\n        uint amountIn1 = IERC20(token1).balanceOf(address(this));\\n        _approve(IERC20(token0), _router, amountIn0);\\n        _approve(IERC20(token1), _router, amountIn1);\\n        IUniswapV2Router(_router).addLiquidity(\\n            token0,\\n            token1,\\n            amountIn0,\\n            amountIn1,\\n            0,\\n            0,\\n            address(this),\\n            deadline\\n        );\\n    }\\n\\n    function _removeLiquidity(\\n        uint amount,\\n        address token0,\\n        address token1,\\n        uint deadline\\n    ) internal {\\n        address _router = router; // gas savings\\n        address _stakingToken = stakingToken; // gas savings\\n\\n        require(amount <= IERC20(_stakingToken).balanceOf(address(this)), \\\"not enough liquidity to remove\\\");\\n\\n        _approve(IERC20(_stakingToken), _router, amount);\\n        IUniswapV2Router(_router).removeLiquidity(\\n            token0,\\n            token1,\\n            amount,\\n            0,\\n            0,\\n            address(this),\\n            deadline\\n        );\\n    }\\n\\n    function _approve(\\n        IERC20 token,\\n        address spender,\\n        uint amount\\n    ) internal {\\n        if (token.allowance(address(this), spender) != 0) {\\n            token.safeApprove(spender, 0);\\n        }\\n        token.safeApprove(spender, amount);\\n    }\\n\\n    function _swap(\\n        uint amount,\\n        uint outMin,\\n        address[] memory path,\\n        uint deadline\\n    ) internal {\\n        if (path[0] == path[path.length - 1]) return;\\n\\n        IUniswapV2Router(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        // IUniswapV2Router(router).swapExactTokensForTokens(\\n            amount,\\n            outMin,\\n            path,\\n            address(this),\\n            deadline\\n        );\\n    }\\n\\n    function _stake(uint amount) internal {\\n        _approve(IERC20(stakingToken), pool, amount);\\n        IMasterChef2(pool).deposit(poolIndex, amount);\\n    }\\n\\n    function _unStake(uint amount) internal {\\n        IMasterChef2(pool).withdraw(poolIndex, amount);\\n    }\\n\\n    function _returnRemainder(address token3) internal {\\n        address[3] memory tokens = [IUniswapV2Pair(stakingToken).token0(), IUniswapV2Pair(stakingToken).token1(), token3];\\n        address target = IRDNRegistry(registry).getUserAddress(ownerId);\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            if (tokens[i] == address(0)) continue;\\n            uint256 tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n            if (tokenBalance > 0) {\\n                if (tokens[i] == wrapper) {\\n                    IWrap(wrapper).withdraw(tokenBalance);\\n                    (bool sentRecipient, ) = payable(target).call{value: address(this).balance}(\\\"\\\");\\n                    require(sentRecipient, \\\"transfer ETH to recipeint failed\\\");\\n                } else {\\n                    IERC20(tokens[i]).safeTransfer(target, tokenBalance);\\n                }\\n            }\\n        }\\n  }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/RDN/interfaces/IRDNRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IRDNRegistry {\\n    \\n    struct User {\\n        uint level;\\n        address userAddress;\\n        uint parentId;\\n        uint tariff;\\n        uint activeUntill;\\n        uint created;\\n    }\\n\\n    function register(uint _parentId) external;\\n\\n    function getUser(uint) external view returns(User memory);\\n\\n    function getUserIdByAddress(address _userAddress) external view returns(uint);\\n\\n    function usersCount() external view returns(uint);\\n    \\n    function getUsersCount() external view returns(uint);\\n    \\n    function getChildren(uint _userId) external view returns(uint[] memory);\\n\\n    function isRegistered(uint _userId) external view returns(bool);\\n    \\n    function isValidUser(uint _userId) external view returns(bool);\\n    \\n    function isRegisteredByAddress(address _userAddress) external view returns(bool);\\n\\n    function isActive(uint _userId) external view returns(bool);\\n\\n    function factorsAddress() external view returns(address);\\n\\n    function getParentId(uint _userId) external view returns(uint);\\n\\n    function getLevel(uint _userId) external view returns(uint);\\n\\n    function getTariff(uint _userId) external view returns(uint);\\n\\n    function getActiveUntill(uint _userId) external view returns(uint);\\n\\n    function getUserAddress(uint _userId) external view returns(address);\\n\\n    function getDistributor(address _token) external view returns(address);\\n\\n    function setTariff(uint _userId, uint _tariff) external;\\n    \\n    function setActiveUntill(uint _userId, uint _activeUntill) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/RDN/RDNOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {IRDNRegistry} from \\\"./interfaces/IRDNRegistry.sol\\\";\\n\\ncontract RDNOwnable {\\n    address public registry;\\n    uint public ownerId;\\n\\n    function initRDNOwnable(address _registry, uint _ownerId) internal {\\n        registry = _registry;\\n        require(IRDNRegistry(registry).isValidUser(_ownerId));\\n        ownerId = _ownerId;\\n    }\\n\\n    modifier onlyRDNOwner(address _userAddress) {\\n        require(isRDNOwner(_userAddress), \\\"RDNOwnable: access denied\\\");\\n        _;\\n    }\\n\\n    modifier onlyActiveRDNOwner(address _userAddress) {\\n        require(isActiveRDNOwner(_userAddress), \\\"RDNOwnable: access denied\\\");\\n        _;\\n    }\\n\\n    function isRDNOwner(address _userAddress) public view returns(bool) {\\n        return(IRDNRegistry(registry).getUserIdByAddress(_userAddress) == ownerId);\\n    }\\n\\n    function isActiveRDNOwner(address _userAddress) public view returns(bool) {\\n        IRDNRegistry registryInterface = IRDNRegistry(registry);\\n        return(registryInterface.isActive(registryInterface.getUserIdByAddress(_userAddress)));\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"operationType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpToken1Amount\",\"type\":\"uint256\"}],\"name\":\"SpotLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"callAny\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swap0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swap1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swapReward0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swapReward1\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_poolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ownerId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"isActiveRDNOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"isRDNOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swapReward0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swapReward1\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swap0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swap1\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swapReward0\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"outMin\",\"type\":\"uint256\"}],\"internalType\":\"struct SpotV1.Swap\",\"name\":\"swapReward1\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SpotV1", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}