{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier onlyOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/** \r\n    Tax Free MDB Purchases\r\n    Locks Up Funds For 60 Days\r\n    Minimum Amount To Purchase\r\n */\r\ncontract MDBBonds is Ownable {\r\n\r\n    // MDB Token\r\n    address public constant MDB = 0x0557a288A93ed0DF218785F2787dac1cd077F8f3;\r\n\r\n    // PCS Router\r\n    IUniswapV2Router02 public constant router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    // day\r\n    uint256 private constant day = 28800;\r\n\r\n    // Lock Time In Blocks\r\n    uint256 public lockTime = day * 60;\r\n\r\n    // Minimum Value To Buy Bond\r\n    uint256 public minimumValue = 20 * 10**18; // 20 BNB\r\n\r\n    // Bond Structure\r\n    struct Bond {\r\n        address recipient;\r\n        uint256 numTokens;\r\n        uint256 unlockBlock;\r\n        uint256 indexInUserArray;\r\n    }\r\n    // User -> ID[]\r\n    mapping ( address => uint256[] ) public userIDs;\r\n    // ID -> Bond\r\n    mapping ( uint256 => Bond ) public bonds;\r\n\r\n    // Global ID Nonce\r\n    uint256 public nonce;\r\n\r\n    // Number of active bonds\r\n    uint256 public numberOfActiveBonds;\r\n\r\n    // Swap Path\r\n    address[] private path;\r\n\r\n    // Last Bond Purchase\r\n    uint256 public lastBondPurchased;\r\n\r\n    // Events\r\n    event BondCreated(address indexed user, uint amount, uint unlockBlock, uint bondID);\r\n\r\n    constructor(){\r\n        path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = MDB;\r\n        lastBondPurchased = block.number;\r\n    }\r\n\r\n    function setLockTime(uint newLockTime) external onlyOwner {\r\n        require(\r\n            newLockTime < day * 366,\r\n            'Lock Time Too Long'\r\n        );\r\n        \r\n        lockTime = newLockTime;\r\n    }\r\n\r\n    function setMinimumValue(uint newMinimum) external onlyOwner {\r\n        require(\r\n            newMinimum > 0,\r\n            'Minimum too small'\r\n        );\r\n\r\n        minimumValue = newMinimum;\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        (bool s,) = payable(msg.sender).call{value: address(this).balance}(\"\");\r\n        require(s);\r\n    }\r\n\r\n    function withdraw(address token) external onlyOwner {\r\n        require(token != MDB, 'Cannot Withdraw MDB');\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    receive() external payable {\r\n        _purchaseBond(msg.sender, msg.value, 0);\r\n    }\r\n\r\n    function purchaseBond() external payable {\r\n        _purchaseBond(msg.sender, msg.value, 0);\r\n    }\r\n\r\n    function purchaseBond(uint minOut) external payable {\r\n        _purchaseBond(msg.sender, msg.value, minOut);\r\n    }\r\n\r\n    function purchaseBondForUser(address user, uint minOut) external payable {\r\n        _purchaseBond(user, msg.value, minOut);\r\n    }\r\n\r\n    function releaseBond(uint256 bondID) external {\r\n        _releaseBond(bondID);\r\n    }\r\n\r\n    function releaseBonds(uint256[] calldata bondIDs) external {\r\n        uint len = bondIDs.length;\r\n        for (uint i = 0; i < len;) {\r\n            _releaseBond(bondIDs[i]);\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    function _releaseBond(uint256 bondID) internal {\r\n        require(\r\n            bondID < nonce,\r\n            'Invalid Bond ID'\r\n        );\r\n        require(\r\n            bonds[bondID].unlockBlock <= block.number,\r\n            'Lock Time Has Not Passed'\r\n        );\r\n\r\n        // number of MDB tokens bond ID has held\r\n        uint256 nTokens = bonds[bondID].numTokens;\r\n\r\n        // recipient of the MDB Tokens held by bond ID\r\n        address recipient = bonds[bondID].recipient;\r\n\r\n        // Ensure ID Has Not Already Been Released\r\n        require(\r\n            nTokens > 0 &&\r\n            recipient != address(0),\r\n            'Bond has already been released'\r\n        );\r\n\r\n        // Maybe remove bondID from user array\r\n        _removeBond(bondID);\r\n\r\n        // send tokens back to recipient\r\n        if (nTokens > balanceOf()) {\r\n            nTokens = balanceOf();\r\n        }\r\n        require(\r\n            IERC20(MDB).transfer(\r\n                recipient,\r\n                nTokens\r\n            ),\r\n            'Failure On Token Transfer'\r\n        );\r\n    }\r\n\r\n    function _purchaseBond(address user, uint amount, uint minOut) internal {\r\n        require(\r\n            user != address(0),\r\n            'Zero User'\r\n        );\r\n        require(\r\n            amount >= minimumValue,\r\n            'Amount Less Than Minimum'\r\n        );\r\n        require(\r\n            nextBondAvailable(),\r\n            'Bond Not Available'\r\n        );\r\n\r\n        // reset bond availability\r\n        lastBondPurchased = block.number;\r\n\r\n        // buy MDB\r\n        uint received = _buy(amount, minOut);\r\n\r\n        // register bond to nonce\r\n        bonds[nonce].recipient = user;\r\n        bonds[nonce].numTokens = received;\r\n        bonds[nonce].unlockBlock = block.number + lockTime;\r\n        bonds[nonce].indexInUserArray = userIDs[user].length;\r\n\r\n        // register nonce to user\r\n        userIDs[user].push(nonce);\r\n\r\n        // emit event\r\n        emit BondCreated(user, amount, bonds[nonce].unlockBlock, nonce);\r\n\r\n        // increment global nonce\r\n        nonce++;\r\n        numberOfActiveBonds++;\r\n    }\r\n\r\n    function _buy(uint amount, uint minOut) internal returns (uint256) {\r\n\r\n        // MDB balance before buy\r\n        uint before = balanceOf();\r\n\r\n        // swap BNB to MDB\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(minOut, path, address(this), block.timestamp + 100);\r\n\r\n        // MDB balance after buy\r\n        uint After = balanceOf();\r\n        \r\n        // ensure tokens were received\r\n        require(\r\n            After > before,\r\n            'Zero Received'\r\n        );\r\n\r\n        // ensure minOut was preserved\r\n        uint received = After - before;\r\n        require(\r\n            received >= minOut,\r\n            'Min Out'\r\n        );\r\n\r\n        // return number of tokens purchased\r\n        return received;\r\n    }\r\n\r\n    function _removeBond(uint256 bondID) internal {\r\n\r\n        // index of bond ID we are removing\r\n        uint rmIndex = bonds[bondID].indexInUserArray;\r\n        // user who owns the bond ID\r\n        address user = bonds[bondID].recipient;\r\n        // length of user bond ID array\r\n        uint userIDLength = userIDs[user].length;\r\n\r\n        // set index of last element to be removed index\r\n        bonds[\r\n            userIDs[user][userIDLength - 1]\r\n        ].indexInUserArray = rmIndex;\r\n\r\n        // set removed element to be last element of user array\r\n        userIDs[user][\r\n            rmIndex\r\n        ] = userIDs[user][userIDLength - 1];\r\n\r\n        // pop last element off user array\r\n        userIDs[user].pop();\r\n\r\n        // decrement number of active bonds\r\n        numberOfActiveBonds--;\r\n\r\n        // remove bond data\r\n        delete bonds[bondID];\r\n    }\r\n\r\n    function nextBondAvailable() public view returns (bool) {\r\n        return block.number - lastBondPurchased >= day;\r\n    }\r\n\r\n    function timeUntilNextBond() public view returns (uint256) {\r\n        if (nextBondAvailable()) {\r\n            return 0;\r\n        }\r\n        return day - ( block.number - lastBondPurchased);\r\n    }\r\n\r\n    function balanceOf() public view returns (uint256) {\r\n        return IERC20(MDB).balanceOf(address(this));\r\n    }\r\n    \r\n    function timeUntilUnlock(uint256 bondID) public view returns (uint256) {\r\n        return bonds[bondID].unlockBlock <= block.number ? 0 : bonds[bondID].unlockBlock - block.number;\r\n    }\r\n\r\n    function numBonds(address user) public view returns (uint256) {\r\n        return userIDs[user].length;\r\n    }\r\n\r\n    function fetchBondIDs(address user) external view returns (uint256[] memory) {\r\n        return userIDs[user];\r\n    }\r\n\r\n    function fetchTotalTokensToClaim(address user) external view returns (uint256 total) {\r\n        uint nBonds = numBonds(user);\r\n        for (uint i = 0; i < nBonds; i++) {\r\n            total += bonds[userIDs[user][i]].numTokens;\r\n        }\r\n    }\r\n\r\n    function fetchTotalTokensToClaimThatCanBeClaimed(address user) external view returns (uint256 total) {\r\n        (, uint256[] memory tokens) = fetchIDsAndNumTokensThatCanBeClaimed(user);\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            total += tokens[i];\r\n        }\r\n    }\r\n\r\n    function fetchIDsAndNumTokensAndLockDurations(address user) external view returns (uint256[] memory, uint256[] memory, uint256[] memory) {\r\n        uint nBonds = numBonds(user);\r\n        uint256[] memory tokens = new uint256[](nBonds);\r\n        uint256[] memory unlockDurations = new uint256[](nBonds);\r\n\r\n        for (uint i = 0; i < nBonds; i++) {\r\n            tokens[i] = bonds[userIDs[user][i]].numTokens;\r\n            unlockDurations[i] = timeUntilUnlock(userIDs[user][i]);\r\n        }\r\n        return (userIDs[user], tokens, unlockDurations);\r\n    }\r\n\r\n    function fetchIDsAndNumTokensThatCanBeClaimed(address user) public view returns (uint256[] memory, uint256[] memory) {\r\n        uint nBonds = numBonds(user);\r\n\r\n        uint count = 0;\r\n        for (uint i = 0; i < nBonds; i++) {\r\n            if (timeUntilUnlock(userIDs[user][i]) == 0) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory tokens = new uint256[](count);\r\n        uint256[] memory IDs = new uint256[](count);\r\n\r\n        uint uCount = 0;\r\n        for (uint i = 0; i < nBonds; i++) {\r\n            if (timeUntilUnlock(userIDs[user][i]) == 0) {\r\n                tokens[uCount] = bonds[userIDs[user][i]].numTokens;\r\n                IDs[uCount] = userIDs[user][i];\r\n                uCount++;\r\n            }\r\n        }\r\n\r\n        return (IDs, tokens);\r\n    }\r\n\r\n    function fetchIDsThatCanBeClaimed(address user) public view returns (uint256[] memory) {\r\n        uint nBonds = numBonds(user);\r\n\r\n        uint count = 0;\r\n        for (uint i = 0; i < nBonds; i++) {\r\n            if (timeUntilUnlock(userIDs[user][i]) == 0) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        uint256[] memory IDs = new uint256[](count);\r\n\r\n        uint uCount = 0;\r\n        for (uint i = 0; i < nBonds; i++) {\r\n            if (timeUntilUnlock(userIDs[user][i]) == 0) {\r\n                IDs[uCount] = userIDs[user][i];\r\n                uCount++;\r\n            }\r\n        }\r\n\r\n        return (IDs);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bondID\",\"type\":\"uint256\"}],\"name\":\"BondCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MDB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexInUserArray\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchBondIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchIDsAndNumTokensAndLockDurations\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchIDsAndNumTokensThatCanBeClaimed\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchIDsThatCanBeClaimed\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchTotalTokensToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"fetchTotalTokensToClaimThatCanBeClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBondPurchased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextBondAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"numBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfActiveBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseBond\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"purchaseBond\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"purchaseBondForUser\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondID\",\"type\":\"uint256\"}],\"name\":\"releaseBond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"bondIDs\",\"type\":\"uint256[]\"}],\"name\":\"releaseBonds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimum\",\"type\":\"uint256\"}],\"name\":\"setMinimumValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeUntilNextBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bondID\",\"type\":\"uint256\"}],\"name\":\"timeUntilUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MDBBonds", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e2261d05309f7f391193ea7b7f10cc523b8b957f61d95b94eacaa9fbfadef33c"}