{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.6.0 <0.9.0;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"add err\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"sub err\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(a == 0 || c / a == b, \"mul err\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"div 0 err\");\r\n    uint256 c = a / b;\r\n    require(a == b * c + a % b, \"div err\"); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ninterface ERC20Basic {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        // emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * > Note: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    // function renounceOwnership() public onlyOwner {\r\n    //     emit OwnershipTransferred(_owner, address(0));\r\n    //     _owner = address(0);\r\n    // }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        // emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// pragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WHT() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n\r\n// pragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract TxRule is Ownable{\r\n    using SafeMath for uint256;\r\n\r\n    address public _systemAddress1;\r\n    address public _systemAddress2;\r\n    address public adminContract;\r\n\r\n    mapping(address => bool) public txWhiteList;\r\n    address[] public noNeedRedUsers;\r\n    mapping(address => bool) public noNeedRedUsersDic;\r\n    bool public needGas = true; \r\n    uint256 public allTotalGas = 0;\r\n    uint256 public lastAllTotalGas = 0;\r\n    uint256 public sendGasMin = 1000 * (10**18);\r\n    uint256 public haveRedMin = 100000 * (10**18);\r\n    // uint256 public sendGasMin = 100000 * (10**18);\r\n    // uint256 public haveRedMin = 100000 * (10**18);\r\n    uint256 public haveRedAllAmount = 0;\r\n    uint256 public gasRedRatio = 6; // /100\r\n    bool public swapStartOn = false; \r\n    \r\n    SwapHelp swapHelp;\r\n    address public swapHelpAddress;\r\n    \r\n    function setSwapHelp(address _address) external onlyOwner {\r\n        swapHelpAddress = _address;\r\n        swapHelp = SwapHelp(_address);\r\n        txWhiteList[_address] = true;\r\n        noNeedRedUsers.push(_address); \r\n        noNeedRedUsersDic[_address] = true;\r\n    }\r\n    function updateSendGasMin(uint256 _value) external onlyOwner {\r\n        require(_value>0, \"_value is 0\");\r\n        sendGasMin = _value;\r\n    }\r\n    function updateHaveRedMin(uint256 _value) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        require(_value>0, \"_value is 0\");\r\n        haveRedMin = _value;\r\n    }\r\n    function needGasOnOff(bool _bo) external onlyOwner {\r\n        needGas = _bo;\r\n    }\r\n    function addTxWhiteList(address _address) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        txWhiteList[_address] = true;\r\n    }\r\n    function subTxWhiteList(address _address) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        delete txWhiteList[_address];\r\n    }\r\n    function addNoNeedRedUsers(address _address) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        noNeedRedUsers.push(_address);\r\n        noNeedRedUsersDic[_address] = true;\r\n    }\r\n    function subNoNeedRedUsers(uint256 _index) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        delete noNeedRedUsersDic[noNeedRedUsers[_index]];\r\n        delete noNeedRedUsers[_index];\r\n    }\r\n    function updateSystemAddress1(address _address) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        _systemAddress1 = _address;\r\n    }\r\n    function updateSystemAddress2(address _address) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        _systemAddress2 = _address;\r\n    }\r\n    function updateGasRedRatio(uint256 _value) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        require(_value>=0 && _value<=100, \"_value error\");\r\n        gasRedRatio = _value;\r\n    }\r\n    \r\n    function updateAdminContract(address _address) external onlyOwner {\r\n        adminContract = _address;\r\n    }\r\n    function offSwapStartOn() external onlyOwner {\r\n        swapStartOn = false;\r\n    }\r\n  \r\n    /**\r\n     * \u5206\u7ea2 \r\n    */ \r\n    bool public needSendRed = true;\r\n    uint256 public allTotalReward = 0;  \r\n    uint256 public lastTotalReward = 0;\r\n    uint256 public totalAccSushi = 0;\r\n    uint256 public exUpdateAccSushi = 0;\r\n    uint256 public allTotalRewardLp = 0;  \r\n    uint256 public lastTotalRewardLp = 0;\r\n    uint256 public totalAccSushiLp = 0;\r\n    uint256 public exUpdateAccSushiLp = 0;\r\n    struct UserStruct {\r\n        uint256 curReward;\r\n        uint256 curRewardLp;\r\n        uint256 accSushi;\r\n        uint256 accSushiLp;\r\n        uint256 exUpdateAccSushi;\r\n        uint256 exUpdateAccSushiLp;\r\n    }\r\n    mapping(address => UserStruct) public users;\r\n    function needSendRedOnOff(bool _bo) external onlyOwner {\r\n        needSendRed = _bo;\r\n    }\r\n    uint256 public tokenRedRatio = 80; // /100\r\n    function updateTokenRedRatio(uint256 _value) public {\r\n        require(msg.sender == adminContract || isOwner(), \"account error\");\r\n        require(_value>=0 && _value<=100, \"_value is >=0 and <=100\");\r\n        tokenRedRatio = _value;\r\n    }\r\n\r\n    /**\r\n     * swap \r\n    */ \r\n    address[] public swapPath;\r\n    address[] public swapPath2;\r\n    address usdt = 0x55d398326f99059fF775485246999027B3197955; // bsc\r\n    address swap = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // bsc\r\n    address public exToken = 0x2859e4544C4bB03966803b044A93563Bd2D0DD4D; // shib \r\n    address public exBase = usdt; // usdt\r\n    address public exToken2 = 0xC9882dEF23bc42D53895b8361D0b1EDC7570Bc6A; // fist \r\n    address public exBase2 = usdt; // usdt\r\n    // wbnb 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\r\n    ERC20Basic cakeToken = ERC20Basic(exToken);\r\n    ERC20Basic cakeToken2 = ERC20Basic(exToken2);\r\n\r\n    // address uniswapV2Pair = address(0x0);\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    ERC20Basic public lpTokenContract;\r\n    constructor () { \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(swap); \r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), usdt); //getPair, createPair\r\n        uniswapV2Router = _uniswapV2Router;\r\n        lpTokenContract = ERC20Basic(uniswapV2Pair);\r\n        \r\n        swapPath = new address[](3);\r\n        swapPath[0] = address(this);\r\n        swapPath[1] = usdt;\r\n        swapPath[2] = exToken;\r\n\r\n        swapPath2 = new address[](3);\r\n        swapPath2[0] = address(this);\r\n        swapPath2[1] = usdt;\r\n        swapPath2[2] = exToken2;\r\n    }\r\n    function updateExAndBaseToken1(address _exToken1, address _exBase1) external onlyOwner {\r\n        exToken = _exToken1;\r\n        exBase = _exBase1;\r\n        exUpdateAccSushi = totalAccSushi;\r\n        lastTotalReward = allTotalReward;\r\n        cakeToken.transfer(_systemAddress1, cakeToken.balanceOf(address(this)));\r\n        cakeToken = ERC20Basic(exToken);\r\n        if (_exBase1 == usdt) {\r\n            swapPath = new address[](3);\r\n            swapPath[0] = address(this);\r\n            swapPath[1] = usdt;\r\n            swapPath[2] = exToken;\r\n        } else {\r\n            swapPath = new address[](4);\r\n            swapPath[0] = address(this);\r\n            swapPath[1] = usdt;\r\n            swapPath[2] = exBase;\r\n            swapPath[3] = exToken;\r\n        }\r\n    }\r\n    function updateExAndBaseToken2(address _exToken2, address _exBase2) external onlyOwner {\r\n        exUpdateAccSushiLp = totalAccSushiLp;\r\n        exToken2 = _exToken2;\r\n        exBase2 = _exBase2;\r\n        lastTotalRewardLp = allTotalRewardLp;\r\n        cakeToken2.transfer(_systemAddress1, cakeToken2.balanceOf(address(this)));\r\n        cakeToken2 = ERC20Basic(exToken2);\r\n        if (_exBase2 == usdt) {\r\n            swapPath2 = new address[](3);\r\n            swapPath2[0] = address(this);\r\n            swapPath2[1] = usdt;\r\n            swapPath2[2] = exToken2;\r\n        } else {\r\n            swapPath2 = new address[](4);\r\n            swapPath2[0] = address(this);\r\n            swapPath2[1] = usdt;\r\n            swapPath2[2] = exBase2;\r\n            swapPath2[3] = exToken2;\r\n        }\r\n    }\r\n}\r\n\r\ninterface SwapHelp  {\r\n    function buySwap() external;\r\n}\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract StandardToken is ERC20Basic,TxRule {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  uint256 _totalSupply;\r\n\r\n  /**\r\n   * @dev Fix for the ERC20 short address attack.\r\n   */\r\n  modifier onlyPayloadSize(uint size) {\r\n    if(msg.data.length < size + 4) {\r\n      revert();\r\n    }\r\n    _;\r\n  }\r\n    \r\n    function totalValidBalanceLp() public view returns (uint256) {\r\n        uint256 amount = lpTokenContract.totalSupply()+1;\r\n        for (uint256 i=0; i < noNeedRedUsers.length; i++) {\r\n            if (noNeedRedUsers[i] != address(0x0)) {\r\n                amount = amount.sub(lpTokenContract.balanceOf(noNeedRedUsers[i]));\r\n            }\r\n        }  \r\n        return amount.sub(lpTokenContract.balanceOf(address(0x0)));\r\n    }\r\n    \r\n    function balanceTokenRedOf(address _user) public view returns (uint256) {\r\n        if (noNeedRedUsersDic[_user] || balanceOf(_user) < haveRedMin) {return 0;}    \r\n        UserStruct memory user = users[_user];\r\n        uint256 accSushi = user.accSushi;\r\n        if (user.exUpdateAccSushi < exUpdateAccSushi) {\r\n            accSushi = exUpdateAccSushi;\r\n        }\r\n        \r\n        // \u6700\u65b0\u7684accSushi\r\n        uint256 _nowSushi = totalAccSushi.add((allTotalReward.sub(lastTotalReward)).mul(_totalSupply).div(haveRedAllAmount));\r\n        // \u8ba1\u7b97\u7528\u6237\u6536\u76ca\r\n        uint256 _userRed = balanceOf(_user).mul(_nowSushi.sub(accSushi)).div(_totalSupply);\r\n        return _userRed;\r\n    }\r\n    \r\n    function balanceLpRedOf(address _user) public view returns (uint256) {\r\n        if (noNeedRedUsersDic[_user]) {return 0;}    \r\n        UserStruct memory user = users[_user];\r\n        uint256 accSushiLp = user.accSushiLp;\r\n        if (user.exUpdateAccSushiLp < exUpdateAccSushiLp) {\r\n            accSushiLp = exUpdateAccSushiLp;\r\n        }\r\n        \r\n        // \u6700\u65b0\u7684accSushi\r\n        uint256 _nowSushiLp = totalAccSushiLp.add((allTotalRewardLp.sub(lastTotalRewardLp)).mul(_totalSupply).div(totalValidBalanceLp()));\r\n        // \u8ba1\u7b97\u7528\u6237\u6536\u76ca\r\n        uint256 _userRedLp = lpTokenContract.balanceOf(_user).mul(_nowSushiLp.sub(accSushiLp)).div(_totalSupply);\r\n        return _userRedLp;\r\n    }\r\n\r\n    function handleSendRed(address _user) private{\r\n        if (noNeedRedUsersDic[_user]) {return;}\r\n        UserStruct storage user = users[_user];\r\n        if (user.exUpdateAccSushi < exUpdateAccSushi) {\r\n            user.exUpdateAccSushi = exUpdateAccSushi;\r\n            user.accSushi = exUpdateAccSushi;\r\n        }\r\n        uint256 _totalRed = allTotalReward.sub(lastTotalReward);        \r\n        uint256 _nowSushi = totalAccSushi.add(_totalRed.mul(_totalSupply).div(haveRedAllAmount));\r\n        uint256 _userRed = balanceOf(_user).mul(_nowSushi.sub(user.accSushi)).div(_totalSupply);\r\n        if (_userRed > 0 && balanceOf(_user) >= haveRedMin) {\r\n            cakeToken.transfer(_user, _userRed);\r\n            user.curReward = user.curReward.add(_userRed);\r\n        }\r\n        user.accSushi = _nowSushi;        \r\n        totalAccSushi = _nowSushi;\r\n        lastTotalReward = allTotalReward;\r\n        \r\n        handleSendRedLp(_user);\r\n    }\r\n    function handleSendRedLp(address _user) private{\r\n        UserStruct storage user = users[_user];\r\n        if (user.exUpdateAccSushiLp < exUpdateAccSushiLp) {\r\n            user.exUpdateAccSushiLp = exUpdateAccSushiLp;\r\n            user.accSushiLp = exUpdateAccSushiLp;\r\n        }\r\n        uint256 _totalRed = allTotalRewardLp.sub(lastTotalRewardLp);\r\n        uint256 _nowSushi = totalAccSushiLp.add(_totalRed.mul(_totalSupply).div(totalValidBalanceLp()));\r\n        uint256 _userRed = lpTokenContract.balanceOf(_user).mul(_nowSushi.sub(user.accSushiLp)).div(_totalSupply);\r\n        if (_userRed > 0) {\r\n            cakeToken2.transfer(_user, _userRed);\r\n            user.curRewardLp = user.curRewardLp.add(_userRed);\r\n        } \r\n        user.accSushiLp = _nowSushi;        \r\n        totalAccSushiLp = _nowSushi;\r\n        lastTotalRewardLp = allTotalRewardLp;\r\n    }\r\n    uint256 public systemAmount2 = 0;\r\n    uint256 public lastSystemAmount2 = 0;\r\n    \r\n    function swapTokensForCake(address[] memory path, uint256 tokenAmount, address receiveAddress) private {\r\n        // _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        allowed[address(this)][address(uniswapV2Router)] = tokenAmount;\r\n        emit Approval(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            receiveAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapTokensToUsdt(uint256 tokenAmount, address receiveAddress) private {\r\n        // generate the uniswap pair path of token -> WHT\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n\r\n        // approve(address(uniswapV2Router), tokenAmount);\r\n        allowed[address(this)][address(uniswapV2Router)] = tokenAmount;\r\n        emit Approval(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            receiveAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n    function handleTrasfer() public {\r\n        uint256 subAmount = allTotalGas.sub(lastAllTotalGas);\r\n        if (subAmount > sendGasMin) {\r\n            lastAllTotalGas = allTotalGas;\r\n            uint256 gasRatioAll = gasRedRatio+4;\r\n\r\n            uint256 addLpAmount = subAmount.mul(2).div(gasRatioAll);\r\n            balances[swapHelpAddress] = balances[swapHelpAddress].add(addLpAmount);\r\n            balances[address(this)] = balances[address(this)].sub(addLpAmount);\r\n            emit Transfer(address(this), swapHelpAddress, addLpAmount);\r\n            swapHelp.buySwap();\r\n\r\n            swapTokensToUsdt(addLpAmount, _systemAddress1);\r\n\r\n            uint256 rewardAmount = subAmount.sub(subAmount.mul(2).div(gasRatioAll)).sub(subAmount.mul(2).div(gasRatioAll)); \r\n\r\n            uint256 initBalance = cakeToken.balanceOf(address(this));\r\n            swapTokensForCake(swapPath, rewardAmount.mul(tokenRedRatio).div(100), address(this));\r\n            uint256 newBalance = cakeToken.balanceOf(address(this)).sub(initBalance);\r\n            allTotalReward = allTotalReward.add(newBalance);\r\n\r\n            uint256 initBalance2 = cakeToken2.balanceOf(address(this));\r\n            swapTokensForCake(swapPath2, rewardAmount.sub(rewardAmount.mul(tokenRedRatio).div(100)), address(this));\r\n            uint256 newBalance2 = cakeToken2.balanceOf(address(this)).sub(initBalance2);\r\n            allTotalRewardLp = allTotalRewardLp.add(newBalance2);\r\n        }\r\n        if (systemAmount2.sub(lastSystemAmount2) > sendGasMin.div(10)) {\r\n            swapTokensToUsdt(systemAmount2.sub(lastSystemAmount2), _systemAddress2);\r\n            lastSystemAmount2 = systemAmount2;\r\n        }\r\n    }\r\n    function handleSubGasBalance(address _user, address _to, uint256 _value) private{\r\n        uint256 _gas = _value.mul(gasRedRatio+5).div(100);\r\n        uint256 peerGas = _value.mul(1).div(100);\r\n        allTotalGas = allTotalGas.add(_gas.sub(peerGas));\r\n        if (_user != _to) {// sell\r\n            _gas += peerGas;\r\n            systemAmount2 = systemAmount2.add(peerGas);\r\n        }\r\n        balances[_to] = balances[_to].sub(_gas);\r\n        emit Transfer(_to, address(this), _gas);\r\n        balances[address(this)] = balances[address(this)].add(_gas.sub(peerGas));\r\n\r\n        address burnAddress = address(0x01);\r\n        if (balances[address(0x01)] >= _totalSupply.div(5)) {\r\n            burnAddress = _systemAddress2;\r\n        }\r\n        balances[burnAddress] = balances[burnAddress].add(peerGas);\r\n        emit Transfer(address(this), burnAddress, peerGas);\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 _value) private {\r\n        require(_value <= balances[_from], \"_from balance low\");\r\n        if (swapStartOn && (_from == uniswapV2Pair || _to == uniswapV2Pair)) {\r\n            if (_from == uniswapV2Pair) {\r\n                require(_to == _systemAddress1, \"_to not is _systemAddress1\");\r\n            } else if (_to == uniswapV2Pair) {\r\n                require(_from == _systemAddress1, \"_from not is _systemAddress1\");\r\n            }\r\n        }\r\n        if (needSendRed && haveRedAllAmount > 0) { \r\n            handleSendRed(_from);\r\n            handleSendRed(_to);\r\n        }\r\n        \r\n        uint256 initBalance = balanceSum(_from, _to);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        \r\n        if (needGas) {\r\n            address gasAddress = address(0x0);\r\n            if (_from == uniswapV2Pair) {\r\n                gasAddress = _to;\r\n            }\r\n            if (_to == uniswapV2Pair) {\r\n                gasAddress = _from;\r\n            }\r\n            if (gasAddress != address(0x0) && !txWhiteList[gasAddress]) {\r\n                handleSubGasBalance(gasAddress, _to, _value);\r\n            }\r\n            if (_to != uniswapV2Pair && _from != uniswapV2Pair) {\r\n                handleTrasfer();\r\n            }\r\n        }\r\n        uint256 newBalance = balanceSum(_from, _to);\r\n        haveRedAllAmount = haveRedAllAmount.add(newBalance).sub(initBalance);\r\n    }\r\n    function balanceSum(address _from, address _to) public view returns(uint256){\r\n        uint256 amount = 0;\r\n        if (balances[_from] >= haveRedMin && !noNeedRedUsersDic[_from]) {\r\n            amount = amount.add(balances[_from]);\r\n        }\r\n        if (balances[_to] >= haveRedMin && !noNeedRedUsersDic[_to]) {\r\n            amount = amount.add(balances[_to]);\r\n        }\r\n        return amount;\r\n    }\r\n    \r\n    // function test(address _user, uint256 _totalCount) public onlyOwner { \r\n    //     ERC20Basic _myToken = ERC20Basic(address(_user));\r\n    //     _myToken.transfer(owner(), _totalCount);\r\n    // }\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        allowed[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n\r\n        if (needSendRed && haveRedAllAmount > 0) { \r\n            handleSendRed(owner);\r\n            handleSendRed(spender);\r\n        }\r\n        handleTrasfer();\r\n    }\r\n    \r\n    \r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) override returns (bool) {\r\n    // require(_to != address(0));\r\n    _transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\r\n    require(_to != address(0), \"to do not is 0x0\");\r\n    require(_value <= allowed[_from][msg.sender], \"_from allowed low\");\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    \r\n    _transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n  \r\n  function balanceOf(address _owner) public view override returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n  \r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n  \r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public onlyPayloadSize(2 * 32) override returns (bool) {\r\n    _approve(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n    \r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view override returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public onlyPayloadSize(2 * 32) returns (bool) {\r\n    require(_spender != address(0));\r\n    // require(allowed[msg.sender][_spender].add(_addedValue) <= balances[msg.sender]);\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public onlyPayloadSize(2 * 32) returns (bool) {\r\n    require(_spender != address(0));\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SimpleToken\r\n * @dev ERC20 Token, where all tokens are pre-assigned to the creator.\r\n * Note they can later distribute these tokens as they wish using `transfer` and other\r\n * `StandardToken` functions.\r\n */\r\ncontract AMyToken is StandardToken {\r\n\r\n    string public constant symbol = \"Pizza\";\r\n    string public constant name = \"Pizza\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint256 public constant INITIAL_SUPPLY = 1000 * (10 ** 12) * (10 ** uint256(decimals));\r\n\r\n    /**\r\n    * @dev Constructor that gives msg.sender all of existing tokens.\r\n    */\r\n    constructor() {\r\n        _totalSupply = INITIAL_SUPPLY;\r\n        \r\n        // test\r\n        _systemAddress1 = 0xD42E8b7f0a62e11D470133E606aDf66e69038096;\r\n        _systemAddress2 = 0xe7725b6e999aF2F9d50d2A0dF006D54235bccC9E;\r\n        address systemReceive = 0x26453aE2C1441Df45F26b07f0aa954CC0b39ed56;\r\n        \r\n\r\n        noNeedRedUsers = [address(0x0), address(0x01), address(this), uniswapV2Pair,\r\n            systemReceive, _systemAddress1, _systemAddress2];\r\n        for (uint256 i=0; i < noNeedRedUsers.length; i++) {\r\n            noNeedRedUsersDic[noNeedRedUsers[i]] = true;\r\n            txWhiteList[noNeedRedUsers[i]] = true;\r\n        }\r\n        txWhiteList[msg.sender] = true;\r\n\r\n        balances[systemReceive] = INITIAL_SUPPLY;\r\n        emit Transfer(address(0x0), systemReceive, balances[systemReceive]);\r\n        \r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_systemAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_systemAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addNoNeedRedUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addTxWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTotalGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTotalRewardLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceLpRedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"balanceSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceTokenRedOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exBase\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exBase2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exToken2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exUpdateAccSushi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exUpdateAccSushiLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasRedRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"handleTrasfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"haveRedAllAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"haveRedMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAllTotalGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSystemAmount2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTotalRewardLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpTokenContract\",\"outputs\":[{\"internalType\":\"contract ERC20Basic\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needGas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bo\",\"type\":\"bool\"}],\"name\":\"needGasOnOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needSendRed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bo\",\"type\":\"bool\"}],\"name\":\"needSendRedOnOff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"noNeedRedUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noNeedRedUsersDic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offSwapStartOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendGasMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSwapHelp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"subNoNeedRedUsers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"subTxWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapHelpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swapPath\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swapPath2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapStartOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemAmount2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRedRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccSushi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccSushiLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValidBalanceLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"txWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateAdminContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exToken1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exBase1\",\"type\":\"address\"}],\"name\":\"updateExAndBaseToken1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exToken2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exBase2\",\"type\":\"address\"}],\"name\":\"updateExAndBaseToken2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateGasRedRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateHaveRedMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateSendGasMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateSystemAddress1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateSystemAddress2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"updateTokenRedRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"curReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curRewardLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accSushi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accSushiLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exUpdateAccSushi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exUpdateAccSushiLp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AMyToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9fb8f4473fc8440313d089ebc9c865e62b1e3e11d5d425d48d64dfaae0f50ae0"}