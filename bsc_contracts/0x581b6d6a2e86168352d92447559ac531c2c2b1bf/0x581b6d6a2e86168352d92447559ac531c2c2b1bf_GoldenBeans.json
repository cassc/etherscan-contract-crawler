{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GoldenBeans.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./utils/SafeMath.sol\\\";\\n\\ncontract GoldenBeans {\\n    using SafeMath for uint256;\\n    \\n     /* Team can:\\n     * -> change the Proof of BEAN balance requirement for referrals\\n     * -> disable Early Roasters mode exactly once\\n     * -> can increase early roaster max amount\\n     * -> add new accounts who have Baraista role */\\n    modifier onlyTeam {\\n        require(owner == msg.sender, \\\"Only Team\\\");\\n        _;\\n    }\\n\\n    /* Bariastas can: \\n     * -> add Early Roasters \\n     *\\n     * Baristas and Team CANNOT:\\n     * -> take funds from contract\\n     * -> disable withdrawals\\n     * -> kill the contract\\n     * -> change the price of tokens */\\n    modifier onlyBaristas {\\n        require(baristas[msg.sender] == true, \\\"Only Baristas\\\");\\n        _;\\n    }\\n\\n    /* re-entrancy protections, just in case */\\n    bool internal locked;\\n    modifier notReentrant() {\\n        require(!locked, \\\"No re-entrancy\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    // only holders of tokens\\n    modifier onlyBeanMasters {\\n        require(balanceOf(msg.sender) > 0, \\\"Only Bean Masters\\\");\\n        _;\\n    }\\n    \\n    // only holders with profits\\n    modifier onlyBeanTycoons {\\n        require(myDividends(true) > 0, \\\"Only Bean Tycoons\\\");\\n        _;\\n    }\\n\\n    // early roaster program\\n    modifier antiBurntBean(uint256 _amountOfEther) {\\n        if (onlyEarlyRoasters) {\\n            require(\\n                // is the customer in the early roaster list?\\n                earlyRoasters[msg.sender] == true,\\n                \\\"Only early roasters\\\");\\n            require(\\n                // does this purchase exceed the max early roaster amount?\\n                (earlyRoasterQuota[msg.sender] + _amountOfEther) <= earlyRoasterMaxAmount,\\n                \\\"Exceeds max early roaster amount\\\"\\n            );\\n            // update the accumulated quota\\n            earlyRoasterQuota[msg.sender] = SafeMath.add(earlyRoasterQuota[msg.sender], _amountOfEther);\\n        }  \\n        // execute\\n        _;\\n    }\\n    \\n    /*********************************\\n     *            EVENTS             *\\n     *********************************/\\n    event onRoast(\\n        address indexed account,\\n        uint256 incomingEther,\\n        uint256 tokensMinted,\\n        address indexed referredBy\\n    );\\n    \\n    event onDarkRoast(\\n        address indexed account,\\n        uint256 etherReinvested,\\n        uint256 tokensMinted\\n    );\\n\\n    event onBrew(\\n        address indexed account,\\n        uint256 tokensBurned,\\n        uint256 etherEarned\\n    );\\n\\n    event onWithdraw(\\n        address indexed account,\\n        uint256 etherWithdrawn\\n    );\\n    \\n    // ERC20\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 tokens\\n    );\\n    \\n    string public name = \\\"Golden Beans\\\";\\n    string public symbol = \\\"BEANS\\\";\\n    uint8 constant public decimals = 18;\\n    uint8 constant internal dividendFee_ = 10;\\n    uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\\n    uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\\n    uint256 constant internal magnitude = 2**64;\\n    \\n    // Proof of Bean (defaults to 10 BEANS)\\n    uint256 public proofOfBean = 10 ether;\\n    uint256 public numberOfRoasts = 0;\\n    uint256 public numberOfBrews = 0;\\n\\n    // early roaster program\\n    bool public onlyEarlyRoasters = true;\\n    mapping(address => bool) public earlyRoasters;\\n    mapping(address => uint256) public earlyRoasterQuota;\\n    uint256 public earlyRoasterMaxAmount = 1 ether;\\n    \\n    // amount of shares for each address\\n    mapping(address => uint256) internal tokenBalanceLedger_;\\n    mapping(address => uint256) internal referralBalance_;\\n    mapping(address => int256) internal payoutsTo_;\\n    uint256 internal tokenSupply_ = 0;\\n    uint256 internal profitPerShare_;\\n    \\n    // baristas list\\n    mapping(address => bool) public baristas;\\n    \\n    // Owner\\n    address public owner;\\n\\n    address[6] public feeWallets;\\n    uint256 public feeBasis;\\n    uint256 constant public FEE_DIVIDER = 10000;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        feeWallets[0] = 0x07315b79FEa4d2eEeF6Cd6498FbF9c61A32a8678;\\n        feeWallets[1] = 0x6667b89c61bF929bb6440B7772F7893Fa44ED3F8;\\n        feeWallets[2] = 0xa5a47E554Ba4762Fb3972506F883D4479A91C01b;\\n        feeWallets[3] = 0xF29A99E4647209f0977237570886dC47B7a2b24E;\\n        feeWallets[4] = 0x7a0AD44b416A9D5B4F0154D49c65Bac66f3065a1;\\n        feeWallets[5] = 0x755B40Cb53D327e1BcEb8FFF4F83B58e0A8510d3;\\n        feeBasis = 100;\\n    }\\n    \\n    /**\\n     * Converts all incoming Ether to tokens for the caller, and passes down the referral address\\n     */\\n    function roast(address _referredBy)\\n        notReentrant\\n        external\\n        payable\\n        returns (uint256 tokens)\\n    {\\n        uint256 taxes = fees(msg.value);\\n        tokens = purchaseTokens(msg.value - taxes, _referredBy);\\n    }\\n    \\n    receive() payable external {\\n        uint256 taxes = fees(msg.value);\\n        purchaseTokens(msg.value - taxes, owner);\\n    }\\n    \\n    /**\\n     * Converts all of caller's dividends to tokens.\\n     */\\n    function darkroast()\\n        onlyBeanTycoons\\n        external\\n        returns (uint256 tokens)\\n    {\\n        // fetch dividends\\n        uint256 _dividends = myDividends(false); // retrieve ref. bonus later in the code\\n        \\n        // pay out the dividends virtually [saves gas]\\n        payoutsTo_[msg.sender] += (int256) (_dividends * magnitude);\\n        \\n        // retrieve ref. bonus\\n        _dividends += referralBalance_[msg.sender];\\n        referralBalance_[msg.sender] = 0;\\n        \\n        // dispatch a buy order with the dividends, with no referrer\\n        tokens = purchaseTokens(_dividends, address(0));\\n        \\n        // fire event\\n        emit onDarkRoast(msg.sender, _dividends, tokens);\\n    }\\n    \\n    /**\\n     * Combined alias of brew() and withdraw().\\n     */\\n    function exit()\\n        external\\n    {\\n        // get token count for caller, sell them all and receive Ether back\\n        uint256 _tokens = tokenBalanceLedger_[msg.sender];\\n        if (_tokens > 0) {\\n            brew(_tokens);\\n        }\\n        withdraw();\\n    }\\n\\n    /**\\n     * Withdraws all of the callers earnings [receiving Ether]\\n     */\\n    function withdraw()\\n        onlyBeanTycoons\\n        public\\n    {\\n        uint256 _dividends = myDividends(false); \\n        \\n        // update dividend tracker\\n        payoutsTo_[msg.sender] += (int256) (_dividends * magnitude);\\n        \\n        // add ref. bonus\\n        _dividends += referralBalance_[msg.sender];\\n        referralBalance_[msg.sender] = 0;\\n        \\n        // apply tax\\n        uint256 taxes = fees(_dividends);\\n\\n        // send Ether\\n        msg.sender.transfer(_dividends - taxes);\\n        \\n        // fire event\\n        emit onWithdraw(msg.sender, _dividends);\\n    }\\n    \\n    /**\\n     * Liquifies tokens [no Ether is returned]\\n     */\\n    function brew(uint256 _tokens)\\n        onlyBeanMasters\\n        public\\n        returns (uint256 _taxedEther)\\n    {\\n        require(_tokens <= tokenBalanceLedger_[msg.sender], \\\"invalid amount\\\");\\n        uint256 _ether = tokensToEther_(_tokens);\\n        uint256 _dividends = SafeMath.div(_ether, dividendFee_);\\n        _taxedEther = SafeMath.sub(_ether, _dividends);\\n        \\n        // burn the sold tokens\\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\\n        tokenBalanceLedger_[msg.sender] = SafeMath.sub(tokenBalanceLedger_[msg.sender], _tokens);\\n        \\n        // update dividends tracker\\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEther * magnitude));\\n        payoutsTo_[msg.sender] -= _updatedPayouts;       \\n        \\n        // dividing by zero is a bad idea\\n        if (tokenSupply_ > 0) {\\n            // update the amount of dividends per token\\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\\n        }\\n        \\n        numberOfBrews++;\\n\\n        // fire event\\n        emit onBrew(msg.sender, _tokens, _taxedEther);\\n    }\\n    \\n    /**\\n     * Transfer tokens from the caller to a new holder.\\n     * There's a 10% fee sent as dividends to current holders\\n     */\\n    function transfer(address _toAddress, uint256 _amountOfTokens)\\n        onlyBeanMasters\\n        public\\n        returns(bool)\\n    {\\n        // make sure customer has the requested tokens\\n        require(_amountOfTokens <= tokenBalanceLedger_[msg.sender], \\\"invalid amount\\\");\\n        \\n        // withdraw all outstanding dividends first\\n        if (myDividends(true) > 0) {\\n            withdraw();\\n        }\\n        \\n        // liquify 10% of the tokens that are transfered\\n        // these are dispersed to token holders\\n        uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\\n        uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\\n        uint256 _dividends = tokensToEther_(_tokenFee);\\n  \\n        // burn the fee tokens\\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\\n\\n        // exchange tokens\\n        tokenBalanceLedger_[msg.sender] = SafeMath.sub(tokenBalanceLedger_[msg.sender], _amountOfTokens);\\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\\n        \\n        // update dividend trackers\\n        payoutsTo_[msg.sender] -= (int256) (profitPerShare_ * _amountOfTokens);\\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\\n        \\n        // disperse dividends among token holders\\n        profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\\n        \\n        // fire event\\n        emit Transfer(msg.sender, _toAddress, _taxedTokens);\\n        \\n        // ERC20\\n        return true;\\n    }\\n    \\n    /* Team only methods  */\\n    /**\\n     *  Team can disable the early roasters phase exactly once\\n     */\\n    function disableEarlyRoasters()\\n        onlyTeam\\n        external\\n    {\\n        onlyEarlyRoasters = false;\\n    }\\n\\n    /**\\n     * Team can add an address as a Bariasta\\n     * which also allows address to deposit as an early roaster\\n     */\\n    function addBarista(address _identifier)\\n        onlyTeam\\n        external\\n    {\\n        baristas[_identifier] = true;\\n        earlyRoasters[_identifier] = true;\\n    }\\n\\n    /**\\n     *  Team can increase the max purchase for early roasters\\n     */\\n    function setEarlyRoasterMaxPurchase(uint256 _amount)\\n        onlyTeam\\n        external\\n    {\\n        require(_amount > earlyRoasterMaxAmount, \\\"Can only increase amount\\\");\\n        earlyRoasterMaxAmount = _amount;\\n    }\\n    \\n    /**\\n     *  Team can set the amount of BEANS required for referrals \\n     */\\n    function setProofOfBean(uint256 _amountOfTokens)\\n        onlyTeam\\n        external\\n    {\\n        proofOfBean = _amountOfTokens;\\n    }\\n    \\n    /**\\n     *  Baristas can add early roaster addresses\\n     */\\n    \\n    function addEarlyRoasters(address newEarlyRoaster)  \\n        onlyBaristas\\n        external \\n    {\\n        earlyRoasters[newEarlyRoaster] = true;\\n    }\\n\\n    /*----------  HELPERS AND CALCULATORS  ----------*/\\n    /**\\n     * Method to view the current Ether stored in the contract\\n     * Example: totalEtherBalance()\\n     */\\n    function totalEtherBalance()\\n        public\\n        view\\n        returns(uint)\\n    {\\n        return address(this).balance;\\n    }\\n    \\n    /**\\n     * Retrieve the total token supply.\\n     */\\n    function totalSupply()\\n        external\\n        view\\n        returns(uint256)\\n    {\\n        return tokenSupply_;\\n    }\\n    \\n    /**\\n     * Retrieve the dividends owned by the caller.\\n       */ \\n    function myDividends(bool _includeReferralBonus) \\n        public \\n        view \\n        returns(uint256)\\n    {\\n        return _includeReferralBonus ? dividendsOf(msg.sender) + referralBalance_[msg.sender] : dividendsOf(msg.sender) ;\\n    }\\n    \\n    /**\\n     * Retrieve the token balance of any single address.\\n     */\\n    function balanceOf(address _customerAddress)\\n        view\\n        public\\n        returns(uint256)\\n    {\\n        return tokenBalanceLedger_[_customerAddress];\\n    }\\n    \\n    /**\\n     * Retrieve the dividend balance of any single address.\\n     */\\n    function dividendsOf(address _customerAddress)\\n        view\\n        public\\n        returns(uint256)\\n    {\\n        return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\\n    }\\n    \\n    /**\\n     * Return the buy price of 1 individual token.\\n     */\\n    function sellPrice() \\n        external \\n        view \\n        returns(uint256)\\n    {\\n        if (tokenSupply_ == 0) {\\n            return tokenPriceInitial_ - tokenPriceIncremental_;\\n        } else {\\n            uint256 _ether = tokensToEther_(1e18);\\n            uint256 _dividends = SafeMath.div(_ether, dividendFee_);\\n            uint256 _taxedEther = SafeMath.sub(_ether, _dividends);\\n            return _taxedEther;\\n        }\\n    }\\n    \\n    /**\\n     * Return the sell price of 1 individual token.\\n     */\\n    function buyPrice() \\n        external \\n        view \\n        returns(uint256)\\n    {\\n        if (tokenSupply_ == 0) {\\n            return tokenPriceInitial_ + tokenPriceIncremental_;\\n        } else {\\n            uint256 _ether = tokensToEther_(1e18);\\n            uint256 _dividends = SafeMath.div(_ether, dividendFee_);\\n            uint256 _taxedEther = SafeMath.add(_ether, _dividends);\\n            return _taxedEther;\\n        }\\n    }\\n       \\n    function calculateTokensReceived(uint256 _etherToSpend) \\n        external \\n        view \\n        returns(uint256)\\n    {\\n        uint256 _dividends = SafeMath.div(_etherToSpend, dividendFee_);\\n        uint256 _taxedEther = SafeMath.sub(_etherToSpend, _dividends);\\n        uint256 _amountOfTokens = etherToTokens_(_taxedEther);\\n        return _amountOfTokens;\\n    }\\n    \\n    function calculateEtherReceived(uint256 _tokensToSell) \\n        external \\n        view \\n        returns(uint256)\\n    {\\n        require(_tokensToSell <= tokenSupply_, \\\"invalid tokens to sell\\\");\\n        uint256 _ether = tokensToEther_(_tokensToSell);\\n        uint256 _dividends = SafeMath.div(_ether, dividendFee_);\\n        uint256 _taxedEther = SafeMath.sub(_ether, _dividends);\\n        return _taxedEther;\\n    }\\n\\n    /*==========================================\\n    =            INTERNAL FUNCTIONS            =\\n    ==========================================*/\\n    function purchaseTokens(uint256 _incomingEther, address _referredBy)\\n        antiBurntBean(_incomingEther)\\n        internal\\n        returns(uint256 _amountOfTokens)\\n    {\\n        uint256 _undividedDividends = SafeMath.div(_incomingEther, dividendFee_);\\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\\n        uint256 _taxedEther = SafeMath.sub(_incomingEther, _undividedDividends);\\n        uint256 _fee = _dividends * magnitude;\\n        _amountOfTokens = etherToTokens_(_taxedEther);\\n \\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_), \\\"invalid amount\\\");\\n        \\n        // is the user referred?\\n        if (\\n            // is this a referred purchase?\\n            _referredBy != address(0) &&\\n\\n            // no cheating!\\n            _referredBy != msg.sender &&\\n            \\n            tokenBalanceLedger_[_referredBy] >= proofOfBean\\n        ) {\\n            // bean redistribution\\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\\n        } else {\\n            // no ref purchase\\n            // add the referral bonus back to the global dividends\\n            _dividends = SafeMath.add(_dividends, _referralBonus);\\n            _fee = _dividends * magnitude;\\n        }\\n        \\n        // we can't give people infinite ether\\n        if (tokenSupply_ > 0) {\\n            // add tokens to the pool\\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\\n \\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\\n            \\n            // calculate the amount of tokens the customer receives over his purchase \\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\\n        \\n        } else {\\n            // add tokens to the pool\\n            tokenSupply_ = _amountOfTokens;\\n        }\\n        \\n        // update circulating supply & the ledger address for the customer\\n        tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);\\n        \\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\\n        payoutsTo_[msg.sender] += _updatedPayouts;\\n    \\n        emit onRoast(msg.sender, _incomingEther, _amountOfTokens, _referredBy);\\n        numberOfRoasts++;\\n        return _amountOfTokens;\\n    }\\n\\n    function fees(uint256 amount) internal returns (uint256) {\\n        uint256 totalFees;\\n        for (uint256 i = 0; i < feeWallets.length; i++) {\\n            uint256 feeShare = amount.mul(feeBasis).div(FEE_DIVIDER);\\n            payable(feeWallets[i]).transfer(feeShare);\\n            totalFees += feeShare;\\n        }\\n        return totalFees;\\n    }\\n\\n    /**\\n     * Calculate Token price based on an amount of incoming ether\\n     * Some conversions occurr to prevent decimal errors or underflows / overflows.\\n     */\\n    function etherToTokens_(uint256 _ether)\\n        internal\\n        view\\n        returns(uint256)\\n    {\\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\\n        uint256 _tokensReceived = \\n         (\\n            (\\n                // underflow attempts BTFO\\n                SafeMath.sub(\\n                    (sqrt\\n                        (\\n                            (_tokenPriceInitial**2)\\n                            +\\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ether * 1e18))\\n                            +\\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\\n                            +\\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\\n                        )\\n                    ), _tokenPriceInitial\\n                )\\n            )/(tokenPriceIncremental_)\\n        )-(tokenSupply_)\\n        ;\\n        return _tokensReceived;\\n    }\\n    \\n    /**\\n     * Calculate token sell value.\\n          */\\n     function tokensToEther_(uint256 _tokens)\\n        internal\\n        view\\n        returns(uint256)\\n    {\\n        uint256 tokens_ = (_tokens + 1e18);\\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\\n        uint256 _etherReceived =\\n        (\\n            // underflow attempts BTFO\\n            SafeMath.sub(\\n                (\\n                    (\\n                        (\\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\\n                        )-tokenPriceIncremental_\\n                    )*(tokens_ - 1e18)\\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\\n            )\\n        /1e18);\\n        return _etherReceived;\\n    }\\n    \\n    function sqrt(uint x) internal pure returns (uint y) {\\n        uint z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.5;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n   \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n   \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return c;\\n    }\\n\\n    \\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n   \\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherEarned\",\"type\":\"uint256\"}],\"name\":\"onBrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onDarkRoast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingEther\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"onRoast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"etherWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_identifier\",\"type\":\"address\"}],\"name\":\"addBarista\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newEarlyRoaster\",\"type\":\"address\"}],\"name\":\"addEarlyRoasters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baristas\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"brew\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxedEther\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEtherReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_etherToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"darkroast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableEarlyRoasters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyRoasterMaxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyRoasterQuota\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyRoasters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBasis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfBrews\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfRoasts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onlyEarlyRoasters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proofOfBean\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"roast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setEarlyRoasterMaxPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setProofOfBean\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEtherBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GoldenBeans", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}