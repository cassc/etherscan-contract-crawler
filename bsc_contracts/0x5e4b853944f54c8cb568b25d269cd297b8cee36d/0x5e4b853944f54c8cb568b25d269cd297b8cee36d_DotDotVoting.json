{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DotDotVoting.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IEpsProxy.sol\\\";\\nimport \\\"ITokenLocker.sol\\\";\\nimport \\\"IIncentiveVoting.sol\\\";\\n\\n\\ncontract DotDotVoting is Ownable {\\n\\n    struct Vote {\\n        address token;\\n        uint256 votes;\\n    }\\n    struct TokenApprovalVote {\\n        uint256 week;\\n        uint256 ratio;\\n    }\\n\\n    // user -> week -> votes used\\n    mapping(address => uint256[65535]) public userVotes;\\n\\n    // user -> token -> week -> votes for pool\\n    mapping(address => mapping(address => uint256[65535])) public userTokenVotes;\\n\\n    // token -> week -> votes received\\n    mapping(address => uint256[65535]) public tokenVotes;\\n\\n    // week -> number of EPS votes per DDD vote\\n    uint256[65535] public epsVoteRatio;\\n\\n    // vote ID -> user -> yes votes\\n    mapping(uint256 => mapping(address => uint256)) public userTokenApprovalVotes;\\n    // user -> timestamp of last created token approval vote\\n    mapping(address => uint256) public lastVote;\\n\\n    mapping (uint256 => TokenApprovalVote) tokenApprovalVotes;\\n\\n    uint256 constant WEEK = 86400 * 7;\\n\\n    // new weeks within this contract begin on Thursday 00:00:00 UTC\\n    uint256 public startTime;\\n\\n    IIncentiveVoting public immutable epsVoter;\\n    ITokenLocker public immutable epsLocker;\\n\\n    ITokenLocker public dddLocker;\\n    address public fixedVoteLpToken;\\n    IEllipsisProxy public proxy;\\n\\n    mapping(address => bool) public isApproved;\\n\\n    event VotedForIncentives(\\n        address indexed voter,\\n        address[] tokens,\\n        uint256[] votes,\\n        uint256 userVotesUsed,\\n        uint256 totalUserVotes\\n    );\\n    event CreatedTokenApprovalVote(\\n        address indexed user,\\n        uint256 voteIndex,\\n        address token\\n    );\\n    event VotedForTokenApproval(\\n        address indexed voter,\\n        uint256 voteIndex,\\n        uint256 yesVotes\\n    );\\n\\n    constructor(\\n        IIncentiveVoting _epsVoter,\\n        ITokenLocker _epsLocker\\n    ) {\\n        epsVoter = _epsVoter;\\n        epsLocker = _epsLocker;\\n\\n        startTime = _epsVoter.startTime();\\n    }\\n\\n    function setAddresses(\\n        ITokenLocker _dddLocker,\\n        address _fixedVoteLpToken,\\n        IEllipsisProxy _proxy\\n    ) external onlyOwner {\\n        dddLocker = _dddLocker;\\n        fixedVoteLpToken = _fixedVoteLpToken;\\n        proxy = _proxy;\\n\\n        renounceOwnership();\\n    }\\n\\n    function votingOpen() public view returns (bool) {\\n        uint256 weekStart = block.timestamp / WEEK * WEEK;\\n        return block.timestamp - 86400 * 4 >= weekStart;\\n    }\\n\\n    function getWeek() public view returns (uint256) {\\n        if (startTime >= block.timestamp) return 0;\\n        return (block.timestamp - startTime) / WEEK;\\n    }\\n\\n\\n    function weeklyVotes(address _user, address _token, uint256 _week) external view returns (uint256, uint256) {\\n        return (userTokenVotes[_user][_token][_week], tokenVotes[_token][_week]);\\n    }\\n\\n    /**\\n        @notice Get data on the current votes made in the active week\\n        @return _totalVotes Total number of votes this week for all pools\\n        @return _voteData Dynamic array of (token address, votes for token)\\n     */\\n    function getCurrentVotes() external view returns (uint256 _totalVotes, Vote[] memory _voteData) {\\n        _voteData = new Vote[](epsVoter.approvedTokensLength());\\n        uint256 week = getWeek();\\n        uint256 totalVotes;\\n        for (uint i = 0; i < _voteData.length; i++) {\\n            address token = epsVoter.approvedTokens(i);\\n            uint256 votes = tokenVotes[token][week];\\n            totalVotes += votes;\\n            _voteData[i] = Vote({token: token, votes: votes});\\n        }\\n        return (totalVotes, _voteData);\\n    }\\n\\n    /**\\n        @notice Get data on current votes `_user` has made in the active week\\n        @return _totalVotes Total number of votes from `_user` this week for all pools\\n        @return _voteData Dynamic array of (token address, votes for token)\\n     */\\n    function getUserCurrentVotes(address _user)\\n        external\\n        view\\n        returns (uint256 _totalVotes, Vote[] memory _voteData)\\n    {\\n        _voteData = new Vote[](epsVoter.approvedTokensLength());\\n        uint256 week = getWeek();\\n        for (uint i = 0; i < _voteData.length; i++) {\\n            address token = epsVoter.approvedTokens(i);\\n            _voteData[i] = Vote({token: token, votes: userTokenVotes[_user][token][week]});\\n        }\\n        return (userVotes[_user][week], _voteData);\\n    }\\n\\n    /**\\n        @notice Get the amount of unused votes for for the current week being voted on\\n        @param _user Address to query\\n        @return uint Amount of unused votes\\n     */\\n    function availableVotes(address _user) external view returns (uint256) {\\n        if (!votingOpen()) return 0;\\n        uint256 week = getWeek();\\n        uint256 usedVotes = userVotes[_user][week];\\n        uint256 totalVotes = dddLocker.weeklyWeightOf(_user, week) / 1e18;\\n        return totalVotes - usedVotes;\\n    }\\n\\n    /**\\n        @notice Allocate votes toward LP tokens to receive emissions in the following week\\n        @dev Voting works identically to\\n        @param _tokens List of addresses of LP tokens to vote for\\n        @param _votes Votes to allocate to `_tokens`. Values are additive, they do\\n                        not include previous votes. For example, if you have already\\n                        allocated 100 votes and wish to allocate a total of 300,\\n                        the vote amount should be given as 200.\\n     */\\n    function vote(address[] calldata _tokens, uint256[] memory _votes) external {\\n        require(votingOpen(), \\\"Voting period has not opened for this week\\\");\\n        require(_tokens.length == _votes.length, \\\"Input length mismatch\\\");\\n\\n        uint256 week = getWeek();\\n        uint256 ratio = epsVoteRatio[week];\\n        if (ratio == 0) {\\n            uint256 epsVotes = epsVoter.availableVotes(address(proxy));\\n\\n            if (epsVoter.isApproved(fixedVoteLpToken)) {\\n                // use 5% of the votes for EPX/dEPX pool\\n                address[] memory fixedVoteToken = new address[](1);\\n                fixedVoteToken[0] = fixedVoteLpToken;\\n                uint256[] memory fixedVote = new uint256[](1);\\n                fixedVote[0] = epsVotes / 20;\\n                proxy.vote(fixedVoteToken, fixedVote);\\n                epsVotes -= fixedVote[0];\\n            }\\n            uint256 dddVotes = dddLocker.weeklyTotalWeight(week) / 1e18;\\n            ratio = epsVotes / dddVotes;\\n            epsVoteRatio[week] = ratio;\\n        }\\n\\n        // update accounting for this week's votes\\n        uint256 usedVotes = userVotes[msg.sender][week];\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address token = _tokens[i];\\n            uint256 amount = _votes[i];\\n            tokenVotes[token][week] += amount;\\n            userTokenVotes[msg.sender][token][week] += amount;\\n            usedVotes += amount;\\n            // multiply by ratio after updating internal accounting but prior to submitting\\n            _votes[i] = amount * ratio;\\n        }\\n\\n        // make sure user has not exceeded available votes\\n        uint256 totalVotes = dddLocker.weeklyWeightOf(msg.sender, week) / 1e18;\\n        require(usedVotes <= totalVotes, \\\"Available votes exceeded\\\");\\n        userVotes[msg.sender][week] = usedVotes;\\n\\n        // submit votes\\n        proxy.vote(_tokens, _votes);\\n\\n        emit VotedForIncentives(\\n            msg.sender,\\n            _tokens,\\n            _votes,\\n            usedVotes,\\n            totalVotes\\n        );\\n    }\\n\\n    function minWeightForNewTokenApprovalVote() public view returns (uint256) {\\n        uint256 lockerWeek = epsLocker.getWeek();\\n        if (lockerWeek == 0) return 0;\\n        uint256 epsVotes = epsLocker.weeklyWeightOf(address(proxy), epsLocker.getWeek() - 1);\\n        uint256 dddVotes = dddLocker.weeklyTotalWeight(getWeek() - 1) / 1e18;\\n        uint256 ratio = epsVotes / dddVotes;\\n        return epsVoter.NEW_TOKEN_APPROVAL_VOTE_MIN_WEIGHT() / ratio;\\n    }\\n\\n    function createTokenApprovalVote(address _token) external returns (uint256 _voteIndex) {\\n        require(epsVoter.isApproved(fixedVoteLpToken), \\\"Cannot make vote until dEPX/EPX pool approved\\\");\\n        require(lastVote[msg.sender] + 86400 * 30 < block.timestamp, \\\"One new vote per 30 days\\\");\\n        uint256 weight = dddLocker.weeklyWeightOf(msg.sender, getWeek() - 1);\\n        require(weight >= minWeightForNewTokenApprovalVote(), \\\"User has insufficient DotDot lock weight\\\");\\n        _voteIndex = proxy.createTokenApprovalVote(_token);\\n        lastVote[msg.sender] = block.timestamp;\\n        emit CreatedTokenApprovalVote(msg.sender, _voteIndex, _token);\\n    }\\n\\n    function availableTokenApprovalVotes(address _user, uint256 _voteIndex) external view returns (uint256) {\\n        uint256 ratio = tokenApprovalVotes[_voteIndex].ratio;\\n        uint256 week = tokenApprovalVotes[_voteIndex].week;\\n        if (ratio == 0) {\\n            uint256 epsVotes = epsVoter.availableTokenApprovalVotes(address(proxy), _voteIndex);\\n            if (epsVotes == 0) return 0;\\n            week = getWeek() - 1;\\n            uint256 dddVotes = dddLocker.weeklyTotalWeight(week) / 1e18;\\n            ratio = epsVotes / dddVotes;\\n        }\\n        uint256 totalVotes = dddLocker.weeklyWeightOf(_user, week) / 1e18;\\n        uint256 usedVotes = userTokenApprovalVotes[_voteIndex][_user];\\n        return totalVotes - usedVotes;\\n    }\\n\\n    /**\\n        @notice Vote in favor of approving a new token for protocol emissions\\n        @param _voteIndex Array index referencing the vote\\n     */\\n    function voteForTokenApproval(uint256 _voteIndex, uint256 _yesVotes) external {\\n        TokenApprovalVote storage vote = tokenApprovalVotes[_voteIndex];\\n        if (vote.ratio == 0) {\\n            uint256 epsVotes = epsVoter.availableTokenApprovalVotes(address(proxy), _voteIndex);\\n            require(epsVotes > 0, \\\"Vote has closed or does not exist\\\");\\n            vote.week = getWeek() - 1;\\n            uint256 dddVotes = dddLocker.weeklyTotalWeight(vote.week) / 1e18;\\n            vote.ratio = epsVotes / dddVotes;\\n        }\\n\\n        uint256 totalVotes = dddLocker.weeklyWeightOf(msg.sender, vote.week) / 1e18;\\n        uint256 usedVotes = userTokenApprovalVotes[_voteIndex][msg.sender];\\n        if (_yesVotes == type(uint256).max) {\\n            _yesVotes = totalVotes - usedVotes;\\n        }\\n        usedVotes += _yesVotes;\\n        require(usedVotes <= totalVotes, \\\"Exceeds available votes\\\");\\n\\n        userTokenApprovalVotes[_voteIndex][msg.sender] = usedVotes;\\n        proxy.voteForTokenApproval(_voteIndex, _yesVotes * vote.ratio);\\n        emit VotedForTokenApproval(msg.sender, _voteIndex, _yesVotes);\\n    }\\n\\n    /**\\n        @notice Create a token approval vote for `fixedVoteLpToken` and vote\\n                with all available weight\\n        @dev This function is unguarded, but will revert within EPS if the the\\n             token is already approved or the last vote was made less than 1\\n             week ago.\\n     */\\n    function createFixedVoteApprovalVote() external {\\n        uint256 voteId = proxy.createTokenApprovalVote(fixedVoteLpToken);\\n        proxy.voteForTokenApproval(voteId, type(uint256).max);\\n        emit CreatedTokenApprovalVote(msg.sender, voteId, fixedVoteLpToken);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"IEpsProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\ninterface IEllipsisProxy {\\n    function lock(uint256 _amount) external returns (bool);\\n    function extendLock(uint256 _amount, uint256 _weeks) external returns (bool);\\n    function deposit(address _token, uint256 _amount) external returns (uint256);\\n    function withdraw(address _receiver, address _token, uint256 _amount) external returns (uint256);\\n    function claimEmissions(address _token) external returns (uint256);\\n    function claimFees(address[] calldata _tokens) external returns (bool);\\n    function vote(address[] calldata _tokens, uint256[] calldata _votes) external returns (bool);\\n    function createTokenApprovalVote(address _token) external returns (uint256 _voteIndex);\\n    function voteForTokenApproval(uint256 _voteIndex, uint256 _yesVotes) external returns (bool);\\n    function getReward(address _lpToken, address[] calldata _rewards) external returns (bool);\\n}\"\r\n    },\r\n    \"ITokenLocker.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\n\\ninterface ITokenLocker {\\n\\n    function MAX_LOCK_WEEKS() external view returns (uint256);\\n    function getWeek() external view returns (uint256);\\n    function userWeight(address _user) external view returns (uint256);\\n    function totalWeight() external view returns (uint256);\\n    function weeklyWeight(address _user, uint256 _week) external view returns (uint256, uint256);\\n    function startTime() external view returns (uint256);\\n    function weeklyTotalWeight(uint256 week) external view returns (uint256);\\n    function weeklyWeightOf(address user, uint256 week) external view returns (uint256);\\n\\n    /**\\n        @notice Get data on a user's active token locks\\n        @param _user Address to query data for\\n        @return lockData dynamic array of [weeks until expiration, balance of lock]\\n     */\\n    function getActiveUserLocks(address _user) external view returns (uint256[2][] memory lockData);\\n\\n    /**\\n        @notice Allow or block third-party calls to deposit, withdraw\\n                or claim rewards on behalf of the caller\\n     */\\n    function setBlockThirdPartyActions(bool _block) external;\\n\\n    /**\\n        @notice Deposit tokens into the contract to create a new lock.\\n        @param _user Address to create a new lock for (does not have to be the caller)\\n        @param _amount Amount of tokens to lock. This balance transfered from the caller.\\n        @param _weeks The number of weeks for the lock.\\n     */\\n    function lock(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _weeks\\n    ) external returns (bool);\\n\\n    /**\\n        @notice Extend the length of an existing lock.\\n        @param _amount Amount of tokens to extend the lock for.\\n        @param _weeks The number of weeks for the lock that is being extended.\\n        @param _newWeeks The number of weeks to extend the lock until.\\n     */\\n    function extendLock(\\n        uint256 _amount,\\n        uint256 _weeks,\\n        uint256 _newWeeks\\n    ) external returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"IIncentiveVoting.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\ninterface IIncentiveVoting {\\n\\n    function NEW_TOKEN_APPROVAL_VOTE_MIN_WEIGHT() external view returns (uint256);\\n    function startTime() external view returns (uint256);\\n    function availableVotes(address _user) external view returns (uint256);\\n    function availableTokenApprovalVotes(address _user, uint256 _voteIndex) external view returns (uint256);\\n    function isApproved(address _token) external view returns (bool);\\n    function approvedTokensLength() external view returns (uint256);\\n    function approvedTokens(uint256) external view returns (address);\\n\\n    /**\\n        @notice Allocate votes toward LP tokens to receive emissions in the following week\\n        @param _tokens List of addresses of LP tokens to vote for\\n        @param _votes Votes to allocate to `_tokens`\\n     */\\n    function vote(address[] calldata _tokens, uint256[] calldata _votes) external;\\n\\n    /**\\n        @notice Create a new vote to enable protocol emissions on a given token\\n        @param _token Token address to create a vote for\\n        @return _voteIndex uint Index value used to reference the vote\\n     */\\n    function createTokenApprovalVote(address _token) external returns (uint256 _voteIndex);\\n\\n    /**\\n        @notice Vote in favor of approving a new token for protocol emissions\\n        @param _voteIndex Array index referencing the vote\\n     */\\n    function voteForTokenApproval(uint256 _voteIndex, uint256 _yesVotes) external;\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"DotDotVoting.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IIncentiveVoting\",\"name\":\"_epsVoter\",\"type\":\"address\"},{\"internalType\":\"contract ITokenLocker\",\"name\":\"_epsLocker\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"CreatedTokenApprovalVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"votes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userVotesUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalUserVotes\",\"type\":\"uint256\"}],\"name\":\"VotedForIncentives\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yesVotes\",\"type\":\"uint256\"}],\"name\":\"VotedForTokenApproval\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_voteIndex\",\"type\":\"uint256\"}],\"name\":\"availableTokenApprovalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"availableVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createFixedVoteApprovalVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"createTokenApprovalVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dddLocker\",\"outputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epsLocker\",\"outputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epsVoteRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epsVoter\",\"outputs\":[{\"internalType\":\"contract IIncentiveVoting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedVoteLpToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVotes\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct DotDotVoting.Vote[]\",\"name\":\"_voteData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserCurrentVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVotes\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct DotDotVoting.Vote[]\",\"name\":\"_voteData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWeightForNewTokenApprovalVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"internalType\":\"contract IEllipsisProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"_dddLocker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fixedVoteLpToken\",\"type\":\"address\"},{\"internalType\":\"contract IEllipsisProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenApprovalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userTokenVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_votes\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_yesVotes\",\"type\":\"uint256\"}],\"name\":\"voteForTokenApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_week\",\"type\":\"uint256\"}],\"name\":\"weeklyVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DotDotVoting", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004695e50a38e33ea09d1f623ba8a8db24219bb06a00000000000000000000000022a93f53a0a3e6847d05dd504283e8e296a49aae", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}