{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Atlas.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at BscScan.com on 2022-02-18\\r\\n */\\r\\n\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n//\\r\\n// PETOVERSE PROTOCOL COPYRIGHT (C) 2022\\r\\n\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapPair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint256 amount0In,\\r\\n        uint256 amount1In,\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function kLast() external view returns (uint256);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\r\\n\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeSwapFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\r\\n    function allPairs(uint256) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint256);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipRenounced(address indexed previousOwner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipRenounced(_owner);\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract ERC20Detailed is IERC20 {\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    constructor(\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_\\r\\n    ) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Vault {}\\r\\n\\r\\ncontract LiquidityFeeHolder {}\\r\\n\\r\\ncontract ATLAS is ERC20Detailed, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMathInt for int256;\\r\\n\\r\\n    event LogRebase(uint256 indexed block, uint256 totalSupply);\\r\\n    event AddedLiquidity(uint256 eth, uint256 tokens, uint256 timestamp);\\r\\n    event Swap(uint256 eth, uint256 tokens, uint256 timestamp);\\r\\n    event RewardClaim(address indexed account, uint256 amount, uint256 timestamp, uint256 nextClaim);\\r\\n\\r\\n    string public _name = \\\"THE ATLAS COIN\\\";\\r\\n    string public _symbol = \\\"ATLAS\\\";\\r\\n    uint8 public _decimals = 5;\\r\\n\\r\\n    IPancakeSwapPair public pairContract;\\r\\n    mapping(address => bool) _isFeeExempt;\\r\\n\\r\\n    modifier validRecipient(address to) {\\r\\n        require(to != address(0x0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    uint256 public constant DECIMALS = 5;\\r\\n    uint256 public constant MAX_UINT256 = ~uint256(0);\\r\\n\\r\\n    // Fee\\r\\n    // buy = 0, sell = 1, p2p = 2\\r\\n    uint256[] public liquidityFee;\\r\\n    uint256[] public treasuryFee;\\r\\n    uint256[] public insuranceFee;\\r\\n    uint256[] public infernoPitFee;\\r\\n    uint256 public feeDenominator = 1000;\\r\\n    bool public feeEnabled = true;\\r\\n\\r\\n    uint256 liquidityFeeCollected;\\r\\n    uint256 treasuryFeeCollected;\\r\\n    uint256 insuranceFeeCollected;\\r\\n\\r\\n    //addresses\\r\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address public liquidityFeeHolder;\\r\\n    address public treasuryReceiver;\\r\\n    address public insuranceReceiver;\\r\\n    address public infernoPit;\\r\\n\\r\\n    // liqudity settings\\r\\n    bool public _autoAddLiquidity;\\r\\n    uint256 public _mintAmountBeforeSwap = 100e5;\\r\\n    uint256 public _liquidityInterval = 48 hours;\\r\\n    uint256 public _lastAddLiquidityTime;\\r\\n\\r\\n    // rebase settings\\r\\n    bool public _autoRebase;\\r\\n    uint256 public _lastRebaseBlock;\\r\\n    uint256 public _rebaseAmount;\\r\\n\\r\\n    // swap settings\\r\\n    bool public swapEnabled = true;\\r\\n    IPancakeSwapRouter public router;\\r\\n    address public pair;\\r\\n    bool inSwap = false;\\r\\n\\r\\n    // reward settings\\r\\n    mapping(address => uint256) public nextAvailableClaimDate;\\r\\n    uint256 public rewardCycleInterval;\\r\\n    uint256 public rewardPerCycle;\\r\\n    address public vault;\\r\\n\\r\\n    // sell limit settings\\r\\n    mapping(address => uint256) public userSells;\\r\\n    mapping(address => uint256) public userSellCycleStart;\\r\\n    uint256 public sellPercentAllow = 30;\\r\\n    bool public sellLimitEnabled = false;\\r\\n\\r\\n    mapping(address => bool) public blacklist;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    uint256 private _gonsPerFragment;\\r\\n\\r\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\r\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 10_000_000 * 10**DECIMALS;\\r\\n    uint256 public constant MAX_SUPPLY = 10_000_000_000 * 10**DECIMALS;\\r\\n\\r\\n    mapping(address => uint256) private _gonBalances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\\r\\n\\r\\n    modifier swapping() {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _router,\\r\\n        address _owner,\\r\\n        address _treasuryReceiver,\\r\\n        address _insuranceReceiver\\r\\n    ) ERC20Detailed(_name, _symbol, uint8(DECIMALS)) Ownable() {\\r\\n        router = IPancakeSwapRouter(_router);\\r\\n        pair = IPancakeSwapFactory(router.factory()).createPair(router.WETH(), address(this));\\r\\n\\r\\n        treasuryReceiver = _treasuryReceiver;\\r\\n        insuranceReceiver = _insuranceReceiver;\\r\\n        infernoPit = DEAD;\\r\\n\\r\\n        liquidityFeeHolder = address(new LiquidityFeeHolder());\\r\\n        vault = address(new Vault());\\r\\n\\r\\n        _allowedFragments[address(this)][address(router)] = uint256(-1);\\r\\n        pairContract = IPancakeSwapPair(pair);\\r\\n\\r\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n        _gonBalances[_owner] = TOTAL_GONS;\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        _lastRebaseBlock = block.number;\\r\\n        _autoRebase = false;\\r\\n        _rebaseAmount = 960000; // 10,000 % APY\\r\\n\\r\\n        _autoAddLiquidity = false;\\r\\n        _isFeeExempt[_owner] = true;\\r\\n        _isFeeExempt[address(this)] = true;\\r\\n        _isFeeExempt[treasuryReceiver] = true;\\r\\n        _isFeeExempt[insuranceReceiver] = true;\\r\\n        _isFeeExempt[infernoPit] = true;\\r\\n        _isFeeExempt[liquidityFeeHolder] = true;\\r\\n        _isFeeExempt[vault] = true;\\r\\n\\r\\n        // initialize fee\\r\\n        liquidityFee.push(20);\\r\\n        liquidityFee.push(30);\\r\\n        liquidityFee.push(0);\\r\\n\\r\\n        treasuryFee.push(0);\\r\\n        treasuryFee.push(50);\\r\\n        treasuryFee.push(0);\\r\\n\\r\\n        insuranceFee.push(0);\\r\\n        insuranceFee.push(40);\\r\\n        insuranceFee.push(0);\\r\\n\\r\\n        infernoPitFee.push(30);\\r\\n        infernoPitFee.push(30);\\r\\n        infernoPitFee.push(0);\\r\\n\\r\\n        _transferOwnership(_owner);\\r\\n\\r\\n        emit Transfer(address(0x0), _owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function rebase() internal {\\r\\n        if (inSwap) return;\\r\\n        uint256 blockCount = block.number.sub(_lastRebaseBlock);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(blockCount.mul(_rebaseAmount));\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        _lastRebaseBlock = block.number;\\r\\n\\r\\n        pairContract.skim(DEAD);\\r\\n\\r\\n        emit LogRebase(block.number, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value) external override validRecipient(to) returns (bool) {\\r\\n        _transferFrom(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external override validRecipient(to) returns (bool) {\\r\\n        if (_allowedFragments[from][msg.sender] != uint256(-1)) {\\r\\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender].sub(\\r\\n                value,\\r\\n                \\\"Insufficient Allowance\\\"\\r\\n            );\\r\\n        }\\r\\n        _transferFrom(from, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _basicTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\\r\\n        _gonBalances[from] = _gonBalances[from].sub(gonAmount);\\r\\n        _gonBalances[to] = _gonBalances[to].add(gonAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        require(!blacklist[sender] && !blacklist[recipient], \\\"in_blacklist\\\");\\r\\n\\r\\n        if (inSwap) {\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n\\r\\n        if (recipient == pair) {\\r\\n            validateSell(sender, amount);\\r\\n        }\\r\\n\\r\\n        if (shouldRebase()) {\\r\\n            rebase();\\r\\n        }\\r\\n\\r\\n        if (shouldAddLiquidity()) {\\r\\n            addLiquidity();\\r\\n        }\\r\\n\\r\\n        if (shouldSwapBack()) {\\r\\n            swapBack();\\r\\n        }\\r\\n\\r\\n        topUpClaimCycleAfterTransfer(sender, recipient, amount);\\r\\n\\r\\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\\r\\n        _gonBalances[sender] = _gonBalances[sender].sub(gonAmount);\\r\\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient)\\r\\n            ? takeFee(sender, recipient, gonAmount)\\r\\n            : gonAmount;\\r\\n        _gonBalances[recipient] = _gonBalances[recipient].add(gonAmountReceived);\\r\\n\\r\\n        emit Transfer(sender, recipient, gonAmountReceived.div(_gonsPerFragment));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function validateSell(address account, uint256 amount) private {\\r\\n        if (!sellLimitEnabled || _isFeeExempt[account]) return;\\r\\n        if (userSellCycleStart[account] + 1 days < block.timestamp) {\\r\\n            userSellCycleStart[account] = block.timestamp;\\r\\n            userSells[account] = 0;\\r\\n        }\\r\\n        uint256 userBalance = balanceOf(account);\\r\\n        userSells[account] = userSells[account].add(amount);\\r\\n        require(\\r\\n            userBalance.mul(sellPercentAllow).div(feeDenominator) > userSells[account],\\r\\n            \\\"Cannot sell this many tokens\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function takeFee(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 gonAmount\\r\\n    ) internal returns (uint256) {\\r\\n        uint256 feeIndex = sender == pair ? 0 : recipient == pair ? 1 : 2;\\r\\n        uint256 _liquidityFee = liquidityFee[feeIndex];\\r\\n        uint256 _treasuryFee = treasuryFee[feeIndex];\\r\\n        uint256 _insuranceFee = insuranceFee[feeIndex];\\r\\n        uint256 _infernoPitFee = infernoPitFee[feeIndex];\\r\\n\\r\\n        treasuryFeeCollected = treasuryFeeCollected.add(_treasuryFee);\\r\\n        insuranceFeeCollected = insuranceFeeCollected.add(_insuranceFee);\\r\\n\\r\\n        uint256 pitFee = gonAmount.div(feeDenominator).mul(_infernoPitFee);\\r\\n        _gonBalances[infernoPit] = _gonBalances[infernoPit].add(pitFee);\\r\\n        emit Transfer(sender, infernoPit, pitFee.div(_gonsPerFragment));\\r\\n\\r\\n        uint256 bnbFee = gonAmount.div(feeDenominator).mul(_treasuryFee.add(_insuranceFee));\\r\\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(bnbFee);\\r\\n        emit Transfer(sender, address(this), bnbFee.div(_gonsPerFragment));\\r\\n\\r\\n        uint256 liqFee = gonAmount.div(feeDenominator).mul(_liquidityFee);\\r\\n        _gonBalances[liquidityFeeHolder] = _gonBalances[liquidityFeeHolder].add(liqFee);\\r\\n        emit Transfer(sender, liquidityFeeHolder, liqFee.div(_gonsPerFragment));\\r\\n\\r\\n        return gonAmount.sub(pitFee).sub(bnbFee).sub(liqFee);\\r\\n    }\\r\\n\\r\\n    function addLiquidity() internal swapping {\\r\\n        uint256 autoLiquidityAmount = _gonBalances[liquidityFeeHolder].div(_gonsPerFragment);\\r\\n        _gonBalances[address(this)] = _gonBalances[address(this)].add(_gonBalances[liquidityFeeHolder]);\\r\\n        _gonBalances[liquidityFeeHolder] = 0;\\r\\n        uint256 amountToLiquify = autoLiquidityAmount.div(2);\\r\\n        uint256 amountToSwap = autoLiquidityAmount.sub(amountToLiquify);\\r\\n\\r\\n        if (amountToSwap == 0 || _mintAmountBeforeSwap > autoLiquidityAmount) {\\r\\n            return;\\r\\n        }\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        uint256 balanceBefore = address(this).balance;\\r\\n\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 amountETHLiquidity = address(this).balance.sub(balanceBefore);\\r\\n\\r\\n        if (amountToLiquify > 0 && amountETHLiquidity > 0) {\\r\\n            router.addLiquidityETH{value: amountETHLiquidity}(\\r\\n                address(this),\\r\\n                amountToLiquify,\\r\\n                0,\\r\\n                0,\\r\\n                DEAD,\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n        _lastAddLiquidityTime = block.timestamp;\\r\\n\\r\\n        emit AddedLiquidity(amountETHLiquidity, amountToLiquify, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function swapBack() internal swapping {\\r\\n        uint256 amountToSwap = _gonBalances[address(this)].div(_gonsPerFragment);\\r\\n\\r\\n        if (\\r\\n            amountToSwap == 0 ||\\r\\n            treasuryFeeCollected.add(insuranceFeeCollected) == 0 ||\\r\\n            amountToSwap < _mintAmountBeforeSwap\\r\\n        ) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 balanceBefore = address(this).balance;\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 ethSwaped = address(this).balance.sub(balanceBefore);\\r\\n\\r\\n        (bool success, ) = payable(treasuryReceiver).call{\\r\\n            value: ethSwaped.mul(treasuryFeeCollected).div(treasuryFeeCollected.add(insuranceFeeCollected)),\\r\\n            gas: 30000\\r\\n        }(\\\"\\\");\\r\\n        (success, ) = payable(insuranceReceiver).call{\\r\\n            value: ethSwaped.mul(insuranceFeeCollected).div(treasuryFeeCollected.add(insuranceFeeCollected)),\\r\\n            gas: 30000\\r\\n        }(\\\"\\\");\\r\\n\\r\\n        insuranceFeeCollected = 0;\\r\\n        treasuryFeeCollected = 0;\\r\\n\\r\\n        emit Swap(ethSwaped, amountToSwap, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function calculateReward(address account) public view returns (uint256) {\\r\\n        uint256 _circulatingSupply = _totalSupply\\r\\n            .sub(balanceOf(address(this)))\\r\\n            .sub(balanceOf(pair))\\r\\n            .sub(balanceOf(owner()))\\r\\n            .sub(balanceOf(vault))\\r\\n            .sub(balanceOf(DEAD))\\r\\n            .sub(balanceOf(address(0)));\\r\\n\\r\\n        uint256 currentBalance = balanceOf(address(account));\\r\\n        uint256 reward = rewardPerCycle.mul(currentBalance).div(_circulatingSupply);\\r\\n\\r\\n        return reward;\\r\\n    }\\r\\n\\r\\n    function claimReward() public {\\r\\n        require(nextAvailableClaimDate[msg.sender] <= block.timestamp, \\\"Error: Reward Claim unavailable!\\\");\\r\\n        require(balanceOf(msg.sender) >= 0, \\\"Error: Must be a holder to claim  rewards!\\\");\\r\\n\\r\\n        uint256 reward = calculateReward(msg.sender);\\r\\n        nextAvailableClaimDate[msg.sender] = block.timestamp + rewardCycleInterval;\\r\\n        _basicTransfer(vault, msg.sender, reward);\\r\\n\\r\\n        emit RewardClaim(msg.sender, reward, block.timestamp, nextAvailableClaimDate[msg.sender]);\\r\\n    }\\r\\n\\r\\n    function topUpClaimCycleAfterTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        uint256 currentSenderBalance = balanceOf(sender);\\r\\n\\r\\n        if (recipient == pair && currentSenderBalance == amount) {\\r\\n            nextAvailableClaimDate[sender] = 0;\\r\\n        } else {\\r\\n            nextAvailableClaimDate[recipient] = block.timestamp + rewardCycleInterval;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function shouldTakeFee(address from, address to) internal view returns (bool) {\\r\\n        return (pair == from || pair == to) && !_isFeeExempt[from] && !_isFeeExempt[to] && feeEnabled;\\r\\n    }\\r\\n\\r\\n    function shouldRebase() internal view returns (bool) {\\r\\n        return\\r\\n            _autoRebase &&\\r\\n            _lastRebaseBlock < block.number &&\\r\\n            (_totalSupply < MAX_SUPPLY) &&\\r\\n            msg.sender != pair &&\\r\\n            !inSwap;\\r\\n    }\\r\\n\\r\\n    function shouldAddLiquidity() internal view returns (bool) {\\r\\n        return\\r\\n            _autoAddLiquidity &&\\r\\n            !inSwap &&\\r\\n            msg.sender != pair &&\\r\\n            block.timestamp >= (_lastAddLiquidityTime + _liquidityInterval);\\r\\n    }\\r\\n\\r\\n    function shouldSwapBack() internal view returns (bool) {\\r\\n        return swapEnabled && !inSwap && msg.sender != pair;\\r\\n    }\\r\\n\\r\\n    function setAutoRebase(bool _flag) external onlyOwner {\\r\\n        if (_flag) {\\r\\n            _autoRebase = _flag;\\r\\n            _lastRebaseBlock = block.number;\\r\\n        } else {\\r\\n            _autoRebase = _flag;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setAutoAddLiquidity(bool _flag) external onlyOwner {\\r\\n        if (_flag) {\\r\\n            _autoAddLiquidity = _flag;\\r\\n            _lastAddLiquidityTime = block.timestamp;\\r\\n        } else {\\r\\n            _autoAddLiquidity = _flag;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setLiquiditySetting(uint256 _amountBeforeSwap, uint256 _interval) external onlyOwner {\\r\\n        _mintAmountBeforeSwap = _amountBeforeSwap;\\r\\n        _liquidityInterval = _interval;\\r\\n    }\\r\\n\\r\\n    function setSwapBackEnabled(bool _swapBack) external onlyOwner {\\r\\n        swapEnabled = _swapBack;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner_, address spender) external view override returns (uint256) {\\r\\n        return _allowedFragments[owner_][spender];\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\r\\n        if (subtractedValue >= oldValue) {\\r\\n            _allowedFragments[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][spender].add(addedValue);\\r\\n        emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value) external override returns (bool) {\\r\\n        _allowedFragments[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkFeeExempt(address _addr) external view returns (bool) {\\r\\n        return _isFeeExempt[_addr];\\r\\n    }\\r\\n\\r\\n    function isNotInSwap() external view returns (bool) {\\r\\n        return !inSwap;\\r\\n    }\\r\\n\\r\\n    function setFeeReceivers(\\r\\n        address _treasuryReceiver,\\r\\n        address _insuranceReceiver,\\r\\n        address _infernoPit\\r\\n    ) external onlyOwner {\\r\\n        treasuryReceiver = _treasuryReceiver;\\r\\n        insuranceReceiver = _insuranceReceiver;\\r\\n        infernoPit = _infernoPit;\\r\\n    }\\r\\n\\r\\n    function setRebaseAmount(uint256 rebaseAmount) external onlyOwner {\\r\\n        _rebaseAmount = rebaseAmount;\\r\\n    }\\r\\n\\r\\n    function setRewardCycle(uint256 _interval, uint256 _rewardPerCycle) external onlyOwner {\\r\\n        rewardCycleInterval = _interval;\\r\\n        rewardPerCycle = _rewardPerCycle;\\r\\n    }\\r\\n\\r\\n    function setFee(\\r\\n        uint256 _feeIndex,\\r\\n        uint256 _liquidityFee,\\r\\n        uint256 _treasuryFee,\\r\\n        uint256 _insuranceFee,\\r\\n        uint256 _infernoPitFee,\\r\\n        bool _feeEnabled\\r\\n    ) external onlyOwner {\\r\\n        feeEnabled = _feeEnabled;\\r\\n        liquidityFee[_feeIndex] = _liquidityFee;\\r\\n        treasuryFee[_feeIndex] = _treasuryFee;\\r\\n        insuranceFee[_feeIndex] = _insuranceFee;\\r\\n        infernoPitFee[_feeIndex] = _infernoPitFee;\\r\\n\\r\\n        uint256 totalFee = _liquidityFee.add(_treasuryFee).add(_insuranceFee).add(_infernoPitFee);\\r\\n        require(totalFee <= 250, \\\"Fee too high!\\\");\\r\\n    }\\r\\n\\r\\n    function setSellSettings(uint256 _sellPercentAllow, bool _sellLimitEnabled) external onlyOwner {\\r\\n        sellPercentAllow = _sellPercentAllow;\\r\\n        sellLimitEnabled = _sellLimitEnabled;\\r\\n        require(sellPercentAllow >= 300, \\\"sell limit too low\\\");\\r\\n    }\\r\\n\\r\\n    function setWhitelist(address _addr) external onlyOwner {\\r\\n        _isFeeExempt[_addr] = true;\\r\\n    }\\r\\n\\r\\n    function setBotBlacklist(address _botAddress, bool _flag) external onlyOwner {\\r\\n        require(isContract(_botAddress), \\\"only contract address, not allowed exteranlly owned account\\\");\\r\\n        blacklist[_botAddress] = _flag;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address who) public view override returns (uint256) {\\r\\n        return _gonBalances[who].div(_gonsPerFragment);\\r\\n    }\\r\\n\\r\\n    function isContract(address addr) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(addr)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_insuranceReceiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AddedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextClaim\",\"type\":\"uint256\"}],\"name\":\"RewardClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAddLiquidityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRebaseBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mintAmountBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rebaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"infernoPit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"infernoPitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"insuranceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNotInSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextAvailableClaimDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairContract\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardCycleInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPercentAllow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_botAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setBotBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_insuranceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_infernoPitFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_feeEnabled\",\"type\":\"bool\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_insuranceReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_infernoPit\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountBeforeSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"setLiquiditySetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rebaseAmount\",\"type\":\"uint256\"}],\"name\":\"setRebaseAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerCycle\",\"type\":\"uint256\"}],\"name\":\"setRewardCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellPercentAllow\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_sellLimitEnabled\",\"type\":\"bool\"}],\"name\":\"setSellSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapBack\",\"type\":\"bool\"}],\"name\":\"setSwapBackEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userSellCycleStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userSells\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ATLAS", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000bd5b0f685d5d01364edb9ea4ecacf9a16b11b66d0000000000000000000000009e791e83a61a44cbe6b5afcf531812adc61d5dbe00000000000000000000000004049bc063b92b026688ea9021aba5187d7a6d80", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}