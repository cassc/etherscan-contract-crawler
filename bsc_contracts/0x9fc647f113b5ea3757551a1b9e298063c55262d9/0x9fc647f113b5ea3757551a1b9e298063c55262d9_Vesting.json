{"SourceCode": "// File: Ownable.sol\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\ncontract OwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract Ownable is OwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev `owner` defaults to msg.sender on construction.\r\n     */\r\n    constructor() {\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n     *      Can only be invoked by the current `owner`.\r\n     * @param _newOwner Address of the new owner.\r\n     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.\r\n     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise\r\n     */\r\n    function transferOwnership(\r\n        address _newOwner,\r\n        bool _direct,\r\n        bool _renounce\r\n    ) external onlyOwner {\r\n        if (_direct) {\r\n            require(_newOwner != address(0) || _renounce, \"zero address\");\r\n\r\n            emit OwnershipTransferred(owner, _newOwner);\r\n            owner = _newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            pendingOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\r\n     */\r\n    function claimOwnership() external {\r\n        address _pendingOwner = pendingOwner;\r\n        require(msg.sender == _pendingOwner, \"caller != pending owner\");\r\n\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the Owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function _setOwner(address newOwner) internal {\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: Lockable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\ncontract LockableData {\r\n    bool public locked;\r\n}\r\n\r\ncontract Lockable is LockableData, Ownable {\r\n    /**\r\n     * @dev Locks functions with whenNotLocked modifier\r\n     */\r\n    function lock() external onlyOwner {\r\n        locked = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called when unlocked.\r\n     */\r\n    modifier whenLocked {\r\n        require(locked, \"Lockable: unlocked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called after it was locked.\r\n     */\r\n    modifier whenNotLocked {\r\n        require(!locked, \"Lockable: locked\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: IERC20.sol\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 amount) external returns (bool);\r\n\r\n    function burnFrom(address account, uint256 amount) external returns (bool);\r\n\r\n    // EIP 2612\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n// File: StableMath.sol\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n// Based on StableMath from mStable\r\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e36 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n// File: Vesting.sol\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title   Vesting\r\n * @notice  Vesting contract\r\n * @dev     Vesting is constantly releasing vested tokens every block every second\r\n */\r\ncontract Vesting is Ownable, Lockable {\r\n    using StableMath for uint256;\r\n\r\n    /// @notice address of vested token\r\n    address public token;\r\n    /// @notice total tokens vested in contract\r\n    uint256 public totalVested;\r\n    /// @notice total tokens already claimed form vesting\r\n    uint256 public totalClaimed;\r\n\r\n    struct Vest {\r\n        uint256 dateStart; // start of claiming, can claim startTokens\r\n        uint256 dateEnd; // after it all tokens can be claimed\r\n        uint256 totalTokens; // total tokens to claim\r\n        uint256 startTokens; // tokens to claim on start\r\n        uint256 claimedTokens; // tokens already claimed\r\n        uint256 cliffLength;\r\n    }\r\n    /// @notice storage of vestings\r\n    Vest[] internal vestings;\r\n    /// @notice map of vestings for user\r\n    mapping(address => uint256[]) internal user2vesting;\r\n\r\n    /// @dev events\r\n    event Claimed(address indexed user, uint256 amount);\r\n    event Vested(address indexed user, uint256 totalAmount, uint256 endDate);\r\n\r\n    /**\r\n     * @dev Contract initiator\r\n     * @param _token address of vested token\r\n     */\r\n    function init(address _token) external onlyOwner {\r\n        require(_token != address(0), \"_token address cannot be 0\");\r\n        require(token == address(0), \"init already done\");\r\n        token = _token;\r\n    }\r\n\r\n    /**\r\n     * @dev Add multiple vesting to contract by arrays of data\r\n     * @param _users[] addresses of holders\r\n     * @param _startTokens[] tokens that can be withdrawn at startDate\r\n     * @param _totalTokens[] total tokens in vesting\r\n     * @param _startDate date from when tokens can be claimed\r\n     * @param _cliff cliff length after TGE initial distribution\r\n     * @param _duration duration of the vesting after the cliff\r\n     */\r\n    function massAddHolders(\r\n        address[] calldata _users,\r\n        uint256[] calldata _startTokens,\r\n        uint256[] calldata _totalTokens,\r\n        uint256 _startDate,\r\n        uint256 _cliff,\r\n        uint256 _duration\r\n    ) external onlyOwner whenNotLocked {\r\n        uint256 len = _users.length; //cheaper to use one variable\r\n        require((len == _startTokens.length) && (len == _totalTokens.length), \"data size mismatch\");\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            _addHolder(_users[i], _startTokens[i], _totalTokens[i], _startDate, _cliff, _duration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add new vesting to contract\r\n     * @param _user address of a holder\r\n     * @param _startTokens how many tokens are claimable at start date\r\n     * @param _totalTokens total number of tokens in added vesting\r\n     * @param _startDate date from when tokens can be claimed\r\n     * @param _cliff cliff length after TGE initial distribution\r\n     * @param _duration duration of the vesting after the cliff\r\n     */\r\n    function _addHolder(\r\n        address _user,\r\n        uint256 _startTokens,\r\n        uint256 _totalTokens,\r\n        uint256 _startDate,\r\n        uint256 _cliff,\r\n        uint256 _duration\r\n    ) internal {\r\n        require(_user != address(0), \"user address cannot be 0\");\r\n        Vest memory v;\r\n        v.startTokens = _startTokens;\r\n        v.totalTokens = _totalTokens;\r\n        v.dateStart = _startDate;\r\n        v.cliffLength = _cliff;\r\n        v.dateEnd = _startDate + _cliff + _duration;\r\n\r\n        totalVested += _totalTokens;\r\n        vestings.push(v);\r\n        user2vesting[_user].push(vestings.length); // we are skipping index \"0\" for reasons\r\n        emit Vested(_user, v.totalTokens, v.dateEnd);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim tokens from msg.sender vestings\r\n     */\r\n    function claim() external {\r\n        _claim(msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim tokens from msg.sender vestings to external address\r\n     * @param _target transfer address for claimed tokens\r\n     */\r\n    function claimTo(address _target) external {\r\n        _claim(msg.sender, _target);\r\n    }\r\n\r\n    /**\r\n     * @dev internal claim function\r\n     * @param _user address of holder\r\n     * @param _target where tokens should be send\r\n     * @return amt number of tokens claimed\r\n     */\r\n    function _claim(address _user, address _target) internal returns (uint256 amt) {\r\n        require(_target != address(0), \"claim, then burn\");\r\n        uint256 len = user2vesting[_user].length;\r\n        require(len > 0, \"no vestings for user\");\r\n        uint256 cl;\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            Vest storage v = vestings[user2vesting[_user][i] - 1];\r\n            cl = _claimable(v);\r\n            v.claimedTokens += cl;\r\n            amt += cl;\r\n        }\r\n        if (amt > 0) {\r\n            totalClaimed += amt;\r\n            _transfer(_target, amt);\r\n            emit Claimed(_user, amt);\r\n        } else revert(\"nothing to claim\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to send out claimed tokens\r\n     * @param _user address that we send tokens\r\n     * @param _amt amount of tokens\r\n     */\r\n    function _transfer(address _user, uint256 _amt) internal {\r\n        require(IERC20(token).transfer(_user, _amt), \"token transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Count how many tokens can be claimed from vesting to date\r\n     * @param _vesting Vesting object\r\n     * @return canWithdraw number of tokens\r\n     */\r\n    function _claimable(Vest memory _vesting) internal view returns (uint256 canWithdraw) {\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 cliffTime = _vesting.dateStart + _vesting.cliffLength;\r\n\r\n        // not started\r\n        if (_vesting.dateStart > currentTime) return 0;\r\n\r\n        if (currentTime <= cliffTime) {\r\n            // we are after start but before cliff\r\n            canWithdraw = _vesting.startTokens;\r\n        } else if (currentTime > cliffTime && currentTime < _vesting.dateEnd) {\r\n            // we are somewhere in the middle\r\n\r\n            // how much time passed (as fraction * 10^18)\r\n            // timeRatio = (time passed * 1e18) / duration\r\n            uint256 timeRatio = (currentTime - cliffTime).divPrecisely(_vesting.dateEnd - cliffTime);\r\n            // how much tokens we can get in total to date\r\n            canWithdraw = (_vesting.totalTokens - _vesting.startTokens).mulTruncate(timeRatio) + _vesting.startTokens;\r\n        }\r\n        // time has passed, we can take all tokens\r\n        else {\r\n            canWithdraw = _vesting.totalTokens;\r\n        }\r\n        // but maybe we take something earlier?\r\n        canWithdraw -= _vesting.claimedTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Read number of claimable tokens by user and vesting no\r\n     * @param _user address of holder\r\n     * @param _id his vesting number (starts from 0)\r\n     * @return amount number of tokens\r\n     */\r\n    function getClaimable(address _user, uint256 _id) external view returns (uint256 amount) {\r\n        amount = _claimable(vestings[user2vesting[_user][_id] - 1]);\r\n    }\r\n\r\n    /**\r\n     * @dev Read total amount of tokens that user can claim to date from all vestings\r\n     *      Function also includes tokens to claim from sale contracts that were not\r\n     *      yet initiated for user.\r\n     * @param _user address of holder\r\n     * @return amount number of tokens\r\n     */\r\n    function getAllClaimable(address _user) public view returns (uint256 amount) {\r\n        uint256 len = user2vesting[_user].length;\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            amount += _claimable(vestings[user2vesting[_user][i] - 1]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Extract all the vestings for the user\r\n     *      Also extract not initialized vestings from\r\n     *      sale contracts.\r\n     * @param _user address of holder\r\n     * @return v array of Vest objects\r\n     */\r\n    function getVestings(address _user) external view returns (Vest[] memory) {\r\n        uint256 len = user2vesting[_user].length;\r\n        Vest[] memory v = new Vest[](len);\r\n\r\n        // copy vestings\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            v[i] = vestings[user2vesting[_user][i] - 1];\r\n        }\r\n\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * @dev Read total number of vestings registered\r\n     * @return number of registered vestings on contract\r\n     */\r\n    function getVestingsCount() external view returns (uint256) {\r\n        return vestings.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Read single registered vesting entry\r\n     * @param _id index of vesting in storage\r\n     * @return Vest object\r\n     */\r\n    function getVestingByIndex(uint256 _id) external view returns (Vest memory) {\r\n        return vestings[_id];\r\n    }\r\n\r\n    /**\r\n     * @dev Read registered vesting list by range from-to\r\n     * @param _start first index\r\n     * @param _end last index\r\n     * @return array of Vest objects\r\n     */\r\n    function getVestingsByRange(uint256 _start, uint256 _end) external view returns (Vest[] memory) {\r\n        uint256 cnt = _end - _start + 1;\r\n        uint256 len = vestings.length;\r\n        require(_end < len, \"range error\");\r\n        Vest[] memory v = new Vest[](cnt);\r\n        uint256 i;\r\n        for (i; i < cnt; i++) {\r\n            v[i] = vestings[_start + i];\r\n        }\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * @dev Recover ETH from contract to owner address.\r\n     */\r\n    function recoverETH() external {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Recover given ERC20 token from contract to owner address.\r\n     *      Can't recover vested tokens.\r\n     * @param _token address of ERC20 token to recover\r\n     */\r\n    function recoverErc20(address _token) external onlyOwner {\r\n        uint256 amt = IERC20(_token).balanceOf(address(this));\r\n        require(amt > 0, \"nothing to recover\");\r\n        IBadErc20(_token).transfer(owner, amt);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IBadErc20\r\n * @dev Interface for emergency recover any ERC20-tokens,\r\n *      even non-erc20-compliant like USDT not returning boolean\r\n */\r\ninterface IBadErc20 {\r\n    function transfer(address _recipient, uint256 _amount) external;\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getVestingByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting.Vest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getVestings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getVestingsByRange\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_totalTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"massAddHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vesting", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://61d4c1b39f96bdd8b6f35651348b76c2e4f62b853703a57ab6119a66539cf504"}