{"SourceCode": "/* *******************************************************************************************************************************************************************************\n *\n * Powered By t.me/BlazeXDeployerBot - This Contract is safe has no hidden malfunctions - Create your own Contract via telegram with blazex.org\n *\n * Disclaimer: The @BlazeXDeployerBot tool assists users in contract deployment. Tokens or contracts initiated through this bot are solely under the user's responsibility and are * not linked to, endorsed by, or associated with the BlazeX Team. Users are urged to approach with caution and comprehend the outcomes of their deployments. The contract has been * reviewed and audited.\n * TG BOT: t.me/BlazeXdeployerBot\n *********************************************************************************************************************************************************************************\n */\n\n\n  /*\n * \n  *\n  *\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n  *\n  * Description: N/A\n  * Website: N/A\n  * Twitter: N/A\n  * Telegram: N/A\n  *\n  *\u2014\u2014\u2014\u2014\u2014\n  */\n  \n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(\n        address payable recipient,\n        uint256 amount\n    ) internal returns (bool) {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        return success;\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\n            data\n        );\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint);\n\n    function permit(\n        address owner,\n        address spender,\n        uint value,\n        uint deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Burn(\n        address indexed sender,\n        uint amount0,\n        uint amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint);\n\n    function price1CumulativeLast() external view returns (uint);\n\n    function kLast() external view returns (uint);\n\n    function burn(address to) external returns (uint amount0, uint amount1);\n\n    function swap(\n        uint amount0Out,\n        uint amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountOut);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn);\n\n    function getAmountsOut(\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract CustomToken is Context, IERC20, Ownable {\n    using Address for address;\n    using Address for address payable;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(address => bool) private _isExcludedFromFees;\n    mapping(address => bool) private _isExcluded;\n    address[] private _excluded;\n\n    string private _name=\"PHOENIX\";\n    string private _symbol=\"PHNX\";\n    uint8 private _decimals=18;\n\n    uint256 private constant MAX = type(uint256).max;\n    uint256 private _tTotal = 100000000000000000000000000000;\n    uint256 private _tTotalSupply = 100000000000000000000000000000;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    uint public ReflectionFeeonBuy=20;\n    uint public ReflectionFeeonSell=20;\n\n    uint public liquidityFeeonBuy=20;\n    uint public liquidityFeeonSell=20;\n\n    uint public marketingFeeonBuy=60;\n    uint public marketingFeeonSell=60;\n\n    uint public burnFeeOnBuy=0;\n    uint public burnFeeOnSell=0;\n\n    uint private _ReflectionFee;\n    uint private _liquidityFee;\n    uint private _marketingFee;\n\n    uint256 private totalBuyFees;\n    uint256 private totalSellFees;\n\n    address public marketingWallet=0x98297AE87a35eCC067B109Afe70956567EBDC1e3;\n\n    address public referralWallet;\n    uint256 public serviceFee;\n    uint256 public referralCommission;\n\n    uint256 public maxTransactionAmountBuy=3000000000000000000000000000;\n    uint256 public maxTransactionAmountSell=3000000000000000000000000000;\n\n    uint256 public maxWalletAmount=50000000000000000000000000000;\n\n    bool public walletToWalletTransferWithoutFee;\n\n    address private DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    IUniswapV2Router02 public uniswapV2Router;\n    address public uniswapV2Pair;\n\n    bool private inSwapAndLiquify;\n    bool public swapEnabled;\n    bool public tradingEnabled;\n    uint256 public swapTokensAtAmount=10000000000000000000000000;\n\n    address public lpPair;\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event MarketingWalletChanged(address marketingWallet);\n    event SwapEnabledUpdated(bool enabled);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 bnbReceived,\n        uint256 tokensIntoLiqudity\n    );\n    event SwapAndSendMarketing(uint256 tokensSwapped, uint256 bnbSend);\n    event SwapTokensAtAmountUpdated(uint256 amount);\n    event BuyFeesChanged(\n        uint256 ReflectionFee,\n        uint256 liquidityFee,\n        uint256 marketingFee\n    );\n    event SellFeesChanged(\n        uint256 ReflectionFee,\n        uint256 liquidityFee,\n        uint256 marketingFee\n    );\n    event WalletToWalletTransferWithoutFeeEnabled(bool enabled);\n\n    constructor() payable {\n        address router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\n    require(msg.value >= 0.3 ether, \"Insufficient value for fee receiver\");\n    \n    \n    serviceFee = 0.29999999999999999 ether;\n    payable(0x72460072CCC5DB06559dd6e970dFD2Cb06ee7876).transfer(serviceFee);\n    \n\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);\n\n        uniswapV2Router = _uniswapV2Router;\n\n        _approve(msg.sender, address(uniswapV2Router), MAX);\n        _approve(msg.sender, address(this), MAX);\n\n        totalBuyFees =\n            ReflectionFeeonBuy +\n            liquidityFeeonBuy +\n            marketingFeeonBuy +\n            burnFeeOnBuy;\n        totalSellFees =\n            ReflectionFeeonSell +\n            liquidityFeeonSell +\n            marketingFeeonSell +\n            burnFeeOnSell;\n\n        swapTokensAtAmount = _tTotal / 5000;\n\n        maxTransactionLimitEnabled = true;\n\n        _isExcludedFromMaxTxLimit[owner()] = true;\n        _isExcludedFromMaxTxLimit[address(0)] = true;\n        _isExcludedFromMaxTxLimit[address(this)] = true;\n        _isExcludedFromMaxTxLimit[marketingWallet] = true;\n        _isExcludedFromMaxTxLimit[DEAD] = true;\n\n        maxWalletLimitEnabled = true;\n\n        _isExcludedFromMaxWalletLimit[owner()] = true;\n        _isExcludedFromMaxWalletLimit[address(this)] = true;\n        _isExcludedFromMaxWalletLimit[address(0xdead)] = true;\n        _isExcludedFromMaxWalletLimit[marketingWallet] = true;\n\n        walletToWalletTransferWithoutFee = true;\n\n        _isExcludedFromFees[owner()] = true;\n        _isExcludedFromFees[address(0xdead)] = true;\n        _isExcludedFromFees[address(this)] = true;\n\n        _isExcluded[address(this)] = true;\n        _isExcluded[address(0xdead)] = true;\n        _isExcluded[address(uniswapV2Pair)] = true;\n\n        _rOwned[owner()] = _rTotal;\n        _tOwned[owner()] = _tTotal;\n\n        emit Transfer(address(0), owner(), _tTotal);\n    }\n\n    function createLPPairIfRequired() private {\n        IUniswapV2Factory factory = IUniswapV2Factory(\n            uniswapV2Router.factory()\n        );\n        address pair = factory.getPair(address(this), uniswapV2Router.WETH());\n        if (pair == address(0)) {\n            uniswapV2Pair = factory.createPair(\n                address(this),\n                uniswapV2Router.WETH()\n            );\n            lpPair = uniswapV2Pair;\n            _isExcluded[address(uniswapV2Pair)] = true;\n        } else {\n            if (uniswapV2Pair != pair) {\n                uniswapV2Pair = pair;\n                lpPair = uniswapV2Pair;\n                _isExcluded[address(uniswapV2Pair)] = true;\n            }\n        }\n    }\n\n    function setPair(address pair) public onlyOwner {\n        uniswapV2Pair = pair;\n        lpPair = uniswapV2Pair;\n        _isExcluded[address(uniswapV2Pair)] = true;\n    }\n\n    function addLiquidityETH(\n        uint256 _tokenAmount\n    ) public payable returns (bool) {\n        swapEnabled = false;\n        createLPPairIfRequired();\n        _transfer(msg.sender, address(this), _tokenAmount);\n        _approve(address(this), address(uniswapV2Router), MAX);\n        uniswapV2Router.addLiquidityETH{value: msg.value}(\n            address(this),\n            _tokenAmount,\n            0,\n            0,\n            address(msg.sender),\n            block.timestamp + 50\n        );\n        swapEnabled = true;\n        return true;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()] - amount\n        );\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender] - subtractedValue\n        );\n        return true;\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalReflectionDistributed() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(\n            !_isExcluded[sender],\n            \"Excluded addresses cannot call this function\"\n        );\n        (uint256 rAmount, , , , , , ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rTotal = _rTotal - rAmount;\n        _tFeeTotal = _tFeeTotal + tAmount;\n    }\n\n    function reflectionFromToken(\n        uint256 tAmount,\n        bool deductTransferFee\n    ) public view returns (uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount, , , , , , ) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (, uint256 rTransferAmount, , , , , ) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(\n        uint256 rAmount\n    ) public view returns (uint256) {\n        require(\n            rAmount <= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount / currentRate;\n    }\n\n    function excludeFromReward(address account) public onlyOwner {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if (_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) external onlyOwner {\n        require(_isExcluded[account], \"Account is already included\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    function claimStuckTokens(address token) external onlyOwner {\n        require(token != address(this), \"Owner cannot claim native tokens\");\n        if (token == address(0x0)) {\n            payable(msg.sender).sendValue(address(this).balance);\n            return;\n        }\n        IERC20 ERC20token = IERC20(token);\n        uint256 balance = ERC20token.balanceOf(address(this));\n        ERC20token.transfer(msg.sender, balance);\n    }\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal - rFee;\n        _tFeeTotal = _tFeeTotal + tFee;\n    }\n\n    function _getValues(\n        uint256 tAmount\n    )\n        private\n        view\n        returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        (\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity,\n            uint256 tMarketing\n        ) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\n            tAmount,\n            tFee,\n            tLiquidity,\n            tMarketing,\n            _getRate()\n        );\n        return (\n            rAmount,\n            rTransferAmount,\n            rFee,\n            tTransferAmount,\n            tFee,\n            tLiquidity,\n            tMarketing\n        );\n    }\n\n    function _getTValues(\n        uint256 tAmount\n    ) private view returns (uint256, uint256, uint256, uint256) {\n        uint256 tFee = calculateReflectionFee(tAmount);\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\n        uint256 tMarketing = calculateMarketingFee(tAmount);\n        uint256 tTransferAmount = tAmount - tFee - tLiquidity - tMarketing;\n        return (tTransferAmount, tFee, tLiquidity, tMarketing);\n    }\n\n    function _getRValues(\n        uint256 tAmount,\n        uint256 tFee,\n        uint256 tLiquidity,\n        uint256 tMarketing,\n        uint256 currentRate\n    ) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount * currentRate;\n        uint256 rFee = tFee * currentRate;\n        uint256 rLiquidity = tLiquidity * currentRate;\n        uint256 rMarketing = tMarketing * currentRate;\n        uint256 rTransferAmount = rAmount - rFee - rLiquidity - rMarketing;\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (\n                _rOwned[_excluded[i]] > rSupply ||\n                _tOwned[_excluded[i]] > tSupply\n            ) return (_rTotal, _tTotal);\n            rSupply = rSupply - _rOwned[_excluded[i]];\n            tSupply = tSupply - _tOwned[_excluded[i]];\n        }\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 liquidityAmount;\n        if (\n            liquidityFeeonBuy > 0 ||\n            liquidityFeeonSell > 0 ||\n            burnFeeOnBuy > 0 ||\n            burnFeeOnSell > 0\n        ) {\n            liquidityAmount =\n                (tLiquidity * (liquidityFeeonBuy + liquidityFeeonSell)) /\n                (liquidityFeeonBuy +\n                    liquidityFeeonSell +\n                    burnFeeOnBuy +\n                    burnFeeOnSell);\n        }\n        uint256 burnAmount = tLiquidity - liquidityAmount;\n\n        if (liquidityAmount > 0) {\n            uint256 currentRate = _getRate();\n            uint256 rLiquidity = liquidityAmount * currentRate;\n            _rOwned[address(this)] = _rOwned[address(this)] + rLiquidity;\n            if (_isExcluded[address(this)])\n                _tOwned[address(this)] =\n                    _tOwned[address(this)] +\n                    liquidityAmount;\n        }\n\n        if (burnAmount > 0) {\n            uint256 currentRate = _getRate();\n            uint256 rBurn = burnAmount * currentRate;\n            _rOwned[address(0xdead)] = _rOwned[address(0xdead)] + rBurn;\n            if (_isExcluded[address(0xdead)])\n                _tOwned[address(0xdead)] =\n                    _tOwned[address(0xdead)] +\n                    burnAmount;\n\n            _tTotalSupply -= burnAmount;\n        }\n    }\n\n    function _takeMarketing(uint256 tMarketing) private {\n        if (tMarketing > 0) {\n            uint256 currentRate = _getRate();\n            uint256 rMarketing = tMarketing * currentRate;\n            _rOwned[address(this)] = _rOwned[address(this)] + rMarketing;\n            if (_isExcluded[address(this)])\n                _tOwned[address(this)] = _tOwned[address(this)] + tMarketing;\n        }\n    }\n\n    function calculateReflectionFee(\n        uint256 _amount\n    ) private view returns (uint256) {\n        return (_amount * _ReflectionFee) / 1000;\n    }\n\n    function calculateLiquidityFee(\n        uint256 _amount\n    ) private view returns (uint256) {\n        return (_amount * _liquidityFee) / 1000;\n    }\n\n    function calculateMarketingFee(\n        uint256 _amount\n    ) private view returns (uint256) {\n        return (_amount * _marketingFee) / 1000;\n    }\n\n    function removeAllFee() private {\n        if (_ReflectionFee == 0 && _liquidityFee == 0 && _marketingFee == 0)\n            return;\n\n        _ReflectionFee = 0;\n        _marketingFee = 0;\n        _liquidityFee = 0;\n    }\n\n    function setBuyFee() private {\n        if (\n            _ReflectionFee == ReflectionFeeonBuy &&\n            _liquidityFee == (liquidityFeeonBuy + burnFeeOnBuy) &&\n            _marketingFee == marketingFeeonBuy\n        ) return;\n\n        _ReflectionFee = ReflectionFeeonBuy;\n        _marketingFee = marketingFeeonBuy;\n        _liquidityFee = liquidityFeeonBuy + burnFeeOnBuy;\n    }\n\n    function setSellFee() private {\n        if (\n            _ReflectionFee == ReflectionFeeonSell &&\n            _liquidityFee == (liquidityFeeonSell + burnFeeOnSell) &&\n            _marketingFee == marketingFeeonSell\n        ) return;\n\n        _ReflectionFee = ReflectionFeeonSell;\n        _marketingFee = marketingFeeonSell;\n        _liquidityFee = liquidityFeeonSell + burnFeeOnSell;\n    }\n\n    function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function enableTrading() external onlyOwner {\n        require(tradingEnabled == false, \"Trading is already enabled\");\n        tradingEnabled = true;\n    }\n\n    function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n            require(tradingEnabled, \"Trading is not enabled yet\");\n        }\n\n        if (maxTransactionLimitEnabled) {\n            if (\n                (from == uniswapV2Pair || to == uniswapV2Pair) &&\n                _isExcludedFromMaxTxLimit[from] == false &&\n                _isExcludedFromMaxTxLimit[to] == false\n            ) {\n                if (from == uniswapV2Pair) {\n                    require(\n                        amount <= maxTransactionAmountBuy,\n                        \"AntiWhale: Transfer amount exceeds the maxTransactionAmount\"\n                    );\n                } else {\n                    require(\n                        amount <= maxTransactionAmountSell,\n                        \"AntiWhale: Transfer amount exceeds the maxTransactionAmount\"\n                    );\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        bool overMinTokenBalance = contractTokenBalance >= swapTokensAtAmount;\n        if (\n            overMinTokenBalance &&\n            !inSwapAndLiquify &&\n            to == uniswapV2Pair &&\n            swapEnabled\n        ) {\n            inSwapAndLiquify = true;\n\n            uint256 marketingShare = marketingFeeonBuy + marketingFeeonSell;\n            uint256 liquidityShare = liquidityFeeonBuy + liquidityFeeonSell;\n\n            uint256 totalShare = marketingShare + liquidityShare;\n\n            if (totalShare > 0) {\n                if (liquidityShare > 0) {\n                    uint256 liquidityTokens = (contractTokenBalance *\n                        liquidityShare) / totalShare;\n                    swapAndLiquify(liquidityTokens);\n                }\n\n                if (marketingShare > 0) {\n                    uint256 marketingTokens = (contractTokenBalance *\n                        marketingShare) / totalShare;\n                    swapAndSendMarketing(marketingTokens);\n                }\n            }\n\n            inSwapAndLiquify = false;\n        }\n\n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from, to, amount);\n\n        if (maxWalletLimitEnabled) {\n            if (\n                !_isExcludedFromMaxWalletLimit[from] &&\n                !_isExcludedFromMaxWalletLimit[to] &&\n                to != uniswapV2Pair\n            ) {\n                uint256 balance = balanceOf(to);\n                require(\n                    balance + amount <= maxWalletAmount,\n                    \"MaxWallet: Recipient exceeds the maxWalletAmount\"\n                );\n            }\n        }\n    }\n\n    function swapAndLiquify(uint256 tokens) private {\n        uint256 half = tokens / 2;\n        uint256 otherHalf = tokens - half;\n\n        uint256 initialBalance = address(this).balance;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            half,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 newBalance = address(this).balance - initialBalance;\n\n        uniswapV2Router.addLiquidityETH{value: newBalance}(\n            address(this),\n            otherHalf,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            DEAD,\n            block.timestamp\n        );\n\n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }\n\n    function swapAndSendMarketing(uint256 tokenAmount) private {\n        uint256 initialBalance = address(this).balance;\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n\n        uint256 newBalance = address(this).balance - initialBalance;\n\n        payable(marketingWallet).sendValue(newBalance);\n\n        emit SwapAndSendMarketing(tokenAmount, newBalance);\n    }\n\n    function setSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\n        require(\n            newAmount > totalSupply() / 1e5,\n            \"SwapTokensAtAmount must be greater than 0.001% of total supply\"\n        );\n        swapTokensAtAmount = newAmount;\n        emit SwapTokensAtAmountUpdated(newAmount);\n    }\n\n    function setSwapEnabled(bool _enabled) external onlyOwner {\n        swapEnabled = _enabled;\n        emit SwapEnabledUpdated(_enabled);\n    }\n\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]) {\n            removeAllFee();\n        } else if (recipient == uniswapV2Pair) {\n            setSellFee();\n        } else if (sender == uniswapV2Pair) {\n            setBuyFee();\n        } else if (walletToWalletTransferWithoutFee) {\n            removeAllFee();\n        } else {\n            setSellFee();\n        }\n\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity,\n            uint256 tMarketing\n        ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity,\n            uint256 tMarketing\n        ) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity,\n            uint256 tMarketing\n        ) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender] - tAmount;\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferBothExcluded(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rFee,\n            uint256 tTransferAmount,\n            uint256 tFee,\n            uint256 tLiquidity,\n            uint256 tMarketing\n        ) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender] - tAmount;\n        _rOwned[sender] = _rOwned[sender] - rAmount;\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\n        _takeMarketing(tMarketing);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function excludeFromFees(\n        address account,\n        bool excluded\n    ) external onlyOwner {\n        require(\n            _isExcludedFromFees[account] != excluded,\n            \"Account is already the value of 'excluded'\"\n        );\n        _isExcludedFromFees[account] = excluded;\n\n        emit ExcludeFromFees(account, excluded);\n    }\n\n    function changeMarketingWallet(\n        address _marketingWallet\n    ) external onlyOwner {\n        require(\n            _marketingWallet != marketingWallet,\n            \"Marketing wallet is already that address\"\n        );\n        require(\n            _marketingWallet != address(0),\n            \"Marketing wallet is the zero address\"\n        );\n        marketingWallet = _marketingWallet;\n        emit MarketingWalletChanged(marketingWallet);\n    }\n\n    function setBuyFeePercentages(\n        uint _ReflectionFeeonBuy,\n        uint _liquidityFeeonBuy,\n        uint _marketingFeeonBuy,\n        uint _burnFeeOnBuy\n    ) external onlyOwner {\n        ReflectionFeeonBuy = _ReflectionFeeonBuy;\n        liquidityFeeonBuy = _liquidityFeeonBuy;\n        marketingFeeonBuy = _marketingFeeonBuy;\n        burnFeeOnBuy = _burnFeeOnBuy;\n\n        totalBuyFees =\n            ReflectionFeeonBuy +\n            liquidityFeeonBuy +\n            marketingFeeonBuy +\n            burnFeeOnBuy;\n\n        require(totalBuyFees <= 300, \"Buy fees cannot be greater than 30%\");\n\n        emit BuyFeesChanged(\n            ReflectionFeeonBuy,\n            liquidityFeeonBuy,\n            marketingFeeonBuy\n        );\n    }\n\n    function setSellFeePercentages(\n        uint _ReflectionFeeonSell,\n        uint _liquidityFeeonSell,\n        uint _marketingFeeonSell,\n        uint _burnFeeOnSell\n    ) external onlyOwner {\n        ReflectionFeeonSell = _ReflectionFeeonSell;\n        liquidityFeeonSell = _liquidityFeeonSell;\n        marketingFeeonSell = _marketingFeeonSell;\n        burnFeeOnSell = _burnFeeOnSell;\n\n        totalSellFees =\n            ReflectionFeeonSell +\n            liquidityFeeonSell +\n            marketingFeeonSell +\n            burnFeeOnSell;\n\n        require(totalSellFees <= 300, \"Sell fees cannot be greater than 30%\");\n\n        emit SellFeesChanged(\n            ReflectionFeeonSell,\n            liquidityFeeonSell,\n            marketingFeeonSell\n        );\n    }\n\n    function enableWalletToWalletTransferWithoutFee(\n        bool enable\n    ) external onlyOwner {\n        require(\n            walletToWalletTransferWithoutFee != enable,\n            \"Wallet to wallet transfer without fee is already set to that value\"\n        );\n        walletToWalletTransferWithoutFee = enable;\n        emit WalletToWalletTransferWithoutFeeEnabled(enable);\n    }\n\n    mapping(address => bool) private _isExcludedFromMaxTxLimit;\n    bool public maxTransactionLimitEnabled;\n\n    event ExcludedFromMaxTransactionLimit(\n        address indexed account,\n        bool isExcluded\n    );\n    event MaxTransactionLimitStateChanged(bool maxTransactionLimit);\n    event MaxTransactionLimitAmountChanged(\n        uint256 maxTransactionAmountBuy,\n        uint256 maxTransactionAmountSell\n    );\n\n    function setEnableMaxTransactionLimit(bool enable) external onlyOwner {\n        require(\n            enable != maxTransactionLimitEnabled,\n            \"Max transaction limit is already set to that state\"\n        );\n        maxTransactionLimitEnabled = enable;\n        emit MaxTransactionLimitStateChanged(maxTransactionLimitEnabled);\n    }\n\n    function setMaxTransactionAmounts(\n        uint256 _maxTransactionAmountBuy,\n        uint256 _maxTransactionAmountSell\n    ) external onlyOwner {\n        require(\n            _maxTransactionAmountBuy >= totalSupply() / 1000 &&\n                _maxTransactionAmountSell >= totalSupply() / 1000,\n            \"Max Transaction limis cannot be lower than 0.1% of total supply\"\n        );\n        maxTransactionAmountBuy = _maxTransactionAmountBuy;\n        maxTransactionAmountSell = _maxTransactionAmountSell;\n        emit MaxTransactionLimitAmountChanged(\n            maxTransactionAmountBuy,\n            maxTransactionAmountSell\n        );\n    }\n\n    function setExcludeFromMaxTransactionLimit(\n        address account,\n        bool exclude\n    ) external onlyOwner {\n        require(\n            _isExcludedFromMaxTxLimit[account] != exclude,\n            \"Account is already set to that state\"\n        );\n        _isExcludedFromMaxTxLimit[account] = exclude;\n        emit ExcludedFromMaxTransactionLimit(account, exclude);\n    }\n\n    function isExcludedFromMaxTransaction(\n        address account\n    ) public view returns (bool) {\n        return _isExcludedFromMaxTxLimit[account];\n    }\n\n    mapping(address => bool) private _isExcludedFromMaxWalletLimit;\n    bool public maxWalletLimitEnabled;\n\n    event ExcludedFromMaxWalletLimit(address indexed account, bool isExcluded);\n    event MaxWalletLimitStateChanged(bool maxWalletLimit);\n    event MaxWalletLimitAmountChanged(uint256 maxWalletAmount);\n\n    function setEnableMaxWalletLimit(bool enable) external onlyOwner {\n        require(\n            enable != maxWalletLimitEnabled,\n            \"Max wallet limit is already set to that state\"\n        );\n        maxWalletLimitEnabled = enable;\n\n        emit MaxWalletLimitStateChanged(maxWalletLimitEnabled);\n    }\n\n    function setMaxWalletAmount(uint256 _maxWalletAmount) external onlyOwner {\n        require(\n            _maxWalletAmount >= totalSupply() / 1000,\n            \"Max wallet percentage cannot be lower than 0.1%\"\n        );\n        maxWalletAmount = _maxWalletAmount;\n\n        emit MaxWalletLimitAmountChanged(maxWalletAmount);\n    }\n\n    function excludeFromMaxWallet(\n        address account,\n        bool exclude\n    ) external onlyOwner {\n        require(\n            _isExcludedFromMaxWalletLimit[account] != exclude,\n            \"Account is already set to that state\"\n        );\n        require(account != address(this), \"Can't set this address.\");\n\n        _isExcludedFromMaxWalletLimit[account] = exclude;\n\n        emit ExcludedFromMaxWalletLimit(account, exclude);\n    }\n\n    function isExcludedFromMaxWalletLimit(\n        address account\n    ) public view returns (bool) {\n        return _isExcludedFromMaxWalletLimit[account];\n    }\n\n    function contractTypeBlazex() external pure returns (uint) {\n        return 2;\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReflectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"}],\"name\":\"BuyFeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromMaxTransactionLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromMaxWalletLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketingWallet\",\"type\":\"address\"}],\"name\":\"MarketingWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransactionAmountBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransactionAmountSell\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionLimitAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"maxTransactionLimit\",\"type\":\"bool\"}],\"name\":\"MaxTransactionLimitStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWalletAmount\",\"type\":\"uint256\"}],\"name\":\"MaxWalletLimitAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"maxWalletLimit\",\"type\":\"bool\"}],\"name\":\"MaxWalletLimitStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ReflectionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"}],\"name\":\"SellFeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbSend\",\"type\":\"uint256\"}],\"name\":\"SwapAndSendMarketing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapTokensAtAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"WalletToWalletTransferWithoutFeeEnabled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ReflectionFeeonBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReflectionFeeonSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"}],\"name\":\"changeMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractTypeBlazex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableWalletToWalletTransferWithoutFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxWalletLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeonBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeonSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeonBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeonSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmountBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmountSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ReflectionFeeonBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeonBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeonBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFeeOnBuy\",\"type\":\"uint256\"}],\"name\":\"setBuyFeePercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setEnableMaxTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setEnableMaxWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"setExcludeFromMaxTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTransactionAmountBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransactionAmountSell\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWalletAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ReflectionFeeonSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeonSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeonSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFeeOnSell\",\"type\":\"uint256\"}],\"name\":\"setSellFeePercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReflectionDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletToWalletTransferWithoutFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CustomToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}