{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: StakeGfamV2.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract StakeGfam is Ownable, Pausable {\r\n    mapping(address => bool) private allowedContracts;\r\n\r\n    IERC20 public gfamToken;\r\n    IERC20 public stableToken;\r\n    ITokenTrade public tokenTrade;\r\n\r\n    uint public rewardRate;\r\n    uint public commissionRate;\r\n    uint public earningDate;\r\n    uint public earningDay;\r\n    uint public offset;\r\n    uint public minDaysStake;\r\n\r\n    uint public stakedTokensAT; //TOTAL FROM START\r\n    uint public stakedTokens;\r\n    uint public stakedTokensRef;\r\n    uint public totaRequestedStableToken; //TOTAL FROM START\r\n    uint public requestedStableTokenNet; //Net\r\n\r\n    uint public rewardDistributionBalancePool; //NET\r\n    uint public ReferralClaimsBalance;\r\n\r\n    mapping(address => Stake[]) public stakes;\r\n    mapping(uint => dayDataStake) public dailyData;\r\n    uint[] public earningDays;\r\n    mapping(uint => uint) public rewardsBalancePerDay;\r\n    mapping(uint => uint) public cumulativeRewardsBalancePerDay;\r\n    mapping(address => uint) public stakesPerUser;\r\n\r\n    mapping(address => address) public referrals;\r\n    mapping(address => uint) public referralClaims;\r\n    int public currentStakes = 0;\r\n    uint public stakesAT = 0;\r\n    int public currentStakesRef = 0;\r\n    uint public stakesRefAT = 0;\r\n    bool public allowRef;\r\n    uint public imported;\r\n\r\n    constructor() {\r\n        gfamToken = IERC20(0x772b609D3A8F2Ebe1c1b8F87EBda2e462eC475F8);\r\n        stableToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n        tokenTrade = ITokenTrade(0x103E68d616e921a36161f119EaAD04F9b32dA173);\r\n        rewardRate = 25;\r\n        commissionRate = 10;\r\n        allowRef = true;\r\n        offset = 1;\r\n        minDaysStake = 90;\r\n        // __addToRewardPool(0);\r\n    }\r\n\r\n    struct dayDataStake {\r\n        uint tkns;\r\n        uint goals;\r\n        uint refTkns;\r\n        uint nbr;\r\n        uint refNbr;\r\n        uint reward;\r\n    }\r\n    struct Stake {\r\n        uint initTokenAmount;\r\n        uint initTokenPrice;\r\n        uint stakeValue;\r\n        uint rewardGoal;\r\n        uint startDate;\r\n        uint startDay;\r\n        uint dayIndex;\r\n        uint lastClaimDate;\r\n        uint lastClaimDay;\r\n        uint rewardClaimed;\r\n        bool isCom;\r\n        bool ended;\r\n    }\r\n    struct TokensData {\r\n        uint stakedTokens;\r\n        uint rewardDistributionBalancePool;\r\n        uint requestedStableTokenNet;\r\n        uint totaRequestedStableToken;\r\n        uint ReferralClaimsBalance;\r\n        uint rewardRate;\r\n        uint commissionRate;\r\n        uint minDaysStake;\r\n        int totalStakes;\r\n        uint stakesAT;\r\n        uint stakesRefAT;\r\n        int currentStakesRef;\r\n    }\r\n    event stakeEvent(address _user, uint _amount, uint _gfamValue);\r\n    event claimEvent(address _user, uint _amount, uint _goal);\r\n    event restakeEvent(address _user, uint _amount, uint _gfamValue);\r\n    event stakeReferralComEvent(address _user, uint _amount, uint _gfamValue);\r\n\r\n    //STAKE\r\n    function stake(\r\n        address _user,\r\n        uint _amount,\r\n        address _referral\r\n    ) external whenNotPaused {\r\n        if (\r\n            referrals[_user] == address(0) &&\r\n            _referral != _user &&\r\n            _referral != address(0)\r\n        ) {\r\n            referrals[_user] = _referral;\r\n        }\r\n        if (referrals[_user] != address(0) && allowRef) {\r\n            referralClaims[referrals[_user]] +=\r\n                (_amount * commissionRate) /\r\n                100;\r\n            ReferralClaimsBalance += (_amount * commissionRate) / 100;\r\n        }\r\n        __stake(_user, _amount, false, block.timestamp);\r\n        gfamToken.transferFrom(_user, address(this), _amount);\r\n        emit stakeEvent(_user, _amount, getPrice(_amount));\r\n    }\r\n\r\n    function stakeReferralCom() external whenNotPaused {\r\n        uint _amount = referralClaims[msg.sender];\r\n        require(_amount > 0, \"Nothing to claim\");\r\n        __stake(msg.sender, _amount, true, block.timestamp);\r\n        emit stakeReferralComEvent(\r\n            msg.sender,\r\n            referralClaims[msg.sender],\r\n            (_amount * getPrice(_amount)) / 1e18\r\n        );\r\n        referralClaims[msg.sender] = 0;\r\n        ReferralClaimsBalance -= _amount;\r\n    }\r\n\r\n    function restake(uint _stakeIndex) external whenNotPaused {\r\n        Stake storage _stake = stakes[msg.sender][_stakeIndex];\r\n        require(_stake.ended, \"Stake still active\");\r\n        require(_stake.isCom == false, \"Only non commission stakes accepted\");\r\n        __stake(msg.sender, _stake.initTokenAmount, false, block.timestamp);\r\n        _removeStake(msg.sender, _stakeIndex, _stake.isCom, true);\r\n    }\r\n\r\n    function unstake(uint _stakeIndex) external whenNotPaused {\r\n        Stake storage _stake = stakes[msg.sender][_stakeIndex];\r\n        require(\r\n            minDaysStake >=\r\n                (_stake.startDate / 1 days) - (block.timestamp / 1 days),\r\n            \"Min Days of stake not reached yet\"\r\n        );\r\n        require(_stake.isCom == false, \"Commission stakes can not be unstaked\");\r\n        _claim(msg.sender, _stakeIndex);\r\n        _removeStake(msg.sender, _stakeIndex, _stake.isCom, false);\r\n    }\r\n\r\n    function claim(uint256 _stakeIndex) external whenNotPaused {\r\n        require(_stakeIndex < stakes[msg.sender].length, \"Invalid stake index\");\r\n        _claim(msg.sender, _stakeIndex);\r\n    }\r\n\r\n    function __stake(\r\n        address _user,\r\n        uint256 _amountToken,\r\n        bool _isCom,\r\n        uint date\r\n    ) internal returns (Stake memory) {\r\n        uint gfamValue = getPrice(_amountToken);\r\n        uint stakeValue = (_amountToken * gfamValue) / 1e18;\r\n        uint goal = (stakeValue * rewardRate) / 100;\r\n        uint _date = date;\r\n        uint _day = date / 1 days;\r\n        uint dayIndex = dailyData[_day].nbr + dailyData[_day].refNbr + 1;\r\n        Stake memory newStake = Stake({\r\n            initTokenAmount: _amountToken,\r\n            initTokenPrice: gfamValue,\r\n            stakeValue: stakeValue,\r\n            rewardGoal: goal,\r\n            startDate: _date,\r\n            startDay: _day,\r\n            dayIndex: dayIndex,\r\n            lastClaimDate: 0,\r\n            lastClaimDay: 0,\r\n            rewardClaimed: 0,\r\n            isCom: _isCom,\r\n            ended: false\r\n        });\r\n        stakes[_user].push(newStake);\r\n        stakesPerUser[_user]++;\r\n        totaRequestedStableToken += goal;\r\n        requestedStableTokenNet += goal;\r\n        if (_isCom) {\r\n            stakesRefAT++;\r\n            currentStakesRef++;\r\n            stakedTokensRef += _amountToken;\r\n            dailyData[_day].refTkns += _amountToken;\r\n            dailyData[_day].goals += goal;\r\n            dailyData[_day].refNbr++;\r\n        } else {\r\n            stakedTokens += _amountToken;\r\n            currentStakes++;\r\n            stakesAT++;\r\n            stakedTokensAT += _amountToken;\r\n            dailyData[_day].tkns += _amountToken;\r\n            dailyData[_day].goals += goal;\r\n            dailyData[_day].nbr++;\r\n        }\r\n        return newStake;\r\n    }\r\n\r\n    function _removeStake(\r\n        address _user,\r\n        uint _stakeIndex,\r\n        bool isCom,\r\n        bool _restake\r\n    ) internal {\r\n        if (stakesPerUser[_user] > 0) stakesPerUser[_user] -= 1;\r\n        if (isCom) {\r\n            currentStakesRef -= 1;\r\n            stakedTokensRef -= stakes[_user][_stakeIndex].initTokenAmount;\r\n        } else {\r\n            currentStakes -= 1;\r\n            stakedTokens -= stakes[_user][_stakeIndex].initTokenAmount;\r\n            if (_restake == false) {\r\n                gfamToken.transfer(\r\n                    _user,\r\n                    stakes[_user][_stakeIndex].initTokenAmount\r\n                );\r\n            }\r\n        }\r\n        requestedStableTokenNet -= (stakes[_user][_stakeIndex].rewardGoal -\r\n            stakes[_user][_stakeIndex].rewardClaimed);\r\n        totaRequestedStableToken -= (stakes[_user][_stakeIndex].rewardGoal -\r\n            stakes[_user][_stakeIndex].rewardClaimed);\r\n        removeItemFromArray(stakes[_user], _stakeIndex);\r\n    }\r\n    function getStakeRewardPercentGlobal(\r\n        address _user,\r\n        uint _stakeIndex\r\n    ) public view returns (uint) {\r\n        if(earningDays.length == 0 || stakes[_user].length == 0){return 0;}\r\n        Stake storage _stake = stakes[_user][_stakeIndex];\r\n        uint earningPoolFromStake = 0;\r\n        if(earningDays.length == 0){\r\n            return 0;\r\n        }\r\n        for (uint256 i = earningDays.length - 1; i >= 0; i--) {\r\n            if (_stake.startDay >= earningDays[i] + offset) {\r\n                break;\r\n            }\r\n            earningPoolFromStake += cumulativeRewardsBalancePerDay[\r\n                earningDays[i]\r\n            ];\r\n        }\r\n        uint res;\r\n        if(rewardDistributionBalancePool <= 0 || earningPoolFromStake>rewardDistributionBalancePool){\r\n            res = 0;\r\n        }else{\r\n            res = (earningPoolFromStake * 1e18) / rewardDistributionBalancePool;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    //\r\n    function _claim(address _user, uint _stakeIndex) internal {\r\n        Stake storage _stake = stakes[_user][_stakeIndex];\r\n        uint totalReward = (requestedStableTokenNet *\r\n            getStakeRewardPercentGlobal(_user, _stakeIndex)) / 1e18;\r\n        bool overflow = totalReward >= _stake.rewardGoal;\r\n        uint reward;\r\n        uint netReward;\r\n        bool ended = false;\r\n        if (overflow) {\r\n            ended = true;\r\n            reward = _stake.rewardGoal;\r\n        } else {\r\n            reward = _stake.rewardGoal - totalReward;\r\n        }\r\n        netReward = _stake.rewardGoal - _stake.rewardClaimed;\r\n        _stake.lastClaimDate = block.timestamp;\r\n        _stake.lastClaimDay = block.timestamp / 1 days;\r\n        _stake.rewardClaimed += netReward;\r\n        _stake.ended = ended;\r\n        //GLOBAL\r\n        requestedStableTokenNet -= netReward;\r\n        //TRANSFER\r\n        require(\r\n            stableToken.balanceOf(address(this)) >= netReward,\r\n            \"Not enough stable token\"\r\n        );\r\n        stableToken.transfer(_user, netReward);\r\n        if (_stake.isCom && ended) {\r\n            _removeStake(_user, _stakeIndex, _stake.isCom, false);\r\n        }\r\n    }\r\n\r\n    function getPrice(uint _amount) public view returns (uint) {\r\n        return tokenTrade.getPrice(_amount);\r\n    }\r\n\r\n    function removeItemFromArray(\r\n        Stake[] storage array,\r\n        uint256 index\r\n    ) internal {\r\n        require(index < array.length, \"Invalid index\");\r\n        if (index < array.length - 1) {\r\n            array[index] = array[array.length - 1];\r\n        }\r\n        array.pop();\r\n    }\r\n\r\n    function getTokensData() public view returns (TokensData memory) {\r\n        return\r\n            TokensData(\r\n                stakedTokens,\r\n                rewardDistributionBalancePool,\r\n                requestedStableTokenNet,\r\n                totaRequestedStableToken,\r\n                ReferralClaimsBalance,\r\n                rewardRate,\r\n                commissionRate,\r\n                minDaysStake,\r\n                currentStakes,\r\n                stakesAT,\r\n                stakesRefAT,\r\n                currentStakesRef\r\n            );\r\n    }\r\n\r\n    //\r\n    function getUserStakes(address _user) public view returns (Stake[] memory) {\r\n        return stakes[_user];\r\n    }\r\n\r\n    function getCurrentDay() public view returns (uint) {\r\n        return block.timestamp / 1 days;\r\n    }\r\n\r\n    function addEarningDay(uint _day) internal {\r\n        if(earningDays.length == 0){\r\n            earningDays.push(_day);\r\n        }\r\n        else if (_day > earningDays[earningDays.length - 1]) {\r\n            earningDays.push(_day);\r\n        }\r\n    }\r\n\r\n    function getEarningDays() public view returns (uint[] memory) {\r\n        return earningDays;\r\n    }\r\n\r\n    function getEarningDaysNbr() public view returns (uint) {\r\n        return earningDays.length;\r\n    }\r\n\r\n    function removeDayEarned(uint _index) public onlyOwner {\r\n        require(_index < earningDays.length, \"Index out of bounds\");\r\n        uint old = rewardsBalancePerDay[earningDays[_index]];\r\n\r\n        cumulativeRewardsBalancePerDay[earningDays[_index]] = 0;\r\n        cumulativeRewardsBalancePerDay[earningDays[_index]+1] += old;\r\n\r\n        dailyData[earningDays[_index]].reward =0;\r\n        dailyData[earningDays[_index+1]].reward += old;\r\n\r\n        rewardsBalancePerDay[earningDays[_index]] = 0;\r\n\r\n        for (uint i = _index; i < earningDays.length - 1; i++) {\r\n            earningDays[i] = earningDays[i + 1];\r\n        }\r\n        earningDays.pop();\r\n    }\r\n\r\n    //IMPORT\r\n\r\n    struct imp_stake {\r\n        address _user;\r\n        address _referral;\r\n        uint _value;\r\n        uint _date;\r\n        bool _isRefClaim;\r\n    }\r\n\r\n    function adm_imp_action(imp_stake[] calldata _items) external onlyOwner {\r\n        for (uint i = 0; i < _items.length; i++) {\r\n            address _user = _items[i]._user;\r\n            address _referral = _items[i]._referral;\r\n            uint _amount = _items[i]._value;\r\n            uint _date = _items[i]._date;\r\n            bool _isRefClaim = _items[i]._isRefClaim;\r\n            if (_isRefClaim) {\r\n                _amount = referralClaims[_user];\r\n                require(_amount > 0, \"Nothing to claim\");\r\n                __stake(_user, _amount, true, _date);\r\n                emit stakeReferralComEvent(\r\n                    _user,\r\n                    referralClaims[_user],\r\n                    (_amount * getPrice(_amount)) / 1e18\r\n                );\r\n                referralClaims[_user] = 0;\r\n                ReferralClaimsBalance -= _amount;\r\n            } else {\r\n                if (\r\n                    referrals[_user] == address(0) &&\r\n                    _referral != _user &&\r\n                    _referral != address(0)\r\n                ) {\r\n                    referrals[_user] = _referral;\r\n                }\r\n                if (referrals[_user] != address(0) && allowRef) {\r\n                    referralClaims[referrals[_user]] +=\r\n                        (_amount * commissionRate) /\r\n                        100;\r\n                    ReferralClaimsBalance += (_amount * commissionRate) / 100;\r\n                }\r\n                __stake(_user, _amount, false, _date);\r\n                emit stakeEvent(_user, _amount, getPrice(_amount));\r\n            }\r\n        }\r\n        imported += _items.length;\r\n    }\r\n\r\n    //ADMIN\r\n\r\n    function setTokenTradeContract(address _addr) external onlyOwner {\r\n        tokenTrade = ITokenTrade(_addr);\r\n    }\r\n\r\n    function setRewardRate(uint _value) external onlyOwner {\r\n        rewardRate = _value;\r\n    }\r\n\r\n    function setCommissionRate(uint _value) external onlyOwner {\r\n        commissionRate = _value;\r\n    }\r\n\r\n    function setReferral(address _user, address _ref) external onlyOwner {\r\n        referrals[_user] = _ref;\r\n    }\r\n\r\n    function setAllowRef(bool _value) external onlyOwner {\r\n        allowRef = _value;\r\n    }\r\n\r\n    function setUserRef(address _user, address _ref) external onlyOwner {\r\n        referrals[_user] = _ref;\r\n    }\r\n\r\n    function setOffset(uint _value) external onlyOwner {\r\n        offset = _value;\r\n    }\r\n\r\n    function setMinDaysStake(uint _value) external onlyOwner {\r\n        minDaysStake = _value;\r\n    }\r\n\r\n    function addToRewardPool(uint _value) external onlyOwner {\r\n        __addToRewardPool(block.timestamp / 1 days,_value);\r\n    }\r\n\r\n    function autoAddToRewardPool(uint _value) external onlyAllowedContract {\r\n        __addToRewardPool(block.timestamp / 1 days,_value);\r\n    }\r\n\r\n    function __addToRewardPool(uint _day, uint _value) internal {\r\n        rewardDistributionBalancePool += _value;\r\n        earningDate = _day*1 days;\r\n        earningDay = _day;\r\n        rewardsBalancePerDay[earningDay] +=_value;\r\n        cumulativeRewardsBalancePerDay[earningDay] =\r\n            rewardDistributionBalancePool +\r\n            _value;\r\n        addEarningDay(block.timestamp / 1 days);\r\n        dailyData[earningDay].reward += _value;\r\n    }\r\n\r\n    function substractFromRewardPool(uint _value) external onlyOwner {\r\n        requestedStableTokenNet -= _value;\r\n    }\r\n\r\n    function busdBalance() public view returns (uint) {\r\n        return stableToken.balanceOf(address(this));\r\n    }\r\n\r\n    function stableTokenBalance() public view returns (uint) {\r\n        return gfamToken.balanceOf(address(this));\r\n    }\r\n\r\n    function withdrawGfam(uint _amount) public onlyOwner {\r\n        gfamToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    function withdrawStableToken(uint _amount) public onlyOwner {\r\n        stableToken.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    function withdrawAllGfam() public onlyOwner {\r\n        gfamToken.transfer(msg.sender, stableTokenBalance());\r\n    }\r\n\r\n    function withdrawAllStableToken() public onlyOwner {\r\n        stableToken.transfer(msg.sender, busdBalance());\r\n    }\r\n\r\n    //ALLOW\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    modifier onlyAllowedContract() {\r\n        require(allowedContracts[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    function allowContract(address _addr) public onlyOwner {\r\n        allowedContracts[_addr] = true;\r\n    }\r\n\r\n    function disallowContract(address _addr) public onlyOwner {\r\n        allowedContracts[_addr] = false;\r\n    }\r\n}\r\n\r\ninterface ITokenTrade {\r\n    function getPrice(uint256 _amount) external view returns (uint256);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_goal\",\"type\":\"uint256\"}],\"name\":\"claimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gfamValue\",\"type\":\"uint256\"}],\"name\":\"restakeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gfamValue\",\"type\":\"uint256\"}],\"name\":\"stakeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gfamValue\",\"type\":\"uint256\"}],\"name\":\"stakeReferralComEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ReferralClaimsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addToRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isRefClaim\",\"type\":\"bool\"}],\"internalType\":\"struct StakeGfam.imp_stake[]\",\"name\":\"_items\",\"type\":\"tuple[]\"}],\"name\":\"adm_imp_action\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"allowContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowRef\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"autoAddToRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busdBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cumulativeRewardsBalancePerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStakes\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStakesRef\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tkns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refTkns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refNbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"disallowContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earningDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earningDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"earningDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarningDays\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarningDaysNbr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getStakeRewardPercentGlobal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDistributionBalancePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedStableTokenNet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totaRequestedStableToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReferralClaimsBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDaysStake\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"totalStakes\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"stakesAT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakesRefAT\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentStakesRef\",\"type\":\"int256\"}],\"internalType\":\"struct StakeGfam.TokensData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"initTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardGoal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dayIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"}],\"internalType\":\"struct StakeGfam.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gfamToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imported\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDaysStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeDayEarned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestedStableTokenNet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"restake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistributionBalancePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsBalancePerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setAllowRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setCommissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMinDaysStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setOffset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"setReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTokenTradeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"setUserRef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeReferralCom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokensAT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokensRef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardGoal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dayIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakesAT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakesPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakesRefAT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"substractFromRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTrade\",\"outputs\":[{\"internalType\":\"contract ITokenTrade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totaRequestedStableToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllGfam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawGfam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeGfam", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://04b81923c16610bb9c8729472194aafa23b3c306e6bf7da2b5c73caf0b8f2d39"}