{"SourceCode": "{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destoys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See `_burn` and `_approve`.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * \\u003e Note that this information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * `IERC20.balanceOf` and `IERC20.transfer`.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"ERC20Mintable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./MinterRole.sol\\\";\\n\\n/**\\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\\n * which have permission to mint (create) new tokens as they see fit.\\n *\\n * At construction, the deployer of the contract is the only minter.\\n */\\ncontract ERC20Mintable is ERC20, MinterRole {\\n    /**\\n     * @dev See `ERC20._mint`.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the `MinterRole`.\\n     */\\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\\n        _mint(account, amount);\\n        return true;\\n    }\\n}\\n\"},\"ERC20Pausable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n/**\\n * @title Pausable token\\n * @dev ERC20 modified with pausable transfers.\\n */\\ncontract ERC20Pausable is ERC20, Pausable {\\n    function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\\n        return super.transfer(to, value);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\\n        return super.transferFrom(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {\\n        return super.approve(spender, value);\\n    }\\n\\n    function increaseAllowance(address spender, uint addedValue) public whenNotPaused returns (bool) {\\n        return super.increaseAllowance(spender, addedValue);\\n    }\\n\\n    function decreaseAllowance(address spender, uint subtractedValue) public whenNotPaused returns (bool) {\\n        return super.decreaseAllowance(spender, subtractedValue);\\n    }\\n}\\n\"},\"ERC20Vesting.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20Mintable.sol\\\";\\nimport \\\"./Math.sol\\\";\\n\\n/**\\n  @title ERC20Vesting\\n  @dev ERC20 that supports vested tokens. Vesting: https://www.investopedia.com/terms/v/vesting.asp.\\n    The vesting is done from the same start date for every address.\\n    Only one lot of vested tokens is supported for a given address.\\n\\n    Note that the vesteable tokens cannot be added after the contract has started vesting.\\n */\\ncontract ERC20Vesting is ERC20Mintable {\\n\\n  using SafeMath for uint256;\\n\\n  struct Vesting {\\n    uint256 vesteableTokens;\\n    uint256 claimedTokens;\\n    uint256 monthsToStart;\\n    uint256 monthsToFinish;\\n    bool immediate;\\n    bool presale;\\n  }\\n\\n  mapping (address =\\u003e Vesting) public vestings;\\n\\n  uint256 private _crowdsaleVestingTimestamp; // Maximum date\\n  uint256 private _presaleVestingTimestamp;\\n  uint256 private _monthToSeconds = 30 days; // 30 * 60 * 60 * 24\\n\\n  uint256 private _tokensInVestingState = 0;\\n\\n  event TokensClaimed(address indexed user, uint256 amount);\\n  event VestingTokensAdded(\\n    address indexed user,\\n    uint256 amount,\\n    uint256 monthsToStart,\\n    uint256 monthsToEnd\\n  );\\n  modifier whenVestingStartedForSender() {\\n    require(\\n      vestingStartDateForUser(msg.sender) \\u003c= now,\\n      \\\"User start vesting date has not been reached yet\\\"\\n    );\\n    _;\\n  }\\n\\n  constructor(uint256 presaleVestingTimestamp, uint256 crowdsaleVestingTimestamp) public {\\n    require(presaleVestingTimestamp \\u003e 0, \\\"presale start vesting timestamp cannot be 0\\\");\\n    _presaleVestingTimestamp = presaleVestingTimestamp;\\n    _crowdsaleVestingTimestamp = crowdsaleVestingTimestamp;\\n  }\\n\\n  /**\\n    @dev Calculates the total supply\\n    @return totalSupply Amount of tokens that are owned or will be owned by users in the future, i.e.\\n    amount of tokens owned by users plus amount of tokens that are in a vesting state\\n  */ \\n  function totalSupply() public view returns (uint256) {\\n    return super.totalSupply().add(_tokensInVestingState);\\n  }\\n\\n  /**\\n    @dev Returns the circulating supply\\n    @return circulatingSupply Amount of tokens that are owned by users now\\n  */\\n  function circulatingSupply() public view returns (uint256) {\\n    return super.totalSupply();\\n  }\\n\\n  /**\\n    @dev Amount of tokens in a vesting state(doesn\\u0027t include claimed tokes)\\n    @return _tokensInVestingState\\n   */\\n  function vestingSupply() public view returns (uint256) {\\n    return _tokensInVestingState;\\n  }\\n\\n  /**\\n    @dev Amount of tokens that the user will be able to claim in the future\\n    @param user Address who has the vesting tokens\\n    @return vestingTokens\\n   */\\n  function vestingBalanceOf(address user) public view returns (uint256) {\\n    Vesting storage vesting = vestings[user];\\n    return vesting.vesteableTokens.sub(vesting.claimedTokens);\\n  }\\n\\n  /**\\n    @dev Lets the user claims the tokens he has already vested. Reverts if the \\n    user doesnt have any tokens to vest.\\n  **/\\n  function claim() public whenVestingStartedForSender {\\n    Vesting storage vesting = vestings[msg.sender];\\n\\n    uint256 vestedTokens = _vestedTokens(msg.sender);\\n\\n    uint256 claimableTokens = vestedTokens.sub(vesting.claimedTokens);\\n\\n    require(claimableTokens \\u003e 0, \\\"The user has claimed all the tokens he can claim for now\\\");\\n\\n    vesting.claimedTokens = vesting.claimedTokens.add(claimableTokens);\\n\\n    _mint(msg.sender, claimableTokens);\\n\\n    _tokensInVestingState = _tokensInVestingState.sub(claimableTokens);\\n\\n    emit TokensClaimed(msg.sender, claimableTokens);\\n  }\\n\\n  /**\\n    @dev Adds vesteable tokens in batch\\n    @notice This MUST be only used to add presale vestings\\n    @param newUsers Array of addresses that will have vesteable tokens\\n    @param amounts Array that tells how much tokens will the address with the same index\\n    will have. Should be strictly greater than 0\\n    @param monthsToStart Amounts of months that the user has to wait to make the first claim\\n    @param monthsToFinish Amounts of months that the user has to wait to claim the tokens completely\\n  **/\\n  function addVestingBatch (\\n    address[] memory newUsers,\\n    uint256[] memory amounts,\\n    uint256[] memory monthsToStart,\\n    uint256[] memory monthsToFinish\\n  ) public onlyMinter {\\n    require(\\n      newUsers.length == amounts.length \\u0026\\u0026 \\n      newUsers.length == monthsToStart.length \\u0026\\u0026 \\n      newUsers.length == monthsToFinish.length,\\n      \\\"Arrays length mismatch\\\");\\n\\n    for (uint256 i = 0; i \\u003c newUsers.length; i ++) {\\n      addVesting(newUsers[i], amounts[i], monthsToStart[i], monthsToFinish[i], false, true);\\n    }\\n  }\\n\\n  /**\\n    @dev Adds vesteable tokens.\\n    @param user Address that will have vesteable tokens.\\n    @param amount Amount of tokens that the address will be able to claim in total.\\n    @param monthsToStart Amount of months that the user has to wait to make the first claim.\\n    @param monthsToFinish Amount of months that the user has to wait to claim the tokens completely.\\n    @param immediate true to allow tokens to be claimed after crowdsale is finished, false otherwise. \\n  **/\\n  function addVesting(\\n    address user,\\n    uint256 amount,\\n    uint256 monthsToStart,\\n    uint256 monthsToFinish,\\n    bool immediate,\\n    bool presale)\\n  public onlyMinter {\\n    require(amount \\u003e 0, \\\"No tokens to vest\\\");\\n    require(monthsToStart \\u003c monthsToFinish, \\\"No time to vest\\\");\\n\\n    require(user != address(0), \\\"user address must not be zero\\\");\\n\\n    uint256 finalAmount = 0;\\n\\n    Vesting memory currentVesting = vestings[user];\\n\\n    if (currentVesting.monthsToStart \\u003e 0 \\u0026\\u0026 currentVesting.monthsToFinish \\u003e 0) {\\n      // adding more tokens to current vesting\\n      require(currentVesting.monthsToStart == monthsToStart, \\\"months to start must equal to the current vesting\\\");\\n      require(currentVesting.monthsToFinish == monthsToFinish, \\\"months to finish must equal to the current vesting\\\");\\n      require(currentVesting.immediate == immediate, \\\"immediate must equal to the current vesting\\\");\\n      require(currentVesting.presale == presale, \\\"presale must equal to the current vesting\\\");\\n      finalAmount = amount.add(currentVesting.vesteableTokens);\\n    } else {\\n      // new vesting!\\n      finalAmount = amount;\\n    }\\n\\n    vestings[user] = Vesting(finalAmount, 0, monthsToStart, monthsToFinish, immediate, presale);\\n    _tokensInVestingState = _tokensInVestingState.add(amount);\\n\\n    emit VestingTokensAdded(user, amount, monthsToStart, monthsToFinish);\\n  }\\n\\n  function vestingStartDateForUser(address user) public view returns(uint256){\\n    return vestings[user].presale ? _presaleVestingTimestamp : _crowdsaleVestingTimestamp;\\n  }\\n\\n  /**\\n    @dev Counts how many tokens the user should have vested until now ideally and\\n    rounds down that number.\\n    @param user Address that have the tokens associated\\n    @return Amounts of vested tokens rounded down.\\n  */\\n  function _vestedTokens(address user) internal view returns (uint256){\\n    Vesting memory vesting = vestings[user];\\n    uint256 vestedTokens = 0;\\n\\n    require(vesting.vesteableTokens \\u003e 0, \\\"User has not vesteable tokens\\\");\\n    if (vesting.immediate) {\\n      vestedTokens = vesting.vesteableTokens;\\n    } else {\\n      uint256 startVestingTimestamp = vestingStartDateForUser(user);\\n      \\n      require(\\n        now \\u003e= startVestingTimestamp.add(vesting.monthsToStart.mul(_monthToSeconds)),\\n        \\\"Has not reached vesting start date\\\"\\n      );\\n\\n      uint256 elapsedVestingTime = now.sub(startVestingTimestamp.add(\\n        vesting.monthsToStart.mul(_monthToSeconds)\\n      ));\\n\\n      uint256 vestingMonths = vesting.monthsToFinish.sub(vesting.monthsToStart);\\n\\n      uint256 vestedTokensWithoutCap = vesting.vesteableTokens.mul(\\n        elapsedVestingTime).div(vestingMonths).div(_monthToSeconds);\\n\\n      vestedTokens = Math.min(vestedTokensWithoutCap, vesting.vesteableTokens);\\n    }\\n\\n    return vestedTokens;\\n  }\\n\\n}\\n\"},\"ERC20VestingCrowdsale.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC20Vesting.sol\\\";\\n\\n/**\\n  @title ERC20VestingCrowdsale\\n  @dev ERC20 that supports vesting and the tokens generation can be done through a crowdsale\\n    Note that when the crowdsale finishes the emission of tokens stops completely.\\n */\\ncontract ERC20VestingCrowdsale is ERC20Vesting, Ownable {\\n\\n  bool private _crowdsaleHasFinished;\\n  bool private _crowdsaleWasSet;\\n  address private _crowdsale;\\n  event CrowdsaleFinished();\\n  event CrowdsaleSet(address crowdsale);\\n\\n  constructor (uint256 presaleVestingTimestamp, uint256 crowdsaleVestingTimestamp) ERC20Vesting(presaleVestingTimestamp, crowdsaleVestingTimestamp) public {\\n    _crowdsaleHasFinished = false;\\n    _crowdsale = address(0); \\n  }\\n\\n  modifier whenCrowdsaleNotSet() {\\n    require(_crowdsale == address(0), \\\"Crowdsale already set\\\");\\n    _;\\n  }\\n\\n  modifier whenCrowdsaleSet() {\\n    require(_crowdsale != address(0), \\\"Crowdsale not set yet\\\");\\n    _;\\n  }\\n\\n  modifier whenCrowdsaleNotFinished() {\\n    require(!hasCrowdsaleFinished(), \\\"Crowdsale has finished already\\\");\\n    _;\\n  }\\n\\n  modifier isCrowdsale() {\\n    require(msg.sender == address(_crowdsale), \\\"Sender is not set crowdsale\\\");\\n    _;\\n  }\\n\\n  function hasCrowdsaleFinished() public view returns (bool) {\\n    return _crowdsaleHasFinished;\\n  }\\n\\n  /**\\n    @dev Finishes the crowdsale and starts vesting.\\n    Can be executed only once, and after the crowdsale finishes.\\n   */\\n  \\n  function finishCrowdsale() public whenCrowdsaleNotFinished isCrowdsale {\\n    _crowdsaleHasFinished = true;\\n    emit CrowdsaleFinished();\\n  }\\n\\n  /**\\n    @dev Generate new tokens. Crowdsale has to be active\\n    @param to The address Which will receive the tokens\\n    @param value Amount of tokens to generate\\n\\n   */\\n  function mint(address to, uint256 value) public returns (bool) {\\n    return super.mint(to, value);\\n  }\\n\\n  /**\\n    @dev Tells the token the address of the crowdsale contract in order to make it\\n    able to mint an pause/unpause the token\\n    @param crowdsale Address of the crowdsale contract\\n   */\\n  function setCrowdsale(address crowdsale) public onlyOwner whenCrowdsaleNotSet  {\\n    require(crowdsale != address(0), \\\"Invalid crowdsale\\\");\\n    addMinter(crowdsale);\\n    _crowdsale = crowdsale;\\n    emit CrowdsaleSet(crowdsale);\\n  } \\n\\n  function addVesting(\\n    address user,\\n    uint256 amount,\\n    uint256 monthsToStart,\\n    uint256 monthsToFinish,\\n    bool immediate,\\n    bool presale)\\n  public {\\n    super.addVesting(user, amount, monthsToStart, monthsToFinish, immediate, presale);\\n  }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"InveCoin.sol\":{\"content\":\"pragma solidity 0.5.0;\\n\\nimport \\\"./ERC20Pausable.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ERC20VestingCrowdsale.sol\\\";\\n\\n/**\\n  @title InveCoin\\n  @dev Token of the Investoland project.\\n  Has vesteable tokens, a crowdsale and is paused during the crowdsale.\\n */\\ncontract InveCoin is ERC20Detailed, ERC20Pausable, ERC20VestingCrowdsale {\\n\\n  constructor(uint256 presaleVestingTimestamp, uint256 crowdsaleVestingTimestamp)\\n    ERC20VestingCrowdsale(presaleVestingTimestamp, crowdsaleVestingTimestamp)\\n    ERC20Detailed(\\\"Invecoin\\\", \\\"INV\\\", 18)\\n    public {\\n    // empty constructor\\n  }\\n\\n  function finishCrowdsale() public {\\n    super.finishCrowdsale();\\n  }\\n\\n  function setCrowdsale(address crowdsale) public  {\\n    super.setCrowdsale(crowdsale);\\n  }\\n}\\n\"},\"Math.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"},\"MinterRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract MinterRole {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () internal {\\n        _addMinter(msg.sender);\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"MinterRole: caller does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * \\u003e Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./PauserRole.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\ncontract Pausable is PauserRole {\\n    /**\\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\\n     * to the deployer.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Called by a pauser to pause, triggers stopped state.\\n     */\\n    function pause() public onlyPauser whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Called by a pauser to unpause, returns to normal state.\\n     */\\n    function unpause() public onlyPauser whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"},\"PauserRole.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\ncontract PauserRole {\\n    using Roles for Roles.Role;\\n\\n    event PauserAdded(address indexed account);\\n    event PauserRemoved(address indexed account);\\n\\n    Roles.Role private _pausers;\\n\\n    constructor () internal {\\n        _addPauser(msg.sender);\\n    }\\n\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender), \\\"PauserRole: caller does not have the Pauser role\\\");\\n        _;\\n    }\\n\\n    function isPauser(address account) public view returns (bool) {\\n        return _pausers.has(account);\\n    }\\n\\n    function addPauser(address account) public onlyPauser {\\n        _addPauser(account);\\n    }\\n\\n    function renouncePauser() public {\\n        _removePauser(msg.sender);\\n    }\\n\\n    function _addPauser(address account) internal {\\n        _pausers.add(account);\\n        emit PauserAdded(account);\\n    }\\n\\n    function _removePauser(address account) internal {\\n        _pausers.remove(account);\\n        emit PauserRemoved(account);\\n    }\\n}\\n\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address =\\u003e bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account\\u0027s access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"monthsToStart\",\"type\":\"uint256\"},{\"name\":\"monthsToFinish\",\"type\":\"uint256\"},{\"name\":\"immediate\",\"type\":\"bool\"},{\"name\":\"presale\",\"type\":\"bool\"}],\"name\":\"addVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"vestingBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newUsers\",\"type\":\"address[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"monthsToStart\",\"type\":\"uint256[]\"},{\"name\":\"monthsToFinish\",\"type\":\"uint256[]\"}],\"name\":\"addVestingBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"vestingStartDateForUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasCrowdsaleFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestings\",\"outputs\":[{\"name\":\"vesteableTokens\",\"type\":\"uint256\"},{\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"name\":\"monthsToStart\",\"type\":\"uint256\"},{\"name\":\"monthsToFinish\",\"type\":\"uint256\"},{\"name\":\"immediate\",\"type\":\"bool\"},{\"name\":\"presale\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"presaleVestingTimestamp\",\"type\":\"uint256\"},{\"name\":\"crowdsaleVestingTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CrowdsaleFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"crowdsale\",\"type\":\"address\"}],\"name\":\"CrowdsaleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"monthsToStart\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"monthsToEnd\",\"type\":\"uint256\"}],\"name\":\"VestingTokensAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "InveCoin", "CompilerVersion": "v0.5.0+commit.1d4f565a", "OptimizationUsed": "1", "Runs": "10000000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000005cf9d330000000000000000000000000000000000000000000000000000000005dbb757f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://5c6f975c61e1f6f86f54ce34f5609f643ec93804152ce7f9148869534a40c3f0"}