{"SourceCode": "{\"AntiSniper.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Libraries.sol\\\";\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./BaseErc20.sol\\\";\\r\\n\\r\\ninterface IPinkAntiBot {\\r\\n  function setTokenOwner(address owner) external;\\r\\n  function onPreTransferCheck(address from, address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\nabstract contract AntiSniper is BaseErc20 {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    IPinkAntiBot public pinkAntiBot;\\r\\n    bool private pinkAntiBotConfigured;\\r\\n\\r\\n    bool public enableSniperBlocking;\\r\\n    bool public enableBlockLogProtection;\\r\\n    bool public enableHighTaxCountdown;\\r\\n    bool public enablePinkAntiBot;\\r\\n    \\r\\n    uint256 public maxSellPercentage;\\r\\n    uint256 public maxHoldPercentage;\\r\\n    uint256 public maxGasLimit;\\r\\n\\r\\n    uint256 public launchTime;\\r\\n    uint256 public launchBlock;\\r\\n    uint256 public snipersCaught;\\r\\n    \\r\\n    mapping (address =\\u003e bool) public isSniper;\\r\\n    mapping (address =\\u003e bool) public isNeverSniper;\\r\\n    mapping (address =\\u003e uint256) public transactionBlockLog;\\r\\n    \\r\\n    // Overrides\\r\\n    \\r\\n    function configure(address _owner) internal virtual override {\\r\\n        isNeverSniper[_owner] = true;\\r\\n        super.configure(_owner);\\r\\n    }\\r\\n    \\r\\n    function launch() override virtual public onlyOwner {\\r\\n        super.launch();\\r\\n        launchTime = block.timestamp;\\r\\n        launchBlock = block.number;\\r\\n    }\\r\\n    \\r\\n    function preTransfer(address from, address to, uint256 value) override virtual internal {\\r\\n        require(enableSniperBlocking == false || isSniper[msg.sender] == false, \\\"sniper rejected\\\");\\r\\n        \\r\\n        if (launched \\u0026\\u0026 from != owner \\u0026\\u0026 isNeverSniper[from] == false \\u0026\\u0026 isNeverSniper[to] == false) {\\r\\n            \\r\\n            if (maxGasLimit \\u003e 0) {\\r\\n               require(gasleft() \\u003c= maxGasLimit, \\\"this is over the max gas limit\\\");\\r\\n            }\\r\\n            \\r\\n            if (maxHoldPercentage \\u003e 0 \\u0026\\u0026 exchanges[to] == false) {\\r\\n                require (_balances[to].add(value) \\u003c= maxHoldAmount(), \\\"this is over the max hold amount\\\");\\r\\n            }\\r\\n            \\r\\n            if (maxSellPercentage \\u003e 0 \\u0026\\u0026 exchanges[to]) {\\r\\n                require (value \\u003c= maxSellAmount(), \\\"this is over the max sell amount\\\");\\r\\n            }\\r\\n            \\r\\n            if(enableBlockLogProtection) {\\r\\n                if (transactionBlockLog[to] == block.number) {\\r\\n                    isSniper[to] = true;\\r\\n                    snipersCaught ++;\\r\\n                }\\r\\n                if (transactionBlockLog[from] == block.number) {\\r\\n                    isSniper[from] = true;\\r\\n                    snipersCaught ++;\\r\\n                }\\r\\n                if (exchanges[to] == false) {\\r\\n                    transactionBlockLog[to] = block.number;\\r\\n                }\\r\\n                if (exchanges[from] == false) {\\r\\n                    transactionBlockLog[from] = block.number;\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            if (enablePinkAntiBot) {\\r\\n                pinkAntiBot.onPreTransferCheck(from, to, value);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        super.preTransfer(from, to, value);\\r\\n    }\\r\\n    \\r\\n    function calculateTransferAmount(address from, address to, uint256 value) internal virtual override returns (uint256) {\\r\\n        uint256 amountAfterTax = value;\\r\\n        if (launched \\u0026\\u0026 enableHighTaxCountdown) {\\r\\n            if (from != owner \\u0026\\u0026 sniperTax() \\u003e 0 \\u0026\\u0026 isNeverSniper[from] == false \\u0026\\u0026 isNeverSniper[to] == false) {\\r\\n                uint256 taxAmount = value.mul(sniperTax()).div(10000);\\r\\n                amountAfterTax = amountAfterTax.sub(taxAmount);\\r\\n            }\\r\\n        }\\r\\n        return super.calculateTransferAmount(from, to, amountAfterTax);\\r\\n    }\\r\\n    \\r\\n    // Public methods\\r\\n    \\r\\n    function maxHoldAmount() public view returns (uint256) {\\r\\n        return totalSupply().mul(maxHoldPercentage).div(10000);\\r\\n    }\\r\\n    \\r\\n    function maxSellAmount() public view returns (uint256) {\\r\\n         return totalSupply().mul(maxSellPercentage).div(10000);\\r\\n    }\\r\\n    \\r\\n   function sniperTax() public virtual view returns (uint256) {\\r\\n        if(launched) {\\r\\n            if (block.number - launchBlock \\u003c 3) {\\r\\n                return 9900;\\r\\n            }\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    // Admin methods\\r\\n    \\r\\n    function configurePinkAntiBot(address antiBot) external onlyOwner {\\r\\n        pinkAntiBot = IPinkAntiBot(antiBot);\\r\\n        pinkAntiBot.setTokenOwner(owner);\\r\\n        pinkAntiBotConfigured = true;\\r\\n        enablePinkAntiBot = true;\\r\\n    }\\r\\n    \\r\\n    function setSniperBlocking(bool enabled) external onlyOwner {\\r\\n        enableSniperBlocking = enabled;\\r\\n    }\\r\\n    \\r\\n    function setBlockLogProtection(bool enabled) external onlyOwner {\\r\\n        enableBlockLogProtection = enabled;\\r\\n    }\\r\\n    \\r\\n    function setHighTaxCountdown(bool enabled) external onlyOwner {\\r\\n        enableHighTaxCountdown = enabled;\\r\\n    }\\r\\n    \\r\\n    function setPinkAntiBot(bool enabled) external onlyOwner {\\r\\n        require(pinkAntiBotConfigured, \\\"pink anti bot is not configured\\\");\\r\\n        enablePinkAntiBot = enabled;\\r\\n    }\\r\\n    \\r\\n    function setMaxSellPercentage(uint256 amount) external onlyOwner {\\r\\n        maxSellPercentage = amount;\\r\\n    }\\r\\n    \\r\\n    function setMaxHoldPercentage(uint256 amount) external onlyOwner {\\r\\n        maxHoldPercentage = amount;\\r\\n    }\\r\\n    \\r\\n    function setMaxGasLimit(uint256 amount) external onlyOwner {\\r\\n        maxGasLimit = amount;\\r\\n    }\\r\\n    \\r\\n    function setIsSniper(address who, bool enabled) external onlyOwner {\\r\\n        isSniper[who] = enabled;\\r\\n    }\\r\\n\\r\\n    function setNeverSniper(address who, bool enabled) external onlyOwner {\\r\\n        isNeverSniper[who] = enabled;\\r\\n    }\\r\\n\\r\\n    // private methods\\r\\n}\"},\"BaseErc20.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./Libraries.sol\\\";\\r\\n\\r\\nabstract contract BaseErc20 is IERC20, IOwnable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowed;\\r\\n    uint256 internal _totalSupply;\\r\\n    bool internal _useSafeTransfer;\\r\\n    \\r\\n    string public symbol;\\r\\n    string public  name;\\r\\n    uint8 public decimals;\\r\\n    \\r\\n    address public override owner;\\r\\n    bool public isTradingEnabled = true;\\r\\n    bool public launched;\\r\\n    \\r\\n    mapping (address =\\u003e bool) public canAlwaysTrade;\\r\\n    mapping (address =\\u003e bool) public excludedFromSelling;\\r\\n    mapping (address =\\u003e bool) public exchanges;\\r\\n    \\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"can only be called by the contract owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    modifier isLaunched() {\\r\\n        require(launched, \\\"can only be called once token is launched\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // @dev Trading is allowed before launch if the sender is the owner, we are transferring from the owner, or in canAlwaysTrade list\\r\\n    modifier tradingEnabled(address from) {\\r\\n        require((isTradingEnabled \\u0026\\u0026 launched) || from == owner || canAlwaysTrade[msg.sender], \\\"trading not enabled\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function configure(address _owner) internal virtual {\\r\\n        owner = _owner;\\r\\n        canAlwaysTrade[owner] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Total number of tokens in existence\\r\\n    */\\r\\n    function totalSupply() public override view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the balance of the specified address.\\r\\n    * @param _owner The address to query the balance of.\\r\\n    * @return An uint256 representing the amount owned by the passed address.\\r\\n    */\\r\\n    function balanceOf(address _owner) public override view returns (uint256) {\\r\\n        return _balances[_owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\r\\n     * @param _owner address The address which owns the funds.\\r\\n     * @param spender address The address which will spend the funds.\\r\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\r\\n     */\\r\\n    function allowance(address _owner, address spender) public override view returns (uint256) {\\r\\n        return _allowed[_owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer token for a specified address\\r\\n    * @param to The address to transfer to.\\r\\n    * @param value The amount to be transferred.\\r\\n    */\\r\\n    function transfer(address to, uint256 value) public override tradingEnabled(msg.sender) returns (bool) {\\r\\n        _transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n     * race condition is to first reduce the spender\\u0027s allowance to 0 and set the desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param value The amount of tokens to be spent.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) public override tradingEnabled(msg.sender) returns (bool) {\\r\\n        require(spender != address(0), \\\"cannot approve the 0 address\\\");\\r\\n\\r\\n        _allowed[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer tokens from one address to another.\\r\\n     * Note that while this function emits an Approval event, this is not required as per the specification,\\r\\n     * and other compliant implementations may not emit the event.\\r\\n     * @param from address The address which you want to send tokens from\\r\\n     * @param to address The address which you want to transfer to\\r\\n     * @param value uint256 the amount of tokens to be transferred\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) public override tradingEnabled(from) returns (bool) {\\r\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\r\\n        _transfer(from, to, value);\\r\\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\r\\n     * approve should be called when allowed_[_spender] == 0. To increment\\r\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n     * the first transaction is mined)\\r\\n     * From MonolithDAO Token.sol\\r\\n     * Emits an Approval event.\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param addedValue The amount of tokens to increase the allowance by.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public tradingEnabled(msg.sender) returns (bool) {\\r\\n        require(spender != address(0), \\\"cannot approve the 0 address\\\");\\r\\n\\r\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\\r\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\r\\n     * approve should be called when allowed_[_spender] == 0. To decrement\\r\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n     * the first transaction is mined)\\r\\n     * From MonolithDAO Token.sol\\r\\n     * Emits an Approval event.\\r\\n     * @param spender The address which will spend the funds.\\r\\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public tradingEnabled(msg.sender) returns (bool) {\\r\\n        require(spender != address(0), \\\"cannot approve the 0 address\\\");\\r\\n\\r\\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\\r\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n    \\r\\n    // Virtual methods\\r\\n    function launch() virtual public onlyOwner {\\r\\n        launched = true;\\r\\n    }\\r\\n    \\r\\n    function preTransfer(address from, address to, uint256 value) virtual internal { }\\r\\n\\r\\n    function calculateTransferAmount(address from, address to, uint256 value) virtual internal returns (uint256) {\\r\\n        require(from != to, \\\"you cannot transfer to yourself\\\");\\r\\n        return value;\\r\\n    }\\r\\n    \\r\\n    function postTransfer(address from, address to) virtual internal { }\\r\\n    \\r\\n\\r\\n\\r\\n    // Admin methods\\r\\n    function changeOwner(address who) external onlyOwner {\\r\\n        require(who != address(0), \\\"cannot be zero address\\\");\\r\\n        owner = who;\\r\\n    }\\r\\n\\r\\n    function removeBnb() external onlyOwner {\\r\\n        uint256 balance = address(this).balance;\\r\\n        payable(owner).transfer(balance);\\r\\n    }\\r\\n\\r\\n    function transferTokens(address token, address to) external onlyOwner returns(bool){\\r\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\r\\n        return IERC20(token).transfer(to, balance);\\r\\n    }\\r\\n\\r\\n    function setTradingEnabled(bool enabled) external onlyOwner {\\r\\n        isTradingEnabled = enabled;\\r\\n    }\\r\\n    \\r\\n    function setCanAlwaysTrade(address who, bool enabled) external onlyOwner {\\r\\n        canAlwaysTrade[who] = enabled;\\r\\n    }\\r\\n    \\r\\n    function setExchange(address who, bool isExchange) external onlyOwner {\\r\\n        exchanges[who] = isExchange;\\r\\n    }\\r\\n    \\r\\n    function setExcludedFromSelling(address who, bool isExcluded) external onlyOwner {\\r\\n        excludedFromSelling[who] = isExcluded;\\r\\n    }\\r\\n\\r\\n    \\r\\n    // Private methods\\r\\n\\r\\n    /**\\r\\n    * @dev Transfer token for a specified addresses\\r\\n    * @param from The address to transfer from.\\r\\n    * @param to The address to transfer to.\\r\\n    * @param value The amount to be transferred.\\r\\n    */\\r\\n    function _transfer(address from, address to, uint256 value) private {\\r\\n        require(to != address(0), \\\"cannot be zero address\\\");\\r\\n        require(excludedFromSelling[from] == false, \\\"address is not allowed to sell\\\");\\r\\n        \\r\\n        if (_useSafeTransfer) {\\r\\n\\r\\n            _balances[from] = _balances[from].sub(value);\\r\\n            _balances[to] = _balances[to].add(value);\\r\\n            emit Transfer(from, to, value);\\r\\n\\r\\n        } else {\\r\\n            preTransfer(from, to, value);\\r\\n\\r\\n            uint256 modifiedAmount = calculateTransferAmount(from, to, value);\\r\\n            _balances[from] = _balances[from].sub(value);\\r\\n            _balances[to] = _balances[to].add(modifiedAmount);\\r\\n\\r\\n            emit Transfer(from, to, modifiedAmount);\\r\\n\\r\\n            postTransfer(from, to);\\r\\n        }\\r\\n    }\\r\\n}\"},\"Burnable.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Libraries.sol\\\";\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./BaseErc20.sol\\\";\\r\\n\\r\\nabstract contract Burnable is BaseErc20, IBurnable {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    mapping (address =\\u003e bool) public ableToBurn;\\r\\n\\r\\n    modifier onlyBurner() {\\r\\n        require(ableToBurn[msg.sender], \\\"no burn permissions\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Overrides\\r\\n    \\r\\n    function configure(address _owner) internal virtual override {\\r\\n        ableToBurn[_owner] = true;\\r\\n        super.configure(_owner);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // Admin methods\\r\\n\\r\\n    function setAbleToBurn(address who, bool enabled) external onlyOwner {\\r\\n        ableToBurn[who] = enabled;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Private methods\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function that burns an amount of the token of a given\\r\\n     * account.\\r\\n     * @param account The account whose tokens will be burnt.\\r\\n     * @param value The amount that will be burnt.\\r\\n     */\\r\\n    function burn(address account, uint256 value) public override onlyBurner {\\r\\n        require(account != address(0));\\r\\n\\r\\n        _totalSupply = _totalSupply.sub(value);\\r\\n        _balances[account] = _balances[account].sub(value);\\r\\n        emit Transfer(account, address(0), value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function that burns an amount of the token of a given\\r\\n     * account, deducting from the sender\\u0027s allowance for said account. Uses the\\r\\n     * internal burn function.\\r\\n     * Emits an Approval event (reflecting the reduced allowance).\\r\\n     * @param account The account whose tokens will be burnt.\\r\\n     * @param value The amount that will be burnt.\\r\\n     */\\r\\n    function burnFrom(address account, uint256 value) public override onlyBurner {\\r\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(value);\\r\\n        burn(account, value);\\r\\n        emit Approval(account, msg.sender, _allowed[account][msg.sender]);\\r\\n    }\\r\\n}\"},\"Dividends.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./BaseErc20.sol\\\";\\r\\n\\r\\nabstract contract Dividends is BaseErc20 {\\r\\n    IDividendDistributor dividendDistributor;\\r\\n    bool public autoDistributeDividends;\\r\\n    mapping (address =\\u003e bool) public excludedFromDividends;\\r\\n    uint256 dividendDistributorGas;\\r\\n    \\r\\n\\r\\n    // Overrides\\r\\n    \\r\\n    function configure(address _owner) internal virtual override {\\r\\n        excludedFromDividends[_owner] = true;\\r\\n        super.configure(_owner);\\r\\n    }\\r\\n    \\r\\n    function postTransfer(address from, address to) internal virtual override {\\r\\n        if (excludedFromDividends[from] == false) {\\r\\n            dividendDistributor.setShare(from, _balances[from]);\\r\\n        }\\r\\n        if (excludedFromDividends[to] == false) {\\r\\n            dividendDistributor.setShare(to, _balances[to]);\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            launched \\u0026\\u0026 \\r\\n            autoDistributeDividends \\u0026\\u0026\\r\\n            exchanges[from] \\u0026\\u0026 \\r\\n            dividendDistributor.inSwap() == false\\r\\n        ) {\\r\\n            try dividendDistributor.process(dividendDistributorGas) {} catch {}\\r\\n        }\\r\\n\\r\\n        super.postTransfer(from, to);\\r\\n    }\\r\\n    \\r\\n    // Public methods\\r\\n    \\r\\n    /**\\r\\n     * @dev Return the address of the dividend distributor contract\\r\\n     */\\r\\n    function dividendDistributorAddress() public view returns (address) {\\r\\n        return address(dividendDistributor);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // Admin methods\\r\\n    \\r\\n    function setDividendDistributionThresholds(uint256 minAmount, uint256 minTime, uint256 gas) external virtual onlyOwner {\\r\\n        dividendDistributorGas = gas;\\r\\n        dividendDistributor.setDistributionCriteria(minTime, minAmount);\\r\\n    }\\r\\n\\r\\n    function setAutoDistributeDividends(bool enabled) external onlyOwner {\\r\\n        autoDistributeDividends = enabled;\\r\\n    }\\r\\n\\r\\n    function setIsDividendExempt(address who, bool isExempt) external onlyOwner {\\r\\n        require(who != address(this), \\\"this address cannot receive shares\\\");\\r\\n        excludedFromDividends[who] = isExempt;\\r\\n        if (isExempt){\\r\\n            dividendDistributor.setShare(who, 0);\\r\\n        } else {\\r\\n            dividendDistributor.setShare(who, _balances[who]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function runDividendsManually(uint256 gas) external onlyOwner {\\r\\n        dividendDistributor.process(gas);\\r\\n    }\\r\\n    \\r\\n\\r\\n}\"},\"Interfaces.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\ninterface IOwnable {\\r\\n    function owner() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n    function allowance(address _owner, address spender) external view returns (uint256);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IBurnable {\\r\\n    function burn(address account, uint256 value) external;\\r\\n    function burnFrom(address account, uint256 value) external;\\r\\n}\\r\\n\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IDividendDistributor {\\r\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\\r\\n    function setShare(address shareholder, uint256 amount) external;\\r\\n    function depositNative() external payable;\\r\\n    function depositToken(address from, uint256 amount) external;\\r\\n    function process(uint256 gas) external;\\r\\n    function inSwap() external view returns (bool);\\r\\n}\\r\\n\\r\\n\\r\\ninterface ITaxDistributor {\\r\\n    receive() external payable;\\r\\n    function lastSwapTime() external view returns (uint256);\\r\\n    function inSwap() external view returns (bool);\\r\\n    function createWalletTax(string memory name, uint256 buyTax, uint256 sellTax, address wallet, bool convertToNative) external;\\r\\n    function createDistributorTax(string memory name, uint256 buyTax, uint256 sellTax, address wallet, bool convertToNative) external;\\r\\n    function createDividendTax(string memory name, uint256 buyTax, uint256 sellTax, address dividendDistributor, bool convertToNative) external;\\r\\n    function createBurnTax(string memory name, uint256 buyTax, uint256 sellTax) external;\\r\\n    function createLiquidityTax(string memory name, uint256 buyTax, uint256 sellTax) external;\\r\\n    function distribute() external payable;\\r\\n    function getSellTax() external view returns (uint256);\\r\\n    function getBuyTax() external view returns (uint256);\\r\\n    function setTaxWallet(string memory taxName, address wallet) external;\\r\\n    function setSellTax(string memory taxName, uint256 taxPercentage) external;\\r\\n    function setBuyTax(string memory taxName, uint256 taxPercentage) external;\\r\\n    function takeSellTax(uint256 value) external returns (uint256);\\r\\n    function takeBuyTax(uint256 value) external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IWalletDistributor {\\r\\n    function receiveToken(address token, address from, uint256 amount) external;\\r\\n}\\r\\n\"},\"Libraries.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that revert on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n    int256 constant private INT256_MIN = -2**255;\\r\\n\\r\\n    /**\\r\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\r\\n    */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Multiplies two signed integers, reverts on overflow.\\r\\n    */\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        require(!(a == -1 \\u0026\\u0026 b == INT256_MIN)); // This is the only case of overflow not detected by the check below\\r\\n\\r\\n        int256 c = a * b;\\r\\n        require(c / a == b);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\r\\n    */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\\r\\n    */\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\\r\\n        require(!(b == -1 \\u0026\\u0026 a == INT256_MIN)); // This is the only case of overflow\\r\\n\\r\\n        int256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\r\\n    */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Subtracts two signed integers, reverts on overflow.\\r\\n    */\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a));\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adds two unsigned integers, reverts on overflow.\\r\\n    */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a);\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Adds two signed integers, reverts on overflow.\\r\\n    */\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\r\\n    * reverts when dividing by zero.\\r\\n    */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"Taxable.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Libraries.sol\\\";\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./BaseErc20.sol\\\";\\r\\n\\r\\nabstract contract Taxable is BaseErc20 {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    ITaxDistributor taxDistributor;\\r\\n\\r\\n    bool public autoSwapTax;\\r\\n    uint256 public minimumTimeBetweenSwaps;\\r\\n    uint256 public minimumTokensBeforeSwap;\\r\\n    mapping (address =\\u003e bool) public excludedFromTax;\\r\\n    uint256 swapStartTime;\\r\\n    \\r\\n    // Overrides\\r\\n    \\r\\n    function configure(address _owner) internal virtual override {\\r\\n        excludedFromTax[_owner] = true;\\r\\n        super.configure(_owner);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function calculateTransferAmount(address from, address to, uint256 value) internal virtual override returns (uint256) {\\r\\n        \\r\\n        uint256 amountAfterTax = value;\\r\\n\\r\\n        if (excludedFromTax[from] == false \\u0026\\u0026 excludedFromTax[to] == false \\u0026\\u0026 launched) {\\r\\n            if (exchanges[from]) {\\r\\n                // we are BUYING\\r\\n                amountAfterTax = taxDistributor.takeBuyTax(value);\\r\\n            } else {\\r\\n                // we are SELLING\\r\\n                amountAfterTax = taxDistributor.takeSellTax(value);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 taxAmount = value.sub(amountAfterTax);\\r\\n        if (taxAmount \\u003e 0) {\\r\\n            _balances[address(taxDistributor)] = _balances[address(taxDistributor)].add(taxAmount);\\r\\n            emit Transfer(from, address(taxDistributor), taxAmount);\\r\\n        }\\r\\n        return super.calculateTransferAmount(from, to, amountAfterTax);\\r\\n    }\\r\\n\\r\\n\\r\\n    function preTransfer(address from, address to, uint256 value) override virtual internal {\\r\\n        uint256 timeSinceLastSwap = block.timestamp - taxDistributor.lastSwapTime();\\r\\n        if (\\r\\n            launched \\u0026\\u0026 \\r\\n            autoSwapTax \\u0026\\u0026 \\r\\n            exchanges[to] \\u0026\\u0026 \\r\\n            swapStartTime + 60 \\u003c= block.timestamp \\u0026\\u0026\\r\\n            timeSinceLastSwap \\u003e= minimumTimeBetweenSwaps \\u0026\\u0026\\r\\n            _balances[address(taxDistributor)] \\u003e= minimumTokensBeforeSwap \\u0026\\u0026\\r\\n            taxDistributor.inSwap() == false\\r\\n        ) {\\r\\n            swapStartTime = block.timestamp;\\r\\n            try taxDistributor.distribute() {} catch {}\\r\\n        }\\r\\n        super.preTransfer(from, to, value);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // Public methods\\r\\n    \\r\\n    /**\\r\\n     * @dev Return the current total sell tax from the tax distributor\\r\\n     */\\r\\n    function sellTax() public view returns (uint256) {\\r\\n        return taxDistributor.getSellTax();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the current total sell tax from the tax distributor\\r\\n     */\\r\\n    function buyTax() public view returns (uint256) {\\r\\n        return taxDistributor.getBuyTax();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return the address of the tax distributor contract\\r\\n     */\\r\\n    function taxDistributorAddress() public view returns (address) {\\r\\n        return address(taxDistributor);\\r\\n    }    \\r\\n    \\r\\n    \\r\\n    // Admin methods\\r\\n\\r\\n    function setAutoSwaptax(bool enabled) external onlyOwner {\\r\\n        autoSwapTax = enabled;\\r\\n    }\\r\\n\\r\\n    function setExcludedFromTax(address who, bool enabled) external onlyOwner {\\r\\n        excludedFromTax[who] = enabled;\\r\\n    }\\r\\n\\r\\n    function setTaxDistributionThresholds(uint256 minAmount, uint256 minTime) external onlyOwner {\\r\\n        minimumTokensBeforeSwap = minAmount;\\r\\n        minimumTimeBetweenSwaps = minTime;\\r\\n    }\\r\\n    \\r\\n    function setSellTax(string memory taxName, uint256 taxAmount) external onlyOwner {\\r\\n        taxDistributor.setSellTax(taxName, taxAmount);\\r\\n    }\\r\\n\\r\\n    function setBuyTax(string memory taxName, uint256 taxAmount) external onlyOwner {\\r\\n        taxDistributor.setBuyTax(taxName, taxAmount);\\r\\n    }\\r\\n    \\r\\n    function setTaxWallet(string memory taxName, address wallet) external onlyOwner {\\r\\n        taxDistributor.setTaxWallet(taxName, wallet);\\r\\n    }\\r\\n    \\r\\n    function runSwapManually() external onlyOwner isLaunched {\\r\\n        taxDistributor.distribute();\\r\\n    }\\r\\n}\"},\"TaxDistributor.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./Libraries.sol\\\";\\r\\n\\r\\ncontract TaxDistributor is ITaxDistributor {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address public tokenPair;\\r\\n    address public routerAddress;\\r\\n    address private _token;\\r\\n    address private _wbnb;\\r\\n\\r\\n    IDEXRouter private _router;\\r\\n\\r\\n    bool public override inSwap;\\r\\n    uint256 public override lastSwapTime;\\r\\n\\r\\n    enum TaxType { WALLET, DIVIDEND, LIQUIDITY, DISTRIBUTOR, BURN }\\r\\n    struct Tax {\\r\\n        string taxName;\\r\\n        uint256 buyTaxPercentage;\\r\\n        uint256 sellTaxPercentage;\\r\\n        uint256 taxPool;\\r\\n        TaxType taxType;\\r\\n        address location;\\r\\n        uint256 share;\\r\\n        bool convertToNative;\\r\\n    }\\r\\n    Tax[] public taxes;\\r\\n\\r\\n    event TaxesDistributed(uint256 tokensSwapped, uint256 ethReceived);\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token, \\\"no permissions\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier swapLock() {\\r\\n        require(inSwap == false, \\\"already swapping\\\");\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor (address router, address pair, address wbnb) {\\r\\n        _token = msg.sender;\\r\\n        _wbnb = wbnb;\\r\\n        _router = IDEXRouter(router);\\r\\n        tokenPair = pair;\\r\\n        routerAddress = router;\\r\\n    }\\r\\n\\r\\n    receive() external override payable {}\\r\\n\\r\\n    function createWalletTax(string memory name, uint256 buyTax, uint256 sellTax, address wallet, bool convertToNative) public override onlyToken {\\r\\n        taxes.push(Tax(name, buyTax, sellTax, 0, TaxType.WALLET, wallet, 0, convertToNative));\\r\\n    }\\r\\n\\r\\n    function createDistributorTax(string memory name, uint256 buyTax, uint256 sellTax, address wallet, bool convertToNative) public override onlyToken {\\r\\n        taxes.push(Tax(name, buyTax, sellTax, 0, TaxType.DISTRIBUTOR, wallet, 0, convertToNative));\\r\\n    }\\r\\n    \\r\\n    function createDividendTax(string memory name, uint256 buyTax, uint256 sellTax, address dividendDistributor, bool convertToNative) public override onlyToken {\\r\\n        taxes.push(Tax(name, buyTax, sellTax, 0, TaxType.DIVIDEND, dividendDistributor, 0, convertToNative));\\r\\n    }\\r\\n    \\r\\n    function createBurnTax(string memory name, uint256 buyTax, uint256 sellTax) public override onlyToken {\\r\\n        taxes.push(Tax(name, buyTax, sellTax, 0, TaxType.BURN, address(0), 0, false));\\r\\n    }\\r\\n\\r\\n    function createLiquidityTax(string memory name, uint256 buyTax, uint256 sellTax) public override onlyToken {\\r\\n        taxes.push(Tax(name, buyTax, sellTax, 0, TaxType.LIQUIDITY, address(0), 0, false));\\r\\n    }\\r\\n\\r\\n    function distribute() public payable override onlyToken swapLock {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _token;\\r\\n        path[1] = _wbnb;\\r\\n        IERC20 token = IERC20(_token);\\r\\n\\r\\n        uint256 totalTokens;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            if (taxes[i].taxType == TaxType.LIQUIDITY) {\\r\\n                uint256 half = taxes[i].taxPool.div(2);\\r\\n                totalTokens += taxes[i].taxPool.sub(half);\\r\\n            } else if (taxes[i].convertToNative) {\\r\\n                totalTokens += taxes[i].taxPool;\\r\\n            }\\r\\n        }\\r\\n        totalTokens = checkTokenAmount(token, totalTokens);\\r\\n      \\r\\n        _router.swapExactTokensForETH(\\r\\n            totalTokens,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp + 300\\r\\n        );\\r\\n        uint256 amountBNB = address(this).balance;\\r\\n\\r\\n        // Calculate the distribution\\r\\n        uint256 toDistribute = amountBNB;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n\\r\\n            if (taxes[i].convertToNative || taxes[i].taxType == TaxType.LIQUIDITY) {\\r\\n                if (i == taxes.length - 1) {\\r\\n                    taxes[i].share = toDistribute;\\r\\n                } else if (taxes[i].taxType == TaxType.LIQUIDITY) {\\r\\n                    uint256 half = taxes[i].taxPool.div(2);\\r\\n                    uint256 share = amountBNB.mul(taxes[i].taxPool.sub(half)).div(totalTokens);\\r\\n                    taxes[i].share = share;\\r\\n                    toDistribute = toDistribute.sub(share);\\r\\n                } else {\\r\\n                    uint256 share = amountBNB.mul(taxes[i].taxPool).div(totalTokens);\\r\\n                    taxes[i].share = share;\\r\\n                    toDistribute = toDistribute.sub(share);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Distribute the coins\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            \\r\\n            if (taxes[i].taxType == TaxType.WALLET) {\\r\\n                if (taxes[i].convertToNative) {\\r\\n                    payable(taxes[i].location).transfer(taxes[i].share);\\r\\n                } else {\\r\\n                    token.transfer(taxes[i].location, checkTokenAmount(token, taxes[i].taxPool));\\r\\n                }\\r\\n            }\\r\\n            else if (taxes[i].taxType == TaxType.DISTRIBUTOR) {\\r\\n                if (taxes[i].convertToNative) {\\r\\n                    payable(taxes[i].location).transfer(taxes[i].share);\\r\\n                } else {\\r\\n                    token.approve(taxes[i].location, taxes[i].taxPool);\\r\\n                    IWalletDistributor(taxes[i].location).receiveToken(_token, address(this), checkTokenAmount(token, taxes[i].taxPool));\\r\\n                }\\r\\n            }\\r\\n            else if (taxes[i].taxType == TaxType.DIVIDEND) {\\r\\n               if (taxes[i].convertToNative) {\\r\\n                    IDividendDistributor(taxes[i].location).depositNative{value: taxes[i].share}();\\r\\n                } else {\\r\\n                    IDividendDistributor(taxes[i].location).depositToken(address(this), checkTokenAmount(token, taxes[i].taxPool));\\r\\n                }\\r\\n            }\\r\\n            else if (taxes[i].taxType == TaxType.BURN) {\\r\\n                IBurnable(_token).burn(address(this), checkTokenAmount(token, taxes[i].taxPool));\\r\\n            }\\r\\n            else if (taxes[i].taxType == TaxType.LIQUIDITY) {\\r\\n                if(taxes[i].share \\u003e 0){\\r\\n                    uint256 half = checkTokenAmount(token, taxes[i].taxPool.div(2));\\r\\n                    _router.addLiquidityETH{value: taxes[i].share}(\\r\\n                        _token,\\r\\n                        half,\\r\\n                        0,\\r\\n                        0,\\r\\n                        IOwnable(_token).owner(),\\r\\n                        block.timestamp + 300\\r\\n                    );\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            taxes[i].taxPool = 0;\\r\\n            taxes[i].share = 0;\\r\\n        }\\r\\n\\r\\n        emit TaxesDistributed(totalTokens, amountBNB);\\r\\n\\r\\n        lastSwapTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function getSellTax() public override onlyToken view returns (uint256) {\\r\\n        uint256 taxAmount;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            taxAmount += taxes[i].sellTaxPercentage;\\r\\n        }\\r\\n        return taxAmount;\\r\\n    }\\r\\n\\r\\n    function getBuyTax() public override onlyToken view returns (uint256) {\\r\\n        uint256 taxAmount;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            taxAmount += taxes[i].buyTaxPercentage;\\r\\n        }\\r\\n        return taxAmount;\\r\\n    }\\r\\n    \\r\\n    function setTaxWallet(string memory taxName, address wallet) public override onlyToken {\\r\\n        bool updated;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            if (taxes[i].taxType == TaxType.WALLET \\u0026\\u0026 compareStrings(taxes[i].taxName, taxName)) {\\r\\n                taxes[i].location = wallet;\\r\\n                updated = true;\\r\\n            }\\r\\n        }\\r\\n        require(updated, \\\"could not find tax to update\\\");\\r\\n    }\\r\\n\\r\\n    function setSellTax(string memory taxName, uint256 taxPercentage) public override onlyToken {\\r\\n        bool updated;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            if (compareStrings(taxes[i].taxName, taxName)) {\\r\\n                taxes[i].sellTaxPercentage = taxPercentage;\\r\\n                updated = true;\\r\\n            }\\r\\n        }\\r\\n        require(updated, \\\"could not find tax to update\\\");\\r\\n        require(getSellTax() \\u003c= 1500, \\\"tax cannot be more than 15%\\\");\\r\\n    }\\r\\n\\r\\n    function setBuyTax(string memory taxName, uint256 taxPercentage) public override onlyToken {\\r\\n        bool updated;\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            //if (taxes[i].taxName == taxName) {\\r\\n            if (compareStrings(taxes[i].taxName, taxName)) {\\r\\n                taxes[i].buyTaxPercentage = taxPercentage;\\r\\n                updated = true;\\r\\n            }\\r\\n        }\\r\\n        require(updated, \\\"could not find tax to update\\\");\\r\\n        require(getBuyTax() \\u003c= 1500, \\\"tax cannot be more than 15%\\\");\\r\\n    }\\r\\n\\r\\n    function takeSellTax(uint256 value) public override onlyToken returns (uint256) {\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            if (taxes[i].sellTaxPercentage \\u003e 0) {\\r\\n                uint256 taxAmount = value.mul(taxes[i].sellTaxPercentage).div(10000);\\r\\n                taxes[i].taxPool += taxAmount;\\r\\n                value = value.sub(taxAmount);\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    function takeBuyTax(uint256 value) public override onlyToken returns (uint256) {\\r\\n        for (uint256 i = 0; i \\u003c taxes.length; i++) {\\r\\n            if (taxes[i].buyTaxPercentage \\u003e 0) {\\r\\n                uint256 taxAmount = value.mul(taxes[i].buyTaxPercentage).div(10000);\\r\\n                taxes[i].taxPool += taxAmount;\\r\\n                value = value.sub(taxAmount);\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    // Private methods\\r\\n    function compareStrings(string memory a, string memory b) public pure returns (bool) {\\r\\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\\r\\n    }\\r\\n\\r\\n    function checkTokenAmount(IERC20 token, uint256 amount) private view returns (uint256) {\\r\\n        uint256 balance = token.balanceOf(address(this));\\r\\n        if (balance \\u003e amount) {\\r\\n            return amount;\\r\\n        }\\r\\n        return balance;\\r\\n    }\\r\\n}\\r\\n\"},\"_PandaGirl.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity ^0.8.16;\\r\\n\\r\\nimport \\\"./Interfaces.sol\\\";\\r\\nimport \\\"./Libraries.sol\\\";\\r\\nimport \\\"./BaseErc20.sol\\\";\\r\\nimport \\\"./Burnable.sol\\\";\\r\\nimport \\\"./Taxable.sol\\\";\\r\\nimport \\\"./TaxDistributor.sol\\\";\\r\\nimport \\\"./AntiSniper.sol\\\";\\r\\nimport \\\"./Dividends.sol\\\";\\r\\n\\r\\ncontract PandaGirl is BaseErc20, AntiSniper, Burnable, Taxable, Dividends {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    constructor () {\\r\\n        configure(0xABe96E7d756f251C48B869EE0aE9893be8A66097);\\r\\n\\r\\n        symbol = \\\"PGIRL\\\";\\r\\n        name = \\\"Panda Girl\\\";\\r\\n        decimals = 6;\\r\\n\\r\\n        // IF USING PINKSALE, REMEMBER TO MARK THE PINKSALE ADDRESS AS:\\r\\n        // setExcludedFromTax\\r\\n        // setIsNeverSniper\\r\\n        // setExcludedFromDividends\\r\\n\\r\\n        // Pancake Swap\\r\\n        address pancakeSwap = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // MAINNET\\r\\n        IDEXRouter router = IDEXRouter(pancakeSwap);\\r\\n        address WBNB = router.WETH();\\r\\n        address pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\\r\\n        exchanges[pair] = true;\\r\\n        taxDistributor = new TaxDistributor(pancakeSwap, pair, WBNB);\\r\\n        dividendDistributor = new DividendDistributor(address(taxDistributor));\\r\\n\\r\\n        // Anti Sniper\\r\\n        enableSniperBlocking = true;\\r\\n        isNeverSniper[address(taxDistributor)] = true;\\r\\n        isNeverSniper[address(dividendDistributor)] = true;\\r\\n\\r\\n        // Tax\\r\\n        minimumTimeBetweenSwaps = 5 minutes;\\r\\n        minimumTokensBeforeSwap = 1000 * 10 ** decimals;\\r\\n        excludedFromTax[address(taxDistributor)] = true;\\r\\n        excludedFromTax[address(dividendDistributor)] = true;\\r\\n        taxDistributor.createBurnTax(\\\"Burn\\\", 100, 100);\\r\\n        taxDistributor.createWalletTax(\\\"Marketing\\\", 400, 400, 0x7e87dDB1A10c1E4A0EfaEC04Fe46eF3BE6179558, true);\\r\\n        taxDistributor.createWalletTax(\\\"Dev\\\", 400, 400, 0x5F1c914832fBcdCD397053dd06d29941f8b3343e, true);\\r\\n        taxDistributor.createDividendTax(\\\"Reflections\\\", 300, 300, dividendDistributorAddress(), false);\\r\\n        autoSwapTax = true;\\r\\n\\r\\n\\r\\n        // Dividends\\r\\n        dividendDistributorGas  = 500_000;\\r\\n        excludedFromDividends[pair] = true;\\r\\n        excludedFromDividends[address(taxDistributor)] = true;\\r\\n        excludedFromDividends[address(dividendDistributor)] = true;\\r\\n        autoDistributeDividends = true;\\r\\n\\r\\n\\r\\n        // Burnable\\r\\n        ableToBurn[address(taxDistributor)] = true;\\r\\n\\r\\n\\r\\n        _allowed[address(taxDistributor)][pancakeSwap] = 2**256 - 1;\\r\\n        _allowed[address(taxDistributor)][address(dividendDistributor)] = 2**256 - 1;\\r\\n        _totalSupply = _totalSupply.add(87_990_087_387_179_100 * 10 ** decimals);\\r\\n        _balances[owner] = _balances[owner].add(_totalSupply);\\r\\n        emit Transfer(address(0), owner, _totalSupply);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Overrides\\r\\n    \\r\\n    function launch() public override(AntiSniper, BaseErc20) onlyOwner {\\r\\n        super.launch();\\r\\n    }\\r\\n\\r\\n    function configure(address _owner) internal override(AntiSniper, Burnable, Taxable, Dividends, BaseErc20) {\\r\\n        super.configure(_owner);\\r\\n    }\\r\\n    \\r\\n    function preTransfer(address from, address to, uint256 value) override(AntiSniper, Taxable, BaseErc20) internal {\\r\\n        super.preTransfer(from, to, value);\\r\\n    }\\r\\n    \\r\\n    function calculateTransferAmount(address from, address to, uint256 value) override(AntiSniper, Taxable, BaseErc20) internal returns (uint256) {\\r\\n        return super.calculateTransferAmount(from, to, value);\\r\\n    }\\r\\n    \\r\\n    function postTransfer(address from, address to) override(Dividends, BaseErc20) internal {\\r\\n        super.postTransfer(from, to);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Admin methods\\r\\n\\r\\n}\\r\\n\\r\\ncontract DividendDistributor is IDividendDistributor {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 private tokenContract;\\r\\n    address private _token;\\r\\n    address private _distributor;\\r\\n\\r\\n    struct Share {\\r\\n        uint256 amount;\\r\\n        uint256 totalTokenExcluded;\\r\\n        uint256 totalTokenRealised;\\r\\n        uint256 totalNativeExcluded;\\r\\n        uint256 totalNativeRealised;\\r\\n    }\\r\\n\\r\\n\\r\\n    address[] private shareholders;\\r\\n    mapping (address =\\u003e uint256) private shareholderIndexes;\\r\\n    mapping (address =\\u003e uint256) private shareholderTokenClaims;\\r\\n\\r\\n    mapping (address =\\u003e Share) public shares;\\r\\n\\r\\n    uint256 public totalShares;\\r\\n    uint256 public totalTokenDividends;\\r\\n    uint256 public totalTokenDistributed;\\r\\n    uint256 public tokenDividendsPerShare;\\r\\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\\r\\n\\r\\n    uint256 public minPeriod = 60 minutes;\\r\\n    uint256 public minNativeDistribution = 1 * (10 ** 15);      // 0.001 BNB\\r\\n    uint256 public minTokenDistribution = 1 * (10 ** 9);        // 1 Token\\r\\n    bool public override inSwap;\\r\\n\\r\\n    uint256 private currentIndex;\\r\\n\\r\\n    event TokenDividendsDistributed(uint256 amountDistributed);\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token, \\\"can only be called by the parent token\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyDistributor() {\\r\\n        require(msg.sender == _distributor, \\\"can only be called by the tax distributor\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier swapLock() {\\r\\n        require(inSwap == false, \\\"already swapping\\\");\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    constructor (address distributor) {\\r\\n        _token = msg.sender;\\r\\n        tokenContract = IERC20(_token);\\r\\n        _distributor = distributor;\\r\\n    }\\r\\n\\r\\n    function setDistributionCriteria(uint256, uint256) external override view onlyToken {\\r\\n        require(false, \\\"use the other setDistirubtionCrtieria method\\\");\\r\\n    }\\r\\n\\r\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minTokenDistribution, uint256 _minNativeDistribution) external onlyToken {\\r\\n        minPeriod = _minPeriod;\\r\\n        minTokenDistribution = _minTokenDistribution;\\r\\n        minNativeDistribution = _minNativeDistribution;\\r\\n    }\\r\\n\\r\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\r\\n        if(amount \\u003e 0 \\u0026\\u0026 shares[shareholder].amount == 0){\\r\\n            addShareholder(shareholder);\\r\\n        }else if(amount == 0 \\u0026\\u0026 shares[shareholder].amount \\u003e 0){\\r\\n            removeShareholder(shareholder);\\r\\n        }\\r\\n\\r\\n        totalShares = totalShares.add(amount).sub(shares[shareholder].amount);\\r\\n        shares[shareholder].amount = amount;\\r\\n        shares[shareholder].totalTokenExcluded = getTokenCumulativeDividends(shares[shareholder].amount);\\r\\n    }\\r\\n\\r\\n    function depositNative() external payable override onlyDistributor {\\r\\n        require(false, \\\"only token dividends are accepted.\\\");\\r\\n    }\\r\\n    \\r\\n    function depositToken(address from, uint256 amount) external override onlyDistributor {\\r\\n        if (amount \\u003e 0) {\\r\\n            tokenContract.transferFrom(from, address(this), amount);\\r\\n            totalTokenDividends = totalTokenDividends.add(amount);\\r\\n            if (totalShares \\u003e 0) {\\r\\n                tokenDividendsPerShare = tokenDividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function process(uint256 gas) external override onlyToken swapLock {\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n\\r\\n        if(shareholderCount == 0) { return; }\\r\\n\\r\\n        uint256 gasUsed;\\r\\n        uint256 gasLeft = gasleft();\\r\\n        uint256 iterations;\\r\\n        uint256 tokenDistributed;\\r\\n\\r\\n        while(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c shareholderCount) {\\r\\n            if(currentIndex \\u003e= shareholderCount){\\r\\n                currentIndex = 0;\\r\\n            }\\r\\n            \\r\\n            if(shouldDistributeToken(shareholders[currentIndex])){\\r\\n                tokenDistributed += distributeTokenDividend(shareholders[currentIndex]);\\r\\n            }\\r\\n\\r\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n\\r\\n        emit TokenDividendsDistributed(tokenDistributed);\\r\\n    }\\r\\n\\r\\n    function shouldDistributeToken(address shareholder) private view returns (bool) {\\r\\n        return shareholderTokenClaims[shareholder] + minPeriod \\u003c block.timestamp\\r\\n        \\u0026\\u0026 getUnpaidTokenEarnings(shareholder) \\u003e minTokenDistribution;\\r\\n    }\\r\\n\\r\\n    function distributeTokenDividend(address shareholder) private returns (uint256){\\r\\n        if(shares[shareholder].amount == 0){ return 0; }\\r\\n\\r\\n        uint256 tokenAmount = getUnpaidTokenEarnings(shareholder);\\r\\n        if (tokenAmount \\u003e 0) {\\r\\n            totalTokenDistributed = totalTokenDistributed.add(tokenAmount);\\r\\n            \\r\\n            tokenContract.transfer(IOwnable(_token).owner(), tokenAmount);\\r\\n\\r\\n            shareholderTokenClaims[shareholder] = block.timestamp;\\r\\n            shares[shareholder].totalTokenRealised = shares[shareholder].totalTokenRealised.add(tokenAmount);\\r\\n            shares[shareholder].totalTokenExcluded = getTokenCumulativeDividends(shares[shareholder].amount);\\r\\n        }\\r\\n        return tokenAmount;\\r\\n    }\\r\\n\\r\\n    function claimDividend() external {\\r\\n        distributeTokenDividend(msg.sender);\\r\\n    }\\r\\n\\r\\n    function getUnpaidTokenEarnings(address shareholder) public view returns (uint256) {\\r\\n        if(shares[shareholder].amount == 0){ return 0; }\\r\\n\\r\\n        uint256 shareholderTotalDividends = getTokenCumulativeDividends(shares[shareholder].amount);\\r\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalTokenExcluded;\\r\\n\\r\\n        if(shareholderTotalDividends \\u003c= shareholderTotalExcluded){ return 0; }\\r\\n\\r\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\r\\n    }\\r\\n\\r\\n    function getTokenCumulativeDividends(uint256 share) private view returns (uint256) {\\r\\n        return share.mul(tokenDividendsPerShare).div(dividendsPerShareAccuracyFactor);\\r\\n    }\\r\\n\\r\\n    function addShareholder(address shareholder) private {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n\\r\\n    function removeShareholder(address shareholder) private {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n}\\r\\n\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ableToBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoDistributeDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoSwapTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canAlwaysTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"antiBot\",\"type\":\"address\"}],\"name\":\"configurePinkAntiBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendDistributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableBlockLogProtection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableHighTaxCountdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enablePinkAntiBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableSniperBlocking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchanges\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromSelling\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isNeverSniper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSniper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launched\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHoldAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHoldPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTimeBetweenSwaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pinkAntiBot\",\"outputs\":[{\"internalType\":\"contract IPinkAntiBot\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"runDividendsManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runSwapManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAbleToBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAutoDistributeDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAutoSwaptax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setBlockLogProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taxName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"taxAmount\",\"type\":\"uint256\"}],\"name\":\"setBuyTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setCanAlwaysTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDividendDistributionThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExchange\",\"type\":\"bool\"}],\"name\":\"setExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromSelling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExcludedFromTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setHighTaxCountdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setIsSniper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxHoldPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxSellPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setNeverSniper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setPinkAntiBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taxName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"taxAmount\",\"type\":\"uint256\"}],\"name\":\"setSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSniperBlocking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTime\",\"type\":\"uint256\"}],\"name\":\"setTaxDistributionThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"taxName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setTaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setTradingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sniperTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snipersCaught\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDistributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transactionBlockLog\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PandaGirl", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://608155cedd8cec9a56b2db1634a957b72b249f0e88ba2fa0454d6134b473bfcc"}