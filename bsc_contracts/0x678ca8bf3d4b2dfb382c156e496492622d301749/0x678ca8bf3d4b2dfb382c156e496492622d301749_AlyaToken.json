{"SourceCode": "// ALYATTES.IO 2023 \u00a9\r\n// SPDX-License-Identifier: MIT\r\n// WE DO NOT SAVE MONEY, WE SAVE PEOPLE.\r\n\r\npragma solidity ^0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the BEP20 standard as defined in the EIP.\r\n */\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/// @dev Reflection tokens have 2 units of measurement: internal and external units.\r\n/// Internal units is what\u2019s actually stored in the contract, but they are never exposed.\r\n/// balanceOf returns external units, transfer accepts external units as input, but the\r\n/// internal balances mapping stores internal units.\r\n/// The rate of conversion between internal and external units is called the reflection rate.\r\n/// The reflection rate changes constantly as tokens are burned.\r\n/// To convert internal units to external units: ET = IT * (externalSupply / internalSupply)\r\n/// To convert external units to internal units: IT = ET * (internalSupply / externalSupply)\r\n/// Internal units may be referred in the contract as \u201creflection\u201d or \u201creflected\u201d units, with the \"r\" prefix.\r\n/// External units may be referred in the contract as \u201ctoken\u201d or \u201ctokenized\u201d units, with the \"t\" prefix.\r\n\r\ncontract AlyaToken is Context, IBEP20, Ownable {\r\n    event AccountExcluded(address indexed);\r\n    event AccountIncluded(address indexed);\r\n    event MiningStarted(address indexed user, uint256 amount);\r\n    event TokenPayback(address indexed user, uint256 amount);\r\n    event NewAlyaBlock(uint256 indexed blockNumber);\r\n    event Burn(address indexed user, uint256 amount);\r\n\r\n    /// @dev Account balances\r\n    mapping(address => uint256) private _rOwned;\r\n\r\n    /// @dev Balances of excluded accounts\r\n    mapping(address => uint256) private _tOwned;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /// @dev Returns whether an account has been excluded from the ecosystem.\r\n    /// Accounts excluded from the ecosystem are not subject to fees. (e.g. charity account, exchanges, etc.)\r\n    mapping(address => bool) public isExcluded;\r\n\r\n    string private _NAME;\r\n    string private _SYMBOL;\r\n    uint256 private immutable _DECIMALS;\r\n    address public AlyaCare;\r\n\r\n    uint256 private constant _MAX = ~uint256(0);\r\n    uint256 private immutable _DECIMALFACTOR;\r\n\r\n    uint256 private _tTotal;\r\n    uint256 private _rTotal;\r\n\r\n    uint256 private _tFeeTotal;\r\n    uint256 private _tCharityTotal;\r\n\r\n    uint256 public _TAX_FEE;\r\n    uint256 public _BURN_FEE;\r\n    uint256 public _CHARITY_FEE;\r\n\r\n    uint256 public maximumTarget;\r\n    uint256 public immutable nRewarMod;\r\n    uint256 public immutable nWtime;\r\n    uint256 public lastBlock;\r\n    uint256 public immutable genesisReward;\r\n\r\n    /// @dev Tokenized supply of token held by excluded accounts.\r\n    uint256 public tExcludedSupply;\r\n\r\n    /// @dev Reflected supply of token held by excluded accounts.\r\n    uint256 public rExcludedSupply;\r\n\r\n    uint256 public constant arrayLimit = 115;\r\n\r\n    /// @dev Latest lucky block where a \"Proof-of-Activity\" sign has taken place.\r\n    uint256 public latestLuckyEthBlock;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint256 _decimals,\r\n        uint256 _supply,\r\n        uint256 _txFee,\r\n        uint256 _burnFee,\r\n        uint256 _charityFee,\r\n        address _AlyaCare,\r\n        address tokenOwner\r\n    ) {\r\n        _NAME = _name;\r\n        _SYMBOL = _symbol;\r\n        _DECIMALS = _decimals;\r\n        _DECIMALFACTOR = 10 ** _DECIMALS;\r\n        _tTotal = _supply * _DECIMALFACTOR + 1;\r\n        _rTotal = _MAX - (_MAX % _tTotal);\r\n        _TAX_FEE = _txFee;\r\n        _BURN_FEE = _burnFee;\r\n        _CHARITY_FEE = _charityFee;\r\n        maximumTarget = 0;\r\n        nRewarMod = 29743;\r\n        nWtime = 7776000;\r\n        lastBlock = 508;\r\n        genesisReward = 1;\r\n        AlyaCare = _AlyaCare;\r\n        _owner = tokenOwner;\r\n        _rOwned[address(1)] = (1 * _rTotal) / _tTotal;\r\n        _rOwned[tokenOwner] = _rTotal - _rOwned[address(1)];\r\n        emit Transfer(address(0), tokenOwner, _tTotal);\r\n        emit Transfer(tokenOwner, address(1), 1);\r\n\r\n        if (_AlyaCare != address(0)) _excludeAccount(_AlyaCare);\r\n        _excludeAccount(address(this));\r\n        _excludeAccount(address(0));\r\n        _excludeAccount(tokenOwner);\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return _NAME;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _SYMBOL;\r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return uint8(_DECIMALS);\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _tTotal - _tOwned[address(0)];\r\n    }\r\n\r\n    /// @dev Return the current supply of token in the ecosystem.\r\n    function getCurrentSupply() external view returns (uint256, uint256) {\r\n        return (_rTotal - rExcludedSupply, _tTotal - tExcludedSupply);\r\n    }\r\n\r\n    /// @dev Return the balance of account in internal units.\r\n    function balanceOfInternal(address account) external view returns (uint256) {\r\n        return _rOwned[account];\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (isExcluded[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        require(recipient != address(0), 'TOKEN20: transfer to the zero address');\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 allowance_ = _allowances[sender][_msgSender()];\r\n        require(allowance_ >= amount, 'TOKEN20: transfer amount exceeds allowance');\r\n        _approve(sender, _msgSender(), allowance_ - amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) external virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) external virtual returns (bool) {\r\n        uint256 allowance_ = _allowances[_msgSender()][spender];\r\n        require(allowance_ >= subtractedValue, 'TOKEN20: decreased allowance below zero');\r\n        _approve(_msgSender(), spender, allowance_ - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Returns the total amount of fees collected.\r\n    function totalFees() external view returns (uint256) {\r\n        return _tFeeTotal;\r\n    }\r\n\r\n    /// @dev Returns the total amount of tokens burned, both voluntarily and as transfer fees.\r\n    function totalBurn() external view returns (uint256) {\r\n        return _tOwned[address(0)];\r\n    }\r\n\r\n    /// @dev Returns the total amount of tokens donated to charity.\r\n    function totalCharity() external view returns (uint256) {\r\n        return _tCharityTotal;\r\n    }\r\n\r\n    /// @dev Distribute tAmount tokens to all holders, including yourself.\r\n    function deliver(uint256 tAmount) external {\r\n        address sender = _msgSender();\r\n        require(!isExcluded[sender], 'Excluded addresses cannot call this function');\r\n        uint256 rAmount = tAmount *\r\n            ((_rTotal - rExcludedSupply) / (_tTotal - tExcludedSupply));\r\n        _rOwned[sender] -= rAmount;\r\n        _rTotal -= rAmount;\r\n    }\r\n\r\n    /// @dev Converts external units to internal units.\r\n    function reflectionFromToken(uint256 tAmount) public view returns (uint256 rAmount) {\r\n        (uint256 rSupply, uint256 tSupply) = (\r\n            _rTotal - rExcludedSupply,\r\n            _tTotal - tExcludedSupply\r\n        );\r\n        return tAmount * (rSupply / tSupply);\r\n    }\r\n\r\n    /// @dev Converts internal units to external units.\r\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256 tAmount) {\r\n        (uint256 rSupply, uint256 tSupply) = (\r\n            _rTotal - rExcludedSupply,\r\n            _tTotal - tExcludedSupply\r\n        );\r\n        return rAmount / (rSupply / tSupply);\r\n    }\r\n\r\n    /// @dev Excludes an account from the ecosystem, making it immune to fees.\r\n    function _excludeAccount(address account) internal {\r\n        uint256 rOwnedUser = _rOwned[account];\r\n        uint256 tOwnedUser = tokenFromReflection(rOwnedUser);\r\n\r\n        _tOwned[account] = tOwnedUser;\r\n        isExcluded[account] = true;\r\n        rExcludedSupply += rOwnedUser;\r\n        tExcludedSupply += tOwnedUser;\r\n\r\n        emit AccountExcluded(account);\r\n    }\r\n\r\n    /// @dev Includes an account in the ecosystem, making it subject to fees.\r\n    function _includeAccount(address account) internal {\r\n        uint256 tOwnedUser = _tOwned[account];\r\n        uint256 rOwnedUser = reflectionFromToken(tOwnedUser);\r\n\r\n        rExcludedSupply -= rOwnedUser;\r\n        tExcludedSupply -= tOwnedUser;\r\n\r\n        _rOwned[account] = rOwnedUser;\r\n        _tOwned[account] = 0;\r\n        isExcluded[account] = false;\r\n\r\n        emit AccountIncluded(account);\r\n    }\r\n\r\n    function excludeAccount(address account) external onlyOwner {\r\n        require(!isExcluded[account], 'Account is already excluded');\r\n        require(account != address(1), 'Cannot exclude address(1)');\r\n        _excludeAccount(account);\r\n    }\r\n\r\n    function includeAccount(address account) external onlyOwner {\r\n        require(account != address(this), 'Cannot include the contract');\r\n        require(account != address(0), 'Cannot include the zero address');\r\n        require(account != AlyaCare, 'Cannot include the AlyaCare address');\r\n        require(isExcluded[account], 'Account is already included');\r\n        _includeAccount(account);\r\n    }\r\n\r\n    function setAsCharityAccount(address account) external onlyOwner {\r\n        require(account != address(0), 'zero address');\r\n        if (AlyaCare != address(0)) _includeAccount(AlyaCare);\r\n        _excludeAccount(account);\r\n        AlyaCare = account;\r\n    }\r\n\r\n    function updateFee(\r\n        uint256 _txFee,\r\n        uint256 _burnFee,\r\n        uint256 _charityFee\r\n    ) external onlyOwner {\r\n        require(_txFee <= 5 && _burnFee <= 5 && _charityFee <= 5, 'Fee must be <= 5%');\r\n        _TAX_FEE = _txFee;\r\n        _BURN_FEE = _burnFee;\r\n        _CHARITY_FEE = _charityFee;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), 'TOKEN20: approve from the zero address');\r\n        require(spender != address(0), 'TOKEN20: approve to the zero address');\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function burn(uint256 tAmount) external {\r\n        require(tAmount > 0, 'Burn amount must be greater than zero');\r\n        address sender = _msgSender();\r\n        _transfer(sender, address(0), tAmount);\r\n        emit Burn(sender, tAmount);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 tAmount) private {\r\n        require(sender != address(0), 'TOKEN20: transfer from the zero address');\r\n        require(sender != address(1), 'TOKEN20: transfer from address(1)');\r\n        require(tAmount > 0, 'Transfer amount must be greater than zero');\r\n        require(tAmount <= balanceOf(sender), 'Transfer amount exceeds balance');\r\n\r\n        uint256 reflectionRate = (_rTotal - rExcludedSupply) /\r\n            (_tTotal - tExcludedSupply);\r\n        bool isExcludedSender = isExcluded[sender];\r\n        bool isExcludedRecipient = isExcluded[recipient];\r\n\r\n        if (isExcludedSender && isExcludedRecipient) {\r\n            _tOwned[sender] -= tAmount;\r\n            _tOwned[recipient] += tAmount;\r\n\r\n            emit Transfer(sender, recipient, tAmount);\r\n        } else if (!isExcludedSender && isExcludedRecipient) {\r\n            _rOwned[sender] -= tAmount * reflectionRate;\r\n            _tOwned[recipient] += tAmount;\r\n\r\n            rExcludedSupply += tAmount * reflectionRate;\r\n            tExcludedSupply += tAmount;\r\n\r\n            emit Transfer(sender, recipient, tAmount);\r\n        } else {\r\n            // The standard transfer happens in 4 steps:\r\n            // 1) transfer the entire specified amount to the recipient\r\n            // 2) burn the appropriate amount of token, updating supply counters accordingly\r\n            // 3) distribute the appropriate amount of token, updating balances accordingly\r\n            //    the sender's balance remains the same - tokens are distributed among everyone else\r\n            // 4) transfer the appropriate amount to the charity wallet\r\n\r\n            // Step 1: transfer. This step does not change the reflection rate.\r\n            if (isExcludedSender && !isExcludedRecipient) {\r\n                _tOwned[sender] -= tAmount;\r\n                _rOwned[recipient] += tAmount * reflectionRate;\r\n\r\n                rExcludedSupply -= tAmount * reflectionRate;\r\n                tExcludedSupply -= tAmount;\r\n            } else {\r\n                uint256 rTransferAmount = tAmount * reflectionRate;\r\n                _rOwned[sender] -= rTransferAmount;\r\n                _rOwned[recipient] += rTransferAmount;\r\n            }\r\n\r\n            // Step 2: burn. This step does not change the reflection rate.\r\n            uint256 tBurnAmount = (tAmount * _BURN_FEE) / 100;\r\n            {\r\n                rExcludedSupply += tBurnAmount * reflectionRate;\r\n                _rOwned[recipient] -= tBurnAmount * reflectionRate;\r\n                tExcludedSupply += tBurnAmount;\r\n                emit Transfer(sender, address(0), tBurnAmount);\r\n            }\r\n\r\n            // Step 3: redistribute tax. This step DOES change the reflection rate.\r\n            uint256 tDistributeAmount = (tAmount * _TAX_FEE) / 100;\r\n            {\r\n                uint256 rDistributeAmount = tDistributeAmount * reflectionRate;\r\n                _rTotal -= rDistributeAmount;\r\n                _rOwned[recipient] -= rDistributeAmount;\r\n\r\n                reflectionRate =\r\n                    (_rTotal - rExcludedSupply) /\r\n                    (_tTotal - tExcludedSupply);\r\n            }\r\n\r\n            // Step 4: transfer to charity. This step does not change the reflection rate.\r\n            uint256 tCharityAmount = (tAmount * _CHARITY_FEE) / 100;\r\n            if (AlyaCare != address(0)) {\r\n                uint256 rCharityAmount = tCharityAmount * reflectionRate;\r\n                _tOwned[AlyaCare] += tCharityAmount;\r\n                _rOwned[recipient] -= rCharityAmount;\r\n                rExcludedSupply += rCharityAmount;\r\n                tExcludedSupply += tCharityAmount;\r\n                emit Transfer(sender, AlyaCare, tCharityAmount);\r\n            } else tCharityAmount = 0;\r\n\r\n            emit Transfer(\r\n                sender,\r\n                recipient,\r\n                tAmount - tBurnAmount - tDistributeAmount - tCharityAmount\r\n            );\r\n\r\n            // update fancy totals\r\n            _tFeeTotal += tDistributeAmount;\r\n            _tOwned[address(0)] += tBurnAmount;\r\n            _tCharityTotal += tCharityAmount;\r\n        }\r\n    }\r\n\r\n    struct stakeInfo {\r\n        uint256 _stocktime;\r\n        uint256 _stockamount;\r\n    }\r\n\r\n    address[] totalminers;\r\n\r\n    mapping(address => stakeInfo) nStockDetails;\r\n\r\n    struct rewarddetails {\r\n        uint256 _artyr;\r\n        bool _didGetReward;\r\n        bool _didisign;\r\n    }\r\n\r\n    mapping(string => rewarddetails) nRewardDetails;\r\n\r\n    struct nBlockDetails {\r\n        uint256 _bTime;\r\n        uint256 _tInvest;\r\n    }\r\n\r\n    mapping(uint256 => nBlockDetails) bBlockIteration;\r\n\r\n    struct activeMiners {\r\n        address bUser;\r\n    }\r\n\r\n    mapping(uint256 => activeMiners[]) aMiners;\r\n\r\n    function uintToString(uint256 v) internal pure returns (string memory str) {\r\n        uint256 maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint256 i = 0;\r\n        while (v != 0) {\r\n            uint256 remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = bytes1(uint8(48 + remainder));\r\n        }\r\n        bytes memory s = new bytes(i + 1);\r\n        for (uint256 j = 0; j <= i; j++) {\r\n            s[j] = reversed[i - j];\r\n        }\r\n        str = string(s);\r\n    }\r\n\r\n    function totalMinerCount() external view returns (uint256) {\r\n        return totalminers.length;\r\n    }\r\n\r\n    function addressHashs() public view returns (uint256) {\r\n        return uint256(uint160(msg.sender)) % 10000000000;\r\n    }\r\n\r\n    function append(\r\n        string memory a,\r\n        string memory b\r\n    ) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, '-', b));\r\n    }\r\n\r\n    function generalCheckPoint() private view returns (string memory) {\r\n        return append(uintToString(addressHashs()), uintToString(lastBlock));\r\n    }\r\n\r\n    function stakerStatus(address _addr) public view returns (bool) {\r\n        if (nStockDetails[_addr]._stocktime == 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function stakerAmount(address _addr) external view returns (uint256) {\r\n        if (nStockDetails[_addr]._stocktime == 0) {\r\n            return 0;\r\n        } else {\r\n            return nStockDetails[_addr]._stockamount;\r\n        }\r\n    }\r\n\r\n    function stakerTimeStart(address _addr) external view returns (uint256) {\r\n        return nStockDetails[_addr]._stocktime;\r\n    }\r\n\r\n    function stakerActiveTotal() external view returns (uint256) {\r\n        return aMiners[lastBlock].length;\r\n    }\r\n\r\n    function getContractAddress() external view returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    /// @dev Start \"mining\" (staking) tokens.\r\n    /// @param mineamount The amount of tokens to be staked.\r\n    function startMining(uint256 mineamount) external returns (uint256) {\r\n        uint256 realMineAmount = mineamount * _DECIMALFACTOR;\r\n        require(balanceOf(msg.sender) >= realMineAmount, 'not enough token');\r\n        require(realMineAmount >= 500 * _DECIMALFACTOR);\r\n        require(nStockDetails[msg.sender]._stocktime == 0);\r\n        nStockDetails[msg.sender]._stocktime = block.timestamp;\r\n        nStockDetails[msg.sender]._stockamount = realMineAmount;\r\n        maximumTarget += mineamount;\r\n        totalminers.push(msg.sender);\r\n\r\n        if (!isExcluded[msg.sender]) _excludeAccount(msg.sender);\r\n\r\n        _transfer(msg.sender, address(this), realMineAmount);\r\n        emit MiningStarted(msg.sender, mineamount);\r\n        return 200;\r\n    }\r\n\r\n    /// @dev Stop mining and get your stake back.\r\n    function tokenPayBack() external returns (uint256) {\r\n        require(stakerStatus(msg.sender));\r\n        require(nStockDetails[msg.sender]._stocktime + nWtime < block.timestamp);\r\n        nStockDetails[msg.sender]._stocktime = 0;\r\n        maximumTarget -= uint256(nStockDetails[msg.sender]._stockamount) / _DECIMALFACTOR;\r\n        _transfer(\r\n            address(this),\r\n            msg.sender,\r\n            uint256(nStockDetails[msg.sender]._stockamount)\r\n        );\r\n        if (isExcluded[msg.sender]) _includeAccount(msg.sender);\r\n        emit TokenPayback(msg.sender, nStockDetails[msg.sender]._stockamount);\r\n        return nStockDetails[msg.sender]._stockamount;\r\n    }\r\n\r\n    /// @dev Do a \"Proof-of-Activity\" sign at a specified recent block.\r\n    /// @param _bnumber The block when the sign is done.\r\n    function necessarySignForReward(uint256 _bnumber) external returns (uint256) {\r\n        require(stakerStatus(msg.sender));\r\n        require((block.number - 1) - _bnumber <= 150);\r\n        require(nStockDetails[msg.sender]._stocktime + nWtime > block.timestamp);\r\n        require(latestLuckyEthBlock == _bnumber || latestLuckyEthBlock + 3600 < _bnumber);\r\n        require(uint256(blockhash(_bnumber)) % nRewarMod == 1);\r\n        latestLuckyEthBlock = _bnumber;\r\n\r\n        if (bBlockIteration[lastBlock]._bTime + 1800 < block.timestamp) {\r\n            lastBlock += 1;\r\n            emit NewAlyaBlock(lastBlock);\r\n            bBlockIteration[lastBlock]._bTime = block.timestamp;\r\n        }\r\n        require(nRewardDetails[generalCheckPoint()]._artyr == 0);\r\n\r\n        bBlockIteration[lastBlock]._tInvest += nStockDetails[msg.sender]._stockamount;\r\n        nRewardDetails[generalCheckPoint()]._artyr = block.timestamp;\r\n        nRewardDetails[generalCheckPoint()]._didGetReward = false;\r\n        nRewardDetails[generalCheckPoint()]._didisign = true;\r\n        aMiners[lastBlock].push(activeMiners(msg.sender));\r\n        return 200;\r\n    }\r\n\r\n    /// @dev Get the reward for \"mining\" a block.\r\n    /// @param _bnumber The block to get the reward for.\r\n    function rewardGet(uint256 _bnumber) external returns (uint256) {\r\n        require(stakerStatus(msg.sender));\r\n        require((block.number - 1) - _bnumber > 150);\r\n        require(uint256(blockhash(_bnumber)) % nRewarMod == 1);\r\n        require(nStockDetails[msg.sender]._stocktime + nWtime > block.timestamp);\r\n        require(!nRewardDetails[generalCheckPoint()]._didGetReward);\r\n        require(nRewardDetails[generalCheckPoint()]._didisign);\r\n\r\n        uint256 halving = lastBlock / 300;\r\n        uint256 totalRA = 58000 * _DECIMALFACTOR;\r\n        if (halving == 0) {\r\n            totalRA = 58000 * _DECIMALFACTOR;\r\n        } else if (halving == 1) {\r\n            totalRA = 81000 * _DECIMALFACTOR;\r\n        } else if (halving == 2) {\r\n            totalRA = 98000 * _DECIMALFACTOR;\r\n        } else if (halving == 3) {\r\n            totalRA = 109000 * _DECIMALFACTOR;\r\n        } else if (halving == 4) {\r\n            totalRA = 100000 * _DECIMALFACTOR;\r\n        } else {\r\n            totalRA = 0;\r\n        }\r\n\r\n        uint256 usersReward = ((totalRA *\r\n            (nStockDetails[msg.sender]._stockamount * 100)) /\r\n            bBlockIteration[lastBlock]._tInvest) / 100;\r\n        nRewardDetails[generalCheckPoint()]._didGetReward = true;\r\n\r\n        _transfer(address(this), msg.sender, usersReward);\r\n        return usersReward;\r\n    }\r\n\r\n    struct memoInfo {\r\n        uint256 _receiveTime;\r\n        uint256 _receiveAmount;\r\n        address _senderAddr;\r\n        string _senderMemo;\r\n    }\r\n\r\n    mapping(address => memoInfo[]) memoGetProcess;\r\n\r\n    function sendMemoToken(\r\n        uint256 _amount,\r\n        address _to,\r\n        string memory _memo\r\n    ) external returns (uint256) {\r\n        memoGetProcess[_to].push(memoInfo(block.timestamp, _amount, msg.sender, _memo));\r\n        _transfer(msg.sender, _to, _amount);\r\n        return 200;\r\n    }\r\n\r\n    function sendMemoOnly(address _to, string memory _memo) external returns (uint256) {\r\n        memoGetProcess[_to].push(memoInfo(block.timestamp, 0, msg.sender, _memo));\r\n        _transfer(msg.sender, _to, 0);\r\n        return 200;\r\n    }\r\n\r\n    function yourMemos(\r\n        address _addr,\r\n        uint256 _index\r\n    ) external view returns (uint256, uint256, string memory, address) {\r\n        uint256 rTime = memoGetProcess[_addr][_index]._receiveTime;\r\n        uint256 rAmount = memoGetProcess[_addr][_index]._receiveAmount;\r\n        string memory sMemo = memoGetProcess[_addr][_index]._senderMemo;\r\n        address sAddr = memoGetProcess[_addr][_index]._senderAddr;\r\n        if (memoGetProcess[_addr][_index]._receiveTime == 0) {\r\n            return (0, 0, '0', _addr);\r\n        } else {\r\n            return (rTime, rAmount, sMemo, sAddr);\r\n        }\r\n    }\r\n\r\n    function yourMemosCount(address _addr) external view returns (uint256) {\r\n        return memoGetProcess[_addr].length;\r\n    }\r\n\r\n    function appendMemos(\r\n        string memory a,\r\n        string memory b,\r\n        string memory c,\r\n        string memory d\r\n    ) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a, '#', b, '#', c, '#', d));\r\n    }\r\n\r\n    function addressToString(address _addr) public pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(uint160(_addr)));\r\n        bytes memory alphabet = '0123456789abcdef';\r\n\r\n        bytes memory str = new bytes(51);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            str[2 + i * 2] = alphabet[uint256(uint8(value[i + 12] >> 4))];\r\n            str[3 + i * 2] = alphabet[uint256(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function getYourMemosOnly(address _addr) external view returns (string[] memory) {\r\n        uint256 total = memoGetProcess[_addr].length;\r\n        string[] memory messages = new string[](total);\r\n\r\n        for (uint256 i = 0; i < total; i++) {\r\n            messages[i] = appendMemos(\r\n                uintToString(memoGetProcess[_addr][i]._receiveTime),\r\n                memoGetProcess[_addr][i]._senderMemo,\r\n                uintToString(memoGetProcess[_addr][i]._receiveAmount),\r\n                addressToString(memoGetProcess[_addr][i]._senderAddr)\r\n            );\r\n        }\r\n\r\n        return messages;\r\n    }\r\n\r\n    /// @dev Batch transfer.\r\n    function alyaMultiSend(\r\n        address[] memory _receivers,\r\n        uint256[] memory _amounts\r\n    ) external {\r\n        require(\r\n            _receivers.length <= arrayLimit,\r\n            'Array length should not exceed limit 115'\r\n        );\r\n        require(\r\n            _receivers.length == _amounts.length,\r\n            'Addresses must equal amounts size.'\r\n        );\r\n\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            _transfer(_msgSender(), _receivers[i], _amounts[i]);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_charityFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_AlyaCare\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AccountExcluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"AccountIncluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MiningStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"NewAlyaBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPayback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AlyaCare\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BURN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CHARITY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressHashs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"alyaMultiSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arrayLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOfInternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getYourMemosOnly\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestLuckyEthBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nRewarMod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nWtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnumber\",\"type\":\"uint256\"}],\"name\":\"necessarySignForReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rExcludedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnumber\",\"type\":\"uint256\"}],\"name\":\"rewardGet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_memo\",\"type\":\"string\"}],\"name\":\"sendMemoOnly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_memo\",\"type\":\"string\"}],\"name\":\"sendMemoToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setAsCharityAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakerActiveTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"stakerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"stakerStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"stakerTimeStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mineamount\",\"type\":\"uint256\"}],\"name\":\"startMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tExcludedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPayBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCharity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_charityFee\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"yourMemos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"yourMemosCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AlyaToken", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000c380d400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007fec4ea343a1e948604772e4f42609bd74b5ed87000000000000000000000000e0ae223bba0d4ed7b865d9768d657e2121829da60000000000000000000000000000000000000000000000000000000000000008414c5941545445530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004414c594100000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://64df8b0632e00b5839bc0651b999f9fa961df549aebebe1697d516b4349058a1"}