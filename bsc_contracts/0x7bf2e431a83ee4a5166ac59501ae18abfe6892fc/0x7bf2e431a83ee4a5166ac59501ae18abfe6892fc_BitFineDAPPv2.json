{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\ninterface IDAPP {\r\n    function getUserData(address account) external view returns\r\n    (   \r\n        uint256 balance_,\r\n        uint256 unclaimROI_,\r\n        uint256 commission_,\r\n        uint256 withdraw_,\r\n        uint256 actionBlock_,\r\n        address referral_,\r\n        bool registered_\r\n    );\r\n    function getUserRefereeMapping(address account,uint256 deeplevel) external view returns (address[] memory);\r\n    function getReceiveETH(address account,uint256 slot) external view returns (uint256);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract BitFineDAPPv2 is Ownable {\r\n\r\n    IDEXRouter public router;\r\n\r\n    address constant zero = address(0);\r\n    address constant dead = address(0xdead);\r\n\r\n    uint256 public minimumDeposit = 25 * 1e16;\r\n    uint256 public maximumDeposit = 10 * 1e18;\r\n\r\n    uint256 public loanFee = 1000;\r\n    uint256 public loanRatio = 2100;\r\n\r\n    uint256 public unlockAmount;\r\n    uint256 public unlockValue;\r\n\r\n    uint256 maxProfitPercent = 20000;\r\n\r\n    uint256[] ROIAmount = [30,70,110,150,200];\r\n    uint256[] ROIRequirement = [0,1,3,10,25];\r\n\r\n    uint256[] topWinnerReward = [1500,3500,5000];\r\n    uint256[] referralAmount = [1000,100,50,50,50,50,50,50,50,50];\r\n\r\n    uint256[] withdrawFee = [2000,1500,1000];\r\n    uint256[] withdrawFilter = [0,1e17,1e18];\r\n\r\n    address tokenAddress = 0x07D675Fa3C17259E6F2999A998ec099Ae27aeee1;\r\n    uint256 depositFeeToTop3 = 250;\r\n    uint256 depositFeeToSwap = 250;\r\n\r\n    address treasuryWallet = 0xDfa46f9fdFa76bEcB20ccf023879E4521a010d6E;\r\n    address[] marketingWallet = [\r\n        0x6F6d6E7D05EF8C87f50183b017133037D891a6A9,\r\n        0x0EbEC1DC1877003EEd15431f15352eC868A5D971,\r\n        0x33bf98f8ae9009b9c2cD57BfD0dD838D4668eFa5,\r\n        0x0812bAfe626C793B24AEe89B3186223Db68355B4\r\n    ];\r\n\r\n    uint256 depositFeeToMarketing = 500;\r\n    uint256 withdrawFeeToTreasury = 5000;\r\n\r\n    uint day = 86400;\r\n    uint256 denominator = 10000;\r\n\r\n    address[] users;\r\n\r\n    struct userData {\r\n        uint256 balance;\r\n        uint256 unclaimROI;\r\n        uint256 commission;\r\n        uint256 withdraw;\r\n        uint256 actionBlock;\r\n        address referral;\r\n        mapping(uint256 => address[]) referee;\r\n        mapping(uint256 => uint256) claimed;\r\n        mapping(uint256 => uint256) receiveETH;\r\n        bool registered;\r\n        uint256 maxDepositBonus;\r\n    }\r\n\r\n    mapping(address => userData) user;\r\n\r\n    struct loadData {\r\n        bool isFreeze;\r\n        uint256 replyAmount;\r\n    }\r\n\r\n    mapping(address => loadData) loan;\r\n\r\n    uint256 genesisBlock;\r\n\r\n    struct Top3Data {\r\n        address[] account;\r\n        uint256[] amount;\r\n        uint256 reward;\r\n        bool init;\r\n    }\r\n\r\n    struct Top3Winner {\r\n        address[] account;\r\n        uint256[] amount;\r\n    }\r\n\r\n    mapping(uint256 => Top3Data) top3;\r\n    mapping(uint256 => Top3Winner) top3Winner;\r\n\r\n    mapping(address => bool) public isMigrate;\r\n    mapping(address => mapping(uint256 => uint256)) public top3Key;\r\n    mapping(address => mapping(uint256 => bool)) public isTopAdsigned;\r\n    mapping(address => mapping(uint256 => bool)) public isTopClaimed;\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() {\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        register(msg.sender,zero,referralAmount.length);\r\n        genesisBlock = 1702051200;\r\n    }\r\n\r\n    function getUsers() public view returns (address[] memory) {\r\n        return users;\r\n    }\r\n\r\n    function getTop3WinnerReward() public view returns (uint256[] memory) {\r\n        return topWinnerReward;\r\n    }\r\n\r\n    function getTop3Winner(uint256 round) public view returns (address[] memory,uint256[] memory) {\r\n        return (top3Winner[round].account,top3Winner[round].amount);\r\n    }\r\n\r\n    function getLoanData(address account) public view returns (loadData memory) {\r\n        return loan[account];\r\n    }\r\n\r\n    function getUserData(address account) public view returns (uint256[] memory uintSet_,address referral_,bool registered_,bool isFreeze_) {\r\n        uint256[] memory uintSet = new uint256[](6);\r\n        uintSet[0] = user[account].balance;\r\n        uintSet[1] = user[account].unclaimROI;\r\n        uintSet[2] = user[account].commission;\r\n        uintSet[3] = user[account].withdraw;\r\n        uintSet[4] = user[account].actionBlock;\r\n        uintSet[5] = user[account].maxDepositBonus;\r\n        return (uintSet,user[account].referral,user[account].registered,loan[account].isFreeze);\r\n    }\r\n\r\n    function getTop3Data(uint256 round) public view returns\r\n    (\r\n        address[] memory account_,\r\n        uint256[] memory amount_,\r\n        uint256 reward_,\r\n        bool init_\r\n    ) {\r\n        return (\r\n            top3[round].account,\r\n            top3[round].amount,\r\n            top3[round].reward,\r\n            top3[round].init\r\n        );\r\n    }\r\n\r\n    function getUserRefereeMapping(address account,uint256 deeplevel) public view returns (address[] memory) {\r\n        return user[account].referee[deeplevel];\r\n    }\r\n\r\n    function getUserReferralMapping(address account,uint256 upperlevel) public view returns (address[] memory) {\r\n        address[] memory referrals = new address[](upperlevel);\r\n        for(uint256 i=0; i<upperlevel; i++){\r\n            referrals[i] = user[account].referral;\r\n            account = user[account].referral;\r\n        }\r\n        return referrals;\r\n    }\r\n\r\n    function getUserClaimed(address account,uint256 slot) public view returns (uint256) {\r\n        return (user[account].claimed[slot]);\r\n    }\r\n\r\n    function getReceiveETH(address account,uint256 slot) public view returns (uint256) {\r\n        return (user[account].receiveETH[slot]);\r\n    }\r\n\r\n    function register(address referee,address referral,uint256 deepLevel) internal {\r\n        if(!user[referee].registered){\r\n            user[referee].registered = true;\r\n            user[referee].referral = referral;\r\n            users.push(referee);\r\n            for(uint256 i = 0; i < deepLevel; i++){\r\n                if(!isDeadAddress(referral)){\r\n                    user[referral].referee[i].push(referee);\r\n                }\r\n                referral = user[referral].referral;\r\n            }\r\n        }\r\n    }\r\n\r\n    function deposit(address referee,address referral) public payable noReentrant returns (bool) {\r\n        require(msg.value>=minimumDeposit,\"BitFine Revert: Need More ETH For Deposit\");\r\n        uint256 afterDeposit = user[referee].balance + msg.value;\r\n        uint256 maxAllowcate = user[referee].maxDepositBonus + maximumDeposit;\r\n        require(afterDeposit<=maxAllowcate,\"BitFine Revert: Maximum Amount ETH For Deposit\");\r\n        if(!user[referee].registered){\r\n            require(user[referral].registered,\"BitFine Revert: Referral Address Must Be Registered\");\r\n            require(referee!=referral,\"BitFine Revert: Referee Must Not Be Referral\");\r\n            claimInternal(referral);\r\n            register(referee,referral,referralAmount.length);\r\n        }\r\n        claimInternal(referee);\r\n        address[] memory upline = new address[](referralAmount.length);\r\n        upline = getUserReferralMapping(referee,referralAmount.length);\r\n        updateTop3Amount(upline[0],msg.value);\r\n        uint256 amountToSplit = getFeeAmount(msg.value,depositFeeToMarketing,denominator)/marketingWallet.length;\r\n        for(uint256 i = 0; i < marketingWallet.length; i++){\r\n            sendValue(marketingWallet[i],amountToSplit);\r\n        }\r\n        autoLiquidity(getFeeAmount(msg.value,depositFeeToSwap,denominator));\r\n        for(uint256 i = 0; i < referralAmount.length; i++){\r\n            uint256 receiveETH = getFeeAmount(msg.value,referralAmount[i],denominator);\r\n            uint256 toCommission = getNonOverpayAmount(upline[i],receiveETH);\r\n            user[upline[i]].commission += toCommission;\r\n            user[upline[i]].receiveETH[i] += toCommission;\r\n        }\r\n        user[referee].balance += msg.value;\r\n        return true;\r\n    }\r\n\r\n    function updateTop3Amount(address account,uint256 amount) internal {\r\n        uint256 round = getCurrentRound();\r\n        if(!top3[round].init){\r\n            top3[round].init = true;\r\n            top3Winner[round].account = new address[](topWinnerReward.length);\r\n            top3Winner[round].amount = new uint256[](topWinnerReward.length);\r\n        }\r\n        top3[round].reward += amount;\r\n        if(!isTopAdsigned[account][round]){\r\n            top3[round].account.push(account);\r\n            top3[round].amount.push(amount);\r\n            isTopAdsigned[account][round] = true;\r\n            top3Key[account][round] = top3[round].account.length - 1;\r\n        }else{\r\n            top3[round].amount[top3Key[account][round]] += amount;\r\n        }\r\n        uint256 score = top3[round].amount[top3Key[account][round]];\r\n        (bool isWinner,uint256 index) = isTopWinner(account,round);\r\n        if(isWinner){\r\n            top3Winner[round].account[index] = account;\r\n            top3Winner[round].amount[index] = score;\r\n        }else{\r\n            for (uint256 i = 0; i < topWinnerReward.length ; i++) {\r\n                if(score > top3Winner[round].amount[i]){\r\n                    top3Winner[round].account[i] = account;\r\n                    top3Winner[round].amount[i] = score;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        sortWinnerData(round);\r\n    }\r\n\r\n    function isTopWinner(address account,uint256 round) public view returns (bool,uint256) {\r\n        if(top3Winner[round].account.length>0){\r\n            for (uint256 i = 0; i < top3Winner[round].account.length ; i++) {\r\n                if(top3Winner[round].account[i]==account){\r\n                    return (true,i);\r\n                }\r\n            }\r\n        }\r\n        return (false,0);\r\n    }\r\n\r\n    function sortWinnerData(uint256 round) internal {\r\n        for (uint256 i = 1; i < topWinnerReward.length; i++) {\r\n            address addr = top3Winner[round].account[i];\r\n            uint256 key = top3Winner[round].amount[i];\r\n            int j = int(i) - 1;\r\n            while ((int(j) >= 0) && (top3Winner[round].amount[uint256(j)] > key)) {\r\n                top3Winner[round].account[uint256(j+1)] = top3Winner[round].account[uint256(j)];\r\n                top3Winner[round].amount[uint256(j+1)] = top3Winner[round].amount[uint256(j)];\r\n                j--;\r\n            }\r\n            top3Winner[round].account[uint256(j+1)] = addr;\r\n            top3Winner[round].amount[uint256(j+1)] = key;\r\n        }\r\n    }\r\n\r\n    function getCurrentRound() public view returns (uint256) {\r\n        if(block.timestamp>genesisBlock){\r\n            uint256 period = block.timestamp - genesisBlock;\r\n            return period / day;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function autoLiquidity(uint256 amount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = tokenAddress;\r\n        try router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amount / 2 }(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        ) {} catch {}\r\n\r\n        uint256 amountTokenDesired = IERC20(tokenAddress).balanceOf(address(this));\r\n        IERC20(tokenAddress).approve(address(router),amountTokenDesired);\r\n\r\n        try router.addLiquidityETH{ value: amount / 2 }(\r\n            tokenAddress,\r\n            amountTokenDesired,\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        ) {} catch {}\r\n    }\r\n\r\n    function getROI(address account) public view returns (uint256) {\r\n        uint256 i = ROIRequirement.length - 1;\r\n        do{\r\n            if(user[account].referee[0].length>=ROIRequirement[i]){\r\n                return ROIAmount[i];\r\n            }\r\n            i--;\r\n        }while(i>0);\r\n        return ROIAmount[0];\r\n    }\r\n\r\n    function claimROI(address account) external noReentrant returns (bool) {\r\n        claimInternal(account);\r\n        uint256 unclaimROI = user[account].unclaimROI;\r\n        uint256 amountToWithdraw = takeFeeAmount(unclaimROI,getWithdrawFee(unclaimROI),denominator);\r\n        uint256 amountToMarketing = getFeeAmount(unclaimROI,getWithdrawFee(unclaimROI),denominator);\r\n        uint256 amountToTreasury = getFeeAmount(amountToMarketing,withdrawFeeToTreasury,denominator);\r\n        uint256 amountToSplit = (amountToMarketing - amountToTreasury) / marketingWallet.length;\r\n        user[account].unclaimROI = 0;\r\n        user[account].withdraw += amountToWithdraw;\r\n        user[account].claimed[0] += amountToWithdraw;\r\n        sendValue(account,amountToWithdraw);\r\n        sendValue(treasuryWallet,amountToTreasury);\r\n        for(uint256 i = 0; i < marketingWallet.length; i++){\r\n            sendValue(marketingWallet[i],amountToSplit);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function claimCommission(address account) external noReentrant returns (bool) {\r\n        uint256 commission = user[account].commission;\r\n        user[account].commission = 0;\r\n        user[account].withdraw += commission;\r\n        user[account].claimed[1] += commission;\r\n        sendValue(account,commission);\r\n        return true;\r\n    }\r\n\r\n    function claimTop3Reward(address account,uint256 round) external noReentrant returns (bool) {\r\n        require(!isTopClaimed[account][round],\"BitFine Revert: This Account Was Claimed\");\r\n        require(getCurrentRound()>round,\"BitFine Revert: This Round Was Not Ended\");\r\n        isTopClaimed[account][round] = true;\r\n        bool isWinner;\r\n        uint256 index;\r\n        for(uint256 i = 0; i < topWinnerReward.length; i++){\r\n            if(account==top3Winner[round].account[i]){\r\n                isWinner = true; index = i;\r\n                break;\r\n            }\r\n        }\r\n        require(isWinner,\"BitFine Revert: This Account Does Not Win This Round\");\r\n        uint256 rewardToBePaid = top3[round].reward * depositFeeToTop3 / denominator;\r\n        uint256 rewardToBeClaim = rewardToBePaid * topWinnerReward[index] / denominator;\r\n        user[account].claimed[2] += rewardToBeClaim;\r\n        sendValue(account,rewardToBeClaim);\r\n        return true;\r\n    }\r\n\r\n    function claimInternal(address account) internal {\r\n        uint256 toClaimAmount = getROIRewards(account);\r\n        user[account].actionBlock = block.timestamp;\r\n        user[account].unclaimROI += toClaimAmount;\r\n    }\r\n\r\n    function getAccountReward(address account) public view returns (uint256) {\r\n        return getROIRewards(account) + user[account].unclaimROI;\r\n    }\r\n\r\n    function getROIRewards(address account) public view returns (uint256) {\r\n        if(user[account].actionBlock>0 && !loan[account].isFreeze){\r\n            uint256 period = block.timestamp - user[account].actionBlock;\r\n            uint256 ROI = user[account].balance * getROI(account) / denominator;\r\n            uint256 reward = ROI * period / day;\r\n            return getNonOverpayAmount(account,reward);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getNonOverpayAmount(address account,uint256 amount) public view returns (uint256) {\r\n        if(getStuckAmount(account) + amount > getMaxEarnAmount(account)){\r\n            return getMaxEarnAmount(account) - getStuckAmount(account);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    function getMaxEarnAmount(address account) public view returns (uint256) {\r\n        return user[account].balance * maxProfitPercent / 10000;\r\n    }\r\n\r\n    function getStuckAmount(address account) public view returns (uint256) {\r\n        return user[account].withdraw + user[account].unclaimROI + user[account].commission;\r\n    }\r\n\r\n    function getmaxProfitPercent() public view returns (uint256) {\r\n        return maxProfitPercent;\r\n    }\r\n\r\n    function getReferralAmount() public view returns (uint256[] memory) {\r\n        return referralAmount;\r\n    }\r\n\r\n    function getWithdrawFees() public view returns (uint256[] memory,uint256[] memory) {\r\n        return (withdrawFee,withdrawFilter);\r\n    }\r\n\r\n    function getROIAmount() public view returns (uint256[] memory,uint256[] memory) {\r\n        return (ROIAmount,ROIRequirement);\r\n    }\r\n\r\n    function getMarketingFees() public view returns \r\n    (\r\n        address treasuryWallet_,\r\n        address[] memory marketingWallet_,\r\n        uint256 depositFeeToTop3_,\r\n        uint256 depositFeeToMarketing_,\r\n        uint256 withdrawFeeToTreasury_\r\n    ) {\r\n        return (\r\n            treasuryWallet,\r\n            marketingWallet,\r\n            depositFeeToTop3,\r\n            depositFeeToMarketing,\r\n            withdrawFeeToTreasury\r\n        );\r\n    }\r\n\r\n    function getExternalReacts() public view returns \r\n    (\r\n        address tokenAddress_,\r\n        uint256 depositFeeToSwap_\r\n    ) {\r\n        return (\r\n            tokenAddress,\r\n            depositFeeToSwap\r\n        );\r\n    }\r\n\r\n    function accountShouldMigrate(address account) public view returns (bool) {\r\n        IDAPP bitfine = IDAPP(0x2eFA1bFa04Dfa837846f447a462cd4dc1380A538);\r\n        (,,,,,,bool reg) = bitfine.getUserData(account);\r\n        if(reg && !isMigrate[account]){ return true; }\r\n        return false;\r\n    }\r\n\r\n    function unlockMaxDeposit(address account) public returns (bool) {\r\n        require(unlockAmount>0,\"BitFine Revert: This Function temporary disabled\");\r\n        IERC20 token = IERC20(tokenAddress);\r\n        token.transferFrom(msg.sender,address(this),unlockAmount);\r\n        user[account].maxDepositBonus += unlockValue;\r\n        return true;\r\n    }\r\n\r\n    function migrateUser(address account) public payable noReentrant returns (bool) {\r\n        require(!isMigrate[account],\"BitFine Revert: This Account Was Migrate\");\r\n        require(account==msg.sender || owner()==msg.sender,\"BitFine Revert: Permission Deney Access\");\r\n        isMigrate[account] = true;\r\n        IDAPP bitfine = IDAPP(0x2eFA1bFa04Dfa837846f447a462cd4dc1380A538);\r\n        uint256[] memory dataSet = new uint256[](6);\r\n        (uint256 b,uint256 u,uint256 c,uint256 w,uint256 a,address ref,bool reg) = bitfine.getUserData(account);\r\n        require(reg,\"BitFine Revert: Migrate Account Must Be In V1\");\r\n        if(account!=owner()){ users.push(account); }\r\n        dataSet[0] = b;\r\n        dataSet[1] = u;\r\n        dataSet[2] = c;\r\n        dataSet[3] = w;\r\n        dataSet[4] = a;\r\n        dataSet[5] = 0;\r\n        updateUserData(account,ref,true,false,dataSet);\r\n        updateUserReferee(account,0,bitfine.getUserRefereeMapping(account,0));\r\n        updateUserReferee(account,1,bitfine.getUserRefereeMapping(account,1));\r\n        updateUserReferee(account,2,bitfine.getUserRefereeMapping(account,2));\r\n        updateUserReferee(account,3,bitfine.getUserRefereeMapping(account,3));\r\n        updateUserReferee(account,4,bitfine.getUserRefereeMapping(account,4));\r\n        updateUserReferee(account,5,bitfine.getUserRefereeMapping(account,5));\r\n        updateUserReferee(account,6,bitfine.getUserRefereeMapping(account,6));\r\n        updateUserReferee(account,7,bitfine.getUserRefereeMapping(account,7));\r\n        updateUserReferee(account,8,bitfine.getUserRefereeMapping(account,8));\r\n        updateUserReferee(account,9,bitfine.getUserRefereeMapping(account,9));\r\n        updateUserReceiveETH(account,0,bitfine.getReceiveETH(account,0));\r\n        updateUserReceiveETH(account,1,bitfine.getReceiveETH(account,1));\r\n        updateUserReceiveETH(account,2,bitfine.getReceiveETH(account,2));\r\n        return true;\r\n    }\r\n\r\n    function loadAsset(address account) public noReentrant returns (bool) {\r\n        require(!loan[account].isFreeze,\"BitFine Revert: This account was freeze\");\r\n        require(user[account].referee[0].length>=ROIRequirement[2],\"BitFine Revert: Need VIP 2\");\r\n        claimInternal(account);\r\n        uint256 futureEarn = getMaxEarnAmount(account) - getStuckAmount(account);\r\n        uint256 loanAmount = futureEarn * loanRatio / denominator;\r\n        uint256 fee = loanAmount * loanFee / denominator;\r\n        loan[account].replyAmount = loanAmount;\r\n        loan[account].isFreeze = true;\r\n        sendValue(account,loanAmount - fee);\r\n        return true;\r\n    }\r\n\r\n    function replyAsset(address account) public payable noReentrant returns (bool) {\r\n        require(loan[account].replyAmount>0,\"BitFine Revert: This Account Have Not Loan Yet\");\r\n        require(loan[account].replyAmount<=msg.value,\"BitFine Revert: Need More ETH To Reply\");\r\n        claimInternal(account);\r\n        loan[account].replyAmount = 0;\r\n        loan[account].isFreeze = false;\r\n        return true;\r\n    }\r\n\r\n    function settingUserData(address account,address referral,bool isRegistered,bool isFreeze,uint256[] memory uintSet) public onlyOwner returns (bool) {\r\n        updateUserData(account,referral,isRegistered,isFreeze,uintSet);\r\n        return true;\r\n    }\r\n\r\n    function settingUserReferee(address account,uint256 slot,address[] memory data) public onlyOwner returns (bool) {\r\n        updateUserReferee(account,slot,data);\r\n        return true;\r\n    }\r\n\r\n    function settingUserReceiveETH(address account,uint256 slot,uint256 value) public onlyOwner returns (bool) {\r\n        updateUserReceiveETH(account,slot,value);\r\n        return true;\r\n    }\r\n\r\n    function updateUserData(address account,address referral,bool isRegistered,bool isFreeze,uint256[] memory uintSet) internal {\r\n        user[account].balance = uintSet[0];\r\n        user[account].unclaimROI = uintSet[1];\r\n        user[account].commission = uintSet[2];\r\n        user[account].withdraw = uintSet[3];\r\n        user[account].actionBlock = uintSet[4];\r\n        user[account].maxDepositBonus = uintSet[5];\r\n        user[account].referral = referral;\r\n        user[account].registered = isRegistered;\r\n        loan[account].isFreeze = isFreeze;\r\n    }\r\n\r\n    function updateUserReferee(address account,uint256 slot,address[] memory data) internal {\r\n        user[account].referee[slot] = data;\r\n    }\r\n\r\n    function updateUserReceiveETH(address account,uint256 slot,uint256 value) internal {\r\n        user[account].receiveETH[slot] = value;\r\n    }\r\n\r\n    function updateGenesisBlock(uint256 blockstamp) public onlyOwner returns (bool) {\r\n        genesisBlock = blockstamp;\r\n        return true;\r\n    }\r\n\r\n    function updateMinimumDeposit(uint256 amountETH) public onlyOwner returns (bool) {\r\n        minimumDeposit = amountETH;\r\n        return true;\r\n    }\r\n\r\n    function updateMaximumDeposit(uint256 amountETH) public onlyOwner returns (bool) {\r\n        maximumDeposit = amountETH;\r\n        return true;\r\n    }\r\n\r\n    function updateLoanData(uint256 fee,uint256 ratio) public onlyOwner returns (bool) {\r\n        loanFee = fee;\r\n        loanRatio = ratio;\r\n        return true;\r\n    }\r\n\r\n    function updateUnlockAmount(uint256 amount,uint256 value) public onlyOwner returns (bool) {\r\n        unlockAmount = amount;\r\n        unlockValue = value;\r\n        return true;\r\n    }\r\n\r\n    function updateMaxProfitPercent(uint256 maxProfit) public onlyOwner returns (bool) {\r\n        maxProfitPercent = maxProfit;\r\n        return true;\r\n    }\r\n\r\n    function updateReferralAmount(uint256[] memory amounts) public onlyOwner returns (bool) {\r\n        referralAmount = amounts;\r\n        return true;\r\n    }\r\n\r\n    function updateROIAmount(uint256[] memory amounts,uint256[] memory requirements) public onlyOwner returns (bool) {\r\n        ROIAmount = amounts;\r\n        ROIRequirement = requirements;\r\n        return true;\r\n    }\r\n\r\n    function updateWithdrawFees(uint256[] memory fees,uint256[] memory filters) public onlyOwner returns (bool) {\r\n        withdrawFee = fees;\r\n        withdrawFilter = filters;\r\n        return true;\r\n    }\r\n\r\n    function updateMarketingWallet(address treasury,address[] memory marketing,uint256 feeTop,uint256 feeDeposit,uint256 feeTreasury) public onlyOwner returns (bool) {\r\n        treasuryWallet = treasury;\r\n        marketingWallet = marketing;\r\n        depositFeeToTop3 = feeTop;\r\n        depositFeeToMarketing = feeDeposit;\r\n        withdrawFeeToTreasury = feeTreasury;\r\n        return true;\r\n    }\r\n\r\n    function updateExternalReacts(address token,uint256 feeSwap) public onlyOwner returns (bool) {\r\n        tokenAddress = token;\r\n        depositFeeToSwap = feeSwap;\r\n        return true;\r\n    }\r\n\r\n    function updateTopWinnerReward(uint256[] memory rewards) public onlyOwner returns (bool) {\r\n        topWinnerReward = rewards;\r\n        return true;\r\n    }\r\n\r\n    function getWithdrawFee(uint256 amount) public view returns (uint256) {\r\n        uint256 i = withdrawFilter.length - 1;\r\n        do{\r\n            if(amount>=withdrawFilter[i]){\r\n                return withdrawFee[i];\r\n            }\r\n            i--;\r\n        }while(i>0);\r\n        return withdrawFee[0];\r\n    }\r\n\r\n    function getFeeAmount(uint256 amount,uint256 fee,uint256 deno) internal pure returns (uint256) {\r\n        return amount * fee / deno;\r\n    }\r\n\r\n    function takeFeeAmount(uint256 amount,uint256 fee,uint256 deno) internal pure returns (uint256) {\r\n        return amount - getFeeAmount(amount,fee,deno);\r\n    }\r\n\r\n    function isDeadAddress(address account) internal pure returns (bool) {\r\n        if(account == zero || account == dead){ return true; }\r\n        return false;\r\n    }\r\n\r\n    function callWithData(address to,bytes memory data) public onlyOwner returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call(data);\r\n        require(success);\r\n        return result;\r\n    }\r\n\r\n    function callWithValue(address to,bytes memory data,uint256 amount) public onlyOwner returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call{ value: amount }(data);\r\n        require(success);\r\n        return result;\r\n    }\r\n\r\n    function sendValue(address to,uint256 amount) internal {\r\n        if(!isDeadAddress(to) && amount > 0){\r\n            (bool success,) = to.call{ value: amount }(\"\");\r\n            require(success,\"BitFine Revert: Fail To Send ETH\");\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accountShouldMigrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callWithData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callWithValue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimCommission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimROI\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"claimTop3Reward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExternalReacts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeToSwap_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLoanData\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isFreeze\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"replyAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BitFineDAPPv2.loadData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketingFees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"treasuryWallet_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"marketingWallet_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeToTop3_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeToMarketing_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFeeToTreasury_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getMaxEarnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getNonOverpayAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getROIAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getROIRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getReceiveETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferralAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStuckAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getTop3Data\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"account_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"init_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getTop3Winner\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTop3WinnerReward\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getUserClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"uintSet_\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"referral_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"registered_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isFreeze_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deeplevel\",\"type\":\"uint256\"}],\"name\":\"getUserRefereeMapping\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"upperlevel\",\"type\":\"uint256\"}],\"name\":\"getUserReferralMapping\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawFees\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getmaxProfitPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMigrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTopAdsigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isTopClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"isTopWinner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"loadAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loanRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"migrateUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"replyAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRegistered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isFreeze\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"uintSet\",\"type\":\"uint256[]\"}],\"name\":\"settingUserData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"settingUserReceiveETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"data\",\"type\":\"address[]\"}],\"name\":\"settingUserReferee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"top3Key\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unlockMaxDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeSwap\",\"type\":\"uint256\"}],\"name\":\"updateExternalReacts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockstamp\",\"type\":\"uint256\"}],\"name\":\"updateGenesisBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"updateLoanData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"marketing\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"feeTop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeTreasury\",\"type\":\"uint256\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxProfit\",\"type\":\"uint256\"}],\"name\":\"updateMaxProfitPercent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"updateMaximumDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"updateMinimumDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"requirements\",\"type\":\"uint256[]\"}],\"name\":\"updateROIAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"updateReferralAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"}],\"name\":\"updateTopWinnerReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateUnlockAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"filters\",\"type\":\"uint256[]\"}],\"name\":\"updateWithdrawFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BitFineDAPPv2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9c9267c30b472acc25356c5791741bca79ccb08b88beca23e2c894c84d3544c8"}