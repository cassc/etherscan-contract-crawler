{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/helpers/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { Ownable } from \\\"./Ownable.sol\\\";\\n\\ncontract LockableData {\\n    bool public locked;\\n}\\n\\ncontract Lockable is LockableData, Ownable {\\n    /**\\n     * @dev Locks functions with whenNotLocked modifier\\n     */\\n    function lock() external onlyOwner {\\n        locked = true;\\n    }\\n\\n    /**\\n     * @dev Throws if called when unlocked.\\n     */\\n    modifier whenLocked {\\n        require(locked, \\\"Lockable: unlocked\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if called after it was locked.\\n     */\\n    modifier whenNotLocked {\\n        require(!locked, \\\"Lockable: locked\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\ncontract OwnableData {\\n    address public owner;\\n    address public pendingOwner;\\n}\\n\\ncontract Ownable is OwnableData {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev `owner` defaults to msg.sender on construction.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\\n     *      Can only be invoked by the current `owner`.\\n     * @param _newOwner Address of the new owner.\\n     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.\\n     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise\\n     */\\n    function transferOwnership(\\n        address _newOwner,\\n        bool _direct,\\n        bool _renounce\\n    ) external onlyOwner {\\n        if (_direct) {\\n            require(_newOwner != address(0) || _renounce, \\\"zero address\\\");\\n\\n            emit OwnershipTransferred(owner, _newOwner);\\n            owner = _newOwner;\\n            pendingOwner = address(0);\\n        } else {\\n            pendingOwner = _newOwner;\\n        }\\n    }\\n\\n    /**\\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\\n     */\\n    function claimOwnership() external {\\n        address _pendingOwner = pendingOwner;\\n        require(msg.sender == _pendingOwner, \\\"caller != pending owner\\\");\\n\\n        emit OwnershipTransferred(owner, _pendingOwner);\\n        owner = _pendingOwner;\\n        pendingOwner = address(0);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the Owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function _setOwner(address newOwner) internal {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function burn(uint256 amount) external returns (bool);\\n\\n    function burnFrom(address account, uint256 amount) external returns (bool);\\n\\n    // EIP 2612\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/StableMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// Based on StableMath from mStable\\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\\n\\nlibrary StableMath {\\n    /**\\n     * @dev Scaling unit for use in specific calculations,\\n     * where 1 * 10**18, or 1e18 represents a unit '1'\\n     */\\n    uint256 private constant FULL_SCALE = 1e18;\\n\\n    /**\\n     * @dev Provides an interface to the scaling unit\\n     * @return Scaling unit (1e18 or 1 * 10**18)\\n     */\\n    function getFullScale() internal pure returns (uint256) {\\n        return FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Scales a given integer to the power of the full scale.\\n     * @param x   Simple uint256 to scale\\n     * @return    Scaled value a to an exact number\\n     */\\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\\n        return x * FULL_SCALE;\\n    }\\n\\n    /***************************************\\n              PRECISE ARITHMETIC\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulTruncateScale(x, y, FULL_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @param scale Scale unit\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncateScale(\\n        uint256 x,\\n        uint256 y,\\n        uint256 scale\\n    ) internal pure returns (uint256) {\\n        // e.g. assume scale = fullScale\\n        // z = 10e18 * 9e17 = 9e36\\n        // return 9e36 / 1e18 = 9e18\\n        return (x * y) / scale;\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit, rounded up to the closest base unit.\\n     */\\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e17 * 17268172638 = 138145381104e17\\n        uint256 scaled = x * y;\\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\\n        uint256 ceil = scaled + FULL_SCALE - 1;\\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\\n        return ceil / FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\\n     * @param x     Left hand input to division\\n     * @param y     Right hand input to division\\n     * @return      Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e18 * 1e18 = 8e36\\n        // e.g. 8e36 / 10e18 = 8e17\\n        return (x * FULL_SCALE) / y;\\n    }\\n\\n    /***************************************\\n                    HELPERS\\n    ****************************************/\\n\\n    /**\\n     * @dev Calculates minimum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Minimum of the two inputs\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n\\n    /**\\n     * @dev Calculated maximum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Maximum of the two inputs\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @dev Clamps a value to an upper bound\\n     * @param x           Left hand input\\n     * @param upperBound  Maximum possible value to return\\n     * @return            Input x clamped to a maximum value, upperBound\\n     */\\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\\n        return x > upperBound ? upperBound : x;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vesting/Vesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nimport { StableMath } from \\\"../libraries/StableMath.sol\\\";\\nimport { IERC20 } from \\\"../interfaces/IERC20.sol\\\";\\nimport { Ownable } from \\\"../helpers/Ownable.sol\\\";\\nimport { Lockable } from \\\"../helpers/Lockable.sol\\\";\\n\\n/**\\n * @title   Vesting\\n * @notice  Vesting contract\\n * @dev     Vesting is constantly releasing vested tokens every block every second\\n */\\ncontract Vesting is Ownable, Lockable {\\n    using StableMath for uint256;\\n\\n    /// @notice address of vested token\\n    address public token;\\n    /// @notice total tokens vested in contract\\n    uint256 public totalVested;\\n    /// @notice total tokens already claimed form vesting\\n    uint256 public totalClaimed;\\n\\n    struct Vest {\\n        uint256 dateStart; // start of claiming, can claim startTokens\\n        uint256 dateEnd; // after it all tokens can be claimed\\n        uint256 totalTokens; // total tokens to claim\\n        uint256 startTokens; // tokens to claim on start\\n        uint256 claimedTokens; // tokens already claimed\\n    }\\n    /// @notice storage of vestings\\n    Vest[] internal vestings;\\n    /// @notice map of vestings for user\\n    mapping(address => uint256[]) internal user2vesting;\\n\\n    /// @dev events\\n    event Claimed(address indexed user, uint256 amount);\\n    event Vested(address indexed user, uint256 totalAmount, uint256 endDate);\\n\\n    /**\\n     * @dev Contract initiator\\n     * @param _token address of vested token\\n     */\\n    function init(address _token) external onlyOwner {\\n        require(_token != address(0), \\\"_token address cannot be 0\\\");\\n        require(token == address(0), \\\"init already done\\\");\\n        token = _token;\\n    }\\n\\n    /**\\n     * @dev Add multiple vesting to contract by arrays of data\\n     * @param _users[] addresses of holders\\n     * @param _startTokens[] tokens that can be withdrawn at startDate\\n     * @param _totalTokens[] total tokens in vesting\\n     * @param _startDate date from when tokens can be claimed\\n     * @param _endDate date after which all tokens can be claimed\\n     */\\n    function massAddHolders(\\n        address[] calldata _users,\\n        uint256[] calldata _startTokens,\\n        uint256[] calldata _totalTokens,\\n        uint256 _startDate,\\n        uint256 _endDate\\n    ) external onlyOwner whenNotLocked {\\n        uint256 len = _users.length; //cheaper to use one variable\\n        require((len == _startTokens.length) && (len == _totalTokens.length), \\\"data size mismatch\\\");\\n        require(_startDate < _endDate, \\\"startDate cannot exceed endDate\\\");\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            _addHolder(_users[i], _startTokens[i], _totalTokens[i], _startDate, _endDate);\\n        }\\n    }\\n\\n    /**\\n     * @dev Add new vesting to contract\\n     * @param _user address of a holder\\n     * @param _startTokens how many tokens are claimable at start date\\n     * @param _totalTokens total number of tokens in added vesting\\n     * @param _startDate date from when tokens can be claimed\\n     * @param _endDate date after which all tokens can be claimed\\n     */\\n    function _addHolder(\\n        address _user,\\n        uint256 _startTokens,\\n        uint256 _totalTokens,\\n        uint256 _startDate,\\n        uint256 _endDate\\n    ) internal {\\n        require(_user != address(0), \\\"user address cannot be 0\\\");\\n        Vest memory v;\\n        v.startTokens = _startTokens;\\n        v.totalTokens = _totalTokens;\\n        v.dateStart = _startDate;\\n        v.dateEnd = _endDate;\\n\\n        totalVested += _totalTokens;\\n        vestings.push(v);\\n        user2vesting[_user].push(vestings.length); // we are skipping index \\\"0\\\" for reasons\\n        emit Vested(_user, _totalTokens, _endDate);\\n    }\\n\\n    /**\\n     * @dev Claim tokens from msg.sender vestings\\n     */\\n    function claim() external {\\n        _claim(msg.sender, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Claim tokens from msg.sender vestings to external address\\n     * @param _target transfer address for claimed tokens\\n     */\\n    function claimTo(address _target) external {\\n        _claim(msg.sender, _target);\\n    }\\n\\n    /**\\n     * @dev internal claim function\\n     * @param _user address of holder\\n     * @param _target where tokens should be send\\n     * @return amt number of tokens claimed\\n     */\\n    function _claim(address _user, address _target) internal returns (uint256 amt) {\\n        require(_target != address(0), \\\"claim, then burn\\\");\\n        uint256 len = user2vesting[_user].length;\\n        require(len > 0, \\\"no vestings for user\\\");\\n        uint256 cl;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            Vest storage v = vestings[user2vesting[_user][i] - 1];\\n            cl = _claimable(v);\\n            v.claimedTokens += cl;\\n            amt += cl;\\n        }\\n        if (amt > 0) {\\n            totalClaimed += amt;\\n            _transfer(_target, amt);\\n            emit Claimed(_user, amt);\\n        } else revert(\\\"nothing to claim\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to send out claimed tokens\\n     * @param _user address that we send tokens\\n     * @param _amt amount of tokens\\n     */\\n    function _transfer(address _user, uint256 _amt) internal {\\n        require(IERC20(token).transfer(_user, _amt), \\\"token transfer failed\\\");\\n    }\\n\\n    /**\\n     * @dev Count how many tokens can be claimed from vesting to date\\n     * @param _vesting Vesting object\\n     * @return canWithdraw number of tokens\\n     */\\n    function _claimable(Vest memory _vesting) internal view returns (uint256 canWithdraw) {\\n        uint256 currentTime = block.timestamp;\\n        if (_vesting.dateStart > currentTime) return 0;\\n        // we are somewhere in the middle\\n        if (currentTime < _vesting.dateEnd) {\\n            // how much time passed (as fraction * 10^18)\\n            // timeRatio = (time passed * 1e18) / duration\\n            uint256 timeRatio = (currentTime - _vesting.dateStart).divPrecisely(_vesting.dateEnd - _vesting.dateStart);\\n            // how much tokens we can get in total to date\\n            canWithdraw = (_vesting.totalTokens - _vesting.startTokens).mulTruncate(timeRatio) + _vesting.startTokens;\\n        }\\n        // time has passed, we can take all tokens\\n        else {\\n            canWithdraw = _vesting.totalTokens;\\n        }\\n        // but maybe we take something earlier?\\n        canWithdraw -= _vesting.claimedTokens;\\n    }\\n\\n    /**\\n     * @dev Read number of claimable tokens by user and vesting no\\n     * @param _user address of holder\\n     * @param _id his vesting number (starts from 0)\\n     * @return amount number of tokens\\n     */\\n    function getClaimable(address _user, uint256 _id) external view returns (uint256 amount) {\\n        amount = _claimable(vestings[user2vesting[_user][_id] - 1]);\\n    }\\n\\n    /**\\n     * @dev Read total amount of tokens that user can claim to date from all vestings\\n     *      Function also includes tokens to claim from sale contracts that were not\\n     *      yet initiated for user.\\n     * @param _user address of holder\\n     * @return amount number of tokens\\n     */\\n    function getAllClaimable(address _user) public view returns (uint256 amount) {\\n        uint256 len = user2vesting[_user].length;\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            amount += _claimable(vestings[user2vesting[_user][i] - 1]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Extract all the vestings for the user\\n     *      Also extract not initialized vestings from\\n     *      sale contracts.\\n     * @param _user address of holder\\n     * @return v array of Vest objects\\n     */\\n    function getVestings(address _user) external view returns (Vest[] memory) {\\n        uint256 len = user2vesting[_user].length;\\n        Vest[] memory v = new Vest[](len);\\n\\n        // copy vestings\\n        uint256 i;\\n        for (i; i < len; i++) {\\n            v[i] = vestings[user2vesting[_user][i] - 1];\\n        }\\n\\n        return v;\\n    }\\n\\n    /**\\n     * @dev Read total number of vestings registered\\n     * @return number of registered vestings on contract\\n     */\\n    function getVestingsCount() external view returns (uint256) {\\n        return vestings.length;\\n    }\\n\\n    /**\\n     * @dev Read single registered vesting entry\\n     * @param _id index of vesting in storage\\n     * @return Vest object\\n     */\\n    function getVestingByIndex(uint256 _id) external view returns (Vest memory) {\\n        return vestings[_id];\\n    }\\n\\n    /**\\n     * @dev Read registered vesting list by range from-to\\n     * @param _start first index\\n     * @param _end last index\\n     * @return array of Vest objects\\n     */\\n    function getVestingsByRange(uint256 _start, uint256 _end) external view returns (Vest[] memory) {\\n        uint256 cnt = _end - _start + 1;\\n        uint256 len = vestings.length;\\n        require(_end < len, \\\"range error\\\");\\n        Vest[] memory v = new Vest[](cnt);\\n        uint256 i;\\n        for (i; i < cnt; i++) {\\n            v[i] = vestings[_start + i];\\n        }\\n        return v;\\n    }\\n\\n    /**\\n     * @dev Recover ETH from contract to owner address.\\n     */\\n    function recoverETH() external {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    /**\\n     * @dev Recover given ERC20 token from contract to owner address.\\n     *      Can't recover vested tokens.\\n     * @param _token address of ERC20 token to recover\\n     */\\n    function recoverErc20(address _token) external {\\n        require(_token != token, \\\"not allowed\\\");\\n        uint256 amt = IERC20(_token).balanceOf(address(this));\\n        require(amt > 0, \\\"nothing to recover\\\");\\n        IBadErc20(_token).transfer(owner, amt);\\n    }\\n}\\n\\n/**\\n * @title IBadErc20\\n * @dev Interface for emergency recover any ERC20-tokens,\\n *      even non-erc20-compliant like USDT not returning boolean\\n */\\ninterface IBadErc20 {\\n    function transfer(address _recipient, uint256 _amount) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endDate\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getVestingByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting.Vest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getVestings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getVestingsByRange\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_totalTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"name\":\"massAddHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vesting", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}