{"SourceCode": "// SPDX-License-Identifier: unlicensed\r\n// DAXE Token was developed by Michel A. and the DAXE dev team.\r\npragma solidity 0.8.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n\r\n\r\n    function percentageOf(uint val, uint percent) internal pure returns(uint){\r\n        val = mul(val,10000);\r\n        val = mul(val,percent);\r\n        val = div(val,100);\r\n        val = div(val,10000);\r\n        return val;\r\n    }\r\n\r\n \r\n    //These functions enable operations on big integers\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n\r\n\r\n}\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\nabstract contract ERC20Interface {\r\n    function totalSupply() virtual public view returns (uint);\r\n    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) virtual public returns (bool success);\r\n    function approve(address spender, uint tokens) virtual public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals\r\n// assisted token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract DAXE is ERC20Interface, SafeMath {\r\n    // Staking maps\r\n    mapping(uint=>address) internal allStakedAddresses;\r\n    mapping(address=>uint) internal allAddresseIndexes;\r\n    mapping(address=>bool) internal addressHasStake;\r\n    mapping(uint=>uint) public allStakedAmounts;\r\n    mapping(uint=>uint) public allStakedReleaseDate;\r\n    mapping(uint=>uint) public allStakedStartDate;\r\n    mapping(uint=>bool) public allStakedIsClosed;\r\n    // mapping(uint=>uint) public allStakedInitialPrinciple;\r\n    mapping(uint=>uint) public allStakedPenalties;\r\n    mapping(uint=>uint) public allStakedPayout;\r\n    // mapping(uint=>uint) public allStakedRewardPerTokenAtStakeStart;\r\n    mapping(uint=>uint) internal allStakedTotalStakeAtStart;\r\n    mapping(uint=>uint) internal allStakedPenaltiesAtStart;\r\n    \r\n    mapping(address=>uint[]) public allAddressToStakes_mapping;\r\n    \r\n    // mapping(uint=>uint) public allStakedCummulatedPenalties;\r\n\r\n    uint public stakeCount = 100;\r\n    uint public activeStakeCount = 0;\r\n   \r\n   \r\n   \r\n    mapping(address=>uint) public balances;\r\n    mapping(address=>mapping(address=>uint)) internal allowed;\r\n    // mapping(address=>uint) public stakedBalance;\r\n    // mapping(address=>mapping(address=>uint)) public allowance;\r\n    uint public decimals = 18;\r\n    uint public _totalSupply = 3000000000000 * 10**decimals;\r\n    uint public totalStaked = 0;\r\n    string public name = \"DAXE\";\r\n    string public symbol = \"DAXE\";\r\n    uint public cummulatedPenaltiesAllTime;\r\n   \r\n\r\n\r\n    struct stakingInfo {\r\n        uint amount;\r\n        address ownerAddress;\r\n        uint releaseDate;\r\n    }\r\n   \r\n    stakingInfo[] allStakes;\r\n   \r\n    // event Transfer(address indexed from, address indexed to, uint value);\r\n    // event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n   \r\n    event test_value(string _msg,address _address, uint _value);\r\n    event test_value2(string _msg, uint _value);\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor(){\r\n        balances[msg.sender] = _totalSupply;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public override view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address owner) public override view returns (uint balance) {\r\n        return balances[owner];\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to receiver account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint value) public override returns (bool success) {\r\n        uint maxTransactionAmount = percentageOf(_totalSupply,5);\r\n        require(balances[msg.sender]>= value, 'Balance too low');\r\n        require(value<maxTransactionAmount,\"Send transaction limit exeeded.  \");\r\n        balances[to] += value;\r\n        balances[msg.sender] -= value;\r\n        emit Transfer(msg.sender,to,value);\r\n        return true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public override returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from sender account to receiver account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from sender account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address sender, address receiver, uint tokens) public override returns (bool success) {\r\n        // uint maxTransactionAmount = percentageOf(_totalSupply,1);\r\n        // maxTransactionAmount = percentageOf(maxTransactionAmount,1);\r\n        // require(balances[msg.sender]>= tokens, 'Balance too low');\r\n        balances[sender] = sub(balances[sender], tokens);\r\n        allowed[sender][msg.sender] = sub(allowed[sender][msg.sender], tokens);\r\n        balances[receiver] = add(balances[receiver], tokens);\r\n        emit Transfer(sender, receiver, tokens);\r\n        return true;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n    \r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Custom DAXE functions\r\n    // ------------------------------------------------------------------------\r\n    function getAllStakesOf(address owner) public view returns (uint[8][] memory){\r\n        //   find out number os stakes for owner\r\n        uint numStake = allAddressToStakes_mapping[owner].length;\r\n\r\n        // emit test_value(\"Nuum stake \",owner,numStake);\r\n        require( numStake>0 );\r\n        uint[8][]    memory stakeIDs = new uint[8][](numStake);\r\n        // address[]  memory addresses = new address[](numStake);\r\n        // uint[]    memory stakedAmounts = new uint[](numStake);\r\n        numStake=0;\r\n        uint isClosed = 0;\r\n        for (uint a=0; a< allAddressToStakes_mapping[owner].length;a++){\r\n          uint stakeID = allAddressToStakes_mapping[owner][a];\r\n          if (allStakedAddresses[stakeID]==owner){\r\n            stakeIDs[numStake][0]=stakeID;\r\n            stakeIDs[numStake][1]=allStakedAmounts[stakeID];\r\n            stakeIDs[numStake][2]=allStakedStartDate[stakeID];\r\n            stakeIDs[numStake][3]=allStakedReleaseDate[stakeID];\r\n            \r\n            uint penaltiesDue = calculatePenaly(allStakedPenaltiesAtStart[stakeID],allStakedAmounts[stakeID],allStakedTotalStakeAtStart[stakeID],cummulatedPenaltiesAllTime,totalStaked);\r\n        \r\n            \r\n            stakeIDs[numStake][4]= penaltiesDue;\r\n            stakeIDs[numStake][5]=allStakedPenalties[stakeID];\r\n            stakeIDs[numStake][6]=allStakedPayout[stakeID];\r\n            if (allStakedIsClosed[stakeID]) \r\n                isClosed = 1;\r\n            else\r\n                isClosed = 0;\r\n            stakeIDs[numStake][7] = isClosed;\r\n            // stakeIDs[numStake][5]=getCumulativeInterestToDate(i);\r\n            //   addresses[i]=allStakedAddresses[i];\r\n            //   stakedAmounts[i]=allStakedAmounts[i];\r\n            // //   emit test_value(\"Adding for return \",owner,allStakedAmounts[i]);\r\n            numStake++;\r\n          }\r\n        }\r\n   \r\n        return (stakeIDs);\r\n   \r\n    }    \r\n   \r\n    \r\n    // function getActiveStakesCount() public view returns (uint){\r\n    //     uint numStakes=0;\r\n    //     for(uint i=100;i<stakeCount;i++){\r\n    //         if(!allStakedIsClosed[i]) numStakes++;\r\n    //     }\r\n    //     return numStakes;\r\n    // }\r\n   \r\n   \r\n\r\n   \r\n    function stake( uint value,uint startDate, uint releaseDate) public returns(bool){\r\n        require(balances[msg.sender]>=value , 'Balance too low');\r\n        require(releaseDate>startDate,'Trying to end stake before it starts');\r\n        startDate = block.timestamp*1000;\r\n        \r\n        // do not stake less than 48 hours\r\n        uint hoursServed = releaseDate - startDate;\r\n        hoursServed = div(hoursServed,1000);\r\n        hoursServed = div(hoursServed,60);\r\n        hoursServed = div(hoursServed,60);\r\n        \r\n        require(hoursServed>48, 'Trying to start a stake shorter than 48 hours');\r\n       \r\n    \r\n        uint maxReleaseDate = add(startDate, mul(5555,86400000));   \r\n        if (releaseDate>maxReleaseDate)  releaseDate = maxReleaseDate;\r\n        \r\n        allStakedAmounts[stakeCount] += value;\r\n        // allStakedInitialPrinciple[stakeCount] = value;\r\n        allStakedReleaseDate[stakeCount] = releaseDate;\r\n        allStakedStartDate[stakeCount] = startDate;\r\n        allStakedAddresses[stakeCount] = msg.sender;\r\n        balances[msg.sender] -= value;\r\n        totalStaked += value;\r\n        _totalSupply -= value;\r\n\r\n        allStakedTotalStakeAtStart[stakeCount] = totalStaked;\r\n        allStakedPenaltiesAtStart[stakeCount] = cummulatedPenaltiesAllTime;\r\n        // allStakedRewardPerTokenAtStakeStart[stakeCount] = getRewardPerTokenRate(cummulatedPenaltiesAllTime,value,totalStaked);\r\n\r\n\r\n        allAddressToStakes_mapping[msg.sender].push(stakeCount);\r\n        require(allAddressToStakes_mapping[msg.sender].length <99,'Too many stakes for this address.');\r\n\r\n        stakeCount +=1;  \r\n        activeStakeCount+=1;\r\n        return true;\r\n    }\r\n   \r\n    function endStake(uint stakeID) public returns(bool){\r\n\r\n        require(allStakedAddresses[stakeID]==msg.sender,'Trying to unstake a stake belonging to another user');\r\n        require( allStakedIsClosed[stakeID]==false, 'Tryint to end a stake that is already closed' );\r\n        \r\n        uint currentDate = block.timestamp*1000;\r\n        // uint currentDate = block.timestamp*1000 + 1000*60*60*24*99;\r\n        uint startDate = allStakedStartDate[stakeID];\r\n        uint releaseDate = allStakedReleaseDate[stakeID];\r\n        \r\n        uint daysServed = sub(currentDate, startDate);\r\n        // uint daysServed = 700;\r\n        daysServed = div(daysServed,1000);\r\n        daysServed = div(daysServed,60);\r\n        daysServed = div(daysServed,60);\r\n        uint hoursServed = daysServed;\r\n        daysServed = div(daysServed,24);\r\n        \r\n        uint stakeDuration = sub(releaseDate, startDate);\r\n        stakeDuration = div(stakeDuration,1000);\r\n        stakeDuration = div(stakeDuration,60);\r\n        stakeDuration = div(stakeDuration,60);\r\n        stakeDuration = div(stakeDuration,24);\r\n\r\n        if(hoursServed<24){\r\n            allStakedPenalties[stakeID] = 0;\r\n            allStakedPayout[stakeID] = 0;\r\n    \r\n            // Remove stake\r\n\r\n            allStakedIsClosed[stakeID] = true;\r\n            balances[msg.sender] = add( balances[msg.sender],  allStakedAmounts[stakeID] );\r\n            _totalSupply +=             allStakedAmounts[stakeID];\r\n            totalStaked -= allStakedAmounts[stakeID];\r\n            allStakedAmounts[stakeID] = 0;\r\n            activeStakeCount-=1;\r\n            return true;\r\n        }\r\n\r\n\r\n       \r\n        uint cumulativePrinciple = computeInterestOnPriniple( daysServed, stakeDuration , allStakedAmounts[stakeID] );\r\n        // emit test_value(\"cumulativePrinciple \",msg.sender, cumulativePrinciple); \r\n        \r\n        \r\n\r\n        uint penaltiesDue = calculatePenaly(allStakedPenaltiesAtStart[stakeID],allStakedAmounts[stakeID],allStakedTotalStakeAtStart[stakeID],cummulatedPenaltiesAllTime,totalStaked);\r\n        \r\n        cumulativePrinciple += penaltiesDue;\r\n        cummulatedPenaltiesAllTime -= penaltiesDue;\r\n        \r\n        if(cummulatedPenaltiesAllTime<0) cummulatedPenaltiesAllTime=0;\r\n        \r\n        uint penaltyOnPrinciple  = 0;\r\n        uint leftOverPrinciple = cumulativePrinciple;\r\n        \r\n        // if stake ended normally there is no penalty\r\n        if (daysServed>=stakeDuration){\r\n            leftOverPrinciple = cumulativePrinciple;\r\n            penaltyOnPrinciple = 0;\r\n        }\r\n        else{\r\n            penaltyOnPrinciple  = computePenaltyOnPrinciple( daysServed, stakeDuration, cumulativePrinciple );\r\n            leftOverPrinciple = computeLeftOverPrinciple( daysServed, stakeDuration, cumulativePrinciple ); \r\n            \r\n            cummulatedPenaltiesAllTime += penaltyOnPrinciple;\r\n            \r\n        }\r\n        \r\n        allStakedPenalties[stakeID] = penaltyOnPrinciple;\r\n        allStakedPayout[stakeID] = leftOverPrinciple;\r\n\r\n        // Remove stake\r\n\r\n        balances[msg.sender] = add( balances[msg.sender], leftOverPrinciple);\r\n        _totalSupply += leftOverPrinciple;\r\n        totalStaked -= allStakedAmounts[stakeID];\r\n        allStakedAmounts[stakeID] = 0;\r\n        allStakedIsClosed[stakeID] = true;   \r\n        activeStakeCount-=1;\r\n        // emit test_value(\"late Balance  \",msg.sender, balances[msg.sender]);\r\n       \r\n       \r\n        return true;\r\n    }\r\n   \r\n    function calculatePenaly(uint _penaltiesAtStart,uint _qtyStaked,uint _totalStakeAtStart, uint _allPenaltiesNow, uint _totalStakeNow) internal pure returns(uint){\r\n        uint penaltyPayoutFromStart = (_penaltiesAtStart * _qtyStaked)*2 / (_totalStakeAtStart*3);\r\n        uint penaltyPayoutNow = ((_allPenaltiesNow * _qtyStaked) / _totalStakeNow )/3;\r\n \r\n        return penaltyPayoutNow+penaltyPayoutFromStart; \r\n        \r\n    }\r\n    \r\n    function computePenaltyOnPrinciple(uint daysServed, uint stakeDuration, uint cumulativePrinciple) internal pure returns( uint){\r\n        uint proportionServed =  mul( daysServed , 1000);\r\n        proportionServed = div(proportionServed,stakeDuration);\r\n        if( proportionServed < 500)\r\n            return div( mul( 795, cumulativePrinciple), 1000);\r\n        else\r\n            return div( mul( sub(1000,proportionServed), cumulativePrinciple), 1000);\r\n    }\r\n\r\n    function computeLeftOverPrinciple(uint daysServed, uint stakeDuration, uint cumulativePrinciple) internal pure returns( uint){\r\n        uint proportionServed =  mul( daysServed , 1000);\r\n        proportionServed = div(proportionServed,stakeDuration);\r\n        if( proportionServed < 500)\r\n            return div( mul( 175, cumulativePrinciple), 1000);\r\n        else\r\n            return div( mul( proportionServed, cumulativePrinciple), 1000);\r\n    }    \r\n    \r\n    function getCumulativeInterestToDate(uint stakeID) internal view returns(uint){\r\n        if(allStakedIsClosed[stakeID]==true) return 0;\r\n        uint currentDate = block.timestamp*1000;\r\n        currentDate = add(currentDate,(mul ( 5550, mul(1000,  mul(60, mul(60,24) ) ) ) ) ); \r\n        // currentDate = add(currentDate,400*)\r\n        uint startDate = allStakedStartDate[stakeID];\r\n        uint releaseDate = allStakedReleaseDate[stakeID];\r\n        \r\n        uint daysServed = sub(currentDate, startDate);\r\n        daysServed = div(daysServed,1000);\r\n        daysServed = div(daysServed,60);\r\n        daysServed = div(daysServed,60);\r\n        daysServed = div(daysServed,24);\r\n        \r\n        uint stakeDuration = sub(releaseDate, startDate);\r\n        stakeDuration = div(stakeDuration,1000);\r\n        stakeDuration = div(stakeDuration,60);\r\n        stakeDuration = div(stakeDuration,60);\r\n        stakeDuration = div(stakeDuration,24);\r\n        uint cumulativePrinciple = computeInterestOnPriniple( daysServed, stakeDuration, allStakedAmounts[stakeID] ); \r\n        return cumulativePrinciple;\r\n    }\r\n    \r\n    \r\n    function computeInterestOnPriniple(uint daysServed,uint stakeDuration, uint principle) internal pure returns(uint){\r\n        return computeAllInteresAtDayN(daysServed,stakeDuration,principle);\r\n    }\r\n    \r\n    function computeAllInteresAtDayN( uint daysServed, uint stakeDuration ,uint principleAtDayN)internal pure returns(uint){\r\n        // if ( daysServed > lastDayOfStake) return 0;\r\n        \r\n        uint cumulativePrinciple = principleAtDayN;\r\n        uint initialPrincipal = add(principleAtDayN,0);\r\n        \r\n        \r\n        uint baseInterest =  mul( principleAtDayN, 2000000);\r\n        baseInterest = div(baseInterest,3652500000);\r\n        uint longStakeInterest = 0;\r\n        uint allInterest =0;\r\n        \r\n        for(uint i=0;i<daysServed && i<stakeDuration;i++){\r\n            // uint baseInterest = computeBaseInterestForDayN(initialPrincipal);\r\n            // longStakeInterest = computeLongStateDialyBonus(i, initialPrincipal);\r\n            longStakeInterest = i*i*10000;\r\n            longStakeInterest = longStakeInterest / (30858025);\r\n            longStakeInterest = longStakeInterest * initialPrincipal *2;\r\n            longStakeInterest = longStakeInterest / 3650000;\r\n            \r\n            allInterest = add( baseInterest, longStakeInterest );\r\n            \r\n            \r\n            cumulativePrinciple = add(cumulativePrinciple, allInterest);\r\n        }\r\n        \r\n        // uint newPrinciple = sum(principleAtDayN, interesAccruedtToday);\r\n        return cumulativePrinciple;\r\n        \r\n    }\r\n    \r\n    function computeBaseInterestForDayN( uint principleAtDayN)internal pure returns(uint){\r\n        uint retval =  mul( principleAtDayN, 2000000);\r\n        retval = div(retval,3652500000);\r\n        return retval;\r\n    }\r\n    \r\n    function computeLongStateDialyBonus(uint daysServed, uint principleAtDayN)internal pure returns(uint){\r\n        // emit test_value2(\"daysServed**2\",mul(daysServed,daysServed)); \r\n        \r\n        uint retval = mul(mul(daysServed,daysServed),100000);\r\n        \r\n        retval = div(retval,mul(5555,5555));\r\n        retval = mul(retval,principleAtDayN);\r\n        retval = mul(retval,200);\r\n        retval = div(retval,100);\r\n        // // get daily rate\r\n        retval = div(retval,365);\r\n        retval = div(retval,100000);\r\n        return retval;\r\n        \r\n    }\r\n   \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"test_value\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_msg\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"test_value2\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeStakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allAddressToStakes_mapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakedAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakedIsClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakedPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakedPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakedReleaseDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakedStartDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cummulatedPenaltiesAllTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"endStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAllStakesOf\",\"outputs\":[{\"internalType\":\"uint256[8][]\",\"name\":\"\",\"type\":\"uint256[8][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseDate\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DAXE", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://50cd0f94d775daa5a8935ee6088b7183d49eb31b0db30460945109a41a0be1a2"}