{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IPancakeSwapLottery {\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param _lotteryId: lotteryId\r\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(uint256 _lotteryId, uint32[] calldata _ticketNumbers) external;\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketIds: array of ticket ids\r\n     * @param _brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256 _lotteryId,\r\n        uint256[] calldata _ticketIds,\r\n        uint32[] calldata _brackets\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(uint256 _lotteryId) external;\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in CAKE per group, and make lottery claimable\r\n     * @param _lotteryId: lottery id\r\n     * @param _autoInjection: reinjects funds into next lottery (vs. withdrawing all)\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(uint256 _lotteryId, bytes32 _seed, bool _autoInjection) external;\r\n\r\n    /**\r\n     * @notice Inject funds\r\n     * @param _lotteryId: lottery id\r\n     * @param _amount: amount to inject in CAKE token\r\n     * @dev Callable by operator\r\n     */\r\n    function injectFunds(uint256 _lotteryId, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param _endTime: endTime of the lottery\r\n     * @param _priceTicketInCake: price of a ticket in CAKE\r\n     * @param _discountDivisor: the divisor to calculate the discount magnitude for bulks\r\n     * @param _rewardsBreakdown: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @param _treasuryFee: treasury fee (10,000 = 100%, 100 = 1%)\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256 _priceTicketInCake,\r\n        uint256 _discountDivisor,\r\n        uint256[6] calldata _rewardsBreakdown,\r\n        uint256 _treasuryFee\r\n    ) external;\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external returns (uint256);\r\n}\r\n\r\n\r\n\r\n/** @title PancakeSwap Lottery.\r\n * @notice It is a contract for a lottery system using\r\n * randomness provided externally.\r\n */\r\ncontract PancakeSwapLottery is ReentrancyGuard, IPancakeSwapLottery, Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public injectorAddress;\r\n    address public operatorAddress;\r\n    address public treasuryAddress;\r\n\r\n    uint256 public currentLotteryId;\r\n    uint256 public currentTicketId;\r\n\r\n    uint256 public maxNumberTicketsPerBuyOrClaim = 100;\r\n\r\n    uint256 public maxPriceTicketInCake = 500000 ether;\r\n    uint256 public minPriceTicketInCake = 0.00000000001 ether;\r\n\r\n    uint256 public pendingInjectionNextLottery;\r\n\r\n    address public OnoutAddress = 0xDf50EF7E506536354e7a805442dcBF25c7Ac249B;\r\n    bool public OnoutFeeEnabled = true;\r\n    uint256 private OnoutFee = 20;\r\n\r\n    uint256 public withdrawCooldown = 31 days;\r\n\r\n    uint256 public constant MIN_DISCOUNT_DIVISOR = 300;\r\n    uint256 public constant MIN_LENGTH_LOTTERY = 5 minutes; // 4 hours - 5 minutes; // 4 hours\r\n    uint256 public constant MAX_LENGTH_LOTTERY = 31 days + 5 minutes; // 31 days\r\n    uint256 public constant MAX_TREASURY_FEE = 3000; // 30%\r\n\r\n    uint32 public numbersCount = 6; // \u041a\u043e\u043b-\u0432\u043e \u0446\u0438\u0444\u0440 \u0432 \u0431\u0438\u043b\u0435\u0442\u0435 \u043e\u0442 2\u0445 \u0434\u043e 6\u0442\u0438\r\n\r\n    IERC20 public cakeToken;\r\n\r\n    enum Status {\r\n        Pending,\r\n        Open,\r\n        Close,\r\n        Claimable\r\n    }\r\n\r\n    struct Lottery {\r\n        Status status;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 priceTicketInCake;\r\n        uint256 discountDivisor;\r\n        uint256[6] rewardsBreakdown; // 0: 1 matching number // 5: 6 matching numbers\r\n        uint256 treasuryFee; // 500: 5% // 200: 2% // 50: 0.5%\r\n        uint256[6] cakePerBracket;\r\n        uint256[6] countWinnersPerBracket;\r\n        uint256 firstTicketId;\r\n        uint256 firstTicketIdNextLottery;\r\n        uint256 amountCollectedInCake;\r\n        uint32 finalNumber;\r\n    }\r\n\r\n    struct Ticket {\r\n        uint32 number;\r\n        address owner;\r\n    }\r\n\r\n    // Mapping are cheaper than arrays\r\n    mapping(uint256 => Lottery) private _lotteries;\r\n    mapping(uint256 => Ticket) private _tickets;\r\n\r\n    // Bracket calculator is used for verifying claims for ticket prizes\r\n    mapping(uint32 => uint32) private _bracketCalculator;\r\n\r\n    // Keeps track of number of ticket per unique combination for each lotteryId\r\n    mapping(uint256 => mapping(uint32 => uint256)) private _numberTicketsPerLotteryId;\r\n\r\n    // Keep track of user ticket ids for a given lotteryId\r\n    mapping(address => mapping(uint256 => uint256[])) private _userTicketIdsPerLotteryId;\r\n\r\n    modifier notContract() {\r\n        require(!_isContract(msg.sender), \"Contract not allowed\");\r\n        require(msg.sender == tx.origin, \"Proxy contract not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operatorAddress, \"Not operator\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrInjector() {\r\n        require((msg.sender == owner()) || (msg.sender == injectorAddress), \"Not owner or injector\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrOperator() {\r\n        require((msg.sender == owner()) || (msg.sender == operatorAddress), \"Not owner or operator\");\r\n        _;\r\n    }\r\n\r\n    event AdminTokenRecovery(address token, uint256 amount);\r\n    event LotteryClose(uint256 indexed lotteryId, uint256 firstTicketIdNextLottery);\r\n    event LotteryInjection(uint256 indexed lotteryId, uint256 injectedAmount);\r\n    event LotteryOpen(\r\n        uint256 indexed lotteryId,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 priceTicketInCake,\r\n        uint256 firstTicketId,\r\n        uint256 injectedAmount\r\n    );\r\n    event LotteryNumberDrawn(uint256 indexed lotteryId, uint256 finalNumber, uint256 countWinningTickets);\r\n    event NewOperatorAndTreasuryAndInjectorAddresses(address operator, address treasury, address injector);\r\n    event TicketsPurchase(address indexed buyer, uint256 indexed lotteryId, uint256 numberTickets);\r\n    event TicketsClaim(address indexed claimer, uint256 amount, uint256 indexed lotteryId, uint256 numberTickets);\r\n\r\n    function setOnoutAddress(address _newFeeAddress) public {\r\n        require(msg.sender == OnoutAddress, \"Only Onout can change fee address\");\r\n        OnoutAddress = _newFeeAddress;\r\n    }\r\n\r\n    function setOnoutFeeEnabled(bool _value) public {\r\n        require(msg.sender == OnoutAddress, \"Only Onout can enable/disable service fee\");\r\n        OnoutFeeEnabled = _value;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @dev RandomNumberGenerator must be deployed prior to this contract\r\n     * @param _cakeTokenAddress: address of the CAKE token\r\n     */\r\n    constructor(address _cakeTokenAddress, bool _OnoutFeeEnabled) {\r\n        cakeToken = IERC20(_cakeTokenAddress);\r\n        OnoutFeeEnabled = _OnoutFeeEnabled;\r\n\r\n        operatorAddress = owner();\r\n        treasuryAddress = owner();\r\n        injectorAddress = owner();\r\n\r\n        // Initializes a mapping\r\n        _bracketCalculator[0] = 1;\r\n        _bracketCalculator[1] = 11;\r\n        _bracketCalculator[2] = 111;\r\n        _bracketCalculator[3] = 1111;\r\n        _bracketCalculator[4] = 11111;\r\n        _bracketCalculator[5] = 111111;\r\n\r\n        currentLotteryId++;\r\n        _lotteries[currentLotteryId] = Lottery({\r\n            status: Status.Claimable,\r\n            startTime: block.timestamp,\r\n            endTime:  block.timestamp,\r\n            priceTicketInCake: 0,\r\n            discountDivisor: 0,\r\n            rewardsBreakdown: [uint256(250),uint256(375),uint256(625),uint256(1250),uint256(2500),uint256(5000)],\r\n            treasuryFee: 2000,\r\n            cakePerBracket: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)],\r\n            countWinnersPerBracket: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)],\r\n            firstTicketId: currentTicketId,\r\n            firstTicketIdNextLottery: currentTicketId,\r\n            amountCollectedInCake: pendingInjectionNextLottery,\r\n            finalNumber: 1000000\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Buy tickets for the current lottery\r\n     * @param _lotteryId: lotteryId\r\n     * @param _ticketNumbers: array of ticket numbers between 1,000,000 and 1,999,999\r\n     * @dev Callable by users\r\n     */\r\n    function buyTickets(uint256 _lotteryId, uint32[] calldata _ticketNumbers)\r\n        external\r\n        override\r\n        notContract\r\n        nonReentrant\r\n    {\r\n        require(_ticketNumbers.length != 0, \"No ticket specified\");\r\n        require(_ticketNumbers.length <= maxNumberTicketsPerBuyOrClaim, \"Too many tickets\");\r\n\r\n        require(_lotteries[_lotteryId].status == Status.Open, \"Lottery is not open\");\r\n        require(block.timestamp < _lotteries[_lotteryId].endTime, \"Lottery is over\");\r\n\r\n        // Calculate number of CAKE to this contract\r\n        uint256 amountCakeToTransfer = _calculateTotalPriceForBulkTickets(\r\n            _lotteries[_lotteryId].discountDivisor,\r\n            _lotteries[_lotteryId].priceTicketInCake,\r\n            _ticketNumbers.length\r\n        );\r\n\r\n        // Transfer cake tokens to this contract\r\n        cakeToken.safeTransferFrom(address(msg.sender), address(this), amountCakeToTransfer);\r\n\r\n        // Increment the total amount collected for the lottery round\r\n        _lotteries[_lotteryId].amountCollectedInCake += amountCakeToTransfer;\r\n\r\n        for (uint256 i = 0; i < _ticketNumbers.length; i++) {\r\n            uint32 thisTicketNumber = _ticketNumbers[i];\r\n\r\n            thisTicketNumber = thisTicketNumber - uint32(10)**(6) + 1000000;\r\n            require((thisTicketNumber >= 1000000) && (thisTicketNumber <= 1999999), \"Outside range\");\r\n\r\n            _numberTicketsPerLotteryId[_lotteryId][1 + (thisTicketNumber % 10)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][11 + (thisTicketNumber % 100)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][111 + (thisTicketNumber % 1000)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][1111 + (thisTicketNumber % 10000)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][11111 + (thisTicketNumber % 100000)]++;\r\n            _numberTicketsPerLotteryId[_lotteryId][111111 + (thisTicketNumber % 1000000)]++;\r\n\r\n            _userTicketIdsPerLotteryId[msg.sender][_lotteryId].push(currentTicketId);\r\n\r\n            _tickets[currentTicketId] = Ticket({number: thisTicketNumber, owner: msg.sender});\r\n\r\n            // Increase lottery ticket number\r\n            currentTicketId++;\r\n        }\r\n\r\n        emit TicketsPurchase(msg.sender, _lotteryId, _ticketNumbers.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim a set of winning tickets for a lottery\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketIds: array of ticket ids\r\n     * @param _brackets: array of brackets for the ticket ids\r\n     * @dev Callable by users only, not contract!\r\n     */\r\n    function claimTickets(\r\n        uint256 _lotteryId,\r\n        uint256[] calldata _ticketIds,\r\n        uint32[] calldata _brackets\r\n    ) external override notContract nonReentrant {\r\n        require(_ticketIds.length == _brackets.length, \"Not same length\");\r\n        require(_ticketIds.length != 0, \"Length must be >0\");\r\n        require(_ticketIds.length <= maxNumberTicketsPerBuyOrClaim, \"Too many tickets\");\r\n        require(_lotteries[_lotteryId].status == Status.Claimable, \"Lottery not claimable\");\r\n\r\n        // Initializes the rewardInCakeToTransfer\r\n        uint256 rewardInCakeToTransfer;\r\n\r\n        for (uint256 i = 0; i < _ticketIds.length; i++) {\r\n            require(_brackets[i] < 6, \"Bracket out of range\"); // Must be between 0 and 5\r\n\r\n            uint256 thisTicketId = _ticketIds[i];\r\n\r\n            require(_lotteries[_lotteryId].firstTicketIdNextLottery > thisTicketId, \"TicketId too high\");\r\n            require(_lotteries[_lotteryId].firstTicketId <= thisTicketId, \"TicketId too low\");\r\n            require(msg.sender == _tickets[thisTicketId].owner, \"Not the owner\");\r\n\r\n            // Update the lottery ticket owner to 0x address\r\n            _tickets[thisTicketId].owner = address(0);\r\n\r\n            uint256 rewardForTicketId = _calculateRewardsForTicketId(_lotteryId, thisTicketId, _brackets[i]);\r\n\r\n            // Check user is claiming the correct bracket\r\n            require(rewardForTicketId != 0, \"No prize for this bracket\");\r\n\r\n            if (_brackets[i] != 5) {\r\n                require(\r\n                    _calculateRewardsForTicketId(_lotteryId, thisTicketId, _brackets[i] + 1) == 0,\r\n                    \"Bracket must be higher\"\r\n                );\r\n            }\r\n\r\n            // Increment the reward to transfer\r\n            rewardInCakeToTransfer += rewardForTicketId;\r\n        }\r\n\r\n        // Transfer money to msg.sender\r\n        cakeToken.safeTransfer(msg.sender, rewardInCakeToTransfer);\r\n\r\n        emit TicketsClaim(msg.sender, rewardInCakeToTransfer, _lotteryId, _ticketIds.length);\r\n    }\r\n\r\n    /**\r\n     * @notice Close lottery\r\n     * @param _lotteryId: lottery id\r\n     * @dev Callable by operator\r\n     */\r\n    function closeLottery(uint256 _lotteryId) external override onlyOwnerOrOperator nonReentrant {\r\n        require(_lotteries[_lotteryId].status == Status.Open, \"Lottery not open\");\r\n        require(block.timestamp > _lotteries[_lotteryId].endTime, \"Lottery not over\");\r\n        _lotteries[_lotteryId].firstTicketIdNextLottery = currentTicketId;\r\n\r\n        _lotteries[_lotteryId].status = Status.Close;\r\n\r\n        emit LotteryClose(_lotteryId, currentTicketId);\r\n    }\r\n\r\n    /**\r\n     * @notice Draw the final number, calculate reward in CAKE per group, and make lottery claimable\r\n     * @param _lotteryId: lottery id\r\n     * @param _autoInjection: reinjects funds into next lottery (vs. withdrawing all)\r\n     * @dev Callable by operator\r\n     */\r\n    function drawFinalNumberAndMakeLotteryClaimable(uint256 _lotteryId, bytes32 _seed, bool _autoInjection)\r\n        external\r\n        override\r\n        onlyOwnerOrOperator\r\n        nonReentrant\r\n    {\r\n        require(_lotteries[_lotteryId].status == Status.Close, \"Lottery not close\");\r\n\r\n        // Initialize a number to count addresses in the previous bracket\r\n        uint256 numberAddressesInPreviousBracket;\r\n\r\n        // Calculate the amount to share post-treasury fee\r\n        uint256 amountToShareToWinners = (\r\n            ((_lotteries[_lotteryId].amountCollectedInCake) * (10000 - _lotteries[_lotteryId].treasuryFee))\r\n        ) / 10000;\r\n\r\n        uint256 randomness = uint(keccak256(abi.encodePacked(\r\n            block.timestamp,\r\n            _seed,\r\n            _lotteryId,\r\n            _lotteries[_lotteryId].firstTicketId,\r\n            _lotteries[_lotteryId].firstTicketIdNextLottery,\r\n            _lotteries[_lotteryId].amountCollectedInCake,\r\n            amountToShareToWinners,\r\n            blockhash(block.number),\r\n            block.coinbase,\r\n            block.difficulty,\r\n            block.gaslimit,\r\n            tx.gasprice\r\n        )));        \r\n        uint32 finalNumber = uint32(1000000 + (randomness % 1000000));\r\n        // Initializes the amount to withdraw to treasury\r\n        uint256 amountToWithdrawToTreasury;\r\n\r\n        // Calculate prizes in CAKE for each bracket by starting from the highest one\r\n        for (uint32 i = 0; i < numbersCount; i++) {\r\n            uint32 j = numbersCount - 1 - i;\r\n            uint32 transformedWinningNumber = _bracketCalculator[j] + (finalNumber % (uint32(10)**(j + 1)));\r\n\r\n            _lotteries[_lotteryId].countWinnersPerBracket[j] =\r\n                _numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -\r\n                numberAddressesInPreviousBracket;\r\n\r\n            // A. If number of users for this _bracket number is superior to 0\r\n            if (\r\n                (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] - numberAddressesInPreviousBracket) !=\r\n                0\r\n            ) {\r\n                // B. If rewards at this bracket are > 0, calculate, else, report the numberAddresses from previous bracket\r\n                if (_lotteries[_lotteryId].rewardsBreakdown[j] != 0) {\r\n                    _lotteries[_lotteryId].cakePerBracket[j] =\r\n                        ((_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /\r\n                            (_numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber] -\r\n                                numberAddressesInPreviousBracket)) /\r\n                        10000;\r\n\r\n                    // Update numberAddressesInPreviousBracket\r\n                    numberAddressesInPreviousBracket = _numberTicketsPerLotteryId[_lotteryId][transformedWinningNumber];\r\n                }\r\n                // A. No CAKE to distribute, they are added to the amount to withdraw to treasury address\r\n            } else {\r\n                _lotteries[_lotteryId].cakePerBracket[j] = 0;\r\n\r\n                amountToWithdrawToTreasury +=\r\n                    (_lotteries[_lotteryId].rewardsBreakdown[j] * amountToShareToWinners) /\r\n                    10000;\r\n            }\r\n        }\r\n\r\n        // Update internal statuses for lottery\r\n        _lotteries[_lotteryId].finalNumber = finalNumber;\r\n        _lotteries[_lotteryId].status = Status.Claimable;\r\n\r\n        if (_autoInjection) {\r\n            pendingInjectionNextLottery = amountToWithdrawToTreasury;\r\n            amountToWithdrawToTreasury = 0;\r\n        }\r\n\r\n        amountToWithdrawToTreasury += (_lotteries[_lotteryId].amountCollectedInCake - amountToShareToWinners);\r\n\r\n        if (OnoutFeeEnabled) {\r\n            // Transfer CAKE to OnoutFee address\r\n            uint256 amountToOnoutFee = amountToWithdrawToTreasury / 100 * OnoutFee;\r\n            amountToWithdrawToTreasury = amountToWithdrawToTreasury - amountToOnoutFee;\r\n            cakeToken.safeTransfer(OnoutAddress, amountToOnoutFee);\r\n        }\r\n        // Transfer CAKE to treasury address\r\n        cakeToken.safeTransfer(treasuryAddress, amountToWithdrawToTreasury);\r\n        emit LotteryNumberDrawn(currentLotteryId, finalNumber, numberAddressesInPreviousBracket);\r\n    }\r\n\r\n    /**\r\n     * @notice Inject funds\r\n     * @param _lotteryId: lottery id\r\n     * @param _amount: amount to inject in CAKE token\r\n     * @dev Callable by owner or injector address\r\n     */\r\n    function injectFunds(uint256 _lotteryId, uint256 _amount) external override onlyOwnerOrInjector {\r\n        require(_lotteries[_lotteryId].status == Status.Open, \"Lottery not open\");\r\n\r\n        cakeToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n        _lotteries[_lotteryId].amountCollectedInCake += _amount;\r\n\r\n        emit LotteryInjection(_lotteryId, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Start the lottery\r\n     * @dev Callable by operator\r\n     * @param _endTime: endTime of the lottery\r\n     * @param _priceTicketInCake: price of a ticket in CAKE\r\n     * @param _discountDivisor: the divisor to calculate the discount magnitude for bulks\r\n     * @param _rewardsBreakdown: breakdown of rewards per bracket (must sum to 10,000)\r\n     * @param _treasuryFee: treasury fee (10,000 = 100%, 100 = 1%)\r\n     */\r\n    function startLottery(\r\n        uint256 _endTime,\r\n        uint256 _priceTicketInCake,\r\n        uint256 _discountDivisor,\r\n        uint256[6] calldata _rewardsBreakdown,\r\n        uint256 _treasuryFee\r\n    ) external override onlyOwnerOrOperator {\r\n        require(\r\n            (currentLotteryId == 0) || (_lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Not time to start lottery\"\r\n        );\r\n\r\n        require(\r\n            ((_endTime - block.timestamp) > MIN_LENGTH_LOTTERY) && ((_endTime - block.timestamp) < MAX_LENGTH_LOTTERY),\r\n            \"Lottery length outside of range\"\r\n        );\r\n/*\r\n        require(\r\n            (_priceTicketInCake >= minPriceTicketInCake) && (_priceTicketInCake <= maxPriceTicketInCake),\r\n            \"Outside of limits\"\r\n        );\r\n*/\r\n        require(_discountDivisor >= MIN_DISCOUNT_DIVISOR, \"Discount divisor too low\");\r\n        require(_treasuryFee <= MAX_TREASURY_FEE, \"Treasury fee too high\");\r\n\r\n        require(\r\n            (_rewardsBreakdown[0] +\r\n                _rewardsBreakdown[1] +\r\n                _rewardsBreakdown[2] +\r\n                _rewardsBreakdown[3] +\r\n                _rewardsBreakdown[4] +\r\n                _rewardsBreakdown[5]) == 10000,\r\n            \"Rewards must equal 10000\"\r\n        );\r\n\r\n        currentLotteryId++;\r\n\r\n        _lotteries[currentLotteryId] = Lottery({\r\n            status: Status.Open,\r\n            startTime: block.timestamp,\r\n            endTime: _endTime,\r\n            priceTicketInCake: _priceTicketInCake,\r\n            discountDivisor: _discountDivisor,\r\n            rewardsBreakdown: _rewardsBreakdown,\r\n            treasuryFee: _treasuryFee,\r\n            cakePerBracket: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)],\r\n            countWinnersPerBracket: [uint256(0), uint256(0), uint256(0), uint256(0), uint256(0), uint256(0)],\r\n            firstTicketId: currentTicketId,\r\n            firstTicketIdNextLottery: currentTicketId,\r\n            amountCollectedInCake: pendingInjectionNextLottery,\r\n            finalNumber: 0\r\n        });\r\n\r\n        emit LotteryOpen(\r\n            currentLotteryId,\r\n            block.timestamp,\r\n            _endTime,\r\n            _priceTicketInCake,\r\n            currentTicketId,\r\n            pendingInjectionNextLottery\r\n        );\r\n\r\n        pendingInjectionNextLottery = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice It allows the admin to recover wrong tokens sent to the contract\r\n     * @param _tokenAddress: the address of the token to withdraw\r\n     * @param _tokenAmount: the number of token amount to withdraw\r\n     * @dev Only callable by owner.\r\n     */\r\n    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\r\n        require(_tokenAddress == address(cakeToken), \"You dont can recover lottery token\");\r\n        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\r\n\r\n        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\r\n    }\r\n\r\n    function withdrawBank(uint256 _tokenAmount) external onlyOwner {\r\n        require(\r\n            (currentLotteryId == 0) || (_lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"You cant withdraw bank while lottery is not finished\"\r\n        );\r\n        require(block.timestamp > _lotteries[currentLotteryId].endTime + withdrawCooldown, \"Withdraw cooldown!\");\r\n\r\n        if (OnoutFeeEnabled) {\r\n            uint256 onoutFeeAmount = _tokenAmount / 100 * OnoutFee;\r\n            _tokenAmount = _tokenAmount - onoutFeeAmount;\r\n            cakeToken.safeTransfer(OnoutAddress, onoutFeeAmount);\r\n        }\r\n        cakeToken.safeTransfer(msg.sender, _tokenAmount);\r\n    }\r\n\r\n    function setNumbersCount(uint32 _numbersCount) external onlyOwner\r\n    {\r\n        require(_numbersCount <=6, \"numbersCount must be <= 6\");\r\n        require(_numbersCount >=2, \"numbersCount must be >= 2\");\r\n        require(\r\n            (currentLotteryId == 0) || (_lotteries[currentLotteryId].status == Status.Claimable),\r\n            \"Has not finished lottery\"\r\n        );\r\n\r\n        numbersCount = _numbersCount;\r\n    }\r\n    /**\r\n     * @notice Set CAKE price ticket upper/lower limit\r\n     * @dev Only callable by owner\r\n     * @param _minPriceTicketInCake: minimum price of a ticket in CAKE\r\n     * @param _maxPriceTicketInCake: maximum price of a ticket in CAKE\r\n     */\r\n    function setMinAndMaxTicketPriceInCake(uint256 _minPriceTicketInCake, uint256 _maxPriceTicketInCake)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_minPriceTicketInCake <= _maxPriceTicketInCake, \"minPrice must be < maxPrice\");\r\n\r\n        minPriceTicketInCake = _minPriceTicketInCake;\r\n        maxPriceTicketInCake = _maxPriceTicketInCake;\r\n    }\r\n\r\n    /**\r\n     * @notice Set max number of tickets\r\n     * @dev Only callable by owner\r\n     */\r\n    function setMaxNumberTicketsPerBuy(uint256 _maxNumberTicketsPerBuy) external onlyOwner {\r\n        require(_maxNumberTicketsPerBuy != 0, \"Must be > 0\");\r\n        maxNumberTicketsPerBuyOrClaim = _maxNumberTicketsPerBuy;\r\n    }\r\n\r\n    /**\r\n     * @notice Set operator, treasury, and injector addresses\r\n     * @dev Only callable by owner\r\n     * @param _operatorAddress: address of the operator\r\n     * @param _treasuryAddress: address of the treasury\r\n     * @param _injectorAddress: address of the injector\r\n     */\r\n    function setOperatorAndTreasuryAndInjectorAddresses(\r\n        address _operatorAddress,\r\n        address _treasuryAddress,\r\n        address _injectorAddress\r\n    ) external onlyOwner {\r\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\r\n        require(_treasuryAddress != address(0), \"Cannot be zero address\");\r\n        require(_injectorAddress != address(0), \"Cannot be zero address\");\r\n\r\n        operatorAddress = _operatorAddress;\r\n        treasuryAddress = _treasuryAddress;\r\n        injectorAddress = _injectorAddress;\r\n\r\n        emit NewOperatorAndTreasuryAndInjectorAddresses(_operatorAddress, _treasuryAddress, _injectorAddress);\r\n    }\r\n\r\n    function setOperatorAddresses(\r\n        address _operatorAddress\r\n    ) external onlyOwner {\r\n        require(_operatorAddress != address(0), \"Cannot be zero address\");\r\n\r\n        operatorAddress = _operatorAddress;\r\n    }\r\n    /**\r\n     * @notice Calculate price of a set of tickets\r\n     * @param _discountDivisor: divisor for the discount\r\n     * @param _priceTicket price of a ticket (in CAKE)\r\n     * @param _numberTickets number of tickets to buy\r\n     */\r\n    function calculateTotalPriceForBulkTickets(\r\n        uint256 _discountDivisor,\r\n        uint256 _priceTicket,\r\n        uint256 _numberTickets\r\n    ) external pure returns (uint256) {\r\n        require(_discountDivisor >= MIN_DISCOUNT_DIVISOR, \"Must be >= MIN_DISCOUNT_DIVISOR\");\r\n        require(_numberTickets != 0, \"Number of tickets must be > 0\");\r\n\r\n        return _calculateTotalPriceForBulkTickets(_discountDivisor, _priceTicket, _numberTickets);\r\n    }\r\n\r\n    /**\r\n     * @notice View current lottery id\r\n     */\r\n    function viewCurrentLotteryId() external view override returns (uint256) {\r\n        return currentLotteryId;\r\n    }\r\n\r\n    /**\r\n     * @notice View lottery information\r\n     * @param _lotteryId: lottery id\r\n     */\r\n    function viewLottery(uint256 _lotteryId) external view returns (Lottery memory) {\r\n        return _lotteries[_lotteryId];\r\n    }\r\n\r\n    /**\r\n     * @notice View ticker statuses and numbers for an array of ticket ids\r\n     * @param _ticketIds: array of _ticketId\r\n     */\r\n    function viewNumbersAndStatusesForTicketIds(uint256[] calldata _ticketIds)\r\n        external\r\n        view\r\n        returns (uint32[] memory, bool[] memory)\r\n    {\r\n        uint256 length = _ticketIds.length;\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            ticketNumbers[i] = _tickets[_ticketIds[i]].number;\r\n            if (_tickets[_ticketIds[i]].owner == address(0)) {\r\n                ticketStatuses[i] = true;\r\n            } else {\r\n                ticketStatuses[i] = false;\r\n            }\r\n        }\r\n\r\n        return (ticketNumbers, ticketStatuses);\r\n    }\r\n\r\n    /**\r\n     * @notice View rewards for a given ticket, providing a bracket, and lottery id\r\n     * @dev Computations are mostly offchain. This is used to verify a ticket!\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketId: ticket id\r\n     * @param _bracket: bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function viewRewardsForTicketId(\r\n        uint256 _lotteryId,\r\n        uint256 _ticketId,\r\n        uint32 _bracket\r\n    ) external view returns (uint256) {\r\n        // Check lottery is in claimable status\r\n        if (_lotteries[_lotteryId].status != Status.Claimable) {\r\n            return 0;\r\n        }\r\n\r\n        // Check ticketId is within range\r\n        if (\r\n            (_lotteries[_lotteryId].firstTicketIdNextLottery < _ticketId) &&\r\n            (_lotteries[_lotteryId].firstTicketId >= _ticketId)\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        return _calculateRewardsForTicketId(_lotteryId, _ticketId, _bracket);\r\n    }\r\n\r\n    /**\r\n     * @notice View user ticket ids, numbers, and statuses of user for a given lottery\r\n     * @param _user: user address\r\n     * @param _lotteryId: lottery id\r\n     * @param _cursor: cursor to start where to retrieve the tickets\r\n     * @param _size: the number of tickets to retrieve\r\n     */\r\n    function viewUserInfoForLotteryId(\r\n        address _user,\r\n        uint256 _lotteryId,\r\n        uint256 _cursor,\r\n        uint256 _size\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory,\r\n            uint32[] memory,\r\n            bool[] memory,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 length = _size;\r\n        uint256 numberTicketsBoughtAtLotteryId = _userTicketIdsPerLotteryId[_user][_lotteryId].length;\r\n\r\n        if (length > (numberTicketsBoughtAtLotteryId - _cursor)) {\r\n            length = numberTicketsBoughtAtLotteryId - _cursor;\r\n        }\r\n\r\n        uint256[] memory lotteryTicketIds = new uint256[](length);\r\n        uint32[] memory ticketNumbers = new uint32[](length);\r\n        bool[] memory ticketStatuses = new bool[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            lotteryTicketIds[i] = _userTicketIdsPerLotteryId[_user][_lotteryId][i + _cursor];\r\n            ticketNumbers[i] = _tickets[lotteryTicketIds[i]].number;\r\n\r\n            // True = ticket claimed\r\n            if (_tickets[lotteryTicketIds[i]].owner == address(0)) {\r\n                ticketStatuses[i] = true;\r\n            } else {\r\n                // ticket not claimed (includes the ones that cannot be claimed)\r\n                ticketStatuses[i] = false;\r\n            }\r\n        }\r\n\r\n        return (lotteryTicketIds, ticketNumbers, ticketStatuses, _cursor + length);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate rewards for a given ticket\r\n     * @param _lotteryId: lottery id\r\n     * @param _ticketId: ticket id\r\n     * @param _bracket: bracket for the ticketId to verify the claim and calculate rewards\r\n     */\r\n    function _calculateRewardsForTicketId(\r\n        uint256 _lotteryId,\r\n        uint256 _ticketId,\r\n        uint32 _bracket\r\n    ) internal view returns (uint256) {\r\n        // Retrieve the winning number combination\r\n        uint32 userNumber = _lotteries[_lotteryId].finalNumber;\r\n\r\n        // Retrieve the user number combination from the ticketId\r\n        uint32 winningTicketNumber = _tickets[_ticketId].number;\r\n\r\n        // Apply transformation to verify the claim provided by the user is true\r\n        uint32 transformedWinningNumber = _bracketCalculator[_bracket] +\r\n            (winningTicketNumber % (uint32(10)**(_bracket + 1)));\r\n\r\n        uint32 transformedUserNumber = _bracketCalculator[_bracket] + (userNumber % (uint32(10)**(_bracket + 1)));\r\n\r\n        // Confirm that the two transformed numbers are the same, if not throw\r\n        if (transformedWinningNumber == transformedUserNumber) {\r\n            return _lotteries[_lotteryId].cakePerBracket[_bracket];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate final price for bulk of tickets\r\n     * @param _discountDivisor: divisor for the discount (the smaller it is, the greater the discount is)\r\n     * @param _priceTicket: price of a ticket\r\n     * @param _numberTickets: number of tickets purchased\r\n     */\r\n    function _calculateTotalPriceForBulkTickets(\r\n        uint256 _discountDivisor,\r\n        uint256 _priceTicket,\r\n        uint256 _numberTickets\r\n    ) internal pure returns (uint256) {\r\n        return (_priceTicket * _numberTickets * (_discountDivisor + 1 - _numberTickets)) / _discountDivisor;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if an address is a contract\r\n     */\r\n    function _isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cakeTokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_OnoutFeeEnabled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTicketIdNextLottery\",\"type\":\"uint256\"}],\"name\":\"LotteryClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"injectedAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryInjection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"countWinningTickets\",\"type\":\"uint256\"}],\"name\":\"LotteryNumberDrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceTicketInCake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTicketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"injectedAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"injector\",\"type\":\"address\"}],\"name\":\"NewOperatorAndTreasuryAndInjectorAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"TicketsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberTickets\",\"type\":\"uint256\"}],\"name\":\"TicketsPurchase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LENGTH_LOTTERY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TREASURY_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DISCOUNT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LENGTH_LOTTERY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OnoutAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OnoutFeeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint32[]\",\"name\":\"_ticketNumbers\",\"type\":\"uint32[]\"}],\"name\":\"buyTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_discountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceTicket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberTickets\",\"type\":\"uint256\"}],\"name\":\"calculateTotalPriceForBulkTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_ticketIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_brackets\",\"type\":\"uint32[]\"}],\"name\":\"claimTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"}],\"name\":\"closeLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTicketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_seed\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_autoInjection\",\"type\":\"bool\"}],\"name\":\"drawFinalNumberAndMakeLotteryClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"injectFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"injectorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxNumberTicketsPerBuyOrClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceTicketInCake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPriceTicketInCake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numbersCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingInjectionNextLottery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverWrongTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxNumberTicketsPerBuy\",\"type\":\"uint256\"}],\"name\":\"setMaxNumberTicketsPerBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPriceTicketInCake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPriceTicketInCake\",\"type\":\"uint256\"}],\"name\":\"setMinAndMaxTicketPriceInCake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_numbersCount\",\"type\":\"uint32\"}],\"name\":\"setNumbersCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeAddress\",\"type\":\"address\"}],\"name\":\"setOnoutAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setOnoutFeeEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"}],\"name\":\"setOperatorAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_injectorAddress\",\"type\":\"address\"}],\"name\":\"setOperatorAndTreasuryAndInjectorAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_priceTicketInCake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_discountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"_rewardsBreakdown\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"}],\"name\":\"startLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewCurrentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"}],\"name\":\"viewLottery\",\"outputs\":[{\"components\":[{\"internalType\":\"enum PancakeSwapLottery.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceTicketInCake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"rewardsBreakdown\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[6]\",\"name\":\"cakePerBracket\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256[6]\",\"name\":\"countWinnersPerBracket\",\"type\":\"uint256[6]\"},{\"internalType\":\"uint256\",\"name\":\"firstTicketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstTicketIdNextLottery\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCollectedInCake\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"finalNumber\",\"type\":\"uint32\"}],\"internalType\":\"struct PancakeSwapLottery.Lottery\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ticketIds\",\"type\":\"uint256[]\"}],\"name\":\"viewNumbersAndStatusesForTicketIds\",\"outputs\":[{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_bracket\",\"type\":\"uint32\"}],\"name\":\"viewRewardsForTicketId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lotteryId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"viewUserInfoForLotteryId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32[]\",\"name\":\"\",\"type\":\"uint32[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawBank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PancakeSwapLottery", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "00000000000000000000000088608399c5a236d506b51c165fd2d43dee770f140000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a681063756bfeac9cf996645d58d2510aaab2ed3fa2e96391931a914159ad031"}