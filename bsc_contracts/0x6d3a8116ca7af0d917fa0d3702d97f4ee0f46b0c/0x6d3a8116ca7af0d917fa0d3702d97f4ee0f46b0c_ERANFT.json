{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"ContractOwner.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nabstract contract ContractOwner {\\r\\n    address public contractOwner = msg.sender;\\r\\n    \\r\\n    modifier ContractOwnerOnly {\\r\\n        require(msg.sender == contractOwner, \\\"contract owner only\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"},\"ERAnft.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./String.sol\\\";\\r\\nimport \\\"./Util.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\nimport \\\"./Member.sol\\\";\\r\\ninterface IMarket{\\r\\n    function createOrder(uint256 tokenid, uint256 tradeAmount) external;\\r\\n}\\r\\n\\r\\ninterface IPromote{\\r\\n    function update(uint256 amount) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\ncontract ERANFT is ERC721,Member {\\r\\n    using String for string;\\r\\n\\tusing SafeERC20 for IERC20;\\r\\n\\tusing SafeMath for uint256;\\r\\n    \\r\\n    uint256 public constant NFT_TotalSupply = 87600;\\r\\n    // uint256 public NFT_Price = 50;    //\u7528\u6237\u521b\u9020NFT\u5355\u4ef7\\r\\n    uint256 public PreOlder_Price = 500 * 1e18; \\r\\n    \\r\\n    uint256 public NFT_Id = 0;\\r\\n    uint256 public UserMintNFT_Id = 87600;\\r\\n    uint256 public preStart;         //\u9884\u552e\u5f00\u59cb\u65f6\u95f4\\r\\n    uint256 public officalStart;\\r\\n    uint256[] public nftPowerPrice = [500,1000,2000,4000,8000,16000];\\r\\n\\r\\n    // bool isInitialized;\\r\\n    bool paused = true;\\r\\n    bool public isPreStart;\\r\\n    uint256 public constant PRE_TOTAL = 600;\\r\\n    uint256 public preCount;\\r\\n    uint256 public onceMax;\\r\\n    uint256 public onceCount;\\r\\n\\r\\n\\r\\n\\r\\n    IERC20 public usdt;\\r\\n    IERC20 public era;\\r\\n    IUniswapV2Pair public pair;\\r\\n\\r\\n    mapping(uint256 =\\u003e starAttributesStruct) public starAttributes;\\r\\n    mapping(string =\\u003e bool) public isSold;\\r\\n    mapping(address =\\u003e bool) public preBuy;\\r\\n    mapping(address =\\u003e bool) public whiteList;\\r\\n\\r\\n\\r\\n    event PreMint(address indexed origin, address indexed owner,string iphshash,uint256 power, uint256 TokenId);\\r\\n    event OfficalMint(address indexed origin, address indexed owner,string iphshash,uint256 power, uint256 TokenId, uint256 ERAprice);\\r\\n    event UserMint(address indexed origin, uint256 indexed price,string iphshash,uint256 power, uint256 TokenId);\\r\\n\\r\\n    event NftTransfer(address indexed from, address to, uint256 tokenid);\\r\\n\\r\\n    struct starAttributesStruct{\\r\\n      address origin;   //\u53d1\u5e03\u8005\\r\\n      string  IphsHash;//hash\\r\\n      uint256 power;//nft\u7b49\u7ea7\\r\\n      uint256 price;   //\u4ef7\u683c\\r\\n      uint256 stampFee;  //\u7248\u7a0e\\r\\n      bool offical;\\r\\n    }\\r\\n \\r\\n    constructor(IERC20 _usdt, IERC20 _era, IUniswapV2Pair _pair)\\r\\n        ERC721(\\\"NINANCE NFT\\\", \\\"NINANCE\\\") {\\r\\n            usdt = _usdt;\\r\\n            era = _era;\\r\\n            pair = _pair;\\r\\n    }\\r\\n\\r\\n    modifier onlyDev() {\\r\\n        require(manager.members(\\\"dev\\\") == msg.sender, \\\"only dev\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWhiteList() {\\r\\n        require(whiteList[msg.sender], \\\"Only white list\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    function preOfficalStart(uint256 start, uint256 num) public {\\r\\n        require(msg.sender == manager.members(\\\"owner\\\"));\\r\\n        require(num \\u003c= PRE_TOTAL - preCount, \\\"num is valid\\\");\\r\\n        preStart = start;\\r\\n        onceMax = num;\\r\\n        onceCount = 0;\\r\\n    }\\r\\n\\r\\n    function transfer(address to,uint256 tokenId) external payable returns(bool) {\\r\\n        _transferFrom(msg.sender, to, tokenId);\\r\\n        emit NftTransfer(msg.sender, to, tokenId);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function pauseOfficalMint(bool _switch) public{\\r\\n        require(msg.sender == address(manager.members(\\\"owner\\\")));\\r\\n        paused = _switch;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function, verify the signature.\\r\\n     */\\r\\n    function checkSig(string memory _hash, bytes32 _r, bytes32 _s, uint8 _v, bytes32 _challenge) view internal {\\r\\n        bytes  memory salt=abi.encodePacked(_hash, _challenge);\\r\\n        bytes  memory Message=abi.encodePacked(\\r\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n\\\",\\r\\n                    \\\"64\\\",\\r\\n                    salt\\r\\n                );\\r\\n        bytes32 digest = keccak256(Message);\\r\\n        address signer=ecrecover(digest, _v, _r, _s);\\r\\n        require(signer != address(0), \\\"signer: address 0\\\");\\r\\n        require(signer == manager.members(\\\"relayer\\\"), \\\"invalid signature\\\");\\r\\n    }\\r\\n    \\r\\n    function mintinternal(address origin, address to, string  memory ipfsHash, uint256 power,uint256 price,uint256 stampFee,bool isOffcial) internal {\\r\\n        if(isOffcial){\\r\\n            NFT_Id++;\\r\\n            require(NFT_Id \\u003c= NFT_TotalSupply,\\\"Already Max\\\");\\r\\n            starAttributes[NFT_Id].origin = origin;\\r\\n            starAttributes[NFT_Id].IphsHash = ipfsHash;\\r\\n            starAttributes[NFT_Id].power = power;\\r\\n            starAttributes[NFT_Id].price = nftPowerPrice[0];\\r\\n            starAttributes[NFT_Id].stampFee = stampFee;\\r\\n            starAttributes[NFT_Id].offical = isOffcial;\\r\\n            _mint(to, NFT_Id);\\r\\n        }\\r\\n        else{\\r\\n            UserMintNFT_Id++;\\r\\n            starAttributes[UserMintNFT_Id].origin = origin;\\r\\n            starAttributes[UserMintNFT_Id].IphsHash = ipfsHash;\\r\\n            starAttributes[UserMintNFT_Id].power = power;\\r\\n            starAttributes[UserMintNFT_Id].price = price;\\r\\n            starAttributes[UserMintNFT_Id].stampFee = stampFee;\\r\\n            starAttributes[UserMintNFT_Id].offical = isOffcial;\\r\\n            _mint(to, UserMintNFT_Id);\\r\\n        }\\r\\n        isSold[ipfsHash] = true;\\r\\n    }\\r\\n    \\r\\n    function burn(uint256 Id) external {\\r\\n        address owner = tokenOwners[Id];\\r\\n        require(msg.sender == owner\\r\\n            || msg.sender == tokenApprovals[Id]\\r\\n            || approvalForAlls[owner][msg.sender],\\r\\n            \\\"msg.sender must be owner or approved\\\");\\r\\n        \\r\\n        _burn(Id);\\r\\n    }\\r\\n    \\r\\n    function tokenURI(uint256 NftId) external view override returns(string memory) {\\r\\n        bytes memory bs = abi.encodePacked(NftId);\\r\\n        return uriPrefix.concat(\\\"nft/\\\").concat(Util.base64Encode(bs));\\r\\n    }\\r\\n    \\r\\n    function setUriPrefix(string memory prefix) external  {\\r\\n        require(msg.sender == manager.members(\\\"owner\\\"));\\r\\n        uriPrefix = prefix;\\r\\n    }\\r\\n\\r\\n    function batchAddToWhitelist(address[] memory _users) public ContractOwnerOnly {\\r\\n        uint256 i;\\r\\n        uint256 len = _users.length;\\r\\n        for(i; i \\u003c len; i++) {\\r\\n            require(_users[i] != address(0), \\\"address 0\\\");\\r\\n            require(!whiteList[_users[i]], \\\"exist\\\");\\r\\n            whiteList[_users[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeWhitelist(address _user) public ContractOwnerOnly {\\r\\n        require(_user != address(0), \\\"address 0\\\");\\r\\n        require(whiteList[_user], \\\"not in white list\\\");\\r\\n        whiteList[_user] = false;\\r\\n    }\\r\\n\\r\\n    function preOfficalMint(string memory _hash, bytes32 _r, bytes32 _s, uint8 _v, bytes32 _challenge) onlyWhiteList public returns(uint256){            //\u9884\u8d2d\\r\\n        require(isSold[_hash] == false, \\\"Sold\\\");\\r\\n        require(block.timestamp \\u003e= preStart,\\\"NOT start!\\\");\\r\\n        require(preCount \\u003c 600 \\u0026\\u0026 onceCount \\u003c onceMax ,\\\"Sale Over!\\\");\\r\\n        require(!preBuy[msg.sender], \\\"Can only pre buy once\\\");\\r\\n        checkSig(_hash, _r, _s, _v, _challenge);\\r\\n        preBuy[msg.sender] = true;\\r\\n        address user = msg.sender;\\r\\n        uint256 needPay = PreOlder_Price;\\r\\n        IERC20(usdt).transferFrom(user,address(manager.members(\\\"OfficalAddress\\\")),needPay);\\r\\n        mintinternal(user,user,_hash,1,0,50,true);\\r\\n        emit PreMint(user,user, _hash, 1, NFT_Id);\\r\\n        preCount++;\\r\\n        onceCount++;\\r\\n        return NFT_Id;\\r\\n\\r\\n    }\\r\\n\\r\\n    function officalMint(string memory _hash) public returns(uint256){              //\u5b98\u65b9\u521b\u5efa\\r\\n        require(isSold[_hash] == false, \\\"Sold\\\");\\r\\n        require(paused == false, \\\"offical mint is paused\\\");\\r\\n        address user = msg.sender;\\r\\n        uint256 NFTprice = 525*1e18;\\r\\n        uint256 era_price = getPrice();\\r\\n        uint256 needPay = NFTprice.mul(1e18).div(era_price);\\r\\n        IERC20(era).transferFrom(user,address(this),needPay);\\r\\n        distribute(needPay);\\r\\n        mintinternal(user,user,_hash,1,0,50,true);\\r\\n        emit OfficalMint(user,user, _hash, 1, NFT_Id, needPay);\\r\\n        return NFT_Id;\\r\\n    }\\r\\n\\r\\n    function userMint(string memory _hash, uint256 stampFee) public returns(uint256){              //\u73a9\u5bb6\u521b\u5efa\\r\\n        require(stampFee \\u003e=0 \\u0026\\u0026 stampFee \\u003c=500,\\\"Out of range!\\\");\\r\\n        require(isSold[_hash] == false, \\\"Sold\\\");\\r\\n        address user = msg.sender;\\r\\n        mintinternal(user,user,_hash,0,0,stampFee,false);\\r\\n        emit UserMint(user,0, _hash, 0, UserMintNFT_Id);\\r\\n        return UserMintNFT_Id;\\r\\n    }\\r\\n\\r\\n    function changePower(uint256 tokenId,uint256 power) external returns(bool){\\r\\n        require(msg.sender == manager.members(\\\"updatecard\\\"),\\\"no permission\\\");\\r\\n        require(power \\u003e 1 \\u0026\\u0026 power \\u003c= 6,\\\"Out of range!\\\");\\r\\n        starAttributes[tokenId].power = power;\\r\\n        starAttributes[tokenId].price = nftPowerPrice[power-1];\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n\\r\\n    function getPrice() public view returns(uint256){\\r\\n        uint256 usd_balance;\\r\\n        uint256 rea_balance;\\r\\n        if (pair.token0() == address(usdt)) {\\r\\n          (usd_balance, rea_balance , ) = pair.getReserves();   \\r\\n        }  \\r\\n        else{\\r\\n          (rea_balance, usd_balance , ) = pair.getReserves();           \\r\\n        }\\r\\n        uint256 token_price = usd_balance.mul(1e18).div(rea_balance);\\r\\n        return token_price;\\r\\n    }\\r\\n\\r\\n    function getWeight(address user) public view returns(uint256){\\r\\n        uint256 len = ownerTokens[user].length;\\r\\n        uint256 weight = 0;\\r\\n        uint256[] storage tokens = ownerTokens[user];\\r\\n        for(uint256 i = 0;i \\u003c len;i++){\\r\\n            uint256 tokenId = tokens[i];\\r\\n            weight += starAttributes[tokenId].power;\\r\\n        }\\r\\n        return weight;\\r\\n    }\\r\\n\\r\\n    function distribute(uint256 needpay) internal{\\r\\n        uint256 OfficalAmount = needpay.mul(1).div(21); \\r\\n        uint256 PromoteAmount = needpay.mul(4).div(21);\\r\\n        uint256 burnAmount = needpay.sub(OfficalAmount).sub(PromoteAmount);\\r\\n        \\r\\n        IERC20(era).transfer(address(manager.members(\\\"OfficalAddress\\\")),OfficalAmount);           //\u5b98\u65b9\u5730\u5740\\r\\n        IERC20(era).transfer(address(manager.members(\\\"PromoteAddress\\\")),PromoteAmount);              //\u63a8\u5e7f\u5956\u52b1\u5730\u5740\\r\\n        IPromote(manager.members(\\\"PromoteAddress\\\")).update(PromoteAmount);\\r\\n        IERC20(era).burn(burnAmount); \\r\\n        \\r\\n    }\\r\\n\\r\\n    function withdrawFunds(IERC20 token,uint256 amount) public returns(bool){\\r\\n        require(msg.sender == manager.members(\\\"owner\\\"));\\r\\n        if(amount \\u003e= token.balanceOf(address(this))){\\r\\n            amount = token.balanceOf(address(this));\\r\\n        }\\r\\n        token.transfer(manager.members(\\\"funder\\\"), amount);\\r\\n        return true;\\r\\n    } \\r\\n\\r\\n}\"},\"ERC721.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./IERC721Metadata.sol\\\";\\r\\nimport \\\"./IERC721TokenReceiver.sol\\\";\\r\\nimport \\\"./IERC721TokenReceiverEx.sol\\\";\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./Util.sol\\\";\\r\\n\\r\\nabstract contract ERC721 is IERC165, IERC721, IERC721Metadata {\\r\\n    using Address for address;\\r\\n    \\r\\n\\r\\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\\r\\n    \\r\\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\\r\\n    \\r\\n    bytes4 private constant INTERFACE_ID_ERC721Metadata = 0x5b5e139f;\\r\\n    \\r\\n    string public override name;\\r\\n    string public override symbol;\\r\\n    uint256 public totalSupply = 0;\\r\\n    string public uriPrefix = \\\"\\\";\\r\\n    \\r\\n    \\r\\n    mapping(address =\\u003e uint256[]) internal ownerTokens;         //\u73a9\u5bb6\u62e5\u6709\u4ee3\u5e01\u6570\u7ec4\\r\\n    mapping(uint256 =\\u003e uint256) internal tokenIndexs;            //\u73a9\u5bb6\u62e5\u6709nft\u4ee3\u5e01\u6570\u7ec4\u4e2d\u7684index\\r\\n    mapping(uint256 =\\u003e address) internal tokenOwners;         //\u6839\u636etokenId\u67e5\u8be2\u73a9\u5bb6\u5730\u5740\\r\\n    \\r\\n    mapping(uint256 =\\u003e address) internal tokenApprovals;        //\u4ee3\u5e01\u6388\u6743\\r\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) internal approvalForAlls;       //owner\u5bf9\u5176\u4ed6\u5730\u5740\u7684\u6388\u6743\\r\\n    \\r\\n    constructor(string memory _name, string memory _symbol) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address owner) external view override returns(uint256) {\\r\\n        require(owner != address(0), \\\"owner is zero address\\\");\\r\\n        return ownerTokens[owner].length;\\r\\n    }\\r\\n    \\r\\n    // [startIndex, endIndex)\\r\\n    function tokensOf(address owner, uint256 startIndex, uint256 endIndex)\\r\\n        external view returns(uint256[] memory) {\\r\\n        \\r\\n        require(owner != address(0), \\\"owner is zero address\\\");\\r\\n        \\r\\n        uint256[] storage tokens = ownerTokens[owner];\\r\\n        if (endIndex == 0) {\\r\\n            return tokens;\\r\\n        }\\r\\n        \\r\\n        require(startIndex \\u003c endIndex, \\\"invalid index\\\");\\r\\n        \\r\\n        uint256[] memory result = new uint256[](endIndex - startIndex);\\r\\n        for (uint256 i = startIndex; i != endIndex; ++i) {\\r\\n            result[i] = tokens[i];\\r\\n        }\\r\\n        \\r\\n        return result;\\r\\n    }\\r\\n    \\r\\n    function ownerOf(uint256 tokenId)\\r\\n        external view override returns(address) {\\r\\n        \\r\\n        address owner = tokenOwners[tokenId];\\r\\n        require(owner != address(0), \\\"nobody own the token\\\");\\r\\n        return owner;\\r\\n    }\\r\\n    \\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId)\\r\\n            external payable override {\\r\\n        \\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n    \\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId,\\r\\n        bytes memory data) public payable override {                     //\u5408\u7ea6\u8f6c\u8d26\\r\\n        \\r\\n        _transferFrom(from, to, tokenId);\\r\\n        \\r\\n        if (to.isContract()) {\\r\\n            require(IERC721TokenReceiver(to)\\r\\n                .onERC721Received(msg.sender, from, tokenId, data)\\r\\n                == Util.ERC721_RECEIVER_RETURN,\\r\\n                \\\"onERC721Received() return invalid\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function transferFrom(address from, address to, uint256 tokenId)\\r\\n        external payable override {               //\u666e\u901a\u4ee3\u7406\u8f6c\u8d26\\r\\n        \\r\\n        _transferFrom(from, to, tokenId);\\r\\n    }\\r\\n    \\r\\n    function _transferFrom(address from, address to, uint256 tokenId)\\r\\n        internal {\\r\\n        \\r\\n        require(from != address(0), \\\"from is zero address\\\");\\r\\n        require(to != address(0), \\\"to is zero address\\\");\\r\\n        \\r\\n        require(from == tokenOwners[tokenId], \\\"from must be owner\\\");\\r\\n        \\r\\n        require(msg.sender == from\\r\\n            || msg.sender == tokenApprovals[tokenId]\\r\\n            || approvalForAlls[from][msg.sender],\\r\\n            \\\"sender must be owner or approvaled\\\");\\r\\n        \\r\\n        if (tokenApprovals[tokenId] != address(0)) {\\r\\n            delete tokenApprovals[tokenId];\\r\\n        }\\r\\n        \\r\\n        _removeTokenFrom(from, tokenId);\\r\\n        _addTokenTo(to, tokenId);\\r\\n        \\r\\n        emit Transfer(from, to, tokenId);\\r\\n    }\\r\\n    \\r\\n    // ensure everything is ok before call it\\r\\n    function _removeTokenFrom(address from, uint256 tokenId) internal {\\r\\n        uint256 index = tokenIndexs[tokenId];  //0\\r\\n        \\r\\n        uint256[] storage tokens = ownerTokens[from];    \\r\\n        uint256 indexLast = tokens.length - 1;   \\r\\n        \\r\\n        // save gas\\r\\n        // if (index != indexLast) {\\r\\n            uint256 tokenIdLast = tokens[indexLast];   //1\\r\\n            tokens[index] = tokenIdLast;                 \\r\\n            tokenIndexs[tokenIdLast] = index;   //tokenIndexs[1]=0\\r\\n        // }\\r\\n        \\r\\n        tokens.pop();   //\u5220\u9664owner\u62e5\u6709nft\u4ee3\u5e01\u6570\u7ec4\\r\\n        \\r\\n        // delete tokenIndexs[tokenId]; // save gas\\r\\n        delete tokenOwners[tokenId];         //\u5220\u9664\u6620\u5c04\u8868\u4e2downer\u7684nft\u8bb0\u5f55\\r\\n    }\\r\\n    \\r\\n    // ensure everything is ok before call it\\r\\n    function _addTokenTo(address to, uint256 tokenId) internal {\\r\\n        uint256[] storage tokens = ownerTokens[to];\\r\\n        tokenIndexs[tokenId] = tokens.length;\\r\\n        tokens.push(tokenId);\\r\\n        \\r\\n        tokenOwners[tokenId] = to;\\r\\n    }\\r\\n    \\r\\n    function approve(address to, uint256 tokenId)\\r\\n        external payable override {\\r\\n        \\r\\n        address owner = tokenOwners[tokenId];\\r\\n        \\r\\n        require(msg.sender == owner\\r\\n            || approvalForAlls[owner][msg.sender],\\r\\n            \\\"sender must be owner or approved for all\\\"\\r\\n        );\\r\\n        \\r\\n        tokenApprovals[tokenId] = to;\\r\\n        emit Approval(owner, to, tokenId);\\r\\n    }\\r\\n    \\r\\n    function setApprovalForAll(address to, bool approved) external override {\\r\\n        approvalForAlls[msg.sender][to] = approved;\\r\\n        emit ApprovalForAll(msg.sender, to, approved);\\r\\n    }\\r\\n    \\r\\n    function getApproved(uint256 tokenId)\\r\\n        external view override returns(address) {\\r\\n        \\r\\n        require(tokenOwners[tokenId] != address(0),\\r\\n            \\\"nobody own then token\\\");\\r\\n        \\r\\n        return tokenApprovals[tokenId];\\r\\n    }\\r\\n    \\r\\n    function isApprovedForAll(address owner, address operator)\\r\\n        external view override returns(bool) {\\r\\n        \\r\\n        return approvalForAlls[owner][operator];\\r\\n    }\\r\\n    \\r\\n    function supportsInterface(bytes4 interfaceID)\\r\\n        external pure override returns(bool) {\\r\\n        \\r\\n        return interfaceID == INTERFACE_ID_ERC165\\r\\n            || interfaceID == INTERFACE_ID_ERC721\\r\\n            || interfaceID == INTERFACE_ID_ERC721Metadata;\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n    function _mint(address to, uint256 tokenId) internal {\\r\\n        _addTokenTo(to, tokenId);\\r\\n        \\r\\n        ++totalSupply;\\r\\n        \\r\\n        emit Transfer(address(0), to, tokenId);\\r\\n    }\\r\\n    \\r\\n    function _burn(uint256 tokenId) internal {\\r\\n        address owner = tokenOwners[tokenId];\\r\\n        _removeTokenFrom(owner, tokenId);\\r\\n        \\r\\n        if (tokenApprovals[tokenId] != address(0)) {\\r\\n            delete tokenApprovals[tokenId];\\r\\n        }\\r\\n        \\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n    }\\r\\n    \\r\\n    function safeBatchTransferFrom(address from, address to,\\r\\n        uint256[] memory tokenIds) external {                   //\u6279\u91cf\u8f6c\u8d26\\r\\n        \\r\\n        safeBatchTransferFrom(from, to, tokenIds, \\\"\\\");\\r\\n    }\\r\\n    \\r\\n    function safeBatchTransferFrom(address from, address to,\\r\\n        uint256[] memory tokenIds, bytes memory data) public {\\r\\n        \\r\\n        batchTransferFrom(from, to, tokenIds);\\r\\n        \\r\\n        if (to.isContract()) {\\r\\n            require(IERC721TokenReceiverEx(to)\\r\\n                .onERC721ExReceived(msg.sender, from, tokenIds, data)\\r\\n                == Util.ERC721_RECEIVER_EX_RETURN,\\r\\n                \\\"onERC721ExReceived() return invalid\\\");\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function batchTransferFrom(address from, address to,\\r\\n        uint256[] memory tokenIds) public {\\r\\n        \\r\\n        require(from != address(0), \\\"from is zero address\\\");\\r\\n        require(to != address(0), \\\"to is zero address\\\");\\r\\n        \\r\\n        uint256 length = tokenIds.length;\\r\\n        address sender = msg.sender;\\r\\n        \\r\\n        bool approval = from == sender || approvalForAlls[from][sender];\\r\\n        \\r\\n        for (uint256 i = 0; i != length; ++i) {\\r\\n            uint256 tokenId = tokenIds[i];\\r\\n\\t\\t\\t\\r\\n            require(from == tokenOwners[tokenId], \\\"from must be owner\\\");\\r\\n            require(approval || sender == tokenApprovals[tokenId],\\r\\n                \\\"sender must be owner or approvaled\\\");\\r\\n            \\r\\n            if (tokenApprovals[tokenId] != address(0)) {\\r\\n                delete tokenApprovals[tokenId];\\r\\n            }\\r\\n            \\r\\n            _removeTokenFrom(from, tokenId);\\r\\n            _addTokenTo(to, tokenId);\\r\\n            \\r\\n            emit Transfer(from, to, tokenId);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    \\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\"},\"IERC165.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0 \\u003c0.8.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns(bool);\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    \\r\\n    function name() external view returns(string memory);\\r\\n    function symbol() external view returns(string memory);\\r\\n    function decimals() external view returns(uint8);\\r\\n    function totalSupply() external view returns(uint256);\\r\\n    function balanceOf(address owner) external view returns(uint256);\\r\\n    function allowance(address owner, address spender) external view returns(uint256);\\r\\n    \\r\\n    function approve(address spender, uint256 value) external returns(bool);\\r\\n    function transfer(address to, uint256 value) external returns(bool);\\r\\n    function transferFrom(address from, address to, uint256 value) external returns(bool);\\r\\n\\r\\n    function burn(uint256 amount) external;\\r\\n}\\r\\n\"},\"IERC721.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\r\\ninterface IERC721 /* is ERC165 */ {\\r\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n    ///  may be created and assigned without emitting Transfer. At the time of\\r\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when the approved address for an NFT is changed or\\r\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\r\\n    ///  When a Transfer event emits, this also indicates that the approved\\r\\n    ///  address for that NFT (if any) is reset to none.\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n    ///  The operator can manage all NFTs of the owner.\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    /// @notice Count all NFTs assigned to an owner\\r\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n    ///  function throws for queries about the zero address.\\r\\n    /// @param _owner An address for whom to query the balance\\r\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n    function balanceOf(address _owner) external view returns(uint256);\\r\\n\\r\\n    /// @notice Find the owner of an NFT\\r\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n    ///  about them do throw.\\r\\n    /// @param _tokenId The identifier for an NFT\\r\\n    /// @return The address of the owner of the NFT\\r\\n    function ownerOf(uint256 _tokenId) external view returns(address);\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n    ///  checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\r\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev This works identically to the other function with an extra data parameter,\\r\\n    ///  except this function just sets data to \\\"\\\".\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n    ///  THEY MAY BE PERMANENTLY LOST\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Change or reaffirm the approved address for an NFT\\r\\n    /// @dev The zero address indicates there is no approved address.\\r\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n    ///  operator of the current owner.\\r\\n    /// @param _approved The new approved NFT controller\\r\\n    /// @param _tokenId The NFT to approve\\r\\n    function approve(address _approved, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n    ///  all of `msg.sender`\\u0027s assets\\r\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n    ///  multiple operators per owner.\\r\\n    /// @param _operator Address to add to the set of authorized operators\\r\\n    /// @param _approved True if the operator is approved, false to revoke approval\\r\\n    function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n    /// @notice Get the approved address for a single NFT\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n    /// @param _tokenId The NFT to find the approved address for\\r\\n    /// @return The approved address for this NFT, or the zero address if there is none\\r\\n    function getApproved(uint256 _tokenId) external view returns(address);\\r\\n\\r\\n    /// @notice Query if an address is an authorized operator for another address\\r\\n    /// @param _owner The address that owns the NFTs\\r\\n    /// @param _operator The address that acts on behalf of the owner\\r\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns(bool);\\r\\n}\\r\\n\"},\"IERC721Metadata.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\r\\ninterface IERC721Metadata /* is ERC721 */ {\\r\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\r\\n    function name() external view returns (string memory);\\r\\n    \\r\\n    /// @notice An abbreviated name for NFTs in this contract\\r\\n    function symbol() external view returns (string memory);\\r\\n    \\r\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\r\\n    ///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\r\\n    ///  Metadata JSON Schema\\\".\\r\\n    /// {\\\"name\\\":\\\"\\\",\\\"description\\\":\\\"\\\",\\\"image\\\":\\\"\\\"}\\r\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\r\\n}\"},\"IERC721TokenReceiver.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\r\\ninterface IERC721TokenReceiver {\\r\\n    /// @notice Handle the receipt of an NFT\\r\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\r\\n    ///  after a `transfer`. This function MAY throw to revert and reject the\\r\\n    ///  transfer. Return of other than the magic value MUST result in the\\r\\n    ///  transaction being reverted.\\r\\n    ///  Note: the contract address is always the message sender.\\r\\n    /// @param _operator The address which called `safeTransferFrom` function\\r\\n    /// @param _from The address which previously owned the token\\r\\n    /// @param _tokenId The NFT identifier which is being transferred\\r\\n    /// @param _data Additional data with no specified format\\r\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n    ///  unless throwing\\r\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\\r\\n}\\r\\n\"},\"IERC721TokenReceiverEx.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nimport \\\"./IERC721TokenReceiver.sol\\\";\\r\\n\\r\\ninterface IERC721TokenReceiverEx is IERC721TokenReceiver {\\r\\n    // bytes4(keccak256(\\\"onERC721ExReceived(address,address,uint256[],bytes)\\\")) = 0x0f7b88e3\\r\\n    function onERC721ExReceived(address operator, address from,\\r\\n        uint256[] memory tokenIds, bytes memory data)\\r\\n        external returns(bytes4);\\r\\n}\\r\\n\"},\"Manager.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nimport \\\"./ContractOwner.sol\\\";\\r\\n\\r\\ncontract Manager is ContractOwner {\\r\\n    mapping(string =\\u003e address) public members;\\r\\n    \\r\\n    mapping(address =\\u003e mapping(string =\\u003e bool)) public userPermits;\\r\\n    \\r\\n    function setMember(string memory name, address member)\\r\\n        external ContractOwnerOnly {\\r\\n        \\r\\n        members[name] = member;\\r\\n    }\\r\\n    \\r\\n    function setUserPermit(address user, string memory permit,\\r\\n        bool enable) external ContractOwnerOnly {\\r\\n        \\r\\n        userPermits[user][permit] = enable;\\r\\n    }\\r\\n    \\r\\n    function getTimestamp() external view returns(uint256) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n}\\r\\n\"},\"Member.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nimport \\\"./ContractOwner.sol\\\";\\r\\nimport \\\"./Manager.sol\\\";\\r\\n\\r\\nabstract contract Member is ContractOwner {\\r\\n    modifier CheckPermit(string memory permit) {\\r\\n        require(manager.userPermits(msg.sender, permit),\\r\\n            \\\"no permit\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    Manager public manager;\\r\\n    \\r\\n    function setManager(address addr) external ContractOwnerOnly {\\r\\n        manager = Manager(addr);\\r\\n    }\\r\\n}\\r\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"String.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nlibrary String {\\r\\n    function equals(string memory a, string memory b)\\r\\n        internal pure returns(bool) {\\r\\n        \\r\\n        bytes memory ba = bytes(a);\\r\\n        bytes memory bb = bytes(b);\\r\\n        \\r\\n        uint256 la = ba.length;\\r\\n        uint256 lb = bb.length;\\r\\n        \\r\\n        for (uint256 i = 0; i != la \\u0026\\u0026 i != lb; ++i) {\\r\\n            if (ba[i] != bb[i]) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return la == lb;\\r\\n    }\\r\\n    \\r\\n    function concat(string memory a, string memory b)\\r\\n        internal pure returns(string memory) {\\r\\n            \\r\\n        bytes memory ba = bytes(a);\\r\\n        bytes memory bb = bytes(b);\\r\\n        bytes memory bc = new bytes(ba.length + bb.length);\\r\\n        \\r\\n        uint256 bal = ba.length;\\r\\n        uint256 bbl = bb.length;\\r\\n        uint256 k = 0;\\r\\n        \\r\\n        for (uint256 i = 0; i != bal; ++i) {\\r\\n            bc[k++] = ba[i];\\r\\n        }\\r\\n        for (uint256 i = 0; i != bbl; ++i) {\\r\\n            bc[k++] = bb[i];\\r\\n        }\\r\\n        \\r\\n        return string(bc);\\r\\n    }\\r\\n}\\r\\n\"},\"Util.sol\":{\"content\":\"pragma solidity ^0.7.0;\\r\\n\\r\\n// SPDX-License-Identifier: SimPL-2.0\\r\\n\\r\\nlibrary Util {\\r\\n    bytes4 internal constant ERC721_RECEIVER_RETURN = 0x150b7a02;\\r\\n    bytes4 internal constant ERC721_RECEIVER_EX_RETURN = 0x0f7b88e3;\\r\\n    \\r\\n    uint256 public constant UDENO = 10 ** 10;\\r\\n    int256 public constant SDENO = 10 ** 10;\\r\\n    \\r\\n    uint256 public constant RARITY_WHITE = 0;\\r\\n    uint256 public constant RARITY_GREEN = 1;\\r\\n    uint256 public constant RARITY_BLUE = 2;\\r\\n    uint256 public constant RARITY_PURPLE = 3;\\r\\n    uint256 public constant RARITY_ORANGE = 4;\\r\\n    uint256 public constant RARITY_GOLD = 5;\\r\\n    \\r\\n    bytes public constant BASE64_CHARS = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\\\";\\r\\n    \\r\\n    function randomUint(bytes memory seed, uint256 min, uint256 max)\\r\\n        internal pure returns(uint256) {\\r\\n        \\r\\n        if (min \\u003e= max) {\\r\\n            return min;\\r\\n        }\\r\\n        \\r\\n        uint256 number = uint256(keccak256(seed));\\r\\n        return number % (max - min + 1) + min;\\r\\n    }\\r\\n    \\r\\n    function randomInt(bytes memory seed, int256 min, int256 max)\\r\\n        internal pure returns(int256) {\\r\\n        \\r\\n        if (min \\u003e= max) {\\r\\n            return min;\\r\\n        }\\r\\n        \\r\\n        int256 number = int256(keccak256(seed));\\r\\n        return number % (max - min + 1) + min;\\r\\n    }\\r\\n    \\r\\n    function randomWeight(bytes memory seed, uint256[] memory weights,\\r\\n        uint256 totalWeight) internal pure returns(uint256) {\\r\\n        \\r\\n        uint256 number = Util.randomUint(seed, 1, totalWeight);\\r\\n        \\r\\n        for (uint256 i = weights.length - 1; i != 0; --i) {\\r\\n            if (number \\u003c= weights[i]) {\\r\\n                return i;\\r\\n            }\\r\\n            \\r\\n            number -= weights[i];\\r\\n        }\\r\\n        \\r\\n        return 0;\\r\\n    }\\r\\n    \\r\\n    function randomProb(bytes memory seed, uint256 nume, uint256 deno)\\r\\n        internal pure returns(bool) {\\r\\n        \\r\\n        uint256 rand = Util.randomUint(seed, 1, deno);\\r\\n        return rand \\u003c= nume;\\r\\n    }\\r\\n    \\r\\n    function base64Encode(bytes memory bs) internal pure returns(string memory) {\\r\\n        uint256 remain = bs.length % 3;\\r\\n        uint256 length = bs.length / 3 * 4;\\r\\n        bytes memory result = new bytes(length + (remain != 0 ? 4 : 0) + (3 - remain) % 3);\\r\\n        \\r\\n        uint256 i = 0;\\r\\n        uint256 j = 0;\\r\\n        while (i != length) {\\r\\n            result[i++] = Util.BASE64_CHARS[uint8(bs[j] \\u003e\\u003e 2)];\\r\\n            result[i++] = Util.BASE64_CHARS[uint8((bs[j] \\u0026 0x03) \\u003c\\u003c 4 | bs[j + 1] \\u003e\\u003e 4)];\\r\\n            result[i++] = Util.BASE64_CHARS[uint8((bs[j + 1] \\u0026 0x0f) \\u003c\\u003c 2 | bs[j + 2] \\u003e\\u003e 6)];\\r\\n            result[i++] = Util.BASE64_CHARS[uint8(bs[j + 2] \\u0026 0x3f)];\\r\\n            \\r\\n            j += 3;\\r\\n        }\\r\\n        \\r\\n        if (remain != 0) {\\r\\n            result[i++] = Util.BASE64_CHARS[uint8(bs[j] \\u003e\\u003e 2)];\\r\\n            \\r\\n            if (remain == 2) {\\r\\n                result[i++] = Util.BASE64_CHARS[uint8((bs[j] \\u0026 0x03) \\u003c\\u003c 4 | bs[j + 1] \\u003e\\u003e 4)];\\r\\n                result[i++] = Util.BASE64_CHARS[uint8((bs[j + 1] \\u0026 0x0f) \\u003c\\u003c 2)];\\r\\n                result[i++] = Util.BASE64_CHARS[0];\\r\\n                result[i++] = 0x3d;\\r\\n            } else {\\r\\n                result[i++] = Util.BASE64_CHARS[uint8((bs[j] \\u0026 0x03) \\u003c\\u003c 4)];\\r\\n                result[i++] = Util.BASE64_CHARS[0];\\r\\n                result[i++] = Util.BASE64_CHARS[0];\\r\\n                result[i++] = 0x3d;\\r\\n                result[i++] = 0x3d;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return string(result);\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_era\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"_pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"NftTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"iphshash\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ERAprice\",\"type\":\"uint256\"}],\"name\":\"OfficalMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"iphshash\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokenId\",\"type\":\"uint256\"}],\"name\":\"PreMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"iphshash\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokenId\",\"type\":\"uint256\"}],\"name\":\"UserMint\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFT_Id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_TotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRE_TOTAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PreOlder_Price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UserMintNFT_Id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"batchAddToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"}],\"name\":\"changePower\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"era\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPreStart\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"isSold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract Manager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftPowerPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"officalMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"officalStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onceCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onceMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_switch\",\"type\":\"bool\"}],\"name\":\"pauseOfficalMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"preBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_challenge\",\"type\":\"bytes32\"}],\"name\":\"preOfficalMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"preOfficalStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"setUriPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"starAttributes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"IphsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stampFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"offical\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NftId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"stampFee\",\"type\":\"uint256\"}],\"name\":\"userMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERANFT", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000a3a9d092f40d2642b1dbaceb5df6b0c7940f9ab40000000000000000000000006f1f07a2441db009ff48e6ec17b21a20f1790e1a", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://388398d53ac256a885494141c7525a4bb158b518e7d1e9d50bbec4b4e4af8dc6"}