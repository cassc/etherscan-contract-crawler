{"SourceCode": "// File: @chainlink/contracts/src/v0.7/vendor/SafeMathChainlink.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMathChainlink {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/vendor/Address.sol\r\n\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts v3.4.0(fa64a1ced0b70ab89073d5d0b6e01b0778f7e7d6)\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain`call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionCall(target, data, \"Address: low-level call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/WithdrawalInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface WithdrawalInterface {\r\n  /**\r\n   * @notice transfer LINK held by the contract belonging to msg.sender to\r\n   * another address\r\n   * @param recipient is the address to send the LINK to\r\n   * @param amount is the amount of LINK to send\r\n   */\r\n  function withdraw(address recipient, uint256 amount) external;\r\n\r\n  /**\r\n   * @notice query the available amount of LINK to withdraw by msg.sender\r\n   */\r\n  function withdrawable() external view returns (uint256);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/OracleInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface OracleInterface {\r\n  function fulfillOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes32 data\r\n  ) external returns (bool);\r\n\r\n  function withdraw(address recipient, uint256 amount) external;\r\n\r\n  function withdrawable() external view returns (uint256);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/ChainlinkRequestInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 requestPrice,\r\n    bytes32 serviceAgreementID,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/OperatorInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\ninterface OperatorInterface is ChainlinkRequestInterface, OracleInterface {\r\n  function operatorRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 specId,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function fulfillOracleRequest2(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes calldata data\r\n  ) external returns (bool);\r\n\r\n  function ownerTransferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/LinkTokenInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n\r\n  function name() external view returns (string memory tokenName);\r\n\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool success);\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/OwnableInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface OwnableInterface {\r\n  function owner() external returns (address);\r\n\r\n  function transferOwnership(address recipient) external;\r\n\r\n  function acceptOwnership() external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(address indexed from, address indexed to);\r\n  event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n  constructor(address newOwner, address pendingOwner) {\r\n    require(newOwner != address(0), \"Cannot set owner to zero\");\r\n\r\n    s_owner = newOwner;\r\n    if (pendingOwner != address(0)) {\r\n      _transferOwnership(pendingOwner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address to) public override onlyOwner {\r\n    _transferOwnership(to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership() external override {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner() public view override returns (address) {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice validate, transfer ownership, and emit relevant events\r\n   */\r\n  function _transferOwnership(address to) private {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice validate access\r\n   */\r\n  function _validateOwnership() internal view {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    _validateOwnership();\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/ConfirmedOwner.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\r\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/LinkTokenReceiver.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\nabstract contract LinkTokenReceiver {\r\n  /**\r\n   * @notice Called when LINK is sent to the contract via `transferAndCall`\r\n   * @dev The data payload's first 2 words will be overwritten by the `sender` and `amount`\r\n   * values to ensure correctness. Calls oracleRequest.\r\n   * @param sender Address of the sender\r\n   * @param amount Amount of LINK sent (specified in wei)\r\n   * @param data Payload of the transaction\r\n   */\r\n  function onTokenTransfer(\r\n    address sender,\r\n    uint256 amount,\r\n    bytes memory data\r\n  ) public validateFromLINK permittedFunctionsForLINK(data) {\r\n    assembly {\r\n      // solhint-disable-next-line avoid-low-level-calls\r\n      mstore(add(data, 36), sender) // ensure correct sender is passed\r\n      // solhint-disable-next-line avoid-low-level-calls\r\n      mstore(add(data, 68), amount) // ensure correct amount is passed\r\n    }\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, ) = address(this).delegatecall(data); // calls oracleRequest\r\n    require(success, \"Unable to create request\");\r\n  }\r\n\r\n  function getChainlinkToken() public view virtual returns (address);\r\n\r\n  /**\r\n   * @notice Validate the function called on token transfer\r\n   */\r\n  function _validateTokenTransferAction(bytes4 funcSelector, bytes memory data) internal virtual;\r\n\r\n  /**\r\n   * @dev Reverts if not sent from the LINK token\r\n   */\r\n  modifier validateFromLINK() {\r\n    require(msg.sender == getChainlinkToken(), \"Must use LINK token\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the given data does not begin with the `oracleRequest` function selector\r\n   * @param data The data payload of the request\r\n   */\r\n  modifier permittedFunctionsForLINK(bytes memory data) {\r\n    bytes4 funcSelector;\r\n    assembly {\r\n      // solhint-disable-next-line avoid-low-level-calls\r\n      funcSelector := mload(add(data, 32))\r\n    }\r\n    _validateTokenTransferAction(funcSelector, data);\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/interfaces/AuthorizedReceiverInterface.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface AuthorizedReceiverInterface {\r\n  function isAuthorizedSender(address sender) external view returns (bool);\r\n\r\n  function getAuthorizedSenders() external returns (address[] memory);\r\n\r\n  function setAuthorizedSenders(address[] calldata senders) external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/AuthorizedReceiver.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\nabstract contract AuthorizedReceiver is AuthorizedReceiverInterface {\r\n  mapping(address => bool) private s_authorizedSenders;\r\n  address[] private s_authorizedSenderList;\r\n\r\n  event AuthorizedSendersChanged(address[] senders, address changedBy);\r\n\r\n  /**\r\n   * @notice Sets the fulfillment permission for a given node. Use `true` to allow, `false` to disallow.\r\n   * @param senders The addresses of the authorized Chainlink node\r\n   */\r\n  function setAuthorizedSenders(address[] calldata senders) external override validateAuthorizedSenderSetter {\r\n    require(senders.length > 0, \"Must have at least 1 authorized sender\");\r\n    // Set previous authorized senders to false\r\n    uint256 authorizedSendersLength = s_authorizedSenderList.length;\r\n    for (uint256 i = 0; i < authorizedSendersLength; i++) {\r\n      s_authorizedSenders[s_authorizedSenderList[i]] = false;\r\n    }\r\n    // Set new to true\r\n    for (uint256 i = 0; i < senders.length; i++) {\r\n      s_authorizedSenders[senders[i]] = true;\r\n    }\r\n    // Replace list\r\n    s_authorizedSenderList = senders;\r\n    emit AuthorizedSendersChanged(senders, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieve a list of authorized senders\r\n   * @return array of addresses\r\n   */\r\n  function getAuthorizedSenders() external view override returns (address[] memory) {\r\n    return s_authorizedSenderList;\r\n  }\r\n\r\n  /**\r\n   * @notice Use this to check if a node is authorized for fulfilling requests\r\n   * @param sender The address of the Chainlink node\r\n   * @return The authorization status of the node\r\n   */\r\n  function isAuthorizedSender(address sender) public view override returns (bool) {\r\n    return s_authorizedSenders[sender];\r\n  }\r\n\r\n  /**\r\n   * @notice customizable guard of who can update the authorized sender list\r\n   * @return bool whether sender can update authorized sender list\r\n   */\r\n  function _canSetAuthorizedSenders() internal virtual returns (bool);\r\n\r\n  /**\r\n   * @notice validates the sender is an authorized sender\r\n   */\r\n  function _validateIsAuthorizedSender() internal view {\r\n    require(isAuthorizedSender(msg.sender), \"Not authorized sender\");\r\n  }\r\n\r\n  /**\r\n   * @notice prevents non-authorized addresses from calling this method\r\n   */\r\n  modifier validateAuthorizedSender() {\r\n    _validateIsAuthorizedSender();\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice prevents non-authorized addresses from calling this method\r\n   */\r\n  modifier validateAuthorizedSenderSetter() {\r\n    require(_canSetAuthorizedSenders(), \"Cannot set authorized senders\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.7/Operator.sol\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The Chainlink Operator contract\r\n * @notice Node operators can deploy this contract to fulfill requests sent to them\r\n */\r\ncontract Operator is AuthorizedReceiver, ConfirmedOwner, LinkTokenReceiver, OperatorInterface, WithdrawalInterface {\r\n  using Address for address;\r\n  using SafeMathChainlink for uint256;\r\n\r\n  struct Commitment {\r\n    bytes31 paramsHash;\r\n    uint8 dataVersion;\r\n  }\r\n\r\n  uint256 public constant getExpiryTime = 5 minutes;\r\n  uint256 private constant MAXIMUM_DATA_VERSION = 256;\r\n  uint256 private constant MINIMUM_CONSUMER_GAS_LIMIT = 400000;\r\n  uint256 private constant SELECTOR_LENGTH = 4;\r\n  uint256 private constant EXPECTED_REQUEST_WORDS = 2;\r\n  uint256 private constant MINIMUM_REQUEST_LENGTH = SELECTOR_LENGTH + (32 * EXPECTED_REQUEST_WORDS);\r\n  // We initialize fields to 1 instead of 0 so that the first invocation\r\n  // does not cost more gas.\r\n  uint256 private constant ONE_FOR_CONSISTENT_GAS_COST = 1;\r\n  // oracleRequest is intended for version 1, enabling single word responses\r\n  bytes4 private constant ORACLE_REQUEST_SELECTOR = this.oracleRequest.selector;\r\n  // operatorRequest is intended for version 2, enabling multi-word responses\r\n  bytes4 private constant OPERATOR_REQUEST_SELECTOR = this.operatorRequest.selector;\r\n\r\n  LinkTokenInterface internal immutable linkToken;\r\n  mapping(bytes32 => Commitment) private s_commitments;\r\n  mapping(address => bool) private s_owned;\r\n  // Tokens sent for requests that have not been fulfilled yet\r\n  uint256 private s_tokensInEscrow = ONE_FOR_CONSISTENT_GAS_COST;\r\n\r\n  event OracleRequest(\r\n    bytes32 indexed specId,\r\n    address requester,\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddr,\r\n    bytes4 callbackFunctionId,\r\n    uint256 cancelExpiration,\r\n    uint256 dataVersion,\r\n    bytes data\r\n  );\r\n\r\n  event CancelOracleRequest(bytes32 indexed requestId);\r\n\r\n  event OracleResponse(bytes32 indexed requestId);\r\n\r\n  event OwnableContractAccepted(address indexed acceptedContract);\r\n\r\n  event TargetsUpdatedAuthorizedSenders(address[] targets, address[] senders, address changedBy);\r\n\r\n  /**\r\n   * @notice Deploy with the address of the LINK token\r\n   * @dev Sets the LinkToken address for the imported LinkTokenInterface\r\n   * @param link The address of the LINK token\r\n   * @param owner The address of the owner\r\n   */\r\n  constructor(address link, address owner) ConfirmedOwner(owner) {\r\n    linkToken = LinkTokenInterface(link); // external but already deployed and unalterable\r\n  }\r\n\r\n  /**\r\n   * @notice The type and version of this contract\r\n   * @return Type and version string\r\n   */\r\n  function typeAndVersion() external pure virtual returns (string memory) {\r\n    return \"Operator 1.0.0\";\r\n  }\r\n\r\n  /**\r\n   * @notice Creates the Chainlink request. This is a backwards compatible API\r\n   * with the Oracle.sol contract, but the behavior changes because\r\n   * callbackAddress is assumed to be the same as the request sender.\r\n   * @param callbackAddress The consumer of the request\r\n   * @param payment The amount of payment given (specified in wei)\r\n   * @param specId The Job Specification ID\r\n   * @param callbackAddress The address the oracle data will be sent to\r\n   * @param callbackFunctionId The callback function ID for the response\r\n   * @param nonce The nonce sent by the requester\r\n   * @param dataVersion The specified data version\r\n   * @param data The extra request parameters\r\n   */\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 specId,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external override validateFromLINK {\r\n    (bytes32 requestId, uint256 expiration) = _verifyAndProcessOracleRequest(\r\n      sender,\r\n      payment,\r\n      callbackAddress,\r\n      callbackFunctionId,\r\n      nonce,\r\n      dataVersion\r\n    );\r\n    emit OracleRequest(specId, sender, requestId, payment, sender, callbackFunctionId, expiration, dataVersion, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates the Chainlink request\r\n   * @dev Stores the hash of the params as the on-chain commitment for the request.\r\n   * Emits OracleRequest event for the Chainlink node to detect.\r\n   * @param sender The sender of the request\r\n   * @param payment The amount of payment given (specified in wei)\r\n   * @param specId The Job Specification ID\r\n   * @param callbackFunctionId The callback function ID for the response\r\n   * @param nonce The nonce sent by the requester\r\n   * @param dataVersion The specified data version\r\n   * @param data The extra request parameters\r\n   */\r\n  function operatorRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 specId,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external override validateFromLINK {\r\n    (bytes32 requestId, uint256 expiration) = _verifyAndProcessOracleRequest(\r\n      sender,\r\n      payment,\r\n      sender,\r\n      callbackFunctionId,\r\n      nonce,\r\n      dataVersion\r\n    );\r\n    emit OracleRequest(specId, sender, requestId, payment, sender, callbackFunctionId, expiration, dataVersion, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Called by the Chainlink node to fulfill requests\r\n   * @dev Given params must hash back to the commitment stored from `oracleRequest`.\r\n   * Will call the callback address' callback function without bubbling up error\r\n   * checking in a `require` so that the node can get paid.\r\n   * @param requestId The fulfillment request ID that must match the requester's\r\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\r\n   * @param callbackAddress The callback address to call for fulfillment\r\n   * @param callbackFunctionId The callback function ID to use for fulfillment\r\n   * @param expiration The expiration that the node should respond by before the requester can cancel\r\n   * @param data The data to return to the consuming contract\r\n   * @return Status if the external call was successful\r\n   */\r\n  function fulfillOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes32 data\r\n  )\r\n    external\r\n    override\r\n    validateAuthorizedSender\r\n    validateRequestId(requestId)\r\n    validateCallbackAddress(callbackAddress)\r\n    returns (bool)\r\n  {\r\n    _verifyOracleRequestAndProcessPayment(requestId, payment, callbackAddress, callbackFunctionId, expiration, 1);\r\n    emit OracleResponse(requestId);\r\n    require(gasleft() >= MINIMUM_CONSUMER_GAS_LIMIT, \"Must provide consumer enough gas\");\r\n    // All updates to the oracle's fulfillment should come before calling the\r\n    // callback(addr+functionId) as it is untrusted.\r\n    // See: https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\r\n    (bool success, ) = callbackAddress.call(abi.encodeWithSelector(callbackFunctionId, requestId, data)); // solhint-disable-line avoid-low-level-calls\r\n    return success;\r\n  }\r\n\r\n  /**\r\n   * @notice Called by the Chainlink node to fulfill requests with multi-word support\r\n   * @dev Given params must hash back to the commitment stored from `oracleRequest`.\r\n   * Will call the callback address' callback function without bubbling up error\r\n   * checking in a `require` so that the node can get paid.\r\n   * @param requestId The fulfillment request ID that must match the requester's\r\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\r\n   * @param callbackAddress The callback address to call for fulfillment\r\n   * @param callbackFunctionId The callback function ID to use for fulfillment\r\n   * @param expiration The expiration that the node should respond by before the requester can cancel\r\n   * @param data The data to return to the consuming contract\r\n   * @return Status if the external call was successful\r\n   */\r\n  function fulfillOracleRequest2(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    override\r\n    validateAuthorizedSender\r\n    validateRequestId(requestId)\r\n    validateCallbackAddress(callbackAddress)\r\n    validateMultiWordResponseId(requestId, data)\r\n    returns (bool)\r\n  {\r\n    _verifyOracleRequestAndProcessPayment(requestId, payment, callbackAddress, callbackFunctionId, expiration, 2);\r\n    emit OracleResponse(requestId);\r\n    require(gasleft() >= MINIMUM_CONSUMER_GAS_LIMIT, \"Must provide consumer enough gas\");\r\n    // All updates to the oracle's fulfillment should come before calling the\r\n    // callback(addr+functionId) as it is untrusted.\r\n    // See: https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\r\n    (bool success, ) = callbackAddress.call(abi.encodePacked(callbackFunctionId, data)); // solhint-disable-line avoid-low-level-calls\r\n    return success;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer the ownership of ownable contracts. This is primarily\r\n   * intended for Authorized Forwarders but could possibly be extended to work\r\n   * with future contracts.\r\n   * @param ownable list of addresses to transfer\r\n   * @param newOwner address to transfer ownership to\r\n   */\r\n  function transferOwnableContracts(address[] calldata ownable, address newOwner) external onlyOwner {\r\n    for (uint256 i = 0; i < ownable.length; i++) {\r\n      s_owned[ownable[i]] = false;\r\n      OwnableInterface(ownable[i]).transferOwnership(newOwner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Accept the ownership of an ownable contract. This is primarily\r\n   * intended for Authorized Forwarders but could possibly be extended to work\r\n   * with future contracts.\r\n   * @dev Must be the pending owner on the contract\r\n   * @param ownable list of addresses of Ownable contracts to accept\r\n   */\r\n  function acceptOwnableContracts(address[] calldata ownable) public validateAuthorizedSenderSetter {\r\n    for (uint256 i = 0; i < ownable.length; i++) {\r\n      s_owned[ownable[i]] = true;\r\n      emit OwnableContractAccepted(ownable[i]);\r\n      OwnableInterface(ownable[i]).acceptOwnership();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the fulfillment permission for\r\n   * @param targets The addresses to set permissions on\r\n   * @param senders The addresses that are allowed to send updates\r\n   */\r\n  function setAuthorizedSendersOn(address[] calldata targets, address[] calldata senders)\r\n    public\r\n    validateAuthorizedSenderSetter\r\n  {\r\n    TargetsUpdatedAuthorizedSenders(targets, senders, msg.sender);\r\n\r\n    for (uint256 i = 0; i < targets.length; i++) {\r\n      AuthorizedReceiverInterface(targets[i]).setAuthorizedSenders(senders);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Accepts ownership of ownable contracts and then immediately sets\r\n   * the authorized sender list on each of the newly owned contracts. This is\r\n   * primarily intended for Authorized Forwarders but could possibly be\r\n   * extended to work with future contracts.\r\n   * @param targets The addresses to set permissions on\r\n   * @param senders The addresses that are allowed to send updates\r\n   */\r\n  function acceptAuthorizedReceivers(address[] calldata targets, address[] calldata senders)\r\n    external\r\n    validateAuthorizedSenderSetter\r\n  {\r\n    acceptOwnableContracts(targets);\r\n    setAuthorizedSendersOn(targets, senders);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the node operator to withdraw earned LINK to a given address\r\n   * @dev The owner of the contract can be another wallet and does not have to be a Chainlink node\r\n   * @param recipient The address to send the LINK token to\r\n   * @param amount The amount to send (specified in wei)\r\n   */\r\n  function withdraw(address recipient, uint256 amount)\r\n    external\r\n    override(OracleInterface, WithdrawalInterface)\r\n    onlyOwner\r\n    validateAvailableFunds(amount)\r\n  {\r\n    assert(linkToken.transfer(recipient, amount));\r\n  }\r\n\r\n  /**\r\n   * @notice Displays the amount of LINK that is available for the node operator to withdraw\r\n   * @dev We use `ONE_FOR_CONSISTENT_GAS_COST` in place of 0 in storage\r\n   * @return The amount of withdrawable LINK on the contract\r\n   */\r\n  function withdrawable() external view override(OracleInterface, WithdrawalInterface) returns (uint256) {\r\n    return _fundsAvailable();\r\n  }\r\n\r\n  /**\r\n   * @notice Forward a call to another contract\r\n   * @dev Only callable by the owner\r\n   * @param to address\r\n   * @param data to forward\r\n   */\r\n  function ownerForward(address to, bytes calldata data) external onlyOwner validateNotToLINK(to) {\r\n    require(to.isContract(), \"Must forward to a contract\");\r\n    (bool status, ) = to.call(data);\r\n    require(status, \"Forwarded call failed\");\r\n  }\r\n\r\n  /**\r\n   * @notice Interact with other LinkTokenReceiver contracts by calling transferAndCall\r\n   * @param to The address to transfer to.\r\n   * @param value The amount to be transferred.\r\n   * @param data The extra data to be passed to the receiving contract.\r\n   * @return success bool\r\n   */\r\n  function ownerTransferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external override onlyOwner validateAvailableFunds(value) returns (bool success) {\r\n    return linkToken.transferAndCall(to, value, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Distribute funds to multiple addresses using ETH send\r\n   * to this payable function.\r\n   * @dev Array length must be equal, ETH sent must equal the sum of amounts.\r\n   * A malicious receiver could cause the distribution to revert, in which case\r\n   * it is expected that the address is removed from the list.\r\n   * @param receivers list of addresses\r\n   * @param amounts list of amounts\r\n   */\r\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable {\r\n    require(receivers.length > 0 && receivers.length == amounts.length, \"Invalid array length(s)\");\r\n    uint256 valueRemaining = msg.value;\r\n    for (uint256 i = 0; i < receivers.length; i++) {\r\n      uint256 sendAmount = amounts[i];\r\n      valueRemaining = valueRemaining.sub(sendAmount);\r\n      receivers[i].transfer(sendAmount);\r\n    }\r\n    require(valueRemaining == 0, \"Too much ETH sent\");\r\n  }\r\n\r\n  /**\r\n   * @notice Allows recipient to cancel requests sent to this oracle contract.\r\n   * Will transfer the LINK sent for the request back to the recipient address.\r\n   * @dev Given params must hash to a commitment stored on the contract in order\r\n   * for the request to be valid. Emits CancelOracleRequest event.\r\n   * @param requestId The request ID\r\n   * @param payment The amount of payment given (specified in wei)\r\n   * @param callbackFunc The requester's specified callback function selector\r\n   * @param expiration The time of the expiration for the request\r\n   */\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunc,\r\n    uint256 expiration\r\n  ) external override {\r\n    bytes31 paramsHash = _buildParamsHash(payment, msg.sender, callbackFunc, expiration);\r\n    require(s_commitments[requestId].paramsHash == paramsHash, \"Params do not match request ID\");\r\n    // solhint-disable-next-line not-rely-on-time\r\n    require(expiration <= block.timestamp, \"Request is not expired\");\r\n\r\n    delete s_commitments[requestId];\r\n    emit CancelOracleRequest(requestId);\r\n\r\n    linkToken.transfer(msg.sender, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows requester to cancel requests sent to this oracle contract.\r\n   * Will transfer the LINK sent for the request back to the recipient address.\r\n   * @dev Given params must hash to a commitment stored on the contract in order\r\n   * for the request to be valid. Emits CancelOracleRequest event.\r\n   * @param nonce The nonce used to generate the request ID\r\n   * @param payment The amount of payment given (specified in wei)\r\n   * @param callbackFunc The requester's specified callback function selector\r\n   * @param expiration The time of the expiration for the request\r\n   */\r\n  function cancelOracleRequestByRequester(\r\n    uint256 nonce,\r\n    uint256 payment,\r\n    bytes4 callbackFunc,\r\n    uint256 expiration\r\n  ) external {\r\n    bytes32 requestId = keccak256(abi.encodePacked(msg.sender, nonce));\r\n    bytes31 paramsHash = _buildParamsHash(payment, msg.sender, callbackFunc, expiration);\r\n    require(s_commitments[requestId].paramsHash == paramsHash, \"Params do not match request ID\");\r\n    // solhint-disable-next-line not-rely-on-time\r\n    require(expiration <= block.timestamp, \"Request is not expired\");\r\n\r\n    delete s_commitments[requestId];\r\n    emit CancelOracleRequest(requestId);\r\n\r\n    linkToken.transfer(msg.sender, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the LINK token\r\n   * @dev This is the public implementation for chainlinkTokenAddress, which is\r\n   * an internal method of the ChainlinkClient contract\r\n   */\r\n  function getChainlinkToken() public view override returns (address) {\r\n    return address(linkToken);\r\n  }\r\n\r\n  /**\r\n   * @notice Require that the token transfer action is valid\r\n   * @dev OPERATOR_REQUEST_SELECTOR = multiword, ORACLE_REQUEST_SELECTOR = singleword\r\n   */\r\n  function _validateTokenTransferAction(bytes4 funcSelector, bytes memory data) internal pure override {\r\n    require(data.length >= MINIMUM_REQUEST_LENGTH, \"Invalid request length\");\r\n    require(\r\n      funcSelector == OPERATOR_REQUEST_SELECTOR || funcSelector == ORACLE_REQUEST_SELECTOR,\r\n      \"Must use whitelisted functions\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Verify the Oracle Request and record necessary information\r\n   * @param sender The sender of the request\r\n   * @param payment The amount of payment given (specified in wei)\r\n   * @param callbackAddress The callback address for the response\r\n   * @param callbackFunctionId The callback function ID for the response\r\n   * @param nonce The nonce sent by the requester\r\n   */\r\n  function _verifyAndProcessOracleRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion\r\n  ) private validateNotToLINK(callbackAddress) returns (bytes32 requestId, uint256 expiration) {\r\n    requestId = keccak256(abi.encodePacked(sender, nonce));\r\n    require(s_commitments[requestId].paramsHash == 0, \"Must use a unique ID\");\r\n    // solhint-disable-next-line not-rely-on-time\r\n    expiration = block.timestamp.add(getExpiryTime);\r\n    bytes31 paramsHash = _buildParamsHash(payment, callbackAddress, callbackFunctionId, expiration);\r\n    s_commitments[requestId] = Commitment(paramsHash, _safeCastToUint8(dataVersion));\r\n    s_tokensInEscrow = s_tokensInEscrow.add(payment);\r\n    return (requestId, expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify the Oracle request and unlock escrowed payment\r\n   * @param requestId The fulfillment request ID that must match the requester's\r\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\r\n   * @param callbackAddress The callback address to call for fulfillment\r\n   * @param callbackFunctionId The callback function ID to use for fulfillment\r\n   * @param expiration The expiration that the node should respond by before the requester can cancel\r\n   */\r\n  function _verifyOracleRequestAndProcessPayment(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    uint256 dataVersion\r\n  ) internal {\r\n    bytes31 paramsHash = _buildParamsHash(payment, callbackAddress, callbackFunctionId, expiration);\r\n    require(s_commitments[requestId].paramsHash == paramsHash, \"Params do not match request ID\");\r\n    require(s_commitments[requestId].dataVersion <= _safeCastToUint8(dataVersion), \"Data versions must match\");\r\n    s_tokensInEscrow = s_tokensInEscrow.sub(payment);\r\n    delete s_commitments[requestId];\r\n  }\r\n\r\n  /**\r\n   * @notice Build the bytes31 hash from the payment, callback and expiration.\r\n   * @param payment The payment amount that will be released for the oracle (specified in wei)\r\n   * @param callbackAddress The callback address to call for fulfillment\r\n   * @param callbackFunctionId The callback function ID to use for fulfillment\r\n   * @param expiration The expiration that the node should respond by before the requester can cancel\r\n   * @return hash bytes31\r\n   */\r\n  function _buildParamsHash(\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) internal pure returns (bytes31) {\r\n    return bytes31(keccak256(abi.encodePacked(payment, callbackAddress, callbackFunctionId, expiration)));\r\n  }\r\n\r\n  /**\r\n   * @notice Safely cast uint256 to uint8\r\n   * @param number uint256\r\n   * @return uint8 number\r\n   */\r\n  function _safeCastToUint8(uint256 number) internal pure returns (uint8) {\r\n    require(number < MAXIMUM_DATA_VERSION, \"number too big to cast\");\r\n    return uint8(number);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the LINK available in this contract, not locked in escrow\r\n   * @return uint256 LINK tokens available\r\n   */\r\n  function _fundsAvailable() private view returns (uint256) {\r\n    uint256 inEscrow = s_tokensInEscrow.sub(ONE_FOR_CONSISTENT_GAS_COST);\r\n    return linkToken.balanceOf(address(this)).sub(inEscrow);\r\n  }\r\n\r\n  /**\r\n   * @notice concrete implementation of AuthorizedReceiver\r\n   * @return bool of whether sender is authorized\r\n   */\r\n  function _canSetAuthorizedSenders() internal view override returns (bool) {\r\n    return isAuthorizedSender(msg.sender) || owner() == msg.sender;\r\n  }\r\n\r\n  // MODIFIERS\r\n\r\n  /**\r\n   * @dev Reverts if the first 32 bytes of the bytes array is not equal to requestId\r\n   * @param requestId bytes32\r\n   * @param data bytes\r\n   */\r\n  modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata data) {\r\n    require(data.length >= 32, \"Response must be > 32 bytes\");\r\n    bytes32 firstDataWord;\r\n    assembly {\r\n      firstDataWord := calldataload(data.offset)\r\n    }\r\n    require(requestId == firstDataWord, \"First word must be requestId\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if amount requested is greater than withdrawable balance\r\n   * @param amount The given amount to compare to `s_withdrawableTokens`\r\n   */\r\n  modifier validateAvailableFunds(uint256 amount) {\r\n    require(_fundsAvailable() >= amount, \"Amount requested is greater than withdrawable balance\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if request ID does not exist\r\n   * @param requestId The given request ID to check in stored `commitments`\r\n   */\r\n  modifier validateRequestId(bytes32 requestId) {\r\n    require(s_commitments[requestId].paramsHash != 0, \"Must have a valid requestId\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the callback address is the LINK token\r\n   * @param to The callback address\r\n   */\r\n  modifier validateNotToLINK(address to) {\r\n    require(to != address(linkToken), \"Cannot call to LINK\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the target address is owned by the operator\r\n   */\r\n  modifier validateCallbackAddress(address callbackAddress) {\r\n    require(!s_owned[callbackAddress], \"Cannot call owned contract\");\r\n    _;\r\n  }\r\n}\r\n\r\n// File: docs.chain.link/samples/ChainlinkNodes/Operator.sol\r\n\r\n\r\npragma solidity ^0.7.6;", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"AuthorizedSendersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"CancelOracleRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"specId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callbackAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cancelExpiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dataVersion\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"OracleRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"OracleResponse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acceptedContract\",\"type\":\"address\"}],\"name\":\"OwnableContractAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"changedBy\",\"type\":\"address\"}],\"name\":\"TargetsUpdatedAuthorizedSenders\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"}],\"name\":\"acceptAuthorizedReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ownable\",\"type\":\"address[]\"}],\"name\":\"acceptOwnableContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunc\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"cancelOracleRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunc\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"cancelOracleRequestByRequester\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"distributeFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"callbackAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"}],\"name\":\"fulfillOracleRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"callbackAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"fulfillOracleRequest2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorizedSenders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainlinkToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"isAuthorizedSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"specId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataVersion\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"operatorRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"specId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callbackAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"callbackFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dataVersion\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"oracleRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ownerForward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ownerTransferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"}],\"name\":\"setAuthorizedSenders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"senders\",\"type\":\"address[]\"}],\"name\":\"setAuthorizedSendersOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"ownable\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnableContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Operator", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000404460c6a5ede2d891e8297795264fde62adbb75000000000000000000000000528434ba149f1624faabcaf04c3c1af84e6ccfcd", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8176c803763ca489e6c892b3d0e535054f71bbe7d170f0be5839e9e7ead1d8fc"}