{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface INFT {\r\n    function ProcessTokenRequest(address account,uint256 amount) external returns (bool);\r\n    function UpdateCycleReward(uint256 amount) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract SuperLandNodeMatrix is Ownable {\r\n\r\n    address public deployer;\r\n\r\n    event NewNode(address indexed account,address referral,uint256 amount,uint256 blockstamp);\r\n    event UpLevel(address indexed account,address referral,uint256 amount,uint256 blockstamp);\r\n    event Reinvest(address indexed reinvestor,uint256 matrixLevel,uint256 reinvest,uint256 blockstamp);\r\n\r\n    struct Node {\r\n        uint256 id;\r\n        address referral;\r\n        address[] referees;\r\n        uint256 directAmount;\r\n        bool registered;\r\n        mapping(uint256 => bool) actived;\r\n        mapping(uint256 => Matrix) matrix;\r\n    }\r\n\r\n    struct Matrix {\r\n        address overhead;\r\n        uint256 firstLayer;\r\n        uint256 secondLayer;\r\n        address[] below;\r\n        uint256 reinvest;\r\n        mapping(uint256 => Data) data;\r\n        mapping(uint256 => uint256) matchingAmount;\r\n    }\r\n\r\n    struct Data {\r\n        address[] keep;\r\n    }\r\n\r\n    address[] nodes;\r\n    mapping(address => Node) node;\r\n\r\n    IERC20 token;\r\n    INFT ticket;\r\n\r\n    uint256 public nativeRequire = 2e15;\r\n\r\n    uint256 matchingLevel = 15;\r\n    uint256 matchingAmount = 150;\r\n    uint256 directReward = 200;\r\n    uint256 firstLayerReward = 100;\r\n    uint256 secondLayerReward = 500;\r\n    uint256 ticketReward = 30;\r\n    uint256 denominator = 1000;\r\n\r\n    address[] admin;\r\n    uint256[] dividend;\r\n\r\n    uint256[] activedCost = [10e18,40e18,160e18];\r\n    uint256[] nftMint = [1,4,16];\r\n\r\n    mapping(address => address[]) members;\r\n    mapping(address => mapping(address => bool)) isCounted;\r\n\r\n    bool locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor(address genesisId,address depositToken,address ticketContract) {\r\n        deployer = payable(msg.sender);\r\n        token = IERC20(depositToken);\r\n        ticket = INFT(ticketContract);\r\n        registerNew(genesisId,address(0));\r\n        for(uint256 i = 0; i < activedCost.length; i++){\r\n            node[genesisId].actived[i] = true;\r\n        }\r\n    }\r\n\r\n    function getDAPPInfo() public view returns (\r\n        address depositToken_,\r\n        address ticketToken,\r\n        uint256 matchingLevel_,\r\n        uint256 matchingAmount_,\r\n        uint256 directReward_,\r\n        uint256 firstLayerReward_,\r\n        uint256 secondLayerReward_,\r\n        uint256 ticketReward_,\r\n        uint256 denominator_,\r\n        uint256[] memory activedCost_,\r\n        uint256[] memory nftMint_\r\n    ) {\r\n        return (\r\n            address(token),\r\n            address(ticket),\r\n            matchingLevel,\r\n            matchingAmount,\r\n            directReward,\r\n            firstLayerReward,\r\n            secondLayerReward,\r\n            ticketReward,\r\n            denominator,\r\n            activedCost,\r\n            nftMint\r\n        );\r\n    }\r\n\r\n    function getNodes() public view returns (address[] memory) {\r\n        return nodes;\r\n    }\r\n\r\n    function getMembers(address account) public view returns (address[] memory) {\r\n        return members[account];\r\n    }\r\n\r\n    function id2address(uint256 id) public view returns (address) {\r\n        return nodes[id-1];\r\n    }\r\n\r\n    function getNodeInfo(address account) public view returns (\r\n        uint256 id_,\r\n        address referral_,\r\n        address[] memory referees_,\r\n        uint256 directAmount_,\r\n        bool registered_,\r\n        bool[] memory actived_\r\n    ) {\r\n        bool[] memory actived = new bool[](activedCost.length);\r\n        for(uint256 i = 0; i < activedCost.length; i++){\r\n            actived[i] = node[account].actived[i];\r\n        }\r\n        return (\r\n            node[account].id,\r\n            node[account].referral,\r\n            node[account].referees,\r\n            node[account].directAmount,\r\n            node[account].registered,\r\n            actived\r\n        );\r\n    }\r\n\r\n    function getMatrixInfo(address account,uint256 level) public view returns (\r\n        address overhead_,\r\n        uint256 firstLayer_,\r\n        uint256 secondLayer_,\r\n        address[] memory below_,\r\n        uint256 reinvest_,\r\n        uint256[] memory matchingAmount_\r\n    ) {\r\n        uint256[] memory result = new uint256[](matchingLevel);\r\n        for(uint256 i = 0; i < matchingLevel; i++){\r\n            result[i] = node[account].matrix[level].matchingAmount[i];\r\n        }\r\n        return (\r\n            node[account].matrix[level].overhead,\r\n            node[account].matrix[level].firstLayer,\r\n            node[account].matrix[level].secondLayer,\r\n            node[account].matrix[level].below,\r\n            node[account].matrix[level].reinvest,\r\n            result\r\n        );\r\n    }\r\n\r\n    function getReinvestInfo(address account,uint256 level,uint256 cycle) public view returns (address[] memory keep_) {\r\n        return node[account].matrix[level].data[cycle].keep;\r\n    }\r\n\r\n    function getAdminWallet() public view returns (address[] memory admin_,uint256[] memory dividend_) {\r\n        return (admin,dividend);\r\n    }\r\n\r\n    function newNode(address account,address referral) public payable noReentrant returns (bool) {\r\n        if(nativeRequire>0){ require(msg.value>=nativeRequire); }\r\n        require(!node[account].registered,\"DAPP REVERT: ACCOUNT WAS REGISTERED!\");\r\n        require(node[referral].registered,\"DAPP REVERT: REFERRAL MUST BE REGISTERED!\");\r\n        uint256 amount = activedCost[0];\r\n        token.transferFrom(msg.sender,address(this),amount);\r\n        registerNew(account,referral);\r\n        (address header,bool isClosePart,bool isReinvest) = findSpot(referral,0);\r\n        adminPaid(amount);\r\n        placeMatrix(account,header,0,isReinvest,false);\r\n        rewardPaid(account,referral,0,isClosePart,false);\r\n        emit NewNode(account,referral,amount,block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function uplevel(address account,uint256 level) public payable noReentrant returns (bool) {\r\n        if(nativeRequire>0){ require(msg.value>=nativeRequire); }\r\n        require(node[account].actived[level-1],\"DAPP REVERT: PLEASE ACTIVED PREVIOUS LEVEL FIRST!\");\r\n        require(!node[account].actived[level],\"DAPP REVERT: LEVEL WAS ACTIVED!\");\r\n        uint256 amount = activedCost[level];\r\n        token.transferFrom(msg.sender,address(this),amount);\r\n        node[account].actived[level] = true;\r\n        address referral = node[account].referral;\r\n        (address header,bool isClosePart,bool isReinvest) = findSpot(findHeaderLevel(referral,level),level);\r\n        adminPaid(amount);\r\n        placeMatrix(account,header,level,isReinvest,false);\r\n        rewardPaid(account,referral,level,isClosePart,false);\r\n        emit UpLevel(account,referral,amount,block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function newNodeWithPermit(address account,address referral) public onlyOwner returns (bool) {\r\n        require(!node[account].registered,\"DAPP REVERT: ACCOUNT WAS REGISTERED!\");\r\n        require(node[referral].registered,\"DAPP REVERT: REFERRAL MUST BE REGISTERED!\");\r\n        uint256 amount = activedCost[0];\r\n        registerNew(account,referral);\r\n        (address header,bool isClosePart,bool isReinvest) = findSpot(referral,0);\r\n        placeMatrix(account,header,0,isReinvest,true);\r\n        rewardPaid(account,referral,0,isClosePart,true);\r\n        emit NewNode(account,referral,amount,block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function uplevelWithPermit(address account,uint256 level) public onlyOwner returns (bool) {\r\n        require(node[account].actived[level-1],\"DAPP REVERT: PLEASE ACTIVED PREVIOUS LEVEL FIRST!\");\r\n        require(!node[account].actived[level],\"DAPP REVERT: LEVEL WAS ACTIVED!\");\r\n        uint256 amount = activedCost[level];\r\n        node[account].actived[level] = true;\r\n        address referral = node[account].referral;\r\n        (address header,bool isClosePart,bool isReinvest) = findSpot(findHeaderLevel(referral,level),level);\r\n        placeMatrix(account,header,level,isReinvest,true);\r\n        rewardPaid(account,referral,level,isClosePart,true);\r\n        emit UpLevel(account,referral,amount,block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    function adminPaid(uint256 amount) internal {\r\n        if(admin.length>0){\r\n            for(uint256 i = 0; i < admin.length; i++){\r\n                if(!isDead(admin[i])){\r\n                    token.transfer(admin[i],amount * dividend[i] / denominator);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function rewardPaid(address account,address referral,uint256 level,bool isClosePart,bool isPermit) internal {\r\n        ticket.ProcessTokenRequest(account,nftMint[level]);\r\n        ticket.UpdateCycleReward(activedCost[level] * ticketReward / denominator);\r\n        address[] memory overhead = new address[](matchingLevel);\r\n        overhead = getHeaderMap(account,level,matchingLevel);\r\n        paidDirect(referral,activedCost[level],isPermit);\r\n        paidFirstLayer(overhead[0],level,activedCost[level],isPermit);\r\n        if(!isClosePart){ paidSecondLayer(overhead[1],level,activedCost[level],isPermit); }\r\n        paidMatching(account,overhead,level,activedCost[level],isPermit);\r\n        if(address(this).balance>0){\r\n            (bool success,) = deployer.call{ value: address(this).balance }(\"\");\r\n            require(success);\r\n        }\r\n    }\r\n\r\n    function registerNew(address account,address referral) internal {\r\n        nodes.push(account);\r\n        node[account].id = nodes.length;\r\n        node[account].referral = referral;\r\n        node[account].registered = true;\r\n        node[account].actived[0] = true;\r\n        node[referral].referees.push(account);\r\n    }\r\n\r\n    function placeMatrix(address account,address header,uint256 level,bool isReinvest,bool isPermit) internal {\r\n        node[account].matrix[level].overhead = header;\r\n        node[header].matrix[level].below.push(account);\r\n        if(isReinvest){\r\n            address reinvestor = node[header].matrix[level].overhead;\r\n            uint256 reinvest = node[reinvestor].matrix[level].reinvest;\r\n            node[reinvestor].matrix[level].data[reinvest].keep = node[reinvestor].matrix[level].below;\r\n            node[reinvestor].matrix[level].below = new address[](0);\r\n            emit Reinvest(reinvestor,level,reinvest,block.timestamp);\r\n            node[reinvestor].matrix[level].reinvest++;\r\n            rewardPaid(reinvestor,node[reinvestor].referral,level,false,isPermit);\r\n        }\r\n    }\r\n\r\n    function findSpot(address account,uint256 level) internal view returns (address,bool,bool) {\r\n        address spot;\r\n        if(node[account].matrix[level].below.length<2){\r\n            spot = account;\r\n        }else{\r\n            address checkLeft = node[account].matrix[level].below[0];\r\n            if(node[checkLeft].matrix[level].below.length<2){\r\n                spot = checkLeft;\r\n            }else{\r\n                spot = node[account].matrix[level].below[1];\r\n            }\r\n        }\r\n        (bool isClosePart,bool isReinvest) = shouldReinvest(spot,level);\r\n        return (spot,isClosePart,isReinvest);\r\n    }\r\n\r\n    function shouldReinvest(address account,uint256 level) internal view returns (bool,bool) {\r\n        bool isClosePart = false;\r\n        bool isReinvest = false;\r\n        address checker = node[account].matrix[level].overhead;\r\n        if(node[checker].matrix[level].below.length==2){\r\n            address Left = node[checker].matrix[level].below[0];\r\n            address Right = node[checker].matrix[level].below[1];\r\n            if(node[Left].matrix[level].below.length==2){\r\n                isClosePart = true;\r\n                if(node[Right].matrix[level].below.length==1){\r\n                    isReinvest = true;\r\n                }\r\n            }else if(node[Right].matrix[level].below.length==2){\r\n                isClosePart = true;\r\n                if(node[Left].matrix[level].below.length==1){\r\n                    isReinvest = true;\r\n                }\r\n            }\r\n        }\r\n        return (isClosePart,isReinvest);\r\n    }\r\n\r\n    function findHeaderLevel(address account,uint256 level) internal view returns (address) {\r\n        do{\r\n            if(node[account].actived[level]){\r\n                return account;\r\n            }\r\n            account = node[account].referral;\r\n        }while(true);\r\n        return address(0);\r\n    }\r\n\r\n    function getHeaderMap(address account,uint256 level,uint256 deeplevel) public view returns (address[] memory) {\r\n        address[] memory accounts = new address[](deeplevel);\r\n        for(uint256 i = 0; i < deeplevel; i++){\r\n            accounts[i] = node[account].matrix[level].overhead;\r\n            account = node[account].matrix[level].overhead;\r\n        }\r\n        return accounts;\r\n    }\r\n\r\n    function paidDirect(address account,uint256 amount,bool isPermit) internal {\r\n        if(!isDead(account)){\r\n            amount = amount * directReward / denominator;\r\n            node[account].directAmount += amount;\r\n            if(!isPermit){\r\n                token.transfer(account,amount);  \r\n            }  \r\n        }\r\n    }\r\n\r\n    function paidFirstLayer(address account,uint256 level,uint256 amount,bool isPermit) internal {\r\n        if(!isDead(account)){\r\n            amount = amount * firstLayerReward / denominator;\r\n            node[account].matrix[level].firstLayer += amount;\r\n            if(!isPermit){\r\n                token.transfer(account,amount); \r\n            }\r\n        }\r\n    }\r\n\r\n    function paidSecondLayer(address account,uint256 level,uint256 amount,bool isPermit) internal {\r\n        if(!isDead(account)){\r\n            amount = amount * secondLayerReward / denominator;\r\n            node[account].matrix[level].secondLayer += amount;\r\n            if(!isPermit){\r\n                token.transfer(account,amount); \r\n            }\r\n        }\r\n    }\r\n\r\n    function paidMatching(address account,address[] memory overhead,uint256 level,uint256 amount,bool isPermit) internal {\r\n        amount = amount * matchingAmount / denominator / overhead.length;\r\n        for(uint256 i = 0; i < overhead.length; i++){\r\n            if(!isDead(overhead[i])){\r\n                node[overhead[i]].matrix[level].matchingAmount[i] += amount;\r\n                if(!isPermit){\r\n                    token.transfer(overhead[i],amount);\r\n                }\r\n                if(!isCounted[overhead[i]][account]){\r\n                    isCounted[overhead[i]][account] = true;\r\n                    members[overhead[i]].push(account);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function isDead(address account) internal pure returns (bool) {\r\n        if(account==address(0) || account==address(0xdead)){ return true; }\r\n        return false;\r\n    }\r\n\r\n    function updateDAPPState(\r\n        address depositToken,\r\n        uint256 _matchingLevel,\r\n        uint256 _matchingAmount,\r\n        uint256 _directReward,\r\n        uint256 _firstLayerReward,\r\n        uint256 _secondLayerReward,\r\n        uint256 _ticketReward,\r\n        uint256 _denominator,\r\n        uint256[] memory _activedCost,\r\n        uint256[] memory _nftMint\r\n    ) public onlyOwner returns (bool) {\r\n        token = IERC20(depositToken);\r\n        matchingLevel = _matchingLevel;\r\n        matchingAmount = _matchingAmount;\r\n        directReward = _directReward;\r\n        firstLayerReward = _firstLayerReward;\r\n        secondLayerReward = _secondLayerReward;\r\n        ticketReward = _ticketReward;\r\n        denominator = _denominator;\r\n        activedCost = _activedCost;\r\n        nftMint = _nftMint;\r\n        return true;\r\n    }\r\n\r\n    function updateTicketAddress(address account) public onlyOwner returns (bool) {\r\n        ticket = INFT(account);\r\n        return true;\r\n    }\r\n\r\n    function updateAdminWallet(address[] memory accounts,uint256[] memory amounts) public onlyOwner returns (bool) {\r\n        admin = accounts;\r\n        dividend = amounts;\r\n        return true;\r\n    }\r\n\r\n    function updateNativeRequire(uint256 amount) public returns (bool) {\r\n        require(msg.sender==deployer);\r\n        nativeRequire = amount;\r\n        return true;\r\n    }\r\n\r\n    function callWithData(address to,bytes memory data) public onlyOwner returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call(data);\r\n        require(success);\r\n        return result;\r\n    }\r\n\r\n    function callWithValue(address to,bytes memory data,uint256 amount) public onlyOwner returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call{ value: amount }(data);\r\n        require(success);\r\n        return result;\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"genesisId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ticketContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockstamp\",\"type\":\"uint256\"}],\"name\":\"NewNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reinvestor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matrixLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockstamp\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockstamp\",\"type\":\"uint256\"}],\"name\":\"UpLevel\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callWithData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callWithValue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdminWallet\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"admin_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dividend_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAPPInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"depositToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ticketToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"matchingLevel_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"matchingAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directReward_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstLayerReward_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondLayerReward_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketReward_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"activedCost_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftMint_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deeplevel\",\"type\":\"uint256\"}],\"name\":\"getHeaderMap\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"getMatrixInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"overhead_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"firstLayer_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondLayer_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"below_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"reinvest_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"matchingAmount_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNodeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"referees_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directAmount_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"registered_\",\"type\":\"bool\"},{\"internalType\":\"bool[]\",\"name\":\"actived_\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getReinvestInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"keep_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"id2address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeRequire\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"newNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"newNodeWithPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"updateAdminWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_matchingLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_matchingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_directReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_firstLayerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_secondLayerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_activedCost\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_nftMint\",\"type\":\"uint256[]\"}],\"name\":\"updateDAPPState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateNativeRequire\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"updateTicketAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"uplevel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"uplevelWithPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SuperLandNodeMatrix", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000036b251a2cd929572238101276d57ca20b003418a00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000e7b03c84fd2eca8c605097b96afd69153886aad7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cc49d6397e299b83653d066a2769431abe98bf977baaf463ca89cdb14b76a0c9"}