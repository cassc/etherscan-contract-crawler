{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tokens/liquidityGenerator/LiquidityGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.16;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary SafeMath {\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function WETC() external pure returns (address);\\n\\n    function WHT() external pure returns (address);\\n\\n    function WROSE() external pure returns (address);\\n\\n    function WAVAX() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function addLiquidityAVAX(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function addLiquidityETC(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function addLiquidityROSE(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function swapExactTokensForETCSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForROSESupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\\nabstract contract BaseToken {\\n    event TokenCreated(\\n        address indexed owner,\\n        address indexed token,\\n        string tokenType,\\n        uint256 version\\n    );\\n}\\n\\nabstract contract CoinscopeBuyback {\\n    address public constant COINSCOPE_ADDRESS =\\n        0xD41C4805A9A3128f9F7A7074Da25965371Ba50d5;\\n\\n    IUniswapV2Router02 public constant BSC_PANCAKE_ROUTER =\\n        IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n\\n    event CoinscopeBuybackRejectedSwapBalance();\\n    event CoinscopeBuybackApproved(\\n        uint256 amountToken,\\n        uint256 amountETH,\\n        uint256 liquidity,\\n        uint256 ownerAmountReceiveed\\n    );\\n    event CoinscopeBuybackRejectedLiquidity();\\n    event CoinscopeBuybackRejectedSwap();\\n\\n    function coinscopeBuyback(\\n        address recepient,\\n        address platformFeeReceiver,\\n        uint8 feeShare\\n    ) internal {\\n        if (block.chainid != 56 || address(this).balance == 0 || feeShare > 100)\\n            return;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = BSC_PANCAKE_ROUTER.WETH();\\n        path[1] = COINSCOPE_ADDRESS;\\n\\n        uint256 swapAmount = (address(this).balance * feeShare) / 100;\\n\\n        try\\n            BSC_PANCAKE_ROUTER.swapExactETHForTokens{value: swapAmount}(\\n                0,\\n                path,\\n                address(this),\\n                block.timestamp\\n            )\\n        returns (uint256[] memory amounts) {\\n            uint256 coinscopeBalance = amounts[amounts.length - 1];\\n\\n            if (coinscopeBalance == 0) {\\n                emit CoinscopeBuybackRejectedSwapBalance();\\n                return;\\n            }\\n\\n            uint256 ownerTokens = coinscopeBalance / 100;\\n\\n            IERC20 coinscopeToken = IERC20(COINSCOPE_ADDRESS);\\n\\n            require(\\n                coinscopeToken.transfer(recepient, ownerTokens),\\n                \\\"Coinscope tokens should transferred to owner\\\"\\n            );\\n\\n            coinscopeBalance = coinscopeToken.balanceOf(address(this));\\n\\n            require(\\n                coinscopeToken.approve(\\n                    address(BSC_PANCAKE_ROUTER),\\n                    coinscopeBalance\\n                ),\\n                \\\"Coinscope allowance should be approved\\\"\\n            );\\n\\n            try\\n                BSC_PANCAKE_ROUTER.addLiquidityETH{\\n                    value: address(this).balance\\n                }(\\n                    COINSCOPE_ADDRESS,\\n                    coinscopeBalance,\\n                    0,\\n                    0,\\n                    platformFeeReceiver,\\n                    block.timestamp\\n                )\\n            returns (\\n                uint256 amountToken,\\n                uint256 amountETH,\\n                uint256 liquidity\\n            ) {\\n                emit CoinscopeBuybackApproved(\\n                    amountToken,\\n                    amountETH,\\n                    liquidity,\\n                    ownerTokens\\n                );\\n            } catch {\\n                emit CoinscopeBuybackRejectedLiquidity();\\n            }\\n        } catch {\\n            emit CoinscopeBuybackRejectedSwap();\\n        }\\n    }\\n}\\n\\ncontract LiquidityGeneratorToken is\\n    IERC20,\\n    Ownable,\\n    BaseToken,\\n    CoinscopeBuyback\\n{\\n    using SafeMath for uint256;\\n\\n    uint256 public constant VERSION = 3;\\n\\n    mapping(address => uint256) private rOwned;\\n    mapping(address => uint256) private tOwned;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    mapping(address => bool) private isExcludedFromFee;\\n    mapping(address => bool) private isExcluded;\\n    address[] private excluded;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 private immutable tTotal;\\n    uint256 private rTotal;\\n    uint256 private tFeeTotal;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private immutable _decimals;\\n\\n    uint256 public taxFee;\\n    uint256 private previousTaxFee;\\n\\n    uint256 public liquidityFee;\\n    uint256 private previousLiquidityFee;\\n\\n    uint256 public teamFee;\\n    uint256 private previousTeamFee;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n    address public teamAddress;\\n\\n    bool inSwapAndLiquify;\\n    bool public swapAndLiquifyEnabled;\\n\\n    uint256 private numTokensSellToAddToLiquidity;\\n\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n    event UpdatedTokenSellToLiquify(uint256 amount, uint256 previousAmount);\\n    event UpdatedTaxFeePercent(uint256 value, uint256 previousValue);\\n    event UpdatedLiquidityFeePercent(uint256 value, uint256 previousValue);\\n    event UpdatedTeamFeePercent(uint256 value, uint256 previousValue);\\n    event UpdatedTeamAddress(address value, address previousValue);\\n    event Reflect(address sender, uint256 amount);\\n    event SwapError(uint256 amount);\\n\\n    modifier lockTheSwap() {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_,\\n        uint256 totalSupply_,\\n        address router_,\\n        address teamAddress_,\\n        uint16 taxfeeTax_,\\n        uint16 liquidityFeeTax_,\\n        uint16 teamFeeTax_,\\n        address feeReceiver,\\n        uint8 feeShare\\n    ) payable {\\n        require(\\n            teamAddress_ != address(0),\\n            \\\"teamAddress_ should not be the zero address\\\"\\n        );\\n\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n\\n        tTotal = totalSupply_;\\n        rTotal = (MAX - (MAX % tTotal));\\n\\n        taxFee = taxfeeTax_;\\n        previousTaxFee = taxFee;\\n\\n        liquidityFee = liquidityFeeTax_;\\n        previousLiquidityFee = liquidityFee;\\n\\n        teamAddress = teamAddress_;\\n        teamFee = teamFeeTax_;\\n        previousTeamFee = teamFee;\\n\\n        validateTaxes();\\n\\n        numTokensSellToAddToLiquidity = (totalSupply_) / 10000; // 0.01%\\n\\n        swapAndLiquifyEnabled = true;\\n\\n        rOwned[owner()] = rTotal;\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router_);\\n\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), getNativeCurrency());\\n\\n        isExcludedFromFee[owner()] = true;\\n        isExcludedFromFee[address(this)] = true;\\n\\n        emit Transfer(address(0), owner(), tTotal);\\n\\n        emit TokenCreated(\\n            owner(),\\n            address(this),\\n            \\\"liquidityGenerator\\\",\\n            VERSION\\n        );\\n\\n        if (feeReceiver == address(0x0)) return;\\n\\n        coinscopeBuyback(owner(), feeReceiver, feeShare);\\n        payable(feeReceiver).transfer(address(this).balance);\\n    }\\n\\n    function getNativeCurrency() internal view returns (address) {\\n        if (block.chainid == 61) {\\n            //etc\\n            return uniswapV2Router.WETC();\\n        } else if (block.chainid == 128) {\\n            //heco chain\\n            return uniswapV2Router.WHT();\\n        } else if (block.chainid == 42262) {\\n            //oasis\\n            return uniswapV2Router.WROSE();\\n        } else if (block.chainid == 43114 || block.chainid == 43113) {\\n            //avalance\\n            return uniswapV2Router.WAVAX();\\n        } else {\\n            return uniswapV2Router.WETH();\\n        }\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (isExcluded[account]) return tOwned[account];\\n        return tokenFromReflection(rOwned[account]);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address account,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[account][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    ) external virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    ) external virtual returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    function isExcludedFromReward(\\n        address account\\n    ) external view returns (bool) {\\n        return isExcluded[account];\\n    }\\n\\n    function totalFees() external view returns (uint256) {\\n        return tFeeTotal;\\n    }\\n\\n    function deliver(uint256 tAmount) external {\\n        address sender = _msgSender();\\n        require(\\n            !isExcluded[sender],\\n            \\\"Excluded addresses cannot call this function\\\"\\n        );\\n        (uint256 rAmount, , , , , , ) = _getValues(tAmount);\\n        rOwned[sender] = rOwned[sender] - rAmount;\\n        rTotal = rTotal - rAmount;\\n        tFeeTotal = tFeeTotal + tAmount;\\n    }\\n\\n    function reflectionFromToken(\\n        uint256 tAmount,\\n        bool deductTransferFee\\n    ) external view returns (uint256) {\\n        require(tAmount <= tTotal, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , , , , ) = _getValues(tAmount);\\n            return rAmount;\\n        } else {\\n            (, uint256 rTransferAmount, , , , , ) = _getValues(tAmount);\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    function tokenFromReflection(\\n        uint256 rAmount\\n    ) public view returns (uint256) {\\n        require(\\n            rAmount <= rTotal,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    function excludeFromReward(address account) external onlyOwner {\\n        require(!isExcluded[account], \\\"Account is already excluded\\\");\\n        if (rOwned[account] > 0) {\\n            tOwned[account] = tokenFromReflection(rOwned[account]);\\n        }\\n        isExcluded[account] = true;\\n        excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner {\\n        require(isExcluded[account], \\\"Account is already excluded\\\");\\n\\n        for (uint256 i = 0; i < excluded.length; i++) {\\n            if (excluded[i] == account) {\\n                excluded[i] = excluded[excluded.length - 1];\\n                tOwned[account] = 0;\\n                isExcluded[account] = false;\\n                excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _transferBothExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tTeam\\n        ) = _getValues(tAmount);\\n        tOwned[sender] = tOwned[sender] - tAmount;\\n        rOwned[sender] = rOwned[sender] - rAmount;\\n        tOwned[recipient] = tOwned[recipient] + tTransferAmount;\\n        rOwned[recipient] = rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(sender, tLiquidity);\\n        _takeTeamFee(sender, tTeam);\\n        _reflectFee(sender, rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function excludeFromFee(address account) external onlyOwner {\\n        isExcludedFromFee[account] = true;\\n    }\\n\\n    function includeInFee(address account) external onlyOwner {\\n        isExcludedFromFee[account] = false;\\n    }\\n\\n    function setTaxFeePercent(uint256 taxFeeBps) external onlyOwner {\\n        emit UpdatedTaxFeePercent(taxFeeBps, taxFee);\\n\\n        taxFee = taxFeeBps;\\n\\n        validateTaxes();\\n    }\\n\\n    function setLiquidityFeePercent(\\n        uint256 liquidityFeeBps\\n    ) external onlyOwner {\\n        emit UpdatedLiquidityFeePercent(liquidityFeeBps, liquidityFee);\\n\\n        liquidityFee = liquidityFeeBps;\\n\\n        validateTaxes();\\n    }\\n\\n    function setTeamFeePercent(uint256 teamFeeBps) external onlyOwner {\\n        emit UpdatedTeamFeePercent(teamFeeBps, teamFee);\\n\\n        teamFee = teamFeeBps;\\n\\n        validateTaxes();\\n    }\\n\\n    function setTeamAddress(address wallet) external onlyOwner {\\n        require(wallet != address(0x0));\\n\\n        emit UpdatedTeamAddress(wallet, teamAddress);\\n\\n        teamAddress = wallet;\\n    }\\n\\n    function validateTaxes() internal view {\\n        require(\\n            taxFee + liquidityFee + teamFee <= 10 ** 4 / 5,\\n            \\\"Total fee is over 20%\\\"\\n        );\\n    }\\n\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyOwner {\\n        swapAndLiquifyEnabled = enabled;\\n        emit SwapAndLiquifyEnabledUpdated(enabled);\\n    }\\n\\n    function setTokenSellToLiquify(uint256 amount) external onlyOwner {\\n        require(\\n            amount > tTotal / 10 ** 5 && amount <= tTotal / 10 ** 3,\\n            \\\"Amount must be between 0.001% - 0.1% of total supply\\\"\\n        );\\n\\n        emit UpdatedTokenSellToLiquify(amount, numTokensSellToAddToLiquidity);\\n\\n        numTokensSellToAddToLiquidity = amount;\\n    }\\n\\n    receive() external payable {}\\n\\n    function _getValues(\\n        uint256 tAmount\\n    )\\n        private\\n        view\\n        returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256)\\n    {\\n        (\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tTeam\\n        ) = _getTValues(tAmount);\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\\n            tAmount,\\n            tFee,\\n            tLiquidity,\\n            tTeam,\\n            _getRate()\\n        );\\n        return (\\n            rAmount,\\n            rTransferAmount,\\n            rFee,\\n            tTransferAmount,\\n            tFee,\\n            tLiquidity,\\n            tTeam\\n        );\\n    }\\n\\n    function _getTValues(\\n        uint256 tAmount\\n    ) private view returns (uint256, uint256, uint256, uint256) {\\n        uint256 tFee = calculateTaxFee(tAmount);\\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\\n        uint256 tTeamFee = calculateTeamFee(tAmount);\\n        uint256 tTransferAmount = tAmount - tFee - tLiquidity - tTeamFee;\\n        return (tTransferAmount, tFee, tLiquidity, tTeamFee);\\n    }\\n\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tFee,\\n        uint256 tLiquidity,\\n        uint256 tTeam,\\n        uint256 currentRate\\n    ) private pure returns (uint256, uint256, uint256) {\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rLiquidity = tLiquidity * currentRate;\\n        uint256 rTeam = tTeam * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee - rLiquidity - rTeam;\\n        return (rAmount, rTransferAmount, rFee);\\n    }\\n\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = rTotal;\\n        uint256 tSupply = tTotal;\\n        for (uint256 i = 0; i < excluded.length; i++) {\\n            if (rOwned[excluded[i]] > rSupply || tOwned[excluded[i]] > tSupply)\\n                return (rTotal, tTotal);\\n            rSupply = rSupply - rOwned[excluded[i]];\\n            tSupply = tSupply - tOwned[excluded[i]];\\n        }\\n        if (rSupply < rTotal / tTotal) return (rTotal, tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    function _takeLiquidity(address sender, uint256 tLiquidity) private {\\n        if (tLiquidity == 0) return;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rLiquidity = tLiquidity * currentRate;\\n        rOwned[address(this)] = rOwned[address(this)] + rLiquidity;\\n\\n        if (isExcluded[address(this)])\\n            tOwned[address(this)] = tOwned[address(this)] + tLiquidity;\\n\\n        emit Transfer(sender, address(this), tLiquidity);\\n    }\\n\\n    function _takeTeamFee(address sender, uint256 tTeam) private {\\n        if (tTeam == 0) return;\\n\\n        uint256 currentRate = _getRate();\\n        uint256 rTeam = tTeam * currentRate;\\n        rOwned[teamAddress] = rOwned[teamAddress] + rTeam;\\n\\n        if (isExcluded[teamAddress])\\n            tOwned[teamAddress] = tOwned[teamAddress] + tTeam;\\n\\n        emit Transfer(sender, teamAddress, tTeam);\\n    }\\n\\n    function _reflectFee(address sender, uint256 rFee, uint256 tFee) private {\\n        if (tFee == 0) return;\\n\\n        rTotal = rTotal - rFee;\\n        tFeeTotal = tFeeTotal + tFee;\\n\\n        emit Reflect(sender, tFee);\\n    }\\n\\n    function calculateTaxFee(uint256 amount) private view returns (uint256) {\\n        return (amount * taxFee) / (10 ** 4);\\n    }\\n\\n    function calculateLiquidityFee(\\n        uint256 amount\\n    ) private view returns (uint256) {\\n        return (amount * liquidityFee) / (10 ** 4);\\n    }\\n\\n    function calculateTeamFee(uint256 amount) private view returns (uint256) {\\n        return (amount * teamFee) / (10 ** 4);\\n    }\\n\\n    function removeAllFee() private {\\n        previousTaxFee = taxFee;\\n        previousLiquidityFee = liquidityFee;\\n        previousTeamFee = teamFee;\\n\\n        taxFee = 0;\\n        liquidityFee = 0;\\n        teamFee = 0;\\n    }\\n\\n    function restoreAllFee() private {\\n        taxFee = previousTaxFee;\\n        liquidityFee = previousLiquidityFee;\\n        teamFee = previousTeamFee;\\n    }\\n\\n    function getIsExcludedFromFee(address account) public view returns (bool) {\\n        return isExcludedFromFee[account];\\n    }\\n\\n    function _approve(\\n        address account,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[account][spender] = amount;\\n        emit Approval(account, spender, amount);\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) private {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool overMinTokenBalance = contractTokenBalance >=\\n            numTokensSellToAddToLiquidity;\\n        if (\\n            overMinTokenBalance &&\\n            !inSwapAndLiquify &&\\n            from != uniswapV2Pair &&\\n            swapAndLiquifyEnabled\\n        ) {\\n            contractTokenBalance = numTokensSellToAddToLiquidity;\\n            swapAndLiquify(contractTokenBalance);\\n        }\\n\\n        bool takeFee = !isExcludedFromFee[from] && !isExcludedFromFee[to];\\n\\n        _tokenTransfer(from, to, amount, takeFee);\\n    }\\n\\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\\n        uint256 half = contractTokenBalance / 2;\\n        uint256 otherHalf = contractTokenBalance - half;\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        swapTokensForEth(half);\\n\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        if (newBalance == 0) return;\\n\\n        addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = getNativeCurrency();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        if (block.chainid == 61) {\\n            //etc\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETCSupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0, // accept any amount of ETH\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapError(tokenAmount);\\n            }\\n        } else if (block.chainid == 42262) {\\n            //oasis\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForROSESupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0, // accept any amount of ETH\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapError(tokenAmount);\\n            }\\n        } else if (block.chainid == 43114 || block.chainid == 43113) {\\n            //avalance\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForAVAXSupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0, // accept any amount of ETH\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapError(tokenAmount);\\n            }\\n        } else {\\n            try\\n                uniswapV2Router\\n                    .swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        tokenAmount,\\n                        0, // accept any amount of ETH\\n                        path,\\n                        address(this),\\n                        block.timestamp\\n                    )\\n            {} catch {\\n                emit SwapError(tokenAmount);\\n            }\\n        }\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        if (block.chainid == 61) {\\n            //etc\\n            uniswapV2Router.addLiquidityETC{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                owner(),\\n                block.timestamp\\n            );\\n        } else if (block.chainid == 42262) {\\n            //oasis\\n            uniswapV2Router.addLiquidityROSE{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                owner(),\\n                block.timestamp\\n            );\\n        } else if (block.chainid == 43114 || block.chainid == 43113) {\\n            //avalance\\n            uniswapV2Router.addLiquidityAVAX{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                owner(),\\n                block.timestamp\\n            );\\n        } else {\\n            uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                0,\\n                0,\\n                owner(),\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        if (!takeFee) removeAllFee();\\n\\n        if (isExcluded[sender] && !isExcluded[recipient]) {\\n            _transferFromExcluded(sender, recipient, amount);\\n        } else if (!isExcluded[sender] && isExcluded[recipient]) {\\n            _transferToExcluded(sender, recipient, amount);\\n        } else if (!isExcluded[sender] && !isExcluded[recipient]) {\\n            _transferStandard(sender, recipient, amount);\\n        } else if (isExcluded[sender] && isExcluded[recipient]) {\\n            _transferBothExcluded(sender, recipient, amount);\\n        } else {\\n            _transferStandard(sender, recipient, amount);\\n        }\\n\\n        if (!takeFee) restoreAllFee();\\n    }\\n\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tTeam\\n        ) = _getValues(tAmount);\\n        rOwned[sender] = rOwned[sender] - rAmount;\\n        rOwned[recipient] = rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(sender, tLiquidity);\\n        _takeTeamFee(sender, tTeam);\\n        _reflectFee(sender, rFee, tFee);\\n\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _transferToExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tTeam\\n        ) = _getValues(tAmount);\\n        rOwned[sender] = rOwned[sender] - rAmount;\\n        tOwned[recipient] = tOwned[recipient] + tTransferAmount;\\n        rOwned[recipient] = rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(sender, tLiquidity);\\n        _takeTeamFee(sender, tTeam);\\n        _reflectFee(sender, rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _transferFromExcluded(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee,\\n            uint256 tLiquidity,\\n            uint256 tTeam\\n        ) = _getValues(tAmount);\\n        tOwned[sender] = tOwned[sender] - tAmount;\\n        rOwned[sender] = rOwned[sender] - rAmount;\\n        rOwned[recipient] = rOwned[recipient] + rTransferAmount;\\n        _takeLiquidity(sender, tLiquidity);\\n        _takeTeamFee(sender, tTeam);\\n        _reflectFee(sender, rFee, tFee);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"teamAddress_\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"taxfeeTax_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"liquidityFeeTax_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"teamFeeTax_\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"feeShare\",\"type\":\"uint8\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownerAmountReceiveed\",\"type\":\"uint256\"}],\"name\":\"CoinscopeBuybackApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CoinscopeBuybackRejectedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CoinscopeBuybackRejectedSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CoinscopeBuybackRejectedSwapBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reflect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"}],\"name\":\"UpdatedLiquidityFeePercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"}],\"name\":\"UpdatedTaxFeePercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousValue\",\"type\":\"address\"}],\"name\":\"UpdatedTeamAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"}],\"name\":\"UpdatedTeamFeePercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedTokenSellToLiquify\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BSC_PANCAKE_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COINSCOPE_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getIsExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFeeBps\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taxFeeBps\",\"type\":\"uint256\"}],\"name\":\"setTaxFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamFeeBps\",\"type\":\"uint256\"}],\"name\":\"setTeamFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTokenSellToLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiquidityGeneratorToken", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000000f13e144de84b6ea420862b2fad1f9354ab1f8c6000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004746573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000047465737400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}