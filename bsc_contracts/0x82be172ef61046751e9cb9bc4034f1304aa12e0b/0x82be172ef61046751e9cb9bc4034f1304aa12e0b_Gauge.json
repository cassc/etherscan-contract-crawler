{"SourceCode": "{\"Address.sol\":{\"content\":\"/**\\n * @title Address\\n * @dev Address.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance \\u003e= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                0,\\n                \\\"Address: low-level call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance \\u003e= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return\\n            verifyCallResultFromTarget(\\n                target,\\n                success,\\n                returndata,\\n                errorMessage\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return\\n            verifyCallResultFromTarget(\\n                target,\\n                success,\\n                returndata,\\n                errorMessage\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return\\n            verifyCallResultFromTarget(\\n                target,\\n                success,\\n                returndata,\\n                errorMessage\\n            );\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage)\\n        private\\n        pure\\n    {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"Gauge.sol\":{\"content\":\"/**\\n * @title Gauge\\n * @dev Gauge.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./IBasePair.sol\\\";\\nimport \\\"./IBaseFactory.sol\\\";\\nimport \\\"./IBribe.sol\\\";\\nimport \\\"./IGaugeFactory.sol\\\";\\nimport \\\"./ProtocolGovernance.sol\\\";\\nimport \\\"./IReferrals.sol\\\";\\nimport \\\"./IGauge.sol\\\";\\n\\ncontract Gauge is IGauge, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public immutable STABLE;\\n    IERC20 public immutable TOKEN;\\n    address private immutable token;\\n\\n    uint256 public constant DURATION = 1 weeks;\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    uint256 public fees0;\\n    uint256 public fees1;\\n\\n    address public immutable gaugeFactory;\\n    address public referralContract;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public whitelisted;\\n    mapping(address =\\u003e uint256) public earnedRefs;\\n\\n    /**\\n     * @dev Outputs the fee variables.\\n     */\\n    uint256 public referralFee;\\n    uint256[] public refLevelPercent = [60000, 30000, 10000];\\n\\n    uint256 internal divisor = 100000;\\n\\n    modifier onlyDistribution() {\\n        require(\\n            msg.sender == gaugeFactory,\\n            \\\"Caller is not RewardsDistribution contract\\\"\\n        );\\n        _;\\n    }\\n\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\n    mapping(address =\\u003e uint256) public rewards;\\n\\n    uint256 private _totalSupply;\\n    uint256 public derivedSupply;\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(address =\\u003e uint256) public derivedBalances;\\n    mapping(address =\\u003e uint256) private _base;\\n\\n    constructor(\\n        address _stable,\\n        address _token,\\n        address _gaugeFactory\\n    ) public {\\n        STABLE = IERC20(_stable);\\n        TOKEN = IERC20(_token);\\n        token = _token;\\n        gaugeFactory = _gaugeFactory;\\n        referralContract = IProtocolGovernance(gaugeFactory)\\n            .baseReferralsContract();\\n        referralFee = IProtocolGovernance(gaugeFactory).baseReferralFee();\\n    }\\n\\n    // Claim the fees from the LP token and Bribe to the voter\\n    function claimVotingFees()\\n        external\\n        nonReentrant\\n        returns (uint256 claimed0, uint256 claimed1)\\n    {\\n        return _claimVotingFees();\\n    }\\n\\n    function _claimVotingFees()\\n        internal\\n        returns (uint256 claimed0, uint256 claimed1)\\n    {\\n        (claimed0, claimed1) = IBasePair(address(TOKEN)).claimFees();\\n        if (claimed0 \\u003e 0 || claimed1 \\u003e 0) {\\n            address bribe = IGaugeFactory(gaugeFactory).bribes(address(this));\\n            uint256 _fees0 = fees0 + claimed0;\\n            uint256 _fees1 = fees1 + claimed1;\\n            (address _token0, address _token1) = IBasePair(address(TOKEN))\\n                .tokens();\\n            if (_fees0 \\u003e DURATION) {\\n                fees0 = 0;\\n                IERC20(_token0).safeApprove(bribe, _fees0);\\n                IBribe(bribe).notifyRewardAmount(_token0, _fees0);\\n            } else {\\n                fees0 = _fees0;\\n            }\\n            if (_fees1 \\u003e DURATION) {\\n                fees1 = 0;\\n                IERC20(_token1).safeApprove(bribe, _fees1);\\n                IBribe(bribe).notifyRewardAmount(_token1, _fees1);\\n            } else {\\n                fees1 = _fees1;\\n            }\\n\\n            emit ClaimVotingFees(msg.sender, claimed0, claimed1);\\n        }\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return Math.min(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (derivedSupply == 0) {\\n            return 0;\\n        }\\n\\n        if (_totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored +\\n            (((lastTimeRewardApplicable() - lastUpdateTime) *\\n                rewardRate *\\n                1e18) / derivedSupply);\\n    }\\n\\n    // The derivedBalance function calculates the derived balance of an account, which is used to determine the amount of rewards earned by the account.\\n    function derivedBalance(address account) public view returns (uint256) {\\n        if (IGaugeFactory(gaugeFactory).weights(token) == 0) return 0;\\n        uint256 _balance = _balances[account];\\n        uint256 _derived = (_balance * 40) / 100;\\n        uint256 _adjusted = ((((_totalSupply *\\n            IGaugeFactory(gaugeFactory).votes(account, token)) /\\n            IGaugeFactory(gaugeFactory).weights(token)) * 60) / 100);\\n        return Math.min(_derived + _adjusted, _balance);\\n    }\\n\\n    // The kick function updates the derived balance of an account and the total derived supply of the contract\\n    function kick(address account) public {\\n        uint256 _derivedBalance = derivedBalances[account];\\n        derivedSupply = derivedSupply - _derivedBalance;\\n        _derivedBalance = derivedBalance(account);\\n        derivedBalances[account] = _derivedBalance;\\n        derivedSupply = derivedSupply + _derivedBalance;\\n        emit Kick(account);\\n    }\\n\\n    // Your earned rewards (without referrals deduction)\\n    function earned(address account) public view returns (uint256) {\\n        if (derivedSupply == 0) {\\n            return rewards[account];\\n        }\\n        return\\n            ((derivedBalances[account] *\\n                (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18) +\\n            rewards[account];\\n    }\\n\\n    // How many rewards will be distributed this epoch\\n    function getRewardForDuration() external view returns (uint256) {\\n        return rewardRate * DURATION;\\n    }\\n\\n    // Deposit LP token\\n    function deposit(uint256 amount) external {\\n        _deposit(amount, msg.sender);\\n    }\\n\\n    function depositFor(uint256 amount, address account) external {\\n        _deposit(amount, account);\\n    }\\n\\n    function _deposit(uint256 amount, address account)\\n        internal\\n        nonReentrant\\n        updateReward(account)\\n    {\\n        require(account != address(0), \\\"cannot deposit to address 0\\\");\\n        require(amount \\u003e 0, \\\"deposit(Gauge): cannot stake 0\\\");\\n\\n        _balances[account] = _balances[account] + amount;\\n        _totalSupply = _totalSupply + amount;\\n\\n        TOKEN.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit Staked(account, amount);\\n    }\\n\\n    // Withdraw LP token\\n    function withdraw(uint256 amount) external {\\n        _withdraw(amount);\\n    }\\n\\n    function _withdraw(uint256 amount)\\n        internal\\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\n        _totalSupply = _totalSupply - amount;\\n        _balances[msg.sender] = _balances[msg.sender] - amount;\\n        TOKEN.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    // Claim your rewards\\n    function getReward() external {\\n        getRewardForOwnerToOtherOwner(msg.sender, msg.sender);\\n    }\\n\\n    // Give the owner the earned rewards\\n    function getRewardForOwner(address _owner) external {\\n        getRewardForOwnerToOtherOwner(_owner, _owner);\\n    }\\n\\n    // Get the reward from a owner to a whistlistet address or self\\n    function getRewardForOwnerToOtherOwner(address _owner, address _receiver)\\n        public\\n        nonReentrant\\n        updateReward(_owner)\\n    {\\n        uint256 reward = rewards[_owner];\\n        if (reward \\u003e 0) {\\n            if (_owner != _receiver) {\\n                require(\\n                    _owner == msg.sender ||\\n                        whitelisted[_owner][_receiver] == true,\\n                    \\\"not owner or whitelisted\\\"\\n                );\\n            }\\n            uint256 _divisor = divisor;\\n            rewards[_owner] = 0;\\n\\n            uint256 refReward = (reward * referralFee) / _divisor;\\n            uint256 remainingRefReward = refReward;\\n\\n            STABLE.safeTransfer(_receiver, reward - refReward);\\n            emit RewardPaid(_owner, _receiver, reward - refReward);\\n\\n            address ref = IReferrals(referralContract).getSponsor(_owner);\\n\\n            uint256 i = 0;\\n            while (i \\u003c refLevelPercent.length \\u0026\\u0026 refLevelPercent[i] \\u003e 0) {\\n                if (ref != IReferrals(referralContract).membersList(0)) {\\n                    uint256 refFeeAmount = (refReward * refLevelPercent[i]) /\\n                        _divisor;\\n                    remainingRefReward = remainingRefReward - refFeeAmount;\\n                    STABLE.safeTransfer(ref, refFeeAmount);\\n                    earnedRefs[ref] = earnedRefs[ref] + refFeeAmount;\\n                    emit RefRewardPaid(ref, reward);\\n                    ref = IReferrals(referralContract).getSponsor(ref);\\n                    i++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (remainingRefReward \\u003e 0) {\\n                address _mainRefFeeReceiver = IProtocolGovernance(gaugeFactory)\\n                    .mainRefFeeReceiver();\\n                STABLE.safeTransfer(_mainRefFeeReceiver, remainingRefReward);\\n                earnedRefs[_mainRefFeeReceiver] =\\n                    earnedRefs[_mainRefFeeReceiver] +\\n                    remainingRefReward;\\n                emit RefRewardPaid(_mainRefFeeReceiver, remainingRefReward);\\n            }\\n        }\\n    }\\n\\n    // Notify rewards for the LP depositer\\n    function notifyRewardAmount(uint256 reward)\\n        external\\n        onlyDistribution\\n        updateReward(address(0))\\n    {\\n        if (derivedSupply != 0) {\\n            STABLE.safeTransferFrom(gaugeFactory, address(this), reward);\\n            if (block.timestamp \\u003e= periodFinish) {\\n                rewardRate = reward / DURATION;\\n            } else {\\n                uint256 remaining = periodFinish - block.timestamp;\\n                uint256 leftover = remaining * rewardRate;\\n                rewardRate = (reward + leftover) / DURATION;\\n            }\\n        }\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = STABLE.balanceOf(address(this));\\n        require(rewardRate \\u003c= balance / DURATION, \\\"Provided reward too high\\\");\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp + DURATION;\\n        emit RewardAdded(reward);\\n    }\\n\\n    // Update the rewards\\n    modifier updateReward(address account) {\\n        if (block.timestamp \\u003e IGaugeFactory(gaugeFactory).nextPoke(account)) {\\n            IGaugeFactory(gaugeFactory).poke(account);\\n        }\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n        if (account != address(0)) {\\n            kick(account);\\n        }\\n    }\\n\\n    // Update the referral variables\\n    function updateReferral(\\n        address _referralsContract,\\n        uint256 _referralFee,\\n        uint256[] memory _refLevelPercent\\n    ) public {\\n        require(\\n            msg.sender == IProtocolGovernance(gaugeFactory).governance() ||\\n                msg.sender == IProtocolGovernance(gaugeFactory).admin(),\\n            \\\"Pair: only factory\\u0027s feeAmountOwner or admin\\\"\\n        );\\n        referralContract = _referralsContract;\\n        referralFee = _referralFee;\\n        refLevelPercent = _refLevelPercent;\\n        emit UpdateReferral(referralContract, referralFee, refLevelPercent);\\n    }\\n\\n    // Set whitelist for other receiver\\n    function setWhitelisted(address _receiver, bool _whitelist) public {\\n        whitelisted[msg.sender][_receiver] = _whitelist;\\n        emit Whitelisted(msg.sender, _receiver);\\n    }\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(\\n        address indexed user,\\n        address indexed receiver,\\n        uint256 reward\\n    );\\n    event RefRewardPaid(address indexed user, uint256 reward);\\n    event ClaimVotingFees(\\n        address indexed from,\\n        uint256 claimed0,\\n        uint256 claimed1\\n    );\\n    event Whitelisted(address user, address whitelistedUser);\\n    event UpdateReferral(\\n        address referralContract,\\n        uint256 referralFee,\\n        uint256[] refLevelPercent\\n    );\\n    event Kick(address account);\\n}\\n\"},\"IBaseFactory.sol\":{\"content\":\"/**\\n * @title Interface Base V1 Factory\\n * @dev IBaseV1Factory.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBaseFactory {\\n    function isPaused() external view returns (bool);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function feeAmountOwner() external view returns (address);\\n\\n    function baseStableFee() external view returns (uint256);\\n\\n    function baseVariableFee() external view returns (uint256);\\n\\n    function getPair(\\n        address token0,\\n        address token1,\\n        bool stable\\n    ) external view returns (address);\\n\\n    function allPairs(uint256 id) external view returns (address);\\n\\n    function isPair(address pair) external view returns (bool);\\n\\n    function protocolAddresses(address pair) external view returns (address);\\n\\n    function usdfiMaker() external view returns (address);\\n\\n    function maxGasPrice() external view returns (uint256);\\n\\n    function setBaseVariableFee(uint256 fee) external;\\n\\n    function setMaxGasPrice(uint256 gas) external;\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function setOwner(address owner) external;\\n\\n    function acceptOwner() external;\\n\\n    function setPause(bool state) external;\\n\\n    function setProtocolAddress(address pair, address protocolAddress) external;\\n\\n    function setAdmins(\\n        address usdfiMaker,\\n        address feeAmountOwner,\\n        address admin\\n    ) external;\\n\\n    function pairCodeHash() external pure returns (bytes32);\\n\\n    function getInitializable()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        bool stable\\n    ) external returns (address pair);\\n}\\n\"},\"IBasePair.sol\":{\"content\":\"/**\\n * @title Interface Base Pair\\n * @dev IBasePair.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBasePair {\\n    function name() external view returns (string calldata);\\n\\n    function symbol() external view returns (string calldata);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function stable() external view returns (bool);\\n\\n    function fee() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function fees() external view returns (address);\\n\\n    function reserve0() external view returns (uint256);\\n\\n    function reserve1() external view returns (uint256);\\n\\n    function blockTimestampLast() external view returns (uint256);\\n\\n    function reserve0CumulativeLast() external view returns (uint256);\\n\\n    function reserve1CumulativeLast() external view returns (uint256);\\n\\n    function index0() external view returns (uint256);\\n\\n    function index1() external view returns (uint256);\\n\\n    function supplyIndex0(address owner) external view returns (uint256);\\n\\n    function supplyIndex1(address owner) external view returns (uint256);\\n\\n    function claimable0(address owner) external view returns (uint256);\\n\\n    function claimable1(address owner) external view returns (uint256);\\n\\n    function observationLength() external view returns (uint256);\\n\\n    function metadata()\\n        external\\n        view\\n        returns (\\n            uint256 decimals0,\\n            uint256 decimals1,\\n            uint256 reserve0,\\n            uint256 reserve1,\\n            bool stable,\\n            address token0,\\n            address token1\\n        );\\n\\n    function tokens() external view returns (address, address);\\n\\n    function usdfiMaker() external view returns (address);\\n\\n    function protocol() external view returns (address);\\n\\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 reserve0,\\n            uint256 reserve1,\\n            uint256 blockTimestampLast\\n        );\\n\\n    function currentCumulativePrices()\\n        external\\n        view\\n        returns (\\n            uint256 reserve0Cumulative,\\n            uint256 reserve1Cumulative,\\n            uint256 blockTimestamp\\n        );\\n\\n    function current(address tokenIn, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut);\\n\\n    function quote(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 granularity\\n    ) external view returns (uint256 amountOut);\\n\\n    function prices(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points\\n    ) external view returns (uint256[] memory);\\n\\n    function sample(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points,\\n        uint256 window\\n    ) external view returns (uint256[] memory);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function getAmountOut(uint256 amountIn, address tokenIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function setFee(uint256 fee) external;\\n}\\n\"},\"IBribe.sol\":{\"content\":\"/**\\n * @title Interface Bribe\\n * @dev IBribe.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBribe {\\n    function WEEK() external view returns (uint256);\\n\\n    function firstBribeTimestamp() external view returns (uint256);\\n\\n    function isRewardToken(address token) external view returns (bool);\\n\\n    function rewardTokens(uint256 ID) external view returns (address);\\n\\n    function gaugeFactory() external view returns (address);\\n\\n    function bribeFactory() external view returns (address);\\n\\n    function userTimestamp(address owner, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function _totalSupply(uint256 timestamp) external view returns (uint256);\\n\\n    function _balances(address owner, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function referralFee() external view returns (uint256);\\n\\n    function referralContract() external view returns (address);\\n\\n    function refLevelPercent(uint256 level) external view returns (uint256);\\n\\n    function earnedRefs(address owner, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function whitelisted(address owner, address receiver)\\n        external\\n        view\\n        returns (bool);\\n\\n    function userFirstDeposit(address owner) external view returns (uint256);\\n\\n    function getEpoch() external view returns (uint256);\\n\\n    function rewardsListLength() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalSupplyNextEpoch() external view returns (uint256);\\n\\n    function totalSupplyAt(uint256 timestamp) external view returns (uint256);\\n\\n    function balanceOfAt(address voter, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address voter) external view returns (uint256);\\n\\n    function earned(address voter, address rewardToken)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function _earned(\\n        address voter,\\n        address rewardToken,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    function rewardPerToken(address rewardsToken, uint256 timestmap)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function _deposit(uint256 amount, address voter) external;\\n\\n    function _withdraw(uint256 amount, address voter) external;\\n\\n    function notifyRewardAmount(address rewardsToken, uint256 reward) external;\\n\\n    function getReward() external;\\n\\n    function getRewardForOwner(address voter) external;\\n\\n    function getRewardForOwnerToOtherOwner(address voter, address receiver)\\n        external;\\n\\n    function getRewardForOwnerToOtherOwnerSingleToken(\\n        address voter,\\n        address receiver,\\n        address[] memory tokens\\n    ) external;\\n\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external;\\n\\n    function addRewardtoken(address rewardsToken) external;\\n\\n    function setWhitelisted(address receiver, bool whitlist) external;\\n\\n    function updateReferral(\\n        address referralsContract,\\n        uint256 referralFee,\\n        uint256[] memory refLevelPercent\\n    ) external;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"/**\\n * @title Interface ERC20\\n * @dev IERC20.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"IGauge.sol\":{\"content\":\"/**\\n * @title Interface Gauge\\n * @dev IGauge.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IGauge {\\n    function DURATION() external returns (uint256);\\n\\n    function periodFinish() external returns (uint256);\\n\\n    function rewardRate() external returns (uint256);\\n\\n    function lastUpdateTime() external returns (uint256);\\n\\n    function rewardPerTokenStored() external returns (uint256);\\n\\n    function fees0() external returns (uint256);\\n\\n    function fees1() external returns (uint256);\\n\\n    function gaugeFactory() external returns (address);\\n\\n    function referralContract() external returns (address);\\n\\n    function whitelisted(address owner, address receiver)\\n        external\\n        returns (bool);\\n\\n    function earnedRefs(address owner) external returns (uint256);\\n\\n    function referralFee() external returns (uint256);\\n\\n    function refLevelPercent(uint256 level) external returns (uint256);\\n\\n    function userRewardPerTokenPaid(address owner) external returns (uint256);\\n\\n    function rewards(address owner) external returns (uint256);\\n\\n    function derivedSupply() external returns (uint256);\\n\\n    function derivedBalances(address owner) external returns (uint256);\\n\\n    function claimVotingFees()\\n        external\\n        returns (uint256 claimed0, uint256 claimed1);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function lastTimeRewardApplicable() external view returns (uint256);\\n\\n    function rewardPerToken() external view returns (uint256);\\n\\n    function derivedBalance(address account) external view returns (uint256);\\n\\n    function kick(address account) external;\\n\\n    function earned(address account) external view returns (uint256);\\n\\n    function getRewardForDuration() external view returns (uint256);\\n\\n    function deposit(uint256 amount) external;\\n\\n    function depositFor(uint256 amount, address account) external;\\n\\n    function withdraw(uint256 amount) external;\\n\\n    function getReward() external;\\n\\n    function getRewardForOwner(address owner) external;\\n\\n    function getRewardForOwnerToOtherOwner(address owner, address receiver)\\n        external;\\n\\n    function notifyRewardAmount(uint256 reward) external;\\n\\n    function updateReferral(\\n        address referralsContract,\\n        uint256 referralFee,\\n        uint256[] memory refLevelPercent\\n    ) external;\\n\\n    function setWhitelisted(address receiver, bool whitelist) external;\\n}\\n\"},\"IGaugeFactory.sol\":{\"content\":\"/**\\n * @title Interface Gauge Factory\\n * @dev IGaugeFactory.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IGaugeFactory {\\n    function tokens() external view returns (address[] memory);\\n\\n    function getGauge(address token) external view returns (address);\\n\\n    function getBribes(address gauge) external view returns (address);\\n\\n    function reset(address user) external;\\n\\n    function poke(address owner) external;\\n\\n    function vote(\\n        address user,\\n        address[] calldata tokenVote,\\n        uint256[] calldata weights\\n    ) external;\\n\\n    function addGauge(address tokenLP, uint256 maxVotesToken)\\n        external\\n        returns (address);\\n\\n    function deprecateGauge(address token) external;\\n\\n    function resurrectGauge(address token) external;\\n\\n    function length() external view returns (uint256);\\n\\n    function distribute(uint256 start, uint256 end) external;\\n\\n    function updateVeProxy(address veProxy) external;\\n\\n    function updatePokeDelay(uint256 pokeDelay) external;\\n\\n    function updateMaxVotesToken(uint256 ID, uint256 maxVotesToken) external;\\n\\n    function bribeFactory() external view returns (address);\\n\\n    function totalWeight() external view returns (uint256);\\n\\n    function delay() external view returns (uint256);\\n\\n    function lastDistribute() external view returns (uint256);\\n\\n    function lastVote(address user) external view returns (uint256);\\n\\n    function nextPoke(address user) external view returns (uint256);\\n\\n    function lockedTotalWeight() external view returns (uint256);\\n\\n    function lockedBalance() external view returns (uint256);\\n\\n    function locktime() external view returns (uint256);\\n\\n    function epoch() external view returns (uint256);\\n\\n    function lockedWeights(address user) external view returns (uint256);\\n\\n    function maxVotesToken(address user) external view returns (uint256);\\n\\n    function hasDistributed(address user) external view returns (bool);\\n\\n    function _tokens(uint256 tokenID) external view returns (address);\\n\\n    function gauges(address token) external view returns (address);\\n\\n    function gaugeStatus(address token) external view returns (bool);\\n\\n    function gaugeExists(address token) external view returns (bool);\\n\\n    function pokeDelay() external view returns (uint256);\\n\\n    function bribes(address gauge) external view returns (address);\\n\\n    function weights(address token) external view returns (uint256);\\n\\n    function votes(address user, address token) external view returns (uint256);\\n\\n    function tokenVote(address user, uint256 tokenID)\\n        external\\n        view\\n        returns (address);\\n\\n    function usedWeights(address user) external view returns (uint256);\\n}\\n\"},\"IProtocolGovernance.sol\":{\"content\":\"/**\\n * @title Interface Protocol Governance\\n * @dev IProtocolGovernance.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IProtocolGovernance {\\n    function setGovernance(address governance) external;\\n\\n    function acceptGovernance() external;\\n\\n    function setAdminAndVoter(address admin, address voter) external;\\n\\n    function setStableMiner(address stableMiner) external;\\n\\n    function updateBaseReferrals(\\n        address referralsContract,\\n        uint256 baseReferralFee,\\n        address mainRefFeeReceiver\\n    ) external;\\n\\n    function governance() external view returns (address);\\n\\n    function pendingGovernance() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function voter() external view returns (address);\\n\\n    function stableMiner() external view returns (address);\\n\\n    function baseReferralsContract() external view returns (address);\\n\\n    function baseReferralFee() external view returns (uint256);\\n\\n    function mainRefFeeReceiver() external view returns (address);\\n}\\n\"},\"IReferrals.sol\":{\"content\":\"/**\\n * @title Interface Referrals\\n * @dev IReferrals contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IReferrals {\\n    function getSponsor(address _account) external view returns (address);\\n\\n    function isMember(address _user) external view returns (bool);\\n\\n    function addMember(address _member, address _parent) external;\\n\\n    function membersList(uint256 _id) external view returns (address);\\n\\n    function getListReferrals(address _member)\\n        external\\n        view\\n        returns (address[] memory);\\n}\\n\"},\"Math.sol\":{\"content\":\"/**\\n * @title Math\\n * @dev Math.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n    }\\n}\\n\"},\"ProtocolGovernance.sol\":{\"content\":\"/**\\n * @title Protocol Governance\\n * @dev ProtocolGovernance.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./IProtocolGovernance.sol\\\";\\n\\ncontract ProtocolGovernance is IProtocolGovernance {\\n    /// @notice governance address for the governance contract\\n    address public governance;\\n    address public pendingGovernance;\\n    address public admin; //Admin address to manage gauges like add/deprecate/resurrect\\n    address public voter; //Admin address to manage voting\\n    address public stableMiner; // Address for stable miner\\n\\n    // Base fee variables\\n    address public baseReferralsContract;\\n    uint256 public baseReferralFee = 2000;\\n    address public mainRefFeeReceiver;\\n\\n    /**\\n     * @notice Allows governance to change governance (for future upgradability)\\n     * @param _governance new governance address to set\\n     */\\n    function setGovernance(address _governance) external {\\n        require(msg.sender == governance, \\\"setGovernance: !gov\\\");\\n        pendingGovernance = _governance;\\n\\n        emit SetGovernance(pendingGovernance);\\n    }\\n\\n    /**\\n     * @notice Allows pendingGovernance to accept their role as governance (protection pattern)\\n     */\\n    function acceptGovernance() external {\\n        require(\\n            msg.sender == pendingGovernance,\\n            \\\"acceptGovernance: !pendingGov\\\"\\n        );\\n        governance = pendingGovernance;\\n\\n        emit AcceptGovernance(governance);\\n    }\\n\\n    /**\\n     * @notice Allows governance to change governance (for future upgradability)\\n     * @param _admin new admin address to set\\n     * @param _voter new voter address to set\\n     */\\n    function setAdminAndVoter(address _admin, address _voter) external {\\n        require(msg.sender == governance, \\\"!gov\\\");\\n        admin = _admin;\\n        voter = _voter;\\n        emit SetAdminAndVoter(admin, voter);\\n    }\\n\\n    // Set Stable-miner\\n    function setStableMiner(address _stableMiner) external {\\n        require(msg.sender == governance || msg.sender == admin, \\\"!gov\\\");\\n        stableMiner = _stableMiner;\\n        emit SetStableMiner(stableMiner);\\n    }\\n\\n    // Update the base referral contract and base referral fee and the main referral fee receiver\\n    function updateBaseReferrals(\\n        address _referralsContract,\\n        uint256 _baseReferralFee,\\n        address _mainRefFeeReceiver\\n    ) public {\\n        require(\\n            (msg.sender == governance || msg.sender == admin),\\n            \\\"!gov or !admin\\\"\\n        );\\n        require((_baseReferralFee \\u003c= 10000), \\\"must be lower 10%\\\");\\n        baseReferralsContract = _referralsContract;\\n        baseReferralFee = _baseReferralFee;\\n        mainRefFeeReceiver = _mainRefFeeReceiver;\\n        emit UpdateBaseReferrals(\\n            baseReferralsContract,\\n            baseReferralFee,\\n            mainRefFeeReceiver\\n        );\\n    }\\n\\n    event UpdateBaseReferrals(\\n        address referralContract,\\n        uint256 referralFee,\\n        address refLevelPercent\\n    );\\n    event SetStableMiner(address stableMiner);\\n    event SetAdminAndVoter(address admin, address voter);\\n    event SetGovernance(address pendingGovernance);\\n    event AcceptGovernance(address governance);\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"/**\\n * @title Reentrancy Guard\\n * @dev ReentrancyGuard.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"/**\\n * @title Safe ERC20\\n * @dev SafeERC20.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gaugeFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimed0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimed1\",\"type\":\"uint256\"}],\"name\":\"ClaimVotingFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Kick\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RefRewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referralContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"refLevelPercent\",\"type\":\"uint256[]\"}],\"name\":\"UpdateReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelistedUser\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STABLE\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimVotingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"derivedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"derivedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"derivedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earnedRefs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getRewardForOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"getRewardForOwnerToOtherOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"kick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refLevelPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitelist\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referralFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_refLevelPercent\",\"type\":\"uint256[]\"}],\"name\":\"updateReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Gauge", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "950", "ConstructorArguments": "000000000000000000000000a3870fbbeb730ba99e4107051612af3465ca9f5e000000000000000000000000edbe30433528643d1ea4733e89d3ffa99bc304b2000000000000000000000000960dc34c0b1bc4ddbdd130693581180707c3115b", "EVMVersion": "Default", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://96c8ade021642c5bf7a2b07e6e70599fe1f9350b1ba23ca086cda670475548f2"}