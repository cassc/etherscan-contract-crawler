{"SourceCode": "pragma solidity 0.5.16;\r\n\r\n/*\r\n___________________________________________________________________\r\n  _      _                                        ______           \r\n  |  |  /          /                                /              \r\n--|-/|-/-----__---/----__----__---_--_----__-------/-------__------\r\n  |/ |/    /___) /   /   ' /   ) / /  ) /___)     /      /   )     \r\n__/__|____(___ _/___(___ _(___/_/_/__/_(___ _____/______(___/__o_o_\r\n\r\n\r\n=== 'CYCLIC TOKEN' Token contract with following features ===\r\n    => BEP20 Compliance\r\n    => SafeMath implementation  \r\n\r\n\r\n======================= Quick Stats =====================\r\n\r\n    => Name        : CYCLIC\r\n    => Symbol      : CYC\r\n    => Max supply  : 110000000\r\n    => Decimals    : 18\r\n\r\n============= Independant Audit of the code ==============\r\n\r\n    => Multiple Freelancers Auditors\r\n    => Community Audit by Bug Bounty program\r\n\r\n-------------------------------------------------------------------\r\n Copyright (c) 2022 onwards ZCN\r\n-------------------------------------------------------------------\r\n*/ \r\n\r\n\r\n//*******************************************************************//\r\n//------------------------ SafeMath Library -------------------------//\r\n//*******************************************************************//\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath mul failed');\r\n    return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, 'SafeMath sub failed');\r\n    return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath add failed');\r\n    return c;\r\n    }\r\n}\r\n\r\n//*******************************************************************//\r\n//------------------ Contract to Manage Ownership -------------------//\r\n//*******************************************************************//\r\n    \r\ncontract owned {\r\n    address payable public owner;\r\n    address payable internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //this flow is to prevent transferring ownership to wrong wallet by mistake\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n//****************************************************************************//\r\n//---------------------        MAIN CODE STARTS HERE     ---------------------//\r\n//****************************************************************************//\r\n\r\ncontract CYCLIC is owned {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    string constant private _name = \"CYCLIC\";\r\n    string constant private _symbol = \"CYC\";\r\n    uint256 constant private _decimals = 18;\r\n    uint256 private _totalSupply;                       \r\n    uint256 private maxSupply = 110000000 * (10**_decimals);\r\n    uint256 private maxBurnable = maxSupply.mul(70).div(100);\r\n    mapping (address => uint256) private _balanceOf;\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n    mapping (address => bool) public frozenAccount;\r\n    uint256 public _totalBurn;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    event FrozenAccounts(address target, bool frozen);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n    \r\n    address public minerContract;\r\n    address public dexContract;\r\n    bool public dexContractChangeLock;\r\n    \r\n    constructor() public{ }\r\n    \r\n    function name() public pure returns(string memory){\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public pure returns(string memory){\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public pure returns(uint256){\r\n        return _decimals;\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function maxsupply() public view returns (uint256) {\r\n        return maxSupply;\r\n    }\r\n    \r\n    function balanceOf(address user) public view returns(uint256){\r\n        return _balanceOf[user];\r\n    }\r\n    \r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowance[owner][spender];\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        \r\n        //checking conditions\r\n        require (_to != address(0));                      // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);    \r\n        \r\n        uint _sendValue;\r\n        uint burnableAmount = _value.mul(2).div(100);\r\n        if(_totalBurn.add(burnableAmount) <= maxBurnable ){\r\n             _sendValue = _value.sub(burnableAmount);\r\n             _totalBurn =_totalBurn.add(burnableAmount);\r\n             _totalSupply = _totalSupply.sub(burnableAmount);\r\n        }else{\r\n            _sendValue = _value;\r\n        }                   // Check if recipient is frozen\r\n        \r\n        // overflow and undeflow checked by SafeMath Library\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);    // Subtract from the sender\r\n        _balanceOf[_to] = _balanceOf[_to].add(_sendValue);  \r\n        // Add the same to the recipient\r\n        \r\n        // emit Transfer event\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //no need to check for input validations, as that is ruled by SafeMath\r\n        \r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //checking of allowance and token value is done by SafeMath\r\n        //we want to pre-approve system contracts so that it does not need to ask for approval calls\r\n        if(msg.sender != minerContract && msg.sender != dexContract){\r\n            _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\r\n        }\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n\r\n        /* AUDITOR NOTE:\r\n            Many dex and dapps pre-approve large amount of tokens to save gas for subsequent transaction. This is good use case.\r\n            On flip-side, some malicious dapp, may pre-approve large amount and then drain all token balance from user.\r\n            So following condition is kept in commented. It can be be kept that way or not based on client's consent.\r\n        */\r\n        //require(_balanceOf[msg.sender] >= _value, \"Balance does not have enough tokens\");\r\n        _allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function increase_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n    function decrease_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n    \r\n    function burn(uint256 _value) public returns (bool success) {\r\n\r\n        //checking of enough token balance is done by SafeMath\r\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\r\n        _totalSupply = _totalSupply.sub(_value); \r\n        _totalBurn =_totalBurn.add(_value);                    // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n    function repurches(address _user, uint256 _value) external returns(bool) {\r\n\r\n        require(msg.sender == minerContract, 'Invalid caller');\r\n        //checking of enough token balance is done by SafeMath\r\n        _balanceOf[_user] = _balanceOf[_user].sub(_value);  // Subtract from the sender\r\n        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\r\n        emit Burn(_user, _value);\r\n        emit Transfer(_user, address(0), _value);\r\n        return true;\r\n    }\r\n    \r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        emit  FrozenAccounts(target, freeze);\r\n    }\r\n    \r\n    function setMinerContract(address _minerContract) external onlyOwner returns(bool){\r\n        require(_minerContract != address(0), 'Invalid address');\r\n        minerContract = _minerContract;\r\n        return true;\r\n    }\r\n    \r\n    function mintTokens(address receipient, uint256 tokenAmount) external returns(bool){\r\n        require(msg.sender == minerContract, 'Invalid caller');\r\n        require(_totalSupply.add(tokenAmount) <= maxSupply, 'Max supply reached');\r\n        \r\n        _balanceOf[receipient] = _balanceOf[receipient].add(tokenAmount);\r\n        _totalSupply = _totalSupply.add(tokenAmount);\r\n        emit Transfer(address(0), receipient, tokenAmount);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function setDexContract(address _dexContract) external onlyOwner returns(bool){\r\n        require(_dexContract != address(0), 'Invalid address');\r\n        require(!dexContractChangeLock, 'Dex contrat can not be changed');\r\n        dexContractChangeLock=true;\r\n        dexContract = _dexContract;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    \r\n}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decrease_allowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexContractChangeLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increase_allowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxsupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minerContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"repurches\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexContract\",\"type\":\"address\"}],\"name\":\"setDexContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minerContract\",\"type\":\"address\"}],\"name\":\"setMinerContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CYCLIC", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e49d21660d3cb79c1eaaea73c669d29cbae73f8c8345f09e420b2816536db8a9"}