{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/LiquidityLock/LPLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract LPLocker {\\n    address public owner;\\n    uint256 public price;\\n    uint256 public penaltyfee;\\n\\n    struct holder {\\n        address holderAddress;\\n        mapping(address => Token) tokens;\\n    }\\n\\n    struct Token {\\n        uint256 balance;\\n        address tokenAddress;\\n        uint256 unlockTime;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only available to the contract owner.\\\");\\n        _;\\n    }\\n\\n    mapping(address => holder) public holders;\\n\\n    constructor(address _owner, uint256 _price) {\\n        owner = _owner;\\n        price = _price;\\n        penaltyfee = 10; // default value\\n    }\\n\\n    event Hold(\\n        address indexed holder,\\n        address token,\\n        uint256 amount,\\n        uint256 unlockTime\\n    );\\n\\n    event PanicWithdraw(\\n        address indexed holder,\\n        address token,\\n        uint256 amount,\\n        uint256 unlockTime\\n    );\\n\\n    event Withdrawal(address indexed holder, address token, uint256 amount);\\n\\n    event FeesClaimed();\\n\\n    event SetOwnerSuccess(address owner);\\n\\n    event SetPriceSuccess(uint256 _price);\\n\\n    event SetPenaltyFeeSuccess(uint256 _fee);\\n\\n    event OwnerWithdrawSuccess(uint256 amount);\\n\\n    function lpLock(\\n        address token,\\n        uint256 amount,\\n        uint256 unlockTime,\\n        address withdrawer\\n    ) public payable {\\n        require(msg.value >= price, \\\"Required price is low\\\");\\n\\n        holder storage holder0 = holders[withdrawer];\\n        holder0.holderAddress = withdrawer;\\n\\n        Token storage lockedToken = holders[withdrawer].tokens[token];\\n\\n        if (lockedToken.balance > 0) {\\n            lockedToken.balance += amount;\\n\\n            if (lockedToken.unlockTime < unlockTime) {\\n                lockedToken.unlockTime = unlockTime;\\n            }\\n        } else {\\n            holders[withdrawer].tokens[token] = Token(\\n                amount,\\n                token,\\n                unlockTime\\n            );\\n        }\\n\\n        IERC20(token).transferFrom(withdrawer, address(this), amount);\\n\\n        emit Hold(withdrawer, token, amount, unlockTime);\\n    }\\n\\n    function withdraw(address token) public {\\n        holder storage holder0 = holders[msg.sender];\\n\\n        require(\\n            msg.sender == holder0.holderAddress,\\n            \\\"Only available to the token owner.\\\"\\n        );\\n\\n        require(\\n            block.timestamp > holder0.tokens[token].unlockTime,\\n            \\\"Unlock time not reached yet.\\\"\\n        );\\n\\n        uint256 amount = holder0.tokens[token].balance;\\n\\n        holder0.tokens[token].balance = 0;\\n\\n        IERC20(token).transfer(msg.sender, amount);\\n\\n        emit Withdrawal(msg.sender, token, amount);\\n    }\\n\\n    function panicWithdraw(address token) public {\\n        holder storage holder0 = holders[msg.sender];\\n\\n        require(\\n            msg.sender == holder0.holderAddress,\\n            \\\"Only available to the token owner.\\\"\\n        );\\n\\n        uint256 feeAmount = (holder0.tokens[token].balance / 100) * penaltyfee;\\n        uint256 withdrawalAmount = holder0.tokens[token].balance - feeAmount;\\n\\n        holder0.tokens[token].balance = 0;\\n\\n        //Transfers fees to the contract administrator/owner\\n        // holders[address(owner)].tokens[token].balance = feeAmount;\\n\\n        // Transfers fees to the token owner\\n        IERC20(token).transfer(msg.sender, withdrawalAmount);\\n\\n        // Transfers fees to the contract administrator/owner\\n        IERC20(token).transfer(owner, feeAmount);\\n\\n        emit PanicWithdraw(\\n            msg.sender,\\n            token,\\n            withdrawalAmount,\\n            holder0.tokens[token].unlockTime\\n        );\\n    }\\n\\n    // function claimTokenListFees(address[] memory tokenList) public onlyOwner {\\n\\n    //     for (uint256 i = 0; i < tokenList.length; i++) {\\n\\n    //         uint256 amount = holders[owner].tokens[tokenList[i]].balance;\\n\\n    //         if (amount > 0) {\\n\\n    //             holders[owner].tokens[tokenList[i]].balance = 0;\\n\\n    //             IERC20(tokenList[i]).transfer(owner, amount);\\n    //         }\\n    //     }\\n    //     emit FeesClaimed();\\n    // }\\n\\n    // function claimTokenFees(address token) public onlyOwner {\\n\\n    //     uint256 amount = holders[owner].tokens[token].balance;\\n\\n    //     require(amount > 0, \\\"No fees available for claiming.\\\");\\n\\n    //     holders[owner].tokens[token].balance = 0;\\n\\n    //     IERC20(token).transfer(owner, amount);\\n\\n    //     emit FeesClaimed();\\n    // }\\n\\n    function OwnerWithdraw() public onlyOwner {\\n        uint256 amount = address(this).balance;\\n        address payable ownerAddress = payable(owner);\\n\\n        ownerAddress.transfer(amount);\\n\\n        emit OwnerWithdrawSuccess(amount);\\n    }\\n\\n    function getcurtime() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function GetBalance(address token) public view returns (uint256) {\\n        Token storage lockedToken = holders[msg.sender].tokens[token];\\n        return lockedToken.balance;\\n    }\\n\\n    function SetOwner(address contractowner) public onlyOwner {\\n        owner = contractowner;\\n        emit SetOwnerSuccess(owner);\\n    }\\n\\n    function SetPrice(uint256 _price) public onlyOwner {\\n        price = _price;\\n        emit SetPriceSuccess(price);\\n    }\\n\\n    // function GetPrice() public view returns (uint256) {\\n    //     return price;\\n    // }\\n\\n    function SetPenaltyFee(uint256 _penaltyfee) public onlyOwner {\\n        penaltyfee = _penaltyfee;\\n        emit SetPenaltyFeeSuccess(penaltyfee);\\n    }\\n\\n    // function GetPenaltyFee() public view returns (uint256) {\\n    //     return penaltyfee;\\n    // }\\n\\n    function GetUnlockTime(address token) public view returns (uint256) {\\n        Token storage lockedToken = holders[msg.sender].tokens[token];\\n        return lockedToken.unlockTime;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"Hold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OwnerWithdrawSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"PanicWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SetOwnerSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"SetPenaltyFeeSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"SetPriceSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"GetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"GetUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OwnerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractowner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_penaltyfee\",\"type\":\"uint256\"}],\"name\":\"SetPenaltyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"SetPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getcurtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"holderAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"}],\"name\":\"lpLock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"panicWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LPLocker", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "0000000000000000000000002b4a43497ef48c96588718ee7b6f854e7469ab05000000000000000000000000000000000000000000000000002386f26fc10000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}