{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.15;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(uint256 amount) external returns (uint256);\r\n\r\n    function destroy(uint256 amount) external returns (uint256);\r\n\r\n    function getPrice() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PublicReward {\r\n    constructor(address USDT, address HD) {\r\n        IERC20(USDT).approve(msg.sender, ~uint256(0));\r\n        IERC20(HD).approve(msg.sender, ~uint256(0));\r\n    }\r\n}\r\n\r\ncontract InviteContract is Ownable, ReentrancyGuard {\r\n    struct User {\r\n        Team team;\r\n        uint8 level; // \u7b49\u7ea7\r\n        uint64 latestLevelPowerTs; // \u6700\u65b0\u66f4\u65b0\u65f6\u95f4\r\n        uint64 latestLPPowerTs; // \u6700\u65b0\u66f4\u65b0\u65f6\u95f4\r\n        uint64 latestClaimTs; // \u6700\u65b0\u9886\u53d6\u65f6\u95f4\r\n        uint256 claimedHDReward; // \u5df2\u9886\u53d6HD\u5956\u52b1\r\n        uint256 claimedUSDTReward; // \u5df2\u9886\u53d6USDT\u5956\u52b1\r\n        uint256 bourtUSDT; // \u5df2\u8d2d\u4e70USDT\u6570\r\n        mapping(uint32 => uint256) teamReward; // \u56e2\u961fBH\u5956\u52b1\r\n        mapping(uint32 => uint256) lpPower; // lp\u7b97\u529b\r\n        mapping(uint32 => uint256) levelPower; // \u7b49\u7ea7\u7b97\u529b\r\n        mapping(uint32 => uint256) dailyTransaction; // \u6bcf\u65e5\u4ea4\u6613\u989d\r\n    }\r\n\r\n    struct Team {\r\n        address add;\r\n        address[] redirects; // \u76f4\u63a8\r\n        address left; // \u5de6\u8282\u70b9\r\n        address right; //  \u53f3\u8282\u70b9\r\n        address middle; //  \u4e2d\u95f4\u8282\u70b9\r\n        address top; // \u7236\u8282\u70b9\r\n        address leader; // \u9886\u5bfc\r\n        uint16 floor; // \u6240\u5728\u5c42\r\n        uint16 reachFloor; // \u6700\u4e0b\u9762\u6ee1\u5c42\u7684\u8be5\u5c42\u5c42\u6570\r\n        uint32 nextCount; // \u76f4\u63a5\u5b50\u8282\u70b9\u6570\r\n        uint32 childCount; // \u5b50\u8282\u70b9\u6570\r\n        uint32 index; // \u6240\u5728\u5c42\u7684\u5e8f\u53f7\r\n        uint32 latestIndex; // \u4e0a\u6b21\u6ed1\u843d\u6240\u5728\u7236\u8282\u70b9\u5e8f\u53f7\r\n        uint64 initTime; // \u521d\u59cb\u5316\u65f6\u95f4\r\n        mapping(uint32 => mapping(uint16 => uint32)) floorChildInfo; // \u4e0b\u9762\u6bcf\u5c42\u7684\u76f4\u63a5\u5b50\u8282\u4fe1\u606f\r\n    }\r\n\r\n    IERC20 USDT;\r\n    IERC20 HD;\r\n\r\n    PublicReward public publicReward;\r\n\r\n    ISwapRouter router;\r\n    IUniswapV2Pair pair;\r\n    mapping(uint256 => mapping(uint256 => address)) public floorUsers;\r\n    mapping(address => User) users;\r\n    mapping(bytes32 => bool) verifiedMessage;\r\n\r\n    // \u6bcf\u4e00\u7ea7\u6240\u9700\u8981\u7684\u6295\u8d44\u989d\r\n    uint256[] public levelPrice;\r\n\r\n    uint256[] public levelUSDTLimit;\r\n\r\n    uint256 latestdailyTotalLevelPowerTs;\r\n    uint256 latestdailyTotalLPPowerTs;\r\n    mapping(uint256 => uint256) public dailyTotalLPPower;\r\n    mapping(uint256 => uint256) public dailyTotalLevelPower;\r\n    mapping(uint256 => uint256) public dailyPublicUSDTReward;\r\n    mapping(uint256 => uint256) public dailyPublicHDReward;\r\n    mapping(uint256 => uint256) public dailyLPPowerValue;\r\n\r\n    mapping(uint256 => bool) public isPublicRewardEveryDay;\r\n    uint256 public publicRewardEveryDayCount;\r\n    uint256 public publicRewardEveryDayBase;\r\n    uint256 dailyTransactionLimit;\r\n    // must\r\n    address private delegateContract;\r\n    address private delegateUpgradContract;\r\n    address deadAddress;\r\n\r\n    function inviteProxy(address add, address _leader) public {\r\n        if (_leader == address(0)) {\r\n            _leader = floorUsers[1][1];\r\n        }\r\n        Team storage user = users[add].team;\r\n        Team storage leader = users[_leader].team;\r\n        require(leader.initTime > 0, \"leader not exist\");\r\n        require(user.initTime == 0, \"user exist\");\r\n\r\n        leader.redirects.push(add);\r\n        user.leader = _leader;\r\n        user.initTime = uint64(block.timestamp);\r\n        user.add = add;\r\n        if (leader.nextCount < 3) {\r\n            uint16 lmr;\r\n            ++leader.childCount;\r\n            if (leader.left == address(0)) {\r\n                leader.left = add;\r\n                user.index = (leader.index - 1) * 3 + 1;\r\n            } else if (leader.middle == address(0)) {\r\n                lmr = 1;\r\n                leader.middle = add;\r\n                user.index = (leader.index - 1) * 3 + 2;\r\n            } else {\r\n                leader.right = add;\r\n                lmr = 2;\r\n                user.index = (leader.index - 1) * 3 + 3;\r\n                leader.reachFloor = leader.floor + 1;\r\n            }\r\n            ++leader.nextCount;\r\n            user.top = _leader;\r\n            user.floor = leader.floor + 1;\r\n            floorUsers[user.floor][user.index] = add;\r\n            // leader.floorChildcount[user.floor] += 1;\r\n            leader.floorChildInfo[user.floor][0] += 1;\r\n            _updateTop(_leader, lmr, user.floor, leader.floor, 0);\r\n        } else {\r\n            uint32 startIndex = uint32(\r\n                (leader.index - 1) *\r\n                    (3 ** (leader.reachFloor - leader.floor)) +\r\n                    1\r\n            );\r\n            uint32 endIndex = uint32(\r\n                startIndex + 3 ** (leader.reachFloor - leader.floor) - 1\r\n            );\r\n            if (leader.latestIndex > startIndex) {\r\n                startIndex = leader.latestIndex;\r\n            }\r\n            if (leader.floorChildInfo[leader.reachFloor][0] > 0) {\r\n                _updateUser(add, _leader, startIndex, endIndex, 0);\r\n            } else if (leader.floorChildInfo[leader.reachFloor][1] > 0) {\r\n                _updateUser(add, _leader, startIndex, endIndex, 1);\r\n            } else {\r\n                _updateUser(add, _leader, startIndex, endIndex, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateTop(\r\n        address top,\r\n        uint16 lmr,\r\n        uint16 userFloor,\r\n        uint leaderFloor,\r\n        uint32 latestIndex\r\n    ) private {\r\n        uint i = 0;\r\n        Team storage topUser = users[top].team;\r\n        while (topUser.top != address(0)) {\r\n            topUser = users[topUser.top].team;\r\n            ++topUser.childCount;\r\n            // \u8d85\u8fc725\u5c42\u5c31\u6ca1\u610f\u4e49\u4e86   \u4e0d\u53ef\u80fd\u51fa\u73b0\u6ed1\u843d\u523025\u5c42\u7684\u60c5\u51b5\r\n            if (i < 25) {\r\n                topUser.floorChildInfo[userFloor][0] += 1;\r\n                topUser.floorChildInfo[userFloor - 1][lmr] -= 1;\r\n                topUser.floorChildInfo[userFloor - 1][lmr + 1] += 1;\r\n                if (latestIndex != 0 && topUser.floor >= leaderFloor) {\r\n                    topUser.latestIndex = latestIndex;\r\n                }\r\n                if (lmr == 2) {\r\n                    uint256 count = topUser.floorChildInfo[userFloor][0] +\r\n                        topUser.floorChildInfo[userFloor][1] +\r\n                        topUser.floorChildInfo[userFloor][2] +\r\n                        topUser.floorChildInfo[userFloor][3];\r\n                    if (count == 3 ** (userFloor - topUser.floor)) {\r\n                        topUser.reachFloor = userFloor;\r\n                        topUser.latestIndex = 1;\r\n                    }\r\n                }\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n\r\n    function _updateUser(\r\n        address _user,\r\n        address leader,\r\n        uint32 startIndex,\r\n        uint32 endIndex,\r\n        uint16 lmr\r\n    ) private {\r\n        Team storage user = users[_user].team;\r\n        for (uint32 i = startIndex; i <= endIndex; i++) {\r\n            if (\r\n                users[floorUsers[users[leader].team.reachFloor][i]]\r\n                    .team\r\n                    .nextCount == lmr\r\n            ) {\r\n                Team storage topUser = users[\r\n                    floorUsers[users[leader].team.reachFloor][i]\r\n                ].team;\r\n                user.top = topUser.add;\r\n                user.floor = users[leader].team.reachFloor + 1;\r\n                user.index = (i - 1) * 3 + 1 + lmr;\r\n                floorUsers[user.floor][user.index] = _user;\r\n                if (lmr == 0) {\r\n                    topUser.left = _user;\r\n                } else if (lmr == 1) {\r\n                    topUser.middle = _user;\r\n                } else {\r\n                    topUser.right = _user;\r\n                    topUser.reachFloor = user.floor;\r\n                }\r\n\r\n                ++topUser.nextCount;\r\n                ++topUser.childCount;\r\n                topUser.floorChildInfo[user.floor][0] += 1;\r\n                if (i == endIndex) {\r\n                    i = 1;\r\n                }\r\n                _updateTop(topUser.add, lmr, user.floor, topUser.floor, i);\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyLPPowerValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyPublicHDReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyPublicUSDTReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalLPPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyTotalLevelPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"floorUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"}],\"name\":\"inviteProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isPublicRewardEveryDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelUSDTLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicReward\",\"outputs\":[{\"internalType\":\"contract PublicReward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRewardEveryDayBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRewardEveryDayCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InviteContract", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://337f2ff58518d1c035b7b885a223decb9a97a61fcbb3c5d010cabc7a64469425"}