{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    function balanceOf(address owner) external view returns (uint balance);\r\n\r\n    function ownerOf(uint tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint tokenId) external;\r\n\r\n    function getApproved(uint tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ncontract star is IERC721 {\r\n\r\n    using Address for address;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint indexed tokenId);\r\n    event Approval(address indexed owner,address indexed approved,uint indexed tokenId);\r\n    event ApprovalForAll(address indexed owner,address indexed operator,bool approved);\r\n\r\n    string private _name  ;\r\n    string private _symbol ;\r\n\r\n\r\n    struct URI {\r\n        string name;\r\n        string symbol;\r\n    }\r\n\r\n    struct ADTOKEN {\r\n        uint256[] tokenId;\r\n    }\r\n\r\n    mapping(address=>bool)     internal myownered;\r\n    mapping(uint256 => string) private  gettokenURI;\r\n    mapping(uint256 => URI)    internal uris;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint => address) private _owners;\r\n\r\n    address private _owner;\r\n    // Mapping owner address to token count\r\n    mapping(address => uint) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint => address) private _tokenApprovals;\r\n    uint256 internal autoid;\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    string[] private url;\r\n\r\n    mapping(address => ADTOKEN) private ownertokens;\r\n    uint256 private _totalSupply;\r\n\r\n    address nftV2Addr;\r\n\r\n    constructor() {\r\n        autoid=0;\r\n        _owner=msg.sender;\r\n        _name = \"Spacedoge\";\r\n        _symbol = \"Spacedoge\";\r\n        url=[\"https://www.spacedogs.live/1.png\"];\r\n        // nftV2Addr = 0xf2d6b5093cC2f9C418C7323f147F92254b999999;//3\u9636\u5361\u724c\r\n        // nftV2Addr=0x1A30974E70dE38b9ca011aD392f0C899b2d1d377;\r\n        nftV2Addr=0xc30Af9B35f3B14f9287fB2049bD1E8d016ab7844;\r\n        // for(uint i = 0;i<1000;i++) {\r\n        //     mint(nftV2Addr);\r\n        // }\r\n    }\r\n    function supportsInterface(bytes4 interfaceId)\r\n    external\r\n    pure\r\n    override\r\n    returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function balanceOf(address owner) external view override returns (uint) {\r\n        require(owner != address(0), \"owner = zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function name() public view  returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view  returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function seturl(uint256 a,string memory b) public onlyOwner {\r\n        url[a] = b;\r\n    }\r\n\r\n    function ownerOf(uint tokenId) public view override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        // require(owner != address(0), \"token doesn't exist\");\r\n        return owner;\r\n    }\r\n    function totalSupply() public view  returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function isApprovedForAll(address owner, address operator)\r\n    external\r\n    view\r\n    override\r\n    returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) external override {\r\n        _operatorApprovals[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function getApproved(uint tokenId) external view override returns (address) {\r\n        require(_owners[tokenId] != address(0), \"token doesn't exist\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address to,\r\n        uint tokenId\r\n    ) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n\r\n    function approve(address to, uint tokenId) public override {\r\n        address owner = _owners[tokenId];\r\n        require(\r\n            msg.sender == owner || _operatorApprovals[owner][msg.sender],\r\n            \"not owner nor approved for all\"\r\n        );\r\n        _approve(owner, to, tokenId);\r\n    }\r\n\r\n    function approvenft(address to, uint tokenId) public {\r\n        approve(to,tokenId);\r\n    }\r\n\r\n\r\n    function _isApprovedOrOwner(\r\n        address owner,\r\n        address spender,\r\n        uint tokenId\r\n    ) private view returns (bool) {\r\n        return (spender == owner ||\r\n        _tokenApprovals[tokenId] == spender ||\r\n         _operatorApprovals[owner][spender]);\r\n    }\r\n\r\n    function _transfer(\r\n        address owner,\r\n        address from,\r\n        address to,\r\n        uint tokenId\r\n    ) private {\r\n        require(from == owner, \"not owner\");\r\n        if(to==address(0)){\r\n            _totalSupply=_totalSupply-1;\r\n        }\r\n        // require(to != address(0), \"transfer to the zero address\");\r\n\r\n        _approve(owner, address(0), tokenId);\r\n        ADTOKEN storage ownertoken = ownertokens[from];\r\n        uint256 tmp=999999999999999;\r\n        for(uint i=0;i<ownertoken.tokenId.length;i++){\r\n            if(tokenId==ownertoken.tokenId[i]){\r\n                tmp=i;\r\n                break;\r\n            }\r\n        }\r\n        if(tmp!=999999999999999){\r\n            require(tmp < ownertoken.tokenId.length, \"Invalid index\");\r\n            ownertoken.tokenId[tmp] = ownertoken.tokenId[ownertoken.tokenId.length - 1];\r\n            ownertoken.tokenId.pop();\r\n        }\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n        ownertokens[to].tokenId.push(tokenId);\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId\r\n    ) external override {\r\n        address owner = ownerOf(tokenId);\r\n        require(\r\n            _isApprovedOrOwner(owner, msg.sender, tokenId),\r\n            \"not owner nor approved\"\r\n        );\r\n        _transfer(owner, from, to, tokenId);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            return\r\n                IERC721Receiver(to).onERC721Received(\r\n                    msg.sender,\r\n                    from,\r\n                    tokenId,\r\n                    _data\r\n                ) == IERC721Receiver.onERC721Received.selector;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address owner,\r\n        address from,\r\n        address to,\r\n        uint tokenId,\r\n        bytes memory _data\r\n    ) private {\r\n        _transfer(owner, from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"not ERC721Receiver\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId,\r\n        bytes memory _data\r\n    ) public override {\r\n        address owner = ownerOf(tokenId);\r\n        require(\r\n            _isApprovedOrOwner(owner, msg.sender, tokenId),\r\n            \"not owner nor approved\"\r\n        );\r\n        _safeTransfer(owner, from, to, tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId\r\n    ) external override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function getownertoken(address to) public view returns (uint256[] memory){\r\n        ADTOKEN storage ownertoken = ownertokens[to];\r\n        return ownertoken.tokenId;\r\n    }\r\n\r\n    //\u4f5c\u54c1\u7684\u63cf\u8ff0\u4fe1\u606f\r\n    function tokeninfo(uint256 itokenId) public view returns (uint256,string memory){\r\n        return (itokenId,gettokenURI[itokenId]);\r\n    }\r\n\r\n\r\n    //\u4f5c\u54c1\u7684url\u5730\u5740\u4fe1\u606f\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory){\r\n        return gettokenURI[_tokenId];\r\n    }\r\n\r\n\r\n    function setownerad(address fromad) public onlyOwner{\r\n        myownered[fromad]=true;\r\n    }\r\n\r\n    function getownerad(address _ad) public  view returns(bool){\r\n        return myownered[_ad];\r\n    }\r\n\r\n\r\n    function mint(address to) public {\r\n        require(to != address(0), \"mint to zero address\");\r\n        // require(_owners[tokenId] == address(0), \"token already minted\");\r\n        require(myownered[msg.sender] || msg.sender==_owner,\"you cannot mint\");\r\n        _balances[to] += 1;\r\n        _owners[autoid] = to;\r\n        ADTOKEN storage ownertoken = ownertokens[to];\r\n        ownertoken.tokenId.push(autoid);\r\n        URI storage uri = uris[autoid];\r\n        uri.name = _name;\r\n        uri.symbol = _symbol;\r\n        gettokenURI[autoid] = url[0];\r\n        autoid+=1;\r\n        _totalSupply=_totalSupply+1;\r\n        emit Transfer(address(0), to, autoid-1);\r\n    }\r\n\r\n    function mintnft(uint256 amount) public {\r\n        require(myownered[msg.sender] || msg.sender==_owner,\"you cannot mint\");\r\n         for(uint i = 0;i<amount;i++) {\r\n            mint(nftV2Addr);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approvenft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ad\",\"type\":\"address\"}],\"name\":\"getownerad\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getownertoken\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintnft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromad\",\"type\":\"address\"}],\"name\":\"setownerad\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"b\",\"type\":\"string\"}],\"name\":\"seturl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itokenId\",\"type\":\"uint256\"}],\"name\":\"tokeninfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "star", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://54c79c7c37df980d6e7fdb55b0886abe54a65c31ffb77b59bff7f5607af9a04b"}