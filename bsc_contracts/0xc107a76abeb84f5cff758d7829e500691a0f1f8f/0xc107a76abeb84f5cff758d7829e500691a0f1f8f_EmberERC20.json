{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FreeErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.19;\\r\\n\\r\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\r\\nimport \\\"solmate/auth/Owned.sol\\\";\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract EmberERC20 is ERC20, Owned {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint public max_holding;\\r\\n    uint public max_transfer;\\r\\n    uint public sell_tax_threshold;\\r\\n    uint public buy_tax;\\r\\n    uint public sell_tax;\\r\\n    uint public in_swap = 1; // 1 is false, 2 is true\\r\\n    uint public is_trading_enabled = 1; // 1 is false, 2 is true\\r\\n\\r\\n    address public tax_receiver;\\r\\n\\r\\n    mapping(address => bool) public lps;\\r\\n    mapping(address => bool) public routers;\\r\\n    mapping(address => bool) public anti_whale_exceptions;\\r\\n    mapping(address => bool) public tax_exceptions;\\r\\n\\r\\n    address public weth;\\r\\n    address public uni_router;\\r\\n    address public uni_factory;\\r\\n\\r\\n    constructor(\\r\\n        string memory name,\\r\\n        string memory ticker,\\r\\n        uint8 decimals,\\r\\n        uint _totalSupply,\\r\\n        uint _max_holding,\\r\\n        uint _max_transfer,\\r\\n        uint _buy_tax,\\r\\n        uint _sell_tax,\\r\\n\\r\\n        address _uni_router,\\r\\n        address _weth\\r\\n    ) ERC20(name, ticker, decimals) Owned(msg.sender) {\\r\\n        require(_buy_tax <= 30, \\\"buy tax too high\\\");\\r\\n        require(_sell_tax <= 30, \\\"sell tax too high\\\");\\r\\n\\r\\n        if (_max_holding == 0) {\\r\\n            _max_holding = type(uint256).max;\\r\\n        }\\r\\n\\r\\n        if (_max_transfer == 0) {\\r\\n            _max_transfer = type(uint256).max;\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            _max_holding >= _totalSupply.div(100),\\r\\n            \\\"Max Holding Limit cannot be less than 1% of total supply\\\"\\r\\n        );\\r\\n        require(\\r\\n            _max_transfer >= _totalSupply.div(100),\\r\\n            \\\"Max Transfer Limit cannot be less than 1% of total supply\\\"\\r\\n        );\\r\\n\\r\\n        max_holding = _max_holding;\\r\\n        max_transfer = _max_transfer;\\r\\n\\r\\n        sell_tax_threshold = _totalSupply / 100;\\r\\n        buy_tax = _buy_tax;\\r\\n        sell_tax = _sell_tax;\\r\\n\\r\\n        anti_whale_exceptions[address(this)] = true;\\r\\n        anti_whale_exceptions[msg.sender] = true;\\r\\n\\r\\n        uni_router = _uni_router;\\r\\n        uni_factory = IUniswapV2Router01(uni_router).factory();\\r\\n        weth = _weth;\\r\\n\\r\\n        routers[_uni_router] = true;\\r\\n        allowance[address(this)][_uni_router] = type(uint256).max;\\r\\n        anti_whale_exceptions[_uni_router] = true;\\r\\n        allowance[msg.sender][address(this)] = type(uint256).max;\\r\\n\\r\\n        tax_receiver = owner;\\r\\n\\r\\n        _mint(msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        in_swap = 2;\\r\\n        _;\\r\\n        in_swap = 1;\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _transfer(msg.sender, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\r\\n\\r\\n        if (allowed != type(uint256).max) {\\r\\n            require(allowed >= amount, \\\"no allowance\\\");\\r\\n            allowance[from][msg.sender] = allowed - amount;\\r\\n        }\\r\\n\\r\\n        _transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint amount) private {\\r\\n        require(\\r\\n            is_trading_enabled == 2 || tx.origin == owner,\\r\\n            \\\"trading isnt live\\\"\\r\\n        );\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        uint256 taxAmount = 0;\\r\\n        if (from != owner && to != owner && tx.origin != owner) {\\r\\n            bool isSelling;\\r\\n            if (lps[from] && !routers[to] && !tax_exceptions[to]) {\\r\\n                require(\\r\\n                    max_transfer >= amount || anti_whale_exceptions[to],\\r\\n                    \\\"max tx limit\\\"\\r\\n                );\\r\\n\\r\\n                taxAmount = amount.mul(buy_tax).div(100);\\r\\n            }\\r\\n\\r\\n            if (lps[to] && from != address(this) && !tax_exceptions[from]) {\\r\\n                isSelling = true;\\r\\n                require(\\r\\n                    max_transfer >= amount || anti_whale_exceptions[from],\\r\\n                    \\\"max tx limit\\\"\\r\\n                );\\r\\n\\r\\n                taxAmount = amount.mul(sell_tax).div(100);\\r\\n            }\\r\\n\\r\\n            uint256 contractTokenBalance = balanceOf[address(this)];\\r\\n            if (\\r\\n                in_swap == 1 &&\\r\\n                isSelling &&\\r\\n                contractTokenBalance > sell_tax_threshold\\r\\n            ) {\\r\\n                swapTokensForEth(contractTokenBalance);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (taxAmount > 0) {\\r\\n            balanceOf[address(this)] = balanceOf[address(this)].add(taxAmount);\\r\\n            emit Transfer(from, address(this), taxAmount);\\r\\n        } else {\\r\\n            require(\\r\\n                max_transfer >= amount || anti_whale_exceptions[from],\\r\\n                \\\"max tx limit\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        balanceOf[from] = balanceOf[from].sub(amount);\\r\\n        balanceOf[to] = balanceOf[to].add(amount.sub(taxAmount));\\r\\n\\r\\n        require(\\r\\n            balanceOf[to] <= max_holding ||\\r\\n                anti_whale_exceptions[to] ||\\r\\n                tx.origin == owner,\\r\\n            \\\"max holding limit\\\"\\r\\n        );\\r\\n\\r\\n        emit Transfer(from, to, amount.sub(taxAmount));\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint amount) private lockTheSwap {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = weth;\\r\\n\\r\\n        try\\r\\n            IUniswapV2Router01(uni_router)\\r\\n                .swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n                    amount,\\r\\n                    0,\\r\\n                    path,\\r\\n                    tax_receiver,\\r\\n                    99999999999999999999\\r\\n                )\\r\\n        {\\r\\n            //\\r\\n        } catch {\\r\\n            // Ignore, to prevent calls from failing if owner sets invalid router\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isAntiWhaleEnabled() external view returns (bool) {\\r\\n        return max_holding != 0 || max_transfer != 0;\\r\\n    }\\r\\n\\r\\n    function setLimits(\\r\\n        uint _max_holding,\\r\\n        uint _max_transfer\\r\\n    ) external onlyOwner {\\r\\n        if (_max_holding == 0) {\\r\\n            _max_holding = type(uint256).max;\\r\\n        }\\r\\n\\r\\n        if (_max_transfer == 0) {\\r\\n            _max_transfer = type(uint256).max;\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            _max_holding >= totalSupply.div(100),\\r\\n            \\\"Max Holding Limit cannot be less than 1% of total supply\\\"\\r\\n        );\\r\\n        require(\\r\\n            _max_transfer >= totalSupply.div(100),\\r\\n            \\\"Max Transfer Limit cannot be less than 1% of total supply\\\"\\r\\n        );\\r\\n\\r\\n        max_holding = _max_holding;\\r\\n        max_transfer = _max_transfer;\\r\\n    }\\r\\n\\r\\n    function setAntiWhaleException(address user, bool val) external onlyOwner {\\r\\n        anti_whale_exceptions[user] = val;\\r\\n    }\\r\\n\\r\\n    function enableTrading() external onlyOwner {\\r\\n        is_trading_enabled = 2;\\r\\n    }\\r\\n\\r\\n    function setUniRouter(address newRouter, address newFactory) external onlyOwner {\\r\\n        uni_factory = newFactory;\\r\\n        uni_router = newRouter;\\r\\n        routers[newRouter] = true;\\r\\n        allowance[address(this)][newRouter] = type(uint256).max;\\r\\n        anti_whale_exceptions[newRouter] = true;\\r\\n    }\\r\\n\\r\\n    function setAmm(address lp) public onlyOwner {\\r\\n        lps[lp] = true;\\r\\n        anti_whale_exceptions[lp] = true;\\r\\n    }\\r\\n\\r\\n    function addRouter(address router) external onlyOwner {\\r\\n        routers[router] = true;\\r\\n        allowance[address(this)][router] = type(uint256).max;\\r\\n        anti_whale_exceptions[router] = true;\\r\\n    }\\r\\n\\r\\n    function setExcludeFromFee(address addy, bool val) external onlyOwner {\\r\\n        tax_exceptions[addy] = val;\\r\\n    }\\r\\n\\r\\n    function setSwapThreshold(uint newThreshold) external onlyOwner {\\r\\n        sell_tax_threshold = newThreshold;\\r\\n    }\\r\\n\\r\\n    function setTaxes(uint _buy_tax, uint _sell_tax) external onlyOwner {\\r\\n        require(_buy_tax <= 30, \\\"buy tax too high\\\");\\r\\n        require(_sell_tax <= 30, \\\"sell tax too high\\\");\\r\\n\\r\\n        buy_tax = _buy_tax;\\r\\n        sell_tax = _sell_tax;\\r\\n    }\\r\\n\\r\\n    function setTaxReceiver(address _tax_receiver) external onlyOwner {\\r\\n        tax_receiver = _tax_receiver;\\r\\n    }\\r\\n\\r\\n    function addLp(uint amount) external payable onlyOwner {\\r\\n        is_trading_enabled = 2;\\r\\n        _transfer(owner, address(this), amount);\\r\\n        uint balance = address(this).balance;\\r\\n        address pair = uniV2Pair();\\r\\n        IUniswapV2Router01(uni_router).addLiquidityETH{value: balance}(\\r\\n            address(this),\\r\\n            amount,\\r\\n            amount,\\r\\n            balance,\\r\\n            owner,\\r\\n            block.timestamp\\r\\n        );\\r\\n        setAmm(pair);\\r\\n        is_trading_enabled = 1;\\r\\n    }\\r\\n\\r\\n    function uniV2Pair() public view returns (address pair) {\\r\\n        pair = pairFor(weth, address(this));\\r\\n    }\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) internal view returns (address pair) {\\r\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\r\\n        pair = address(\\r\\n            uint160(\\r\\n                uint(\\r\\n                    keccak256(\\r\\n                        abi.encodePacked(\\r\\n                            hex\\\"ff\\\",\\r\\n                            uni_factory,\\r\\n                            keccak256(abi.encodePacked(token0, token1)),\\r\\n                            hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function sortTokens(\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) internal pure returns (address token0, address token1) {\\r\\n        (token0, token1) = tokenA < tokenB\\r\\n            ? (tokenA, tokenB)\\r\\n            : (tokenB, tokenA);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        (bool sent, ) = owner.call{value: address(this).balance}(\\\"\\\");\\r\\n        require(sent, \\\"Failed to send Ether\\\");\\r\\n    }\\r\\n\\r\\n    function version() public pure returns (uint) {\\r\\n        return 2;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\r\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\r\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\r\\nabstract contract ERC20 {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            METADATA STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              ERC20 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping(address => uint256) public balanceOf;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) public allowance;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            EIP-2612 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\r\\n\\r\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\r\\n\\r\\n    mapping(address => uint256) public nonces;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals\\r\\n    ) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n\\r\\n        INITIAL_CHAIN_ID = block.chainid;\\r\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               ERC20 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\r\\n        allowance[msg.sender][spender] = amount;\\r\\n\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\r\\n        balanceOf[msg.sender] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(msg.sender, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\r\\n\\r\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\r\\n\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             EIP-2612 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\r\\n\\r\\n        // Unchecked because the only math done is incrementing\\r\\n        // the owner's nonce which cannot realistically overflow.\\r\\n        unchecked {\\r\\n            address recoveredAddress = ecrecover(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"\\\\x19\\\\x01\\\",\\r\\n                        DOMAIN_SEPARATOR(),\\r\\n                        keccak256(\\r\\n                            abi.encode(\\r\\n                                keccak256(\\r\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\r\\n                                ),\\r\\n                                owner,\\r\\n                                spender,\\r\\n                                value,\\r\\n                                nonces[owner]++,\\r\\n                                deadline\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                v,\\r\\n                r,\\r\\n                s\\r\\n            );\\r\\n\\r\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\r\\n\\r\\n            allowance[recoveredAddress][spender] = value;\\r\\n        }\\r\\n\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\r\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n                    keccak256(bytes(name)),\\r\\n                    keccak256(\\\"1\\\"),\\r\\n                    block.chainid,\\r\\n                    address(this)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                        INTERNAL MINT/BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mint(address to, uint256 amount) internal virtual {\\r\\n        totalSupply += amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can't exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), to, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address from, uint256 amount) internal virtual {\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot underflow because a user's balance\\r\\n        // will never be larger than the total supply.\\r\\n        unchecked {\\r\\n            totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Simple single owner authorization mixin.\\r\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\r\\nabstract contract Owned {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            OWNERSHIP STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    modifier onlyOwner() virtual {\\r\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\r\\n\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             OWNERSHIP LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        owner = newOwner;\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"src/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.2;\\r\\n\\r\\n// https://uniswap.org/docs/v2/smart-contracts/router01/\\r\\n// https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/UniswapV2Router01.sol implementation\\r\\n// UniswapV2Router01 is deployed at 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a on the Ethereum mainnet, and the Ropsten, Rinkeby, G\u00f6rli, and Kovan testnets\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n      address tokenA,\\r\\n      address tokenB,\\r\\n      uint amountADesired,\\r\\n      uint amountBDesired,\\r\\n      uint amountAMin,\\r\\n      uint amountBMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n  function addLiquidityETH(\\r\\n      address token,\\r\\n      uint amountTokenDesired,\\r\\n      uint amountTokenMin,\\r\\n      uint amountETHMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n  function removeLiquidity(\\r\\n      address tokenA,\\r\\n      address tokenB,\\r\\n      uint liquidity,\\r\\n      uint amountAMin,\\r\\n      uint amountBMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n  function removeLiquidityETH(\\r\\n      address token,\\r\\n      uint liquidity,\\r\\n      uint amountTokenMin,\\r\\n      uint amountETHMin,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function removeLiquidityWithPermit(\\r\\n      address tokenA,\\r\\n      address tokenB,\\r\\n      uint liquidity,\\r\\n      uint amountAMin,\\r\\n      uint amountBMin,\\r\\n      address to,\\r\\n      uint deadline,\\r\\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETHWithPermit(\\r\\n      address token,\\r\\n      uint liquidity,\\r\\n      uint amountTokenMin,\\r\\n      uint amountETHMin,\\r\\n      address to,\\r\\n      uint deadline,\\r\\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function swapExactTokensForTokens(\\r\\n      uint amountIn,\\r\\n      uint amountOutMin,\\r\\n      address[] calldata path,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapTokensForExactTokens(\\r\\n      uint amountOut,\\r\\n      uint amountInMax,\\r\\n      address[] calldata path,\\r\\n      address to,\\r\\n      uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      payable\\r\\n      returns (uint[] memory amounts);\\r\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      returns (uint[] memory amounts);\\r\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      returns (uint[] memory amounts);\\r\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n      external\\r\\n      payable\\r\\n      returns (uint[] memory amounts);\\r\\n\\r\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"\r\n    },\r\n    \"src/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function allPairs(uint256) external view returns (address);\\r\\n\\r\\n    function allPairsLength() external view returns (uint256);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n    external\\r\\n    returns (address pair);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address, address) external view returns (address);\\r\\n\\r\\n    function setFeeTo(address _feeTo) external;\\r\\n\\r\\n    function setFeeToSetter(address _feeToSetter) external;\\r\\n}\"\r\n    },\r\n    \"src/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\r\\n    // uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b <= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    c = a + b;\\r\\n    assert(c >= a);\\r\\n    return c;\\r\\n  }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solady/=lib/solady/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ticker\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_holding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_transfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buy_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell_tax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_uni_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"addRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"anti_whale_exceptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"in_swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAntiWhaleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"is_trading_enabled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_holding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_transfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"routers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tax_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"setAmm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setAntiWhaleException\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max_holding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_transfer\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tax_receiver\",\"type\":\"address\"}],\"name\":\"setTaxReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buy_tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell_tax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newFactory\",\"type\":\"address\"}],\"name\":\"setUniRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tax_exceptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax_receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uni_factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uni_router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EmberERC20", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000065d855df3abc8fbeec0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c0000000000000000000000000000000000000000000000000000000000000004746573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045445535400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}