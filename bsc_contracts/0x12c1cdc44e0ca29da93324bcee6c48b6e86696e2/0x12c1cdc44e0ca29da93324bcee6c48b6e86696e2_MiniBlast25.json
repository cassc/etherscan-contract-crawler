{"SourceCode": "pragma solidity 0.6.0; \r\n\r\n//*******************************************************************************//\r\n//------------------ Contract to 100% secure p2p decentrlised mini blast25 -------------------//\r\n//*******************************************************************************//\r\ncontract owned\r\n{\r\n    address internal owner;\r\n    address internal newOwner;\r\n    address public signer;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        signer = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlySigner {\r\n        require(msg.sender == signer, 'caller must be signer');\r\n        _;\r\n    }\r\n\r\n\r\n    function changeSigner(address _signer) public onlyOwner {\r\n        signer = _signer;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         token interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function isUserExists(address userAddress) external returns (bool);\r\n }\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n\r\ncontract MiniBlast25 is owned {\r\n\r\n    // Replace below address with main token token\r\n    address public tokenAddress;\r\n    address public blastAddress;\r\n    address public rewadaddress;\r\n\r\n    uint public maxDownLimit = 2;\r\n    uint[4] public lastIDCount;\r\n    uint public joiningFee = 5 * (10 ** 18);    \r\n    uint public reJoinFee = 5 * (10 ** 18);\r\n    \r\n  \r\n    uint nextJoinWait = 1 days;\r\n    uint nextReJoinWait = 2 hours;\r\n    //uint nextJoinWait = 3 hours;\r\n    //uint nextReJoinWait = 1 hours;\r\n    \r\n\r\n    uint public royaltee;\r\n\r\n    mapping(address => uint) public ActiveDirect;\r\n    mapping(address => uint) public ActiveUnit;    \r\n    mapping(address => uint) public nextJoinPending;\r\n    mapping(address => uint) public lastJoinTime;\r\n    mapping(address => uint) public lastReJoinTime;\r\n    mapping(address => uint) public boostPending;\r\n    mapping(address => uint) public boosedCounter;\r\n   \r\n\r\n    uint[4] public nextMemberFillIndex;  \r\n    uint[4] public nextMemberFillBox;   \r\n\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parent;\r\n        uint referrerID;\r\n        uint directCount;\r\n    }\r\n\r\n    mapping(address => address[]) public directAddress;\r\n\r\n    \r\n\r\n    struct TotalInfo {\r\n        uint32 user;        \r\n        uint32 activeUnits;\r\n        uint32 pendingUnits;        \r\n        uint32 boostUnits;       \r\n    }\r\n\r\n    struct UserIncomeInfo {         \r\n        uint32 UnitIncome;\r\n        uint32 DirectIncome;\r\n        uint32 LevelIncome;\r\n    }\r\n\r\n    mapping(address => UserIncomeInfo) public UserIncomeInfos;\r\n    bool public doUS; // enable or disable update stat\r\n\r\n    TotalInfo public total;\r\n\r\n    mapping(address => userInfo[6]) public userInfos;\r\n    mapping(uint => address) public refAddressbyUID;\r\n    mapping(address=> uint) public uidByRefAddress;\r\n\r\n\r\n    //userID => _level => address\r\n    mapping(uint => mapping(uint => address)) public userAddressByID;\r\n  \r\n    function init() public onlyOwner returns(bool){\r\n        require(lastIDCount[0]==0, \"can be called only once\");\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n\r\n        temp.joined = true;\r\n        temp.id = 1;\r\n        temp.parent = 1;\r\n        temp.referrerID = 1;\r\n        //temp.directCount = 2 ** 100;\r\n        temp.directCount = 100;\r\n\r\n\r\n        userInfos[owner][0] = temp;\r\n        userAddressByID[1][0] = owner;\r\n\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), 173 * (10 ** 18));\r\n\r\n        for(uint i=1;i<4;i++)\r\n        {\r\n            lastIDCount[i]++;\r\n            userInfos[owner][i] = temp;\r\n            userAddressByID[1][i] = owner;\r\n        }\r\n\r\n    }\r\n\r\n    function setTokenNTigerAddress(address _tokenAddress, address _rewadaddress) public onlyOwner returns(bool)\r\n    {\r\n        tokenAddress = _tokenAddress;        \r\n        rewadaddress = _rewadaddress;\r\n        return true;\r\n    }\r\n\r\n\r\n    function toggleDoUS() public onlyOwner returns(bool)\r\n    {\r\n        doUS = !doUS;\r\n        return true;\r\n    }\r\n\r\n    event regUserEv(address _user,uint userid, address _referrer, uint refID,address parent, uint parentid,  uint timeNow, uint uid);\r\n    function regUser() public returns(bool) \r\n    {\r\n        address _ref = refAddressbyUID[1];\r\n\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID =1;\r\n        //require(tokenInterface(blastAddress).isUserExists(msg.sender), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        require(!userInfos[msg.sender][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), joiningFee);\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n\r\n        userInfos[_ref][0].directCount = userInfos[_ref][0].directCount + 1;\r\n\r\n        lastJoinTime[msg.sender] = now;\r\n        //nextJoinPending[msg.sender] = 2;\r\n        ActiveUnit[msg.sender]++;\r\n        ActiveDirect[_ref]++;\r\n        \r\n        directAddress[_ref].push(msg.sender);\r\n\r\n        uint uid = uint(now) % 10000000;\r\n\r\n        uidByRefAddress[msg.sender] = uid;\r\n        refAddressbyUID[uid] = msg.sender;\r\n\r\n        total.user++;        \r\n        total.activeUnits++;\r\n       // total.pendingUnits=total.pendingUnits+2;        \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n\r\n        //Direct+Level -- registration\r\n        payForLevel(_referrerID, 7);\r\n        \r\n        emit regUserEv(msg.sender,temp.id, _ref, _referrerID,userAddressByID[temp.parent][0], temp.parent, now, uid);\r\n        return true;\r\n    }\r\n\r\n    function regUser_top_byother( address _useraddress) public returns(bool) \r\n    {\r\n        address _ref = refAddressbyUID[1];\r\n\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID = 1;\r\n        //require(tokenInterface(tigerAddress).isUserExists(msg.sender), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        //require(_useraddress == tx.origin, \"contract can't call\");\r\n        require(!userInfos[_useraddress][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), joiningFee);\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[_useraddress][0] = temp;\r\n        userAddressByID[temp.id][0] = _useraddress;\r\n\r\n\r\n        userInfos[_ref][0].directCount = userInfos[_ref][0].directCount + 1;\r\n\r\n        lastJoinTime[_useraddress] = now;\r\n        //nextJoinPending[msg.sender] = 2;\r\n        ActiveUnit[_useraddress]++;\r\n        ActiveDirect[_ref]++;\r\n        \r\n        directAddress[_ref].push(_useraddress);\r\n\r\n       uint uid = uint(now) % 10000000;\r\n\r\n        uidByRefAddress[_useraddress] = uid;\r\n        refAddressbyUID[uid] = _useraddress;\r\n\r\n        total.user++;        \r\n        total.activeUnits++;\r\n       // total.pendingUnits=total.pendingUnits+2;        \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n\r\n        //Direct+Level -- registration\r\n       // payForLevel(_referrerID, 7);\r\n        \r\n        emit regUserEv(_useraddress,temp.id, _ref, _referrerID,userAddressByID[temp.parent][0], temp.parent, now, uid);\r\n        return true;\r\n    }\r\n\r\n    event enterMoreEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function BuyULP() public returns(bool){\r\n        require(lastReJoinTime[msg.sender] + nextReJoinWait <= now, \"please wait time little more\");\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), reJoinFee);\r\n\r\n       // require(userInfos[msg.sender][0].joined, \"Not Registration\");\r\n\r\n       // nextJoinPending[msg.sender]++;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n       // userInfos[userAddressByID[_referrerID][0]][0].directCount = userInfos[userAddressByID[_referrerID][0]][0].directCount + 1;\r\n\r\n        lastReJoinTime[msg.sender] = now;\r\n\r\n       \r\n        total.activeUnits++;\r\n        //total.pendingUnits=total.pendingUnits+1;\r\n            \r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    \r\n\r\n    event joinNextEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);    \r\n    function joinNext() public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n       // require(userInfos[msg.sender][0].joined, \"address used already\");\r\n        require(nextJoinPending[msg.sender] > 0, \"no pending next join\");\r\n        require(lastJoinTime[msg.sender] + nextJoinWait <= now, \"please wait time little more\");\r\n        nextJoinPending[msg.sender]--;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n\r\n        lastJoinTime[msg.sender] = now;\r\n        \r\n         \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits-1;       \r\n                \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n   \r\n    event buyLevelEv(uint level, address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function buyLevel(address _user, uint _level) internal returns(bool)\r\n    {\r\n        userInfo memory temp = userInfos[_user][0];\r\n\r\n        lastIDCount[_level]++;\r\n        temp.id = lastIDCount[_level];\r\n        if(_level == 0) temp.directCount = userInfos[_user][0].directCount;\r\n\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(_level);\r\n \r\n\r\n        userInfos[_user][_level] = temp;\r\n        userAddressByID[temp.id][_level] = _user;\r\n\r\n        address parentAddress = userAddressByID[temp.parent][_level];\r\n\r\n\r\n        if(pay)\r\n        {\r\n            if(_level < 3 ) payForLevel(temp.parent, _level); // for 0,1, only\r\n            if(_level < 3 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1, only\r\n            if(_level == 2 ) \r\n            {\r\n                nextJoinPending[msg.sender] = (nextJoinPending[msg.sender]+2);\r\n                total.pendingUnits = (total.pendingUnits+2);\r\n               \r\n            }           \r\n            if(_level == 3 ) \r\n            {\r\n                boostPending[parentAddress]++;\r\n               // nextJoinPending[parentAddress] = (nextJoinPending[parentAddress]+2);\r\n            }\r\n\r\n        }\r\n        emit buyLevelEv(_level, msg.sender, temp.id, userAddressByID[temp.parent][0], temp.parent, now);\r\n        return true;\r\n    }\r\n\r\n    event boostEv(address user, uint boostCount, uint remainingBoost, uint timeNow);\r\n    function boost() public returns(bool)\r\n    {\r\n        require(boostPending[msg.sender] > 0 , \"not eligible\" );\r\n        boosedCounter[msg.sender]++;\r\n        payForLevel(userInfos[msg.sender][2].id, 3);\r\n       // buyLevel(msg.sender, 0); // 1 id in level 1st level\r\n       // buyLevel(msg.sender, 2); // 1 id in level 3rd level\r\n        //nextJoinPending[msg.sender]++; // 1 id after 48 hr in 1st level \r\n        nextJoinPending[msg.sender] = (nextJoinPending[msg.sender]+3);\r\n        \r\n        //ActiveUnit[msg.sender]++;\r\n        boostPending[msg.sender]--;\r\n\r\n        \r\n        //total.activeUnits++;       \r\n        total.boostUnits++;\r\n        total.pendingUnits = (total.pendingUnits+3);\r\n        emit boostEv(msg.sender,boosedCounter[msg.sender],boostPending[msg.sender] , now);       \r\n        return true;\r\n    }\r\n \r\n\r\n    event payForLevelEv(uint level, uint parentID,address paidTo, uint amount, bool direct, uint timeNow);\r\n\r\n    function payForLevel(uint _pID, uint _level) internal returns (bool){\r\n        address _user = userAddressByID[_pID][_level];\r\n        if(_level == 0) \r\n        {\r\n            // tokenInterface(tokenAddress).transfer(_user,2 * (10 ** 18));\r\n            // US(_user, 0, 2);\r\n            // emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), false, now);\r\n\r\n            // _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            // tokenInterface(tokenAddress).transfer(_user,1 * (10 ** 18));\r\n            // US(_user, 1, 1);\r\n            // emit payForLevelEv(_level,_pID,_user, 1 * (10 ** 18), true, now);\r\n\r\n            // _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            // tokenInterface(tokenAddress).transfer(_user,1 * (10 ** 18));\r\n            // US(_user, 2, 1);\r\n            // emit payForLevelEv(_level,_pID,_user, 1 * (10 ** 18), true, now);\r\n\r\n            // royaltee += 1 * (10 ** 18) ;\r\n        }\r\n        else if(_level == 1)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 2 * (10 ** 18));\r\n            US(_user, 0, 2);\r\n            emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), false, now);\r\n\r\n           tokenInterface(tokenAddress).transfer(rewadaddress,1 * (10 ** 18));\r\n\r\n           \r\n        }\r\n        else if(_level == 2)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 3 * (10 ** 18));\r\n            US(_user, 0, 3);\r\n            emit payForLevelEv(_level,_pID,_user, 3 * (10 ** 18), false, now);\r\n\r\n             tokenInterface(tokenAddress).transfer(rewadaddress,1 * (10 ** 18));\r\n        }\r\n        else if(_level == 3)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 25 * (10 ** 18));\r\n            US(_user, 0, 25);\r\n            emit payForLevelEv(_level,_pID,_user, 25 * (10 ** 18), false, now);\r\n\r\n           tokenInterface(tokenAddress).transfer(rewadaddress,2 * (10 ** 18));\r\n                \r\n        }  \r\n                \r\n        return true;\r\n\r\n    }\r\n\r\n    function US(address _user,uint8 _type, uint32 _amount) internal \r\n    {\r\n        if (doUS)\r\n        {\r\n            if(_type == 0 ) UserIncomeInfos[_user].UnitIncome = UserIncomeInfos[_user].UnitIncome + _amount ;\r\n            else if (_type == 1 ) UserIncomeInfos[_user].DirectIncome =  UserIncomeInfos[_user].DirectIncome + _amount;\r\n            else if (_type == 2 ) UserIncomeInfos[_user].LevelIncome =  UserIncomeInfos[_user].LevelIncome + _amount;\r\n        }\r\n    }\r\n\r\n  \r\n\r\n    //function findFreeReferrer(uint _level) internal returns(uint,bool) {\r\n    function findFreeReferrer(uint _level) public returns(uint,bool) {\r\n\r\n        bool pay;\r\n\r\n        uint currentID = nextMemberFillIndex[_level];\r\n\r\n        if(nextMemberFillBox[_level] == 0)\r\n        {\r\n            nextMemberFillBox[_level] = 1;\r\n        }   \r\n        else\r\n        {\r\n            nextMemberFillIndex[_level]++;\r\n            nextMemberFillBox[_level] = 0;\r\n            pay = true;\r\n        }\r\n        return (currentID+1,pay);\r\n    }\r\n\r\n    \r\n   \r\n    //a = join, b = ulp join\r\n    function timeRemains(address _user) public view returns(uint, uint)\r\n    {\r\n        uint a; // UNIT TIME\r\n        uint b; // ULP TIME\r\n        \r\n        if( nextJoinPending[_user] == 0 || lastJoinTime[_user] + nextJoinWait < now) \r\n        {\r\n            a = 0;\r\n        }\r\n        else\r\n        {\r\n            a = (lastJoinTime[_user] + nextJoinWait) - now;\r\n        }\r\n               \r\n        if(lastReJoinTime[_user] + nextReJoinWait < now) \r\n        {\r\n            b = 0;\r\n        }\r\n        else\r\n        {\r\n            b = (lastReJoinTime[_user] + nextReJoinWait) - now ;\r\n        }\r\n\r\n         \r\n        return (a,b);\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBoost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"boostEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"buyLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"enterMoreEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"joinNextEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"payForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"}],\"name\":\"regUserEv\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveDirect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyULP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserIncomeInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"UnitIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"DirectIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"LevelIncome\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blastAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boosedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boost\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinNext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joiningFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextJoinPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reJoinFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refAddressbyUID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"regUser_top_byother\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewadaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewadaddress\",\"type\":\"address\"}],\"name\":\"setTokenNTigerAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeRemains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDoUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"user\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"activeUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pendingUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uidByRefAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MiniBlast25", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6aac10cbc6a46bc4d0f396acaffea66e5916df809a983e29b5ffeecf11db14e9"}