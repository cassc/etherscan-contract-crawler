{"SourceCode": "{\"contract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./interface.sol\\\";\\n            \\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;}\\n\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;}}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;}\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;}}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    constructor() {\\n        _transferOwnership(_msgSender());}\\n    function owner() public view virtual returns (address) {\\n        return _owner;}\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;}\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));}\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);}\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);}}\\n\"},\"interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\ninterface IERC721A {\\n    error ApprovalCallerNotOwnerNorApproved();\\n    error ApprovalQueryForNonexistentToken();\\n    error ApproveToCaller();\\n    error ApprovalToCurrentOwner();\\n    error BalanceQueryForZeroAddress();\\n    error MintToZeroAddress();\\n    error MintZeroQuantity();\\n    error OwnerQueryForNonexistentToken();\\n    error TransferCallerNotOwnerNorApproved();\\n    error TransferFromIncorrectOwner();\\n    error TransferToNonERC721ReceiverImplementer();\\n    error TransferToZeroAddress();\\n    error URIQueryForNonexistentToken();\\n\\n    struct TokenOwnership {\\n        address addr;\\n        uint64 startTimestamp;\\n        bool burned;}\\n\\n    function totalSupply() external view returns (uint256);\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);}\\n\\ninterface ERC721A__IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);}\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);}\\n\"},\"library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;}\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;}\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a / b;}\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;}\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;}}\\n\"},\"stake.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.18;\\n\\nimport \\\"./contract.sol\\\";\\nimport \\\"./library.sol\\\";\\n\\ncontract NFTStaking is ERC721A__IERC721Receiver, Ownable, ReentrancyGuard {\\n    using SafeMath for uint256;\\n\\n    struct boostInfo{\\n        bool boosted;\\n        uint256 boostId;}\\n\\n    struct stakingInfo {\\n        bool staked;\\n        uint256 tokenValue;\\n        uint256 valueWithdrawn;\\n        uint256 stakingTimestamp;\\n        bool boosted;\\n        uint256 stakingBoostTimestamp;}\\n    \\n    mapping(address =\\u003e boostInfo) public boostData;\\n    mapping(address =\\u003e mapping(address =\\u003e mapping(uint256 =\\u003e stakingInfo))) public stakingData;\\n    mapping(address =\\u003e address[]) public addedContracts;\\n\\n    mapping(address =\\u003e mapping (address =\\u003e uint256[])) public ownedTokens;\\n\\n    //Wallet for tax\\n\\n    address public devWallet;\\n\\n    function setAddress(address _devWallet) external onlyOwner {\\n        devWallet = _devWallet;}\\n\\n    //Moderator\\n\\n    address public moderator;\\n\\n    modifier onlyModerator() {\\n        require(msg.sender == owner() || msg.sender == moderator, \\\"Not owner or moderator!\\\");\\n        _;}\\n\\n    function setModerator(address _moderator) external onlyOwner {\\n        moderator = _moderator;}\\n\\n    //Contract Allowance\\n\\n    address[] public allowedContracts;\\n\\n    modifier onlyAllowedContracts() {\\n        bool isAllowed = false;\\n        for (uint i = 0; i \\u003c allowedContracts.length; i++) {\\n            if (msg.sender == allowedContracts[i]) {\\n                isAllowed = true;\\n                break;}}\\n        require(isAllowed, \\\"Caller address not allowed!\\\");\\n        _;}\\n\\n    function addAllowedContract(address _contractAddress) public onlyOwner {\\n        allowedContracts.push(_contractAddress);}\\n\\n    function removeAllowedContract(address _contractAddress) public onlyOwner {\\n        for (uint256 i = 0; i \\u003c allowedContracts.length; i++) {\\n            if (allowedContracts[i] == _contractAddress) {\\n                allowedContracts[i] = allowedContracts[allowedContracts.length.sub(1)];\\n                allowedContracts.pop();\\n                break;}}}\\n\\n    function checkContractAllowed(address _contractAddress) public view returns (bool) {\\n        bool isAllowed = false;\\n        for (uint256 i = 0; i \\u003c allowedContracts.length; i++) {\\n            if (allowedContracts[i] == _contractAddress) {\\n                isAllowed = true;\\n                break;}}\\n        return isAllowed;}\\n\\n    function isContractAdded(address _user, address _contractAddress) internal view returns(bool) {\\n        address[] memory contracts = addedContracts[_user];\\n        for(uint i = 0; i \\u003c contracts.length; i++) {\\n            if(contracts[i] == _contractAddress) {\\n                return true;}}\\n        return false;}\\n\\n    function isTokenIdAdded(address _user, address _contractAddress, uint256 _tokenId) internal view returns(bool) {\\n        uint256[] memory tokens = ownedTokens[_user][_contractAddress];\\n        for(uint i = 0; i \\u003c tokens.length; i++) {\\n            if(tokens[i] == _tokenId) {\\n                return true;}}\\n        return false;}\\n\\n    //Staking \\n    uint256 public totalValueLocked;\\n    uint256 public totalNFTLocked;\\n\\n    function stakeNFT(address _caller, address _collection, uint256 tokenId, uint256 _nominalValue) external onlyAllowedContracts returns (bool) {\\n        require(addToken(_caller, _collection, tokenId, _nominalValue), \\\"ID not added\\\");\\n        return true;}\\n\\n    function addToken(address _caller, address _contractAddress, uint256 _tokenId, uint256 _value) internal returns (bool) {\\n        require(!isTokenIdAdded(_caller, _contractAddress, _tokenId), \\\"TokenId already added for this contract.\\\");\\n        if(!isContractAdded(_caller, _contractAddress)) {\\n            addedContracts[_caller].push(_contractAddress);}\\n        stakingData[_caller][_contractAddress][_tokenId].staked = true;\\n        stakingData[_caller][_contractAddress][_tokenId].tokenValue = _value;\\n        stakingData[_caller][_contractAddress][_tokenId].stakingTimestamp = block.timestamp;\\n        ownedTokens[_caller][_contractAddress].push(_tokenId);\\n        totalValueLocked = totalValueLocked.add(_value);\\n        totalNFTLocked = totalNFTLocked.add(1);\\n        return true;}\\n        \\n    function getValueWithdrable(address _caller, address _collection, uint256 _tokenId) public view returns (uint256) {\\n        //da aggiungere except\\n        uint256 _nominalValue = stakingData[_caller][_collection][_tokenId].tokenValue;\\n        uint256 _halfNominalValue = _nominalValue.mul(50).div(100);\\n        uint256 _valueWhitdrawn = stakingData[_caller][_collection][_tokenId].valueWithdrawn;\\n        uint256 _amount = 0;\\n        if(_valueWhitdrawn \\u003e _halfNominalValue){\\n            if(_valueWhitdrawn \\u003e _nominalValue){\\n                _amount = 0;}\\n            else{\\n                _amount = _nominalValue.sub(_valueWhitdrawn);}}\\n        else{\\n            _amount = _halfNominalValue;}\\n        return _amount;}\\n\\n    function unstakeNFT(address _collection, uint256 _tokenId) external {\\n        IERC721A _nftCollection = IERC721A(_collection);\\n        require(stakingData[msg.sender][_collection][_tokenId].staked, \\\"Token not staked\\\");\\n        uint256 amountWhitdrable = getValueWithdrable(msg.sender, _collection, _tokenId);\\n        require(amountWhitdrable \\u003e 0, \\\"No tokens to claim!\\\");\\n        require(paymentToken.transfer(msg.sender, amountWhitdrable.mul(90).div(100)) \\u0026\\u0026 paymentToken.transfer(devWallet, amountWhitdrable.mul(10).div(100)) , \\\"Token transfer failed!\\\");\\n        require(removeToken(_collection, _tokenId), \\\"ID not removed\\\");\\n        _nftCollection.safeTransferFrom(address(this), msg.sender, _tokenId);}\\n\\n    function removeToken(address _contractAddress, uint256 _tokenId) internal returns (bool) {\\n        require(stakingData[msg.sender][_contractAddress][_tokenId].staked, \\\"Token not staked\\\");\\n        totalValueLocked = totalValueLocked.sub(stakingData[msg.sender][_contractAddress][_tokenId].tokenValue);\\n        totalNFTLocked = totalNFTLocked.sub(1);\\n        stakingData[msg.sender][_contractAddress][_tokenId].staked = false;\\n        stakingData[msg.sender][_contractAddress][_tokenId].tokenValue = 0;\\n        stakingData[msg.sender][_contractAddress][_tokenId].stakingTimestamp = 0;\\n        \\n        return true;}\\n\\n    //NOS\\n    IERC721A public nosNFT;\\n\\n    function checkBoost(address _caller) public view returns (bool, uint256) {\\n        return (boostData[_caller].boosted, boostData[_caller].boostId);}\\n\\n    function setNosNFT(address _nosNFT) external onlyOwner {\\n        nosNFT = IERC721A(_nosNFT);}\\n\\n    function activeBoost(uint256 _tokenId) external {\\n        require(!boostData[msg.sender].boosted, \\\"Boost already staked\\\");\\n        nosNFT.safeTransferFrom(msg.sender, address(this), _tokenId);\\n        boostData[msg.sender].boosted = true;\\n        boostData[msg.sender].boostId = _tokenId;\\n        address _contractAddress;\\n        for (uint i = 0; i \\u003c allowedContracts.length; i++) {\\n            _contractAddress = allowedContracts[i];\\n            uint256[] memory tokens = ownedTokens[msg.sender][_contractAddress];\\n            for(uint e = 0; e \\u003c tokens.length; e++) {\\n                stakingData[msg.sender][_contractAddress][tokens[e]].boosted = true;\\n                stakingData[msg.sender][_contractAddress][tokens[e]].stakingBoostTimestamp = block.timestamp;}}}\\n\\n    function disactiveBoost(uint256 _tokenId) external {\\n        require(boostData[msg.sender].boosted, \\\"Boost not staked\\\");\\n        nosNFT.safeTransferFrom(address(this), msg.sender, _tokenId);\\n        boostData[msg.sender].boosted = false;\\n        boostData[msg.sender].boostId = 0;\\n        address _contractAddress;\\n        for (uint i = 0; i \\u003c allowedContracts.length; i++) {\\n            _contractAddress = allowedContracts[i];\\n            uint256[] memory tokens = ownedTokens[msg.sender][_contractAddress];\\n            for(uint e = 0; e \\u003c tokens.length; e++) {\\n                stakingData[msg.sender][_contractAddress][tokens[e]].boosted = false;\\n                stakingData[msg.sender][_contractAddress][tokens[e]].stakingBoostTimestamp = 0;}}}\\n    \\n    function updateBoost() external {\\n        require(boostData[msg.sender].boosted, \\\"Boost not staked\\\");\\n        address _contractAddress;\\n        for (uint i = 0; i \\u003c allowedContracts.length; i++) {\\n            _contractAddress = allowedContracts[i];\\n            uint256[] memory tokens = ownedTokens[msg.sender][_contractAddress];\\n            for(uint e = 0; e \\u003c tokens.length; e++) {\\n                if(stakingData[msg.sender][_contractAddress][tokens[e]].stakingBoostTimestamp == 0){\\n                    stakingData[msg.sender][_contractAddress][tokens[e]].boosted = true;\\n                    stakingData[msg.sender][_contractAddress][tokens[e]].stakingBoostTimestamp = block.timestamp;}}}}\\n\\n    function getOwnedTokens(address _wallet, address _contractAddress) public view returns (uint256[] memory) {\\n        return ownedTokens[_wallet][_contractAddress];}\\n\\n    IERC20 public paymentToken;\\n\\n    function setPaymentToken(address _paymentToken) external onlyOwner {\\n        paymentToken = IERC20(_paymentToken);}\\n\\n    //Claim \\u0026 Compound Rewards\\n\\n    uint256 public rewardsPerMinutes = 1736;\\n    uint256 public additionalRewards = 694;\\n    uint256 public divisor = 100000000;\\n\\n    function compound(address _contractAddress, uint256 _tokenId) external nonReentrant returns (bool) {\\n        require(stakingData[msg.sender][_contractAddress][_tokenId].staked, \\\"NFT not staked\\\");\\n        uint256 _nominalValue = stakingData[msg.sender][_contractAddress][_tokenId].tokenValue;\\n        uint256 nftStaked = stakingData[msg.sender][_contractAddress][_tokenId].stakingTimestamp;\\n        uint256 _valueCompund = getAccumulation(_nominalValue, nftStaked, rewardsPerMinutes);\\n        bool nosStaked = stakingData[msg.sender][_contractAddress][_tokenId].boosted;\\n        uint256 nosTimestamp = stakingData[msg.sender][_contractAddress][_tokenId].stakingBoostTimestamp;\\n        uint256 _valueCompundByNos = 0;\\n        if(nosStaked == true){\\n            _valueCompundByNos = getAccumulation(_nominalValue, nosTimestamp, additionalRewards);}\\n        totalValueLocked = (totalValueLocked.add(_valueCompund)).add(_valueCompundByNos);\\n        stakingData[msg.sender][_contractAddress][_tokenId].tokenValue = _nominalValue + _valueCompund + _valueCompundByNos;\\n        stakingData[msg.sender][_contractAddress][_tokenId].stakingTimestamp = block.timestamp;\\n        if(nosStaked == true){\\n            stakingData[msg.sender][_contractAddress][_tokenId].stakingBoostTimestamp = block.timestamp;}\\n        return true;}\\n\\n    function getMinuteElapsed(uint256 _stakingTimestamp) internal view returns (uint256) {\\n        uint256 _minutesElapsed = (block.timestamp.sub(_stakingTimestamp)).div(60);\\n        return _minutesElapsed;}\\n\\n    function getAccumulatedPercentage(uint256 _stakingTimestamp, uint256 _rewardsPerMinutes) internal view returns (uint256) {\\n        uint256 _minutesElapsed = getMinuteElapsed(_stakingTimestamp);\\n        uint256 _accumulatedPercentage = _minutesElapsed.mul(_rewardsPerMinutes);\\n        return _accumulatedPercentage;}\\n\\n    function getAccumulation(uint256 _value, uint256 _stakingTimestamp, uint256 _rewardsPerMinutes) internal view returns (uint256) {\\n        uint256 _accumulatedPercentage = getAccumulatedPercentage(_stakingTimestamp, _rewardsPerMinutes);\\n        uint256 _accumulation = _value.mul(_accumulatedPercentage).div(divisor);\\n        return _accumulation;}\\n\\n    function getTotalAccumulation(address _caller, address _contractAddress, uint256 _tokenId) public view returns (uint256) {\\n        require(stakingData[_caller][_contractAddress][_tokenId].staked, \\\"NFT not staked\\\");\\n        uint256 _value = getAccumulation(stakingData[_caller][_contractAddress][_tokenId].tokenValue, stakingData[_caller][_contractAddress][_tokenId].stakingTimestamp, rewardsPerMinutes);\\n        if(stakingData[_caller][_contractAddress][_tokenId].boosted == true){\\n            _value = _value.add(getAccumulation(stakingData[_caller][_contractAddress][_tokenId].tokenValue, stakingData[_caller][_contractAddress][_tokenId].stakingBoostTimestamp, additionalRewards));}        \\n        return _value;}\\n\\n    function getAllInformation(address _caller, address _contractAddress, uint256 _tokenId) public view returns (uint256, bool, bool, uint256, uint256, uint256) {\\n        bool _staked = stakingData[_caller][_contractAddress][_tokenId].staked;\\n        bool _boosted = stakingData[_caller][_contractAddress][_tokenId].boosted;\\n        uint256 _tokenValue = stakingData[_caller][_contractAddress][_tokenId].tokenValue;\\n        uint256 _valueWhitdrable = getValueWithdrable(_caller, _contractAddress, _tokenId);\\n        uint256 _accumulation = getTotalAccumulation(_caller, _contractAddress, _tokenId);\\n        return(_tokenId, _staked, _boosted, _tokenValue, _valueWhitdrable, _accumulation);}\\n\\n    function claimRewards(address _contractAddress, uint256 _tokenId) external nonReentrant {\\n        uint256 _valueWhitdrawn = stakingData[msg.sender][_contractAddress][_tokenId].valueWithdrawn;\\n        uint256 _amount = getTotalAccumulation(msg.sender, _contractAddress, _tokenId);\\n        require(_amount \\u003e 0, \\\"No tokens to claim!\\\");\\n        require(paymentToken.transfer(msg.sender, _amount.mul(90).div(100)) \\u0026\\u0026 paymentToken.transfer(devWallet, _amount.mul(10).div(100)) , \\\"Token transfer failed!\\\");\\n        stakingData[msg.sender][_contractAddress][_tokenId].valueWithdrawn = _valueWhitdrawn.add(_amount);\\n        stakingData[msg.sender][_contractAddress][_tokenId].stakingTimestamp = block.timestamp;\\n        if(stakingData[msg.sender][_contractAddress][_tokenId].boosted == true){\\n            stakingData[msg.sender][_contractAddress][_tokenId].stakingBoostTimestamp = block.timestamp;}}\\n\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external override returns (bytes4) {\\n            return ERC721A__IERC721Receiver.onERC721Received.selector;}}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"activeBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"addAllowedContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"additionalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"boosted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"boostId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"checkBoost\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"checkContractAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"disactiveBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"divisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAllInformation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"getOwnedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTotalAccumulation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getValueWithdrable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moderator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nosNFT\",\"outputs\":[{\"internalType\":\"contract IERC721A\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"removeAllowedContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerMinutes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_moderator\",\"type\":\"address\"}],\"name\":\"setModerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nosNFT\",\"type\":\"address\"}],\"name\":\"setNosNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"setPaymentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nominalValue\",\"type\":\"uint256\"}],\"name\":\"stakeNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valueWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"boosted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"stakingBoostTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNFTLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValueLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unstakeNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTStaking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ea4f83a6fa1e33552852738bcd423b86d4371985d081ee90be2fd6c1008be517"}