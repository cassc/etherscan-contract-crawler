{"SourceCode": "// File: @openzeppelin\\contracts\\math\\SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: Contracts\\RegistryBEP.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\ncontract Proxiable {\r\n    // Code position in storage is keccak256(\"PROXIABLE\") = \"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\"\r\n\r\n    function updateCodeAddress(address newAddress) internal {\r\n        require(\r\n            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\r\n            \"Not compatible\"\r\n        );\r\n        assembly { // solium-disable-line\r\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\r\n        }\r\n    }\r\n    function proxiableUUID() public pure returns (bytes32) {\r\n        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\r\n    }\r\n}\r\n\r\ncontract LibraryLockDataLayout {\r\n  bool public initialized = false;\r\n}\r\n\r\ncontract LibraryLock is LibraryLockDataLayout {\r\n    // Ensures no one can manipulate the Logic Contract once it is deployed.\r\n    // PARITY WALLET HACK PREVENTION\r\n\r\n    modifier delegatedOnly() {\r\n        require(initialized == true, \"The library is locked. No direct 'call' is allowed\");\r\n        _;\r\n    }\r\n    function initialize() internal {\r\n        initialized = true;\r\n    }\r\n}\r\n\r\ncontract RegistryDataLayout is LibraryLock {\r\n    address public owner;\r\n    \r\n    struct whitelistVotes {\r\n        uint32 yesVotes;\r\n        uint32 noVotes;\r\n        address[] managers; //deprecated\r\n    }\r\n    mapping(address => whitelistVotes) public whitelistContract;\r\n    \r\n    mapping(address => bool) public whitelist;\r\n    \r\n    struct queuedContract {\r\n        uint256 finalizationBlock;\r\n        bool result;\r\n    }\r\n    mapping(address => queuedContract) public queuedContracts;\r\n    address[] public queueList;\r\n    \r\n    using SafeMath for uint32;\r\n    using SafeMath for uint256;\r\n    \r\n    address public fundContract = 0x2c9728ad35C1CfB16E3C1B5045bC9BA30F37FAc5;\r\n    address public connector = 0x60d70dF1c783b1E5489721c443465684e2756555;\r\n    address public devFund = 0xd66A9D2B706e225204F475c9e70A4c09eEa62199;\r\n    address public rewardsContract = 0x868f7622F57b62330Db8b282044d7EAf067fAcfe;\r\n    address public contractManager;\r\n    address public nyanManager;\r\n    address public selfManager;\r\n    address public nyanVoting;\r\n}\r\n\r\ninterface usedContract {\r\n    function getManagerLimit() external returns(uint32);\r\n    function sendFundBNB(address _manager) external payable;\r\n    function getFundBNB(uint256 amount) external;\r\n    function returnFundBNB() external payable;\r\n    function fundLog(address manager, string calldata reason, address recipient) external payable;\r\n    function isFundManager(address manager) view external returns(bool);\r\n    function checkFundManagerAllowance(address _manager, uint256 BNB) external returns(bool);\r\n    function checkManagerAllowance(address _manager, uint256 BNB) external returns(bool);\r\n    function adjustFundManagerAllowance(address _manager, uint256 BNB, uint256 profit) external;\r\n    function adjustManagerAllowance(address _manager, uint256 BNB, uint256 profit) external;\r\n    function canDevUpdate(address _dev) external returns(bool);\r\n    function getPoolFee(address _manager) external returns(uint32);\r\n}\r\n\r\ninterface NyanVoting {\r\n    function addToUpdateList(address _contract) external;\r\n    function updateResults() external returns(bool);\r\n}\r\n\r\ncontract RegistryBEP is RegistryDataLayout, Proxiable {\r\n    constructor() public {\r\n        \r\n    }\r\n    \r\n    /** @notice Initialize proxy contract.\r\n      */\r\n    function initRegistry(address _nyanManager) public {\r\n        require(!initialized);\r\n        owner = msg.sender;\r\n        initialize();\r\n    }\r\n\r\n    /** @notice Renounces contract ownerships.\r\n      */\r\n    function renounceOwnership() public delegatedOnly {\r\n        require(msg.sender == owner);\r\n        owner = address(0);\r\n    }\r\n    \r\n    /** @notice Adds the contract address to the voting queue. Non Devs must pay a BNB fee.\r\n      * @param newCode Address of the new logic contract.\r\n      */\r\n    function updateCode(address newCode) public payable delegatedOnly  {\r\n        if (owner == address(0)) {\r\n            //check to see if caller is dev\r\n            bool isDev = NyanDev(devFund).canUpdate(msg.sender);\r\n            //if not, check for 30BNB value\r\n            if (!isDev) {\r\n                require(msg.value >= 30000000000000000000, \"You have to pay the troll toll.\");\r\n                rewardsContract.call{value: msg.value}(\"\");\r\n            }\r\n        } else {\r\n            require(msg.sender == owner);\r\n        }\r\n        //add contract to update list on voting contract\r\n        NyanVoting(nyanVoting).addToUpdateList(newCode);\r\n    }\r\n\r\n    /** @notice Allows the owner to immediately update the contract logic.\r\n      * @param newCode Address of the new logic contract.\r\n      */\r\n    function ownerUpdate(address newCode) public delegatedOnly {\r\n        require(msg.sender == owner);\r\n        updateCodeAddress(newCode);\r\n    }\r\n\r\n    /** @notice Finalize contract logic update using results from Nyan Voting contract.\r\n      */\r\n    function finalizeUpdate(address newCode) public delegatedOnly {\r\n        //check with voting contract\r\n        bool votingResult = NyanVoting(nyanVoting).updateResults();\r\n        //if true\r\n        if (votingResult) {\r\n            updateCodeAddress(newCode);\r\n        }\r\n        \r\n    }\r\n    \r\n    /** @notice Set the address for various key contracts.\r\n      * @param _selfManager Address of the Managed pools creator.\r\n      * @param _nyanVoting Address of the Nyan Voting contract.\r\n      * @param _fundContract Address of the Central Nyan fund.\r\n      * @param _connector Address of the Connector(intermediary between the Central fund)\r\n      * @param _devFund Address of the Nyan developer fund.\r\n      * @param _rewardsContract Address of the Nyan rewards contract(where burns occur).\r\n      */\r\n    function setContracts(address _selfManager,\r\n                          address _nyanVoting,\r\n                          address _fundContract,\r\n                          address _connector,\r\n                          address _devFund,\r\n                          address _rewardsContract) \r\n                              public {\r\n                              require(msg.sender == owner);\r\n                              selfManager = _selfManager;\r\n                              nyanVoting = _nyanVoting;\r\n                              fundContract = _fundContract;\r\n                              connector = _connector;\r\n                              devFund = _devFund;\r\n                              rewardsContract = _rewardsContract;\r\n    }\r\n    \r\n    /** @notice Allows a manager of a custom active pool to use their liqiuidity within\r\n        a whitelisted contract.\r\n      * @param manager Address of the pool's creator.\r\n      * @param BNB Amount of BNB to send to whitelisted contract.\r\n      * @param recipient The address of the whitelisted contract.\r\n      */\r\n    function useManagerBNB(address manager, uint256 BNB, address recipient) public delegatedOnly payable {\r\n        require(whitelist[msg.sender]);\r\n        bool canSpend = usedContract(selfManager).checkManagerAllowance(manager, BNB);\r\n        require(canSpend);\r\n        usedContract(connector).getFundBNB(BNB);\r\n        usedContract(connector).fundLog(manager, \"used BNB for an investment\", recipient);\r\n        require(whitelist[recipient]);\r\n        recipient.call{value: BNB}(\"\");\r\n    }\r\n    \r\n    /** @notice Called by a whitelisted contract to return the manager's liquidity to the \r\n        Nyan fund contract.\r\n      * @param manager Address of the pool's creator.\r\n      * @param profit Amount of profit generated from the manager's investment. Calculated by the whitelisted contract.\r\n      */\r\n    function returnManagerBNB(address manager, uint256 profit) public delegatedOnly payable {\r\n        require(whitelist[msg.sender]);\r\n        uint256 valueSub = 0;\r\n        if (profit > 100) {\r\n            //get manager's pool fee\r\n            uint32 managerFee = usedContract(selfManager).getPoolFee(manager);\r\n            devFund.call{value: profit.mul(3).div(1000).sub(1)}(\"\");\r\n            rewardsContract.call{value: profit.mul(7).div(1000).sub(1)}(\"\");\r\n\r\n            manager.call{value: profit.mul(managerFee).div(100)}(\"\");\r\n            usedContract(connector).returnFundBNB{value: msg.value.sub(profit.mul(managerFee.add(1)).div(100))}();\r\n            profit = profit.sub(profit.mul(managerFee.add(1)).div(100));\r\n            valueSub = profit.mul(managerFee.add(1)).div(100);\r\n        } else {\r\n            usedContract(connector).returnFundBNB{value: msg.value}();\r\n        }\r\n\r\n        usedContract(connector).fundLog(manager, \"returned BNB from an investment\", fundContract);\r\n        usedContract(selfManager).adjustManagerAllowance(manager, msg.value.sub(valueSub), profit);\r\n    }\r\n\r\n    /** @notice Adds a new contract to the whitelist queue for Governance voting\r\n      * @param _contract Address of the contract to whitelist.\r\n      */\r\n    function addToQueue(address _contract) public {\r\n        //require user is dev with access\r\n        require(usedContract(devFund).canDevUpdate(msg.sender));\r\n        require(queueList.length.add(1) == 1, \"One contract at a time\");\r\n        queueList.push(_contract);\r\n        queuedContracts[_contract].finalizationBlock = block.number.add(91000);\r\n    }\r\n\r\n    /** @notice Finalizes the result of whitelisting voting\r\n      * @param _contract Address of the contract to whitelist.\r\n      */\r\n    function finalizeWhitelist(address _contract) public {\r\n        for (uint32 i; i < queueList.length; i++) {\r\n            if (queueList[i] == _contract) {\r\n                if (queuedContracts[queueList[i]].finalizationBlock < block.number) {\r\n                    whitelist[_contract] = queuedContracts[queueList[i]].result;\r\n                    whitelistContract[_contract].yesVotes = 0;\r\n                    whitelistContract[_contract].noVotes = 0;\r\n                    removeFromQueue(i);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Trims queueList array after result is finalized.\r\n      * @param index The index of the contract in the queueList array.\r\n      */\r\n    function removeFromQueue(uint index) internal {\r\n        queueList[index] = queueList[queueList.length-1];\r\n        delete queueList[queueList.length-1];\r\n        queueList.pop();\r\n    }\r\n    \r\n    /** @notice Manages the voting process for whitelisting a contract. Can only be called\r\n        by the Nyan voting contract.\r\n      * @param _contract The address of the contract up for voting.\r\n      * @param votes The number of votes allocated to a direction.\r\n      * @param direction Yes(Allow) or No(Reject).\r\n      */\r\n    function manageContract(address _contract, uint256 votes, bool direction) \r\n        public delegatedOnly returns(uint256){\r\n            require(msg.sender == nyanVoting);\r\n        \r\n            //add staker's vote to contract\r\n            if (direction) {\r\n                whitelistContract[_contract].yesVotes = uint32(whitelistContract[_contract].yesVotes.add(1));\r\n            } else {\r\n                whitelistContract[_contract].noVotes = uint32(whitelistContract[_contract].noVotes.add(1));\r\n            }\r\n            whitelistContract[_contract].managers.push(msg.sender);\r\n            \r\n            //shift result based on majority\r\n            if (whitelistContract[_contract].yesVotes > whitelistContract[_contract].noVotes) {\r\n                queuedContracts[_contract].result = true;\r\n            }\r\n            if (whitelistContract[_contract].yesVotes < whitelistContract[_contract].noVotes) {\r\n                queuedContracts[_contract].result = false;\r\n            }\r\n            return queuedContracts[_contract].finalizationBlock;\r\n    }\r\n    \r\n    /** @notice Owner bypass for immediate contract whitelisting.\r\n      * @param _contract Address of the contract to whitelist.\r\n      */\r\n    function createWhitelist(address _contract) public {\r\n        require(msg.sender == owner);\r\n        whitelist[_contract] = true;\r\n    }\r\n    \r\n    /** @notice Checks if a contract is whitelisted.\r\n      * @param _contract Address of the contract.\r\n      */\r\n    function checkRegistry(address _contract) public view returns(bool) {\r\n        return whitelist[_contract];\r\n    }\r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n\r\n}\r\n\r\ninterface NyanDev {\r\n    function canUpdate(address _manager) external returns(bool);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"addToQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"checkRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"createWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"finalizeUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"finalizeWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nyanManager\",\"type\":\"address\"}],\"name\":\"initRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"direction\",\"type\":\"bool\"}],\"name\":\"manageContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nyanManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nyanVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"ownerUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queueList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"queuedContracts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalizationBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"returnManagerBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_selfManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nyanVoting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_connector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsContract\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCode\",\"type\":\"address\"}],\"name\":\"updateCode\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"BNB\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"useManagerBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistContract\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"yesVotes\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"noVotes\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RegistryBEP", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9e08d5093c2dacf1ecd48297f7fc94a7b30c9eef18f40564f71b236c8cdb9ad3"}