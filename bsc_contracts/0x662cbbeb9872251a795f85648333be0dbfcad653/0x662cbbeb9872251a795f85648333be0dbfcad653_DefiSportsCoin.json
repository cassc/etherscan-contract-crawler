{"SourceCode": "{\"BEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBEP20.sol\\\";\\n\\ncontract BEP20 is IBEP20 {\\n  mapping (address =\\u003e uint256) private _balances;\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n  string private constant _name = \\\"DefiSportsCoin\\\";\\n  string private constant _symbol = \\\"DSC\\\";\\n  uint8 private constant _decimals = 18;\\n  uint256 private constant _totalSupply = 10**10 * 10**_decimals;\\n  address private immutable _owner;\\n\\n  constructor() {\\n    _owner = msg.sender;\\n    _balances[msg.sender] = _totalSupply;\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\n  }\\n\\n  function getOwner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  function decimals() public pure returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  function symbol() external pure returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  function name() external pure returns (string memory) {\\n    return _name;\\n  }\\n\\n  function totalSupply() external pure returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address account) public view returns (uint256) {\\n    return _balances[account];\\n  }\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool) {\\n    _transfer(msg.sender, recipient, amount);\\n    return true;\\n  }\\n\\n  function allowance(address owner, address spender) external view returns (uint256) {\\n    return _allowances[owner][spender];\\n  }\\n\\n  function approve(address spender, uint256 amount) external returns (bool) {\\n    _approve(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\n    _transfer(sender, recipient, amount);\\n\\n    uint256 currentAllowance = _allowances[sender][msg.sender];\\n    require(currentAllowance \\u003e= amount, \\\"BEP20: transfer amount exceeds allowance\\\");\\n\\n    _approve(sender, msg.sender, currentAllowance - amount);\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n    uint256 currentAllowance = _allowances[msg.sender][spender];\\n    require(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n\\n    _approve(msg.sender, spender, currentAllowance - subtractedValue);\\n    return true;\\n  }\\n\\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n    require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n    require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n\\n    uint256 senderBalance = _balances[sender];\\n    require(senderBalance \\u003e= amount, \\\"BEP20: transfer amount exceeds balance\\\");\\n    _balances[sender] = senderBalance - amount;\\n    _balances[recipient] += amount;\\n\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  function _approve(address owner, address spender, uint256 amount) internal {\\n    require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n    require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n}\\n\"},\"DSC.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\nimport \\\"./BEP20.sol\\\";\\nimport \\\"./IDEX.sol\\\";\\n\\ncontract DefiSportsCoin is BEP20 {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  address public constant MARKETING = 0x59a62Afd58123Ca6C7d3d0B482c0f9A758D456E0;\\n  address constant LOCKER = 0x0706dB0ee120b04140D35c776B6171462AD4776B; // to update after locker deployment\\n\\n  uint256 private timeFrame = 525600 minutes; // 1 year in minutes\\n  uint256 private startTime = block.timestamp;\\n\\n  uint256 public swapThreshold = 300000 * 10**18;\\n  bool public swapEnabled = true;\\n  bool public tradingEnabled;\\n  bool _sniperTax = true;\\n  bool _inSwap;\\n\\n  uint256 public liquidityFee = 500;\\n  uint256 public marketingFee = 900;\\n  uint256 _totalFee = 1400;\\n  uint256 constant FEE_DENOMINATOR = 10000;\\n\\n  IDexRouter public constant ROUTER = IDexRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); \\n    //0xD99D1c33F9fC3444f8101754aBC46c52416550D1 testnet router\\n        //0x10ED43C718714eb63d5aA57B78B54704E256024E mainnet router\\n        //pinkswap router 0xBBe737384C2A26B15E23a181BDfBd9Ec49E00248\\n  address public immutable pair;\\n  uint256 public transferGas = 25000;\\n\\n  mapping (address =\\u003e bool) public isWhitelisted;\\n  mapping (address =\\u003e bool) public isFeeExempt;\\n  mapping (address =\\u003e bool) public isBaseFeeExempt;\\n  mapping (address =\\u003e bool) public isMarketMaker;\\n\\n  event SetIsWhitelisted(address indexed account, bool indexed status);\\n  event SetBaseFeeExempt(address indexed account, bool indexed exempt);\\n  event SetFeeExempt(address indexed account, bool indexed exempt);\\n  event SetMarketMaker(address indexed account, bool indexed isMM);\\n  event SetSwapBackSettings(bool indexed enabled, uint256 amount);\\n  event SetFees(uint256 liquidity, uint256 marketing);\\n  event AutoLiquidity(uint256 pair, uint256 tokens);\\n  event UpdateTransferGas(uint256 gas);\\n  event Recover(uint256 amount);\\n  event TriggerSwapBack();\\n  event EnableTrading();\\n\\n  // Vesting\\n\\n  // Helper to determine vesting logic with O(1) complexity\\n  // Can\\u0027t be used in enumeration as the ordering can\\u0027t be guaranteed\\n  EnumerableSet.AddressSet vesting;\\n  uint256[5][5] leftX;\\n  address[5] allWallets = [\\n    0xDc271B68e559Bcfb8304421CA193206C9a4E93eD, // Wallet for Ambassadors\\n    0xbBa5D96D3588238E560e71ccCa973429765988f6, // Wallet for Associations\\n    0x850bCd23a20E36140b45C6B4dFc3285d61Ff3863, // Wallet for The BitcoinManTM\\n    0xAC2a8d02ff977c1c3BfEd6648f84cb786714E045, // Wallet for Advisors\\n    0xfeD7e1F6c2534FF1c05CAE1Bc7BA35B37e053a4a // Wallet for Team\\n  ];\\n\\n\\n  modifier swapping() { \\n    _inSwap = true;\\n    _;\\n    _inSwap = false;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == getOwner());\\n    _;\\n  }\\n\\n  constructor() BEP20() {\\n    pair = IDexFactory(ROUTER.factory()).createPair(ROUTER.WETH(), address(this));\\n    _approve(address(this), address(ROUTER), type(uint256).max);\\n    isMarketMaker[pair] = true;\\n\\n    _initVesting();\\n\\n    isWhitelisted[getOwner()] = true;\\n    isWhitelisted[MARKETING] = true;\\n    isWhitelisted[address(this)] = true;\\n\\n    isBaseFeeExempt[0xDc271B68e559Bcfb8304421CA193206C9a4E93eD] = true;\\n    isBaseFeeExempt[0xbBa5D96D3588238E560e71ccCa973429765988f6] = true;\\n    isBaseFeeExempt[0x850bCd23a20E36140b45C6B4dFc3285d61Ff3863] = true;\\n    isBaseFeeExempt[0xAC2a8d02ff977c1c3BfEd6648f84cb786714E045] = true;\\n    isBaseFeeExempt[0xfeD7e1F6c2534FF1c05CAE1Bc7BA35B37e053a4a] = true;\\n\\n\\n    isFeeExempt[0xDc271B68e559Bcfb8304421CA193206C9a4E93eD] = true;\\n    isFeeExempt[0xbBa5D96D3588238E560e71ccCa973429765988f6] = true;\\n    isFeeExempt[0x850bCd23a20E36140b45C6B4dFc3285d61Ff3863] = true;\\n    isFeeExempt[0xAC2a8d02ff977c1c3BfEd6648f84cb786714E045] = true;\\n    isFeeExempt[0xfeD7e1F6c2534FF1c05CAE1Bc7BA35B37e053a4a] = true;\\n\\n    vesting.add(0xDc271B68e559Bcfb8304421CA193206C9a4E93eD);\\n    vesting.add(0xbBa5D96D3588238E560e71ccCa973429765988f6);\\n    vesting.add(0x850bCd23a20E36140b45C6B4dFc3285d61Ff3863);\\n    vesting.add(0xAC2a8d02ff977c1c3BfEd6648f84cb786714E045);\\n    vesting.add(0xfeD7e1F6c2534FF1c05CAE1Bc7BA35B37e053a4a);\\n  }\\n\\n  // Override\\n\\n  function _transfer(address sender, address recipient, uint256 amount) internal override {\\n    if (isWhitelisted[sender] || isWhitelisted[recipient]) { super._transfer(sender, recipient, amount); return; }\\n    require(tradingEnabled, \\\"Trading is disabled\\\");\\n\\n    if (_shouldSwapBack(recipient)) { _swapBack(); }\\n    uint256 amountAfterFees = _takeFee(sender, recipient, amount);\\n\\n    uint256 timePeriod = (block.timestamp - startTime) / timeFrame;\\n    if (vesting.contains(sender) \\u0026\\u0026 timePeriod \\u003c 5) { _validateVesting(sender, amount, timePeriod); }\\n\\n    super._transfer(sender, recipient, amountAfterFees);\\n  }\\n\\n  // Public\\n\\n  function getTotalFee() public view returns (uint256) {\\n    if (_sniperTax) { return FEE_DENOMINATOR - 200; }\\n    return _totalFee;\\n  }\\n\\n  receive() external payable {}\\n\\n  // Private\\n\\n  function _takeFee(address sender, address recipient, uint256 amount) private returns (uint256) {\\n    if (amount \\u003e 0) {\\n      uint256 baseFeeAmount;\\n      if (!isBaseFeeExempt[sender] \\u0026\\u0026 !isBaseFeeExempt[recipient]) {\\n        baseFeeAmount = amount / 100;\\n        super._transfer(sender, MARKETING, baseFeeAmount);\\n      }\\n\\n      uint256 feeAmount;\\n      if (!isFeeExempt[sender] \\u0026\\u0026 !isFeeExempt[recipient] \\u0026\\u0026 (isMarketMaker[recipient] || isMarketMaker[sender])) {\\n        feeAmount = amount * getTotalFee() / FEE_DENOMINATOR;\\n        super._transfer(sender, address(this), feeAmount);\\n      }\\n\\n      return amount - baseFeeAmount - feeAmount;\\n    } else {\\n      return amount;\\n    }\\n  }\\n\\n  function _validateVesting(address sender, uint256 amount, uint256 timePeriod) private view {\\n    for (uint256 i = 0; i \\u003c 5; i++) {\\n      if (sender == allWallets[i]) {\\n        require(balanceOf(sender) - amount \\u003e= leftX[i][timePeriod], \\\"Amount requested larger than allowed, Please refer to the release plan\\\");\\n        break;\\n      }\\n    }\\n  }\\n\\n  function _initVesting() private {\\n       // The amount of token should be left in each wallet in every timePeriod\\n    // wallets for Ambassadors, Associations, Advisors will be released at the beginning of each year\\n    // becasue DefiSports company needs to distribute tokens to Ambassadors, Associations and Advisors.\\n    // Other wallets will be released at the completion of each year.\\n    \\n    leftX[0] = [16*10**8*10**18, 12*10**8*10**18, 8*10**8*10**18, 4*10**8*10**18, 0]; //Ambassadors (4% will be released at the beginning of each year)\\n    leftX[1] = [8*10**8*10**18, 6*10**8*10**18, 4*10**8*10**18, 2*10**8*10**18, 0]; //Associations (2% will be released at the beginning of each year)\\n    leftX[2] = [5*10**8*10**18, 3*10**8*10**18, 1*10**8*10**18, 0, 0];//BitcoinManTM\\n    leftX[3] = [4*10**8*10**18, 3*10**8*10**18, 2*10**8*10**18, 1*10**8*10**18, 0]; //Advisors (1% will be released at the beginning of each year)\\n    leftX[4] = [15*10**8*10**18, 12*10**8*10**18, 9*10**8*10**18, 6*10**8*10**18, 3*10**8*10**18];//Team wallet\\n  }\\n\\n  function _shouldSwapBack(address recipient) private view returns (bool) {\\n    return isMarketMaker[recipient] // TODO: test swap logic with custom market maker \\\"sell\\\"\\n    \\u0026\\u0026 !_inSwap\\n    \\u0026\\u0026 swapEnabled\\n    \\u0026\\u0026 balanceOf(address(this)) \\u003e= swapThreshold;\\n  }\\n\\n  function _swapBack() private swapping {\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = ROUTER.WETH();\\n\\n    uint256 liquidityTokens = swapThreshold * liquidityFee / _totalFee / 2;\\n    uint256 amountToSwap = swapThreshold - liquidityTokens;\\n    uint256 balanceBefore = address(this).balance;\\n\\n    ROUTER.swapExactTokensForETH(\\n      amountToSwap,\\n      0,\\n      path,\\n      address(this),\\n      block.timestamp\\n    );\\n\\n    uint256 amountBNB = address(this).balance - balanceBefore;\\n    uint256 totalBNBFee = _totalFee - liquidityFee / 2;\\n\\n    uint256 amountBNBLiquidity = amountBNB * liquidityFee / totalBNBFee / 2;\\n    uint256 amountBNBMarketing = amountBNB * marketingFee / totalBNBFee;\\n    payable(MARKETING).call{value: amountBNBMarketing, gas: transferGas}(\\\"\\\");\\n\\n    if (liquidityTokens \\u003e 0) {\\n      ROUTER.addLiquidityETH{value: amountBNBLiquidity}(\\n        address(this),\\n        liquidityTokens,\\n        0,\\n        0,\\n        LOCKER,\\n        block.timestamp\\n      );\\n\\n      emit AutoLiquidity(amountBNBLiquidity, liquidityTokens);\\n    }\\n  }\\n\\n  // Owner\\n\\n  function removeSniperTax() external onlyOwner {\\n    _sniperTax = false;\\n  }\\n\\n  function enableTrading() external onlyOwner {\\n    tradingEnabled = true;\\n    emit EnableTrading();\\n  }\\n\\n  function setIsWhitelisted(address account, bool status) external onlyOwner {\\n    require(account != getOwner() \\u0026\\u0026 !isMarketMaker[account]);\\n    isWhitelisted[account] = status;\\n    emit SetIsWhitelisted(account, status);\\n  }\\n\\n  function setIsBaseFeeExempt(address account, bool exempt) external onlyOwner {\\n    require(account != getOwner() \\u0026\\u0026 account != MARKETING \\u0026\\u0026 !isMarketMaker[account]);\\n    isBaseFeeExempt[account] = exempt;\\n    emit SetBaseFeeExempt(account, exempt);\\n  }\\n\\n  function setIsFeeExempt(address account, bool exempt) external onlyOwner {\\n    require(account != getOwner() \\u0026\\u0026 account != MARKETING \\u0026\\u0026 !isMarketMaker[account]);\\n    isFeeExempt[account] = exempt;\\n    emit SetFeeExempt(account, exempt);\\n  }\\n\\n  function setIsMarketMaker(address account, bool isMM) external onlyOwner {\\n    require(account != pair);\\n    isMarketMaker[account] = isMM;\\n    emit SetMarketMaker(account, isMM);\\n  }\\n\\n  function setFees(uint256 newLiquidityFee, uint256 newMarketingFee) external onlyOwner {\\n    liquidityFee = newLiquidityFee;\\n    marketingFee = newMarketingFee;\\n    _totalFee = liquidityFee + marketingFee;\\n    require(_totalFee \\u003c= 1500);\\n\\n    emit SetFees(liquidityFee, marketingFee);\\n  }\\n\\n  function setSwapBackSettings(bool enabled, uint256 amount) external onlyOwner {\\n    uint256 tokenAmount = amount * 10**decimals();\\n    swapEnabled = enabled;\\n    swapThreshold = tokenAmount;\\n    emit SetSwapBackSettings(enabled, amount);\\n  }\\n\\n  function updateTransferGas(uint256 newGas) external onlyOwner {\\n    require(newGas \\u003e= 21000 \\u0026\\u0026 newGas \\u003c= 100000);\\n    transferGas = newGas;\\n    emit UpdateTransferGas(newGas);\\n  }\\n\\n  function triggerSwapBack() external onlyOwner {\\n    _swapBack();\\n    emit TriggerSwapBack();\\n  }\\n\\n  function recover() external onlyOwner {\\n    uint256 amount = address(this).balance;\\n    (bool sent,) = payable(MARKETING).call{value: amount, gas: transferGas}(\\\"\\\");\\n    require(sent, \\\"Tx failed\\\");\\n    emit Recover(amount);\\n  }\\n}\\n\"},\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue\\u0027s index to valueIndex\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n}\\n\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IBEP20 {\\n  function totalSupply() external view returns (uint256);\\n  function decimals() external view returns (uint8);\\n  function symbol() external view returns (string memory);\\n  function name() external view returns (string memory);\\n  function getOwner() external view returns (address);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IDEX.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDexFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IDexRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETH(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pair\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"AutoLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recover\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"SetBaseFeeExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"SetFeeExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetIsWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isMM\",\"type\":\"bool\"}],\"name\":\"SetMarketMaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SetSwapBackSettings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TriggerSwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"UpdateTransferGas\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MARKETING\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBaseFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMarketMaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeSniperTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsBaseFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isMM\",\"type\":\"bool\"}],\"name\":\"setIsMarketMaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setIsWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGas\",\"type\":\"uint256\"}],\"name\":\"updateTransferGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DefiSportsCoin", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0255bc5396ae8012867dbb0e765482850b81196c7e489026f990e3a2a7622f6e"}