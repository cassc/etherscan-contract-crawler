{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EacMiner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IPancakeRouter02.sol\\\";\\nimport \\\"./Relation.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ncontract EacMiner is Ownable {\\n\\n    event addRelationEvent (\\n        address owner,\\n        address recommer\\n    );\\n\\n    event buyViaEacEvent (\\n        address owner,\\n        uint256 tokenAmount,\\n        uint256 hashrate,\\n        uint256 eacBalance,\\n        uint256 ethBalance,\\n        uint256 outAmount\\n    );\\n\\n    event buyViaUsdtEvent (\\n        address owner,\\n        uint256 tokenAmount,\\n        uint256 hashrate,\\n        uint256 eacBalance,\\n        uint256 ethBalance,\\n        uint256 outAmount\\n    );\\n\\n    event increaseHashrateEvent (\\n        address owner,\\n        uint256 hashrate\\n    );\\n\\n    event decreaseHashrateEvent(\\n        address owner,\\n        uint256 hashrate\\n    );\\n\\n    event increaseTeamHashrateEvent (\\n        address buyer,\\n        uint256 payment,\\n        uint256 paymentUnit,\\n        address receiver,\\n        uint256 hashrate,\\n        uint256 reward,\\n        uint256 rewardScale\\n    );\\n\\n    event decreaseTeamHashrateEvent (\\n        address buyer,\\n        address receiver,\\n        uint256 hashrate\\n    );\\n\\n    event claimEacEvent(\\n        address owner,\\n        uint256 amount,\\n        uint256 eacBalance,\\n        uint256 ethBalance\\n    );\\n\\n    event claimEthEvent (\\n        address owner,\\n        uint256 amount,\\n        uint256 eacBalance,\\n        uint256 ethBalance\\n    );\\n\\n    struct Miner {\\n        address owner;\\n        uint256 hashrate;\\n        uint256 teamHashrate;\\n        uint256 outAmount;\\n        uint256 lastTimeForEth;\\n        uint256 lastTimeForEac;\\n        uint256 totalPurchase;\\n        uint256 totalEthClaimed;\\n        uint256 totalEacClaimed;\\n    }\\n\\n    mapping(address => Miner) public minerInfo;\\n    mapping(address => uint256) public activeRecommendNum;\\n    mapping(address => bool) private bootAddress;\\n    mapping(address => mapping(address => uint256)) private additionHashrateMapping;\\n    address immutable private ctoAddress;\\n    address private platformAddress;\\n    address public pledgeDividendsAddress;\\n    address immutable private router;\\n    address immutable public relation;\\n    address immutable private WETH_EAC_LP;\\n    address immutable public deadAddress;\\n    address immutable public USDT;\\n    address immutable public EAC;\\n    address immutable public WETH;\\n    address public nodeAddress;\\n    address public coo;\\n    address public oracle;\\n    uint256 private totalHashrate;\\n    uint256 immutable private claimInterval;\\n    uint256 public eacDistributeDenominator;\\n    uint256 public bnbDistributeDenominator;\\n    uint256[] private additionCoefficient;\\n    uint256[] private additionCoefficientConditions;\\n    \\n\\n    constructor(address _cto,\\n                    address _pledge,\\n                    address _platform,\\n                    address _relation,\\n                    address _coo) {\\n\\n       deadAddress = 0x000000000000000000000000000000000000dEaD;\\n       additionCoefficient = [50, 10, 10, 15, 15, 15, 20, 20, 20, 50];\\n       additionCoefficientConditions = [100 * 10**18, 300 * 10**18, 500 * 10**18, 800 * 10**18, 1000 * 10**18, 5000 * 10**18, 10000 * 10**18, 100000 * 10**18, 500000 * 10**18, 1000000 * 10**18];\\n       USDT = 0x55d398326f99059fF775485246999027B3197955;\\n       EAC = 0x3423dE0Fd15356841493188B93eeD1AB7e3B54De;\\n       WETH_EAC_LP = 0xD937E9559f7e68e26b49139ac16dA66c284DBf8C;\\n       WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n       ctoAddress = _cto;\\n       pledgeDividendsAddress = _pledge;\\n       platformAddress = _platform;\\n       relation = _relation;\\n       router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n       claimInterval = 60 * 60 * 24 * 5;\\n       eacDistributeDenominator = 10;\\n       bnbDistributeDenominator = 3;\\n       coo = _coo;\\n       oracle = 0xd70Bf35eCD45a85966c841F4D534a797642E9B8c;\\n       nodeAddress = 0xe7A2C8Ee9A53dDE9AbFDD16c13FB2e2d890C8Eff;\\n   }\\n\\n   function setEacDistributeDenominator(uint256 _eacDistributeDenominator) external {\\n    require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    eacDistributeDenominator = _eacDistributeDenominator;\\n   }\\n\\n   function setBnbDistributeDenominator(uint256 _bnbDistributeDenominator) external {\\n    require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    bnbDistributeDenominator = _bnbDistributeDenominator;\\n   }\\n\\n   function setAdditionCoefficientConditions(uint256[] memory _additionCoefficientConditions) external {\\n       require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    for (uint256 i=0; i<10; i++) {\\n        additionCoefficientConditions[i] = _additionCoefficientConditions[i] * 10**18;\\n    }\\n   }\\n   \\n\\n   function setOracle(address _oracle) external {\\n    require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    oracle = _oracle;\\n   }\\n\\n   function setNode(address _nodeAddress) external {\\n    require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    nodeAddress = _nodeAddress;\\n   }\\n\\n   function setPlege(address _pledge) external {\\n    require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    pledgeDividendsAddress = _pledge;\\n   }\\n\\n   function setCoo(address _coo) external onlyOwner {\\n    coo = _coo;\\n   }\\n   \\n   function setPlatform(address _platform) external {\\n    require(msg.sender == coo, \\\"caller is not the coo\\\");\\n    platformAddress = _platform;\\n   }\\n\\n    function addRelationEx(address recommer) external returns (bool result) {\\n        require(minerInfo[recommer].owner != address(0), \\\"Member does not exist\\\");\\n        result =  Relation(relation).addRelationEx(msg.sender, recommer);\\n        minerInfo[msg.sender].owner = msg.sender;\\n        emit addRelationEvent(msg.sender, recommer);\\n    }\\n\\n    function calViaEac(uint256 amount) external view returns (uint hashrate) {\\n        address[] memory path2 = new address[](2);\\n        path2[0] = EAC;\\n        path2[1] = USDT;\\n        uint256[] memory amounts = IPancakeRouter02(router).getAmountsOut(amount, path2);\\n        hashrate = amounts[1];\\n    }\\n\\n   function depositUSDT(uint256 amount) external {\\n        minerInfo[msg.sender].owner = msg.sender;\\n        uint256 tokenAmount = amount;\\n\\n        // transfer USDT\\n        IERC20(USDT).transferFrom(msg.sender, address(this), tokenAmount);\\n\\n        // 50% to buy ETH\\n        uint256 swapEthAmountIn = tokenAmount / 2;\\n        address[] memory path1 = new address[](2);\\n        path1[0] = USDT;\\n        path1[1] = WETH;\\n        uint256 swapEthAmountOut = _swapUForToken(swapEthAmountIn, path1, address(this));\\n        // distribute Eth\\n        _distributeEth(swapEthAmountOut);\\n\\n        // 50% to buy EAC\\n        uint256 swapEacAmountIn = tokenAmount * 5 / 10;\\n        address[] memory path2 = new address[](2);\\n        path2[0] = USDT;\\n        path2[1] = EAC;\\n        uint256 oracleEacAmountOut = IOracle(oracle).consult(USDT, swapEacAmountIn);\\n        uint256 swapEacAmountOut = _swapUForToken(swapEacAmountIn, path2, address(this));\\n        minerInfo[msg.sender].outAmount += oracleEacAmountOut * 2;\\n        // distribute eac\\n        _distributeEac(swapEacAmountOut);\\n\\n        // 10% to addLP\\n        // uint256 addLqEacAmount = swapEacAmountOut * 25 / 100;\\n\\n        // 10% to USDT Market Cap\\n        // uint256 addLqAmount2 = tokenAmount / 10;\\n        // _addLiquidity(EAC, USDT, addLqEacAmount, addLqAmount2, deadAddress);\\n\\n        // add hashrate\\n        _increaseHashrate(msg.sender, tokenAmount);\\n\\n        // add recommer\\n        _addRecommend(msg.sender, Relation(relation).parentOf(msg.sender));\\n\\n        // add team hashrate\\n        _increaseTeamHashrate(msg.sender, amount, 1, tokenAmount);\\n\\n        emit buyViaUsdtEvent(msg.sender, tokenAmount, tokenAmount, IERC20(EAC).balanceOf(address(this)), IERC20(WETH).balanceOf(address(this)), minerInfo[msg.sender].outAmount);\\n   }\\n\\n   function depositEAC(uint256 amount) external {\\n    require(amount <= IERC20(EAC).balanceOf(WETH_EAC_LP) * 5 / 100, \\\"Must not exceed 5% of LP\\\");\\n    minerInfo[msg.sender].owner = msg.sender;\\n    uint256 tokenAmount = amount;\\n    address[] memory path2 = new address[](2);\\n    path2[0] = EAC;\\n    path2[1] = USDT;\\n    uint256 hashrate = IOracle(oracle).consult(EAC, tokenAmount);\\n\\n    // transfer EAC\\n    IERC20(EAC).transferFrom(msg.sender, address(this), tokenAmount);\\n\\n    // 50% to buy eth\\n    uint256 swapEthAmountIn = tokenAmount * 50 / 100;\\n    address[] memory path1 = new address[](2);\\n    path1[0] = EAC;\\n    path1[1] = WETH;\\n    uint256 swapEthAmountOut = _swapUForToken(swapEthAmountIn, path1, address(this));\\n\\n    // out amount\\n    minerInfo[msg.sender].outAmount += ((amount - swapEthAmountIn) * 2);\\n\\n    // distribute Eth\\n    _distributeEth(swapEthAmountOut);\\n\\n    // 10% addLq eac/usdt\\n    // _addLiquidity(EAC, WETH, tokenAmount / 10, swapEthAmountOut * 167 / 1000 , deadAddress);\\n\\n    // 5% to pledge\\n    // IERC20(EAC).transfer(pledgeDividendsAddress, tokenAmount * 5 / 100);\\n    // add hashrate\\n\\n    _distributeEac(amount - swapEthAmountIn);\\n\\n    _increaseHashrate(msg.sender, hashrate);\\n\\n    // add recommer\\n    _addRecommend(msg.sender, Relation(relation).parentOf(msg.sender));\\n\\n    // add team hashrate\\n    _increaseTeamHashrate(msg.sender, amount, 2, hashrate);\\n\\n    emit buyViaEacEvent(msg.sender, tokenAmount, hashrate, IERC20(EAC).balanceOf(address(this)), IERC20(WETH).balanceOf(address(this)), minerInfo[msg.sender].outAmount);\\n   }\\n\\n    function calClaimETH(address owner) external view returns (uint256 amount) {\\n        Miner memory miner = minerInfo[owner];\\n        if (block.timestamp - miner.lastTimeForEth  < claimInterval ||\\n        miner.hashrate <= 0) {\\n            amount = 0;\\n        } else {\\n            amount = IERC20(WETH).balanceOf(address(this)) * (miner.hashrate + miner.teamHashrate) / bnbDistributeDenominator / totalHashrate;\\n        }\\n    }\\n\\n    function calClaimEAC(address owner) external view returns (uint256 amount) {\\n        Miner memory miner = minerInfo[owner];\\n        if (block.timestamp - miner.lastTimeForEac < claimInterval ||\\n        miner.hashrate <= 0) {\\n            amount = 0;\\n        } else {\\n            uint256 claimAmount = IERC20(EAC).balanceOf(address(this)) * (miner.hashrate + miner.teamHashrate) / eacDistributeDenominator / totalHashrate;\\n            uint256 remainAmount = miner.outAmount - miner.totalEacClaimed;\\n            if (claimAmount > remainAmount) {\\n                claimAmount = remainAmount;\\n            }\\n            amount = claimAmount;\\n        }\\n    }\\n\\n   function withdraw() external {\\n    Miner storage miner = minerInfo[msg.sender];\\n    require(miner.hashrate > 0, \\\"Please buy hashrate first\\\");\\n    if (block.timestamp - miner.lastTimeForEac >= claimInterval) {\\n     miner.lastTimeForEac = block.timestamp;\\n     uint256 claimAmount = IERC20(EAC).balanceOf(address(this)) * (miner.hashrate + miner.teamHashrate) / eacDistributeDenominator / totalHashrate;\\n     uint256 remainAmount = miner.outAmount - miner.totalEacClaimed;\\n     if (claimAmount > remainAmount) {\\n        claimAmount = remainAmount;\\n     }\\n\\n     miner.totalEacClaimed += claimAmount;\\n     IERC20(EAC).transfer(msg.sender, claimAmount);\\n\\n     // out or not\\n     _outOrNot(msg.sender);\\n     emit claimEacEvent(msg.sender, claimAmount, IERC20(EAC).balanceOf(address(this)), IERC20(WETH).balanceOf(address(this)));\\n    }\\n\\n    if (block.timestamp - miner.lastTimeForEth >= claimInterval) {\\n     miner.lastTimeForEth = block.timestamp;\\n     uint256 claimAmount = IERC20(WETH).balanceOf(address(this)) * (miner.hashrate + miner.teamHashrate) / bnbDistributeDenominator / totalHashrate;\\n     miner.totalEthClaimed += claimAmount;\\n     IERC20(WETH).transfer(msg.sender, claimAmount);\\n     emit claimEthEvent(msg.sender, claimAmount, IERC20(EAC).balanceOf(address(this)), IERC20(WETH).balanceOf(address(this)));   \\n    }\\n   }\\n\\n   function _addRecommend(address owner, address recommer) private {\\n    if (!bootAddress[owner]) {\\n        activeRecommendNum[recommer] += 1;\\n        bootAddress[owner] = true;\\n    }\\n   }\\n\\n   function _outOrNot(address owner) private {\\n    Miner storage miner = minerInfo[owner];\\n    if (miner.totalEacClaimed >= miner.outAmount) {\\n        // decrease hashrate\\n        _decreaseHashrate(owner, miner.hashrate);\\n    }\\n   }\\n\\n   function _swapUForToken(uint256 tokenAmount, address[] memory path, address to) private returns (uint amount) {\\n\\n        uint oriBalance = IERC20(path[path.length - 1]).balanceOf(to);\\n\\n        IERC20(path[0]).approve(router, tokenAmount);\\n\\n        // make the swap\\n        IPancakeRouter02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            to,\\n            block.timestamp\\n        );\\n        amount = IERC20(path[path.length - 1]).balanceOf(to) - oriBalance;\\n    }\\n\\n    function _distributeEth(uint256 tokenAmount) private {\\n        // 1% to cto\\n        IERC20(WETH).transfer(ctoAddress, tokenAmount / 100);\\n\\n        // 4% to platform\\n        IERC20(WETH).transfer(platformAddress, tokenAmount * 5 / 100);\\n\\n        // 15% to node\\n        IERC20(WETH).transfer(nodeAddress, tokenAmount * 14 / 100);        \\n\\n        // 80% to contract\\n    }\\n\\n    function _distributeEac(uint256 tokenAmount) private {\\n        // 10% to pledge dividends\\n        IERC20(EAC).transfer(pledgeDividendsAddress, tokenAmount * 10 / 100);\\n\\n        // 10% to dead Address\\n       IERC20(EAC).transfer(deadAddress, tokenAmount * 10 / 100);\\n\\n        // 80% to miner\\n    }\\n\\n    function _increaseHashrate(address owner, uint256 amount) private {\\n        Miner storage miner = minerInfo[owner];\\n        if (miner.hashrate <=0) {\\n            miner.lastTimeForEac = block.timestamp;\\n            miner.lastTimeForEth = block.timestamp;\\n        }\\n        miner.hashrate += amount;\\n        miner.totalPurchase += amount;\\n        totalHashrate += amount;\\n        emit increaseHashrateEvent(owner, amount);\\n    }\\n\\n    function _increaseTeamHashrate(address owner, uint256 payment, uint256 paymentUnit, uint256 amount) private {\\n        address[] memory parents = Relation(relation).getForefathers(owner, 10);\\n        for (uint256 i = 0; i < parents.length; i++) {\\n            if (parents[i] == address(0)) {\\n                break;\\n            }\\n            Miner storage miner = minerInfo[parents[i]];\\n            if (miner.hashrate + miner.teamHashrate >= additionCoefficientConditions[i] && activeRecommendNum[parents[i]] >= i + 1) {\\n                uint256 additionHashrate = amount * additionCoefficient[i] / 100;\\n                miner.teamHashrate += additionHashrate;\\n                totalHashrate += additionHashrate;\\n                additionHashrateMapping[owner][parents[i]] += additionHashrate;\\n                emit increaseTeamHashrateEvent(owner, payment, paymentUnit, parents[i], amount, additionHashrate, additionCoefficient[i]);\\n            }\\n        }\\n    }\\n\\n    function _decreaseHashrate(address owner, uint amount) private {\\n        // decrease own hashrate\\n        Miner storage miner = minerInfo[owner];\\n        miner.hashrate -= amount;\\n        totalHashrate -= amount;\\n\\n        if (miner.hashrate <=0) {\\n            miner.lastTimeForEac = 0;\\n            miner.lastTimeForEth = 0;\\n        }\\n\\n        //decrease team hashrate\\n        address[] memory parents = Relation(relation).getForefathers(owner, 10);\\n        for (uint256 i = 0; i < parents.length; i++) {\\n            if (parents[i] == address(0)) {\\n                break;\\n            }\\n            if (additionHashrateMapping[owner][parents[i]] != 0) {\\n                minerInfo[parents[i]].teamHashrate -= additionHashrateMapping[owner][parents[i]];\\n                totalHashrate -= additionHashrateMapping[owner][parents[i]];\\n                emit decreaseTeamHashrateEvent(owner, parents[i], additionHashrateMapping[owner][parents[i]]);\\n                additionHashrateMapping[owner][parents[i]] = 0;\\n            }\\n        }\\n        emit decreaseHashrateEvent(owner, amount);\\n    }\\n\\n     // \u589e\u52a0\u6d41\u52a8\u6027\\n    function _addLiquidity(address token1, address token2, uint256 tokenAmount1, uint256 tokenAmount2, address to) private {\\n        // approve token transfer to cover all possible scenarios\\n        IPancakeRouter02 r = IPancakeRouter02(router);\\n        IERC20(token1).approve(router, tokenAmount1);\\n        IERC20(token2).approve(router, tokenAmount2);\\n\\n        // add the liquidityswapExactTokensForTokensSupportingFeeOnTransferTokens\\n        r.addLiquidity(\\n            token1,\\n            token2,\\n            tokenAmount1,\\n            tokenAmount2,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            to,\\n            block.timestamp\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n\\n     function consult(address token, uint amountIn) external view returns (uint amountOut);\\n}\"\r\n    },\r\n    \"contracts/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IPancakeRouter01.sol\\\";\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/Relation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract RelationStorage {\\n\\n    struct RecommerData {\\n        uint256 ts;\\n        address addr;\\n    }\\n\\n    uint public totalAddresses;\\n    // parent node\\n    mapping (address => address) public _recommerMapping;\\n    // child node\\n    mapping (address => address[]) internal _recommerList;\\n    // child node data\\n    mapping (address => RecommerData[]) internal _recommerDataList;\\n    \\n    constructor() {\\n    }\\n}\\n\\ncontract Relation is RelationStorage() {\\n\\n    modifier onlyBoss() {\\n        require(bosses[msg.sender], \\\"Relation: caller is not the boss\\\");\\n        _;\\n    }\\n\\n    mapping(address => bool) public bosses;\\n\\n      constructor(address _boss) {\\n        bosses[_boss] = true;\\n    }\\n\\n    function addBoss(address _boss) external onlyBoss {\\n        bosses[_boss] = true;\\n    }\\n\\n    function removeBoss(address _boss) external onlyBoss {\\n        bosses[_boss] = false;\\n    }\\n\\n    // bind\\n    function addRelationEx(address slef,address recommer) external onlyBoss returns (bool) {\\n\\n        require(recommer != slef,\\\"your_self\\\");                   \\n\\n        require(_recommerMapping[slef] == address(0),\\\"binded\\\");\\n\\n        totalAddresses++;\\n\\n        _recommerMapping[slef] = recommer;\\n        _recommerList[recommer].push(slef);\\n        _recommerDataList[recommer].push(RecommerData(block.timestamp, slef));\\n        return true;\\n    }\\n\\n    // find parent\\n    function parentOf(address owner) external view returns(address){\\n        return _recommerMapping[owner];\\n    }\\n    \\n    // find parent\\n    function getForefathers(address owner,uint num) public view returns(address[] memory fathers){\\n\\n        fathers = new address[](num);\\n\\n        address parent  = owner;\\n        for( uint i = 0; i < num; i++){\\n            parent = _recommerMapping[parent];\\n\\n            if(parent == address(0) ) break;\\n\\n            fathers[i] = parent;\\n        }\\n    }\\n    \\n    // find child\\n    function childrenOf(address owner) external view returns(address[] memory){\\n        return _recommerList[owner];\\n    }\\n\\n    function childrenDataOf(address owner) external view returns (RecommerData[] memory) {\\n        return _recommerDataList[owner];\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cto\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pledge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_platform\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relation\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coo\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"}],\"name\":\"addRelationEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eacBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"name\":\"buyViaEacEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eacBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"name\":\"buyViaUsdtEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eacBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"}],\"name\":\"claimEacEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eacBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethBalance\",\"type\":\"uint256\"}],\"name\":\"claimEthEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"}],\"name\":\"decreaseHashrateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"}],\"name\":\"decreaseTeamHashrateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"}],\"name\":\"increaseHashrateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentUnit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardScale\",\"type\":\"uint256\"}],\"name\":\"increaseTeamHashrateEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EAC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeRecommendNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recommer\",\"type\":\"address\"}],\"name\":\"addRelationEx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbDistributeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"calClaimEAC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"calClaimETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calViaEac\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositEAC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eacDistributeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minerInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"hashrate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamHashrate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeForEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeForEac\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEthClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEacClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pledgeDividendsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_additionCoefficientConditions\",\"type\":\"uint256[]\"}],\"name\":\"setAdditionCoefficientConditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnbDistributeDenominator\",\"type\":\"uint256\"}],\"name\":\"setBnbDistributeDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coo\",\"type\":\"address\"}],\"name\":\"setCoo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eacDistributeDenominator\",\"type\":\"uint256\"}],\"name\":\"setEacDistributeDenominator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nodeAddress\",\"type\":\"address\"}],\"name\":\"setNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platform\",\"type\":\"address\"}],\"name\":\"setPlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pledge\",\"type\":\"address\"}],\"name\":\"setPlege\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EacMiner", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001cdd27b026f615bcc01c2194b1f0afeac83ce279000000000000000000000000079b0db8d05231f56caec48b16c4484aee1a090100000000000000000000000024551c7568a71c2db470be05ccae68cbea17b821000000000000000000000000d2aab53893af2266c131344a4f021378c1abf455000000000000000000000000c9266fdd5d2da8dccf8c3268cf3fda6a06d23d1e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}