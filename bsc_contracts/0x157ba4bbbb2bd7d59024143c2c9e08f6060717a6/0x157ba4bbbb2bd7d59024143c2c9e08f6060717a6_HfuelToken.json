{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HfuelToken.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./MintableToken.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract HfuelToken is MintableToken {\\r\\n    using SafeMath for uint256;\\r\\n    struct Stats {\\r\\n        uint256 txs;\\r\\n        uint256 minted;\\r\\n    }\\r\\n\\r\\n    string public constant name = \\\"HFuel Token\\\";\\r\\n    string public constant symbol = \\\"HFUEL\\\";\\r\\n    uint8 public constant decimals = 18;\\r\\n    uint256 public constant targetSupply = 2**256 - 1;\\r\\n    uint256 public totalTxs;\\r\\n    uint256 public players;\\r\\n    uint256 private mintedSupply_;\\r\\n\\r\\n    mapping(address => Stats) private stats;\\r\\n\\r\\n    address public vaultAddress;\\r\\n    uint8 constant internal taxDefault = 5; // 10% tax on transfers\\r\\n\\r\\n    mapping (address => uint8) private _customTaxRate;\\r\\n    mapping (address => bool) private _hasCustomTax;\\r\\n\\r\\n    mapping (address => bool) private _isExcluded;\\r\\n    address[] private _excluded;\\r\\n\\r\\n    event TaxPayed(address from, address vault, uint256 amount);\\r\\n    /**\\r\\n     * @dev default constructor\\r\\n     */\\r\\n    constructor(uint256 _initialMint) Ownable() public {\\r\\n        addAddressToWhitelist(owner);\\r\\n        mint(owner, _initialMint * 1e18);\\r\\n        removeAddressFromWhitelist(owner);\\r\\n    }\\r\\n\\r\\n    function setVaultAddress(address _newVaultAddress) public onlyOwner {\\r\\n        vaultAddress = _newVaultAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to mint tokens (onlyOwner)\\r\\n     * @param _to The address that will receive the minted tokens.\\r\\n     * @param _amount The amount of tokens to mint.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function mint(address _to, uint256 _amount) public override returns (bool) {\\r\\n\\r\\n        //Never fail, just don't mint if over\\r\\n        if (_amount == 0 || mintedSupply_.add(_amount) > targetSupply) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        //Mint\\r\\n        super.mint(_to, _amount);\\r\\n        mintedSupply_ = mintedSupply_.add(_amount);\\r\\n\\r\\n        if (mintedSupply_ == targetSupply) {\\r\\n            mintingFinished = true;\\r\\n            emit MintFinished();\\r\\n        }\\r\\n\\r\\n        /* Members */\\r\\n        if (stats[_to].txs == 0) {\\r\\n            players += 1;\\r\\n        }\\r\\n\\r\\n        stats[_to].txs += 1;\\r\\n        stats[_to].minted += _amount;\\r\\n\\r\\n        totalTxs += 1;\\r\\n\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Override so that minting cannot be accidentally terminated\\r\\n     */\\r\\n    function finishMinting() onlyOwner canMint public override returns (bool) {\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function calculateTransactionTax(uint256 _value, uint8 _tax) internal returns (uint256 adjustedValue, uint256 taxAmount){\\r\\n        taxAmount = _value.mul(_tax).div(100);\\r\\n        adjustedValue = _value.mul(SafeMath.sub(100, _tax)).div(100);\\r\\n        return (adjustedValue, taxAmount);\\r\\n    }\\r\\n\\r\\n    /** @dev Transfers (using transferFrom) */\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\\r\\n\\r\\n        (uint256 adjustedValue, uint256 taxAmount) = calculateTransferTaxes(_from, _value);\\r\\n\\r\\n        if (taxAmount > 0){\\r\\n            require(super.transferFrom(_from, vaultAddress, taxAmount));\\r\\n            emit TaxPayed(_from, vaultAddress, taxAmount);\\r\\n        }\\r\\n        require(super.transferFrom(_from, _to, adjustedValue));\\r\\n\\r\\n        /* Members */\\r\\n        if (stats[_to].txs == 0) {\\r\\n            players += 1;\\r\\n        }\\r\\n\\r\\n        stats[_to].txs += 1;\\r\\n        stats[_from].txs += 1;\\r\\n\\r\\n        totalTxs += 1;\\r\\n\\r\\n        return true;\\r\\n\\r\\n\\r\\n    }\\r\\n\\r\\n    /** @dev Transfers */\\r\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\r\\n\\r\\n        (uint256 adjustedValue, uint256 taxAmount) = calculateTransferTaxes(msg.sender, _value);\\r\\n\\r\\n        if (taxAmount > 0){\\r\\n            require(super.transfer(vaultAddress, taxAmount));\\r\\n            emit TaxPayed(msg.sender, vaultAddress, taxAmount);\\r\\n        }\\r\\n        require(super.transfer(_to, adjustedValue));\\r\\n\\r\\n        /* Members */\\r\\n        if (stats[_to].txs == 0) {\\r\\n            players += 1;\\r\\n        }\\r\\n\\r\\n        stats[_to].txs += 1;\\r\\n        stats[msg.sender].txs += 1;\\r\\n\\r\\n        totalTxs += 1;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function calculateTransferTaxes(address _from, uint256 _value) public  returns (uint256 adjustedValue, uint256 taxAmount){\\r\\n        adjustedValue = _value;\\r\\n        taxAmount = 0;\\r\\n\\r\\n        if (!_isExcluded[_from]) {\\r\\n            uint8 taxPercent = taxDefault; // set to default tax 10%\\r\\n\\r\\n            // set custom tax rate if applicable\\r\\n            if (_hasCustomTax[_from]){\\r\\n                taxPercent = _customTaxRate[_from];\\r\\n            }\\r\\n\\r\\n            (adjustedValue, taxAmount) = calculateTransactionTax(_value, taxPercent);\\r\\n        }\\r\\n        return (adjustedValue, taxAmount);\\r\\n    }\\r\\n\\r\\n    /** @dev Returns the supply still available to mint */\\r\\n    function remainingMintableSupply() public view returns (uint256) {\\r\\n        return targetSupply.sub(mintedSupply_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the cap for the token minting.\\r\\n     */\\r\\n    function cap() public view returns (uint256) {\\r\\n        return targetSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev total number of minted tokens\\r\\n    */\\r\\n    function mintedSupply() public view returns (uint256) {\\r\\n        return mintedSupply_;\\r\\n    }\\r\\n\\r\\n    /** @dev stats of player, (txs, minted) */\\r\\n    function statsOf(address player) public view returns (uint256, uint256, uint256){\\r\\n        return (balanceOf(player), stats[player].txs, stats[player].minted);\\r\\n    }\\r\\n\\r\\n    ///** @dev Returns the number of tokens minted by the player */\\r\\n    function mintedBy(address player) public view returns (uint256){\\r\\n        return stats[player].minted;\\r\\n    }\\r\\n\\r\\n    function setAccountCustomTax(address account, uint8 taxRate) external onlyOwner() {\\r\\n        require(taxRate >= 0 && taxRate <= 100, \\\"Invalid tax amount\\\");\\r\\n        _hasCustomTax[account] = true;\\r\\n        _customTaxRate[account] = taxRate;\\r\\n    }\\r\\n\\r\\n    function removeAccountCustomTax(address account) external onlyOwner() {\\r\\n        _hasCustomTax[account] = false;\\r\\n    }\\r\\n\\r\\n    function excludeAccount(address account) external onlyOwner() {\\r\\n        require(!_isExcluded[account], \\\"Account is already excluded\\\");\\r\\n        _isExcluded[account] = true;\\r\\n        _excluded.push(account);\\r\\n    }\\r\\n\\r\\n    function includeAccount(address account) external onlyOwner() {\\r\\n        require(_isExcluded[account], \\\"Account is already excluded\\\");\\r\\n        for (uint256 i = 0; i < _excluded.length; i++) {\\r\\n            if (_excluded[i] == account) {\\r\\n                _excluded[i] = _excluded[_excluded.length - 1];\\r\\n                _isExcluded[account] = false;\\r\\n                delete _excluded[_excluded.length - 1];\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isExcluded(address account) public view returns (bool) {\\r\\n        return _isExcluded[account];\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/MintableToken.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Mintable token\\r\\n * @dev Simple BEP20 Token example, with mintable token creation\\r\\n * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120\\r\\n */\\r\\n\\r\\nimport \\\"./StandardToken.sol\\\";\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\ncontract MintableToken is StandardToken, Whitelist {\\r\\n    event Mint(address indexed to, uint256 amount);\\r\\n    event MintFinished();\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    bool public mintingFinished = false;\\r\\n\\r\\n    modifier canMint() {\\r\\n        require(!mintingFinished);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to mint tokens\\r\\n     * @param _to The address that will receive the minted tokens.\\r\\n     * @param _amount The amount of tokens to mint.\\r\\n     * @return A boolean that indicates if the operation was successful.\\r\\n     */\\r\\n    function mint(address _to, uint256 _amount) onlyWhitelisted canMint virtual public returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        totalSupply_ = totalSupply_.add(_amount);\\r\\n        balances[_to] = balances[_to].add(_amount);\\r\\n        emit Mint(_to, _amount);\\r\\n        emit Transfer(address(0), _to, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to stop minting new tokens.\\r\\n     * @return True if the operation was successful.\\r\\n     */\\r\\n    function finishMinting() onlyWhitelisted canMint public virtual returns (bool) {\\r\\n        mintingFinished = true;\\r\\n        emit MintFinished();\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Multiplies two numbers, throws on overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        c = a * b;\\r\\n        assert(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Integer division of two numbers, truncating the quotient.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\r\\n        // uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        assert(b <= a);\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /* @dev Subtracts two numbers, else returns zero */\\r\\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (b > a) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds two numbers, throws on overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n        c = a + b;\\r\\n        assert(c >= a);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a >= b ? a : b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/StandardToken.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n/**\\r\\n * @title Standard BEP20 token\\r\\n *\\r\\n * @dev Implementation of the basic standard token.\\r\\n * @dev https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\n\\r\\nimport \\\"./BEP20.sol\\\";\\r\\nimport \\\"./BasicToken.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\ncontract StandardToken is BEP20, BasicToken {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    mapping(address => mapping(address => uint256)) internal allowed;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer tokens from one address to another\\r\\n     * @param _from address The address which you want to send tokens from\\r\\n     * @param _to address The address which you want to transfer to\\r\\n     * @param _value uint256 the amount of tokens to be transferred\\r\\n     */\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public override virtual returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        require(_value <= balances[_from]);\\r\\n        require(_value <= allowed[_from][msg.sender]);\\r\\n        \\r\\n        balances[_from] = balances[_from].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n        emit Transfer(_from, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n     *\\r\\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     * @param _spender The address which will spend the funds.\\r\\n     * @param _value The amount of tokens to be spent.\\r\\n     */\\r\\n    function approve(address _spender, uint256 _value) public override returns (bool) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\\r\\n     * @param _owner address The address which owns the funds.\\r\\n     * @param _spender address The address which will spend the funds.\\r\\n     * @return A uint256 specifying the amount of tokens still available for the spender.\\r\\n     */\\r\\n    function allowance(address _owner, address _spender) public view override returns (uint256) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\\r\\n     *\\r\\n     * approve should be called when allowed[_spender] == 0. To increment\\r\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n     * the first transaction is mined)\\r\\n     * From MonolithDAO Token.sol\\r\\n     * @param _spender The address which will spend the funds.\\r\\n     * @param _addedValue The amount of tokens to increase the allowance by.\\r\\n     */\\r\\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\\r\\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\r\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\\r\\n     *\\r\\n     * approve should be called when allowed[_spender] == 0. To decrement\\r\\n     * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n     * the first transaction is mined)\\r\\n     * From MonolithDAO Token.sol\\r\\n     * @param _spender The address which will spend the funds.\\r\\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\\r\\n     */\\r\\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\\r\\n        uint oldValue = allowed[msg.sender][_spender];\\r\\n        if (_subtractedValue > oldValue) {\\r\\n            allowed[msg.sender][_spender] = 0;\\r\\n        } else {\\r\\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/Whitelist.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\ncontract Whitelist is Ownable {\\r\\n    mapping(address => bool) public whitelist;\\r\\n\\r\\n    event WhitelistedAddressAdded(address addr);\\r\\n    event WhitelistedAddressRemoved(address addr);\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account that's not whitelisted.\\r\\n     */\\r\\n    modifier onlyWhitelisted() {\\r\\n        require(whitelist[msg.sender], 'not whitelisted');\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add an address to the whitelist\\r\\n     * @param addr address\\r\\n     * @return success true if the address was added to the whitelist, false if the address was already in the whitelist\\r\\n     */\\r\\n    function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\\r\\n        if (!whitelist[addr]) {\\r\\n            whitelist[addr] = true;\\r\\n            emit WhitelistedAddressAdded(addr);\\r\\n            success = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev add addresses to the whitelist\\r\\n     * @param addrs addresses\\r\\n     * @return success true if at least one address was added to the whitelist,\\r\\n     * false if all addresses were already in the whitelist\\r\\n     */\\r\\n    function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\\r\\n        for (uint256 i = 0; i < addrs.length; i++) {\\r\\n            if (addAddressToWhitelist(addrs[i])) {\\r\\n                success = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove an address from the whitelist\\r\\n     * @param addr address\\r\\n     * @return success true if the address was removed from the whitelist,\\r\\n     * false if the address wasn't in the whitelist in the first place\\r\\n     */\\r\\n    function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\\r\\n        if (whitelist[addr]) {\\r\\n            whitelist[addr] = false;\\r\\n            emit WhitelistedAddressRemoved(addr);\\r\\n            success = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev remove addresses from the whitelist\\r\\n     * @param addrs addresses\\r\\n     * @return success successtrue if at least one address was removed from the whitelist,\\r\\n     * false if all addresses weren't in the whitelist in the first place\\r\\n     */\\r\\n    function removeAddressesFromWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\\r\\n        for (uint256 i = 0; i < addrs.length; i++) {\\r\\n            if (removeAddressFromWhitelist(addrs[i])) {\\r\\n                success = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/BEP20.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n/**\\r\\n * @title BEP20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\n\\r\\n import \\\"./BEP20Basic.sol\\\";\\r\\n\\r\\nabstract contract BEP20 is BEP20Basic {\\r\\n    function allowance(address owner, address spender) public virtual view returns (uint256);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value) public virtual returns (bool);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/BasicToken.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n/**\\r\\n * @title Basic token\\r\\n * @dev Basic version of StandardToken, with no allowances.\\r\\n */\\r\\n\\r\\n import \\\"./BEP20Basic.sol\\\";\\r\\n import \\\"./SafeMath.sol\\\";\\r\\ncontract BasicToken is BEP20Basic {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) balances;\\r\\n\\r\\n    uint256 totalSupply_;\\r\\n\\r\\n    /**\\r\\n    * @dev total number of tokens in existence\\r\\n    */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return totalSupply_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev transfer token for a specified address\\r\\n    * @param _to The address to transfer to.\\r\\n    * @param _value The amount to be transferred.\\r\\n    */\\r\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\r\\n        require(_to != address(0));\\r\\n        require(_value <= balances[msg.sender]);\\r\\n\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @dev Gets the balance of the specified address.\\r\\n    * @param _owner The address to query the the balance of.\\r\\n    * @return An uint256 representing the amount owned by the passed address.\\r\\n    */\\r\\n    function balanceOf(address _owner) public view override returns (uint256) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/BEP20Basic.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface BEP20Basic {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"/*\\r\\n    SPDX-License-Identifier: MIT\\r\\n    SideKick Finance\\r\\n    High Net Worth\\r\\n    Copyright 2022\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n    address public owner;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n     * account.\\r\\n     */\\r\\n    constructor() public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n     * @param newOwner The address to transfer ownership to.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialMint\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TaxPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateTransferTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"adjustedValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"mintedBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingMintableSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAccountCustomTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"taxRate\",\"type\":\"uint8\"}],\"name\":\"setAccountCustomTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVaultAddress\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HfuelToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}