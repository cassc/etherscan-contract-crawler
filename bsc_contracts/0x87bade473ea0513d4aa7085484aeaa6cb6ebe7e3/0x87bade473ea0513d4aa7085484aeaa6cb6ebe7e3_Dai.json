{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// DssDeploy.sol\r\n\r\n// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.12;\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        virtual\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        virtual\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(address(0))) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue()\r\n        }\r\n\r\n        _;\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n    }\r\n}\r\n\r\ncontract DSPause is DSAuth, DSNote {\r\n\r\n    // --- admin ---\r\n\r\n    modifier wait { require(msg.sender == address(proxy), \"ds-pause-undelayed-call\"); _; }\r\n\r\n    function setOwner(address owner_) public override wait {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n    function setAuthority(DSAuthority authority_) public override wait {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n    function setDelay(uint delay_) public note wait {\r\n        delay = delay_;\r\n    }\r\n\r\n    // --- math ---\r\n\r\n    function _add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x, \"ds-pause-addition-overflow\");\r\n    }\r\n\r\n    // --- data ---\r\n\r\n    mapping (bytes32 => bool) public plans;\r\n    DSPauseProxy public proxy;\r\n    uint         public delay;\r\n\r\n    // --- init ---\r\n\r\n    constructor(uint delay_, address owner_, DSAuthority authority_) public {\r\n        delay = delay_;\r\n        owner = owner_;\r\n        authority = authority_;\r\n        proxy = new DSPauseProxy();\r\n    }\r\n\r\n    // --- util ---\r\n\r\n    function hash(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        internal pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(usr, tag, fax, eta));\r\n    }\r\n\r\n    function soul(address usr)\r\n        internal view\r\n        returns (bytes32 tag)\r\n    {\r\n        assembly { tag := extcodehash(usr) }\r\n    }\r\n\r\n    // --- operations ---\r\n\r\n    function plot(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note auth\r\n    {\r\n        require(eta >= _add(now, delay), \"ds-pause-delay-not-respected\");\r\n        plans[hash(usr, tag, fax, eta)] = true;\r\n    }\r\n\r\n    function drop(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note auth\r\n    {\r\n        plans[hash(usr, tag, fax, eta)] = false;\r\n    }\r\n\r\n    function exec(address usr, bytes32 tag, bytes memory fax, uint eta)\r\n        public note\r\n        returns (bytes memory out)\r\n    {\r\n        require(plans[hash(usr, tag, fax, eta)], \"ds-pause-unplotted-plan\");\r\n        require(soul(usr) == tag,                \"ds-pause-wrong-codehash\");\r\n        require(now >= eta,                      \"ds-pause-premature-exec\");\r\n\r\n        plans[hash(usr, tag, fax, eta)] = false;\r\n\r\n        out = proxy.exec(usr, fax);\r\n        require(proxy.owner() == address(this), \"ds-pause-illegal-storage-change\");\r\n    }\r\n}\r\n\r\n// plans are executed in an isolated storage context to protect the pause from\r\n// malicious storage modification during plan execution\r\ncontract DSPauseProxy {\r\n    address public owner;\r\n    modifier auth { require(msg.sender == owner, \"ds-pause-proxy-unauthorized\"); _; }\r\n    constructor() public { owner = msg.sender; }\r\n\r\n    function exec(address usr, bytes memory fax)\r\n        public auth\r\n        returns (bytes memory out)\r\n    {\r\n        bool ok;\r\n        (ok, out) = usr.delegatecall(fax);\r\n        require(ok, \"ds-pause-delegatecall-error\");\r\n    }\r\n}\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSToken is DSMath, DSAuth {\r\n    bool                                              public  stopped;\r\n    uint256                                           public  totalSupply;\r\n    mapping (address => uint256)                      public  balanceOf;\r\n    mapping (address => mapping (address => uint256)) public  allowance;\r\n    string                                            public  symbol;\r\n    uint8                                             public  decimals = 18; // standard token precision. override to customize\r\n    string                                            public  name = \"\";     // Optional token name\r\n\r\n\r\n    constructor(string memory symbol_) public {\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n    event Stop();\r\n    event Start();\r\n\r\n    modifier stoppable {\r\n        require(!stopped, \"ds-stop-is-stopped\");\r\n        _;\r\n    }\r\n\r\n    function approve(address guy) external returns (bool) {\r\n        return approve(guy, uint(-1));\r\n    }\r\n\r\n    function approve(address guy, uint wad) public stoppable returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        stoppable\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n\r\n        require(balanceOf[src] >= wad, \"ds-token-insufficient-balance\");\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    function push(address dst, uint wad) external {\r\n        transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function pull(address src, uint wad) external {\r\n        transferFrom(src, msg.sender, wad);\r\n    }\r\n\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n    */\r\n\r\n\r\n    function mint(uint wad) external {\r\n        mint(msg.sender, wad);\r\n    }\r\n\r\n    function burn(uint wad) external {\r\n        burn(msg.sender, wad);\r\n    }\r\n\r\n    function mint(address guy, uint wad) public auth stoppable {\r\n        balanceOf[guy] = add(balanceOf[guy], wad);\r\n        totalSupply = add(totalSupply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n\r\n    function burn(address guy, uint wad) public auth stoppable {\r\n        if (guy != msg.sender && allowance[guy][msg.sender] != uint(-1)) {\r\n            require(allowance[guy][msg.sender] >= wad, \"ds-token-insufficient-approval\");\r\n            allowance[guy][msg.sender] = sub(allowance[guy][msg.sender], wad);\r\n        }\r\n\r\n        require(balanceOf[guy] >= wad, \"ds-token-insufficient-balance\");\r\n        balanceOf[guy] = sub(balanceOf[guy], wad);\r\n        totalSupply = sub(totalSupply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n\r\n    function stop() public auth {\r\n        stopped = true;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() public auth {\r\n        stopped = false;\r\n        emit Start();\r\n    }\r\n\r\n\r\n    function setName(string memory name_) public auth {\r\n        name = name_;\r\n    }\r\n}\r\n\r\ncontract Vat is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 1; }\r\n    function deny(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    mapping(address => mapping (address => uint)) public can;\r\n    function hope(address usr) external note { can[msg.sender][usr] = 1; }\r\n    function nope(address usr) external note { can[msg.sender][usr] = 0; }\r\n    function wish(address bit, address usr) internal view returns (bool) {\r\n        return either(bit == usr, can[bit][usr] == 1);\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 Art;   // Total Normalised Debt     [wad]\r\n        uint256 rate;  // Accumulated Rates         [ray]\r\n        uint256 spot;  // Price with Safety Margin  [ray]\r\n        uint256 line;  // Debt Ceiling              [rad]\r\n        uint256 dust;  // Urn Debt Floor            [rad]\r\n    }\r\n    struct Urn {\r\n        uint256 ink;   // Locked Collateral  [wad]\r\n        uint256 art;   // Normalised Debt    [wad]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk)                       public ilks;\r\n    mapping (bytes32 => mapping (address => Urn )) public urns;\r\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\r\n    mapping (address => uint256)                   public dai;  // [rad]\r\n    mapping (address => uint256)                   public sin;  // [rad]\r\n\r\n    uint256 public debt;  // Total Dai Issued    [rad]\r\n    uint256 public vice;  // Total Unbacked Dai  [rad]\r\n    uint256 public Line;  // Total Debt Ceiling  [rad]\r\n    uint256 public live;  // Active Flag\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function _add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function _sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function _mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function _add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function _sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function _mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function init(bytes32 ilk) external note auth {\r\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\r\n        ilks[ilk].rate = 10 ** 27;\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Vat/not-live\");\r\n        if (what == \"Line\") Line = data;\r\n        else revert(\"Vat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Vat/not-live\");\r\n        if (what == \"spot\") ilks[ilk].spot = data;\r\n        else if (what == \"line\") ilks[ilk].line = data;\r\n        else if (what == \"dust\") ilks[ilk].dust = data;\r\n        else revert(\"Vat/file-unrecognized-param\");\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n\r\n    // --- Fungibility ---\r\n    function slip(bytes32 ilk, address usr, int256 wad) external note auth {\r\n        gem[ilk][usr] = _add(gem[ilk][usr], wad);\r\n    }\r\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external note {\r\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\r\n        gem[ilk][src] = _sub(gem[ilk][src], wad);\r\n        gem[ilk][dst] = _add(gem[ilk][dst], wad);\r\n    }\r\n    function move(address src, address dst, uint256 rad) external note {\r\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\r\n        dai[src] = _sub(dai[src], rad);\r\n        dai[dst] = _add(dai[dst], rad);\r\n    }\r\n\r\n    function either(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := or(x, y)}\r\n    }\r\n    function both(bool x, bool y) internal pure returns (bool z) {\r\n        assembly{ z := and(x, y)}\r\n    }\r\n\r\n    // --- CDP Manipulation ---\r\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external note {\r\n        // system is live\r\n        require(live == 1, \"Vat/not-live\");\r\n\r\n        Urn memory urn = urns[i][u];\r\n        Ilk memory ilk = ilks[i];\r\n        // ilk has been initialised\r\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\r\n\r\n        urn.ink = _add(urn.ink, dink);\r\n        urn.art = _add(urn.art, dart);\r\n        ilk.Art = _add(ilk.Art, dart);\r\n\r\n        int dtab = _mul(ilk.rate, dart);\r\n        uint tab = _mul(ilk.rate, urn.art);\r\n        debt     = _add(debt, dtab);\r\n\r\n        // either debt has decreased, or debt ceilings are not exceeded\r\n        require(either(dart <= 0, both(_mul(ilk.Art, ilk.rate) <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\r\n        // urn is either less risky than before, or it is safe\r\n        require(either(both(dart <= 0, dink >= 0), tab <= _mul(urn.ink, ilk.spot)), \"Vat/not-safe\");\r\n\r\n        // urn is either more safe, or the owner consents\r\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\r\n        // collateral src consents\r\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\r\n        // debt dst consents\r\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\r\n\r\n        // urn has no debt, or a non-dusty amount\r\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\r\n\r\n        gem[i][v] = _sub(gem[i][v], dink);\r\n        dai[w]    = _add(dai[w],    dtab);\r\n\r\n        urns[i][u] = urn;\r\n        ilks[i]    = ilk;\r\n    }\r\n    // --- CDP Fungibility ---\r\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external note {\r\n        Urn storage u = urns[ilk][src];\r\n        Urn storage v = urns[ilk][dst];\r\n        Ilk storage i = ilks[ilk];\r\n\r\n        u.ink = _sub(u.ink, dink);\r\n        u.art = _sub(u.art, dart);\r\n        v.ink = _add(v.ink, dink);\r\n        v.art = _add(v.art, dart);\r\n\r\n        uint utab = _mul(u.art, i.rate);\r\n        uint vtab = _mul(v.art, i.rate);\r\n\r\n        // both sides consent\r\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\r\n\r\n        // both sides safe\r\n        require(utab <= _mul(u.ink, i.spot), \"Vat/not-safe-src\");\r\n        require(vtab <= _mul(v.ink, i.spot), \"Vat/not-safe-dst\");\r\n\r\n        // both sides non-dusty\r\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\r\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\r\n    }\r\n    // --- CDP Confiscation ---\r\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external note auth {\r\n        Urn storage urn = urns[i][u];\r\n        Ilk storage ilk = ilks[i];\r\n\r\n        urn.ink = _add(urn.ink, dink);\r\n        urn.art = _add(urn.art, dart);\r\n        ilk.Art = _add(ilk.Art, dart);\r\n\r\n        int dtab = _mul(ilk.rate, dart);\r\n\r\n        gem[i][v] = _sub(gem[i][v], dink);\r\n        sin[w]    = _sub(sin[w],    dtab);\r\n        vice      = _sub(vice,      dtab);\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function heal(uint rad) external note {\r\n        address u = msg.sender;\r\n        sin[u] = _sub(sin[u], rad);\r\n        dai[u] = _sub(dai[u], rad);\r\n        vice   = _sub(vice,   rad);\r\n        debt   = _sub(debt,   rad);\r\n    }\r\n    function suck(address u, address v, uint rad) external note auth {\r\n        sin[u] = _add(sin[u], rad);\r\n        dai[v] = _add(dai[v], rad);\r\n        vice   = _add(vice,   rad);\r\n        debt   = _add(debt,   rad);\r\n    }\r\n\r\n    // --- Rates ---\r\n    function fold(bytes32 i, address u, int rate) external note auth {\r\n        require(live == 1, \"Vat/not-live\");\r\n        Ilk storage ilk = ilks[i];\r\n        ilk.rate = _add(ilk.rate, rate);\r\n        int rad  = _mul(ilk.Art, rate);\r\n        dai[u]   = _add(dai[u], rad);\r\n        debt     = _add(debt,   rad);\r\n    }\r\n}\r\n\r\ncontract Jug is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Jug/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        uint256 duty;  // Collateral-specific, per-second stability fee contribution [ray]\r\n        uint256  rho;  // Time of last drip [unix epoch time]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n    Vat                      public vat;   // CDP Engine\r\n    address                  public vow;   // Debt Engine\r\n    uint256                  public base;  // Global, per-second stability fee contribution [ray]\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = Vat(vat_);\r\n    }\r\n\r\n    // --- Math ---\r\n    function rpow(uint x, uint n, uint b) internal pure returns (uint z) {\r\n      assembly {\r\n        switch x case 0 {switch n case 0 {z := b} default {z := 0}}\r\n        default {\r\n          switch mod(n, 2) case 0 { z := b } default { z := x }\r\n          let half := div(b, 2)  // for rounding.\r\n          for { n := div(n, 2) } n { n := div(n,2) } {\r\n            let xx := mul(x, x)\r\n            if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n            let xxRound := add(xx, half)\r\n            if lt(xxRound, xx) { revert(0,0) }\r\n            x := div(xxRound, b)\r\n            if mod(n,2) {\r\n              let zx := mul(z, x)\r\n              if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n              let zxRound := add(zx, half)\r\n              if lt(zxRound, zx) { revert(0,0) }\r\n              z := div(zxRound, b)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    uint256 constant ONE = 10 ** 27;\r\n    function _add(uint x, uint y) internal pure returns (uint z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function diff(uint x, uint y) internal pure returns (int z) {\r\n        z = int(x) - int(y);\r\n        require(int(x) >= 0 && int(y) >= 0);\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / ONE;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function init(bytes32 ilk) external note auth {\r\n        Ilk storage i = ilks[ilk];\r\n        require(i.duty == 0, \"Jug/ilk-already-init\");\r\n        i.duty = ONE;\r\n        i.rho  = now;\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(now == ilks[ilk].rho, \"Jug/rho-not-updated\");\r\n        if (what == \"duty\") ilks[ilk].duty = data;\r\n        else revert(\"Jug/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"base\") base = data;\r\n        else revert(\"Jug/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \"vow\") vow = data;\r\n        else revert(\"Jug/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Stability Fee Collection ---\r\n    function drip(bytes32 ilk) external note returns (uint rate) {\r\n        require(now >= ilks[ilk].rho, \"Jug/invalid-now\");\r\n        (, uint prev,,,) = vat.ilks(ilk);\r\n        rate = rmul(rpow(_add(base, ilks[ilk].duty), now - ilks[ilk].rho, ONE), prev);\r\n        vat.fold(ilk, vow, diff(rate, prev));\r\n        ilks[ilk].rho = now;\r\n    }\r\n}\r\n\r\ninterface PipLike {\r\n    function peek() external view returns (bytes32, bool);\r\n    function read() external view returns (bytes32);\r\n}\r\n\r\ncontract Spotter is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1;  }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Spotter/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        PipLike pip;  // Price Feed\r\n        uint256 mat;  // Liquidation ratio [ray]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    Vat     public vat;  // CDP Engine\r\n    uint256 public par;  // ref per dai [ray]\r\n\r\n    uint256 public live;\r\n\r\n    // --- Events ---\r\n    event Poke(\r\n      bytes32 ilk,\r\n      bytes32 val,  // [wad]\r\n      uint256 spot  // [ray]\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = Vat(vat_);\r\n        par = ONE;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint constant ONE = 10 ** 27;\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = mul(x, ONE) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 ilk, bytes32 what, address pip_) external note auth {\r\n        require(live == 1, \"Spotter/not-live\");\r\n        if (what == \"pip\") ilks[ilk].pip = PipLike(pip_);\r\n        else revert(\"Spotter/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Spotter/not-live\");\r\n        if (what == \"par\") par = data;\r\n        else revert(\"Spotter/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\r\n        require(live == 1, \"Spotter/not-live\");\r\n        if (what == \"mat\") ilks[ilk].mat = data;\r\n        else revert(\"Spotter/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Update value ---\r\n    function poke(bytes32 ilk) external {\r\n        (bytes32 val, bool has) = ilks[ilk].pip.peek();\r\n        uint256 spot = has ? rdiv(rdiv(mul(uint(val), 10 ** 9), par), ilks[ilk].mat) : 0;\r\n        vat.file(ilk, \"spot\", spot);\r\n        emit Poke(ilk, val, spot);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n}\r\n\r\n/*\r\n   \"Savings Dai\" is obtained when Dai is deposited into\r\n   this contract. Each \"Savings Dai\" accrues Dai interest\r\n   at the \"Dai Savings Rate\".\r\n\r\n   This contract does not implement a user tradeable token\r\n   and is intended to be used with adapters.\r\n\r\n         --- `save` your `dai` in the `pot` ---\r\n\r\n   - `dsr`: the Dai Savings Rate\r\n   - `pie`: user balance of Savings Dai\r\n\r\n   - `join`: start saving some dai\r\n   - `exit`: remove some dai\r\n   - `drip`: perform rate collection\r\n\r\n*/\r\n\r\ncontract Pot is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Pot/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    mapping (address => uint256) public pie;  // Normalised Savings Dai [wad]\r\n\r\n    uint256 public Pie;   // Total Normalised Savings Dai  [wad]\r\n    uint256 public dsr;   // The Dai Savings Rate          [ray]\r\n    uint256 public chi;   // The Rate Accumulator          [ray]\r\n\r\n    Vat     public vat;   // CDP Engine\r\n    address public vow;   // Debt Engine\r\n    uint256 public rho;   // Time of last drip     [unix epoch time]\r\n\r\n    uint256 public live;  // Active Flag\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = Vat(vat_);\r\n        dsr = ONE;\r\n        chi = ONE;\r\n        rho = now;\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant ONE = 10 ** 27;\r\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\r\n        assembly {\r\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\r\n            default {\r\n                switch mod(n, 2) case 0 { z := base } default { z := x }\r\n                let half := div(base, 2)  // for rounding.\r\n                for { n := div(n, 2) } n { n := div(n,2) } {\r\n                    let xx := mul(x, x)\r\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\r\n                    let xxRound := add(xx, half)\r\n                    if lt(xxRound, xx) { revert(0,0) }\r\n                    x := div(xxRound, base)\r\n                    if mod(n,2) {\r\n                        let zx := mul(z, x)\r\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                        let zxRound := add(zx, half)\r\n                        if lt(zxRound, zx) { revert(0,0) }\r\n                        z := div(zxRound, base)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = _mul(x, y) / ONE;\r\n    }\r\n\r\n    function _add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function _sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function _mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        require(live == 1, \"Pot/not-live\");\r\n        require(now == rho, \"Pot/rho-not-updated\");\r\n        if (what == \"dsr\") dsr = data;\r\n        else revert(\"Pot/file-unrecognized-param\");\r\n    }\r\n\r\n    function file(bytes32 what, address addr) external note auth {\r\n        if (what == \"vow\") vow = addr;\r\n        else revert(\"Pot/file-unrecognized-param\");\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n        dsr = ONE;\r\n    }\r\n\r\n    // --- Savings Rate Accumulation ---\r\n    function drip() external note returns (uint tmp) {\r\n        require(now >= rho, \"Pot/invalid-now\");\r\n        tmp = rmul(rpow(dsr, now - rho, ONE), chi);\r\n        uint chi_ = _sub(tmp, chi);\r\n        chi = tmp;\r\n        rho = now;\r\n        vat.suck(address(vow), address(this), _mul(Pie, chi_));\r\n    }\r\n\r\n    // --- Savings Dai Management ---\r\n    function join(uint wad) external note {\r\n        require(now == rho, \"Pot/rho-not-updated\");\r\n        pie[msg.sender] = _add(pie[msg.sender], wad);\r\n        Pie             = _add(Pie,             wad);\r\n        vat.move(msg.sender, address(this), _mul(chi, wad));\r\n    }\r\n\r\n    function exit(uint wad) external note {\r\n        pie[msg.sender] = _sub(pie[msg.sender], wad);\r\n        Pie             = _sub(Pie,             wad);\r\n        vat.move(address(this), msg.sender, _mul(chi, wad));\r\n    }\r\n}\r\n\r\ncontract Dai is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address guy) external note auth { wards[guy] = 1; }\r\n    function deny(address guy) external note auth { wards[guy] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Dai/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- ERC20 Data ---\r\n    string  public constant name     = \"Mor Stablecoin\";\r\n    string  public constant symbol   = \"MOR\";\r\n    string  public constant version  = \"1\";\r\n    uint8   public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint)                      public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint)                      public nonces;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    // --- EIP712 niceties ---\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n\r\n    constructor(uint256 chainId_) public {\r\n        wards[msg.sender] = 1;\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n            keccak256(bytes(name)),\r\n            keccak256(bytes(version)),\r\n            chainId_,\r\n            address(this)\r\n        ));\r\n    }\r\n\r\n    // --- Token ---\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\r\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\r\n        }\r\n        balanceOf[src] = sub(balanceOf[src], wad);\r\n        balanceOf[dst] = add(balanceOf[dst], wad);\r\n        emit Transfer(src, dst, wad);\r\n        return true;\r\n    }\r\n    function mint(address usr, uint wad) external auth {\r\n        balanceOf[usr] = add(balanceOf[usr], wad);\r\n        totalSupply    = add(totalSupply, wad);\r\n        emit Transfer(address(0), usr, wad);\r\n    }\r\n    function burn(address usr, uint wad) external {\r\n        require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\r\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\r\n            require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\r\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\r\n        }\r\n        balanceOf[usr] = sub(balanceOf[usr], wad);\r\n        totalSupply    = sub(totalSupply, wad);\r\n        emit Transfer(usr, address(0), wad);\r\n    }\r\n    function approve(address usr, uint wad) external returns (bool) {\r\n        allowance[msg.sender][usr] = wad;\r\n        emit Approval(msg.sender, usr, wad);\r\n        return true;\r\n    }\r\n\r\n    // --- Alias ---\r\n    /*\r\n    function push(address usr, uint wad) external {\r\n        transferFrom(msg.sender, usr, wad);\r\n    }\r\n    function pull(address usr, uint wad) external {\r\n        transferFrom(usr, msg.sender, wad);\r\n    }\r\n    function move(address src, address dst, uint wad) external {\r\n        transferFrom(src, dst, wad);\r\n    }\r\n    */\r\n\r\n    // --- Approve by signature ---\r\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\r\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\r\n    {\r\n        bytes32 digest =\r\n            keccak256(abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH,\r\n                                     holder,\r\n                                     spender,\r\n                                     nonce,\r\n                                     expiry,\r\n                                     allowed))\r\n        ));\r\n\r\n        require(holder != address(0), \"Dai/invalid-address-0\");\r\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\r\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\r\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\r\n        uint wad = allowed ? uint(-1) : 0;\r\n        allowance[holder][spender] = wad;\r\n        emit Approval(holder, spender, wad);\r\n    }\r\n}\r\n\r\n/*\r\n    Here we provide *adapters* to connect the Vat to arbitrary external\r\n    token implementations, creating a bounded context for the Vat. The\r\n    adapters here are provided as working examples:\r\n\r\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\r\n                   semantics.\r\n\r\n      - `ETHJoin`: For native Ether.\r\n\r\n      - `DaiJoin`: For connecting internal Dai balances to an external\r\n                   `DSToken` implementation.\r\n\r\n    In practice, adapter implementations will be varied and specific to\r\n    individual collateral types, accounting for different transfer\r\n    semantics and token standards.\r\n\r\n    Adapters need to implement two basic methods:\r\n\r\n      - `join`: enter collateral into the system\r\n      - `exit`: remove collateral from the system\r\n\r\n*/\r\n\r\ncontract GemJoin is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"GemJoin/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    Vat     public vat;   // CDP Engine\r\n    bytes32 public ilk;   // Collateral Type\r\n    DSToken public gem;\r\n    uint    public dec;\r\n    uint    public live;  // Active Flag\r\n\r\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = Vat(vat_);\r\n        ilk = ilk_;\r\n        gem = DSToken(gem_);\r\n        dec = gem.decimals();\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        require(live == 1, \"GemJoin/not-live\");\r\n        require(int(wad) >= 0, \"GemJoin/overflow\");\r\n        vat.slip(ilk, usr, int(wad));\r\n        require(gem.transferFrom(msg.sender, address(this), wad), \"GemJoin/failed-transfer\");\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(wad <= 2 ** 255, \"GemJoin/overflow\");\r\n        vat.slip(ilk, msg.sender, -int(wad));\r\n        require(gem.transfer(usr, wad), \"GemJoin/failed-transfer\");\r\n    }\r\n}\r\n\r\ncontract DaiJoin is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"DaiJoin/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    Vat     public vat;  // CDP Engine\r\n    Dai     public dai;  // Stablecoin Token\r\n    uint    public live; // Active Flag\r\n\r\n    constructor(address vat_, address dai_) public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        vat = Vat(vat_);\r\n        dai = Dai(dai_);\r\n    }\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n    uint constant ONE = 10 ** 27;\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function join(address usr, uint wad) external note {\r\n        vat.move(address(this), usr, mul(ONE, wad));\r\n        dai.burn(msg.sender, wad);\r\n    }\r\n    function exit(address usr, uint wad) external note {\r\n        require(live == 1, \"DaiJoin/not-live\");\r\n        vat.move(msg.sender, address(this), mul(ONE, wad));\r\n        dai.mint(usr, wad);\r\n    }\r\n}\r\n\r\n/*\r\n   This thing lets you sell some dai in return for gems.\r\n\r\n - `lot` dai in return for bid\r\n - `bid` gems paid\r\n - `ttl` single bid lifetime\r\n - `beg` minimum bid increase\r\n - `end` max auction duration\r\n*/\r\n\r\ncontract Flapper is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Flapper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;  // gems paid               [wad]\r\n        uint256 lot;  // dai in return for bid   [rad]\r\n        address guy;  // high bidder\r\n        uint48  tic;  // bid expiry time         [unix epoch time]\r\n        uint48  end;  // auction expiry time     [unix epoch time]\r\n    }\r\n\r\n    mapping (uint => Bid) public bids;\r\n\r\n    Vat      public   vat;  // CDP Engine\r\n    DSToken  public   gem;\r\n\r\n    uint256  constant ONE = 1.00E18;\r\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint48   public   ttl = 3 hours;  // 3 hours bid duration         [seconds]\r\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\r\n    uint256  public kicks = 0;\r\n    uint256  public live;  // Active Flag\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = Vat(vat_);\r\n        gem = DSToken(gem_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"beg\") beg = data;\r\n        else if (what == \"ttl\") ttl = uint48(data);\r\n        else if (what == \"tau\") tau = uint48(data);\r\n        else revert(\"Flapper/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(uint lot, uint bid) external auth returns (uint id) {\r\n        require(live == 1, \"Flapper/not-live\");\r\n        require(kicks < uint(-1), \"Flapper/overflow\");\r\n        id = ++kicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = msg.sender;  // configurable??\r\n        bids[id].end = add(uint48(now), tau);\r\n\r\n        vat.move(msg.sender, address(this), lot);\r\n\r\n        emit Kick(id, lot, bid);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end < now, \"Flapper/not-finished\");\r\n        require(bids[id].tic == 0, \"Flapper/bid-already-placed\");\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function tend(uint id, uint lot, uint bid) external note {\r\n        require(live == 1, \"Flapper/not-live\");\r\n        require(bids[id].guy != address(0), \"Flapper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flapper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flapper/already-finished-end\");\r\n\r\n        require(lot == bids[id].lot, \"Flapper/lot-not-matching\");\r\n        require(bid >  bids[id].bid, \"Flapper/bid-not-higher\");\r\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid), \"Flapper/insufficient-increase\");\r\n\r\n        if (msg.sender != bids[id].guy) {\r\n            gem.transferFrom(msg.sender, bids[id].guy, bids[id].bid);\r\n            bids[id].guy = msg.sender;\r\n        }\r\n        gem.transferFrom(msg.sender, address(this), bid - bids[id].bid);\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(live == 1, \"Flapper/not-live\");\r\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flapper/not-finished\");\r\n        vat.move(address(this), bids[id].guy, bids[id].lot);\r\n        uint256 bid = bids[id].bid;\r\n        try gem.burn(bid) {} catch { gem.transfer(address(0xdead), bid); }\r\n        delete bids[id];\r\n    }\r\n\r\n    function cage(uint rad) external note auth {\r\n       live = 0;\r\n       vat.move(address(this), msg.sender, rad);\r\n    }\r\n    function yank(uint id) external note {\r\n        require(live == 0, \"Flapper/still-live\");\r\n        require(bids[id].guy != address(0), \"Flapper/guy-not-set\");\r\n        gem.transferFrom(address(this), bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\n/*\r\n   This thing creates gems on demand in return for dai.\r\n\r\n - `lot` gems in return for bid\r\n - `bid` dai paid\r\n - `gal` receives dai income\r\n - `ttl` single bid lifetime\r\n - `beg` minimum bid increase\r\n - `end` max auction duration\r\n*/\r\n\r\ncontract Flopper is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Flopper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;  // dai paid                [rad]\r\n        uint256 lot;  // gems in return for bid  [wad]\r\n        address guy;  // high bidder\r\n        uint48  tic;  // bid expiry time         [unix epoch time]\r\n        uint48  end;  // auction expiry time     [unix epoch time]\r\n    }\r\n\r\n    mapping (uint => Bid) public bids;\r\n\r\n    Vat      public   vat;  // CDP Engine\r\n    DSToken  public   gem;\r\n\r\n    uint256  constant ONE = 1.00E18;\r\n    uint256  public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint256  public   pad = 1.50E18;  // 50% lot increase for tick\r\n    uint48   public   ttl = 3 hours;  // 3 hours bid lifetime         [seconds]\r\n    uint48   public   tau = 2 days;   // 2 days total auction length  [seconds]\r\n    uint256  public kicks = 0;\r\n    uint256  public live;             // Active Flag\r\n    address  public vow;              // not used until shutdown\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid,\r\n      address indexed gal\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address gem_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = Vat(vat_);\r\n        gem = DSToken(gem_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        if (x > y) { z = y; } else { z = x; }\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"beg\") beg = data;\r\n        else if (what == \"pad\") pad = data;\r\n        else if (what == \"ttl\") ttl = uint48(data);\r\n        else if (what == \"tau\") tau = uint48(data);\r\n        else revert(\"Flopper/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(address gal, uint lot, uint bid) external auth returns (uint id) {\r\n        require(live == 1, \"Flopper/not-live\");\r\n        require(kicks < uint(-1), \"Flopper/overflow\");\r\n        id = ++kicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = gal;\r\n        bids[id].end = add(uint48(now), tau);\r\n\r\n        emit Kick(id, lot, bid, gal);\r\n    }\r\n    function tick(uint id) external note {\r\n        require(bids[id].end < now, \"Flopper/not-finished\");\r\n        require(bids[id].tic == 0, \"Flopper/bid-already-placed\");\r\n        bids[id].lot = mul(pad, bids[id].lot) / ONE;\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function dent(uint id, uint lot, uint bid) external note {\r\n        require(live == 1, \"Flopper/not-live\");\r\n        require(bids[id].guy != address(0), \"Flopper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flopper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flopper/already-finished-end\");\r\n\r\n        require(bid == bids[id].bid, \"Flopper/not-matching-bid\");\r\n        require(lot <  bids[id].lot, \"Flopper/lot-not-lower\");\r\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \"Flopper/insufficient-decrease\");\r\n\r\n        if (msg.sender != bids[id].guy) {\r\n            vat.move(msg.sender, bids[id].guy, bid);\r\n\r\n            // on first dent, clear as much Ash as possible\r\n            if (bids[id].tic == 0) {\r\n                uint Ash = Vow(bids[id].guy).Ash();\r\n                Vow(bids[id].guy).kiss(min(bid, Ash));\r\n            }\r\n\r\n            bids[id].guy = msg.sender;\r\n        }\r\n\r\n        bids[id].lot = lot;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint id) external note {\r\n        require(live == 1, \"Flopper/not-live\");\r\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flopper/not-finished\");\r\n        gem.mint(bids[id].guy, bids[id].lot); // will fail if mint is unavailable\r\n        delete bids[id];\r\n    }\r\n\r\n    // --- Shutdown ---\r\n    function cage() external note auth {\r\n       live = 0;\r\n       vow = msg.sender;\r\n    }\r\n    function yank(uint id) external note {\r\n        require(live == 0, \"Flopper/still-live\");\r\n        require(bids[id].guy != address(0), \"Flopper/guy-not-set\");\r\n        vat.suck(vow, bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ncontract Vow is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external note auth { require(live == 1, \"Vow/not-live\"); wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Vow/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    Vat      public vat;       // CDP Engine\r\n    Flapper  public flapper;   // Surplus Auction House\r\n    Flopper  public flopper;   // Debt Auction House\r\n\r\n    mapping (uint256 => uint256) public sin;  // debt queue\r\n    uint256 public Sin;   // Queued debt            [rad]\r\n    uint256 public Ash;   // On-auction debt        [rad]\r\n\r\n    uint256 public wait;  // Flop delay             [seconds]\r\n    uint256 public dump;  // Flop initial lot size  [wad]\r\n    uint256 public sump;  // Flop fixed bid size    [rad]\r\n\r\n    uint256 public bump;  // Flap fixed lot size    [rad]\r\n    uint256 public hump;  // Surplus buffer         [rad]\r\n\r\n    uint256 public live;  // Active Flag\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address flapper_, address flopper_) public {\r\n        wards[msg.sender] = 1;\r\n        vat     = Vat(vat_);\r\n        flapper = Flapper(flapper_);\r\n        flopper = Flopper(flopper_);\r\n        vat.hope(flapper_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint data) external note auth {\r\n        if (what == \"wait\") wait = data;\r\n        else if (what == \"bump\") bump = data;\r\n        else if (what == \"sump\") sump = data;\r\n        else if (what == \"dump\") dump = data;\r\n        else if (what == \"hump\") hump = data;\r\n        else revert(\"Vow/file-unrecognized-param\");\r\n    }\r\n\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \"flapper\") {\r\n            vat.nope(address(flapper));\r\n            flapper = Flapper(data);\r\n            vat.hope(data);\r\n        }\r\n        else if (what == \"flopper\") flopper = Flopper(data);\r\n        else revert(\"Vow/file-unrecognized-param\");\r\n    }\r\n\r\n    // Push to debt-queue\r\n    function fess(uint tab) external note auth {\r\n        sin[now] = add(sin[now], tab);\r\n        Sin = add(Sin, tab);\r\n    }\r\n    // Pop from debt-queue\r\n    function flog(uint era) external note {\r\n        require(add(era, wait) <= now, \"Vow/wait-not-finished\");\r\n        Sin = sub(Sin, sin[era]);\r\n        sin[era] = 0;\r\n    }\r\n\r\n    // Debt settlement\r\n    function heal(uint rad) external note {\r\n        require(rad <= vat.dai(address(this)), \"Vow/insufficient-surplus\");\r\n        require(rad <= sub(sub(vat.sin(address(this)), Sin), Ash), \"Vow/insufficient-debt\");\r\n        vat.heal(rad);\r\n    }\r\n    function kiss(uint rad) external note {\r\n        require(rad <= Ash, \"Vow/not-enough-ash\");\r\n        require(rad <= vat.dai(address(this)), \"Vow/insufficient-surplus\");\r\n        Ash = sub(Ash, rad);\r\n        vat.heal(rad);\r\n    }\r\n\r\n    // Debt auction\r\n    function flop() external note returns (uint id) {\r\n        require(sump <= sub(sub(vat.sin(address(this)), Sin), Ash), \"Vow/insufficient-debt\");\r\n        require(vat.dai(address(this)) == 0, \"Vow/surplus-not-zero\");\r\n        Ash = add(Ash, sump);\r\n        id = flopper.kick(address(this), dump, sump);\r\n    }\r\n    // Surplus auction\r\n    function flap() external note returns (uint id) {\r\n        require(vat.dai(address(this)) >= add(add(vat.sin(address(this)), bump), hump), \"Vow/insufficient-surplus\");\r\n        require(sub(sub(vat.sin(address(this)), Sin), Ash) == 0, \"Vow/debt-not-zero\");\r\n        id = flapper.kick(bump, 0);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        require(live == 1, \"Vow/not-live\");\r\n        live = 0;\r\n        Sin = 0;\r\n        Ash = 0;\r\n        flapper.cage(vat.dai(address(flapper)));\r\n        flopper.cage();\r\n        vat.heal(min(vat.dai(address(this)), vat.sin(address(this))));\r\n    }\r\n}\r\n\r\ninterface Kicker {\r\n    function kick(address urn, address gal, uint256 tab, uint256 lot, uint256 bid)\r\n        external returns (uint256);\r\n}\r\n\r\ncontract Cat is DSNote {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external note auth { wards[usr] = 1; }\r\n    function deny(address usr) external note auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Cat/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        address flip;  // Liquidator\r\n        uint256 chop;  // Liquidation Penalty  [wad]\r\n        uint256 dunk;  // Liquidation Quantity [rad]\r\n    }\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    uint256 public live;   // Active Flag\r\n    Vat     public vat;    // CDP Engine\r\n    Vow     public vow;    // Debt Engine\r\n    uint256 public box;    // Max Dai out for liquidation        [rad]\r\n    uint256 public litter; // Balance of Dai out for liquidation [rad]\r\n\r\n    // --- Events ---\r\n    event Bite(\r\n      bytes32 indexed ilk,\r\n      address indexed urn,\r\n      uint256 ink,\r\n      uint256 art,\r\n      uint256 tab,\r\n      address flip,\r\n      uint256 id\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        wards[msg.sender] = 1;\r\n        vat = Vat(vat_);\r\n        live = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        if (x > y) { z = y; } else { z = x; }\r\n    }\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external note auth {\r\n        if (what == \"vow\") vow = Vow(data);\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, uint256 data) external note auth {\r\n        if (what == \"box\") box = data;\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint256 data) external note auth {\r\n        if (what == \"chop\") ilks[ilk].chop = data;\r\n        else if (what == \"dunk\") ilks[ilk].dunk = data;\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, address flip) external note auth {\r\n        if (what == \"flip\") {\r\n            vat.nope(ilks[ilk].flip);\r\n            ilks[ilk].flip = flip;\r\n            vat.hope(flip);\r\n        }\r\n        else revert(\"Cat/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- CDP Liquidation ---\r\n    function bite(bytes32 ilk, address urn) external returns (uint256 id) {\r\n        (,uint256 rate,uint256 spot,,uint256 dust) = vat.ilks(ilk);\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\r\n\r\n        require(live == 1, \"Cat/not-live\");\r\n        require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Cat/not-unsafe\");\r\n\r\n        Ilk memory milk = ilks[ilk];\r\n        uint256 dart;\r\n        {\r\n            uint256 room = sub(box, litter);\r\n\r\n            // test whether the remaining space in the litterbox is dusty\r\n            require(litter < box && room >= dust, \"Cat/liquidation-limit-hit\");\r\n\r\n            dart = min(art, mul(min(milk.dunk, room), WAD) / rate / milk.chop);\r\n        }\r\n\r\n        uint256 dink = min(ink, mul(ink, dart) / art);\r\n\r\n        require(dart >  0      && dink >  0     , \"Cat/null-auction\");\r\n        require(dart <= 2**255 && dink <= 2**255, \"Cat/overflow\"    );\r\n\r\n        // This may leave the CDP in a dusty state\r\n        vat.grab(\r\n            ilk, urn, address(this), address(vow), -int256(dink), -int256(dart)\r\n        );\r\n        vow.fess(mul(dart, rate));\r\n\r\n        { // Avoid stack too deep\r\n            // This calcuation will overflow if dart*rate exceeds ~10^14,\r\n            // i.e. the maximum dunk is roughly 100 trillion DAI.\r\n            uint256 tab = mul(mul(dart, rate), milk.chop) / WAD;\r\n            litter = add(litter, tab);\r\n\r\n            id = Kicker(milk.flip).kick({\r\n                urn: urn,\r\n                gal: address(vow),\r\n                tab: tab,\r\n                lot: dink,\r\n                bid: 0\r\n            });\r\n        }\r\n\r\n        emit Bite(ilk, urn, dink, dart, mul(dart, rate), milk.flip, id);\r\n    }\r\n\r\n    function claw(uint256 rad) external note auth {\r\n        litter = sub(litter, rad);\r\n    }\r\n\r\n    function cage() external note auth {\r\n        live = 0;\r\n    }\r\n}\r\n\r\n// FIXME: This contract was altered compared to the production version.\r\n// It doesn't use LibNote anymore.\r\n// New deployments of this contract will need to include custom events (TO DO).\r\n\r\n/*\r\n   This thing lets you flip some gems for a given amount of dai.\r\n   Once the given amount of dai is raised, gems are forgone instead.\r\n\r\n - `lot` gems in return for bid\r\n - `tab` total dai wanted\r\n - `bid` dai paid\r\n - `gal` receives dai income\r\n - `usr` receives gem forgone\r\n - `ttl` single bid lifetime\r\n - `beg` minimum bid increase\r\n - `end` max auction duration\r\n*/\r\n\r\ncontract Flipper {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; }\r\n    function deny(address usr) external auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Flipper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Bid {\r\n        uint256 bid;  // dai paid                 [rad]\r\n        uint256 lot;  // gems in return for bid   [wad]\r\n        address guy;  // high bidder\r\n        uint48  tic;  // bid expiry time          [unix epoch time]\r\n        uint48  end;  // auction expiry time      [unix epoch time]\r\n        address usr;\r\n        address gal;\r\n        uint256 tab;  // total dai wanted         [rad]\r\n    }\r\n\r\n    mapping (uint256 => Bid) public bids;\r\n\r\n    Vat     public   vat;            // CDP Engine\r\n    bytes32 public   ilk;            // collateral type\r\n\r\n    uint256 constant ONE = 1.00E18;\r\n    uint256 public   beg = 1.05E18;  // 5% minimum bid increase\r\n    uint48  public   ttl = 3 hours;  // 3 hours bid duration         [seconds]\r\n    uint48  public   tau = 2 days;   // 2 days total auction length  [seconds]\r\n    uint256 public kicks = 0;\r\n    Cat     public   cat;            // cat liquidation module\r\n\r\n    // --- Events ---\r\n    event Kick(\r\n      uint256 id,\r\n      uint256 lot,\r\n      uint256 bid,\r\n      uint256 tab,\r\n      address indexed usr,\r\n      address indexed gal\r\n    );\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address cat_, bytes32 ilk_) public {\r\n        vat = Vat(vat_);\r\n        cat = Cat(cat_);\r\n        ilk = ilk_;\r\n        wards[msg.sender] = 1;\r\n    }\r\n\r\n    // --- Math ---\r\n    function add(uint48 x, uint48 y) internal pure returns (uint48 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Admin ---\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if (what == \"beg\") beg = data;\r\n        else if (what == \"ttl\") ttl = uint48(data);\r\n        else if (what == \"tau\") tau = uint48(data);\r\n        else revert(\"Flipper/file-unrecognized-param\");\r\n    }\r\n    function file(bytes32 what, address data) external auth {\r\n        if (what == \"cat\") cat = Cat(data);\r\n        else revert(\"Flipper/file-unrecognized-param\");\r\n    }\r\n\r\n    // --- Auction ---\r\n    function kick(address usr, address gal, uint256 tab, uint256 lot, uint256 bid)\r\n        public auth returns (uint256 id)\r\n    {\r\n        require(kicks < uint256(-1), \"Flipper/overflow\");\r\n        id = ++kicks;\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].lot = lot;\r\n        bids[id].guy = msg.sender;  // configurable??\r\n        bids[id].end = add(uint48(now), tau);\r\n        bids[id].usr = usr;\r\n        bids[id].gal = gal;\r\n        bids[id].tab = tab;\r\n\r\n        vat.flux(ilk, msg.sender, address(this), lot);\r\n\r\n        emit Kick(id, lot, bid, tab, usr, gal);\r\n    }\r\n    function tick(uint256 id) external {\r\n        require(bids[id].end < now, \"Flipper/not-finished\");\r\n        require(bids[id].tic == 0, \"Flipper/bid-already-placed\");\r\n        bids[id].end = add(uint48(now), tau);\r\n    }\r\n    function tend(uint256 id, uint256 lot, uint256 bid) external {\r\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flipper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flipper/already-finished-end\");\r\n\r\n        require(lot == bids[id].lot, \"Flipper/lot-not-matching\");\r\n        require(bid <= bids[id].tab, \"Flipper/higher-than-tab\");\r\n        require(bid >  bids[id].bid, \"Flipper/bid-not-higher\");\r\n        require(mul(bid, ONE) >= mul(beg, bids[id].bid) || bid == bids[id].tab, \"Flipper/insufficient-increase\");\r\n\r\n        if (msg.sender != bids[id].guy) {\r\n            vat.move(msg.sender, bids[id].guy, bids[id].bid);\r\n            bids[id].guy = msg.sender;\r\n        }\r\n        vat.move(msg.sender, bids[id].gal, bid - bids[id].bid);\r\n\r\n        bids[id].bid = bid;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function dent(uint256 id, uint256 lot, uint256 bid) external {\r\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\r\n        require(bids[id].tic > now || bids[id].tic == 0, \"Flipper/already-finished-tic\");\r\n        require(bids[id].end > now, \"Flipper/already-finished-end\");\r\n\r\n        require(bid == bids[id].bid, \"Flipper/not-matching-bid\");\r\n        require(bid == bids[id].tab, \"Flipper/tend-not-finished\");\r\n        require(lot < bids[id].lot, \"Flipper/lot-not-lower\");\r\n        require(mul(beg, lot) <= mul(bids[id].lot, ONE), \"Flipper/insufficient-decrease\");\r\n\r\n        if (msg.sender != bids[id].guy) {\r\n            vat.move(msg.sender, bids[id].guy, bid);\r\n            bids[id].guy = msg.sender;\r\n        }\r\n        vat.flux(ilk, address(this), bids[id].usr, bids[id].lot - lot);\r\n\r\n        bids[id].lot = lot;\r\n        bids[id].tic = add(uint48(now), ttl);\r\n    }\r\n    function deal(uint256 id) external {\r\n        require(bids[id].tic != 0 && (bids[id].tic < now || bids[id].end < now), \"Flipper/not-finished\");\r\n        cat.claw(bids[id].tab);\r\n        vat.flux(ilk, address(this), bids[id].guy, bids[id].lot);\r\n        delete bids[id];\r\n    }\r\n\r\n    function yank(uint256 id) external auth {\r\n        require(bids[id].guy != address(0), \"Flipper/guy-not-set\");\r\n        require(bids[id].bid < bids[id].tab, \"Flipper/already-dent-phase\");\r\n        cat.claw(bids[id].tab);\r\n        vat.flux(ilk, address(this), msg.sender, bids[id].lot);\r\n        vat.move(msg.sender, bids[id].guy, bids[id].bid);\r\n        delete bids[id];\r\n    }\r\n}\r\n\r\ninterface Abacus {\r\n    // 1st arg: initial price               [ray]\r\n    // 2nd arg: seconds since auction start [seconds]\r\n    // returns: current auction price       [ray]\r\n    function price(uint256, uint256) external view returns (uint256);\r\n}\r\n\r\ncontract LinearDecrease is Abacus {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"LinearDecrease/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    uint256 public tau;  // Seconds after auction start when the price reaches zero [seconds]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if (what ==  \"tau\") tau = data;\r\n        else revert(\"LinearDecrease/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant RAY = 10 ** 27;\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / RAY;\r\n    }\r\n\r\n    // Price calculation when price is decreased linearly in proportion to time:\r\n    // tau: The number of seconds after the start of the auction where the price will hit 0\r\n    // top: Initial price\r\n    // dur: current seconds since the start of the auction\r\n    //\r\n    // Returns y = top * ((tau - dur) / tau)\r\n    //\r\n    // Note the internal call to mul multiples by RAY, thereby ensuring that the rmul calculation\r\n    // which utilizes top and tau (RAY values) is also a RAY value.\r\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\r\n        if (dur >= tau) return 0;\r\n        return rmul(top, mul(tau - dur, RAY) / tau);\r\n    }\r\n}\r\n\r\ncontract StairstepExponentialDecrease is Abacus {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"StairstepExponentialDecrease/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    uint256 public step; // Length of time between price drops [seconds]\r\n    uint256 public cut;  // Per-step multiplicative factor     [ray]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n\r\n    // --- Init ---\r\n    // @notice: `cut` and `step` values must be correctly set for\r\n    //     this contract to return a valid price\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if      (what ==  \"cut\") require((cut = data) <= RAY, \"StairstepExponentialDecrease/cut-gt-RAY\");\r\n        else if (what == \"step\") step = data;\r\n        else revert(\"StairstepExponentialDecrease/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant RAY = 10 ** 27;\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / RAY;\r\n    }\r\n    // optimized version from dss PR #78\r\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch n case 0 { z := b }\r\n            default {\r\n                switch x case 0 { z := 0 }\r\n                default {\r\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\r\n                    let half := div(b, 2)  // for rounding.\r\n                    for { n := div(n, 2) } n { n := div(n,2) } {\r\n                        let xx := mul(x, x)\r\n                        if shr(128, x) { revert(0,0) }\r\n                        let xxRound := add(xx, half)\r\n                        if lt(xxRound, xx) { revert(0,0) }\r\n                        x := div(xxRound, b)\r\n                        if mod(n,2) {\r\n                            let zx := mul(z, x)\r\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                            let zxRound := add(zx, half)\r\n                            if lt(zxRound, zx) { revert(0,0) }\r\n                            z := div(zxRound, b)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // top: initial price\r\n    // dur: seconds since the auction has started\r\n    // step: seconds between a price drop\r\n    // cut: cut encodes the percentage to decrease per step.\r\n    //   For efficiency, the values is set as (1 - (% value / 100)) * RAY\r\n    //   So, for a 1% decrease per step, cut would be (1 - 0.01) * RAY\r\n    //\r\n    // returns: top * (cut ^ dur)\r\n    //\r\n    //\r\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\r\n        return rmul(top, rpow(cut, dur / step, RAY));\r\n    }\r\n}\r\n\r\n// While an equivalent function can be obtained by setting step = 1 in StairstepExponentialDecrease,\r\n// this continous (i.e. per-second) exponential decrease has be implemented as it is more gas-efficient\r\n// than using the stairstep version with step = 1 (primarily due to 1 fewer SLOAD per price calculation).\r\ncontract ExponentialDecrease is Abacus {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"ExponentialDecrease/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    uint256 public cut;  // Per-second multiplicative factor [ray]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n\r\n    // --- Init ---\r\n    // @notice: `cut` value must be correctly set for\r\n    //     this contract to return a valid price\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if      (what ==  \"cut\") require((cut = data) <= RAY, \"ExponentialDecrease/cut-gt-RAY\");\r\n        else revert(\"ExponentialDecrease/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant RAY = 10 ** 27;\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x * y;\r\n        require(y == 0 || z / y == x);\r\n        z = z / RAY;\r\n    }\r\n    // optimized version from dss PR #78\r\n    function rpow(uint256 x, uint256 n, uint256 b) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch n case 0 { z := b }\r\n            default {\r\n                switch x case 0 { z := 0 }\r\n                default {\r\n                    switch mod(n, 2) case 0 { z := b } default { z := x }\r\n                    let half := div(b, 2)  // for rounding.\r\n                    for { n := div(n, 2) } n { n := div(n,2) } {\r\n                        let xx := mul(x, x)\r\n                        if shr(128, x) { revert(0,0) }\r\n                        let xxRound := add(xx, half)\r\n                        if lt(xxRound, xx) { revert(0,0) }\r\n                        x := div(xxRound, b)\r\n                        if mod(n,2) {\r\n                            let zx := mul(z, x)\r\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\r\n                            let zxRound := add(zx, half)\r\n                            if lt(zxRound, zx) { revert(0,0) }\r\n                            z := div(zxRound, b)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // top: initial price\r\n    // dur: seconds since the auction has started\r\n    // cut: cut encodes the percentage to decrease per second.\r\n    //   For efficiency, the values is set as (1 - (% value / 100)) * RAY\r\n    //   So, for a 1% decrease per second, cut would be (1 - 0.01) * RAY\r\n    //\r\n    // returns: top * (cut ^ dur)\r\n    //\r\n    function price(uint256 top, uint256 dur) override external view returns (uint256) {\r\n        return rmul(top, rpow(cut, dur, RAY));\r\n    }\r\n}\r\n\r\ninterface ClipperCallee {\r\n    function clipperCall(address, uint256, uint256, bytes calldata) external;\r\n}\r\n\r\ncontract Clipper {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Clipper/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    bytes32  immutable public ilk;   // Collateral type of this Clipper\r\n    Vat      immutable public vat;   // Core CDP Engine\r\n\r\n    Dog         public dog;      // Liquidation module\r\n    address     public vow;      // Recipient of dai raised in auctions\r\n    Spotter     public spotter;  // Collateral price module\r\n    Abacus      public calc;     // Current price calculator\r\n\r\n    uint256 public buf;    // Multiplicative factor to increase starting price                  [ray]\r\n    uint256 public tail;   // Time elapsed before auction reset                                 [seconds]\r\n    uint256 public cusp;   // Percentage drop before auction reset                              [ray]\r\n    uint64  public chip;   // Percentage of tab to suck from vow to incentivize keepers         [wad]\r\n    uint192 public tip;    // Flat fee to suck from vow to incentivize keepers                  [rad]\r\n    uint256 public chost;  // Cache the ilk dust times the ilk chop to prevent excessive SLOADs [rad]\r\n\r\n    uint256   public kicks;   // Total auctions\r\n    uint256[] public active;  // Array of active auction ids\r\n\r\n    struct Sale {\r\n        uint256 pos;  // Index in active array\r\n        uint256 tab;  // Dai to raise       [rad]\r\n        uint256 lot;  // collateral to sell [wad]\r\n        address usr;  // Liquidated CDP\r\n        uint96  tic;  // Auction start time\r\n        uint256 top;  // Starting price     [ray]\r\n    }\r\n    mapping(uint256 => Sale) public sales;\r\n\r\n    uint256 internal locked;\r\n\r\n    // Levels for circuit breaker\r\n    // 0: no breaker\r\n    // 1: no new kick()\r\n    // 2: no new kick() or redo()\r\n    // 3: no new kick(), redo(), or take()\r\n    uint256 public stopped = 0;\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed what, address data);\r\n\r\n    event Kick(\r\n        uint256 indexed id,\r\n        uint256 top,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address indexed usr,\r\n        address indexed kpr,\r\n        uint256 coin\r\n    );\r\n    event Take(\r\n        uint256 indexed id,\r\n        uint256 max,\r\n        uint256 price,\r\n        uint256 owe,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address indexed usr\r\n    );\r\n    event Redo(\r\n        uint256 indexed id,\r\n        uint256 top,\r\n        uint256 tab,\r\n        uint256 lot,\r\n        address indexed usr,\r\n        address indexed kpr,\r\n        uint256 coin\r\n    );\r\n\r\n    event Yank(uint256 id);\r\n\r\n    // --- Init ---\r\n    constructor(address vat_, address spotter_, address dog_, bytes32 ilk_) public {\r\n        vat     = Vat(vat_);\r\n        spotter = Spotter(spotter_);\r\n        dog     = Dog(dog_);\r\n        ilk     = ilk_;\r\n        buf     = RAY;\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Synchronization ---\r\n    modifier lock {\r\n        require(locked == 0, \"Clipper/system-locked\");\r\n        locked = 1;\r\n        _;\r\n        locked = 0;\r\n    }\r\n\r\n    modifier isStopped(uint256 level) {\r\n        require(stopped < level, \"Clipper/stopped-incorrect\");\r\n        _;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external auth lock {\r\n        if      (what == \"buf\")         buf = data;\r\n        else if (what == \"tail\")       tail = data;           // Time elapsed before auction reset\r\n        else if (what == \"cusp\")       cusp = data;           // Percentage drop before auction reset\r\n        else if (what == \"chip\")       chip = uint64(data);   // Percentage of tab to incentivize (max: 2^64 - 1 => 18.xxx WAD = 18xx%)\r\n        else if (what == \"tip\")         tip = uint192(data);  // Flat fee to incentivize keepers (max: 2^192 - 1 => 6.277T RAD)\r\n        else if (what == \"stopped\") stopped = data;           // Set breaker (0, 1, 2, or 3)\r\n        else revert(\"Clipper/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 what, address data) external auth lock {\r\n        if (what == \"spotter\") spotter = Spotter(data);\r\n        else if (what == \"dog\")    dog = Dog(data);\r\n        else if (what == \"vow\")    vow = data;\r\n        else if (what == \"calc\")  calc = Abacus(data);\r\n        else revert(\"Clipper/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant BLN = 10 **  9;\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x <= y ? x : y;\r\n    }\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / WAD;\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, RAY) / y;\r\n    }\r\n\r\n    // --- Auction ---\r\n\r\n    // get the price directly from the OSM\r\n    // Could get this from rmul(Vat.ilks(ilk).spot, Spotter.mat()) instead, but\r\n    // if mat has changed since the last poke, the resulting value will be\r\n    // incorrect.\r\n    function getFeedPrice() internal view returns (uint256 feedPrice) {\r\n        (PipLike pip, ) = spotter.ilks(ilk);\r\n        (bytes32 val, bool has) = pip.peek();\r\n        require(has, \"Clipper/invalid-price\");\r\n        feedPrice = rdiv(mul(uint256(val), BLN), spotter.par());\r\n    }\r\n\r\n    // start an auction\r\n    // note: trusts the caller to transfer collateral to the contract\r\n    // The starting price `top` is obtained as follows:\r\n    //\r\n    //     top = val * buf / par\r\n    //\r\n    // Where `val` is the collateral's unitary value in USD, `buf` is a\r\n    // multiplicative factor to increase the starting price, and `par` is a\r\n    // reference per DAI.\r\n    function kick(\r\n        uint256 tab,  // Debt                   [rad]\r\n        uint256 lot,  // Collateral             [wad]\r\n        address usr,  // Address that will receive any leftover collateral\r\n        address kpr   // Address that will receive incentives\r\n    ) external auth lock isStopped(1) returns (uint256 id) {\r\n        // Input validation\r\n        require(tab  >          0, \"Clipper/zero-tab\");\r\n        require(lot  >          0, \"Clipper/zero-lot\");\r\n        require(usr != address(0), \"Clipper/zero-usr\");\r\n        id = ++kicks;\r\n        require(id   >          0, \"Clipper/overflow\");\r\n\r\n        active.push(id);\r\n\r\n        sales[id].pos = active.length - 1;\r\n\r\n        sales[id].tab = tab;\r\n        sales[id].lot = lot;\r\n        sales[id].usr = usr;\r\n        sales[id].tic = uint96(block.timestamp);\r\n\r\n        uint256 top;\r\n        top = rmul(getFeedPrice(), buf);\r\n        require(top > 0, \"Clipper/zero-top-price\");\r\n        sales[id].top = top;\r\n\r\n        // incentive to kick auction\r\n        uint256 _tip  = tip;\r\n        uint256 _chip = chip;\r\n        uint256 coin;\r\n        if (_tip > 0 || _chip > 0) {\r\n            coin = add(_tip, wmul(tab, _chip));\r\n            vat.suck(vow, kpr, coin);\r\n        }\r\n\r\n        emit Kick(id, top, tab, lot, usr, kpr, coin);\r\n    }\r\n\r\n    // Reset an auction\r\n    // See `kick` above for an explanation of the computation of `top`.\r\n    function redo(\r\n        uint256 id,  // id of the auction to reset\r\n        address kpr  // Address that will receive incentives\r\n    ) external lock isStopped(2) {\r\n        // Read auction data\r\n        address usr = sales[id].usr;\r\n        uint96  tic = sales[id].tic;\r\n        uint256 top = sales[id].top;\r\n\r\n        require(usr != address(0), \"Clipper/not-running-auction\");\r\n\r\n        // Check that auction needs reset\r\n        // and compute current price [ray]\r\n        (bool done,) = status(tic, top);\r\n        require(done, \"Clipper/cannot-reset\");\r\n\r\n        uint256 tab   = sales[id].tab;\r\n        uint256 lot   = sales[id].lot;\r\n        sales[id].tic = uint96(block.timestamp);\r\n\r\n        uint256 feedPrice = getFeedPrice();\r\n        top = rmul(feedPrice, buf);\r\n        require(top > 0, \"Clipper/zero-top-price\");\r\n        sales[id].top = top;\r\n\r\n        // incentive to redo auction\r\n        uint256 _tip  = tip;\r\n        uint256 _chip = chip;\r\n        uint256 coin;\r\n        if (_tip > 0 || _chip > 0) {\r\n            uint256 _chost = chost;\r\n            if (tab >= _chost && mul(lot, feedPrice) >= _chost) {\r\n                coin = add(_tip, wmul(tab, _chip));\r\n                vat.suck(vow, kpr, coin);\r\n            }\r\n        }\r\n\r\n        emit Redo(id, top, tab, lot, usr, kpr, coin);\r\n    }\r\n\r\n    // Buy up to `amt` of collateral from the auction indexed by `id`.\r\n    // \r\n    // Auctions will not collect more DAI than their assigned DAI target,`tab`;\r\n    // thus, if `amt` would cost more DAI than `tab` at the current price, the\r\n    // amount of collateral purchased will instead be just enough to collect `tab` DAI.\r\n    //\r\n    // To avoid partial purchases resulting in very small leftover auctions that will\r\n    // never be cleared, any partial purchase must leave at least `Clipper.chost`\r\n    // remaining DAI target. `chost` is an asynchronously updated value equal to\r\n    // (Vat.dust * Dog.chop(ilk) / WAD) where the values are understood to be determined\r\n    // by whatever they were when Clipper.upchost() was last called. Purchase amounts\r\n    // will be minimally decreased when necessary to respect this limit; i.e., if the\r\n    // specified `amt` would leave `tab < chost` but `tab > 0`, the amount actually\r\n    // purchased will be such that `tab == chost`.\r\n    //\r\n    // If `tab <= chost`, partial purchases are no longer possible; that is, the remaining\r\n    // collateral can only be purchased entirely, or not at all.\r\n    function take(\r\n        uint256 id,           // Auction id\r\n        uint256 amt,          // Upper limit on amount of collateral to buy  [wad]\r\n        uint256 max,          // Maximum acceptable price (DAI / collateral) [ray]\r\n        address who,          // Receiver of collateral and external call address\r\n        bytes calldata data   // Data to pass in external call; if length 0, no call is done\r\n    ) external lock isStopped(3) {\r\n\r\n        address usr = sales[id].usr;\r\n        uint96  tic = sales[id].tic;\r\n\r\n        require(usr != address(0), \"Clipper/not-running-auction\");\r\n\r\n        uint256 price;\r\n        {\r\n            bool done;\r\n            (done, price) = status(tic, sales[id].top);\r\n\r\n            // Check that auction doesn't need reset\r\n            require(!done, \"Clipper/needs-reset\");\r\n        }\r\n\r\n        // Ensure price is acceptable to buyer\r\n        require(max >= price, \"Clipper/too-expensive\");\r\n\r\n        uint256 lot = sales[id].lot;\r\n        uint256 tab = sales[id].tab;\r\n        uint256 owe;\r\n\r\n        {\r\n            // Purchase as much as possible, up to amt\r\n            uint256 slice = min(lot, amt);  // slice <= lot\r\n\r\n            // DAI needed to buy a slice of this sale\r\n            owe = mul(slice, price);\r\n\r\n            // Don't collect more than tab of DAI\r\n            if (owe > tab) {\r\n                // Total debt will be paid\r\n                owe = tab;                  // owe' <= owe\r\n                // Adjust slice\r\n                slice = owe / price;        // slice' = owe' / price <= owe / price == slice <= lot\r\n            } else if (owe < tab && slice < lot) {\r\n                // If slice == lot => auction completed => dust doesn't matter\r\n                uint256 _chost = chost;\r\n                if (tab - owe < _chost) {    // safe as owe < tab\r\n                    // If tab <= chost, buyers have to take the entire lot.\r\n                    require(tab > _chost, \"Clipper/no-partial-purchase\");\r\n                    // Adjust amount to pay\r\n                    owe = tab - _chost;      // owe' <= owe\r\n                    // Adjust slice\r\n                    slice = owe / price;     // slice' = owe' / price < owe / price == slice < lot\r\n                }\r\n            }\r\n\r\n            // Calculate remaining tab after operation\r\n            tab = tab - owe;  // safe since owe <= tab\r\n            // Calculate remaining lot after operation\r\n            lot = lot - slice;\r\n\r\n            // Send collateral to who\r\n            vat.flux(ilk, address(this), who, slice);\r\n\r\n            // Do external call (if data is defined) but to be\r\n            // extremely careful we don't allow to do it to the two\r\n            // contracts which the Clipper needs to be authorized\r\n            Dog dog_ = dog;\r\n            if (data.length > 0 && who != address(vat) && who != address(dog_)) {\r\n                ClipperCallee(who).clipperCall(msg.sender, owe, slice, data);\r\n            }\r\n\r\n            // Get DAI from caller\r\n            vat.move(msg.sender, vow, owe);\r\n\r\n            // Removes Dai out for liquidation from accumulator\r\n            dog_.digs(ilk, lot == 0 ? tab + owe : owe);\r\n        }\r\n\r\n        if (lot == 0) {\r\n            _remove(id);\r\n        } else if (tab == 0) {\r\n            vat.flux(ilk, address(this), usr, lot);\r\n            _remove(id);\r\n        } else {\r\n            sales[id].tab = tab;\r\n            sales[id].lot = lot;\r\n        }\r\n\r\n        emit Take(id, max, price, owe, tab, lot, usr);\r\n    }\r\n\r\n    function _remove(uint256 id) internal {\r\n        uint256 _move    = active[active.length - 1];\r\n        if (id != _move) {\r\n            uint256 _index   = sales[id].pos;\r\n            active[_index]   = _move;\r\n            sales[_move].pos = _index;\r\n        }\r\n        active.pop();\r\n        delete sales[id];\r\n    }\r\n\r\n    // The number of active auctions\r\n    function count() external view returns (uint256) {\r\n        return active.length;\r\n    }\r\n\r\n    // Return the entire array of active auctions\r\n    function list() external view returns (uint256[] memory) {\r\n        return active;\r\n    }\r\n\r\n    // Externally returns boolean for if an auction needs a redo and also the current price\r\n    function getStatus(uint256 id) external view returns (bool needsRedo, uint256 price, uint256 lot, uint256 tab) {\r\n        // Read auction data\r\n        address usr = sales[id].usr;\r\n        uint96  tic = sales[id].tic;\r\n\r\n        bool done;\r\n        (done, price) = status(tic, sales[id].top);\r\n\r\n        needsRedo = usr != address(0) && done;\r\n        lot = sales[id].lot;\r\n        tab = sales[id].tab;\r\n    }\r\n\r\n    // Internally returns boolean for if an auction needs a redo\r\n    function status(uint96 tic, uint256 top) internal view returns (bool done, uint256 price) {\r\n        price = calc.price(top, sub(block.timestamp, tic));\r\n        done  = (sub(block.timestamp, tic) > tail || rdiv(price, top) < cusp);\r\n    }\r\n\r\n    // Public function to update the cached dust*chop value.\r\n    function upchost() external {\r\n        (,,,, uint256 _dust) = Vat(vat).ilks(ilk);\r\n        chost = wmul(_dust, dog.chop(ilk));\r\n    }\r\n\r\n    // Cancel an auction during ES or via governance action.\r\n    function yank(uint256 id) external auth lock {\r\n        require(sales[id].usr != address(0), \"Clipper/not-running-auction\");\r\n        dog.digs(ilk, sales[id].tab);\r\n        vat.flux(ilk, address(this), msg.sender, sales[id].lot);\r\n        _remove(id);\r\n        emit Yank(id);\r\n    }\r\n}\r\n\r\ncontract Dog {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"Dog/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    struct Ilk {\r\n        address clip;  // Liquidator\r\n        uint256 chop;  // Liquidation Penalty                                          [wad]\r\n        uint256 hole;  // Max DAI needed to cover debt+fees of active auctions per ilk [rad]\r\n        uint256 dirt;  // Amt DAI needed to cover debt+fees of active auctions per ilk [rad]\r\n    }\r\n\r\n    Vat     immutable public vat;  // CDP Engine\r\n\r\n    mapping (bytes32 => Ilk) public ilks;\r\n\r\n    Vow     public vow;   // Debt Engine\r\n    uint256 public live;  // Active Flag\r\n    uint256 public Hole;  // Max DAI needed to cover debt+fees of active auctions [rad]\r\n    uint256 public Dirt;  // Amt DAI needed to cover debt+fees of active auctions [rad]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed what, address data);\r\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed ilk, bytes32 indexed what, address clip);\r\n\r\n    event Bark(\r\n      bytes32 indexed ilk,\r\n      address indexed urn,\r\n      uint256 ink,\r\n      uint256 art,\r\n      uint256 due,\r\n      address clip,\r\n      uint256 indexed id\r\n    );\r\n    event Digs(bytes32 indexed ilk, uint256 rad);\r\n    event Cage();\r\n\r\n    // --- Init ---\r\n    constructor(address vat_) public {\r\n        vat = Vat(vat_);\r\n        live = 1;\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x <= y ? x : y;\r\n    }\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external auth {\r\n        if (what == \"vow\") vow = Vow(data);\r\n        else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if (what == \"Hole\") Hole = data;\r\n        else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\r\n        if (what == \"chop\") {\r\n            require(data >= WAD, \"Dog/file-chop-lt-WAD\");\r\n            ilks[ilk].chop = data;\r\n        } else if (what == \"hole\") ilks[ilk].hole = data;\r\n        else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(ilk, what, data);\r\n    }\r\n    function file(bytes32 ilk, bytes32 what, address clip) external auth {\r\n        if (what == \"clip\") {\r\n            require(ilk == Clipper(clip).ilk(), \"Dog/file-ilk-neq-clip.ilk\");\r\n            ilks[ilk].clip = clip;\r\n        } else revert(\"Dog/file-unrecognized-param\");\r\n        emit File(ilk, what, clip);\r\n    }\r\n\r\n    function chop(bytes32 ilk) external view returns (uint256) {\r\n        return ilks[ilk].chop;\r\n    }\r\n\r\n    // --- CDP Liquidation: all bark and no bite ---\r\n    //\r\n    // Liquidate a Vault and start a Dutch auction to sell its collateral for DAI.\r\n    //\r\n    // The third argument is the address that will receive the liquidation reward, if any.\r\n    //\r\n    // The entire Vault will be liquidated except when the target amount of DAI to be raised in\r\n    // the resulting auction (debt of Vault + liquidation penalty) causes either Dirt to exceed\r\n    // Hole or ilk.dirt to exceed ilk.hole by an economically significant amount. In that\r\n    // case, a partial liquidation is performed to respect the global and per-ilk limits on\r\n    // outstanding DAI target. The one exception is if the resulting auction would likely\r\n    // have too little collateral to be interesting to Keepers (debt taken from Vault < ilk.dust),\r\n    // in which case the function reverts. Please refer to the code and comments within if\r\n    // more detail is desired.\r\n    function bark(bytes32 ilk, address urn, address kpr) external returns (uint256 id) {\r\n        require(live == 1, \"Dog/not-live\");\r\n\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\r\n        Ilk memory milk = ilks[ilk];\r\n        uint256 dart;\r\n        uint256 rate;\r\n        uint256 dust;\r\n        {\r\n            uint256 spot;\r\n            (,rate, spot,, dust) = vat.ilks(ilk);\r\n            require(spot > 0 && mul(ink, spot) < mul(art, rate), \"Dog/not-unsafe\");\r\n\r\n            // Get the minimum value between:\r\n            // 1) Remaining space in the general Hole\r\n            // 2) Remaining space in the collateral hole\r\n            require(Hole > Dirt && milk.hole > milk.dirt, \"Dog/liquidation-limit-hit\");\r\n            uint256 room = min(Hole - Dirt, milk.hole - milk.dirt);\r\n\r\n            // uint256.max()/(RAD*WAD) = 115,792,089,237,316\r\n            dart = min(art, mul(room, WAD) / rate / milk.chop);\r\n\r\n            // Partial liquidation edge case logic\r\n            if (art > dart) {\r\n                if (mul(art - dart, rate) < dust) {\r\n\r\n                    // If the leftover Vault would be dusty, just liquidate it entirely.\r\n                    // This will result in at least one of dirt_i > hole_i or Dirt > Hole becoming true.\r\n                    // The amount of excess will be bounded above by ceiling(dust_i * chop_i / WAD).\r\n                    // This deviation is assumed to be small compared to both hole_i and Hole, so that\r\n                    // the extra amount of target DAI over the limits intended is not of economic concern.\r\n                    dart = art;\r\n                } else {\r\n\r\n                    // In a partial liquidation, the resulting auction should also be non-dusty.\r\n                    require(mul(dart, rate) >= dust, \"Dog/dusty-auction-from-partial-liquidation\");\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 dink = mul(ink, dart) / art;\r\n\r\n        require(dink > 0, \"Dog/null-auction\");\r\n        require(dart <= 2**255 && dink <= 2**255, \"Dog/overflow\");\r\n\r\n        vat.grab(\r\n            ilk, urn, milk.clip, address(vow), -int256(dink), -int256(dart)\r\n        );\r\n\r\n        uint256 due = mul(dart, rate);\r\n        vow.fess(due);\r\n\r\n        {   // Avoid stack too deep\r\n            // This calcuation will overflow if dart*rate exceeds ~10^14\r\n            uint256 tab = mul(due, milk.chop) / WAD;\r\n            Dirt = add(Dirt, tab);\r\n            ilks[ilk].dirt = add(milk.dirt, tab);\r\n\r\n            id = Clipper(milk.clip).kick({\r\n                tab: tab,\r\n                lot: dink,\r\n                usr: urn,\r\n                kpr: kpr\r\n            });\r\n        }\r\n\r\n        emit Bark(ilk, urn, dink, dart, due, milk.clip, id);\r\n    }\r\n\r\n    function digs(bytes32 ilk, uint256 rad) external auth {\r\n        Dirt = sub(Dirt, rad);\r\n        ilks[ilk].dirt = sub(ilks[ilk].dirt, rad);\r\n        emit Digs(ilk, rad);\r\n    }\r\n\r\n    function cage() external auth {\r\n        live = 0;\r\n        emit Cage();\r\n    }\r\n}\r\n\r\n/*\r\n    This is the `End` and it coordinates Global Settlement. This is an\r\n    involved, stateful process that takes place over nine steps.\r\n\r\n    First we freeze the system and lock the prices for each ilk.\r\n\r\n    1. `cage()`:\r\n        - freezes user entrypoints\r\n        - cancels flop/flap auctions\r\n        - starts cooldown period\r\n        - stops pot drips\r\n\r\n    2. `cage(ilk)`:\r\n       - set the cage price for each `ilk`, reading off the price feed\r\n\r\n    We must process some system state before it is possible to calculate\r\n    the final dai / collateral price. In particular, we need to determine\r\n\r\n      a. `gap`, the collateral shortfall per collateral type by\r\n         considering under-collateralised CDPs.\r\n\r\n      b. `debt`, the outstanding dai supply after including system\r\n         surplus / deficit\r\n\r\n    We determine (a) by processing all under-collateralised CDPs with\r\n    `skim`:\r\n\r\n    3. `skim(ilk, urn)`:\r\n       - cancels CDP debt\r\n       - any excess collateral remains\r\n       - backing collateral taken\r\n\r\n    We determine (b) by processing ongoing dai generating processes,\r\n    i.e. auctions. We need to ensure that auctions will not generate any\r\n    further dai income.\r\n\r\n    In the two-way auction model (Flipper) this occurs when\r\n    all auctions are in the reverse (`dent`) phase. There are two ways\r\n    of ensuring this:\r\n\r\n    4a. i) `wait`: set the cooldown period to be at least as long as the\r\n           longest auction duration, which needs to be determined by the\r\n           cage administrator.\r\n\r\n           This takes a fairly predictable time to occur but with altered\r\n           auction dynamics due to the now varying price of dai.\r\n\r\n       ii) `skip`: cancel all ongoing auctions and seize the collateral.\r\n\r\n           This allows for faster processing at the expense of more\r\n           processing calls. This option allows dai holders to retrieve\r\n           their collateral faster.\r\n\r\n           `skip(ilk, id)`:\r\n            - cancel individual flip auctions in the `tend` (forward) phase\r\n            - retrieves collateral and debt (including penalty) to owner's CDP\r\n            - returns dai to last bidder\r\n            - `dent` (reverse) phase auctions can continue normally\r\n\r\n    Option (i), `wait`, is sufficient (if all auctions were bidded at least\r\n    once) for processing the system settlement but option (ii), `skip`,\r\n    will speed it up. Both options are available in this implementation,\r\n    with `skip` being enabled on a per-auction basis.\r\n\r\n    In the case of the Dutch Auctions model (Clipper) they keep recovering\r\n    debt during the whole lifetime and there isn't a max duration time\r\n    guaranteed for the auction to end.\r\n    So the way to ensure the protocol will not receive extra dai income is:\r\n\r\n    4b. i) `snip`: cancel all ongoing auctions and seize the collateral.\r\n\r\n           `snip(ilk, id)`:\r\n            - cancel individual running clip auctions\r\n            - retrieves remaining collateral and debt (including penalty)\r\n              to owner's CDP\r\n\r\n    When a CDP has been processed and has no debt remaining, the\r\n    remaining collateral can be removed.\r\n\r\n    5. `free(ilk)`:\r\n        - remove collateral from the caller's CDP\r\n        - owner can call as needed\r\n\r\n    After the processing period has elapsed, we enable calculation of\r\n    the final price for each collateral type.\r\n\r\n    6. `thaw()`:\r\n       - only callable after processing time period elapsed\r\n       - assumption that all under-collateralised CDPs are processed\r\n       - fixes the total outstanding supply of dai\r\n       - may also require extra CDP processing to cover vow surplus\r\n\r\n    7. `flow(ilk)`:\r\n        - calculate the `fix`, the cash price for a given ilk\r\n        - adjusts the `fix` in the case of deficit / surplus\r\n\r\n    At this point we have computed the final price for each collateral\r\n    type and dai holders can now turn their dai into collateral. Each\r\n    unit dai can claim a fixed basket of collateral.\r\n\r\n    Dai holders must first `pack` some dai into a `bag`. Once packed,\r\n    dai cannot be unpacked and is not transferrable. More dai can be\r\n    added to a bag later.\r\n\r\n    8. `pack(wad)`:\r\n        - put some dai into a bag in preparation for `cash`\r\n\r\n    Finally, collateral can be obtained with `cash`. The bigger the bag,\r\n    the more collateral can be released.\r\n\r\n    9. `cash(ilk, wad)`:\r\n        - exchange some dai from your bag for gems from a specific ilk\r\n        - the number of gems is limited by how big your bag is\r\n*/\r\n\r\ncontract End {\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;\r\n    function rely(address usr) external auth { wards[usr] = 1; emit Rely(usr); }\r\n    function deny(address usr) external auth { wards[usr] = 0; emit Deny(usr); }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"End/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    // --- Data ---\r\n    Vat      public vat;   // CDP Engine\r\n    Cat      public cat;\r\n    Dog      public dog;\r\n    Vow      public vow;   // Debt Engine\r\n    Pot      public pot;\r\n    Spotter  public spot;\r\n\r\n    uint256  public live;  // Active Flag\r\n    uint256  public when;  // Time of cage                   [unix epoch time]\r\n    uint256  public wait;  // Processing Cooldown Length             [seconds]\r\n    uint256  public debt;  // Total outstanding dai following processing [rad]\r\n\r\n    mapping (bytes32 => uint256) public tag;  // Cage price              [ray]\r\n    mapping (bytes32 => uint256) public gap;  // Collateral shortfall    [wad]\r\n    mapping (bytes32 => uint256) public Art;  // Total debt per ilk      [wad]\r\n    mapping (bytes32 => uint256) public fix;  // Final cash price        [ray]\r\n\r\n    mapping (address => uint256)                      public bag;  //    [wad]\r\n    mapping (bytes32 => mapping (address => uint256)) public out;  //    [wad]\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event File(bytes32 indexed what, address data);\r\n\r\n    event Cage();\r\n    event Cage(bytes32 indexed ilk);\r\n    event Snip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\r\n    event Skip(bytes32 indexed ilk, uint256 indexed id, address indexed usr, uint256 tab, uint256 lot, uint256 art);\r\n    event Skim(bytes32 indexed ilk, address indexed urn, uint256 wad, uint256 art);\r\n    event Free(bytes32 indexed ilk, address indexed usr, uint256 ink);\r\n    event Thaw();\r\n    event Flow(bytes32 indexed ilk);\r\n    event Pack(address indexed usr, uint256 wad);\r\n    event Cash(bytes32 indexed ilk, address indexed usr, uint256 wad);\r\n\r\n    // --- Init ---\r\n    constructor() public {\r\n        wards[msg.sender] = 1;\r\n        live = 1;\r\n        emit Rely(msg.sender);\r\n    }\r\n\r\n    // --- Math ---\r\n    uint256 constant WAD = 10 ** 18;\r\n    uint256 constant RAY = 10 ** 27;\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, y) / RAY;\r\n    }\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = mul(x, WAD) / y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, address data) external auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"vat\")  vat = Vat(data);\r\n        else if (what == \"cat\")   cat = Cat(data);\r\n        else if (what == \"dog\")   dog = Dog(data);\r\n        else if (what == \"vow\")   vow = Vow(data);\r\n        else if (what == \"pot\")   pot = Pot(data);\r\n        else if (what == \"spot\") spot = Spotter(data);\r\n        else revert(\"End/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        require(live == 1, \"End/not-live\");\r\n        if (what == \"wait\") wait = data;\r\n        else revert(\"End/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Settlement ---\r\n    function cage() external auth {\r\n        require(live == 1, \"End/not-live\");\r\n        live = 0;\r\n        when = block.timestamp;\r\n        vat.cage();\r\n        cat.cage();\r\n        dog.cage();\r\n        vow.cage();\r\n        spot.cage();\r\n        pot.cage();\r\n        emit Cage();\r\n    }\r\n\r\n    function cage(bytes32 ilk) external {\r\n        require(live == 0, \"End/still-live\");\r\n        require(tag[ilk] == 0, \"End/tag-ilk-already-defined\");\r\n        (Art[ilk],,,,) = vat.ilks(ilk);\r\n        (PipLike pip,) = spot.ilks(ilk);\r\n        // par is a ray, pip returns a wad\r\n        tag[ilk] = wdiv(spot.par(), uint256(pip.read()));\r\n        emit Cage(ilk);\r\n    }\r\n\r\n    function snip(bytes32 ilk, uint256 id) external {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n\r\n        (address _clip,,,) = dog.ilks(ilk);\r\n        Clipper clip = Clipper(_clip);\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        (, uint256 tab, uint256 lot, address usr,,) = clip.sales(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        clip.yank(id);\r\n\r\n        uint256 art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\r\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\r\n        emit Snip(ilk, id, usr, tab, lot, art);\r\n    }\r\n\r\n    function skip(bytes32 ilk, uint256 id) external {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n\r\n        (address _flip,,) = cat.ilks(ilk);\r\n        Flipper flip = Flipper(_flip);\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        (uint256 bid, uint256 lot,,,, address usr,, uint256 tab) = flip.bids(id);\r\n\r\n        vat.suck(address(vow), address(vow),  tab);\r\n        vat.suck(address(vow), address(this), bid);\r\n        vat.hope(address(flip));\r\n        flip.yank(id);\r\n\r\n        uint256 art = tab / rate;\r\n        Art[ilk] = add(Art[ilk], art);\r\n        require(int256(lot) >= 0 && int256(art) >= 0, \"End/overflow\");\r\n        vat.grab(ilk, usr, address(this), address(vow), int256(lot), int256(art));\r\n        emit Skip(ilk, id, usr, tab, lot, art);\r\n    }\r\n\r\n    function skim(bytes32 ilk, address urn) external {\r\n        require(tag[ilk] != 0, \"End/tag-ilk-not-defined\");\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, urn);\r\n\r\n        uint256 owe = rmul(rmul(art, rate), tag[ilk]);\r\n        uint256 wad = min(ink, owe);\r\n        gap[ilk] = add(gap[ilk], sub(owe, wad));\r\n\r\n        require(wad <= 2**255 && art <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, urn, address(this), address(vow), -int256(wad), -int256(art));\r\n        emit Skim(ilk, urn, wad, art);\r\n    }\r\n\r\n    function free(bytes32 ilk) external {\r\n        require(live == 0, \"End/still-live\");\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, msg.sender);\r\n        require(art == 0, \"End/art-not-zero\");\r\n        require(ink <= 2**255, \"End/overflow\");\r\n        vat.grab(ilk, msg.sender, msg.sender, address(vow), -int256(ink), 0);\r\n        emit Free(ilk, msg.sender, ink);\r\n    }\r\n\r\n    function thaw() external {\r\n        require(live == 0, \"End/still-live\");\r\n        require(debt == 0, \"End/debt-not-zero\");\r\n        require(vat.dai(address(vow)) == 0, \"End/surplus-not-zero\");\r\n        require(block.timestamp >= add(when, wait), \"End/wait-not-finished\");\r\n        debt = vat.debt();\r\n        emit Thaw();\r\n    }\r\n    function flow(bytes32 ilk) external {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        require(fix[ilk] == 0, \"End/fix-ilk-already-defined\");\r\n\r\n        (, uint256 rate,,,) = vat.ilks(ilk);\r\n        uint256 wad = rmul(rmul(Art[ilk], rate), tag[ilk]);\r\n        fix[ilk] = mul(sub(wad, gap[ilk]), RAY) / (debt / RAY);\r\n        emit Flow(ilk);\r\n    }\r\n\r\n    function pack(uint256 wad) external {\r\n        require(debt != 0, \"End/debt-zero\");\r\n        vat.move(msg.sender, address(vow), mul(wad, RAY));\r\n        bag[msg.sender] = add(bag[msg.sender], wad);\r\n        emit Pack(msg.sender, wad);\r\n    }\r\n    function cash(bytes32 ilk, uint256 wad) external {\r\n        require(fix[ilk] != 0, \"End/fix-ilk-not-defined\");\r\n        vat.flux(ilk, address(this), msg.sender, rmul(wad, fix[ilk]));\r\n        out[ilk][msg.sender] = add(out[ilk][msg.sender], wad);\r\n        require(out[ilk][msg.sender] <= bag[msg.sender], \"End/insufficient-bag-balance\");\r\n        emit Cash(ilk, msg.sender, wad);\r\n    }\r\n}\r\n\r\ninterface DenyLike {\r\n    function deny(address) external;\r\n}\r\n\r\ncontract ESM {\r\n    DSToken public immutable gem;   // collateral (MKR token)\r\n    End     public immutable end;   // cage module\r\n    address public immutable proxy; // Pause proxy\r\n    uint256 public immutable min;   // minimum activation threshold [wad]\r\n\r\n    mapping(address => uint256) public sum; // per-address balance\r\n    uint256 public Sum; // total balance\r\n\r\n    event Fire();\r\n    event Join(address indexed usr, uint256 wad);\r\n\r\n    constructor(address gem_, address end_, address proxy_, uint256 min_) public {\r\n        gem = DSToken(gem_);\r\n        end = End(end_);\r\n        proxy = proxy_;\r\n        min = min_;\r\n    }\r\n\r\n    function revokesGovernanceAccess() external view returns (bool ret) {\r\n        ret = proxy != address(0);\r\n    }\r\n\r\n    // -- math --\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x + y;\r\n        require(z >= x);\r\n    }\r\n\r\n    function fire() external {\r\n        require(Sum >= min,  \"ESM/min-not-reached\");\r\n\r\n        if (proxy != address(0)) {\r\n            end.vat().deny(proxy);\r\n        }\r\n        end.cage();\r\n\r\n        emit Fire();\r\n    }\r\n\r\n    function deny(address target) external {\r\n        require(Sum >= min,  \"ESM/min-not-reached\");\r\n\r\n        DenyLike(target).deny(proxy);\r\n    }\r\n\r\n    function join(uint256 wad) external {\r\n        require(end.live() == 1, \"ESM/system-already-shutdown\");\r\n\r\n        sum[msg.sender] = add(sum[msg.sender], wad);\r\n        Sum = add(Sum, wad);\r\n\r\n        require(gem.transferFrom(msg.sender, address(this), wad), \"ESM/transfer-failed\");\r\n        emit Join(msg.sender, wad);\r\n    }\r\n\r\n    function burn() external {\r\n        uint256 balance = gem.balanceOf(address(this));\r\n        try gem.burn(balance) {} catch { gem.transfer(address(0xdead), balance); }\r\n    }\r\n}\r\n\r\ncontract VatFab {\r\n    function newVat(address owner) public returns (Vat vat) {\r\n        vat = new Vat();\r\n        vat.rely(owner);\r\n        vat.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract JugFab {\r\n    function newJug(address owner, address vat) public returns (Jug jug) {\r\n        jug = new Jug(vat);\r\n        jug.rely(owner);\r\n        jug.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract VowFab {\r\n    function newVow(address owner, address vat, address flap, address flop) public returns (Vow vow) {\r\n        vow = new Vow(vat, flap, flop);\r\n        vow.rely(owner);\r\n        vow.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract CatFab {\r\n    function newCat(address owner, address vat) public returns (Cat cat) {\r\n        cat = new Cat(vat);\r\n        cat.rely(owner);\r\n        cat.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DogFab {\r\n    function newDog(address owner, address vat) public returns (Dog dog) {\r\n        dog = new Dog(vat);\r\n        dog.rely(owner);\r\n        dog.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DaiFab {\r\n    function newDai(address owner, uint chainId) public returns (Dai dai) {\r\n        dai = new Dai(chainId);\r\n        dai.rely(owner);\r\n        dai.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract DaiJoinFab {\r\n    function newDaiJoin(address vat, address dai) public returns (DaiJoin daiJoin) {\r\n        daiJoin = new DaiJoin(vat, dai);\r\n    }\r\n}\r\n\r\ncontract FlapFab {\r\n    function newFlap(address owner, address vat, address gov) public returns (Flapper flap) {\r\n        flap = new Flapper(vat, gov);\r\n        flap.rely(owner);\r\n        flap.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract FlopFab {\r\n    function newFlop(address owner, address vat, address gov) public returns (Flopper flop) {\r\n        flop = new Flopper(vat, gov);\r\n        flop.rely(owner);\r\n        flop.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract FlipFab {\r\n    function newFlip(address owner, address vat, address cat, bytes32 ilk) public returns (Flipper flip) {\r\n        flip = new Flipper(vat, cat, ilk);\r\n        flip.rely(owner);\r\n        flip.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract ClipFab {\r\n    function newClip(address owner, address vat, address spotter, address dog, bytes32 ilk) public returns (Clipper clip) {\r\n        clip = new Clipper(vat, spotter, dog, ilk);\r\n        clip.rely(owner);\r\n        clip.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract SpotFab {\r\n    function newSpotter(address owner, address vat) public returns (Spotter spotter) {\r\n        spotter = new Spotter(vat);\r\n        spotter.rely(owner);\r\n        spotter.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract PotFab {\r\n    function newPot(address owner, address vat) public returns (Pot pot) {\r\n        pot = new Pot(vat);\r\n        pot.rely(owner);\r\n        pot.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract EndFab {\r\n    function newEnd(address owner) public returns (End end) {\r\n        end = new End();\r\n        end.rely(owner);\r\n        end.deny(address(this));\r\n    }\r\n}\r\n\r\ncontract ESMFab {\r\n    function newESM(address gov, address end, address proxy, uint min) public returns (ESM esm) {\r\n        esm = new ESM(gov, end, proxy, min);\r\n    }\r\n}\r\n\r\ncontract PauseFab {\r\n    function newPause(uint delay, address owner, DSAuthority authority) public returns(DSPause pause) {\r\n        pause = new DSPause(delay, owner, authority);\r\n    }\r\n}\r\n\r\ncontract DssDeploy is DSAuth {\r\n    VatFab     public vatFab;\r\n    JugFab     public jugFab;\r\n    VowFab     public vowFab;\r\n    CatFab     public catFab;\r\n    DogFab     public dogFab;\r\n    DaiFab     public daiFab;\r\n    DaiJoinFab public daiJoinFab;\r\n    FlapFab    public flapFab;\r\n    FlopFab    public flopFab;\r\n    FlipFab    public flipFab;\r\n    ClipFab    public clipFab;\r\n    SpotFab    public spotFab;\r\n    PotFab     public potFab;\r\n    EndFab     public endFab;\r\n    ESMFab     public esmFab;\r\n    PauseFab   public pauseFab;\r\n\r\n    Vat     public vat;\r\n    Jug     public jug;\r\n    Vow     public vow;\r\n    Cat     public cat;\r\n    Dog     public dog;\r\n    Dai     public dai;\r\n    DaiJoin public daiJoin;\r\n    Flapper public flap;\r\n    Flopper public flop;\r\n    Spotter public spotter;\r\n    Pot     public pot;\r\n    End     public end;\r\n    ESM     public esm;\r\n    DSPause public pause;\r\n\r\n    mapping(bytes32 => Ilk) public ilks;\r\n\r\n    uint8 public step = 0;\r\n\r\n    uint256 constant ONE = 10 ** 27;\r\n\r\n    struct Ilk {\r\n        Flipper flip;\r\n        Clipper clip;\r\n        address join;\r\n    }\r\n\r\n    constructor(\r\n        VatFab vatFab_,\r\n        JugFab jugFab_,\r\n        VowFab vowFab_,\r\n        CatFab catFab_,\r\n        DogFab dogFab_,\r\n        DaiFab daiFab_,\r\n        DaiJoinFab daiJoinFab_,\r\n        FlapFab flapFab_,\r\n        FlopFab flopFab_,\r\n        FlipFab flipFab_,\r\n        ClipFab clipFab_,\r\n        SpotFab spotFab_,\r\n        PotFab potFab_,\r\n        EndFab endFab_,\r\n        ESMFab esmFab_,\r\n        PauseFab pauseFab_\r\n    ) public {\r\n        vatFab = vatFab_;\r\n        jugFab = jugFab_;\r\n        vowFab = vowFab_;\r\n        catFab = catFab_;\r\n        dogFab = dogFab_;\r\n        daiFab = daiFab_;\r\n        daiJoinFab = daiJoinFab_;\r\n        flapFab = flapFab_;\r\n        flopFab = flopFab_;\r\n        flipFab = flipFab_;\r\n        clipFab = clipFab_;\r\n        spotFab = spotFab_;\r\n        potFab = potFab_;\r\n        endFab = endFab_;\r\n        esmFab = esmFab_;\r\n        pauseFab = pauseFab_;\r\n    }\r\n\r\n    function rad(uint wad) internal pure returns (uint) {\r\n        return wad * 10 ** 27;\r\n    }\r\n\r\n    function updateDeployed(\r\n        Vat vat_,\r\n        Jug jug_,\r\n        Vow vow_,\r\n        Cat cat_,\r\n        Dog dog_,\r\n        Dai dai_,\r\n        DaiJoin daiJoin_,\r\n        Flapper flap_,\r\n        Flopper flop_,\r\n        Spotter spot_,\r\n        Pot pot_,\r\n        End end_,\r\n        ESM esm_,\r\n        DSPause pause_\r\n    ) external auth {\r\n        require(address(vat) == address(0), \"Already updated\");\r\n        vat = vat_;\r\n        jug = jug_;\r\n        vow = vow_;\r\n        cat = cat_;\r\n        dog = dog_;\r\n        dai = dai_;\r\n        daiJoin = daiJoin_;\r\n        flap = flap_;\r\n        flop = flop_;\r\n        spotter = spot_;\r\n        pot = pot_;\r\n        end = end_;\r\n        esm = esm_;\r\n        pause = pause_;\r\n     }\r\n\r\n/*\r\n    function deployVat() public auth {\r\n        require(address(vatFab) != address(0), \"Missing Fabs 1\");\r\n        require(address(flapFab) != address(0), \"Missing Fabs 2\");\r\n        require(address(vat) == address(0), \"VAT already deployed\");\r\n        vat = vatFab.newVat(address(this));\r\n        spotter = spotFab.newSpotter(address(this), address(vat));\r\n\r\n        // Internal auth\r\n        vat.rely(address(spotter));\r\n    }\r\n\r\n    function deployDai(uint256 chainId) public auth {\r\n        require(address(vat) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        dai = daiFab.newDai(address(this), chainId);\r\n        daiJoin = daiJoinFab.newDaiJoin(address(vat), address(dai));\r\n        dai.rely(address(daiJoin));\r\n    }\r\n\r\n    function deployTaxation() public auth {\r\n        require(address(vat) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        jug = jugFab.newJug(address(this), address(vat));\r\n        pot = potFab.newPot(address(this), address(vat));\r\n\r\n        // Internal auth\r\n        vat.rely(address(jug));\r\n        vat.rely(address(pot));\r\n    }\r\n\r\n    function deployAuctions(address gov) public auth {\r\n        require(gov != address(0), \"Missing GOV address\");\r\n        require(address(jug) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        flap = flapFab.newFlap(address(this), address(vat), gov);\r\n        flop = flopFab.newFlop(address(this), address(vat), gov);\r\n        vow = vowFab.newVow(address(this), address(vat), address(flap), address(flop));\r\n\r\n        // Internal references set up\r\n        jug.file(\"vow\", address(vow));\r\n        pot.file(\"vow\", address(vow));\r\n\r\n        // Internal auth\r\n        vat.rely(address(flop));\r\n        flap.rely(address(vow));\r\n        flop.rely(address(vow));\r\n    }\r\n\r\n    function deployLiquidator() public auth {\r\n        require(address(vow) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        cat = catFab.newCat(address(this), address(vat));\r\n        dog = dogFab.newDog(address(this), address(vat));\r\n\r\n        // Internal references set up\r\n        cat.file(\"vow\", address(vow));\r\n        dog.file(\"vow\", address(vow));\r\n\r\n        // Internal auth\r\n        vat.rely(address(cat));\r\n        vat.rely(address(dog));\r\n        vow.rely(address(cat));\r\n        vow.rely(address(dog));\r\n    }\r\n\r\n    function deployEnd() public auth {\r\n        require(address(cat) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        end = endFab.newEnd(address(this));\r\n\r\n        // Internal references set up\r\n        end.file(\"vat\", address(vat));\r\n        end.file(\"cat\", address(cat));\r\n        end.file(\"dog\", address(dog));\r\n        end.file(\"vow\", address(vow));\r\n        end.file(\"pot\", address(pot));\r\n        end.file(\"spot\", address(spotter));\r\n\r\n        // Internal auth\r\n        vat.rely(address(end));\r\n        cat.rely(address(end));\r\n        dog.rely(address(end));\r\n        vow.rely(address(end));\r\n        pot.rely(address(end));\r\n        spotter.rely(address(end));\r\n    }\r\n\r\n    function deployPause(uint delay, DSAuthority authority) public auth {\r\n        require(address(dai) != address(0), \"Missing previous step\");\r\n        require(address(end) != address(0), \"Missing previous step\");\r\n\r\n        pause = pauseFab.newPause(delay, address(0), authority);\r\n\r\n        vat.rely(address(pause.proxy()));\r\n        cat.rely(address(pause.proxy()));\r\n        dog.rely(address(pause.proxy()));\r\n        vow.rely(address(pause.proxy()));\r\n        jug.rely(address(pause.proxy()));\r\n        pot.rely(address(pause.proxy()));\r\n        spotter.rely(address(pause.proxy()));\r\n        flap.rely(address(pause.proxy()));\r\n        flop.rely(address(pause.proxy()));\r\n        end.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function deployESM(address gov, uint256 min) public auth {\r\n        require(address(pause) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy ESM\r\n        esm = esmFab.newESM(gov, address(end), address(pause.proxy()), min);\r\n        end.rely(address(esm));\r\n        vat.rely(address(esm));\r\n    }\r\n*/\r\n    function deployCollateralFlip(bytes32 ilk, address join, address pip) public auth {\r\n        require(ilk != bytes32(\"\"), \"Missing ilk name\");\r\n        require(join != address(0), \"Missing join address\");\r\n        require(pip != address(0), \"Missing pip address\");\r\n        require(address(pause) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        ilks[ilk].flip = flipFab.newFlip(address(this), address(vat), address(cat), ilk);\r\n        ilks[ilk].join = join;\r\n        Spotter(spotter).file(ilk, \"pip\", address(pip)); // Set pip\r\n\r\n        // Internal references set up\r\n        cat.file(ilk, \"flip\", address(ilks[ilk].flip));\r\n        vat.init(ilk);\r\n        jug.init(ilk);\r\n\r\n        // Internal auth\r\n        vat.rely(join);\r\n        cat.rely(address(ilks[ilk].flip));\r\n        ilks[ilk].flip.rely(address(cat));\r\n        ilks[ilk].flip.rely(address(end));\r\n        ilks[ilk].flip.rely(address(esm));\r\n        ilks[ilk].flip.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function deployCollateralClip(bytes32 ilk, address join, address pip, address calc) public auth {\r\n        require(ilk != bytes32(\"\"), \"Missing ilk name\");\r\n        require(join != address(0), \"Missing join address\");\r\n        require(pip != address(0), \"Missing pip address\");\r\n        require(calc != address(0), \"Missing calc address\");\r\n        require(address(pause) != address(0), \"Missing previous step\");\r\n\r\n        // Deploy\r\n        ilks[ilk].clip = clipFab.newClip(address(this), address(vat), address(spotter), address(dog), ilk);\r\n        ilks[ilk].join = join;\r\n        Spotter(spotter).file(ilk, \"pip\", address(pip)); // Set pip\r\n\r\n        // Internal references set up\r\n        dog.file(ilk, \"clip\", address(ilks[ilk].clip));\r\n        ilks[ilk].clip.file(\"vow\", address(vow));\r\n        ilks[ilk].clip.file(\"calc\", calc);\r\n        vat.init(ilk);\r\n        jug.init(ilk);\r\n\r\n        // Internal auth\r\n        vat.rely(join);\r\n        vat.rely(address(ilks[ilk].clip));\r\n        dog.rely(address(ilks[ilk].clip));\r\n        ilks[ilk].clip.rely(address(dog));\r\n        ilks[ilk].clip.rely(address(end));\r\n        ilks[ilk].clip.rely(address(esm));\r\n        ilks[ilk].clip.rely(address(pause.proxy()));\r\n    }\r\n\r\n    function releaseAuth() public auth {\r\n        vat.deny(address(this));\r\n        cat.deny(address(this));\r\n        dog.deny(address(this));\r\n        vow.deny(address(this));\r\n        jug.deny(address(this));\r\n        pot.deny(address(this));\r\n        dai.deny(address(this));\r\n        spotter.deny(address(this));\r\n        flap.deny(address(this));\r\n        flop.deny(address(this));\r\n        end.deny(address(this));\r\n    }\r\n\r\n    function releaseAuthFlip(bytes32 ilk) public auth {\r\n        ilks[ilk].flip.deny(address(this));\r\n    }\r\n\r\n    function releaseAuthClip(bytes32 ilk) public auth {\r\n        ilks[ilk].clip.deny(address(this));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"foo\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bar\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fax\",\"type\":\"bytes\"}],\"name\":\"LogNote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Dai", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000038", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fa48af1e0c670a63657c606ce4da2ae2c4c205ad438f56a53342c7e37afed344"}