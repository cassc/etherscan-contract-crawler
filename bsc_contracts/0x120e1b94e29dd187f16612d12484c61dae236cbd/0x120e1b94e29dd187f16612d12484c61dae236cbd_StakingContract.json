{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract StakingContract is ReentrancyGuard {\r\n\tusing SafeMath for uint256;\r\n\r\n    enum Status{\r\n        PENDING,\r\n        FINISHED\r\n    }\r\n    struct Plan {\r\n        uint256 duration;\r\n        uint256 dailyInterestRate;\r\n    }\r\n    struct StakeInfo {\r\n        uint256 amount;\r\n        uint256 planId;\r\n        uint256 lastClaimTimestamp;\r\n        uint256 endTime;\r\n        address tokenAddress;\r\n        Status status;\r\n    }\r\n\r\n    address public owner;\r\n    uint256 public REFERRAL_REWARD = 500; //5%\r\n    uint256 public WITHDRAW_COMMISSION = 500; //5%\r\n\r\n    mapping(uint256 => Plan) public plans;\r\n    mapping(address => StakeInfo[]) public stakes;\r\n    mapping(address => address) public referrers;\r\n    mapping(address => address[]) public referralsList;\r\n    mapping(address => uint256) public totalStakedAmount;\r\n    mapping(address => uint256) public totalReferralsAmount;\r\n    mapping(address => mapping(address => uint256)) public referralRewards;\r\n\r\n    event Staked(address indexed user, uint256 amount, uint256 planId, address referrer);\r\n    event Claimed(address indexed user, uint256 amount, uint256 stakeIndex);\r\n    event Withdrawn(address indexed user, uint256 amount, uint256 stakeIndex);\r\n    event Referral(address indexed user, address indexed referrer, uint256 amount);\r\n    event ReferralBonusClaimed(address indexed user,uint256 bonunAmount);\r\n\r\n    constructor(address _owner) {\r\n        plans[1] = Plan(30 days, 100);\r\n        plans[2] = Plan(60 days, 100);\r\n        plans[3] = Plan(90 days, 100);\r\n        plans[4] = Plan(120 days, 100);\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner{\r\n        require(msg.sender == owner,\"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    function stake(uint256 planId, uint256 amount, address token, address referrer) external nonReentrant {\r\n        require(amount >= 20 ether, \"Minimum stake amount is 20 tokens\");\r\n        require(planId >= 1 && planId <= 4, \"Invalid plan\");\r\n        require(IERC20(token).balanceOf(msg.sender) >= amount, \"Insufficient balance\");\r\n        require(referrer == address(0) || stakes[referrer].length > 0, \"Invalid referrer\");\r\n\r\n        if (stakes[msg.sender].length == 0) {\r\n            uint256 ownerFee = 10 ether; // 10 tokens\r\n            require(amount >= ownerFee, \"Insufficient amount to cover owner fee\");\r\n            IERC20(token).transferFrom(msg.sender, owner, ownerFee);\r\n            amount -= ownerFee;\r\n        }\r\n\r\n        Plan memory plan = plans[planId];\r\n\r\n        uint256 expirationTime = block.timestamp +  plan.duration; \r\n\r\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n        stakes[msg.sender].push(\r\n            StakeInfo(\r\n                amount, \r\n                planId, \r\n                block.timestamp, \r\n                expirationTime, \r\n                token, \r\n                Status.PENDING\r\n            )\r\n        );\r\n        totalStakedAmount[token] += amount;\r\n\r\n        if (referrer != address(0)) {\r\n            address referrerLevel1 = referrers[msg.sender];\r\n            if (referrerLevel1 == address(0) && referrer != msg.sender) {\r\n                referrers[msg.sender] = referrer;\r\n                referralsList[referrer].push(msg.sender);\r\n            }\r\n            uint256 referrerReward = amount * REFERRAL_REWARD / 10000;\r\n            referralRewards[referrer][token] += referrerReward;\r\n            totalReferralsAmount[token] += referrerReward;\r\n            emit Referral(msg.sender, referrer, referrerReward);\r\n        }\r\n\r\n        emit Staked(msg.sender, amount, planId, referrer);\r\n    }\r\n\r\n    function claim(uint256 stakeIndex) external nonReentrant {\r\n        require(stakeIndex < stakes[msg.sender].length, \"Invalid stake index\");\r\n        StakeInfo storage info = stakes[msg.sender][stakeIndex];\r\n        require(info.status == Status.PENDING, \"Already claimed\");\r\n\r\n        uint256 reward = calculateEarnings(msg.sender,stakeIndex);\r\n\r\n        info.lastClaimTimestamp = block.timestamp;\r\n\r\n        IERC20(info.tokenAddress).transfer(msg.sender, reward);\r\n\r\n        emit Claimed(msg.sender, reward, stakeIndex);\r\n    }\r\n\r\n    function withdraw(uint256 stakeIndex) external nonReentrant {\r\n        require(stakeIndex < stakes[msg.sender].length, \"Invalid stake index\");\r\n        StakeInfo storage info = stakes[msg.sender][stakeIndex];\r\n        require(info.status == Status.PENDING, \"Already withdrawn\");\r\n\r\n        uint256 totalAmount = info.amount;\r\n        uint256 withdrawFee = totalAmount * WITHDRAW_COMMISSION / 10000;\r\n        uint256 reward = calculateEarnings(msg.sender,stakeIndex);\r\n        \r\n        info.lastClaimTimestamp = block.timestamp;\r\n        info.status = Status.FINISHED;\r\n        totalAmount += reward;\r\n\r\n        IERC20(info.tokenAddress).transfer(msg.sender, totalAmount.sub(withdrawFee));\r\n        IERC20(info.tokenAddress).transfer(owner, withdrawFee);\r\n\r\n        emit Withdrawn(msg.sender, totalAmount, stakeIndex);\r\n    }\r\n\r\n    function calculateEarnings(address user,uint256 stakeIndex) public view returns (uint256) {\r\n        StakeInfo memory info = stakes[user][stakeIndex];\r\n        Plan memory planInfo = plans[info.planId];\r\n\r\n        uint256 endTime = block.timestamp;\r\n\r\n        if(block.timestamp > info.endTime){\r\n            endTime = info.endTime;\r\n        }\r\n\r\n        uint256 duration = endTime - info.lastClaimTimestamp;\r\n        uint256 dailyRate = 50;\r\n        if (info.amount >= 100001 ether) {\r\n            dailyRate = 300;\r\n        } else if (info.amount >= 50001 ether) {\r\n            dailyRate = 200;\r\n        } else if (info.amount >= 10001 ether) {\r\n            dailyRate = 150;\r\n        } else if (info.amount >= 1001 ether) {\r\n            dailyRate = 100;\r\n        }\r\n\r\n        uint256 reward = (info.amount * dailyRate / 10000) * duration / planInfo.duration;\r\n\r\n        return reward;\r\n    }\r\n\r\n    function claimReferralBonus(address _token) public nonReentrant {\r\n        uint256 bonusAmount = referralRewards[msg.sender][_token];\r\n\r\n        require(bonusAmount > 0, \"Referral bonus is not available\");\r\n    \r\n        referralRewards[msg.sender][_token] = 0;\r\n        IERC20(_token).transfer(msg.sender, bonusAmount);\r\n        emit ReferralBonusClaimed(msg.sender, bonusAmount);\r\n    }   \r\n\r\n    function changeOwner(address _newOwner) public nonReentrant onlyOwner {\r\n        owner = _newOwner;\r\n    } \r\n\r\n    function updateReferralReward(uint256 _newReferralReward) external nonReentrant onlyOwner {\r\n        REFERRAL_REWARD = _newReferralReward;\r\n    }  \r\n\r\n    function updateWithdrawCommission(uint256 _newWithdrawCommission) external nonReentrant onlyOwner {\r\n        WITHDRAW_COMMISSION = _newWithdrawCommission;\r\n    }  \r\n\r\n    function withdrawFunds(address _token,uint256 _amount) public nonReentrant onlyOwner {\r\n        require(IERC20(_token).balanceOf(address(this)) >= _amount, \"Insufficient balance\");\r\n        require(IERC20(_token).transfer(owner, _amount),\"Token transfer failed\");\r\n    }  \r\n\r\n    function updatePlan(uint256 planId, uint256 duration, uint256 dailyInterestRate) public nonReentrant onlyOwner {\r\n        Plan storage plan = plans[planId];\r\n        plan.duration = duration * 1 days;\r\n        plan.dailyInterestRate = dailyInterestRate;\r\n    } \r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function getUserStakes(address user) external view returns (StakeInfo[] memory) {\r\n        return stakes[user];\r\n    }\r\n\r\n    function getReferrerAddress(address user) external view returns (address) {\r\n        return referrers[user];\r\n    }\r\n\r\n    function getUserReferralRewards(address user,address token) external view returns (uint256) {\r\n        return referralRewards[user][token];\r\n    }\r\n\r\n    function getUserReferralList(address user) external view returns (address[] memory) {\r\n        return referralsList[user];\r\n    }\r\n\r\n    function getPlans() external view returns (Plan[] memory) {\r\n        Plan[] memory plansData = new Plan[](4);\r\n        plansData[0] = plans[1];\r\n        plansData[1] = plans[2];\r\n        plansData[2] = plans[3];\r\n        plansData[3] = plans[4];\r\n        return plansData;\r\n    }\r\n\r\n    function getStatsOfToken(address _token) public view returns (uint256, uint256) {\r\n        return (totalStakedAmount[_token], totalReferralsAmount[_token]);\r\n    }  \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Referral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonunAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralBonusClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REFERRAL_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW_COMMISSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"calculateEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimReferralBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlans\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterestRate\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingContract.Plan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getReferrerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getStatsOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserReferralList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserReferralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum StakingContract.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct StakingContract.StakeInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterestRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralsList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"enum StakingContract.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReferralsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterestRate\",\"type\":\"uint256\"}],\"name\":\"updatePlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newReferralReward\",\"type\":\"uint256\"}],\"name\":\"updateReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newWithdrawCommission\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingContract", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ba19e5efd1fb094610076f7a4eb9dde6f59d39e4", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://153ca53a0d22be3057cd49a432932dcf981c457bca71b161bded14c01da728f7"}