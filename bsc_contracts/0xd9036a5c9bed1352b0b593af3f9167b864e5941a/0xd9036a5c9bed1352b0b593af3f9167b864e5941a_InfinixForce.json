{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n   \r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract InfinixForce {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    IERC20 public token;\r\n    uint256 public registrationFee = 1e18; // 1 USDC with 18 decimals\r\n    uint256 public globalReward = 5e17; // 0.5 USDC with 18 decimals\r\n    uint256 public totalContributions;\r\n    uint256 public numberOfUsers;\r\n    bool public systemLive;\r\n\r\n    mapping(address => uint256) public userIDs;\r\n    mapping(uint256 => address) public idToAddress;\r\n    mapping(address => address) public referrers;\r\n    mapping(address => uint256) public referralRewards;\r\n    mapping(uint256 => bool) public paymentsMade;\r\n\r\n    event Registration(address indexed user, address indexed directReferrer);\r\n    event RegistrationFeeChanged(uint256 newFee);\r\n\r\n    constructor(address _token) {\r\n        owner = msg.sender;\r\n        setTokenContract(_token);\r\n        numberOfUsers = 1;\r\n        userIDs[owner] = numberOfUsers;\r\n        idToAddress[numberOfUsers] = owner;\r\n    }\r\n\r\n    function setTokenContract(address _token) public onlyOwner {\r\n        require(_token != address(0), \"Invalid token address\");\r\n        token = IERC20(_token);\r\n    }\r\n function setRegistrationFee(uint256 newFee) external onlyOwner {\r\n        require(newFee > 0, \"Registration fee must be greater than zero\");\r\n        registrationFee = newFee;\r\n            \r\n                emit RegistrationFeeChanged(newFee);\r\n    }\r\n\r\n    function register(address directReferrer) external {\r\n        require(userIDs[msg.sender] == 0, \"User already registered\");\r\n        require(directReferrer != msg.sender, \"Cannot be your own referrer\");\r\n\r\n        // Ensure the user has approved the contract to spend the registration fee\r\n        require(token.allowance(msg.sender, address(this)) >= registrationFee, \"Insufficient allowance\");\r\n\r\n        // Check if the user has enough balance\r\n        require(token.balanceOf(msg.sender) >= registrationFee, \"Insufficient balance\");\r\n\r\n        // Transfer the registration fee from the user's allowance\r\n        require(token.transferFrom(msg.sender, address(this), registrationFee), \"Token transfer failed\");\r\n\r\n        // Assuming token is an instance of the USDC token contract\r\n        address contractAddress = address(this);\r\n        token.approve(contractAddress, registrationFee);\r\n\r\n        numberOfUsers = numberOfUsers.add(1);\r\n        uint256 userID = numberOfUsers;\r\n        userIDs[msg.sender] = userID;\r\n        idToAddress[userID] = msg.sender;\r\n        referrers[msg.sender] = directReferrer;\r\n\r\n        // Distribute referral rewards\r\n        _distributeReferralRewards(msg.sender, registrationFee);\r\n\r\n        // Distribute random registration reward\r\n        _distributeRandomRegistrationReward(registrationFee);\r\n\r\n        // Update contribution tracking\r\n        totalContributions = totalContributions.add(registrationFee);\r\n\r\n        // Emit registration event\r\n        emit Registration(msg.sender, directReferrer);\r\n    }\r\n\r\n\r\n\r\n\r\n    function _distributeReferralRewards(address user, uint256 amount) internal {\r\n        address directReferrer = referrers[user];\r\n        address indirectReferrer = referrers[directReferrer];\r\n        address indirectReferrerOfReferrer = referrers[indirectReferrer];\r\n\r\n        uint256 directReferrerReward = amount.mul(50).div(100);\r\n        uint256 indirectReferrerReward = amount.mul(10).div(100);\r\n        uint256 indirectReferrerOfReferrerReward = amount.mul(10).div(100);\r\n        uint256 non_working = amount.mul(10).div(100);\r\n\r\n        if (userIDs[indirectReferrer] != 0) {\r\n            require(token.transfer(indirectReferrer, indirectReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrer] = referralRewards[indirectReferrer].add(indirectReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[indirectReferrerOfReferrer] != 0) {\r\n            require(token.transfer(indirectReferrerOfReferrer, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrerOfReferrer] = referralRewards[indirectReferrerOfReferrer].add(indirectReferrerOfReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[directReferrer] != 0) {\r\n            require(token.transfer(directReferrer, directReferrerReward), \"Token transfer failed\");\r\n            referralRewards[directReferrer] = referralRewards[directReferrer].add(directReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, directReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        // Distribute creator reward\r\n        require(token.transfer(owner, non_working), \"Token transfer failed\");\r\n    }\r\n\r\n    function _distributeRandomRegistrationReward(uint256 amount) internal {\r\n        uint256 randomReward = amount.mul(20).div(100);\r\n        uint256 randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, numberOfUsers))) % numberOfUsers + 1;\r\n        address randomUser = idToAddress[randomUserID];\r\n        require(token.transfer(randomUser, randomReward), \"Token transfer failed\");\r\n        paymentsMade[randomUserID] = true;\r\n    }\r\n\r\n    function distributeEarnings() external {\r\n        require(totalContributions > 0, \"No contributions to distribute\");\r\n        require(token.balanceOf(address(this)) > 0, \"Contract balance is zero\");\r\n\r\n        uint256 remainingReward = token.balanceOf(address(this)).mul(20).div(100);\r\n        uint256 ownerReward = token.balanceOf(address(this)).mul(10).div(100);\r\n\r\n        // Distribute remaining reward to 4 random users\r\n        _distributeRandomRewards(remainingReward);\r\n\r\n        // Distribute owner reward\r\n        require(token.transfer(owner, ownerReward), \"Token transfer failed\");\r\n\r\n        totalContributions = 0; // Reset contributions after distribution\r\n    }\r\n\r\n    function _distributeRandomRewards(uint256 amount) internal {\r\n        uint256 userLimit = numberOfUsers;\r\n        if (userLimit > 4) {\r\n            userLimit = 4;\r\n        }\r\n\r\n        for (uint256 i = 1; i <= userLimit; i++) {\r\n            uint256 randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n            address randomUser = idToAddress[randomUserID];\r\n            require(token.transfer(randomUser, amount), \"Token transfer failed\");\r\n            paymentsMade[randomUserID] = true;\r\n        }\r\n    }\r\n\r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        revert(\"Contract does not accept Ether directly. Use register function for token payments.\");\r\n    }\r\n    function systemActiveInactive() onlyOwner public {\r\n    systemLive = !systemLive;\r\n}\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"RegistrationFeeChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentsMade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemActiveInactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InfinixForce", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c6e07189bc7565d53ce1c7744879620ccc70c17f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://99f838d56e33b34a3ced441275b797d5867eaf0491037a46819cd495dd3e658b"}