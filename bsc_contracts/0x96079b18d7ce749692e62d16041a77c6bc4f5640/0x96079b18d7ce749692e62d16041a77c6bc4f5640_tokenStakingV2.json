{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IStaking {\\n\\n    struct Pool {\\n        address token;\\n        address rewardToken;\\n        uint minimumDeposit;\\n        uint roi;\\n        uint bonusRoi;\\n        uint roiStep;\\n        uint rquirePool;\\n        uint requireAmount;\\n        uint blockDuration;\\n        uint nftId;\\n    }\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        address user;\\n        address referrer;\\n        uint investment;\\n        uint stakingValue;\\n        uint rewardLockedUp;\\n        uint totalDeposit;\\n        uint totalWithdrawn;\\n        uint nextWithdraw;\\n        uint unlockDate;\\n        uint depositCheckpoint;\\n        uint busdTotalDeposit;\\n        uint nftBalance;\\n    }\\n\\n    struct RefData {\\n        address referrer;\\n        uint amount;\\n        bool exists;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IVault {\\n\\n    function safeTransfer(IERC20 from, address to, uint amount) external;\\n\\n    function safeTransfer(address _to, uint _value) external;\\n\\n    function getTokenAddressBalance(address token) external view returns (uint);\\n\\n    function getTokenBalance(IERC20 token) external view returns (uint);\\n\\n    function getBalance() external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/resources/IContractsLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\nabstract contract IContractsLibrary {\\n    function BUSD() external view virtual returns (address);\\n\\n    function WBNB() external view virtual returns (address);\\n\\n    function ROUTER() external view virtual returns (IUniswapV2Router01);\\n\\n    function getBusdToBNBToToken(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBNBtoBusd(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBnb(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getBnbToTokens(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getTokenToBnbToAltToken(\\n        address token,\\n        address altToken,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getLpPrice(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getUsdToBnB(uint amount) external view virtual returns (uint256);\\n\\n    function getBnbToUsd(uint amount) external view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/resources/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/satkingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"./StakingStateV2.sol\\\";\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./resources/IContractsLibrary.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\ncontract tokenStakingV2 is StakingStateV2, ReentrancyGuard, ERC1155Holder, IStaking {\\n    using SafeMath for uint;\\n    // uint internal constant PERCENT_DIVIDER = 1000; // 1000 = 100%, 100 = 10%, 10 = 1%, 1 = 0.1%\\n    IVault public vault;\\n    IContractsLibrary public contractsLibrary;\\n    IERC1155 public nft;\\n\\n    mapping(address => RefData) public referrers;\\n\\n    uint public constant minPool = 1;\\n    uint public poolsLength = 0;\\n    mapping(uint => mapping(address => UserInfo)) public users;\\n\\n    mapping(address => uint) public lastBlock;\\n    mapping(uint => Pool) public pools;\\n\\n    bool public forceAllowed;\\n\\n    event Newbie(address user);\\n    event NewDeposit(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RefBonus(\\n        address indexed referrer,\\n        address indexed referral,\\n        uint256 indexed level,\\n        uint256 amount\\n    );\\n    event FeePayed(address indexed user, uint256 totalAmount);\\n    event Reinvestment(address indexed user, uint256 amount);\\n    event ForceWithdraw(address indexed user, uint256 amount);\\n\\n    constructor(\\n        address _vault,\\n        address _library,\\n        address _token,\\n        address _nft\\n    ) {\\n        devAddress = msg.sender;\\n        vault = IVault(_vault);\\n        contractsLibrary = IContractsLibrary(_library);\\n        nft = IERC1155(_nft);\\n\\n        pools[1] = Pool({\\n            token: _token,\\n            rewardToken: address(0),\\n            minimumDeposit: 0,\\n            roi: 30,\\n            bonusRoi: 30,\\n            roiStep: MONTH_STEP,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockDuration: MONTH_STEP,\\n            nftId: 0\\n        });\\n\\n        pools[2] = Pool({\\n            token: _token,\\n            rewardToken: address(0),\\n            minimumDeposit: 0,\\n            roi: 50,\\n            bonusRoi: 50,\\n            roiStep: MONTH_STEP,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockDuration: MONTH_STEP * 2,\\n            nftId: 0\\n        });\\n\\n        pools[3] = Pool({\\n            token: _token,\\n            rewardToken: address(0),\\n            minimumDeposit: 0,\\n            roi: 80,\\n            bonusRoi: 70,\\n            roiStep: MONTH_STEP,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockDuration: MONTH_STEP * 3,\\n            nftId: 0\\n        });\\n\\n        poolsLength = 3;\\n    }\\n\\n    modifier tenBlocks() {\\n        require(block.number.sub(lastBlock[msg.sender]) > 10, \\\"wait 10 blocks\\\");\\n        _;\\n        lastBlock[msg.sender] = block.number;\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    modifier isNotContract() {\\n        require(!isContract(msg.sender), \\\"contract not allowed\\\");\\n        _;\\n    }\\n\\n    function invest(\\n        uint _pool,\\n        uint amount\\n    )\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        require(amount > 0, \\\"Amount must be greater than 0\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        UserInfo storage user = users[_pool][msg.sender];\\n        Pool memory pool = pools[_pool];\\n        require(user.stakingValue == 0, \\\"User already invested\\\");\\n\\n        if (pool.rquirePool > 0) {\\n            require(\\n                users[pool.rquirePool][msg.sender].totalDeposit >=\\n                    pool.requireAmount,\\n                \\\"Require amount\\\"\\n            );\\n        }\\n        if (pool.minimumDeposit > 0) {\\n            require(amount >= pool.minimumDeposit, \\\"Minimum deposit\\\");\\n        }\\n\\n        IERC20(pool.token).transferFrom(msg.sender, address(vault), amount);\\n\\n        RefData storage refData = referrers[msg.sender];\\n        if (!refData.exists) {\\n            refData.exists = true;\\n            totalUsers++;\\n            emit Newbie(msg.sender);\\n        }\\n\\n        if (user.user == address(0)) {\\n            user.user = msg.sender;\\n            investors[_pool][totalUsers] = msg.sender;\\n        }\\n        updateDeposit(msg.sender, _pool);\\n        users[_pool][msg.sender].investment += amount;\\n\\n        if (pool.token == pool.rewardToken) {\\n            users[_pool][msg.sender].stakingValue += amount;\\n        } else if (pool.rewardToken == address(0)) {\\n            users[_pool][msg.sender].stakingValue += contractsLibrary\\n                .getTokensToBnb(pool.token, amount);\\n        } else {\\n            users[_pool][msg.sender].stakingValue += contractsLibrary\\n                .getTokenToBnbToAltToken(pool.token, pool.rewardToken, amount);\\n        }\\n        users[_pool][msg.sender].totalDeposit += amount;\\n\\n        totalInvested[_pool] += amount;\\n        totalDeposits[_pool]++;\\n\\n        if (user.nextWithdraw == 0) {\\n            user.nextWithdraw = block.timestamp + HARVEST_DELAY;\\n        }\\n\\n        user.unlockDate = block.timestamp + pool.blockDuration;\\n\\n        emit NewDeposit(msg.sender, amount);\\n    }\\n\\n    function payBonus(uint _pool) external nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction {\\n            require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n            UserInfo storage user = users[_pool][msg.sender];\\n            require(user.stakingValue > 0, \\\"User not invested\\\");\\n            require(user.nftBalance == 0, \\\"User already has bonus\\\");\\n            require(user.unlockDate > block.timestamp, \\\"Token is unlocked\\\");\\n            Pool memory pool = pools[_pool];\\n            uint nftBalance = nft.balanceOf(msg.sender, pool.nftId);\\n            require(nftBalance > 0, \\\"User has no NFT\\\");\\n            updateDeposit(msg.sender, _pool);\\n            user.nftBalance = 1;\\n            nft.safeTransferFrom(msg.sender, address(this), pool.nftId, 1, \\\"\\\");\\n        }\\n\\n    function payToUser(uint _pool, bool _withdraw) internal {\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        updateDeposit(msg.sender, _pool);\\n        uint fromVault;\\n        uint nftBalance;\\n        if (_withdraw) {\\n            require(\\n                block.timestamp >= users[_pool][msg.sender].unlockDate,\\n                \\\"Token is locked\\\"\\n            );\\n            fromVault = users[_pool][msg.sender].investment;\\n            nftBalance = users[_pool][msg.sender].nftBalance;\\n            delete users[_pool][msg.sender].investment;\\n            delete users[_pool][msg.sender].stakingValue;\\n            delete users[_pool][msg.sender].nextWithdraw;\\n            delete users[_pool][msg.sender].nftBalance;\\n            delete users[_pool][msg.sender].unlockDate;\\n        } else {\\n            users[_pool][msg.sender].nextWithdraw =\\n                block.timestamp +\\n                HARVEST_DELAY;\\n        }\\n        uint formThis = users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        uint _toWithdraw = formThis;\\n        totalWithdrawn[_pool] += _toWithdraw;\\n        users[_pool][msg.sender].totalWithdrawn += _toWithdraw;\\n        if (fromVault > 0) {\\n            vault.safeTransfer(\\n                IERC20(pools[_pool].token),\\n                msg.sender,\\n                fromVault\\n            );\\n        }\\n        if(nftBalance > 0) {\\n            nft.safeTransferFrom(address(this), msg.sender, pools[_pool].nftId, nftBalance, \\\"\\\");\\n        }\\n        address tokenReward = pools[_pool].rewardToken;\\n        if (tokenReward == address(0)) {\\n            payable(msg.sender).transfer(formThis);\\n        } else {\\n            IERC20(tokenReward).transfer(msg.sender, formThis);\\n        }\\n        emit Withdrawn(msg.sender, _toWithdraw);\\n    }\\n\\n    function harvest(\\n        uint _pool\\n    )\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payToUser(_pool, false);\\n    }\\n\\n    function withdraw(\\n        uint _pool\\n    )\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payToUser(_pool, true);\\n    }\\n\\n    function forceWithdraw(\\n        uint _pool\\n    ) external nonReentrant whenNotPaused tenBlocks isNotContract {\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(forceAllowed, \\\"Force withdraw is not allowed\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        uint toTransfer = users[_pool][msg.sender].investment;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].investment;\\n        delete users[_pool][msg.sender].stakingValue;\\n        delete users[_pool][msg.sender].nextWithdraw;\\n        delete users[_pool][msg.sender].unlockDate;\\n        // users[_pool][msg.sender].totalWithdrawn += toTransfer;\\n        delete users[_pool][msg.sender].depositCheckpoint;\\n        uint nftBalance = users[_pool][msg.sender].nftBalance;\\n        delete users[_pool][msg.sender].nftBalance;\\n        // totalWithdrawn[_pool] += toTransfer;\\n        require(toTransfer > 0, \\\"Nothing to withdraw\\\");\\n        vault.safeTransfer(IERC20(pools[_pool].token), msg.sender, toTransfer);\\n        if(nftBalance > 0) {\\n            nft.safeTransferFrom(address(this), msg.sender, pools[_pool].nftId, nftBalance, \\\"\\\");\\n        }\\n\\n        emit ForceWithdraw(msg.sender, toTransfer);\\n    }\\n\\n    function getReward(\\n        uint _weis,\\n        uint _seconds,\\n        uint _pool,\\n        address _user\\n    ) public view returns (uint) {\\n        Pool memory pool = pools[_pool];\\n        uint roi = pool.roi;\\n        if(users[_pool][_user].nftBalance > 0) {\\n            roi += pool.bonusRoi;\\n        }\\n        return\\n            (_weis * _seconds * roi) /\\n            (pool.roiStep * PERCENT_DIVIDER);\\n    }\\n\\n    function userCanwithdraw(\\n        address user,\\n        uint _pool\\n    ) public view returns (bool) {\\n        if (block.timestamp > users[_pool][user].nextWithdraw) {\\n            if (users[_pool][user].stakingValue > 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function getDeltaPendingRewards(\\n        address _user,\\n        uint _pool\\n    ) public view returns (uint) {\\n        if (users[_pool][_user].depositCheckpoint == 0) {\\n            return 0;\\n        }\\n        uint time = block.timestamp;\\n        if (stopProductionDate > 0 && time > stopProductionDate) {\\n            time = stopProductionDate;\\n        }\\n        if(time > users[_pool][_user].unlockDate) {\\n            time = users[_pool][_user].unlockDate;\\n        }\\n\\n        if(time <= users[_pool][_user].depositCheckpoint) {\\n            return 0;\\n        }\\n        return\\n            getReward(\\n                users[_pool][_user].stakingValue,\\n                time.sub(users[_pool][_user].depositCheckpoint),\\n                _pool,\\n                _user\\n            );\\n    }\\n\\n    function getUserTotalPendingRewards(\\n        address _user,\\n        uint _pool\\n    ) public view returns (uint) {\\n        return\\n            users[_pool][_user].rewardLockedUp +\\n            getDeltaPendingRewards(_user, _pool);\\n    }\\n\\n    function updateDeposit(address _user, uint _pool) internal {\\n        users[_pool][_user].rewardLockedUp = getUserTotalPendingRewards(\\n            _user,\\n            _pool\\n        );\\n        users[_pool][_user].depositCheckpoint = block.timestamp;\\n    }\\n\\n    function getUser(\\n        address _user,\\n        uint _pool\\n    ) external view returns (UserInfo memory userInfo_, uint pendingRewards) {\\n        userInfo_ = users[_pool][_user];\\n        pendingRewards = getUserTotalPendingRewards(_user, _pool);\\n    }\\n\\n    function getAllUsers(uint _pool) external view returns (UserInfo[] memory) {\\n        UserInfo[] memory result = new UserInfo[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            result[i] = users[_pool][investors[_pool][i]];\\n        }\\n        return result;\\n    }\\n\\n    function getUsersRange(uint _pool, uint _from, uint _to)\\n        external\\n        view\\n        returns (UserInfo[] memory)\\n    {\\n        require(_from < _to, \\\"Invalid range\\\");\\n        require(_to <= totalUsers, \\\"Invalid range\\\");\\n        UserInfo[] memory result = new UserInfo[](_to - _from);\\n        for (uint i = _from; i < _to; i++) {\\n            result[i - _from] = users[_pool][investors[_pool][i]];\\n        }\\n        return result;\\n    }\\n\\n    function getUserByIndex(\\n        uint _pool,\\n        uint _index\\n    ) external view returns (UserInfo memory) {\\n        require(_index < totalUsers, \\\"Index out of bounds\\\");\\n        return users[_pool][investors[_pool][_index]];\\n    }\\n\\n    function addPool(\\n        address _token,\\n        address _rewardToken,\\n        uint _minimumDeposit,\\n        uint roi,\\n        uint _bonusRoi,\\n        uint roiStep,\\n        uint _requirePool,\\n        uint _requireAmount,\\n        uint _blockDuration,\\n        uint _nftId\\n    ) external onlyOwner {\\n        poolsLength++;\\n        pools[poolsLength] = Pool({\\n            token: _token,\\n            rewardToken: _rewardToken,\\n            minimumDeposit: _minimumDeposit,\\n            roi: roi,\\n            bonusRoi: _bonusRoi,\\n            roiStep: roiStep,\\n            rquirePool: _requirePool,\\n            requireAmount: _requireAmount,\\n            blockDuration: _blockDuration,\\n            nftId: _nftId\\n        });\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n\\n    function takeBNB() external onlyOwner {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n    \\n    function takeTokens(address _token, uint _bal) external onlyOwner {\\n        IERC20(_token).transfer(msg.sender, _bal);\\n    }\\n\\n    function setAllowForceWithdraw(bool _forceAllowed) external onlyOwner {\\n        forceAllowed = _forceAllowed;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakingStateV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ncontract StakingStateV2 {\\n    address public devAddress;\\n    mapping(uint => mapping(uint => address)) public investors;\\n    uint internal constant TIME_STEP = 1 days;\\n    uint internal constant MONTH_STEP = 30 * TIME_STEP;\\n    uint internal constant HARVEST_DELAY = TIME_STEP;\\n    // uint internal constant BLOCK_TIME_STEP = 30 * TIME_STEP;\\n    uint internal constant PERCENT_DIVIDER = 1000;\\n    uint internal constant REFERRER_PERCENTS = 50;\\n\\n    uint public initDate;\\n\\n    uint internal totalUsers;\\n    mapping(uint => uint) internal totalInvested;\\n    mapping(uint => uint) internal totalWithdrawn;\\n    mapping(uint => uint) internal totalReinvested;\\n    mapping(uint => uint) internal totalDeposits;\\n    mapping(uint => uint) internal totalReinvestCount;\\n    uint public stopProductionDate;\\n    bool public stopProductionVar;\\n    bool public referrer_is_allowed = true;\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    modifier hasStoppedProduction() {\\n        require(hasStoppedProductionView(), \\\"Production is not stopped\\\");\\n        _;\\n    }\\n\\n    modifier hasNotStoppedProduction() {\\n        require(!hasStoppedProductionView(), \\\"Production is stopped\\\");\\n        _;\\n    }\\n\\n    function hasStoppedProductionView() public view returns (bool) {\\n        return stopProductionVar;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(devAddress == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(initDate > 0, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(initDate == 0, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function stopProduction() external onlyOwner {\\n        stopProductionVar = true;\\n        stopProductionDate = block.timestamp;\\n    }\\n\\n    function unpause() external whenPaused onlyOwner {\\n        initDate = block.timestamp;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    function isPaused() public view returns (bool) {\\n        return initDate == 0;\\n    }\\n\\n    function getDAte() external view returns (uint) {\\n        return block.timestamp;\\n    }\\n\\n    function getPublicData(uint _pool)\\n        external\\n        view\\n        returns (\\n            uint totalUsers_,\\n            uint totalInvested_,\\n            uint totalDeposits_,\\n            uint totalReinvested_,\\n            uint totalReinvestCount_,\\n            uint totalWithdrawn_,\\n            bool isPaused_\\n        )\\n    {\\n        totalUsers_ = totalUsers;\\n        totalInvested_ = totalInvested[_pool];\\n        totalDeposits_ = totalDeposits[_pool];\\n        totalReinvested_ = totalReinvested[_pool];\\n        totalReinvestCount_ = totalReinvestCount[_pool];\\n        totalWithdrawn_ = totalWithdrawn[_pool];\\n        isPaused_ = isPaused();\\n    }\\n\\n    function getAllInvestors(\\n        uint _pool\\n    ) external view returns (address[] memory) {\\n        address[] memory investorsList = new address[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            investorsList[i] = investors[_pool][i];\\n        }\\n        return investorsList;\\n    }\\n\\n    function getInvestorByIndex(\\n        uint _pool,\\n        uint index\\n    ) external view returns (address) {\\n        require(index < totalUsers, \\\"Index out of range\\\");\\n        return investors[_pool][index];\\n    }\\n\\n    function setReferrerIsAllowed(\\n        bool _referrer_is_allowed\\n    ) external onlyOwner {\\n        referrer_is_allowed = _referrer_is_allowed;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_library\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForceWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requirePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requireAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsLibrary\",\"outputs\":[{\"internalType\":\"contract IContractsLibrary\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"forceWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct IStaking.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getDeltaPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getPublicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUsers_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvestCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct IStaking.UserInfo\",\"name\":\"userInfo_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"pendingRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct IStaking.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUserTotalPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getUsersRange\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftBalance\",\"type\":\"uint256\"}],\"internalType\":\"struct IStaking.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasStoppedProductionView\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"payBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rquirePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requireAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrer_is_allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_forceAllowed\",\"type\":\"bool\"}],\"name\":\"setAllowForceWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_referrer_is_allowed\",\"type\":\"bool\"}],\"name\":\"setReferrerIsAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProduction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionVar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"takeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"userCanwithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "tokenStakingV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000db04b87149cbadf97370d5a1796def163c3b995000000000000000000000000036268f5e49208949c072aa4108a03dbe7ae30ecb0000000000000000000000003bdeecae844b96a133f98e54e36eb85414ffe5c900000000000000000000000023000af0eccc4bf8454ba6edd882a20b0e2beef6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}