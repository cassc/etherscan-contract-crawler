{"SourceCode": "{\"Smart_Binance.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\nimport \\\"./Smart_Binary.sol\\\";\\ncontract Smart_Binance is Context {\\n    using SafeERC20 for IERC20; struct SEP { uint24 LD; uint24 RD; uint8 TCP; uint16 DP; uint8 CH; uint8 OR; address UPA; address LDA; address RDA;}\\n    mapping(address =\\u003e SEP) private _XB; mapping(uint128 =\\u003e address) private JK; mapping(uint16 =\\u003e address) private _DUP;\\n    address[] private EW; address[] private _PY; address[] private _X_N; uint32[] private _RNN; uint256 private LSR;\\n    uint256 private LRF; uint256 private V_F; uint128 private _U_Z; uint128 private ZA_D; uint64 private _CF; uint64 private _CU_PY;\\n    uint16 private _DUPId; uint8 private Lk; uint8 private Count_Upload; uint8 C_G; address private R_S; address private _SBT; address private Operator;\\n    IERC20 private S_Coin; string private Note; string private IPFS; Smart_Binary private NBJ;\\n    constructor() {R_S = _msgSender(); LSR = block.timestamp;\\n        S_Coin = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\n        _SBT = 0x52B5BD79C5B56B52747d735809177d9ee686E48e;\\n        Operator = 0xF9B29B8853c98B68c19f53F5b39e69eF6eAF1e2c;\\n        NBJ = Smart_Binary(0x3164B3841D2b603ddB43C909C7f6Efd787058541);}\\n    function Reward_12() public {require(Lk == 0, \\\"Proccesing\\\");\\n        require(_XB[_msgSender()].TCP \\u003e 0, \\\"You dont have point\\\" );\\n        require(block.timestamp \\u003e LSR + 12 hours, \\\"Reward_12 time has not come\\\");\\n        Lk = 1; uint256 ZZ = (PRP() * 90) - (Total_Point() * 10**18); V_F = (PRP() * 10);\\n        uint256 QA = ((ZZ)) / Total_Point(); uint128 R_C = (Total_Point()) * 10**18;\\n        for(uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)) {SEP memory T_DE = _XB[JK[i]];\\n        uint24 Pnt; uint24 RLT = T_DE.LD \\u003c= T_DE.RD ? T_DE.LD : T_DE.RD;\\n        if (RLT \\u003e 0) {if (RLT \\u003e 25) {Pnt = 25; if (T_DE.LD \\u003c RLT) { T_DE.LD = 0; T_DE.RD -= RLT;} \\n        else if (T_DE.RD \\u003c RLT) {T_DE.LD -= RLT; T_DE.RD = 0;} else {T_DE.LD -= RLT; T_DE.RD -= RLT;}} else {Pnt = RLT; \\n        if (T_DE.LD \\u003c Pnt) {T_DE.LD = 0; T_DE.RD -= Pnt;} else if (T_DE.RD \\u003c Pnt) { T_DE.LD -= Pnt; T_DE.RD = 0;} \\n        else {T_DE.LD -= Pnt; T_DE.RD -= Pnt;}} T_DE.TCP = 0; _XB[JK[i]] = T_DE;\\n        if (Pnt * QA \\u003e S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(JK[i],S_Coin.balanceOf(address(this)));} \\n        else {S_Coin.safeTransfer( JK[i], Pnt * QA);}_PY.push(JK[i]); _CU_PY++;}} LSR = block.timestamp;\\n        if (R_C \\u003c= S_Coin.balanceOf(address(this))) {S_Coin.safeTransfer(_msgSender(), R_C);} Lk = 0; C_G = 1; LRF = block.timestamp;}\\n    function Register(address upline) public {require(_XB[upline].CH != 2,\\\"Upline has two directs!\\\");\\n        require(_msgSender() != upline, \\\"You can not enter your address!\\\");\\n        bool UU = false; for(uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {UU = true; break;}} require(UU == false, \\\"You were registered!\\\");\\n        bool WH = false; for(uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == upline) { WH = true; break;}} require(WH == true, \\\"Upline is not exist!\\\");\\n        S_Coin.safeTransferFrom(_msgSender(), address(this), 100 * 10**18 ); JK[_U_Z] = _msgSender(); _U_Z++;\\n        uint16 D_X = _XB[upline].DP + 1; _XB[_msgSender()] = SEP(0,0,0,D_X,0,_XB[upline].CH, upline, address(0), address(0));\\n        if (_XB[upline].CH == 0) { _XB[upline].LD++; _XB[upline].LDA = _msgSender();} else {_XB[upline].RD++; _XB[upline].RDA = _msgSender(); } _XB[upline].CH++; setTDP(upline);\\n        address UPN = _XB[upline].UPA; address ChNde = upline; for( uint128 j = 0; j \\u003c _XB[upline].DP; j = unsafe_inc(j)){ \\n        if (_XB[ChNde].OR == 0) {_XB[UPN].LD++; } else {_XB[UPN].RD++; } setTDP(UPN); ChNde = UPN; UPN = _XB[UPN].UPA;}}\\n    function Gift_3() public {require(C_G == 1,\\\"Gift_3 time has not come!\\\");\\n        require(block.timestamp \\u003e LRF + 3 hours, \\\"Gift_3 time has not come\\\");\\n        require(V_F \\u003e 20*10**18, \\\"Gift balance is not enough!\\\" );\\n        require(_CF \\u003e 0, \\\"There is no candidate!\\\" );\\n        bool II = false; for(uint128 i = 0; i \\u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) {II = true; break;}}\\n        require(II == true, \\\"You are not candidated!\\\"); S_Coin.safeTransfer(_msgSender(),10 * 10**18);\\n        uint256 NW = ((V_F - 10*10**18) / 10**18) / 10; if (NW != 0 \\u0026\\u0026 _CF != 0) {if (_CF \\u003e NW) {\\n        for(uint32 i = 1; i \\u003c= _CF; i++ ) {_RNN.push(i);} for(uint128 i = 1; i \\u003c= NW; i = unsafe_inc(i)){\\n        uint256 randomIndex = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, i))) % _CF;\\n        uint128 RSN = _RNN[randomIndex]; _RNN[randomIndex] = _RNN[ _RNN.length - 1 ]; _RNN.pop();\\n        if(_XB[EW[RSN - 1]].TCP == 0){ S_Coin.safeTransfer(EW[RSN - 1], 10 * 10**18 );}}\\n        for(uint128 i = 0; i \\u003c (_CF - NW); i = unsafe_inc(i)) {_RNN.pop();}} else {for (uint128 i = 0; i \\u003c _CF; i = unsafe_inc(i))\\n        {S_Coin.safeTransfer(EW[i], 10 * 10**18 );}}} delete EW; _CF = 0; V_F = 0; C_G = 0; delete _PY; _CU_PY=0;}\\n    function Smart_Gift() public { require(C_G == 1,\\\"Smart_Gift time has not come!\\\");\\n        bool UPY = false; for(uint128 i = 0; i \\u003c _CU_PY; i = unsafe_inc(i)) {if (_PY[i] == _msgSender()) { UPY = true; break;}}  require(UPY == false, \\\"You have point!\\\");\\n        bool UU = false; for(uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) { UU = true; break;}}\\n        require(UU == true, \\\"You are not registered!\\\");\\n        bool II = false; for(uint128 i = 0; i \\u003c _CF; i = unsafe_inc(i)) {if (EW[i] == _msgSender()) { II = true; break;}}\\n        require(II == false, \\\"You were candidated!\\\");\\n        require(((((V_F - 10*10**18) / 10**18) / 10)*2) \\u003e (_CF), \\\"Capacity is completed!\\\"); EW.push(_msgSender()); _CF++;}\\n    function Emergency_72() public {require(_msgSender() == Operator, \\\"Just operator can write!\\\");\\n        require(block.timestamp \\u003e LSR + 72 hours, \\\"Emergency_72 time has not come\\\");\\n        S_Coin.safeTransfer(R_S, S_Coin.balanceOf(address(this)) );}\\n    function Buy_SBT() public {require(S_Coin.balanceOf(_msgSender()) \\u003e= (10 * 10**18), \\\"You dont have enough S_Coin!\\\");\\n        S_Coin.safeTransferFrom(_msgSender(),address(this), 10 * 10**18 ); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18);}\\n    function Get_SBT() public {bool CC = false; for (uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == _msgSender()) {CC = true; break;}}\\n        require(CC == true, \\\"You are not registered!\\\" );\\n        bool TAU = false; for (uint128 i = 0; i \\u003c ZA_D; i = unsafe_inc(i)) {if (_X_N[i] == _msgSender()) {TAU = true; break;}}\\n        require(TAU == false,\\\"You can not receive SBT again!\\\"); IERC20(_SBT).transfer(_msgSender(), 100 * 10**18); _X_N.push(_msgSender()); ZA_D++;}\\n    function Import (address User) public {\\n        bool UU = false; for(uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)) {if (JK[i] == User) {UU = true; break;}} require(UU == false, \\\"You were registered!\\\");\\n        bool TDUP = false; for(uint16 i = 0; i \\u003c= _DUPId; i++) {if (_DUP[i] == User) {TDUP = true; break;}} require(TDUP == false, \\\"You were uploaded!\\\");\\n        require(NBJ.User_Information(User).UplineAddress != address(0), \\\"You were not in Smart Binary\\\");\\n        JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP( \\n          uint24(NBJ.User_Information(User).leftDirect),\\n          uint24(NBJ.User_Information(User).rightDirect), 0,\\n          uint16(NBJ.User_Information(User).depth),\\n          uint8(NBJ.User_Information(User).childs),\\n          uint8(NBJ.User_Information(User).leftOrrightUpline),\\n        NBJ.User_Information(User).UplineAddress,\\n        NBJ.User_Information(User).leftDirectAddress,\\n        NBJ.User_Information(User).rightDirectAddress); _U_Z++;}\\n    function Upload (address User, uint24 L, uint24 R, uint16 D, uint8 C, uint8 LR, address UA, address LA, address RA) \\n    public {require(_msgSender() == Operator, \\\"Just operator can write!\\\");\\n    require(Count_Upload \\u003c= 60, \\\"Its over!\\\"); JK[_U_Z] = User; _XB[JK[_U_Z]] = SEP(L,R,0,D,C,LR,UA,LA,RA); _U_Z++; Count_Upload++;}\\n    function Stable_Coin(address add) public{ require(_msgSender() == Operator, \\\"Just operator can write!\\\"); S_Coin = IERC20(add);}\\n    function PRP() private view returns (uint256) { return (S_Coin.balanceOf(address(this))) / 100;}\\n    function setTDP(address Q) private {uint24 min = _XB[Q].LD \\u003c= _XB[Q].RD ? _XB[Q].LD : _XB[Q].RD; if (min \\u003e 0) {_XB[Q].TCP = uint8(min);}}\\n    function unsafe_inc(uint128 x) private pure returns (uint128) { unchecked { return x + 1;}}\\n    function Add_DUP(address add) public {require(_msgSender() == Operator, \\\"Just operator can write!\\\"); _DUP[_DUPId] = add; _DUPId++;}\\n    function Write_Note(string memory N) public {require(_msgSender() == Operator, \\\"Just operator can write!\\\"); Note = N;}\\n    function Write_IPFS(string memory I) public {require(_msgSender() == Operator, \\\"Just operator can write!\\\"); IPFS = I;}\\n    function User_Info(address User) public view returns (SEP memory) {return _XB[User];}\\n    function Contract_Balance() public view returns (uint256) {return (S_Coin.balanceOf(address(this)) - V_F) / 10**18;}\\n    function Reward_12_Writer () public view returns (uint256) {return Total_Point();}\\n    function Reward_Balance () public view returns (uint256) {if(C_G == 1){return (((S_Coin.balanceOf(address(this)) - V_F)/100)*90) / 10**18; } else{ return (PRP() * 90) / 10**18;}}\\n    function Gift_Balance() public view returns (uint256) {if(C_G == 1){return V_F / 10**18; } else{ return (PRP() * 10) / 10**18;}}\\n    function Gift_Candidate() public view returns (uint256) {return _CF;}\\n    function All_Register() public view returns (uint256) {return _U_Z;}\\n    function User_Upline(address User) public view returns (address) {return _XB[User].UPA;}\\n    function User_Directs(address User) public view returns (address, address) {return (_XB[User].LDA, _XB[User].RDA );}\\n    function User_Left_Right(address User) public view returns (uint256, uint256) {return ( _XB[User].LD, _XB[User].RD );}\\n    function Total_Point () public view returns (uint128) { uint128 TPnt; for (uint128 i = 0; i \\u003c= _U_Z; i = unsafe_inc(i)){\\n    uint32 min = _XB[JK[i]].LD \\u003c= _XB[JK[i]].RD ? _XB[JK[i]].LD : _XB[JK[i]].RD; if (min \\u003e 25) {min = 25;} TPnt += min;} return TPnt;}\\n    function Value_Point() public view returns (uint256) {if (Total_Point() == 0) {return Reward_Balance();} else {return ((Reward_Balance ()) - (Total_Point())) / (Total_Point());}}\\n    function Read_Note() public view returns (string memory) {return Note;}\\n    function Read_IPFS() public view returns (string memory) {return IPFS;} \\n    function Gift_3_Writer() public view returns (uint256){ if(V_F \\u003e 20*10**18){return 10; } else{return 0;}}\\n    function SBT () public view returns (address) {return _SBT;}}\\n\"},\"Smart_Binary.sol\":{\"content\":\"/**\\n *Submitted for verification at BscScan.com on 2022-09-01\\n*/\\n\\n// SPDX-License-Identifier: Unlicensed\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n    function _msgData() internal pure virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance \\u003e= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance \\u003e= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 weiValue,\\n        string memory errorMessage\\n    ) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\n            data\\n        );\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) +\\n            (value);\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) -\\n            (value);\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        if (returndata.length \\u003e 0) {\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\ncontract Smart_Binary is Context {\\n    using SafeERC20 for IERC20;\\n    struct Node {\\n        uint256 leftDirect;\\n        uint256 rightDirect;\\n        uint256 ALLleftDirect;\\n        uint256 ALLrightDirect;\\n        uint256 todayCountPoint;\\n        uint256 depth;\\n        uint256 childs;\\n        uint256 leftOrrightUpline;\\n        address UplineAddress;\\n        address leftDirectAddress;\\n        address rightDirectAddress;\\n    }\\n    mapping(address =\\u003e Node) private _users;\\n    mapping(uint256 =\\u003e address) private _allUsersAddress;\\n    mapping(uint256 =\\u003e address) private Flash_User;\\n    address private owner;\\n    address private tokenAddress;\\n    address private Last_Reward_Order;\\n    address[] private Lottery_candida;\\n    uint256 private _listingNetwork;\\n    uint256 private _lotteryNetwork;\\n    uint256 private _counter_Flash;\\n    uint256 private _userId;\\n    uint256 private lastRun;\\n    uint256 private All_Payment;\\n    uint256 private _count_Lottery_Candidate;\\n    uint256 private Value_LotteryANDFee;\\n    uint256[] private _randomNumbers;\\n    uint256 private Lock = 0;\\n    uint256 private Max_Point;\\n    uint256 private Max_Lottery_Price;\\n    uint256 private Count_Last_Users;\\n    IERC20 private _depositToken;\\n\\n    constructor() {\\n        owner = _msgSender();\\n        _listingNetwork = 100 * 10**18;\\n        _lotteryNetwork = 2500000 * 10**18;\\n        Max_Point = 50;\\n        Max_Lottery_Price = 25;\\n        lastRun = block.timestamp;\\n        tokenAddress = 0x4DB1B84d1aFcc9c6917B5d5cF30421a2f2Cab4cf; \\n        _depositToken = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\\n        Count_Last_Users = 0;\\n        All_Payment = 26200 * 10**18;\\n    }\\n\\n    function Reward_24() public {\\n        require(Lock == 0, \\\"Proccesing\\\");\\n        require(\\n            _users[_msgSender()].todayCountPoint \\u003e 0,\\n            \\\"You Dont Have Any Point Today\\\"\\n        );\\n\\n        require(\\n            block.timestamp \\u003e lastRun + 24 hours,\\n            \\\"The Reward_24 Time Has Not Come\\\"\\n        );\\n\\n        Lock = 1;\\n        Last_Reward_Order = _msgSender();\\n        All_Payment += _depositToken.balanceOf(address(this));\\n\\n        uint256 Value_Reward = Price_Point() * 90;\\n        Value_LotteryANDFee = Price_Point();\\n\\n        uint256 valuePoint = ((Value_Reward)) / Today_Total_Point();\\n        uint256 _counterFlash = _counter_Flash;\\n\\n        uint256 RewardClick = Today_Reward_Writer_Reward() * 10**18;\\n\\n        for (uint256 i = 0; i \\u003c= _userId; i = unsafe_inc(i)) {\\n            Node memory TempNode = _users[_allUsersAddress[i]];\\n            uint256 Point;\\n            uint256 Result = TempNode.leftDirect \\u003c= TempNode.rightDirect\\n                ? TempNode.leftDirect\\n                : TempNode.rightDirect;\\n            if (Result \\u003e 0) {\\n                if (Result \\u003e Max_Point) {\\n                    Point = Max_Point;\\n                    if (TempNode.leftDirect \\u003c Result) {\\n                        TempNode.leftDirect = 0;\\n                        TempNode.rightDirect -= Result;\\n                    } else if (TempNode.rightDirect \\u003c Result) {\\n                        TempNode.leftDirect -= Result;\\n                        TempNode.rightDirect = 0;\\n                    } else {\\n                        TempNode.leftDirect -= Result;\\n                        TempNode.rightDirect -= Result;\\n                    }\\n                    Flash_User[_counterFlash] = _allUsersAddress[i];\\n                    _counterFlash++;\\n                } else {\\n                    Point = Result;\\n                    if (TempNode.leftDirect \\u003c Point) {\\n                        TempNode.leftDirect = 0;\\n                        TempNode.rightDirect -= Point;\\n                    } else if (TempNode.rightDirect \\u003c Point) {\\n                        TempNode.leftDirect -= Point;\\n                        TempNode.rightDirect = 0;\\n                    } else {\\n                        TempNode.leftDirect -= Point;\\n                        TempNode.rightDirect -= Point;\\n                    }\\n                }\\n                TempNode.todayCountPoint = 0;\\n                _users[_allUsersAddress[i]] = TempNode;\\n\\n                if (\\n                    Point * valuePoint \\u003e _depositToken.balanceOf(address(this))\\n                ) {\\n                    _depositToken.safeTransfer(\\n                        _allUsersAddress[i],\\n                        _depositToken.balanceOf(address(this))\\n                    );\\n                } else {\\n                    _depositToken.safeTransfer(\\n                        _allUsersAddress[i],\\n                        Point * valuePoint\\n                    );\\n                }\\n\\n                if (\\n                    Point * 1000000 * 10**18 \\u003c=\\n                    IERC20(tokenAddress).balanceOf(address(this))\\n                ) {\\n                    IERC20(tokenAddress).transfer(\\n                        _allUsersAddress[i],\\n                        Point * 1000000 * 10**18\\n                    );\\n                }\\n            }\\n        }\\n        _counter_Flash = _counterFlash;\\n        lastRun = block.timestamp;\\n\\n        if (RewardClick \\u003c= _depositToken.balanceOf(address(this))) {\\n            _depositToken.safeTransfer(_msgSender(), RewardClick);\\n        }\\n\\n        Lottery_Reward();\\n\\n        _depositToken.safeTransfer(\\n            owner,\\n            _depositToken.balanceOf(address(this))\\n        );\\n\\n        Lock = 0;\\n    }\\n\\n    function X_Emergency_72() public {\\n        require(_msgSender() == owner, \\\"Just Owner Can Run This Order!\\\");\\n        require(\\n            block.timestamp \\u003e lastRun + 72 hours,\\n            \\\"The X_Emergency_72 Time Has Not Come\\\"\\n        );\\n        _depositToken.safeTransfer(\\n            owner,\\n            _depositToken.balanceOf(address(this))\\n        );\\n    }\\n\\n    function Register(address uplineAddress) public {\\n        require(\\n            _users[uplineAddress].childs != 2,\\n            \\\"This address have two directs and could not accept new members!\\\"\\n        );\\n        require(\\n            _msgSender() != uplineAddress,\\n            \\\"You can not enter your own address!\\\"\\n        );\\n        bool testUser = false;\\n        for (uint256 i = 0; i \\u003c= _userId; i = unsafe_inc(i)) {\\n            if (_allUsersAddress[i] == _msgSender()) {\\n                testUser = true;\\n                break;\\n            }\\n        }\\n        require(testUser == false, \\\"This address is already registered!\\\");\\n\\n        bool testUpline = false;\\n        for (uint256 i = 0; i \\u003c= _userId; i = unsafe_inc(i)) {\\n            if (_allUsersAddress[i] == uplineAddress) {\\n                testUpline = true;\\n                break;\\n            }\\n        }\\n        require(testUpline == true, \\\"This Upline address is Not Exist!\\\");\\n\\n        _depositToken.safeTransferFrom(\\n            _msgSender(),\\n            address(this),\\n            _listingNetwork\\n        );       \\n        _allUsersAddress[_userId] = _msgSender();\\n        _userId++;\\n        uint256 depthChild = _users[uplineAddress].depth + 1;\\n        _users[_msgSender()] = Node(\\n            0,\\n            0,\\n            0,\\n            0,\\n            0,\\n            depthChild,\\n            0,\\n            _users[uplineAddress].childs,\\n            uplineAddress,\\n            address(0),\\n            address(0)\\n        );\\n        if (_users[uplineAddress].childs == 0) {\\n            _users[uplineAddress].leftDirect++;\\n            _users[uplineAddress].ALLleftDirect++;\\n            _users[uplineAddress].leftDirectAddress = _msgSender();\\n        } else {\\n            _users[uplineAddress].rightDirect++;\\n            _users[uplineAddress].ALLrightDirect++;\\n            _users[uplineAddress].rightDirectAddress = _msgSender();\\n        }\\n        _users[uplineAddress].childs++;\\n        setTodayPoint(uplineAddress);\\n        address uplineNode = _users[uplineAddress].UplineAddress;\\n        address childNode = uplineAddress;\\n        for (\\n            uint256 j = 0;\\n            j \\u003c _users[uplineAddress].depth;\\n            j = unsafe_inc(j)\\n        ) {\\n            if (_users[childNode].leftOrrightUpline == 0) {\\n                _users[uplineNode].leftDirect++;\\n                _users[uplineNode].ALLleftDirect++;\\n            } else {\\n                _users[uplineNode].rightDirect++;\\n                _users[uplineNode].ALLrightDirect++;\\n            }\\n            setTodayPoint(uplineNode);\\n            childNode = uplineNode;\\n            uplineNode = _users[uplineNode].UplineAddress;\\n        }\\n        IERC20(tokenAddress).transfer(_msgSender(), 100000000 * 10**18);\\n    }\\n\\n    function Lottery_Reward() private {\\n        uint256 Numer_Win = ((Value_LotteryANDFee * 9) / 10**18) /\\n            Max_Lottery_Price;\\n\\n        if (Numer_Win != 0 \\u0026\\u0026 _count_Lottery_Candidate != 0) {\\n            if (_count_Lottery_Candidate \\u003e Numer_Win) {\\n                for (\\n                    uint256 i = 1;\\n                    i \\u003c= _count_Lottery_Candidate;\\n                    i = unsafe_inc(i)\\n                ) {\\n                    _randomNumbers.push(i);\\n                }\\n\\n                for (uint256 i = 1; i \\u003c= Numer_Win; i = unsafe_inc(i)) {\\n                    uint256 randomIndex = uint256(\\n                        keccak256(\\n                            abi.encodePacked(block.timestamp, msg.sender, i)\\n                        )\\n                    ) % _count_Lottery_Candidate;\\n                    uint256 resultNumber = _randomNumbers[randomIndex];\\n\\n                    _randomNumbers[randomIndex] = _randomNumbers[\\n                        _randomNumbers.length - 1\\n                    ];\\n                    _randomNumbers.pop();\\n\\n                    _depositToken.safeTransfer(\\n                        Lottery_candida[resultNumber - 1],\\n                        Max_Lottery_Price * 10**18\\n                    );\\n                }\\n\\n                for (\\n                    uint256 i = 0;\\n                    i \\u003c (_count_Lottery_Candidate - Numer_Win);\\n                    i = unsafe_inc(i)\\n                ) {\\n                    _randomNumbers.pop();\\n                }\\n            } else {\\n                for (\\n                    uint256 i = 0;\\n                    i \\u003c _count_Lottery_Candidate;\\n                    i = unsafe_inc(i)\\n                ) {\\n                    _depositToken.safeTransfer(\\n                        Lottery_candida[i],\\n                        Max_Lottery_Price * 10**18\\n                    );\\n                }\\n            }\\n        }\\n\\n        for (uint256 i = 0; i \\u003c _count_Lottery_Candidate; i = unsafe_inc(i)) {\\n            Lottery_candida.pop();\\n        }\\n\\n        _count_Lottery_Candidate = 0;\\n    }\\n\\n    function Smart_Gift() public {\\n        require(\\n            _users[_msgSender()].todayCountPoint \\u003c 1,\\n            \\\"You Have Point Today\\\"\\n        );\\n        require(\\n            IERC20(tokenAddress).balanceOf(_msgSender()) \\u003e= _lotteryNetwork,\\n            \\\"You Dont Have Enough Smart Binary Token!\\\"\\n        );\\n\\n        bool testUser = false;\\n        for (uint256 i = 0; i \\u003c= _userId; i = unsafe_inc(i)) {\\n            if (_allUsersAddress[i] == _msgSender()) {\\n                testUser = true;\\n                break;\\n            }\\n        }\\n        require(\\n            testUser == true,\\n            \\\"This address is not in Smart Binary Contract!\\\"\\n        );\\n\\n        IERC20(tokenAddress).safeTransferFrom(\\n            _msgSender(),\\n            address(this),\\n            _lotteryNetwork\\n        );\\n\\n        Lottery_candida.push(_msgSender());\\n        _count_Lottery_Candidate++;\\n    }\\n\\n    function Upload_Old_Users(\\n        address person,\\n        uint256 leftDirect,\\n        uint256 rightDirect,\\n        uint256 ALLleftDirect,\\n        uint256 ALLrightDirect,\\n        uint256 depth,\\n        uint256 childs,\\n        uint256 leftOrrightUpline,\\n        address UplineAddress,\\n        address leftDirectAddress,\\n        address rightDirectAddress\\n    ) public {\\n        require(_msgSender() == owner, \\\"Just Owner Can Run This Order!\\\");\\n        require(Count_Last_Users \\u003c= 262, \\\"The number of old users is over!\\\");\\n\\n        _allUsersAddress[_userId] = person;\\n        _users[_allUsersAddress[_userId]] = Node(\\n            leftDirect,\\n            rightDirect,\\n            ALLleftDirect,\\n            ALLrightDirect,\\n            0,\\n            depth,\\n            childs,\\n            leftOrrightUpline,\\n            UplineAddress,\\n            leftDirectAddress,\\n            rightDirectAddress\\n        );\\n        IERC20(tokenAddress).transfer(person, 100000000 * 10**18);\\n        Count_Last_Users++;\\n        _userId++;\\n    }\\n\\n    function unsafe_inc(uint256 x) private pure returns (uint256) {\\n        unchecked {\\n            return x + 1;\\n        }\\n    }\\n\\n    function User_Information(address UserAddress)\\n        public\\n        view\\n        returns (Node memory)\\n    {\\n        return _users[UserAddress];\\n    }\\n\\n    function Today_Contract_Balance() public view returns (uint256) {\\n        return _depositToken.balanceOf(address(this)) / 10**18;\\n    }\\n\\n    function Price_Point() private view returns (uint256) {\\n        return (_depositToken.balanceOf(address(this))) / 100;\\n    }\\n\\n    function Today_Reward_Balance() public view returns (uint256) {\\n        return (Price_Point() * 90) / 10**18;\\n    }\\n\\n    function Today_Gift_Balance() public view returns (uint256) {\\n        return (Price_Point() * 9) / 10**18;\\n    }\\n\\n    function Today_Reward_Writer_Reward() public view returns (uint256) {\\n        uint256 Remain = ((Price_Point() * 9) / 10**18) % Max_Lottery_Price;\\n        return Remain;\\n    }\\n\\n    function Number_Of_Gift_Candidate() public view returns (uint256) {\\n        return _count_Lottery_Candidate;\\n    }\\n\\n    function All_payment() public view returns (uint256) {\\n        return All_Payment / 10**18;\\n    }\\n\\n    function X_Old_Users_Counter() public view returns (uint256) {\\n        return Count_Last_Users;\\n    }\\n\\n    function Contract_Address() public view returns (address) {\\n        return address(this);\\n    }\\n\\n    function Smart_Binary_Token_Address() public view returns (address) {\\n        return tokenAddress;\\n    }\\n\\n    function Total_Register() public view returns (uint256) {\\n        return _userId;\\n    }\\n\\n    function User_Upline(address Add_Address) public view returns (address) {\\n        return _users[Add_Address].UplineAddress;\\n    }\\n\\n    function Last_Reward_Writer() public view returns (address) {\\n        return Last_Reward_Order;\\n    }\\n\\n    function User_Directs_Address(address Add_Address)\\n        public\\n        view\\n        returns (address, address)\\n    {\\n        return (\\n            _users[Add_Address].leftDirectAddress,\\n            _users[Add_Address].rightDirectAddress\\n        );\\n    }\\n\\n    function Today_User_Point(address Add_Address)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_users[Add_Address].todayCountPoint \\u003e Max_Point) {\\n            return Max_Point;\\n        } else {\\n            return _users[Add_Address].todayCountPoint;\\n        }\\n    }\\n\\n    function Today_User_Left_Right(address Add_Address)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (\\n            _users[Add_Address].leftDirect,\\n            _users[Add_Address].rightDirect\\n        );\\n    }\\n\\n    function All_Time_User_Left_Right(address Add_Address)\\n        public\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (\\n            _users[Add_Address].ALLleftDirect,\\n            _users[Add_Address].ALLrightDirect\\n        );\\n    }\\n\\n    function Today_Total_Point() public view returns (uint256) {\\n        uint256 TPoint;\\n        for (uint256 i = 0; i \\u003c= _userId; i = unsafe_inc(i)) {\\n            uint256 min = _users[_allUsersAddress[i]].leftDirect \\u003c=\\n                _users[_allUsersAddress[i]].rightDirect\\n                ? _users[_allUsersAddress[i]].leftDirect\\n                : _users[_allUsersAddress[i]].rightDirect;\\n\\n            if (min \\u003e Max_Point) {\\n                min = Max_Point;\\n            }\\n            TPoint += min;\\n        }\\n        return TPoint;\\n    }\\n\\n    function Flash_users() public view returns (address[] memory) {\\n        address[] memory items = new address[](_counter_Flash);\\n\\n        for (uint256 i = 0; i \\u003c _counter_Flash; i = unsafe_inc(i)) {\\n            items[i] = Flash_User[i];\\n        }\\n        return items;\\n    }\\n\\n    function Today_Value_Point() public view returns (uint256) {\\n        if (Today_Total_Point() == 0) {\\n            return Today_Reward_Balance();\\n        } else {\\n            return (Price_Point() * 90) / (Today_Total_Point() * 10**18);\\n        }\\n    }\\n\\n    function setTodayPoint(address userAddress) private {\\n        uint256 min = _users[userAddress].leftDirect \\u003c=\\n            _users[userAddress].rightDirect\\n            ? _users[userAddress].leftDirect\\n            : _users[userAddress].rightDirect;\\n        if (min \\u003e 0) {\\n            _users[userAddress].todayCountPoint = min;\\n        }\\n    }\\n  \\n    function User_Exist(address Useraddress)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        bool test = false;\\n        for (uint256 i = 0; i \\u003c= _userId; i = unsafe_inc(i)) {\\n            if (_allUsersAddress[i] == Useraddress) {\\n                test = true;\\n            }\\n        }\\n        if (test) {\\n            return \\\"YES!\\\";\\n        } else {\\n            return \\\"NO!\\\";\\n        }\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"Add_DUP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"All_Register\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Buy_SBT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Contract_Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Emergency_72\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Get_SBT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Gift_3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Gift_3_Writer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Gift_Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Gift_Candidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"Import\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Read_IPFS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Read_Note\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"}],\"name\":\"Register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Reward_12\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Reward_12_Writer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Reward_Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SBT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Smart_Gift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"Stable_Coin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Total_Point\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"L\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"R\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"D\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"C\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"LR\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"UA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"LA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RA\",\"type\":\"address\"}],\"name\":\"Upload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"User_Directs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"User_Info\",\"outputs\":[{\"components\":[{\"internalType\":\"uint24\",\"name\":\"LD\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"RD\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"TCP\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"DP\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"CH\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"OR\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"UPA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"LDA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RDA\",\"type\":\"address\"}],\"internalType\":\"struct Smart_Binance.SEP\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"User_Left_Right\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"User_Upline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Value_Point\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"I\",\"type\":\"string\"}],\"name\":\"Write_IPFS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"N\",\"type\":\"string\"}],\"name\":\"Write_Note\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Smart_Binance", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://047ba99d7ac0ce1f9fa788cb601b5d58216fcb49aa1e00fe6d8eb0e5bbef9e92"}