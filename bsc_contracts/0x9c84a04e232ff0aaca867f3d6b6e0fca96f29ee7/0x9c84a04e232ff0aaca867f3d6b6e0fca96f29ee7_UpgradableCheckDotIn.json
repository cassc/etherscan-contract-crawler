{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/jeremyguyet/project/checkdot/insurance/CheckDot.InsuranceProtocol/contracts/insurance/covers/UpgradableCheckDotInsuranceCovers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../../../../../CheckDot.DAOProxyContract/contracts/ProxyDAO.sol\\\";\\n\\ncontract UpgradableCheckDotInsuranceCovers is ProxyDAO {\\n    constructor(address _cdtGouvernanceAddress) ProxyDAO(_cdtGouvernanceAddress) { }\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/utils/ProxyVoteDurations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ProxyVoteDurations\\n * @author Jeremy Guyet (@jguyet)\\n * @dev Library to manage the duration of the votes.\\n */\\nlibrary ProxyVoteDurations {\\n    struct VoteDurationSlot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `VoteDurationSlot` with member `value` located at `slot`.\\n     */\\n    function getVoteDurationSlot(bytes32 slot) internal pure returns (VoteDurationSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/utils/ProxyUpgrades.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ProxyUpgrades\\n * @author Jeremy Guyet (@jguyet)\\n * @dev Provides a library allowing the management of updates.\\n * Library usable for proxies.\\n */\\nlibrary ProxyUpgrades {\\n\\n    struct Upgrade {\\n        uint256 id;\\n        address submitedNewFunctionalAddress;\\n        bytes   initializationData;\\n        uint256 utcStartVote;\\n        uint256 utcEndVote;\\n        uint256 totalApproved;\\n        uint256 totalUnapproved;\\n        bool isFinished;\\n    }\\n\\n    struct Upgrades {\\n        mapping(uint256 => Upgrade) upgrades;\\n        mapping(uint256 => mapping(address => address)) participators;\\n        uint256 counter;\\n    }\\n\\n    struct UpgradesSlot {\\n        Upgrades value;\\n    }\\n\\n    /////////\\n    // Upgrades View\\n    /////////\\n\\n    function isEmpty(Upgrades storage upgrades) internal view returns (bool) {\\n        return upgrades.counter == 0;\\n    }\\n\\n    function current(Upgrades storage upgrades) internal view returns (Upgrade storage) {\\n        return upgrades.upgrades[upgrades.counter - 1];\\n    }\\n\\n    function all(Upgrades storage upgrades) internal view returns (Upgrade[] memory) {\\n        uint256 totalUpgrades = upgrades.counter;\\n        Upgrade[] memory results = new Upgrade[](totalUpgrades);\\n        uint256 index = 0;\\n\\n        for (index; index < totalUpgrades; index++) {\\n            Upgrade storage upgrade = upgrades.upgrades[index];\\n\\n            results[index].id = upgrade.id;\\n            results[index].submitedNewFunctionalAddress = upgrade.submitedNewFunctionalAddress;\\n            results[index].initializationData = upgrade.initializationData;\\n            results[index].utcStartVote = upgrade.utcStartVote;\\n            results[index].utcEndVote = upgrade.utcEndVote;\\n            results[index].totalApproved = upgrade.totalApproved;\\n            results[index].totalUnapproved = upgrade.totalUnapproved;\\n            results[index].isFinished = upgrade.isFinished;\\n        }\\n        return results;\\n    }\\n\\n    function getLastUpgrade(Upgrades storage upgrades) internal view returns (Upgrade memory) {\\n        Upgrade memory result;\\n        Upgrade storage upgrade = upgrades.upgrades[upgrades.counter - 1];\\n                    \\n        result.id = upgrade.id;\\n        result.submitedNewFunctionalAddress = upgrade.submitedNewFunctionalAddress;\\n        result.initializationData = upgrade.initializationData;\\n        result.utcStartVote = upgrade.utcStartVote;\\n        result.utcEndVote = upgrade.utcEndVote;\\n        result.totalApproved = upgrade.totalApproved;\\n        result.totalUnapproved = upgrade.totalUnapproved;\\n        result.isFinished = upgrade.isFinished;\\n        return result;\\n    }\\n\\n    /////////\\n    // Upgrade View\\n    /////////\\n\\n    function hasVoted(Upgrade storage upgrade, Upgrades storage upgrades, address _checkAddress) internal view returns (bool) {\\n        return upgrades.participators[upgrade.id][_checkAddress] == _checkAddress;\\n    }\\n\\n    function voteInProgress(Upgrade storage upgrade) internal view returns (bool) {\\n        return upgrade.utcStartVote < block.timestamp\\n            && upgrade.utcEndVote > block.timestamp;\\n    }\\n\\n    function voteFinished(Upgrade storage upgrade) internal view returns (bool) {\\n        return upgrade.utcStartVote < block.timestamp\\n            && upgrade.utcEndVote < block.timestamp;\\n    }\\n\\n    /////////\\n    // Upgrades Functions\\n    /////////\\n\\n    function add(Upgrades storage upgrades, address _submitedNewFunctionalAddress, bytes memory _initializationData, uint256 _utcStartVote, uint256 _utcEndVote) internal {\\n        unchecked {\\n            uint256 id = upgrades.counter++;\\n            \\n            upgrades.upgrades[id].id = id;\\n            upgrades.upgrades[id].submitedNewFunctionalAddress = _submitedNewFunctionalAddress;\\n            upgrades.upgrades[id].initializationData = _initializationData;\\n            upgrades.upgrades[id].utcStartVote = _utcStartVote;\\n            upgrades.upgrades[id].utcEndVote = _utcEndVote;\\n            upgrades.upgrades[id].totalApproved = 0;\\n            upgrades.upgrades[id].totalUnapproved = 0;\\n            upgrades.upgrades[id].isFinished = false;\\n        }\\n    }\\n\\n    /////////\\n    // Upgrade Functions\\n    /////////\\n\\n    function vote(Upgrade storage upgrade, Upgrades storage upgrades, address _from, uint256 _votes, bool _approved) internal {\\n        unchecked {\\n            if (_approved) {\\n                upgrade.totalApproved += _votes;\\n            } else {\\n                upgrade.totalUnapproved += _votes;\\n            }\\n            upgrades.participators[upgrade.id][_from] = _from;\\n        }\\n    }\\n\\n    function setFinished(Upgrade storage upgrade, bool _finished) internal {\\n        unchecked {\\n            upgrade.isFinished = _finished;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `UpgradesSlot` with member `value` located at `slot`.\\n     */\\n    function getUpgradesSlot(bytes32 slot) internal pure returns (UpgradesSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/utils/ProxyBool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ProxyModes\\n * @author Jeremy Guyet (@jguyet)\\n * @dev Library to save booleans in specifical storage slot.\\n */\\nlibrary ProxyBool {\\n    struct BoolSlot {\\n        bool value;\\n    }\\n\\n    /**\\n     * @dev Returns an `BoolSlot` with member `value` located at `slot`.\\n     */\\n    function getBoolSlot(bytes32 slot) internal pure returns (BoolSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/utils/ProxyAddresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title ProxyAddresses\\n * @author Jeremy Guyet (@jguyet)\\n * @dev Library to manage the storage of addresses for proxies.\\n */\\nlibrary ProxyAddresses {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/interfaces/IERC20BalanceAndDecimals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IERC20BalanceAndDecimals {\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/UpgradableProxyDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./utils/ProxyUpgrades.sol\\\";\\nimport \\\"./utils/ProxyAddresses.sol\\\";\\nimport \\\"./utils/ProxyBool.sol\\\";\\nimport \\\"./utils/ProxyVoteDurations.sol\\\";\\nimport \\\"./interfaces/IERC20BalanceAndDecimals.sol\\\";\\n\\n/**\\n * @title UpgradableProxyDAO\\n * @author Jeremy Guyet (@jguyet)\\n * @dev Smart contract to implement on a contract proxy.\\n * This contract allows the management of the important memory of a proxy.\\n * The memory spaces are extremely far from the beginning of the memory\\n * which allows a high security against collisions.\\n * This contract allows updates using a DAO program governed by an\\n * ERC20 governance token. A voting session is mandatory for each update.\\n * All holders of at least one whole token are eligible to vote.\\n * There are several memory locations dedicated to the proper functioning\\n * of the proxy (Implementation, admin, governance, upgrades).\\n * For more information about the security of these locations please refer\\n * to the discussions around the EIP-1967 standard we have been inspired by.\\n */\\ncontract UpgradableProxyDAO {\\n    using ProxyAddresses for ProxyAddresses.AddressSlot;\\n    using ProxyBool for ProxyBool.BoolSlot;\\n    using ProxyVoteDurations for ProxyVoteDurations.VoteDurationSlot;\\n    using ProxyUpgrades for ProxyUpgrades.Upgrades;\\n    using ProxyUpgrades for ProxyUpgrades.Upgrade;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Storage slot with the address of the gorvenance token of the contract.\\n     * This is the keccak-256 hash of \\\"checkdot.io.proxy.governance-token\\\" subtracted by 1\\n     */\\n    bytes32 private constant _GOVERNANCE_SLOT = 0x6dad0f23c7599fe058f6d945cb006fc2efdeec546a7309619015b2fe6aafe749;\\n\\n    /**\\n     * @dev Storage slot with the upgrades of the contract.\\n     * This is the keccak-256 hash of \\\"checkdot.io.proxy.upgrades\\\" subtracted by 1\\n     */\\n    bytes32 private constant _UPGRADES_SLOT = 0x6190170739ac7613eca8f8497702a38493865185ee4d45c91d18b0973eef39a8;\\n\\n    /**\\n     * @dev Storage slot with the upgrades of the contract.\\n     * This is the keccak-256 hash of \\\"checkdot.io.proxy.vote.duration\\\" subtracted by 1\\n     */\\n    bytes32 private constant _VOTE_DURATION_SLOT = 0x3dbc3e8463648688016ac4674e4344b3e465f24bb2b8d250193e1371f4fe1b31;\\n\\n    /**\\n     * @dev Storage slot with the upgrades of the contract.\\n     * This is the keccak-256 hash of \\\"checkdot.io.proxy.production\\\" subtracted by 1\\n     */\\n    bytes32 private constant _IS_PRODUCTION_SLOT = 0xdb4027e5ac6ab1244eeafe40a76baa5f57763046d91d31b60a29e63885da6ed3;\\n\\n    /**\\n     * @dev Storage slot with the graal mode of the contract.\\n     * This is the keccak-256 hash of \\\"checkdot.io.proxy.graal\\\" subtracted by 1\\n     */\\n    bytes32 private constant _THE_GRAAL_SLOT = 0xc11b5cd5592b4c028201fe20d869d004ea2f18eecb6daa132a73e7a1039a3d7c;\\n\\n    constructor(address _cdtGouvernanceAddress) {\\n        _setOwner(msg.sender);\\n        _setGovernance(_cdtGouvernanceAddress);\\n        _setInProduction(false);\\n        _setVoteDuration(86400); // 1 day\\n        _setTheGraal(false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() external view returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @dev Returns the current Owner address.\\n     */\\n    function getOwner() external view returns (address) {\\n        return _getOwner();\\n    }\\n\\n    /**\\n     * @dev Returns the current Governance address.\\n     */\\n    function getGovernance() external view returns (address) {\\n        return _getGovernance();\\n    }\\n\\n    /**\\n     * @dev Returns the current vote duration.\\n     */\\n    function getVoteDuration() external view returns (uint256) {\\n        return _getVoteDuration();\\n    }\\n\\n    /**\\n     * @dev Returns if the proxy is in production. (Irreversible)\\n     */\\n    function isInProduction() external view returns (bool) {\\n        return _isInProduction();\\n    }\\n\\n    /**\\n     * @dev Enable the production Mode when is in production all upgrades need DAO vote.\\n     */\\n    function setInProduction() external payable {\\n        require(_getOwner() == msg.sender, \\\"Proxy: FORBIDDEN\\\");\\n        _setInProduction(true);\\n    }\\n\\n    /**\\n     * @dev Returns if the protocol do have the graal. (Irreversible)\\n     */\\n    function doHaveTheGraal() external view returns (bool) {\\n        return _doHaveTheGraal();\\n    }\\n\\n    /**\\n     * @dev Enable the Full Decentralized Mode when is in production.\\n     */\\n    function setTheGraal() external payable {\\n        require(_getOwner() == msg.sender, \\\"Proxy: FORBIDDEN\\\");\\n        require(_isInProduction() == true, \\\"Proxy: FORBIDDEN_ONLY_IN_PROD\\\");\\n        _setTheGraal(true);\\n    }\\n\\n    /**\\n     * @dev Set the Vote Duration minimum of 1 day.\\n     */\\n    function setVoteDuration(uint256 _newVoteDuration) external payable {\\n        require(_getOwner() == msg.sender, \\\"Proxy: FORBIDDEN\\\");\\n        _setVoteDuration(_newVoteDuration);\\n    }\\n\\n    /**\\n     * @dev Transfer the ownership onlyOwner can call this function.\\n     */\\n    function transferOwnership(address _newOwner) external payable {\\n        require(_getOwner() == msg.sender, \\\"Proxy: FORBIDDEN\\\");\\n        _setOwner(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Creation and update function of the proxified implementation,\\n     * the entry of a start date and an end date of the voting period by\\n     * the governance is necessary. The start date of the period must be\\n     * greater or equals than the `block.timestamp`.\\n     * The start date and end date of the voting period must be at least\\n     * 86400 seconds apart.\\n     */\\n    function upgrade(address _newAddress, bytes memory _initializationData) external payable {\\n        require(_getOwner() == msg.sender, \\\"Proxy: FORBIDDEN\\\");\\n        require(_doHaveTheGraal() == false, \\\"Proxy: THE_GRAAL\\\");\\n        if (_isInProduction() == false) {\\n            _upgrade(_newAddress, _initializationData);\\n        } else {\\n            ProxyUpgrades.Upgrades storage _proxyUpgrades = ProxyUpgrades.getUpgradesSlot(_UPGRADES_SLOT).value;\\n\\n            require(_proxyUpgrades.isEmpty() || _proxyUpgrades.current().isFinished, \\\"Proxy: UPGRADE_ALREADY_INPROGRESS\\\");\\n            _proxyUpgrades.add(_newAddress, _initializationData, block.timestamp, block.timestamp + _getVoteDuration());\\n        }\\n    }\\n\\n    /**\\n     * @dev Function to check the result of the vote of the implementation\\n     * update.\\n     * Only called by the owner and if the vote is favorable the\\n     * implementation is changed and a call to the initialize function of\\n     * the new implementation will be made.\\n     */\\n    function voteUpgradeCounting() external payable {\\n        require(_getOwner() == msg.sender, \\\"Proxy: FORBIDDEN\\\");\\n        require(_doHaveTheGraal() == false, \\\"Proxy: THE_GRAAL\\\");\\n        ProxyUpgrades.Upgrades storage _proxyUpgrades = ProxyUpgrades.getUpgradesSlot(_UPGRADES_SLOT).value;\\n\\n        require(!_proxyUpgrades.isEmpty(), \\\"Proxy: EMPTY\\\");\\n        require(_proxyUpgrades.current().voteFinished(), \\\"Proxy: VOTE_ALREADY_INPROGRESS\\\");\\n        require(!_proxyUpgrades.current().isFinished, \\\"Proxy: UPGRADE_ALREADY_FINISHED\\\");\\n\\n        _proxyUpgrades.current().setFinished(true);\\n        if (_proxyUpgrades.current().totalApproved > _proxyUpgrades.current().totalUnapproved) {\\n            _upgrade(_proxyUpgrades.current().submitedNewFunctionalAddress, _proxyUpgrades.current().initializationData);\\n        }\\n    }\\n\\n    /**\\n     * @dev Function callable by the holder of at least one unit of the\\n     * governance token.\\n     * A voter can only vote once per update.\\n     */\\n    function voteUpgrade(bool approve) external payable {\\n        ProxyUpgrades.Upgrades storage _proxyUpgrades = ProxyUpgrades.getUpgradesSlot(_UPGRADES_SLOT).value;\\n\\n        require(!_proxyUpgrades.isEmpty(), \\\"Proxy: EMPTY\\\");\\n        require(!_proxyUpgrades.current().isFinished, \\\"Proxy: VOTE_FINISHED\\\");\\n        require(_proxyUpgrades.current().voteInProgress(), \\\"Proxy: VOTE_NOT_STARTED\\\");\\n        require(!_proxyUpgrades.current().hasVoted(_proxyUpgrades, msg.sender), \\\"Proxy: ALREADY_VOTED\\\");\\n        IERC20BalanceAndDecimals token = IERC20BalanceAndDecimals(_getGovernance());\\n        uint256 votes = token.balanceOf(msg.sender) / (10 ** token.decimals());\\n        require(votes >= 1, \\\"Proxy: INSUFFISANT_POWER\\\");\\n\\n        _proxyUpgrades.current().vote(_proxyUpgrades, msg.sender, votes, approve);\\n    }\\n\\n    /**\\n     * @dev Returns the array of all upgrades.\\n     */\\n    function getAllUpgrades() external view returns (ProxyUpgrades.Upgrade[] memory) {\\n        return ProxyUpgrades.getUpgradesSlot(_UPGRADES_SLOT).value.all();\\n    }\\n\\n    /**\\n     * @dev Returns the last upgrade.\\n     */\\n    function getLastUpgrade() external view returns (ProxyUpgrades.Upgrade memory) {\\n        return ProxyUpgrades.getUpgradesSlot(_UPGRADES_SLOT).value.getLastUpgrade();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return ProxyAddresses.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address _newImplementation) private {\\n        ProxyAddresses.getAddressSlot(_IMPLEMENTATION_SLOT).value = _newImplementation;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getOwner() internal view returns (address) {\\n        return ProxyAddresses.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setOwner(address _owner) private {\\n        ProxyAddresses.getAddressSlot(_ADMIN_SLOT).value = _owner;\\n    }\\n\\n    /**\\n     * @dev Returns the governance address.\\n     */\\n    function _getGovernance() internal view returns (address) {\\n        return ProxyAddresses.getAddressSlot(_GOVERNANCE_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the governance slot.\\n     */\\n    function _setGovernance(address _newGovernance) private {\\n        ProxyAddresses.getAddressSlot(_GOVERNANCE_SLOT).value = _newGovernance;\\n    }\\n\\n    /**\\n     * @dev Returns boolean DAO is enabled.\\n     */\\n    function _isInProduction() internal view returns (bool) {\\n        return ProxyBool.getBoolSlot(_IS_PRODUCTION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Application of the production mode, irreversible change.\\n     */\\n    function _setInProduction(bool enabled) private {\\n        ProxyBool.getBoolSlot(_IS_PRODUCTION_SLOT).value = enabled;\\n    }\\n\\n    /**\\n     * @dev Returns boolean Full decentralization is enabled.\\n     */\\n    function _doHaveTheGraal() internal view returns (bool) {\\n        return ProxyBool.getBoolSlot(_THE_GRAAL_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Application of the production Full decentralization, irreversible change.\\n     */\\n    function _setTheGraal(bool enabled) private {\\n        ProxyBool.getBoolSlot(_THE_GRAAL_SLOT).value = enabled;\\n    }\\n\\n    /**\\n     * @dev Returns the vote duration.\\n     */\\n    function _getVoteDuration() internal view returns (uint256) {\\n        return ProxyVoteDurations.getVoteDurationSlot(_VOTE_DURATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores the vote duration\\n     */\\n    function _setVoteDuration(uint256 _newVoteDuration) private {\\n        require(_newVoteDuration >= 86400, \\\"Proxy: Minimum of one day\\\");\\n        ProxyVoteDurations.getVoteDurationSlot(_VOTE_DURATION_SLOT).value = _newVoteDuration;\\n    }\\n\\n    /**\\n     * @dev Stores the new implementation address in the implementation slot\\n     * and call the internal _afterUpgrade function used for calling functions\\n     * on the new implementation just after the set in the same nonce block.\\n     */\\n    function _upgrade(address _newFunctionalAddress, bytes memory _initializationData) internal {\\n        _setImplementation(_newFunctionalAddress);\\n        _afterUpgrade(_newFunctionalAddress, _initializationData);\\n    }\\n\\n    /**\\n     * @dev internal virtual function implemented in the Proxy contract.\\n     * This is called just after all upgrades of the proxy implementation.\\n     */\\n    function _afterUpgrade(address _newFunctionalAddress, bytes memory _initializationData) internal virtual { }\\n\\n}\"\r\n    },\r\n    \"/Users/jeremyguyet/project/checkdot/CheckDot.DAOProxyContract/contracts/ProxyDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"./UpgradableProxyDAO.sol\\\";\\n\\n/**\\n * @title ProxyDAO\\n * @author Jeremy Guyet (@jguyet)\\n * @dev ProxyDAO contract allows the binding of a version by version\\n * implementation which can be updated thanks to the\\n * UpgradableProxyDAO abstraction which allows the proxy a\\n * DAO governance.\\n */\\ncontract ProxyDAO is UpgradableProxyDAO {\\n\\n    constructor(address _cdtGouvernanceAddress) UpgradableProxyDAO(_cdtGouvernanceAddress) { }\\n\\n    /**\\n     * @dev This is the fallback function a fall back function is triggered if someone\\n     * sends a function call or a transaction to this contract AND there is no function\\n     * that corresponds to the name the callers is trying to execute.\\n     * Each call is then passed to the _delegate function which will call the functions\\n     * of the functional implementation.\\n     */\\n    fallback() external payable {\\n        _delegate(_getImplementation());\\n    }\\n\\n    /**\\n     * @dev This is the receive function is triggered if someone send transaction to\\n     * this contract. Each call is then passed to the _delegate function which will\\n     * call the functions of the functional implementation.\\n     */\\n    receive() external payable {\\n        _delegate(_getImplementation());\\n    }\\n\\n    /**\\n     * @dev This is the fallback function a fall back function is triggered if someone\\n     * sends a function call or a transaction to this contract AND there is no function\\n     * that corresponds to the name the callers is trying to execute \\n     * e.g. if someone tries to call HelloWorld() to this contract, which doesn't exist\\n     * in this contract, then the fallback function will be called. \\n     * In this case, the fallback function will redirect the call to the functional contract\\n     */\\n    function _delegate(address implementation) internal {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This function is called once the implementation is updated.\\n     * It calls the initialize function of the proxy contract,\\n     * this allows an update of some variables if necessary\\n     * when updating the proxy code again.\\n     */\\n    function _afterUpgrade(address _newFunctionalAddress, bytes memory _initializationData) internal virtual override {\\n        address implementation = _newFunctionalAddress;\\n        bytes memory data = abi.encodeWithSignature(\\\"initialize(bytes)\\\", _initializationData);\\n\\n        assembly {\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                add(data, 0x20), // add is another assembly function; this changes the format to something that delegate call can read\\n                mload(data), // mload is memory load\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n            let ptr := mload(0x40) // ptr as in pointer\\n            returndatacopy(ptr, 0, size)\\n            switch result // result will either be 0 (as in function call failed), or 1 (function call success)\\n            case 0 {\\n                revert(ptr, size)\\n            } // revert if function call failed\\n            default {\\n                return(ptr, size)\\n            } // default means \\\"else\\\"; else return\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cdtGouvernanceAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"doHaveTheGraal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllUpgrades\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"submitedNewFunctionalAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializationData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"utcStartVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utcEndVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalApproved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUnapproved\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFinished\",\"type\":\"bool\"}],\"internalType\":\"struct ProxyUpgrades.Upgrade[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastUpgrade\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"submitedNewFunctionalAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializationData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"utcStartVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utcEndVote\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalApproved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUnapproved\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFinished\",\"type\":\"bool\"}],\"internalType\":\"struct ProxyUpgrades.Upgrade\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVoteDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInProduction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setInProduction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setTheGraal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newVoteDuration\",\"type\":\"uint256\"}],\"name\":\"setVoteDuration\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initializationData\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"approve\",\"type\":\"bool\"}],\"name\":\"voteUpgrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteUpgradeCounting\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UpgradableCheckDotInsuranceCovers", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000000cbd6fadcf8096cc9a43d90b45f65826102e3ece", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xbf727dc9560ae5a1bde687c3d5672ccb2904a67c", "SwarmSource": ""}