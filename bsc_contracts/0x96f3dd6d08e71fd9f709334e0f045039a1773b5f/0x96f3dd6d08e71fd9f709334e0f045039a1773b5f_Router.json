{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Uniswap/IUniswapV2Factory.sol\\\";\\nimport \\\"./Uniswap/IUniswapV2Router.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\n\\ncontract Router is Owned {\\n    IUniswapV2Router constant router = IUniswapV2Router(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n\\n    address public feeRecr = 0xC0249e091Ce268f4Cae5b4F79e8119f1a6c168E7;\\n    uint256 public feeRate = 30;\\n\\n    constructor() Owned(msg.sender) {}\\n\\n    function swapExactTokensForTokens(address tokenA, address tokenB, uint256 amount, uint256 minOut) external {\\n        IERC20(tokenA).transferFrom(msg.sender, address(this), amount);\\n        IERC20(tokenA).approve(address(router), amount);\\n\\n        uint256 tamount = amount * (10000 - feeRate) / 10000;\\n        IERC20(tokenA).transfer(feeRecr, amount - tamount);\\n        address[] memory path = new address[](2);\\n        path[0] = address(tokenA);\\n        path[1] = address(tokenB);\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(tamount, minOut, path, msg.sender, block.timestamp);\\n    }\\n\\n    function swapExactTokensForTokensbackFee(address tokenA, address tokenB, uint256 amount, uint256 minOut) external {\\n        uint256 startGas = gasleft();\\n        IERC20(tokenA).transferFrom(msg.sender, address(this), amount);\\n        IERC20(tokenA).approve(address(router), amount);\\n\\n        uint256 tamount = amount * (10000 - feeRate) / 10000;\\n        IERC20(tokenA).transfer(feeRecr, amount - tamount);\\n        address[] memory path = new address[](2);\\n        path[0] = address(tokenA);\\n        path[1] = address(tokenB);\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(tamount, minOut, path, msg.sender, block.timestamp);\\n        uint256 gasUsed = startGas - gasleft();\\n        uint256 t_gas = gasUsed + 43000;\\n        uint256 gas_ret = t_gas * tx.gasprice;\\n        msg.sender.call{value: gas_ret}(\\\"\\\");\\n    }\\n\\n    function swapExactEthForTokens(address token, uint256 minOut) external payable {\\n        require(msg.value > 10000, \\\">10000\\\");\\n        uint256 tamount = msg.value * (10000 - feeRate) / 10000;\\n        address[] memory path = new address[](2);\\n        path[0] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n        path[1] = address(token);\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: tamount}(\\n            minOut, path, msg.sender, block.timestamp\\n        );\\n        (bool sent,) = payable(feeRecr).call{value: msg.value - tamount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n    }\\n\\n    function swapExactEthForTokensbackFee(address token, uint256 minOut) external payable {\\n        uint256 startGas = gasleft();\\n        require(msg.value > 10000, \\\">10000\\\");\\n        uint256 tamount = msg.value * (10000 - feeRate) / 10000;\\n        address[] memory path = new address[](2);\\n        path[0] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n        path[1] = address(token);\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: tamount}(\\n            minOut, path, msg.sender, block.timestamp\\n        );\\n        (bool sent,) = payable(feeRecr).call{value: msg.value - tamount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n        uint256 gasUsed = startGas - gasleft();\\n        uint256 t_gas = gasUsed + 43000;\\n        uint256 gas_ret = t_gas * tx.gasprice;\\n        msg.sender.call{value: gas_ret}(\\\"\\\");\\n    }\\n\\n    function withdrawToken(IERC20 token, address to, uint256 _amount) external onlyOwner {\\n        token.transfer(to, _amount);\\n    }\\n\\n    function setFeeReceiver(address _feeRecr) external onlyOwner {\\n        feeRecr = _feeRecr;\\n    }\\n\\n    function setFeeRate(uint256 _feeRate) external onlyOwner {\\n        require(_feeRate < 10000, \\\"<10000\\\");\\n        feeRate = _feeRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Uniswap/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapV2Factory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n}\\n\"\r\n    },\r\n    \"src/Uniswap/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapV2Router {\\n\\tfunction factory() external pure returns (address);\\n\\tfunction WETH() external pure returns (address);\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external;\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable;\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external;\\n\\tfunction addLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint amountTokenDesired,\\n\\t\\tuint amountTokenMin,\\n\\t\\tuint amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\tfunction addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint amountADesired,\\n\\t\\tuint amountBDesired,\\n\\t\\tuint amountAMin,\\n\\t\\tuint amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint amountA, uint amountB, uint liquidity);\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint amountIn,\\n\\t\\tuint amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\tfunction swapTokensForExactTokens(\\n\\t\\tuint amountOut,\\n\\t\\tuint amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint deadline\\n\\t) external returns (uint[] memory amounts);\\n\\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n\\texternal\\n\\tpayable\\n\\treturns (uint[] memory amounts);\\n\\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n\\texternal\\n\\treturns (uint[] memory amounts);\\n\\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n\\texternal\\n\\treturns (uint[] memory amounts);\\n\\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n\\texternal\\n\\tpayable\\n\\treturns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRate\",\"type\":\"uint256\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecr\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"swapExactEthForTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"swapExactEthForTokensbackFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensbackFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}