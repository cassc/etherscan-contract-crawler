{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function feeTo() external view returns (address);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ISwapPair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n}\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary PancakeLibrary {\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'PancakeLibrary: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'PancakeLibrary: ZERO_ADDRESS');\r\n    }\r\n\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint160(uint(keccak256(abi.encodePacked(\r\n            hex'ff',\r\n            factory,\r\n            keccak256(abi.encodePacked(token0, token1)),\r\n            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5')))));\r\n    }\r\n}\r\n\r\ncontract TokenDistributor {\r\n\r\n    constructor (address token) {\r\n\r\n        IERC20(token).approve(msg.sender, ~uint256(0));\r\n    }\r\n\r\n}\r\n\r\nabstract contract AbsToken is IERC20, Ownable {\r\n    struct UserInfo {\r\n        uint256 lpAmount;\r\n        uint256 rewardDebt;\r\n        uint256 nodeAmount;\r\n        uint256 nodeRewardDebt;\r\n        uint256 inviteLPAmount;\r\n        uint256 claimedMintReward;\r\n        uint256 claimedNodeReward;\r\n        uint256 inviteReward;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint256 totalAmount;\r\n        uint256 accMintPerShare;\r\n        uint256 accMintReward;\r\n        uint256 mintPerBlock;\r\n        uint256 lastMintBlock;\r\n        uint256 totalMintReward;\r\n        uint256 totalNodeAmount;\r\n        uint256 accNodeRewardPerShare;\r\n        uint256 accNodeReward;\r\n        uint256 mintAmountPerDay;\r\n    }\r\n\r\n    PoolInfo private _poolInfo;\r\n    uint256 private constant _rewardFactor = 1e12;\r\n    uint256 private constant _dailyBlockNum = 1 days / 3;\r\n    uint256 public _startMintBlock;\r\n    uint256 private constant _initMintRate = 600000;\r\n    uint256 private constant _mintRateDiv = 100000000;\r\n    uint256 private constant _minusMintRateDays = 200;\r\n    uint256 private immutable _stableMintPerDay;\r\n\r\n    mapping(address => uint256) public _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    address public fundAddress;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    mapping(address => bool) public _feeWhiteList;\r\n    mapping(address => bool) public _blackList;\r\n    mapping(address => UserInfo) private _userInfo;\r\n\r\n    uint256 private _tTotal;\r\n\r\n    ISwapRouter public immutable _swapRouter;\r\n    mapping(address => bool) public _swapPairList;\r\n    mapping(address => bool) public _swapRouters;\r\n\r\n    bool private inSwap;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private constant _buyFundFee = 200;\r\n    uint256 private constant _buyRootFee = 300;\r\n    uint256 private constant _sellFundFee = 200;\r\n    uint256 private constant _sellRootFee = 300;\r\n\r\n    uint256 public startTradeBlock;\r\n    address public immutable _mainPair;\r\n    address public  immutable _usdt;\r\n\r\n    bool public _strictCheck = true;\r\n\r\n    mapping(address => address) public _invitor;\r\n    mapping(address => address[]) public _binders;\r\n    uint256 public _bindCondition;\r\n    mapping(address => bool) public _rootList;\r\n    mapping(address => address) public _rootInvitor;\r\n    mapping(address => uint256) public _txTimes;\r\n    uint256 public _freezeBlockNum = 4;\r\n    uint256 public _startMintLPHolderNum = 30;\r\n\r\n    uint256 private immutable _nodeSelfLPCondition;\r\n    uint256 private immutable _nodeInviteLPCondition;\r\n    TokenDistributor public immutable _usdtDistributor;\r\n\r\n    modifier lockTheSwap {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    constructor (\r\n        address RouterAddress, address UsdtAddress,\r\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,\r\n        address ReceiveAddress, address FundAddress\r\n    ){\r\n        _name = Name;\r\n        _symbol = Symbol;\r\n        _decimals = Decimals;\r\n\r\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\r\n        _swapRouter = swapRouter;\r\n        _allowances[address(this)][address(swapRouter)] = MAX;\r\n        _swapRouters[address(swapRouter)] = true;\r\n\r\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\r\n        _usdt = UsdtAddress;\r\n        IERC20(_usdt).approve(address(swapRouter), MAX);\r\n\r\n        address usdtPair;\r\n        if (address(1) == RouterAddress) {\r\n            usdtPair = PancakeLibrary.pairFor(address(swapFactory), _usdt, address(this));\r\n        } else {\r\n            usdtPair = swapFactory.createPair(_usdt, address(this));\r\n        }\r\n        _swapPairList[usdtPair] = true;\r\n        _mainPair = usdtPair;\r\n\r\n        uint256 tokenUnit = 10 ** Decimals;\r\n        uint256 total = Supply * tokenUnit;\r\n        _tTotal = total;\r\n\r\n        uint256 receiveTotal = total;\r\n        _balances[ReceiveAddress] = receiveTotal;\r\n        emit Transfer(address(0), ReceiveAddress, receiveTotal);\r\n\r\n        fundAddress = FundAddress;\r\n\r\n        _feeWhiteList[ReceiveAddress] = true;\r\n        _feeWhiteList[FundAddress] = true;\r\n        _feeWhiteList[address(this)] = true;\r\n        _feeWhiteList[msg.sender] = true;\r\n        _feeWhiteList[address(0)] = true;\r\n        _feeWhiteList[address(0x000000000000000000000000000000000000dEaD)] = true;\r\n        _bindCondition = 100 * tokenUnit / 100000;\r\n        _poolInfo.totalMintReward = 9500000 * tokenUnit;\r\n        _stableMintPerDay = 555 * tokenUnit;\r\n\r\n        uint256 usdtUnit = 10 ** IERC20(UsdtAddress).decimals();\r\n        _minInviteLPUsdt = 200 * usdtUnit;\r\n        _maxInviteLPUsdt = 2000 * usdtUnit;\r\n\r\n        _nodeSelfLPCondition = 2000 * usdtUnit;\r\n        _nodeInviteLPCondition = 6000 * usdtUnit;\r\n\r\n        _usdtDistributor = new TokenDistributor(UsdtAddress);\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_swapPairList[account]) {\r\n            return _balances[account];\r\n        }\r\n        (uint256 mintReward, uint256 nodeReward) = _calPendingMintReward(account);\r\n        return _balances[account] + mintReward + nodeReward;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        if (_allowances[sender][msg.sender] != MAX) {\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(!_blackList[from] || _feeWhiteList[from] || _swapPairList[from], \"BL\");\r\n\r\n        uint256 balance = balanceOf(from);\r\n        require(balance >= amount, \"BNE\");\r\n\r\n        bool takeFee;\r\n        if (!_feeWhiteList[from] && !_feeWhiteList[to] && !_rootList[from] && !_rootList[to]) {\r\n            uint256 maxSellAmount = balance * 999999 / 1000000;\r\n            if (amount > maxSellAmount) {\r\n                amount = maxSellAmount;\r\n            }\r\n            takeFee = true;\r\n        }\r\n\r\n        bool isAddLP;\r\n        bool isRemoveLP;\r\n\r\n        uint256 addLPLiquidity;\r\n        bool updateNode = true;\r\n        if (to == _mainPair && _swapRouters[msg.sender]) {\r\n            addLPLiquidity = _isAddLiquidity(amount);\r\n            if (addLPLiquidity > 0) {\r\n                isAddLP = true;\r\n                takeFee = false;\r\n                updateNode = false;\r\n            }\r\n        }\r\n\r\n        uint256 removeLPLiquidity;\r\n        if (from == _mainPair) {\r\n            removeLPLiquidity = _strictCheckBuy(amount);\r\n            if (removeLPLiquidity > 0) {\r\n                if (to != fundAddress) {\r\n                    require(_userInfo[to].lpAmount >= removeLPLiquidity);\r\n                    if (0 == IERC20(_mainPair).balanceOf(to)) {\r\n                        removeLPLiquidity = _userInfo[to].lpAmount;\r\n                    }\r\n                    isRemoveLP = true;\r\n                    updateNode = false;\r\n                } else {\r\n                    removeLPLiquidity = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        (uint256 tokenPrice, uint256 totalLPValue) = getTokenPriceAndTotalLPValue();\r\n        if (from != address(this)) {\r\n            _claimMintReward(tx.origin, tokenPrice, totalLPValue, removeLPLiquidity, updateNode);\r\n            _updateHighestPrice(tokenPrice);\r\n        }\r\n\r\n        if (addLPLiquidity > 0) {\r\n            _deposit(from, addLPLiquidity, false);\r\n        } else if (removeLPLiquidity > 0) {\r\n            _withdraw(to, removeLPLiquidity, false, removeLPLiquidity);\r\n        }\r\n\r\n        if (_swapPairList[from] || _swapPairList[to]) {\r\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\r\n                require(0 < startTradeBlock);\r\n                if (block.number < startTradeBlock + 3) {\r\n                    _funTransfer(from, to, amount, 99);\r\n                    return;\r\n                }\r\n            }\r\n        } else {\r\n            if (amount == _bindCondition && address(0) == _invitor[from] && 0 == _userInfo[from].lpAmount) {\r\n                _bindInvitor(from, to);\r\n                if (_rootList[to]) {\r\n                    _rootInvitor[from] = to;\r\n                } else {\r\n                    _rootInvitor[from] = _rootInvitor[to];\r\n                }\r\n            }\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount, takeFee, isRemoveLP);\r\n\r\n        if (from != address(this)) {\r\n            if (isAddLP) {\r\n                _addLpProvider(from);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _bindInvitor(address account, address invitor) private {\r\n        if (_invitor[account] == address(0) && invitor != address(0) && invitor != account) {\r\n            if (_binders[account].length == 0) {\r\n                uint256 size;\r\n                assembly {size := extcodesize(account)}\r\n                if (size > 0) {\r\n                    return;\r\n                }\r\n                _invitor[account] = invitor;\r\n                _binders[invitor].push(account);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBinderLength(address account) external view returns (uint256){\r\n        return _binders[account].length;\r\n    }\r\n\r\n    function _isAddLiquidity(uint256 amount) internal view returns (uint256 liquidity){\r\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();\r\n        uint256 amountOther;\r\n        if (rOther > 0 && rThis > 0) {\r\n            amountOther = amount * rOther / rThis;\r\n        }\r\n        if (balanceOther >= rOther + amountOther) {\r\n            (liquidity,) = calLiquidity(balanceOther, amount, rOther, rThis);\r\n        }\r\n    }\r\n\r\n    function _strictCheckBuy(uint256 amount) internal view returns (uint256 liquidity){\r\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();\r\n        if (balanceOther < rOther) {\r\n            liquidity = (amount * ISwapPair(_mainPair).totalSupply()) /\r\n            (_balances[_mainPair] - amount);\r\n        } else if (_strictCheck) {\r\n            uint256 amountOther;\r\n            if (rOther > 0 && rThis > 0) {\r\n                amountOther = amount * rOther / (rThis - amount);\r\n                require(balanceOther >= amountOther + rOther);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calLiquidity(\r\n        uint256 balanceA,\r\n        uint256 amount,\r\n        uint256 r0,\r\n        uint256 r1\r\n    ) private view returns (uint256 liquidity, uint256 feeToLiquidity) {\r\n        uint256 pairTotalSupply = ISwapPair(_mainPair).totalSupply();\r\n        address feeTo = ISwapFactory(_swapRouter.factory()).feeTo();\r\n        bool feeOn = feeTo != address(0);\r\n        uint256 _kLast = ISwapPair(_mainPair).kLast();\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint256 rootK = Math.sqrt(r0 * r1);\r\n                uint256 rootKLast = Math.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint256 numerator;\r\n                    uint256 denominator;\r\n                    if (address(_swapRouter) == address(0x10ED43C718714eb63d5aA57B78B54704E256024E)) {numerator = pairTotalSupply * (rootK - rootKLast) * 8;\r\n                        denominator = rootK * 17 + (rootKLast * 8);\r\n                    } else if (address(_swapRouter) == address(0xD99D1c33F9fC3444f8101754aBC46c52416550D1)) {numerator = pairTotalSupply * (rootK - rootKLast);\r\n                        denominator = rootK * 3 + rootKLast;\r\n                    } else if (address(_swapRouter) == address(0xE9d6f80028671279a28790bb4007B10B0595Def1)) {numerator = pairTotalSupply * (rootK - rootKLast) * 3;\r\n                        denominator = rootK * 5 + rootKLast;\r\n                    } else {numerator = pairTotalSupply * (rootK - rootKLast);\r\n                        denominator = rootK * 5 + rootKLast;\r\n                    }\r\n                    feeToLiquidity = numerator / denominator;\r\n                    if (feeToLiquidity > 0) pairTotalSupply += feeToLiquidity;\r\n                }\r\n            }\r\n        }\r\n        uint256 amount0 = balanceA - r0;\r\n        if (pairTotalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0 * amount) - 1000;\r\n        } else {\r\n            liquidity = Math.min(\r\n                (amount0 * pairTotalSupply) / r0,\r\n                (amount * pairTotalSupply) / r1\r\n            );\r\n        }\r\n    }\r\n\r\n    function _getReserves() public view returns (uint256 rOther, uint256 rThis, uint256 balanceOther){\r\n        (rOther, rThis) = __getReserves();\r\n        balanceOther = IERC20(_usdt).balanceOf(_mainPair);\r\n    }\r\n\r\n    function __getReserves() public view returns (uint256 rOther, uint256 rThis){\r\n        ISwapPair mainPair = ISwapPair(_mainPair);\r\n        (uint r0, uint256 r1,) = mainPair.getReserves();\r\n\r\n        address tokenOther = _usdt;\r\n        if (tokenOther < address(this)) {\r\n            rOther = r0;\r\n            rThis = r1;\r\n        } else {\r\n            rOther = r1;\r\n            rThis = r0;\r\n        }\r\n    }\r\n\r\n    function _funTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount,\r\n        uint256 fee\r\n    ) private {\r\n        _balances[sender] = _balances[sender] - tAmount;\r\n        uint256 feeAmount = tAmount * fee / 100;\r\n        if (feeAmount > 0) {\r\n            _takeTransfer(sender, fundAddress, feeAmount);\r\n        }\r\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\r\n    }\r\n\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount,\r\n        bool takeFee,\r\n        bool isRemoveLP\r\n    ) private {\r\n        uint256 senderBalance = _balances[sender];\r\n        senderBalance -= tAmount;\r\n        _balances[sender] = senderBalance;\r\n        uint256 feeAmount;\r\n\r\n        if (takeFee) {\r\n            uint256 blockNum = block.number;\r\n            address txOrigin = tx.origin;\r\n            uint256 freezeBlockNum = _freezeBlockNum;\r\n            require(blockNum > _txTimes[txOrigin] + freezeBlockNum);\r\n            if (isRemoveLP) {\r\n                require(blockNum > _txTimes[recipient] + freezeBlockNum);\r\n                _txTimes[recipient] = blockNum;\r\n            } else if (_swapPairList[sender]) {uint256 buyFundFeeAmount = tAmount * _buyFundFee / 10000;\r\n                feeAmount += buyFundFeeAmount;\r\n                _takeTransfer(sender, fundAddress, buyFundFeeAmount);\r\n\r\n                uint256 buyRootFeeAmount = tAmount * _buyRootFee / 10000;\r\n                feeAmount += buyRootFeeAmount;\r\n                address rootInvitor = _rootInvitor[recipient];\r\n                if (address(0) == rootInvitor) {\r\n                    rootInvitor = fundAddress;\r\n                }\r\n                _takeTransfer(sender, rootInvitor, buyRootFeeAmount);\r\n\r\n                require(blockNum > _txTimes[recipient] + freezeBlockNum);\r\n                _txTimes[recipient] = blockNum;\r\n                if (_isContract(recipient) || txOrigin != recipient) {\r\n                    _blackList[recipient] = true;\r\n                }\r\n            } else if (_swapPairList[recipient]) {require(txOrigin == sender);\r\n                require(blockNum > _txTimes[sender] + freezeBlockNum);\r\n                _txTimes[sender] = blockNum;\r\n                uint256 swapFeeAmount = tAmount * (_sellFundFee + _sellRootFee) / 10000;\r\n                feeAmount += swapFeeAmount;\r\n                _takeTransfer(sender, address(this), swapFeeAmount);\r\n                if (!inSwap) {\r\n                    address rootInvitor = _rootInvitor[sender];\r\n                    if (address(0) == rootInvitor) {\r\n                        rootInvitor = fundAddress;\r\n                    }\r\n                    swapTokenForFund(swapFeeAmount, rootInvitor);\r\n                }\r\n            } else {\r\n                require(blockNum > _txTimes[sender] + freezeBlockNum);\r\n                _txTimes[sender] = blockNum;\r\n            }\r\n            _txTimes[txOrigin] = blockNum;\r\n        }\r\n\r\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\r\n    }\r\n\r\n    function swapTokenForFund(uint256 tokenAmount, address rootInvitor) private lockTheSwap {\r\n        if (tokenAmount == 0) {\r\n            return;\r\n        }\r\n\r\n        address usdt = _usdt;\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n        address usdtDistributor = address(_usdtDistributor);\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            usdtDistributor,\r\n            block.timestamp\r\n        );\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalance = USDT.balanceOf(usdtDistributor);\r\n        uint256 fundUsdt = usdtBalance * _sellFundFee / (_sellFundFee + _sellRootFee);\r\n        if (fundUsdt > 0) {\r\n            USDT.transferFrom(usdtDistributor, fundAddress, fundUsdt);\r\n            usdtBalance -= fundUsdt;\r\n        }\r\n        if (usdtBalance > 0) {\r\n            USDT.transferFrom(usdtDistributor, rootInvitor, usdtBalance);\r\n        }\r\n    }\r\n\r\n    function _takeTransfer(\r\n        address sender,\r\n        address to,\r\n        uint256 tAmount\r\n    ) private {\r\n        _balances[to] = _balances[to] + tAmount;\r\n        emit Transfer(sender, to, tAmount);\r\n    }\r\n\r\n    address[] public lpProviders;\r\n    mapping(address => uint256) public lpProviderIndex;\r\n\r\n    function getLPProviderLength() public view returns (uint256){\r\n        return lpProviders.length;\r\n    }\r\n\r\n    function _addLpProvider(address adr) private {\r\n        if (0 == lpProviderIndex[adr]) {\r\n            if (0 == lpProviders.length || lpProviders[0] != adr) {\r\n                lpProviderIndex[adr] = lpProviders.length;\r\n                lpProviders.push(adr);\r\n                if (0 == _startMintBlock && lpProviders.length >= _startMintLPHolderNum) {\r\n                    _poolInfo.lastMintBlock = block.number + _dailyBlockNum;\r\n                    _startMintBlock = block.number + _dailyBlockNum;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setFundAddress(address addr) external onlyOwner {\r\n        fundAddress = addr;\r\n        _feeWhiteList[addr] = true;\r\n    }\r\n\r\n    function setFeeWhiteList(address addr, bool enable) external onlyOwner {\r\n        _feeWhiteList[addr] = enable;\r\n    }\r\n\r\n    function batchSetFeeWhiteList(address [] memory addr, bool enable) external onlyOwner {\r\n        for (uint i = 0; i < addr.length; i++) {\r\n            _feeWhiteList[addr[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function batchCheckWhiteList(address [] memory addr) external view returns (bool[] memory isWhiteList) {\r\n        isWhiteList = new bool[](addr.length);\r\n        for (uint i = 0; i < addr.length; i++) {\r\n            isWhiteList[i] = _feeWhiteList[addr[i]];\r\n        }\r\n    }\r\n\r\n    function setRootList(address addr, bool enable) external onlyOwner {\r\n        _rootList[addr] = enable;\r\n    }\r\n\r\n    function batchSetRootList(address [] memory addr, bool enable) external onlyOwner {\r\n        for (uint i = 0; i < addr.length; i++) {\r\n            _rootList[addr[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function batchCheckRootList(address [] memory addr) external view returns (bool[] memory isRootList) {\r\n        isRootList = new bool[](addr.length);\r\n        for (uint i = 0; i < addr.length; i++) {\r\n            isRootList[i] = _rootList[addr[i]];\r\n        }\r\n    }\r\n\r\n    function setBlackList(address addr, bool enable) external onlyOwner {\r\n        _blackList[addr] = enable;\r\n    }\r\n\r\n    function batchSetBlackList(address [] memory addr, bool enable) external onlyOwner {\r\n        for (uint i = 0; i < addr.length; i++) {\r\n            _blackList[addr[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function setSwapPairList(address addr, bool enable) external onlyOwner {\r\n        _swapPairList[addr] = enable;\r\n    }\r\n\r\n    function setSwapRouter(address addr, bool enable) external onlyOwner {\r\n        _swapRouters[addr] = enable;\r\n    }\r\n\r\n    function claimBalance() external {\r\n        payable(fundAddress).transfer(address(this).balance);\r\n    }\r\n\r\n    function claimToken(address token, uint256 amount) external {\r\n        IERC20(token).transfer(fundAddress, amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setStrictCheck(bool enable) external onlyOwner {\r\n        _strictCheck = enable;\r\n    }\r\n\r\n    function startTrade() external onlyOwner {\r\n        require(0 == startTradeBlock, \"T\");\r\n        startTradeBlock = block.number;\r\n    }\r\n\r\n    function setBindCondition(uint256 c) public onlyOwner {\r\n        _bindCondition = c;\r\n    }\r\n\r\n    function updateLPAmount(address account, uint256 lpAmount) public onlyOwner {\r\n        UserInfo storage userInfo = _userInfo[account];\r\n        uint256 preAmount = userInfo.lpAmount;\r\n        if (preAmount > lpAmount) {\r\n            _withdraw(account, preAmount - lpAmount, true, 0);\r\n        } else {\r\n            _deposit(account, lpAmount - preAmount, true);\r\n        }\r\n        _addLpProvider(account);\r\n    }\r\n\r\n    function getUserInfo(address account) public view returns (\r\n        uint256 lpAmount,\r\n        uint256 rewardDebt,\r\n        uint256 nodeAmount,\r\n        uint256 nodeRewardDebt,\r\n        uint256 inviteLPAmount,\r\n        uint256 lpBalance,\r\n        uint256 tokenBalance,\r\n        uint256 claimedMintReward,\r\n        uint256 claimedNodeReward,\r\n        uint256 inviteReward,\r\n        uint256 pendingMintReward,\r\n        uint256 pendingNodeReward\r\n    ) {\r\n        UserInfo storage userInfo = _userInfo[account];\r\n        lpAmount = userInfo.lpAmount;\r\n        rewardDebt = userInfo.rewardDebt;\r\n        nodeAmount = userInfo.nodeAmount;\r\n        nodeRewardDebt = userInfo.nodeRewardDebt;\r\n        inviteLPAmount = userInfo.inviteLPAmount;\r\n        lpBalance = IERC20(_mainPair).balanceOf(account);\r\n        tokenBalance = balanceOf(account);\r\n        claimedMintReward = userInfo.claimedMintReward;\r\n        claimedNodeReward = userInfo.claimedNodeReward;\r\n        inviteReward = userInfo.inviteReward;\r\n        (pendingMintReward, pendingNodeReward) = _calPendingMintReward(account);\r\n    }\r\n\r\n    function getPoolInfo() public view returns (\r\n        uint256 totalAmount,\r\n        uint256 accMintPerShare,\r\n        uint256 accMintReward,\r\n        uint256 mintPerBlock,\r\n        uint256 lastMintBlock,\r\n        uint256 totalMintReward,\r\n        uint256 totalNodeAmount,\r\n        uint256 accNodeRewardPerShare,\r\n        uint256 accNodeReward,\r\n        uint256 mintAmountPerDay,\r\n        uint256 lpTotalSupply,\r\n        uint256 tokenPrice,\r\n        uint256 totalLPValue\r\n    ) {\r\n        totalAmount = _poolInfo.totalAmount;\r\n        accMintPerShare = _poolInfo.accMintPerShare;\r\n        accMintReward = _poolInfo.accMintReward;\r\n        mintPerBlock = _poolInfo.mintPerBlock;\r\n        lastMintBlock = _poolInfo.lastMintBlock;\r\n        totalMintReward = _poolInfo.totalMintReward;\r\n        totalNodeAmount = _poolInfo.totalNodeAmount;\r\n        accNodeRewardPerShare = _poolInfo.accNodeRewardPerShare;\r\n        accNodeReward = _poolInfo.accNodeReward;\r\n        mintAmountPerDay = _poolInfo.mintAmountPerDay;\r\n        lpTotalSupply = IERC20(_mainPair).totalSupply();\r\n        (tokenPrice, totalLPValue) = getTokenPriceAndTotalLPValue();\r\n    }\r\n\r\n    function _testSetStartMintBlock(uint256 b) external onlyOwner {\r\n        require(b > 0, \"not 0\");\r\n        require(_startMintBlock > 0, \"not started\");\r\n        _startMintBlock = b;\r\n    }\r\n\r\n    function _testSetFreezeBlockNum(uint256 n) external onlyOwner {\r\n        _freezeBlockNum = n;\r\n    }\r\n\r\n    function _testSetStartMintLPHolderNum(uint256 n) external onlyOwner {\r\n        _startMintLPHolderNum = n;\r\n    }\r\n\r\n    function _testStartMint() external onlyOwner {\r\n        require(_poolInfo.lastMintBlock > block.number, \"started\");\r\n        _poolInfo.lastMintBlock = block.number;\r\n        _startMintBlock = block.number;\r\n    }\r\n\r\n    function _mintReward(uint256 amount, uint256 realReward) private {\r\n        _tTotal += amount;\r\n        uint256 destroyAmount = amount - realReward;\r\n        if (destroyAmount > 0) {\r\n            _balances[address(0x000000000000000000000000000000000000dEaD)] += destroyAmount;\r\n            emit Transfer(address(0), address(0x000000000000000000000000000000000000dEaD), destroyAmount);\r\n        }\r\n        _balances[address(this)] += realReward;\r\n        emit Transfer(address(0), address(this), realReward);\r\n    }\r\n\r\n    function _deposit(address account, uint256 amount, bool shouldClaim) private {\r\n        require(account != fundAddress, \"NF\");\r\n        (uint256 tokenPrice, uint256 totalLPValue) = getTokenPriceAndTotalLPValue();\r\n        if (shouldClaim) {\r\n            _claimMintReward(account, tokenPrice, totalLPValue, 0, false);\r\n        }\r\n        UserInfo storage user = _userInfo[account];\r\n        user.lpAmount += amount;\r\n        _poolInfo.totalAmount += amount;\r\n        user.rewardDebt = user.lpAmount * _poolInfo.accMintPerShare / _rewardFactor;\r\n\r\n        _updateNodeInfo(account, totalLPValue, 0);\r\n        address invitor = _invitor[account];\r\n        if (address(0) != invitor) {\r\n            _userInfo[invitor].inviteLPAmount += amount;\r\n            _updateNodeInfo(invitor, totalLPValue, 0);\r\n        }\r\n    }\r\n\r\n    function _withdraw(address account, uint256 amount, bool shouldClaim, uint256 removeLPAmount) private {\r\n        require(account != fundAddress, \"NF\");\r\n        (uint256 tokenPrice, uint256 totalLPValue) = getTokenPriceAndTotalLPValue();\r\n        if (shouldClaim) {\r\n            _claimMintReward(account, tokenPrice, totalLPValue, 0, false);\r\n        }\r\n        UserInfo storage user = _userInfo[account];\r\n        user.lpAmount -= amount;\r\n        _poolInfo.totalAmount -= amount;\r\n        user.rewardDebt = user.lpAmount * _poolInfo.accMintPerShare / _rewardFactor;\r\n\r\n        _updateNodeInfo(account, totalLPValue, removeLPAmount);\r\n        address invitor = _invitor[account];\r\n        if (address(0) != invitor) {\r\n            _userInfo[invitor].inviteLPAmount -= amount;\r\n            _updateNodeInfo(invitor, totalLPValue, removeLPAmount);\r\n        }\r\n    }\r\n\r\n    function claimMintReward(address account) public {\r\n        require(tx.origin == msg.sender, \"NC\");\r\n        (uint256 tokenPrice, uint256 totalLPValue) = getTokenPriceAndTotalLPValue();\r\n        _claimMintReward(account, tokenPrice, totalLPValue, 0, true);\r\n    }\r\n\r\n    function _claimMintReward(address account, uint256 price, uint256 totalLPValue, uint256 removeLPLiquidity, bool updateNode) private {\r\n        _updatePool(price);\r\n        UserInfo storage user = _userInfo[account];\r\n        uint256 pendingMint;\r\n        uint256 lpAmount = user.lpAmount;\r\n        if (lpAmount > 0) {\r\n            uint256 accMintReward = lpAmount * _poolInfo.accMintPerShare / _rewardFactor;\r\n            pendingMint = accMintReward - user.rewardDebt;\r\n            if (pendingMint > 0) {\r\n                user.rewardDebt = accMintReward;\r\n            }\r\n        }\r\n        if (pendingMint > 0) {\r\n            user.claimedMintReward += pendingMint;\r\n            _giveMintReward(account, pendingMint);\r\n            _claimNodeReward(account, totalLPValue, removeLPLiquidity, updateNode);\r\n\r\n            uint256 inviteAmount = pendingMint * _lpMintInviteRate / 10000;\r\n            uint256 destroyAmount = inviteAmount;\r\n            address invitor = _invitor[account];\r\n            if (address(0) != invitor) {\r\n                uint256 invitorLPAmount = _userInfo[invitor].lpAmount;\r\n                uint256 invitorLPValue = invitorLPAmount * totalLPValue / (IERC20(_mainPair).totalSupply() + removeLPLiquidity);\r\n                if (invitorLPValue >= _maxInviteLPUsdt) {\r\n                    destroyAmount = 0;\r\n                } else if (invitorLPValue >= _minInviteLPUsdt) {\r\n                    if (invitorLPAmount >= lpAmount) {\r\n                        destroyAmount = 0;\r\n                    } else {\r\n                        inviteAmount = inviteAmount * invitorLPAmount / lpAmount;\r\n                        destroyAmount -= inviteAmount;\r\n                    }\r\n                } else {\r\n                    inviteAmount = 0;\r\n                }\r\n                if (inviteAmount > 0) {\r\n                    _userInfo[invitor].inviteReward += inviteAmount;\r\n                    _giveMintReward(invitor, inviteAmount);\r\n                }\r\n                _claimNodeReward(invitor, totalLPValue, removeLPLiquidity, updateNode);\r\n            }\r\n            if (destroyAmount > 0) {\r\n                _giveMintReward(address(0x000000000000000000000000000000000000dEaD), destroyAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _claimNodeReward(address account, uint256 totalLPValue, uint256 removeLPLiquidity, bool updateNode) private {\r\n        UserInfo storage user = _userInfo[account];\r\n        uint256 pendingNodeMint;\r\n        uint256 nodeAmount = user.nodeAmount;\r\n        if (nodeAmount > 0) {\r\n            uint256 accNodeMintReward = nodeAmount * _poolInfo.accNodeRewardPerShare / _rewardFactor;\r\n            pendingNodeMint = accNodeMintReward - user.nodeRewardDebt;\r\n            if (pendingNodeMint > 0) {\r\n                user.nodeRewardDebt = accNodeMintReward;\r\n                _giveMintReward(account, pendingNodeMint);\r\n                user.claimedNodeReward += pendingNodeMint;\r\n            }\r\n        }\r\n        if (updateNode) {\r\n            _updateNodeInfo(account, totalLPValue, removeLPLiquidity);\r\n        }\r\n    }\r\n\r\n    function _giveMintReward(address account, uint256 amount) private {\r\n        _funTransfer(address(this), account, amount, 0);\r\n    }\r\n\r\n    function _updatePool(uint256 price) private {\r\n        PoolInfo storage pool = _poolInfo;\r\n        uint256 blockNum = block.number;\r\n        uint256 lastRewardBlock = pool.lastMintBlock;\r\n        if (0 == lastRewardBlock || blockNum <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        pool.lastMintBlock = blockNum;\r\n\r\n        uint256 accReward = pool.accMintReward;\r\n        uint256 totalReward = pool.totalMintReward;\r\n        if (accReward >= totalReward) {\r\n            return;\r\n        }\r\n\r\n        uint256 totalAmount = pool.totalAmount;\r\n        uint256 rewardPerBlock = pool.mintPerBlock;\r\n        if (0 < totalAmount && 0 < rewardPerBlock) {\r\n            uint256 reward = rewardPerBlock * (blockNum - lastRewardBlock);\r\n            uint256 remainReward = totalReward - accReward;\r\n            if (reward > remainReward) {\r\n                reward = remainReward;\r\n            }\r\n            if (reward > 0) {\r\n                uint256 realReward = reward;\r\n                uint256 highestPrice = _highestPrice;\r\n                if (price < highestPrice * _mintDestroyTokenPriceRate / 10000) {\r\n                    realReward = reward * price / highestPrice;\r\n                }\r\n                uint256 lpMintReward = realReward * _lpMintRate / 10000;\r\n                pool.accMintPerShare += lpMintReward * _rewardFactor / totalAmount;\r\n                pool.accMintReward += lpMintReward;\r\n\r\n                _mintReward(reward, realReward);\r\n\r\n                uint256 nodeMintReward = realReward * _nodeMintRate / 10000;\r\n                uint256 totalNodeAmount = pool.totalNodeAmount;\r\n                if (totalNodeAmount > 0) {\r\n                    pool.accNodeRewardPerShare += nodeMintReward * _rewardFactor / totalNodeAmount;\r\n                    pool.accNodeReward += nodeMintReward;\r\n                } else {\r\n                    _giveMintReward(address(0x000000000000000000000000000000000000dEaD), nodeMintReward);\r\n                }\r\n            }\r\n        }\r\n        _updateDailyMintAmount();\r\n    }\r\n\r\n    mapping(uint256 => uint256) public _dailyMintAmount;\r\n    uint256 private constant _mintDestroyTokenPriceRate = 7000;\r\n    uint256 private constant _lpMintRate = 6200;\r\n    uint256 private constant _nodeMintRate = 700;\r\n    uint256 private constant _lpMintInviteRate = 5000;\r\n    uint256 private immutable _minInviteLPUsdt;\r\n    uint256 private immutable _maxInviteLPUsdt;\r\n\r\n    function getMintDayNum() public view returns (uint256){\r\n        uint256 startBlock = _startMintBlock;\r\n        uint256 nowBlock = block.number;\r\n        if (0 == startBlock || nowBlock < startBlock) {\r\n            return 0;\r\n        }\r\n        return (nowBlock - startBlock) / _dailyBlockNum + 1;\r\n    }\r\n\r\n    function _updateDailyMintAmount() private {\r\n        uint256 dayNum = getMintDayNum();\r\n        if (0 == dayNum) {\r\n            return;\r\n        }\r\n        if (0 == _dailyMintAmount[dayNum]) {\r\n            uint256 mintAmountPerDay = getMintAmountPerDay(dayNum);\r\n            _dailyMintAmount[dayNum] = mintAmountPerDay;\r\n            _poolInfo.mintPerBlock = mintAmountPerDay / _dailyBlockNum;\r\n            _poolInfo.mintAmountPerDay = mintAmountPerDay;\r\n        }\r\n    }\r\n\r\n    function getMintAmountPerDay(uint256 dayNum) public view returns (uint256){\r\n        if (0 == dayNum) {\r\n            return 0;\r\n        }\r\n        uint256 times = (dayNum - 1) / _minusMintRateDays;\r\n        if (times >= 7) {\r\n            return _stableMintPerDay;\r\n        }\r\n        return totalSupply() * _initMintRate / (2 ** times) / _mintRateDiv;\r\n    }\r\n\r\n    function _calPendingMintReward(address account) public view returns (uint256 mintReward, uint256 nodeReward) {\r\n        UserInfo storage user = _userInfo[account];\r\n        if (user.lpAmount > 0) {\r\n            PoolInfo storage pool = _poolInfo;\r\n            uint256 poolPendingReward;\r\n            uint256 blockNum = block.number;\r\n            uint256 lastRewardBlock = pool.lastMintBlock;\r\n            if (lastRewardBlock > 0 && blockNum > lastRewardBlock) {\r\n                poolPendingReward = pool.mintPerBlock * (blockNum - lastRewardBlock);\r\n                uint256 totalReward = pool.totalMintReward;\r\n                uint256 accReward = pool.accMintReward;\r\n                uint256 remainReward;\r\n                if (totalReward > accReward) {\r\n                    remainReward = totalReward - accReward;\r\n                }\r\n                if (poolPendingReward > remainReward) {\r\n                    poolPendingReward = remainReward;\r\n                }\r\n            }\r\n\r\n            uint256 realReward = poolPendingReward;\r\n            uint256 highestPrice = _highestPrice;\r\n            (uint256 price,) = getTokenPriceAndTotalLPValue();\r\n            if (price < highestPrice * _mintDestroyTokenPriceRate / 10000) {\r\n                realReward = poolPendingReward * price / highestPrice;\r\n            }\r\n            uint256 lpMintReward = realReward * _lpMintRate / 10000;\r\n            mintReward += user.lpAmount * (pool.accMintPerShare + lpMintReward * _rewardFactor / pool.totalAmount) / _rewardFactor - user.rewardDebt;\r\n\r\n            uint256 nodeAmount = user.nodeAmount;\r\n            if (nodeAmount > 0) {\r\n                uint256 nodeMintReward = realReward * _nodeMintRate / 10000;\r\n                nodeReward += nodeAmount * (pool.accNodeRewardPerShare + nodeMintReward * _rewardFactor / pool.totalNodeAmount) / _rewardFactor - user.nodeRewardDebt;\r\n            }\r\n        }\r\n    }\r\n\r\n    uint256 public _highestPrice;\r\n\r\n    function _updateHighestPrice(uint256 price) private {\r\n        if (price > _highestPrice) {\r\n            _highestPrice = price;\r\n        }\r\n    }\r\n\r\n    function getTokenPriceAndTotalLPValue() public view returns (uint256 price, uint256 totalLPValue){\r\n        (uint256 rUsdt, uint256 rToken) = __getReserves();\r\n        totalLPValue = 2 * rUsdt;\r\n        if (rToken > 0) {\r\n            price = 10 ** _decimals * rUsdt / rToken;\r\n        }\r\n    }\r\n\r\n    function _updateNodeInfo(address account, uint256 totalLPValue, uint256 removeLPLiquidity) private {\r\n        uint256 lpTotalSupply = IERC20(_mainPair).totalSupply() + removeLPLiquidity;\r\n        if (0 == lpTotalSupply) {\r\n            return;\r\n        }\r\n        UserInfo storage user = _userInfo[account];\r\n        uint256 lpAmount = user.lpAmount;\r\n        uint256 lpValue = lpAmount * totalLPValue / lpTotalSupply;\r\n        uint256 inviteLPAmount = user.inviteLPAmount;\r\n        uint256 inviteLPValue = inviteLPAmount * totalLPValue / lpTotalSupply;\r\n        uint256 nodeAmount = user.nodeAmount;\r\n        if (lpValue < _nodeSelfLPCondition || inviteLPValue < _nodeInviteLPCondition) {\r\n            if (nodeAmount > 0) {\r\n                _nodeWithdraw(account, nodeAmount);\r\n            }\r\n        } else {if (lpAmount + inviteLPAmount > nodeAmount) {_nodeDeposit(account, lpAmount + inviteLPAmount - nodeAmount);\r\n        } else if (lpAmount + inviteLPAmount < nodeAmount) {_nodeWithdraw(account, nodeAmount - inviteLPAmount - lpAmount);\r\n        }\r\n        }\r\n    }\r\n\r\n    function _nodeDeposit(address account, uint256 amount) private {\r\n        UserInfo storage user = _userInfo[account];\r\n        user.nodeAmount += amount;\r\n        _poolInfo.totalNodeAmount += amount;\r\n        user.nodeRewardDebt = user.nodeAmount * _poolInfo.accNodeRewardPerShare / _rewardFactor;\r\n    }\r\n\r\n    function _nodeWithdraw(address account, uint256 amount) private {\r\n        UserInfo storage user = _userInfo[account];\r\n        user.nodeAmount -= amount;\r\n        _poolInfo.totalNodeAmount -= amount;\r\n        user.nodeRewardDebt = user.nodeAmount * _poolInfo.accNodeRewardPerShare / _rewardFactor;\r\n    }\r\n\r\n    function _isContract(address account) public view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(account)}\r\n        return size > 0;\r\n    }\r\n\r\n    function getBinderList(\r\n        address account,\r\n        uint256 start,\r\n        uint256 length\r\n    ) external view returns (\r\n        uint256 returnCount,\r\n        address[] memory binders,\r\n        uint256[] memory binderLPAmounts,\r\n        uint256[] memory binderLPBalances\r\n    ){\r\n        address[] storage tempBinders = _binders[account];\r\n        uint256 recordLen = tempBinders.length;\r\n        if (0 == length) {\r\n            length = recordLen;\r\n        }\r\n        returnCount = length;\r\n        binders = new address[](length);\r\n        binderLPAmounts = new uint256[](length);\r\n        binderLPBalances = new uint256[](length);\r\n        uint256 index = 0;\r\n        address binder;\r\n        for (uint256 i = start; i < start + length; i++) {\r\n            if (i >= recordLen) {\r\n                return (index, binders, binderLPAmounts, binderLPBalances);\r\n            }\r\n            binder = tempBinders[i];\r\n            binders[index] = binder;\r\n            binderLPAmounts[index] = _userInfo[binder].lpAmount;\r\n            binderLPBalances[index] = IERC20(_mainPair).balanceOf(binder);\r\n            index++;\r\n        }\r\n    }\r\n}\r\n\r\ncontract DikeCoin is AbsToken {\r\n    constructor() AbsToken(\r\n    address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\r\n    address(0x55d398326f99059fF775485246999027B3197955),\r\n    \"Dike.Coin\",\r\n    \"DIKE\",\r\n    18,\r\n    500000,\r\n    address(0x633cB8Df71Cd4eaF8B170b33455f2efDFa8167AF),\r\n    address(0x013bCf42aE7420215Eb1B28ed9426AAb1E464C98)\r\n    ){\r\n\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"__getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rOther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rThis\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_bindCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_binders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_calPendingMintReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_dailyMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_freezeBlockNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rOther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rThis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOther\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_highestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_invitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rootInvitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rootList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_startMintBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_startMintLPHolderNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_strictCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapRouters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"_testSetFreezeBlockNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"_testSetStartMintBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"_testSetStartMintLPHolderNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_testStartMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_txTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdtDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"}],\"name\":\"batchCheckRootList\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"isRootList\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"}],\"name\":\"batchCheckWhiteList\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"isWhiteList\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"batchSetBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"batchSetFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"batchSetRootList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimMintReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBinderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getBinderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnCount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"binders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"binderLPAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"binderLPBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPProviderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayNum\",\"type\":\"uint256\"}],\"name\":\"getMintAmountPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintDayNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastMintBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalNodeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accNodeRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accNodeReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmountPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLPValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPriceAndTotalLPValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLPValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nodeRewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteLPAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedNodeReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingNodeReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpProviderIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"c\",\"type\":\"uint256\"}],\"name\":\"setBindCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setRootList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setStrictCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"updateLPAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DikeCoin", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://457c2bf70f825b3506b6d8bdb481d1175c634824bc204f265a5cc189e73c3a6f"}