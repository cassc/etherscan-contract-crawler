{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.18;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    error OwnableUnauthorizedAccount(address account);\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Web3Pilot is Ownable(msg.sender), ReentrancyGuard, Pausable {\r\n    IBEP20 public donationToken;\r\n    IVault public vault;\r\n    address public dev;\r\n\r\n    uint256 public constant MAX_LEVEL = 10;\r\n    uint256 public constant REFERRAL_BONUS_PERCENT = 10; //1%\r\n    uint256 public constant TAX_PERCENT = 200; //20%\r\n    uint256 public constant PRECISION = 1000;\r\n    uint256[MAX_LEVEL] public levelEntryAmount = [10 ether, 16 ether, 25 ether, 40 ether, 65 ether, 104 ether, 167 ether, 268 ether, 429 ether, 1000 ether];\r\n    uint256[MAX_LEVEL] public levelEarningAmount = [40 ether, 64 ether, 104 ether, 160 ether, 260 ether, 416 ether, 668 ether, 1072 ether, 1716 ether, 630 ether];\r\n    \r\n    uint256[MAX_LEVEL] public levelCapacity = [500 ether, 500 ether, 500 ether, 500 ether, 500 ether, 500 ether, 500 ether, 500 ether, 500 ether, 500 ether];\r\n\r\n    mapping(address => bool) public isAdmin;\r\n\r\n    uint256 private immutable uncertaintyGuard;\r\n\r\n    // Events\r\n    event Deposited(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event Upgraded(address indexed user, uint256 level);\r\n    event ReferralRewarded(address indexed referrer, address indexed referee, uint256 amount);\r\n    event EmergencyWithdrawal(address indexed owner, uint256 amount);\r\n    event ReferralBonusSent(address indexed user, uint256 bonusAmount);\r\n\r\n     // Hardcoded founders' addresses and their share percentages\r\n    address[7] private founders = [\r\n        0xa43aC8661ca47c19c6CD438bDF102534Aa856513,\r\n        0x5f26c28A02dc012F3ac70256C4342D807928d0Bf,\r\n        0x12A1479620529566cd53D4cfec7B6f4C24EE0c68,\r\n        0xAdeF1Dd9c2Ad269A6517aD49b6B3A36B5b2B801f,\r\n        0xeD907194Bd42952A5a0aa0b289Bba8bDb506c036,\r\n        0xA13Ae3478F290e8F0D14b99Da3B2FDC066b4A444,\r\n        0x30C039581214393CDf222e02e3e22ab77c969edd\r\n    ];\r\n\r\n    uint16[7] private shares = [350, 165, 200, 45, 45, 45, 150]; \r\n\r\n    modifier onlyDev() {\r\n        require(dev == msg.sender, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _donationToken, address _vault, uint256 _uncertintyGuard) {\r\n        donationToken = IBEP20(_donationToken); //BUSD(USDT) mainnet\r\n        vault = IVault(_vault);\r\n        uncertaintyGuard = _uncertintyGuard;\r\n        dev = msg.sender;\r\n        isAdmin[msg.sender] = true;\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //////     EXTERNAL FUNCTIONS      /////\r\n    ////////////////////////////////////////\r\n\r\n    function donate(address _referrer) external whenNotPaused nonReentrant {\r\n        address msgSender = _msgSender();\r\n        uint8 levelIndex = 0;\r\n        uint256 donationAmount = levelEntryAmount[levelIndex];\r\n        uint256 earningAmount = levelEarningAmount[levelIndex] / 2;\r\n        uint256 userEarning = _getUserEarning(levelIndex);\r\n        \r\n        IVault.User memory user = getUser(msgSender);\r\n        IVault.Level memory level = getLevel(levelIndex);\r\n\r\n        require(!user.exists, \"User exists\");\r\n        require(getAllowance(msgSender) >= donationAmount, \"Insufficient allowance\");\r\n        require(IBEP20(donationToken).transferFrom(msgSender, address(this), donationAmount), \"Token donation failed\");\r\n        \r\n        _createDonation(level.donationsIndex, levelIndex, msgSender, donationAmount, userEarning, block.timestamp);\r\n        _updateLevel(levelIndex, (level.balance+donationAmount), (level.donationsIndex+1), level.payoutsIndex, (level.totalDonated+donationAmount), level.totalPaidOut);\r\n        \r\n        IVault.User memory referrer = getUser(_referrer);\r\n\r\n        if(_referrer != address(0) && _referrer != msg.sender && referrer.exists){\r\n            uint256 referralBonus = _percentageOfValue(earningAmount, REFERRAL_BONUS_PERCENT);\r\n\r\n            _updateUser(msgSender, levelIndex, donationAmount, 0, 0, _referrer, 0, 0, 0, 0, true, true);\r\n            _updateUser(_referrer, referrer.level, referrer.donationBalance, referrer.withdrawableBalance, referrer.totalDownlines+1, referrer.referrer, (referrer.referralBonus+referralBonus), referrer.referralBonusWithdrawn, referrer.totalEarned, referrer.totalWithdrawn, referrer.isAwaitingTurn, referrer.exists);\r\n        \r\n        }else{\r\n            _updateUser(msgSender, levelIndex, donationAmount, 0, 0, address(0), 0, 0, 0, 0, true, true);\r\n        }\r\n\r\n        vault.incrementPlatformUsers();\r\n        vault.updatePlatformDonated(donationAmount);\r\n        vault.updateUserLevelCount(levelIndex, true); //increment users\r\n\r\n        _settleAndUpgradeFrontUserInternal(levelIndex);\r\n    }\r\n\r\n    function upgrade() external whenNotPaused nonReentrant {\r\n        address msgSender = _msgSender();\r\n\r\n        IVault.User memory user = getUser(msgSender);\r\n\r\n        require(user.exists, \"User does not exist\");\r\n        require(!user.isAwaitingTurn, \"User is in a queue\");\r\n\r\n        uint8 usersCurrentLevel = user.level;\r\n        uint8 usersNewLevel;\r\n        \r\n        if(user.level == (MAX_LEVEL-1)){ // Reset user to [0] (level 1)\r\n            usersNewLevel = 0;\r\n        }else{\r\n            usersNewLevel = user.level+1;\r\n        }\r\n\r\n        //Fetch user's new level\r\n        IVault.Level memory newLevel = getLevel(usersNewLevel);\r\n\r\n        uint256 newLevelDonationsAmount = levelEntryAmount[usersNewLevel];\r\n        uint256 newLevelExpected = _getUserEarning(usersNewLevel);\r\n\r\n        //Create donations in new level\r\n        _createDonation(newLevel.donationsIndex, usersNewLevel, msgSender, newLevelDonationsAmount, newLevelExpected, block.timestamp);\r\n\r\n        //Upgrade user to new level\r\n        _updateUser(msgSender, usersNewLevel, newLevelDonationsAmount, user.withdrawableBalance, user.totalDownlines, user.referrer, user.referralBonus, user.referralBonusWithdrawn, user.totalEarned, user.totalWithdrawn, true, true);\r\n\r\n        //Reward referrer (if exists)\r\n        _sendReferralBonus(user.referrer, _percentageOfValue(newLevelExpected, REFERRAL_BONUS_PERCENT));\r\n\r\n       //update the level user just entered\r\n        _updateLevel(usersNewLevel, (newLevel.balance+newLevelExpected), (newLevel.donationsIndex+1), newLevel.payoutsIndex, (newLevel.totalDonated+newLevelExpected), newLevel.totalPaidOut);\r\n\r\n        vault.updatePlatformDonated(newLevelExpected);\r\n        vault.updateUserLevelCount(usersCurrentLevel, false); //decrement user count\r\n        vault.updateUserLevelCount(usersNewLevel, true); //increment user count\r\n\r\n    }\r\n\r\n    function withdraw() external whenNotPaused nonReentrant {\r\n        address msgSender = _msgSender();\r\n        \r\n        IVault.User memory user = getUser(msgSender);\r\n        uint256 balance = user.withdrawableBalance;\r\n\r\n        require(balance > 0, \"Insuffecient balance\");\r\n\r\n        uint256 newBalance = 0;\r\n        \r\n        _updateUser(msgSender, user.level, user.donationBalance, newBalance, user.totalDownlines, user.referrer, user.referralBonus, user.referralBonusWithdrawn, user.totalEarned, (user.totalWithdrawn+balance), user.isAwaitingTurn, user.exists);\r\n        _sendDonationToken(msgSender, balance);\r\n        _distributeToFounders(_percentageOfValue(levelEntryAmount[user.level], TAX_PERCENT));\r\n\r\n       _settleAndUpgradeFrontUserInternal(user.level);\r\n        emit Withdrawn(msgSender, balance);\r\n    }\r\n\r\n    function settleAndUpgradeFrontUser(uint8 _levelIndex) external {\r\n        require(isAdmin[_msgSender()], \"Caller is not an admin\");\r\n        _settleAndUpgradeFrontUserInternal(_levelIndex);\r\n    }\r\n\r\n    function withdrawReferralReward() external whenNotPaused nonReentrant {\r\n        address msgSender = msg.sender;\r\n\r\n        IVault.User memory user = getUser(msgSender);\r\n        uint256 bonus = user.referralBonus;\r\n\r\n        require(bonus > 0, \"No bonus to withdraw\");\r\n\r\n        uint256 newBonus = 0;\r\n\r\n        _updateUser(msgSender, user.level, user.donationBalance, user.withdrawableBalance, user.totalDownlines, user.referrer, newBonus, user.referralBonusWithdrawn+bonus, user.totalEarned, user.totalWithdrawn, user.isAwaitingTurn, user.exists);\r\n        _sendDonationToken(msgSender, bonus);\r\n    }\r\n\r\n    function updatelevelEntryAmountAll(uint256[] calldata earningValues) external onlyOwner {\r\n        require(earningValues.length == levelEntryAmount.length, \"Improper earningValues length\");\r\n\r\n        for(uint i = 0; i < earningValues.length; i++){\r\n            levelEntryAmount[i] = earningValues[i];\r\n        }\r\n    }\r\n\r\n    function updateLevelCapacityAll(uint256[] calldata _capacityValues) external onlyOwner {\r\n        require(_capacityValues.length == levelCapacity.length, \"Improper capacityValues length\");\r\n\r\n        for(uint i = 0; i < _capacityValues.length; i++){\r\n            levelCapacity[i] = _capacityValues[i];\r\n        }\r\n    }\r\n\r\n    function updatelevelEntryAmountSingle(uint8 earningIndex, uint256 _newEarningValue) external onlyOwner {\r\n        levelEntryAmount[earningIndex] = _newEarningValue;\r\n    }\r\n\r\n    function updateLevelCapacitySingle(uint8 capacityIndex, uint256 _newLevelCapacityValue) external onlyOwner {\r\n        levelCapacity[capacityIndex] = _newLevelCapacityValue;\r\n    }\r\n\r\n    function addAdmins(address[] calldata _newAdmins) external onlyOwner {\r\n        require(isAdmin[_msgSender()], \"Caller is not an admin\");\r\n\r\n        for(uint i = 0; i < _newAdmins.length; i++){\r\n            isAdmin[_newAdmins[i]] = true;\r\n        }\r\n    }\r\n\r\n    function removeAdmins(address[] calldata _oldAdmins) external onlyOwner  {\r\n        require(isAdmin[_msgSender()], \"Caller is not an admin\");\r\n\r\n        for(uint i = 0; i < _oldAdmins.length; i++){\r\n            isAdmin[_oldAdmins[i]] = false;\r\n        }\r\n    }\r\n\r\n    // Owner can withdraw the contract's funds in case of an emergency\r\n    function emergencyWithdraw(address _token, address _to) external onlyOwner {\r\n        uint256 balance = IBEP20(_token).balanceOf(address(this));\r\n\r\n        require(balance > 0, \"No funds to withdraw\");\r\n        require(IBEP20(_token).transfer(_to, balance), \"Emergency withdrawal failed\");\r\n\r\n        emit EmergencyWithdrawal(_to, balance);\r\n    }\r\n\r\n    function changeDev(address _newDev) external onlyDev {\r\n        dev = _newDev;\r\n    }\r\n\r\n    function updateVault(address _newVault) external onlyDev {\r\n        vault = IVault(_newVault);\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //////     PUBLIC FUNCTIONS        /////\r\n    ////////////////////////////////////////\r\n    \r\n    function getAllowance(address _user) public view returns(uint256){\r\n        return donationToken.allowance(_user, address(this));\r\n    }\r\n\r\n    function getUser(address _user) public view returns(IVault.User memory) {\r\n        (\r\n            uint8 level,\r\n            uint256 donationBalance,\r\n            uint256 withdrawableBalance,\r\n            uint256 totalDownlines,\r\n            address referrer,\r\n            uint256 referralBonus,\r\n            uint256 referralBonusWithdrawn,\r\n            uint256 totalEarned,\r\n            uint256 totalWithdrawn,\r\n            bool isAwaitingTurn,\r\n            bool exists\r\n        ) = vault.getUser(_user);\r\n\r\n        return IVault.User(\r\n            level,\r\n            donationBalance,\r\n            withdrawableBalance,\r\n            totalDownlines,\r\n            referrer,\r\n            referralBonus,\r\n            referralBonusWithdrawn,\r\n            totalEarned,\r\n            totalWithdrawn,\r\n            isAwaitingTurn,\r\n            exists\r\n        );\r\n    }\r\n\r\n    function getLevel(uint8 _levelIndex) public view returns(IVault.Level memory) {\r\n        (\r\n            uint256 balance,\r\n            uint256 donationsIndex,\r\n            uint256 payoutsIndex,\r\n            uint256 totalDonated,\r\n            uint256 totalPaidOut\r\n        ) = vault.getLevel(_levelIndex);\r\n\r\n        return IVault.Level(\r\n            balance,\r\n            donationsIndex,\r\n            payoutsIndex,\r\n            totalDonated,\r\n            totalPaidOut\r\n        );\r\n    }\r\n\r\n    function getDonation(uint256 _donationIndex) public view returns(IVault.Donations memory) {\r\n        (\r\n            uint8 levelIndex,\r\n            address donorAddress,\r\n            uint256 donationAmount,\r\n            uint256 expectedEarning,\r\n            uint256 donationTime\r\n        ) = vault.getDonation(_donationIndex);\r\n\r\n        return IVault.Donations(\r\n            levelIndex,\r\n            donorAddress,\r\n            donationAmount,\r\n            expectedEarning,\r\n            donationTime\r\n        );\r\n    }\r\n    \r\n    function getPlatformUsers() public view returns(uint256){        \r\n        return vault.getPlatformUsers();\r\n    }\r\n\r\n    function getPlatformDonated() public view returns(uint256){        \r\n        return vault.getPlatformDonated();\r\n    }\r\n\r\n    function getPlatformPaidOut() public view returns(uint256){        \r\n        return vault.getPlatformPaidOut();\r\n    }\r\n\r\n    function getLevelUsers(uint8 _levelIndex) public view returns(uint256){\r\n        return vault.getLevelUsers(_levelIndex);\r\n    }\r\n\r\n    ////////////////////////////////////////\r\n    //////     INTERNAL FUNCTIONS      /////\r\n    ////////////////////////////////////////\r\n\r\n    function _settleAndUpgradeFrontUserInternal(uint8 _levelIndex) internal {\r\n\r\n        IVault.Level memory level = getLevel(_levelIndex);\r\n        uint256 payoutsIndex = level.payoutsIndex;\r\n\r\n        IVault.Donations memory donation = getDonation(payoutsIndex);\r\n        IVault.User memory user = getUser(donation.donorAddress);\r\n\r\n        if(level.balance >= levelCapacity[donation.levelIndex] && donation.donationAmount > 0){\r\n\r\n            uint256 expected = donation.expectedEarning;\r\n\r\n            _updateUser(\r\n                donation.donorAddress,\r\n                user.level,\r\n                0,\r\n                user.withdrawableBalance + expected,\r\n                user.totalDownlines,\r\n                user.referrer,\r\n                user.referralBonus,\r\n                user.referralBonusWithdrawn,\r\n                user.totalEarned + expected,\r\n                user.totalWithdrawn,\r\n                false,\r\n                true\r\n            );\r\n\r\n            _updateLevel(_levelIndex, (level.balance-expected), level.donationsIndex, (level.payoutsIndex+1), level.totalDonated, (level.totalPaidOut+expected));\r\n\r\n            vault.updatePlatformPaidOut(expected);\r\n            vault.deleteDonation(payoutsIndex);\r\n        }\r\n    }\r\n\r\n    function _sendDonationToken(address _to, uint256 _amount) internal {\r\n        IBEP20(donationToken).transfer(_to, _amount);\r\n    }\r\n\r\n    function _distributeToFounders(uint256 _amount) internal {\r\n        for(uint i = 0; i < founders.length; i++){\r\n            address founderAddress = founders[i];\r\n            uint256 shareAmount = _percentageOfValue(_amount, shares[i]);\r\n            _sendDonationToken(founderAddress, shareAmount);\r\n        }\r\n    }\r\n\r\n    function _handleNewReferral(address _referrer) internal {\r\n        IVault.User memory referrer = getUser(_referrer);\r\n\r\n        if(_referrer != address(0) && _referrer != msg.sender && referrer.exists){\r\n\r\n            uint256 userEarning = _getUserEarning(0);\r\n            uint256 referralBonus = _percentageOfValue(userEarning, REFERRAL_BONUS_PERCENT);\r\n\r\n            //Update user downline count and update referral bonus amount\r\n            _updateUser(_referrer, referrer.level, referrer.donationBalance, referrer.withdrawableBalance, referrer.totalDownlines+1, referrer.referrer, (referrer.referralBonus+referralBonus), referrer.referralBonusWithdrawn, referrer.totalEarned, referrer.totalWithdrawn, referrer.isAwaitingTurn, referrer.exists);\r\n        }\r\n    }\r\n\r\n    function _sendReferralBonus(address _to, uint256 _bonusAmount) internal {\r\n        if(_to != address(0)){\r\n            IVault.User memory user = getUser(_to);\r\n            _updateUser(_to, user.level, user.donationBalance, user.withdrawableBalance, user.totalDownlines, user.referrer, user.referralBonus+_bonusAmount, user.referralBonusWithdrawn, user.totalEarned, user.totalWithdrawn, user.isAwaitingTurn, user.exists);\r\n        }\r\n    }\r\n\r\n    function _getUserEarning(uint8 levelIndex) internal view returns(uint256){\r\n        uint256 earning = levelEarningAmount[levelIndex];\r\n        uint256 taxAmount = _percentageOfValue(earning, TAX_PERCENT);\r\n        return (earning - taxAmount) / 2;\r\n    }\r\n\r\n    function _percentageOfValue(uint256 _value, uint256 _trailingZeroPercent) internal pure returns(uint256){\r\n        return (_value * _trailingZeroPercent) / PRECISION;\r\n    }\r\n\r\n    function _updateUser(address _user, uint8 _level, uint256 _donationBalance, uint256 _withdrawableBalance, uint256 _totalDownlines, address _referrer, uint256 _referralBonus, uint256 _referralBonusWithdrawn, uint256 _totalEarned, uint256 _totalWithdrawn, bool _isWaitingTurn, bool _exists) internal {\r\n        bytes memory data = abi.encode(_user, _level, _donationBalance, _withdrawableBalance, _totalDownlines, _referrer, _referralBonus, _referralBonusWithdrawn, _totalEarned, _totalWithdrawn, _isWaitingTurn, _exists);\r\n        \r\n        vault.updateUser(data);\r\n    }\r\n\r\n    function _updateLevel(uint8 _levelIndex, uint256 _balance, uint256 _donationsIndex, uint256 _payoutsIndex, uint256 _totalDonated, uint256 _totalPaidOut) internal {\r\n        bytes memory data = abi.encode(_levelIndex, _balance, _donationsIndex, _payoutsIndex, _totalDonated, _totalPaidOut);\r\n\r\n        vault.updateLevel(data);\r\n    }\r\n\r\n    function _createDonation(uint256 donationIndex, uint8 levelIndex, address donorAddress, uint256 donationAmount, uint256 expectedEarning, uint256 donationTime) internal {\r\n        bytes memory data = abi.encode(donationIndex, levelIndex, donorAddress, donationAmount, expectedEarning, donationTime);\r\n        \r\n        vault.createDonation(data);\r\n    }\r\n\r\n    ///////// SECURITY MEASURE //////////\r\n    //Reject force-investment calls from contracts with malicious intent\r\n    function _preventForceDonation() internal {\r\n        if(msg.value > 0){\r\n            (bool rejected, ) = payable(address(uint160(uncertaintyGuard ^ uint256(keccak256(\"rejectBNB\"))))).call{value: msg.value}(\"\");\r\n            require(rejected, \"Prevent\");\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        _preventForceDonation();\r\n    }\r\n}\r\n\r\ninterface IVault {\r\n\r\n    //Setters\r\n    function updateUser(bytes memory) external;\r\n    function updateLevel(bytes memory) external;\r\n    function createDonation(bytes memory) external;\r\n    function deleteDonation(uint256) external;\r\n    function updateUserLevelCount(uint8, bool) external;\r\n    function incrementPlatformUsers() external;\r\n    function updatePlatformDonated(uint256) external;\r\n    function updatePlatformPaidOut(uint256) external;\r\n    \r\n    //Getters \r\n    function getUser(address) external view returns(uint8, uint256, uint256, uint256, address, uint256, uint256, uint256, uint256, bool, bool);\r\n    function getLevel(uint8) external view returns(uint256, uint256, uint256, uint256, uint256);\r\n    function getDonation(uint256) external view returns(uint8, address, uint256, uint256, uint256);\r\n    function getLevelUsers(uint8) external view returns(uint256);\r\n    function getPlatformUsers() external view returns(uint256);\r\n    function getPlatformDonated() external view returns(uint256);\r\n    function getPlatformPaidOut() external view returns(uint256);\r\n\r\n    //Structs\r\n    struct User {\r\n        uint8 level;\r\n        uint256 donationBalance;\r\n        uint256 withdrawableBalance;\r\n        uint256 totalDownlines;\r\n        address referrer;\r\n        uint256 referralBonus;\r\n        uint256 referralBonusWithdrawn;\r\n        uint256 totalEarned;\r\n        uint256 totalWithdrawn;\r\n        bool isAwaitingTurn;\r\n        bool exists;\r\n    }\r\n\r\n    struct Level {\r\n        uint256 balance;\r\n        uint256 donationsIndex;\r\n        uint256 payoutsIndex;\r\n        uint256 totalDonated;\r\n        uint256 totalPaidOut;\r\n    }\r\n\r\n    struct Donations {\r\n        uint8 levelIndex;\r\n        address donorAddress;\r\n        uint256 donationAmount;\r\n        uint256 expectedEarning;\r\n        uint256 donationTime;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_donationToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_uncertintyGuard\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralBonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LEVEL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_BONUS_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TAX_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newAdmins\",\"type\":\"address[]\"}],\"name\":\"addAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDev\",\"type\":\"address\"}],\"name\":\"changeDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_donationIndex\",\"type\":\"uint256\"}],\"name\":\"getDonation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"levelIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"donorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"donationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedEarning\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"donationTime\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.Donations\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_levelIndex\",\"type\":\"uint8\"}],\"name\":\"getLevel\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"donationsIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutsIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDonated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPaidOut\",\"type\":\"uint256\"}],\"internalType\":\"struct IVault.Level\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_levelIndex\",\"type\":\"uint8\"}],\"name\":\"getLevelUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformDonated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformPaidOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"donationBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDownlines\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralBonusWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAwaitingTurn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelEarningAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelEntryAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oldAdmins\",\"type\":\"address[]\"}],\"name\":\"removeAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_levelIndex\",\"type\":\"uint8\"}],\"name\":\"settleAndUpgradeFrontUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_capacityValues\",\"type\":\"uint256[]\"}],\"name\":\"updateLevelCapacityAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"capacityIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_newLevelCapacityValue\",\"type\":\"uint256\"}],\"name\":\"updateLevelCapacitySingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVault\",\"type\":\"address\"}],\"name\":\"updateVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"earningValues\",\"type\":\"uint256[]\"}],\"name\":\"updatelevelEntryAmountAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"earningIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_newEarningValue\",\"type\":\"uint256\"}],\"name\":\"updatelevelEntryAmountSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Web3Pilot", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000001dcb4f7acf5733f1e3c3ba88faaef4fbb5874e6a99af4fd366fdd842626dad8d2817fff4e80a104390734cfafb6327fe89608dc7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b073901db185c112444c8a77fd6c0a42df89a08cdf397fbfe4c1519df5408837"}