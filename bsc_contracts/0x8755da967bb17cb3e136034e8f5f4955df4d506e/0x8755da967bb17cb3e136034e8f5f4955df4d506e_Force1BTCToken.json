{"SourceCode": "pragma solidity 0.5.10; \r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath mul failed');\r\n    return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, 'SafeMath sub failed');\r\n    return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath add failed');\r\n    return c;\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _user) external view returns(uint);\r\n    function levelBought_(address _user) external view returns(uint);\r\n }\r\n\r\ncontract Force1BTCToken {\r\n    \r\n\r\n    /*===============================\r\n    =         DATA STORAGE          =\r\n    ===============================*/\r\n\r\n    // Public variables of the token\r\n    using SafeMath for uint256;\r\n    string constant private _name = \"FORCE1 BTC\";\r\n    string constant private _symbol = \"F1BTC\";\r\n    uint256 constant private _decimals = 18;\r\n    uint256 private _totalSupply;         //800 million tokens\r\n\r\n    address public orbitAddress;\r\n\r\n    address public USDTAddress;\r\n\r\n    mapping(uint => uint) levelPrice;\r\n    mapping(address => uint) boughtForLevel;\r\n\r\n    address alternate;\r\n\r\n    uint256 constant public maxSupply = 80000000000000 * (10**_decimals);    //80000 million tokens\r\n    bool public safeguard;  //putting safeguard on will halt all non-owner functions\r\n\r\n    // This creates a mapping with all data storage\r\n    mapping (address => uint256) private _balanceOf;\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n    mapping (address => bool) public frozenAccount;\r\n    mapping (address => uint) public totalBought;\r\n\r\n\r\n\r\n\r\n    // This generates a public event of token transfer\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n        \r\n    // This generates a public event for frozen (blacklisting) accounts\r\n    event FrozenAccounts(address target, bool frozen);\r\n    \r\n    // This will log approval of token Transfer\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n\r\n    function name() public pure returns(string memory){\r\n        return _name;\r\n    }\r\n    \r\n\r\n    function symbol() public pure returns(string memory){\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns(uint256){\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n\r\n    function balanceOf(address user) public view returns(uint256){\r\n        return _balanceOf[user];\r\n    }\r\n    \r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowance[owner][spender];\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        \r\n        //checking conditions\r\n        require(!safeguard);\r\n        require (_to != address(0));                      // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        \r\n        // overflow and undeflow checked by SafeMath Library\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);    // Subtract from the sender\r\n        _balanceOf[_to] = _balanceOf[_to].add(_value);        // Add the same to the recipient\r\n        \r\n        // emit Transfer event\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //no need to check for input validations, as that is ruled by SafeMath\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //checking of allowance and token value is done by SafeMath\r\n        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n\r\n        _allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function increase_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decrease_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function initialize(uint initialLiquidity, uint initialTokens, address _USDTAddress, address _orbitAddress, address _alternateAddress) public returns(bool) {\r\n        require(USDTAddress == address(0), \"can't call twice\");\r\n        USDTAddress = _USDTAddress;\r\n        orbitAddress = _orbitAddress;\r\n        alternate = _alternateAddress;\r\n        uint pow = (10 ** 18);\r\n        levelPrice[1] = 12 * pow;\r\n        levelPrice[2] = 18 * pow;\r\n        levelPrice[3] = 30 * pow;\r\n        levelPrice[4] = 40 * pow;\r\n        levelPrice[5] = 70 * pow;\r\n        levelPrice[6] = 130 * pow;\r\n        levelPrice[7] = 200 * pow;\r\n        levelPrice[8] = 300 * pow;\r\n        levelPrice[9] = 500 * pow;\r\n        levelPrice[10]= 700 * pow;\r\n\r\n        tokenInterface(USDTAddress).transferFrom(msg.sender,address(this),initialLiquidity);\r\n\r\n        mintToken(msg.sender, initialTokens * 95 / 100); // 5% burnt\r\n        emit Burn(msg.sender, initialTokens * 5 / 100);\r\n        emit Transfer(msg.sender, address(0), initialTokens * 5 / 100 );\r\n    }\r\n    \r\n \r\n\r\n    function mintToken(address target, uint256 mintedAmount) internal {\r\n        require(_totalSupply.add(mintedAmount) <= maxSupply, \"Cannot Mint more than maximum supply\");\r\n        _balanceOf[target] = _balanceOf[target].add(mintedAmount);\r\n        _totalSupply = _totalSupply.add(mintedAmount);\r\n        emit Transfer(address(0), target, mintedAmount);\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n        //checking of enough token balance is done by SafeMath\r\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\r\n        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n   \r\n\r\n    function increaseLiquidity(uint _liquidity, address _caller) public returns(bool)\r\n    {\r\n        require(msg.sender == orbitAddress, \"Invalid Caller\");\r\n        uint amount = (_liquidity * 7 / 10) * ( 10 ** 18 ) / currentRate();                 // calculates the amount\r\n        mintToken(_caller, amount * 9 / 10); // 10% burnt\r\n        emit Burn(msg.sender, amount/10);\r\n        emit Transfer(msg.sender, address(0), amount/10);\r\n        return true;\r\n    }\r\n\r\n    \r\n    //current rate is with divisor 1000000000000000000 , to adjust fractional values\r\n    function currentRate() public view returns(uint)\r\n    {\r\n        uint usdtBalance = tokenInterface(USDTAddress).balanceOf(address(this));\r\n        uint curRate =  usdtBalance * (10 ** 18 ) / totalSupply();\r\n        return curRate;\r\n    }\r\n\r\n    function Current_Liquidity() public view returns(uint)\r\n    {\r\n        uint usdtBalance = tokenInterface(USDTAddress).balanceOf(address(this));       \r\n        return usdtBalance;\r\n    }\r\n\r\n    \r\n    function buyf1_BTC_Level(uint _level ) public {\r\n        require(boughtForLevel[msg.sender] + 1 == _level, \"Buy for previous level first\");\r\n        require(tokenInterface(orbitAddress).levelBought_(msg.sender) >= _level, \"orbit level mismatch\");\r\n        boughtForLevel[msg.sender] = _level;\r\n        uint _USDTTokenAmount = levelPrice[_level];\r\n        tokenInterface(USDTAddress).transferFrom(msg.sender,address(this),_USDTTokenAmount);\r\n        totalBought[msg.sender] += _USDTTokenAmount;\r\n        uint amount = _USDTTokenAmount * ( 10 ** 18 ) / currentRate();                 // calculates the amount\r\n        mintToken(msg.sender, amount * 9 / 10); // 10% burnt\r\n        emit Burn(msg.sender, amount/10);\r\n        emit Transfer(msg.sender, address(0), amount/10);\r\n    }\r\n\r\n\r\n    function sell_f1_BTC_Tokens(uint256 amount) public {\r\n        require(_balanceOf[msg.sender] >= amount, \"low balance\");\r\n        uint256 usdtAmount = amount * currentRate() /(10 ** 18);\r\n        usdtAmount = usdtAmount * 9 / 10;\r\n        require(tokenInterface(USDTAddress).balanceOf(address(this)) > usdtAmount,\"insufficient usdt available\");   // checks if the contract has enough usdt to buy\r\n        burn(amount * 95 / 100); // 95% burnt\r\n        transfer(alternate, amount * 5 / 100); // 5% to alternate\r\n        tokenInterface(USDTAddress).transfer(msg.sender,usdtAmount);\r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"initialLiquidity\",\"type\":\"uint256\"},{\"name\":\"initialTokens\",\"type\":\"uint256\"},{\"name\":\"_USDTAddress\",\"type\":\"address\"},{\"name\":\"_orbitAddress\",\"type\":\"address\"},{\"name\":\"_alternateAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyf1_BTC_Level\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decrease_allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Current_Liquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increase_allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"increaseLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeguard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell_f1_BTC_Tokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orbitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDTAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "Force1BTCToken", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://c2aa3ceae46b5890f6d6ae00e77bb6e3d4ca5afea846d539c1d0a50bf71895d2"}