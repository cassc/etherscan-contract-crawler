{"SourceCode": "{\"PayBoost.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./RocketFi.sol\\\";\\r\\n\\r\\ninterface IFloatieParkControlCenter {\\r\\n    function getRecipientAddressByRocketID(string memory _rocketID) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IDexRouter {\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IRocketPlayExtended {\\r\\n    function claimRewards(IERC20 _token, address receiver) external;\\r\\n}\\r\\n\\r\\ninterface IBurnToEarnExtended {\\r\\n    function getSharePosition(address holder) external view returns (uint256);\\r\\n}\\r\\n\\r\\n// User must approve the PayBoost contract for the desired allowance amount prior to sending.\\r\\n// User is allowed to send at all times, however there is a cool down built into the RocketPlay contract.\\r\\n\\r\\ncontract PayBoost is Auth {\\r\\n\\r\\n    RocketFi rocketFi;\\r\\n    address constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n    uint256 public holdRequirement = 50*1e15;\\r\\n    mapping(IERC20 =\\u003e uint8) public isAllowed;\\r\\n    mapping(address =\\u003e uint8) public claimRewardsOnTransfer;\\r\\n    \\r\\n    constructor(RocketFi _rocketFi) Auth(msg.sender) {\\r\\n        rocketFi = _rocketFi;\\r\\n    }\\r\\n\\r\\n    // send an approved bsc token to any smart code recipient and collect RocketFi \\r\\n    function sendTokenToSmartCode(IERC20 token, string memory recipientSmartCode, uint256 tokenAmount) public {\\r\\n        RocketFi _rocketFi = rocketFi;\\r\\n\\r\\n        address _recipient  = IFloatieParkControlCenter(address(_rocketFi.rocketForge())).getRecipientAddressByRocketID(recipientSmartCode); //grab recipient address;\\r\\n        bool    _isValid    = _recipient != address(0) \\u0026\\u0026 _recipient != msg.sender; //ensure sender != recipient or 0 address;\\r\\n        require(_isValid \\u0026\\u0026 isAllowed[token] == 1 \\u0026\\u0026 tokenAmount \\u003e 0,\\u0027invalid code or recipient\\u0027);\\r\\n        \\r\\n        if(address(_rocketFi) == address(token)) { token.transferFrom(msg.sender, _recipient, tokenAmount); }\\r\\n        else { \\r\\n            uint256 _sharePosition; //fuel position\\r\\n            try IBurnToEarnExtended(address(_rocketFi.burnToEarn())).getSharePosition(msg.sender)\\r\\n                returns (uint256 sharePosition) {_sharePosition = sharePosition;} catch {}\\r\\n            if(_rocketFi.balanceOf(msg.sender) + _sharePosition \\u003e holdRequirement) //only collects payboost if rocketfi + fuel balance \\u003e 0\\r\\n                _rocketFi.rocketPlay().playRocketPools(\\r\\n                    msg.sender,\\r\\n                    _recipient,\\r\\n                    RocketLibrary.TransferType.Transfer,\\r\\n                    getAmountsOutMin(address(token), _rocketFi, tokenAmount)); //outputs estimated RocketFi being sent\\r\\n            token.transferFrom(msg.sender, _recipient, tokenAmount);\\r\\n        }\\r\\n        if(claimRewardsOnTransfer[msg.sender]==1)\\r\\n            IRocketPlayExtended(address(_rocketFi.rocketPlay())).claimRewards(IERC20(address(_rocketFi)), msg.sender);\\r\\n    }\\r\\n\\r\\n    //returns estimated RocketFi Tokens Out amount based on the Token In/AmoutnIn\\r\\n    function getAmountsOutMin(address tokenIn, RocketFi _rocketFi, uint256 amountIn) public view returns (uint256 _rocketFiAmount) {\\r\\n        address[] memory path;\\r\\n        path    = new address[](3);\\r\\n        path[0] = tokenIn;\\r\\n        path[1] = WBNB;\\r\\n        path[2] = address(_rocketFi);\\r\\n\\r\\n        _rocketFiAmount = IDexRouter(address(_rocketFi.router())).getAmountsOut(amountIn, path)[path.length -1];\\r\\n    }\\r\\n\\r\\n    function enableToken(IERC20 token, bool value) external authorized {\\r\\n        isAllowed[token] = value ? 1 : 0;\\r\\n    }\\r\\n\\r\\n    function setClaimOnTransfer(bool value) external {\\r\\n        claimRewardsOnTransfer[msg.sender] =  value ? 1 : 0;\\r\\n    }\\r\\n\\r\\n    //contact RocketFi support if you accidentally sent a token or BNB to the PayBoost contract and need it recovered.\\r\\n    function reclaimToken(IERC20 token) external authorized {\\r\\n        token.transfer(msg.sender, token.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function transferBNB(address payable _to) external authorized {\\r\\n        (bool success,) = _to.call{value : address(this).balance}(\\\"\\\");\\r\\n        require(success, \\\"unable to transfer value\\\");\\r\\n    }\\r\\n\\r\\n    function updateHoldRequirement(uint256 _holdRequirement) external authorized {\\r\\n        holdRequirement = _holdRequirement;\\r\\n    }\\r\\n}\"},\"RocketFi.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n/*\\r\\n\u2726 \u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u3000\u3000\u3000\u02da\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\u2002\u2002\u3000\u3000. \u3000\u2008\u3000\u3000\u3000\u3000\u3000\\r\\n. \u3000\u3000\u3000\u3000\u3000\u200a\u200a\u200a\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\u3000\u3000\u3000* .\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u02da .\\r\\n \u2726 \u2726\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\uff9f\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\\r\\n \u3000\u3000\u3000\u02da \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000, .\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\uff9f\u3000\u2002\u2002\u3000\u3000\u3000.\u3000\u3000\u3000\\r\\n \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2726 \u3000\u3000\u3000\u3000\u3000\u3000,\u3000\u3000\u3000\u3000\u3000\u3000\u3000. . \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u3000\u2008\u2008\u2008\u2008\u2008\u200a\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u2008\u3000.\u3000\u3000\u3000\uff9f\u3000\u2008\u200a\u200a\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\\r\\n                                  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\\r\\n                                  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\\r\\n                                  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2550\u255d\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2551      \u3000\u3000\\r\\n                                  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2551\\r\\n                                  \u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\\r\\n                                  \u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d    \u3000\u3000\\r\\n\u3000\u3000. \u3000\u3000\u3000\u02da\u3000\u3000      \u3000\u3000. \u3000\u3000\u3000\\r\\n\\r\\n            \u2580\u2588\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2591\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\\r\\n            \u2591\u2588\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2588\u2584\u2003\u2580\u2584\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003 \u2003\u2588\u2584\u2588\u2003\u2588\u2580\u2591\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2591\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2584\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2584\u2588\\r\\n                                                      REFLECT YOUR WAY\\r\\n                                        \u2726 \u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u3000\u3000\u3000\u02da\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\\r\\n. \u3000\u3000\u3000\u3000\u3000\u200a\u200a\u200a\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\u3000\u3000\u3000* .\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u02da .\\r\\n \u2726 \u2726\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\uff9f\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\\r\\n \u3000\u3000\u3000\u02da \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000, .\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\uff9f\u3000\u2002\u2002\u3000\u3000\u3000.\u3000\u3000\u3000\uff9f\u3000\u3000\u3000\\r\\n \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2726 \u3000\u3000\u3000\u3000\u3000\u3000,\u3000\u3000\u3000\u3000\u3000\u3000\u3000. . \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u3000\u2008\u2008\u2008\u2008\u2008\u200a\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u2008\u2008\u200a\u200a\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\\r\\n*/\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\nabstract contract Auth {\\r\\n    address internal owner;\\r\\n    mapping (address =\\u003e bool) internal authorizations;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n        authorizations[_owner] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be contract owner\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!OWNER\\\"); _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Function modifier to require caller to be authorized\\r\\n     */\\r\\n    modifier authorized() {\\r\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\"); _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Authorize address. Owner only. Calls internal _authorize method\\r\\n     */\\r\\n    function authorize(address adr) external onlyOwner {\\r\\n        _authorize(adr);\\r\\n    }\\r\\n    \\r\\n    function _authorize (address adr) internal {\\r\\n        authorizations[adr] = true;\\r\\n    }\\r\\n    /**\\r\\n     * Remove address\\u0027 authorization. Owner only\\r\\n     */\\r\\n    function unauthorize(address adr) public onlyOwner {\\r\\n        authorizations[adr] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Check if address is owner\\r\\n     */\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Return address\\u0027 authorization status\\r\\n     */\\r\\n    function isAuthorized(address adr) public view returns (bool) {\\r\\n        return authorizations[adr];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\r\\n     */\\r\\n    function transferOwnership(address payable adr) public onlyOwner {\\r\\n        owner = adr;\\r\\n        authorizations[adr] = true;\\r\\n        emit OwnershipTransferred(adr);\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address owner);\\r\\n}\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function getOwner() external view returns (address);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\nlibrary RocketLibrary {\\r\\n    struct Holder {\\r\\n        address _address;\\r\\n        uint256 totalPurchased;\\r\\n        uint256 totalSold;\\r\\n        bool isMerchant;\\r\\n    }\\r\\n\\r\\n    enum TransferType {\\r\\n        Sell,\\r\\n        Buy,\\r\\n        Transfer\\r\\n    }\\r\\n\\r\\n    struct Transfer {\\r\\n        Holder holder;\\r\\n        uint256 amt;\\r\\n        TransferType transferType;\\r\\n        address from;\\r\\n        address to;\\r\\n    }\\r\\n\\r\\n    struct Burner {\\r\\n        uint256 totalBurned;\\r\\n        uint256 stakingPoints;\\r\\n        uint256 totalSold;\\r\\n        uint256 loyaltyBoost;\\r\\n        uint256 totalExcluded;\\r\\n        uint256 totalRealised;\\r\\n        uint256 totalRealisedUndeposited;\\r\\n        bool isExistingBurner;\\r\\n        bool isMigrated;\\r\\n    }\\r\\n\\r\\n    struct PlayCounter {\\r\\n        uint256 totalBurnPlays;\\r\\n        uint256 totalTransferPlays;\\r\\n        uint256 totalBuyPlays;\\r\\n    }\\r\\n\\r\\n    struct Winnings {\\r\\n        uint256 totalWonBurnBoost;\\r\\n        uint256 totalWonBuyBoost;\\r\\n        uint256 totalClaimedTransferBoost;\\r\\n        uint256 lastTimeWonBurnPool;\\r\\n        uint256 lastTimeWonBuyPool;\\r\\n        uint256 lastTimeClaimedTransferPool;\\r\\n    }\\r\\n\\r\\n    struct RocketPlayer {\\r\\n        PlayCounter playCounter;\\r\\n        Winnings winnings;\\r\\n        uint256 rocketTokens;\\r\\n    }\\r\\n}\\r\\ninterface IBurnToEarn {\\r\\n    function updateUser(address holder, uint256 burnedAmount) external; \\r\\n    function updateBurnToEarnFactors(address holder, uint256 boostID, uint256 updateAmount) external; \\r\\n    function syncDeposit(uint256 amount) external;\\r\\n}\\r\\ninterface IRocketPlay {\\r\\n    function getPoolThreshold(IERC20 token, uint poolID) external view returns (uint256, uint256);\\r\\n    function playRocketPools(address sender, address recipient, RocketLibrary.TransferType _transferType, uint256 amount) external;\\r\\n    function playBurnPools(IERC20 token, address sender, uint poolID, uint256 tokenAmount) external;\\r\\n    function updatePools(uint256 tokenAmount) external;\\r\\n    function updatePoolByID(uint256 tokenAmount, uint poolID) external;\\r\\n    function getFee(IERC20 token, uint poolID) external view returns (uint fee);\\r\\n    function validatePoolID(IERC20 token, uint poolID) external view returns (bool);\\r\\n}\\r\\ninterface IPoolDistributionGateway {\\r\\n    function depositBNB() external payable;\\r\\n    function onTransfer(RocketLibrary.Transfer memory _transfer) external;\\r\\n    function setShares(address from, address to, uint256 fromBalance, uint256 toBalance) external;\\r\\n}\\r\\ninterface IRocketForge {\\r\\n    function getDiscount(address holder) external view returns (uint256, uint256);\\r\\n}\\r\\n\\r\\ncontract RocketFi is IERC20, Auth {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    struct Interfaces {\\r\\n        bool isInterface;\\r\\n        uint256 merchantFee;\\r\\n        bool isMerchant;\\r\\n    }\\r\\n\\r\\n    struct RocketContractExclusions {\\r\\n        bool excludeRocketPlay;\\r\\n        bool excludePoolDistributionGateway;\\r\\n        bool excludeBurnToEarn;\\r\\n        bool excludeRocketForge;\\r\\n    }\\r\\n\\r\\n    struct Fees {\\r\\n        uint256 sell;\\r\\n        uint256 transfer;\\r\\n        uint256 buy;\\r\\n        uint256 burn; //Always divided by the fee.sell to calculate result\\r\\n        uint256 rocket; //Always divided by the fee.sell to calculate result\\r\\n        uint256 burn2Earn; //Always divided by the fee.sell to calculate result\\r\\n    }\\r\\n\\r\\n    // Fees\\r\\n    Fees public fee = Fees(2000,50,1000,0,375,350);   \\r\\n\\r\\n    address DEAD = 0x000000000000000000000000000000000000dEaD; \\r\\n\\r\\n    //Maintains tokens to burn seperately during swapback\\r\\n    uint256 public burnReserve; //keeps track of tokens meant to be burned\\r\\n    uint256 public burnThreshold = 10 * 1e15; //burn tokens when burn threshold is reached to save gas during transactions\\r\\n    uint256 public swapThreshold = 250 * 1e15; //swap tokens for BNB on a threshold\\r\\n    \\r\\n    //Token Pair Data\\r\\n    IDEXRouter  public router;\\r\\n    address     public pair;\\r\\n    mapping(address =\\u003e bool) liquidityPairs;\\r\\n    \\r\\n    //RocketFi Token Info\\r\\n    string  constant _name          = \\\"RocketFi\\\";\\r\\n    string  constant _symbol        = \\\"ROCKETFI\\\";\\r\\n    uint8   constant _decimals      = 9;\\r\\n    uint256 public   _totalSupply   = 1e12 * 1e9;\\r\\n    uint256 public   _maxTxAmount   = _totalSupply;\\r\\n    \\r\\n    //Shareholder Standard Mappings\\r\\n    mapping(address =\\u003e uint256)                            _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256))        _allowances;\\r\\n    mapping(address =\\u003e bool)                        public isFeeExempt;\\r\\n    mapping(address =\\u003e bool)                        public isTxLimitExempt;\\r\\n    //Shareholder Rocket Mappings\\r\\n    mapping(address =\\u003e RocketContractExclusions)    public rocketExclusions; //Manages exclusions with external RocketFi contracts\\r\\n    mapping (address =\\u003e Interfaces)                 public interfaces; //Manages Interfacing contracts/merchants allowing contracts to make basic transfer. Custom fees only applicable to merchant/non-interface addresses\\r\\n    mapping (address =\\u003e bool)                       public isRocketContract; //Manages each RocketFi contract that is authorized to interact with the burn pools function\\r\\n    mapping(address =\\u003e RocketLibrary.Holder)        public holders;\\r\\n\\r\\n    //RocketFi Interfaces\\r\\n    IPoolDistributionGateway public  poolDistributionGateway;\\r\\n    IRocketPlay              public  rocketPlay;\\r\\n    IRocketForge             public  rocketForge;\\r\\n    IBurnToEarn              public  burnToEarn;\\r\\n\\r\\n    //Other \\r\\n    uint256 public  tokensBurned; //Counter for tokens burned within the RocketFi EcoSystem\\r\\n    bool    private allowContracts; //Used to prevent other contracts from interacting with our holder accessible functions that are not RocketFi contracts. Used to prevent spamming.\\r\\n    bool    public  enableCustomPool; //Allows interfacing with other IERC20 pools in the RocketPlay contract using the Burn function\\r\\n\\r\\n    //Determines if the contract executed a swap. Used to prevent circulation issues.\\r\\n    bool inSwap;\\r\\n    modifier swapping() {\\r\\n        inSwap = true;\\r\\n        _;\\r\\n        inSwap = false;\\r\\n    }\\r\\n\\r\\n    event ErrorEvent(string reason);\\r\\n    event SetFeeExempt(address _addr, bool _exempt);\\r\\n    event SetTxLimitExempt(address _addr, bool _exempt);\\r\\n    event SetDexRouter(IDEXRouter _router);\\r\\n    event SetNewFees(uint256 _sellFee, uint256 _transferFee, uint256 _buyFee, uint256 _burnFee, uint256 _rocketFee, uint256 _burn2earnFee);\\r\\n    event SetInterface(address _interfaceAddr, bool _isInterface, uint256 _fee, bool _isMerchant);\\r\\n    event SetRocketContract(address _rocketContract, bool _enabled);\\r\\n    event SetRocketExclusions(address _addr, bool _excludeRocketPlay, bool _excludePoolDistributionGateway, bool _excludeBurnToEarn, bool _excludeRocketForge);\\r\\n    event SetSwapThreshold(uint256 _swapThreshold);\\r\\n    event SetTxLimit(uint256 _amount);\\r\\n    event SetContractInteraction(bool _allowContracts);\\r\\n    event SetContractInteraction(address _pair, bool _value);\\r\\n    event TokensBurned(address sender, uint256 amountBurned);\\r\\n\\r\\n    constructor(address _dexRouter) Auth(msg.sender) {\\r\\n\\r\\n        router  = IDEXRouter(_dexRouter);\\r\\n        pair    = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));\\r\\n        liquidityPairs[pair] = true;\\r\\n\\r\\n        isFeeExempt[msg.sender]     = true;\\r\\n        isTxLimitExempt[msg.sender] = true;\\r\\n        isTxLimitExempt[_dexRouter] = true;\\r\\n        isTxLimitExempt[pair]       = true;\\r\\n\\r\\n        _allowances[address(this)][address(router)] = _totalSupply;\\r\\n        approve(_dexRouter, _totalSupply);\\r\\n        approve(address(pair), _totalSupply);\\r\\n\\r\\n        _balances[msg.sender] = _totalSupply;\\r\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\r\\n            _allowances[sender][msg.sender] -= amount;\\r\\n        }\\r\\n        return _transferFrom(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        if (inSwap || interfaces[sender].isInterface || interfaces[recipient].isInterface)\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n\\r\\n        require(amount \\u003c= _maxTxAmount || isTxLimitExempt[sender], \\\"TX Limit Exceeded\\\");\\r\\n\\r\\n        RocketLibrary.TransferType transferType = _determineTransferType(sender, recipient);\\r\\n\\r\\n        if (_shouldSwapBack() \\u0026\\u0026 transferType != RocketLibrary.TransferType.Transfer)\\r\\n            _swapBack();\\r\\n        else if(burnReserve \\u003e= burnThreshold)\\r\\n            _burnTokens();        \\r\\n\\r\\n        //RocketPlay\\r\\n        if (address(rocketPlay) != address(0) \\u0026\\u0026 transferType != RocketLibrary.TransferType.Sell \\u0026\\u0026 !rocketExclusions[sender].excludeRocketPlay) {\\r\\n            try rocketPlay.playRocketPools(sender, recipient, transferType, amount) {}\\r\\n            catch Error (string memory reason) {\\r\\n                emit ErrorEvent(\\\"_transferFrom(): rocketPlay.playRocketPools() Failed\\\");\\r\\n                emit ErrorEvent(reason);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        uint amountAfterFee = _getDiscountAndTakeFee(sender, recipient, amount, transferType);\\r\\n\\r\\n        _setMyRocket(sender, recipient);\\r\\n        \\r\\n        uint256 sold;\\r\\n        if(transferType == RocketLibrary.TransferType.Sell)\\r\\n                sold = amountAfterFee;\\r\\n\\r\\n        if(address(burnToEarn) != address(0) \\u0026\\u0026 !rocketExclusions[msg.sender].excludeBurnToEarn \\u0026\\u0026 sold \\u003e 0)\\r\\n                _updateBurnToEarnFactors(sender, 0, sold);\\r\\n\\r\\n        if (address(poolDistributionGateway) != address(0)) { \\r\\n            uint256 purchased;\\r\\n            if(transferType == RocketLibrary.TransferType.Buy)\\r\\n                purchased = amountAfterFee;\\r\\n\\r\\n            RocketLibrary.Holder memory holder = _updateHolder(address(sender), purchased, sold, interfaces[sender].isMerchant); //creates \\u0026 updates holder data. Cumulative information\\r\\n            RocketLibrary.Transfer memory transf = _buildTransfer(holder, amount, transferType, sender, recipient); //creates a transfer for sending to the distribution gateway\\r\\n\\r\\n            try poolDistributionGateway.onTransfer(transf) {} //store transfer data externally to be used across RocketFi EcoSystem\\r\\n            catch Error (string memory reason) {\\r\\n                emit ErrorEvent(\\u0027_transferFrom(): poolDistributionGateway.onTransfer() Failed\\u0027);\\r\\n                emit ErrorEvent(reason);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Transfer(sender, recipient, amountAfterFee);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _internalApprove(address spender, uint256 amount) internal returns (bool) {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _getDiscountAndTakeFee(address sender, address recipient, uint256 amount, RocketLibrary.TransferType transferType) internal returns (uint256) {\\r\\n        //Grab holder discount information from the RocketForge\\r\\n        uint256 buyDiscount;\\r\\n        uint256 sellDiscount; \\r\\n        if (address(rocketForge) != address(0)) {\\r\\n            if(transferType == RocketLibrary.TransferType.Sell \\u0026\\u0026 !rocketExclusions[sender].excludeRocketForge) \\r\\n                (buyDiscount, sellDiscount) = getDiscount(sender);\\r\\n            if(transferType == RocketLibrary.TransferType.Buy \\u0026\\u0026 !rocketExclusions[recipient].excludeRocketForge)\\r\\n                (buyDiscount, sellDiscount) = getDiscount(recipient);\\r\\n        }\\r\\n\\r\\n        //Calculates and takes applicable fees;\\r\\n        uint amountAfterFee = isFeeExempt[sender] ? amount : _takeFee(sender, recipient, amount, transferType, buyDiscount, sellDiscount);\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amountAfterFee;\\r\\n        return amountAfterFee;\\r\\n    }\\r\\n\\r\\n    //execute any time shareholder balances change to maintain mirrored balance values for external reward distributions\\r\\n    function _setMyRocket(address sender, address recipient) internal {\\r\\n        if (address(poolDistributionGateway) != address(0)) {\\r\\n            uint256 balancesSender = _balances[sender];\\r\\n            uint256 balancesRecipient = _balances[recipient];\\r\\n\\r\\n            try poolDistributionGateway.setShares(sender, recipient, balancesSender, balancesRecipient) {} \\r\\n            catch Error (string memory reason) {\\r\\n                emit ErrorEvent(\\\"_transferFrom(): poolDistributionGateway.setShares() Failed\\\");\\r\\n                emit ErrorEvent(reason);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateHolder(address sender, uint256 purchased, uint256 sold, bool isMerchant) internal returns (RocketLibrary.Holder memory) {\\r\\n        \\r\\n        uint256 _totalPurchased   = holders[sender].totalPurchased + purchased;\\r\\n        uint256 _totalSold        = holders[sender].totalSold + sold;\\r\\n        \\r\\n        RocketLibrary.Holder memory holder = RocketLibrary.Holder(sender, _totalPurchased, _totalSold, isMerchant);\\r\\n\\r\\n        holders[sender] = holder;\\r\\n\\r\\n        return holder;\\r\\n    }\\r\\n\\r\\n    //determines if the transfer is a buy/sell/transfer\\r\\n    function _determineTransferType(address _from, address _recipient) internal view returns (RocketLibrary.TransferType) {\\r\\n        if (liquidityPairs[_recipient]) {\\r\\n            return RocketLibrary.TransferType.Sell;\\r\\n        } else if (liquidityPairs[_from]) {\\r\\n            return RocketLibrary.TransferType.Buy;\\r\\n        }\\r\\n        return RocketLibrary.TransferType.Transfer;\\r\\n    }\\r\\n\\r\\n    //creates the transfer type\\r\\n    function _buildTransfer(RocketLibrary.Holder memory _holder, uint256 _amt, RocketLibrary.TransferType _transferType, address _from, address _to) internal pure returns (RocketLibrary.Transfer memory) {\\r\\n        RocketLibrary.Transfer memory _transfer = RocketLibrary.Transfer(_holder, _amt, _transferType, _from, _to);\\r\\n        return _transfer;\\r\\n    }\\r\\n\\r\\n    //handles interface/swap transfers without any other mechanisms. \\r\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        _balances[sender] -= amount;\\r\\n        _balances[recipient] += amount;\\r\\n        if(!inSwap) _setMyRocket(sender, recipient); //ensures holder\\u0027s shares are updated in the pool distribution gateway,  dex pairs/contracts are exempt at pool distribution gateway. \\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _takeFee(address _sender, address _receiver, uint256 _amount, RocketLibrary.TransferType _transferType, uint256 _buyDiscount, uint256 _sellDiscount) internal returns (uint256) {\\r\\n        // Takes the fee and keeps remainder in contract + burnToEarn contract\\r\\n        uint256 feeAmount = interfaces[_receiver].isMerchant\\r\\n            ? _amount.mul(interfaces[_receiver].merchantFee).div(10000)\\r\\n            : _amount.mul(getTotalFee(_transferType, _buyDiscount, _sellDiscount)).div(10000);\\r\\n\\r\\n        if (feeAmount \\u003e 0) {\\r\\n            //fund external contracts if fees \\u0026 hooked contracts are present\\r\\n            (uint256 rocketPlayAlloc, uint256 burn2earnAlloc) = _fundHookedContracts(_sender, feeAmount);\\r\\n            \\r\\n            uint256 finalFee = feeAmount.sub(burn2earnAlloc).sub(rocketPlayAlloc); //removes the Burn-to-Earn/RocketPlay contract allocation when Burn-to-Earn/RocketPlay is active\\r\\n\\r\\n            burnReserve += finalFee.mul(fee.burn).div(fee.sell);//update balance for tokens to be burned in batches to save gas\\r\\n            \\r\\n            _balances[address(this)] += finalFee;\\r\\n            emit Transfer(_sender, address(this), finalFee);\\r\\n        }\\r\\n        return (_amount - feeAmount);\\r\\n    }\\r\\n\\r\\n    function _fundHookedContracts(address _sender, uint256 feeAmount) internal returns (uint256, uint256) {\\r\\n\\r\\n        uint256 burn2earnAlloc; //Allocation to send to the Burn 2 Earn Contract for Rewards\\r\\n        uint256 rocketPlayAlloc; //Allocation reserved for RocketPlay Contract\\r\\n\\r\\n        if(address(rocketPlay) != address(0) \\u0026\\u0026 fee.rocket \\u003e 0) {\\r\\n                rocketPlayAlloc = feeAmount.mul(fee.rocket).div(fee.sell);\\r\\n                _balances[address(rocketPlay)] += rocketPlayAlloc;\\r\\n                try rocketPlay.updatePools(rocketPlayAlloc) {} catch {}\\r\\n                emit Transfer(_sender, address(rocketPlay), rocketPlayAlloc);\\r\\n        }\\r\\n            \\r\\n        if(address(burnToEarn) != address(0) \\u0026\\u0026 fee.burn2Earn \\u003e 0) {\\r\\n                burn2earnAlloc = feeAmount.mul(fee.burn2Earn).div(fee.sell);\\r\\n                _balances[address(burnToEarn)] += burn2earnAlloc;\\r\\n                try burnToEarn.syncDeposit(burn2earnAlloc) {} catch {}\\r\\n                emit Transfer(_sender, address(burnToEarn), burn2earnAlloc);\\r\\n        }\\r\\n        return (rocketPlayAlloc, burn2earnAlloc);\\r\\n    }\\r\\n\\r\\n    function _shouldSwapBack() internal view returns (bool) {\\r\\n        return ((msg.sender != pair) \\u0026\\u0026 (!inSwap) \\u0026\\u0026 (_balances[address(this)].sub(burnReserve) \\u003e= swapThreshold));\\r\\n    }\\r\\n\\r\\n    function _swapBack() internal swapping {\\r\\n        uint256 amountToSwap = swapThreshold;\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amountToSwap,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 amountBNB = address(this).balance;\\r\\n\\r\\n        if(address(poolDistributionGateway) != address(0)) {\\r\\n            try poolDistributionGateway.depositBNB{value : amountBNB}() {\\r\\n\\r\\n            } catch Error(string memory reason) {\\r\\n                emit ErrorEvent(\\\"_swapBack(): poolDistributionGateway.depositBNB() Failed\\\");\\r\\n                emit ErrorEvent(reason);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _playBurnPools(IERC20 token, address holder, uint poolID, uint256 tokenAmount) internal {\\r\\n        bool success;\\r\\n        try rocketPlay.validatePoolID(token, poolID) returns (bool _success) {\\r\\n            success = _success;\\r\\n        }\\r\\n        catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027_playBurnPools(): rocketPlay.validatePoolID() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n        }\\r\\n        \\r\\n        if(success)\\r\\n        try rocketPlay.playBurnPools(token, holder, poolID, tokenAmount) {} \\r\\n        catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027_playBurnPools(): rocketPlay.playBurnPools() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateBurnToEarnUser(address _holder, uint256 _amountBurned) internal {\\r\\n        try burnToEarn.updateUser(_holder, _amountBurned) {}\\r\\n        catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027_updateBurnToEarnUser(): burnToEarn.updateUser() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateBurnToEarnFactors(address _holder, uint256 boostID, uint256 amountToUpdate) internal {\\r\\n        try burnToEarn.updateBurnToEarnFactors(_holder, boostID, amountToUpdate) {}\\r\\n        catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027_updateBurnToEarnFactors(): burnToEarn.updateBurnToEarnFactors() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _burnAndUpdateSupply(uint256 tokenAmount, uint256 feeAmount) internal {\\r\\n        uint256 amountToBurn = tokenAmount.sub(feeAmount); //subtract fee allocation from total to determine amount to burn\\r\\n        uint256 _total_supply = _totalSupply; //gas savings\\r\\n        _totalSupply = _total_supply.sub(amountToBurn, \\u0027supply cannot be neg\\u0027);\\r\\n        _balances[msg.sender] -= tokenAmount; //requires in place in top call will not revert -=\\r\\n\\r\\n        _setMyRocket(msg.sender, DEAD); //Dead wallet is exempt inside poolDistributionGateway\\r\\n\\r\\n        tokensBurned += amountToBurn;\\r\\n\\r\\n        if(address(burnToEarn) != address(0) \\u0026\\u0026 !rocketExclusions[msg.sender].excludeBurnToEarn)\\r\\n            _updateBurnToEarnUser(msg.sender, amountToBurn);\\r\\n       \\r\\n        _internalApprove(address(router), _total_supply);\\r\\n        _internalApprove(address(pair), _total_supply);\\r\\n        emit Transfer(msg.sender, address(0), amountToBurn);\\r\\n        emit TokensBurned(msg.sender, amountToBurn);\\r\\n    }\\r\\n\\r\\n    function _takeBurnFee(IERC20 token, uint256 tokenAmount, uint poolID) internal returns (uint256) {\\r\\n        address _burnToEarn = address(burnToEarn);\\r\\n        uint rocketPlayFees =  _getRocketFee(token, poolID);   // Grabs current fees from the RocketPlay contract\\r\\n        uint256 alloc = tokenAmount.mul(rocketPlayFees).div(10000); // Take sell fee alloc and send back to RocketPlay Contract + Other Taxes\\r\\n        _balances[_burnToEarn] += alloc;\\r\\n        try burnToEarn.syncDeposit(alloc) {} catch {}\\r\\n        emit Transfer(msg.sender, _burnToEarn, alloc);\\r\\n        return alloc;\\r\\n    }\\r\\n\\r\\n    function _burnTokens() internal {\\r\\n        address _rocketFiAddr = address(this);\\r\\n        uint256 _burnReserve = burnReserve;\\r\\n        uint256 _new_supply = _totalSupply.sub(_burnReserve, \\u0027supply cannot be neg\\u0027);\\r\\n        _totalSupply = _new_supply;\\r\\n        _balances[_rocketFiAddr] = _balances[_rocketFiAddr].sub(_burnReserve);\\r\\n        tokensBurned += _burnReserve;\\r\\n        burnReserve = 0;\\r\\n        _allowances[_rocketFiAddr][address(router)] = _new_supply;\\r\\n        _allowances[_rocketFiAddr][address(pair)] = _new_supply;\\r\\n    }\\r\\n\\r\\n    function _burnTokens(IERC20 token, uint poolID, uint256 tokenAmount, bool justBurn) internal {\\r\\n        require(tokenAmount \\u003e 0, \\u00270 tokens not allowed\\u0027);\\r\\n        uint256 feeAmount; //allocation used for fees, default 0\\r\\n        uint256 _holderBalance = _balances[msg.sender];\\r\\n\\r\\n        if(address(rocketPlay) != address(0) \\u0026\\u0026 !rocketExclusions[msg.sender].excludeRocketPlay \\u0026\\u0026 !justBurn) {\\r\\n            \\r\\n            uint256 holdAmount;\\r\\n            if(allowContracts) // Ensures that external unauthorized contracts are unable to interact with the function. Use to mitigate bot spamming. Only allow rocket contracts\\r\\n                require(!address(msg.sender).isContract() || isRocketContract[msg.sender],\\u0027no external contracts allowed\\u0027); \\r\\n\\r\\n            (tokenAmount, holdAmount) = _getPoolThreshold(token, poolID);   // Gather poolID thresholds for engaging with the Rocket Play platform\\r\\n\\r\\n            require(_holderBalance \\u003e= tokenAmount, \\u0027not enough tokens\\u0027); // Ensures balances are checked; as tokenAmount of 1 is overridden. RocketPlay returns the number of tokens required to engage\\r\\n            require(_holderBalance \\u003e= holdAmount, \\u0027does not hodl enough\\u0027);\\r\\n            \\r\\n            _playBurnPools(token, msg.sender, poolID, tokenAmount);\\r\\n\\r\\n            feeAmount = _takeBurnFee(token, tokenAmount, poolID);\\r\\n        }\\r\\n        else\\r\\n            require(_holderBalance \\u003e= tokenAmount, \\u0027does not hodl enough\\u0027);\\r\\n\\r\\n        _burnAndUpdateSupply(tokenAmount, feeAmount);\\r\\n        \\r\\n    }    \\r\\n\\r\\n    function _takeExternalFee(uint256 feeAmount) internal returns (bool) {\\r\\n        // Takes the fee and keeps remainder in contract + burnToEarn contract\\r\\n        if (feeAmount \\u003e 0) {\\r\\n            \\r\\n            //fund external contracts if fees \\u0026 hooked contracts are present\\r\\n            (uint256 rocketPlayAlloc, uint256 burn2earnAlloc) = _fundHookedContracts(msg.sender, feeAmount);\\r\\n            \\r\\n            uint256 finalFee = feeAmount.sub(burn2earnAlloc).sub(rocketPlayAlloc); //removes the Burn-to-Earn/RocketPlay contract allocation when Burn-to-Earn/RocketPlay is active\\r\\n\\r\\n            //update balance for tokens to be burned in batches to save gas on burn function execution\\r\\n            burnReserve += finalFee.mul(fee.burn).div(fee.sell);\\r\\n\\r\\n            _balances[address(this)] += finalFee;\\r\\n            emit Transfer(msg.sender, address(this), finalFee);\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    function _getRocketFee(IERC20 token, uint poolID) internal returns (uint rocketPlayFee) {\\r\\n        try rocketPlay.getFee(token, poolID) returns (uint _rocketPlayFee) {\\r\\n            rocketPlayFee = _rocketPlayFee;\\r\\n        } \\r\\n        catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027_getRocketFee(): rocketPlay.getFee() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n        }\\r\\n        return rocketPlayFee;\\r\\n    }\\r\\n\\r\\n    function _getPoolThreshold(IERC20 token, uint poolID) internal returns (uint256 poolThreshold, uint256 holdAmount) {\\r\\n        try rocketPlay.getPoolThreshold(token, poolID) returns (uint256 _poolThreshold, uint256 _holdAmount){\\r\\n            poolThreshold=_poolThreshold;\\r\\n            holdAmount = _holdAmount;\\r\\n        } \\r\\n        catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027_getPoolThreshold(): rocketPlay.getPoolThreshold() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n        }\\r\\n        return (poolThreshold, holdAmount);\\r\\n    }\\r\\n\\r\\n    // public getters\\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return (_totalSupply - balanceOf(DEAD) - balanceOf(address(0)));\\r\\n    }\\r\\n    \\r\\n    function getLiquidityBacking(uint256 _accuracy) public view returns (uint256) {\\r\\n        return _accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply()); //reserved for external use later\\r\\n    }\\r\\n\\r\\n    function isOverLiquified(uint256 _target, uint256 _accuracy) public view returns (bool) {\\r\\n        return (getLiquidityBacking(_accuracy) \\u003e _target);\\r\\n    }\\r\\n\\r\\n    //grabs total fee based on transfer type\\r\\n    function getTotalFee(RocketLibrary.TransferType _transferType, uint256 _buyDiscount, uint256 _sellDiscount) public view returns (uint256) {\\r\\n        if (_transferType == RocketLibrary.TransferType.Sell) {\\r\\n            uint256 _sellFee = _sellDiscount \\u003e 0 ? fee.sell.sub(fee.sell.mul(_sellDiscount).div(10000)) : fee.sell;\\r\\n            return _sellFee;\\r\\n        }\\r\\n        if (_transferType == RocketLibrary.TransferType.Transfer) {\\r\\n            return fee.transfer;\\r\\n        }\\r\\n        else {\\r\\n            uint256 _buyFee = _buyDiscount \\u003e 0 ? fee.buy.sub(fee.buy.mul(_buyDiscount).div(10000)) : fee.buy;\\r\\n            return _buyFee;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //grabs holder discount if applicable from Rocket Forge/Referrals contract\\r\\n    function getDiscount(address _addr) public returns (uint256 buyDiscount, uint256 sellDiscount) {\\r\\n\\r\\n        try rocketForge.getDiscount(_addr) returns (uint256 _buyDiscount, uint256 _sellDiscount){\\r\\n            buyDiscount = _buyDiscount;\\r\\n            sellDiscount = _sellDiscount;\\r\\n\\r\\n        } catch Error (string memory reason){\\r\\n            emit ErrorEvent(\\u0027getDiscount(): rocketForge.getDiscount() Failed\\u0027);\\r\\n            emit ErrorEvent(reason);\\r\\n\\r\\n            buyDiscount = 0;\\r\\n            sellDiscount = 0;\\r\\n        }\\r\\n        return (buyDiscount, sellDiscount);\\r\\n    }\\r\\n\\r\\n    // authorized setters\\r\\n    function setNewFees(uint256 _sellFee, uint256 _transferFee, uint256 _buyFee, uint256 _burnFee, uint256 _rocketFee, uint256 _burn2earnFee) external authorized {\\r\\n        require(_sellFee \\u003c= 10000\\r\\n        \\u0026\\u0026 _transferFee \\u003c= 10000\\r\\n        \\u0026\\u0026 _buyFee \\u003c= 10000\\r\\n        \\u0026\\u0026 _burnFee + _rocketFee + _burn2earnFee \\u003c= _sellFee, \\\"New fees should be less than entire sell fee\\\");\\r\\n        \\r\\n        fee.sell = _sellFee;\\r\\n        fee.transfer = _transferFee;\\r\\n        fee.buy = _buyFee;\\r\\n        fee.burn = _burnFee;\\r\\n        fee.rocket = _rocketFee;\\r\\n        fee.burn2Earn = _burn2earnFee;\\r\\n\\r\\n        if(_burnFee == 0)\\r\\n            burnReserve = 0;\\r\\n        emit SetNewFees( _sellFee,  _transferFee, _buyFee, _burnFee, _rocketFee, _burn2earnFee);\\r\\n    }\\r\\n\\r\\n    //update DEX router\\r\\n    function setDexRouter(IDEXRouter _router) external authorized {\\r\\n        router = _router;\\r\\n        emit SetDexRouter(_router);\\r\\n    }\\r\\n\\r\\n    function setTxLimit(uint256 _amount) external authorized {\\r\\n        _maxTxAmount = _amount;\\r\\n        emit SetTxLimit(_amount);\\r\\n    }\\r\\n    //allows authorized external contracts to interact with the burn pool\\r\\n    function setContractInteraction(bool _allowContracts) external authorized {\\r\\n        allowContracts = _allowContracts;\\r\\n        emit SetContractInteraction( _allowContracts);\\r\\n    }\\r\\n\\r\\n    function setIsFeeExempt(address _addr, bool _exempt) external authorized {\\r\\n        isFeeExempt[_addr] = _exempt;\\r\\n        emit SetFeeExempt(_addr, _exempt);\\r\\n    }\\r\\n\\r\\n    function setIsTxLimitExempt(address _addr, bool _exempt) external authorized {\\r\\n        isTxLimitExempt[_addr] = _exempt;\\r\\n        emit SetTxLimitExempt(_addr, _exempt);\\r\\n    }\\r\\n\\r\\n    function setLiquidityPair(address _pair, bool _value) external authorized {\\r\\n        liquidityPairs[_pair] = _value;\\r\\n        emit SetContractInteraction(_pair,_value);\\r\\n    }\\r\\n    //threshold of RocketFi to collect before burning from supply\\r\\n    function setBurnThreshold(uint256 _burnThreshold) external authorized {\\r\\n        burnThreshold = _burnThreshold;\\r\\n    }\\r\\n    //threshold to determine how much RocketFi needs to be in the contract to liquidate for rewards\\r\\n    function setSwapThreshold(uint256 _swapThreshold) external authorized {\\r\\n        swapThreshold = _swapThreshold;\\r\\n        emit SetSwapThreshold(_swapThreshold);\\r\\n    }\\r\\n    //exempts address from external ecosystem contracts as needed\\r\\n    function setRocketExclusions(address _addr, bool _excludeRocketPlay, bool _excludePoolDistributionGateway, bool _excludeBurnToEarn, bool _excludeRocketForge) external authorized {\\r\\n        rocketExclusions[_addr].excludeRocketPlay = _excludeRocketPlay;\\r\\n        rocketExclusions[_addr].excludePoolDistributionGateway = _excludePoolDistributionGateway;\\r\\n        rocketExclusions[_addr].excludeBurnToEarn = _excludeBurnToEarn;\\r\\n        rocketExclusions[_addr].excludeRocketForge = _excludeRocketForge;\\r\\n        emit SetRocketExclusions( _addr,  _excludeRocketPlay,  _excludePoolDistributionGateway,  _excludeBurnToEarn, _excludeRocketForge);\\r\\n    }\\r\\n    //allows basic transfers of tokens without any of the hooks, with the exception of the pool distribution gateway only when present\\r\\n    function setInterface(address _interfaceAddr, bool _isInterface, uint256 _fee, bool _isMerchant) external authorized {\\r\\n        interfaces[_interfaceAddr].isInterface = _isInterface;\\r\\n        interfaces[_interfaceAddr].merchantFee = _fee;\\r\\n        interfaces[_interfaceAddr].isMerchant  = _isMerchant;\\r\\n        emit SetInterface(_interfaceAddr, _isInterface, _fee, _isMerchant);\\r\\n    }\\r\\n    //set interfacing contract addresses, allows future modularity and upgradeability \\r\\n    function setContractInterfaces(IPoolDistributionGateway _poolManager, IRocketPlay _rocketPlay, IRocketForge _rocketForge, IBurnToEarn _burnToEarn) external authorized {\\r\\n        \\r\\n        //Set Authorizations after setting Rocket Contract Interfaces;\\r\\n        poolDistributionGateway = _poolManager;\\r\\n        rocketPlay              = _rocketPlay;\\r\\n        rocketForge             = _rocketForge;\\r\\n        burnToEarn              = _burnToEarn;\\r\\n\\r\\n        if(address(poolDistributionGateway)!=address(0))\\r\\n            isRocketContract[address(poolDistributionGateway)] = true;\\r\\n        if(address(rocketPlay)!=address(0))\\r\\n            isRocketContract[address(rocketPlay)] = true;\\r\\n        if(address(rocketForge)!=address(0))\\r\\n            isRocketContract[address(rocketForge)] = true;\\r\\n        if(address(burnToEarn)!=address(0))\\r\\n            isRocketContract[address(burnToEarn)] = true;\\r\\n    }\\r\\n    //Allows authorized RocketFi eco system contracts access to the _burnTokens function \\r\\n    function setRocketContract(address _rocketContract, bool _enabled) external authorized {\\r\\n        isRocketContract[_rocketContract] = _enabled;\\r\\n        emit SetRocketContract( _rocketContract, _enabled);\\r\\n    }\\r\\n    //Allow additional pools to be rolled for/engaged during burning\\r\\n    function setCustomPool(bool _enableCustomPool) external authorized {\\r\\n        enableCustomPool = _enableCustomPool;\\r\\n    }\\r\\n    //Allows external Rocket contract/external source contribute directly to contract fees\\r\\n    function takeFee(uint256 feeAmount) external returns (bool) {\\r\\n        uint256 holderAmount = _balances[msg.sender];\\r\\n        require(holderAmount \\u003e= feeAmount, \\u0027does not hold enough\\u0027);\\r\\n        _balances[msg.sender] -= feeAmount;\\r\\n        return _takeExternalFee(feeAmount);\\r\\n    }\\r\\n    //function to manually kick off swapback\\r\\n    function manualSwapBack() external {\\r\\n        if(_shouldSwapBack())\\r\\n            _swapBack();\\r\\n    }\\r\\n    //Manually deposit tokens to the specified rocket pool\\r\\n    function depositTokenToRocketPools(uint256[3] memory boostAmounts) external {\\r\\n        address rocketPlayAddr = address(rocketPlay);\\r\\n        require(rocketPlayAddr != address(0),\\u0027not activated\\u0027);\\r\\n        uint256 _totalTokens = boostAmounts[0] + boostAmounts[1] + boostAmounts[2];\\r\\n        require(_balances[msg.sender] \\u003e= _totalTokens,\\u0027not enough tokens\\u0027);\\r\\n        \\r\\n        uint256 _finalBalance;\\r\\n        //boostAmounts[0] is BurnBoost;\\r\\n        //boostAmounts[1] is BuyBoost;\\r\\n        //boostAmounts[2] is TransferBoost;\\r\\n\\r\\n        for(uint x=0; x \\u003c boostAmounts.length; x++) {\\r\\n            if(boostAmounts[x] \\u003e 0)\\r\\n                try rocketPlay.updatePoolByID(x, boostAmounts[x]) {\\r\\n                _finalBalance += boostAmounts[x];\\r\\n                } catch {}\\r\\n        }\\r\\n\\r\\n        //only update balances \\u0026 kick off rewarding rocketfuel points (pool id 2 in Burn To Earn if _finalBalance \\u003e 0\\r\\n        if(_finalBalance \\u003e 0){\\r\\n            if(address(burnToEarn) != address(0) \\u0026\\u0026 !rocketExclusions[msg.sender].excludeBurnToEarn)\\r\\n                    _updateBurnToEarnFactors(msg.sender, 2, _finalBalance);\\r\\n            _balances[rocketPlayAddr] += _finalBalance;\\r\\n            _balances[msg.sender] -= _finalBalance;\\r\\n            _setMyRocket(msg.sender, rocketPlayAddr); //rocketPlayAddr is exempt from the Pool Distribution Participation\\r\\n        }\\r\\n    }\\r\\n    //Public \\u0026 External Interactive Functions\\r\\n    //Burn Functions\\r\\n    function burnTokenOnly(uint256 tokenAmount) external {\\r\\n        _burnTokens(IERC20(this), 0, tokenAmount, true);\\r\\n    }\\r\\n    function burnForDefaultPool(uint poolID) external {\\r\\n        _burnTokens(IERC20(this), poolID, 1, false);\\r\\n    }\\r\\n    function burnForCustomPool(address token, uint poolID) external {\\r\\n        require(enableCustomPool,\\u0027feature not enabled\\u0027);\\r\\n        _burnTokens(IERC20(token), poolID, 1, false);\\r\\n    }\\r\\n    function transferBNB(address payable _to) external authorized {\\r\\n        (bool success,) = _to.call{value : address(this).balance}(\\\"\\\");\\r\\n        require(success, \\\"unable to transfer value\\\");\\r\\n    }\\r\\n\\r\\n    //Interface functions\\r\\n    receive() external payable {}\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n    function name() public pure returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n    function getOwner() public view override returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function allowance(address holder, address spender) external view override returns (uint256) {\\r\\n        return _allowances[holder][spender];\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function approveMax(address spender) external returns (bool) {\\r\\n        return approve(spender, _totalSupply);\\r\\n    }\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        return _transferFrom(msg.sender, recipient, amount);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract RocketFi\",\"name\":\"_rocketFi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimRewardsOnTransfer\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"enableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract RocketFi\",\"name\":\"_rocketFi\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountsOutMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_rocketFiAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"recipientSmartCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sendTokenToSmartCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setClaimOnTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_holdRequirement\",\"type\":\"uint256\"}],\"name\":\"updateHoldRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PayBoost", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "0000000000000000000000006e61579c22f9a6da63a33e819f29b6697d2a126e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://21a9bfa8776856f1c66ac46cf0ab563131b363b4c2a7ff352ddc4bca1742e474"}