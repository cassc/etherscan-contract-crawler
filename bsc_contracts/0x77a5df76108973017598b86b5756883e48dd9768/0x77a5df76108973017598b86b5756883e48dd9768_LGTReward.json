{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function name() external view returns (string memory);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"LGTReward.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\nlibrary Math {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n}\\n\\ncontract LGTReward is Ownable {\\n    IERC20 private constant c_erc20stake = IERC20(0xb0fd95723534aF7a08021813bc9f792a083947B2);\\n    address private constant addr1 = 0xeA98E36494351Fef7e14A584DDB129AAA6Fafc85;\\n    address private constant addr2 = 0xbF51afb312334E1A8f596B245758E73b45908Aa9;\\n    address private constant addr3 = 0x0e16c839295585d5782d70ca68db75c33eAcf2f9;\\n    address private constant addr4 = 0xf0AA562B1d74FD2a1D182c26feF695787EC336BD;\\n    uint256 public minStake = 10*10**18;\\n    uint256 public maxStake = 1000*10**18;\\n    bool public canRegisterWithoutStake = false;\\n    uint256 public maxStakeTimes = 100;\\n    uint256 public rankTime = 1701687600;\\n    uint256 private constant duration = 1 days;\\n    uint256 public V1 = 10000*10**18;\\n    uint256 public V2 = 50000*10**18;\\n    uint256 public V3 = 100000*10**18;\\n    uint256 public caseAmount = 1;\\n    struct StakeInfo {\\n        uint64  stakeTime;\\n        uint64  count;\\n        uint128 stakeAmount;\\n    }\\n    struct User {\\n        uint256 id;\\n        address upline;\\n        uint256 directReward;\\n        uint256 refReward;\\n        uint256 compensationReward;\\n        uint256 rankDirectReward;\\n        uint256 rankBigReward;\\n        uint256 rankTime;\\n        uint256 rankDirectAmount;\\n        uint256 idxIsOut;\\n        StakeInfo[] stakeInfos;\\n        uint256 totalStake;\\n        uint256 outStake;\\n        uint256 totalPayout;\\n        uint256 downlineAmount;\\n        address[] directs;\\n        address maxDirectAddr;\\n        uint256 levelAmount;\\n        uint256 level;\\n        uint256 lastAmount;\\n    }\\n    mapping(address =\\u003e User) private users; \\n    mapping(uint256 =\\u003e address) public id2Address;\\n    uint256 public nextUserId = 2;\\n    uint256 private curBig;\\n    uint256 private nextBig;\\n    uint256 private curRankPool;\\n    uint256 private nextRankPool;\\n    struct RankInfo {\\n        address top;\\n        uint256 amount;\\n    }\\n    RankInfo[] public rankInfos;\\n    RankInfo[] public bigRankInfos;\\n    struct RecordRankInfo {\\n        address top;\\n        uint256 amount;\\n        uint256 reward;\\n    }\\n    RecordRankInfo[] private recordRankInfos;\\n    RecordRankInfo[] private recordBigRankInfos;\\n    address[] private compensationPool;\\n    uint256 private constant fixedCompensationArrayLength = 100;\\n    uint256 private compensationPoolIdx;\\n    uint256 private compensationAmount;\\n    uint256 private compensationTime;\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public nodePerDividend;\\n    mapping(uint256 =\\u003e uint256) public perDividend;\\n    mapping(uint256 =\\u003e uint256) public nodeNum;\\n\\n    constructor(address firstAddr) {\\n        for(uint256 i; i\\u003c3; i++) {\\n            rankInfos.push(RankInfo(address(0), 0));\\n            recordRankInfos.push(RecordRankInfo(address(0), 0, 0));\\n        }\\n        for(uint256 i; i\\u003c10; i++) {\\n            bigRankInfos.push(RankInfo(address(0), 0));\\n            recordBigRankInfos.push(RecordRankInfo(address(0), 0, 0));\\n        }\\n        compensationTime = block.timestamp;\\n        users[firstAddr].id = 1;\\n        users[firstAddr].upline = address(0);\\n        id2Address[1] = firstAddr;\\n    }\\n\\n    function validAmount(uint256 amount, uint256 lastAmount) public view returns(bool) {\\n        uint256 c = caseAmount;\\n        if(c == 1) {\\n            return amount \\u003e= lastAmount;\\n        }else if (c == 0) {\\n            return true;\\n        }\\n        return amount \\u003e lastAmount;\\n    }\\n\\n    function stake(address referrer, uint256 amount) external {\\n        require (amount \\u003e= minStake \\u0026\\u0026 amount \\u003c= maxStake \\u0026\\u0026 validAmount(amount, users[msg.sender].lastAmount), \\\"a\\\");\\n        register(referrer);\\n        c_erc20stake.transferFrom(msg.sender, address(this), amount);\\n        users[msg.sender].stakeInfos.push( StakeInfo(uint64(block.timestamp), uint64(0), uint128(amount)) );\\n        users[msg.sender].totalStake += amount;\\n        users[msg.sender].lastAmount = amount;\\n        require(users[msg.sender].stakeInfos.length \\u003c users[msg.sender].idxIsOut + maxStakeTimes, \\\"t\\\");\\n        pp();\\n        uint256 o = amount/100;\\n        address up = users[msg.sender].upline;\\n        users[up].directReward += 3*o;\\n        curRankPool += o;\\n        nextRankPool += o;\\n        _prk(up, amount);\\n        curBig += o/2;\\n        nextBig += o/2;\\n        _iba(msg.sender, amount);\\n        _acp(msg.sender, amount);\\n        _d(amount);\\n        _cg(msg.sender, amount);\\n        c_erc20stake.transfer(addr1, 3*o);\\n        c_erc20stake.transfer(addr2, 3*o/2);\\n        c_erc20stake.transfer(addr3, 3*o/2);\\n        c_erc20stake.transfer(addr4, 4*o);\\n    }\\n\\n    function _cg(address addr, uint256 amount) private{\\n        address up = users[addr].upline;\\n        for(uint256 i; i \\u003c 30; ++i) {\\n            if(up == address(0)) break;\\n            users[up].downlineAmount += amount;\\n            _cl(addr, amount, up);\\n            addr = up;\\n            up = users[up].upline;\\n        }\\n    }\\n\\n    function _cl(address addr, uint256 amount, address up) private{\\n        address m = users[up].maxDirectAddr;\\n        if(m != addr) {\\n            uint256 mAmount = users[m].totalStake + users[m].downlineAmount;\\n            uint256 aAmount = users[addr].totalStake + users[addr].downlineAmount;\\n            uint256 newLevelAmount;\\n            if(mAmount \\u003e= aAmount) {\\n                newLevelAmount = users[up].levelAmount + amount;\\n            }else{\\n                users[up].maxDirectAddr = addr;\\n                newLevelAmount = users[up].levelAmount + mAmount - (aAmount - amount);\\n            }\\n            uint256 oldLevel = users[up].level;\\n            uint256 newLevel = cla(newLevelAmount);\\n            if(newLevel \\u003e oldLevel) {\\n                if(oldLevel \\u003e 0) {\\n                    nodeNum[oldLevel]--;\\n                    nodePerDividend[up][oldLevel] = perDividend[oldLevel] - nodePerDividend[up][oldLevel];\\n                }\\n                nodeNum[newLevel]++;\\n                nodePerDividend[up][newLevel] = perDividend[newLevel];\\n                users[up].level = newLevel;\\n            }\\n            users[up].levelAmount = newLevelAmount;\\n        }\\n    }\\n\\n    function cla(uint256 amount) public view returns(uint256){\\n        if(amount \\u003c V1) {\\n            return 0;\\n        }else if(amount \\u003e= V1 \\u0026\\u0026 amount \\u003c V2) {\\n            return 1;\\n        }else if(amount \\u003e= V2 \\u0026\\u0026 amount \\u003c V3) {\\n            return 2;\\n        }else {\\n            return 3;\\n        }\\n    }\\n\\n    function canRegister(address referrer) public {\\n        require(canRegisterWithoutStake, \\\"n\\\");\\n        register(referrer);\\n    }\\n\\n    function register(address referrer) private {\\n        if (!isUserExists(msg.sender)) {\\n            require(isUserExists(referrer), \\\"r\\\");\\n            _register(msg.sender, referrer);\\n        }\\n    }\\n\\n    function _register(address down, address up) private {\\n        uint256 id = nextUserId++;\\n        users[down].id = id;\\n        users[down].upline = up;\\n        id2Address[id] = down;\\n        users[up].directs.push(down);\\n    }\\n\\n    function _prk(address up, uint256 amount) private {\\n        if (up == address(0)) {\\n            return;\\n        }\\n        uint256 rda;\\n        if(users[up].rankTime \\u003c rankTime) {\\n            users[up].rankTime = rankTime;\\n            users[up].rankDirectAmount = amount;\\n            rda = amount;\\n        }else{\\n            users[up].rankDirectAmount += amount;\\n            rda = users[up].rankDirectAmount;\\n        }\\n        if(!_ua(up, rda)){\\n            _ia(up, rda);\\n        }\\n    }\\n\\n    function _ua(address addr, uint256 amount) private returns(bool){\\n        for(uint256 i; i \\u003c 3; ++i) {\\n            if(rankInfos[i].top == addr) {\\n                if(i == 0) {\\n                    rankInfos[i].amount = amount;\\n                    return true;\\n                }\\n                int256 j = int256(i) - 1;\\n                for(; j \\u003e= 0; j--){\\n                    if(rankInfos[uint256(j)].amount \\u003e= amount) {\\n                        break;\\n                    }\\n                }\\n                uint256 len = uint256(j + 1); \\n                for(uint256 k = i; k \\u003e len; k--){\\n                    rankInfos[k] = rankInfos[k-1];\\n                }       \\n                rankInfos[len].top = addr;\\n                rankInfos[len].amount = amount;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _ia(address addr, uint256 amount) private {\\n        for(uint256 i; i \\u003c 3; ++i) {\\n            if(rankInfos[i].amount \\u003c amount) {\\n                for(uint256 j = 2; j \\u003e i; j--) {\\n                    rankInfos[j] = rankInfos[j-1];\\n                }\\n                rankInfos[i].top = addr;\\n                rankInfos[i].amount = amount;\\n                return;\\n            }\\n        }\\n    }\\n\\n    function _iba(address addr, uint256 amount) private {\\n        for(uint256 i; i \\u003c 10; ++i) {\\n            if(bigRankInfos[i].amount \\u003c amount) {\\n                for(uint256 j = 9; j \\u003e i; j--) {\\n                    bigRankInfos[j] = bigRankInfos[j-1];\\n                }\\n                bigRankInfos[i].top = addr;\\n                bigRankInfos[i].amount = amount;\\n                return;\\n            }\\n        }\\n    }\\n\\n    function _acp(address addr, uint256 amount) private{\\n        compensationAmount += amount/100;\\n        compensationTime = block.timestamp;\\n        if(compensationPool.length \\u003c fixedCompensationArrayLength){\\n            compensationPool.push(addr);\\n        }else{\\n            uint256 idx = compensationPoolIdx;\\n            compensationPool[idx] = addr;\\n            if(idx == fixedCompensationArrayLength - 1) {\\n                compensationPoolIdx = 0;\\n            }else{\\n                compensationPoolIdx++;\\n            }\\n        }\\n    }\\n\\n    function _d(uint256 amount) private {\\n        uint256 d = amount/50;\\n        for(uint256 i = 1; i \\u003c 4; i++) {\\n            uint256 da;\\n            if(i == 1) {\\n                da = d/2;\\n            }else if(i == 2){\\n                da = d*3/10;\\n            }else {\\n                da = d/5;\\n            }\\n            uint256 levelNodeNum = nodeNum[i];\\n            if(levelNodeNum \\u003e 0) {\\n                perDividend[i] += da/levelNodeNum;\\n            }\\n        }\\n    }\\n\\n    function pp() public {\\n        if(block.timestamp \\u003e rankTime + duration) {\\n            curRankPool = _rp(curRankPool) + nextRankPool;\\n            nextRankPool = 0;\\n            curBig = _brp(curBig) + nextBig;\\n            nextBig = 0;\\n            uint256 interval = (block.timestamp - rankTime)/duration;\\n            rankTime += interval*duration;\\n        }\\n        if(block.timestamp \\u003e compensationTime + duration) {\\n            _cp();\\n        }\\n    }\\n\\n    function _cp() private{\\n        uint256 c = compensationAmount;\\n        uint256 len = compensationPool.length;\\n        if(c == 0 || len == 0) {\\n            return;\\n        }\\n        uint256 idx = compensationPoolIdx;\\n        if(idx \\u003e 0) {\\n            idx--;\\n        }else {\\n            idx = fixedCompensationArrayLength - 1;\\n        }\\n        if(len == 1){\\n            users[compensationPool[idx]].compensationReward += c;\\n        }else{\\n            uint256 o = c/(2*(len-1));\\n            for(uint256 i; i \\u003c len; ++i) {\\n                uint256 amount = o;\\n                if(i == idx){\\n                    amount = c/2;\\n                }\\n                users[compensationPool[i]].compensationReward += amount;\\n            }\\n        }\\n        compensationAmount = 0;\\n        compensationTime = block.timestamp;\\n    }\\n\\n    function _rp(uint256 curRank) private returns(uint256){\\n        RankInfo[] storage s = rankInfos;\\n        uint256 totalPayout;\\n        uint256 o = curRank/10;\\n        for(uint256 i; i \\u003c 3; ++i) {\\n            if(s[i].amount != 0) {\\n                uint256 rate = 5;\\n                if (i == 1) {\\n                    rate = 3;\\n                }else if (i == 2) {\\n                    rate = 2;\\n                }\\n                rate = rate * o;\\n                users[s[i].top].rankDirectReward += rate;\\n                recordRankInfos[i] = RecordRankInfo(s[i].top, s[i].amount, rate);\\n                s[i].amount = 0;\\n                totalPayout += rate;\\n            }else {\\n                crl(recordRankInfos, i);\\n                break;\\n            }\\n\\n        }\\n        return curRank - totalPayout;\\n    }\\n\\n    function crl(RecordRankInfo[] storage s, uint256 clearIdx) private {\\n        for(uint256 i = clearIdx; i \\u003c s.length; i++) {\\n            s[i].amount = 0;\\n        }\\n    }\\n\\n    function _brp(uint256 curB) private returns(uint256){\\n        RankInfo[] storage s = bigRankInfos;\\n        uint256 totalPayout;\\n        uint256 o = curB/10;\\n        for(uint256 i; i \\u003c 10; ++i) {\\n            if(s[i].amount != 0) {\\n                users[s[i].top].rankBigReward += o;\\n                recordBigRankInfos[i] = RecordRankInfo(s[i].top, s[i].amount, o);\\n                s[i].amount = 0;\\n                totalPayout += o;\\n            }else {\\n                crl(recordBigRankInfos, i);\\n                break;\\n            }\\n\\n        }\\n        return curB - totalPayout;\\n    }\\n\\n    function getReward(uint256 i) external {\\n        pp();\\n        User storage s = users[msg.sender];\\n        uint256 maxPayout = 2*s.totalStake - s.totalPayout;\\n        uint256 r;\\n        if(i == 0) {\\n            r = Math.min(maxPayout, _cws(msg.sender));\\n            _rpt(msg.sender, r);\\n        }else if (i ==1) {\\n            r = Math.min(maxPayout, s.directReward);\\n            s.directReward -= r;\\n        }else if (i ==2) { \\n            r = Math.min(maxPayout, s.refReward);\\n            s.refReward -= r;\\n        }else if (i ==3) { \\n            r = Math.min(maxPayout, s.rankBigReward);\\n            s.rankBigReward -= r;\\n        }else if (i ==4) { \\n            r = Math.min(maxPayout, s.rankDirectReward);\\n            s.rankDirectReward -= r;\\n        }else if (i ==5) { \\n            r = Math.min(maxPayout, s.compensationReward);\\n            s.compensationReward -= r;\\n        }else if (i ==6) {\\n            r = _cdd(msg.sender, 1, maxPayout);\\n        }else if (i ==7) {\\n            r = _cdd(msg.sender, 2, maxPayout);\\n        }else if (i ==8) {\\n            r = _cdd(msg.sender, 3, maxPayout);\\n        }\\n        s.totalPayout += r;\\n        c_erc20stake.transfer(msg.sender, r);\\n        _co();\\n    }\\n\\n    function _co() private {\\n        User storage s = users[msg.sender];\\n        uint256 realOutAmount = s.totalPayout + s.directReward + s.refReward + s.rankBigReward +s.rankDirectReward + s.compensationReward;\\n        realOutAmount +=  gdd(msg.sender, 1) + gdd(msg.sender, 2) + gdd(msg.sender, 3);\\n        realOutAmount = realOutAmount/2 - s.outStake;\\n        uint256 idxIsOut = s.idxIsOut;\\n        StakeInfo[] storage si = s.stakeInfos;\\n        uint256 count;\\n        uint256 outStake;\\n        for(uint256 i = idxIsOut; i \\u003c si.length; ++i) {\\n            if(realOutAmount \\u003e= si[i].stakeAmount) {\\n                realOutAmount -= si[i].stakeAmount;\\n                count++;\\n                outStake += si[i].stakeAmount;\\n            }else {\\n                break;\\n            }\\n        }\\n        if (count \\u003e 0) {\\n            s.idxIsOut += count;\\n            s.outStake += outStake;\\n        }\\n    }\\n\\n    function _rpt(address addr, uint256 amount) private{\\n        address up = users[addr].upline;\\n        for(uint256 i; i \\u003c 30; ++i) {\\n            if(up == address(0)) break;\\n            if(users[up].directs.length \\u003e i) {\\n                uint256 rate = 5;\\n                if (i \\u003e= 5 \\u0026\\u0026 i \\u003c= 9) {\\n                    rate = 4;\\n                }else if (i \\u003e= 10 \\u0026\\u0026 i \\u003c=19) {\\n                    rate = 3;\\n                }else if (i \\u003e= 20 \\u0026\\u0026 i \\u003c=24) {\\n                    rate = 2;\\n                }\\n                users[up].refReward += amount*rate/100;\\n            }\\n            up = users[up].upline;\\n        }\\n    }\\n\\n    function _cdd(address addr, uint256 i, uint256 maxPayout) private returns (uint256) {\\n        uint256 level = users[addr].level;\\n        uint256 r;\\n        if (level \\u003e i) {\\n            r = Math.min(maxPayout, nodePerDividend[addr][i]);\\n            nodePerDividend[addr][i] -= r;\\n        }else if(level == i) {\\n            r = Math.min(maxPayout, perDividend[i] - nodePerDividend[addr][i]);\\n            nodePerDividend[addr][i] += r;\\n        }\\n        return r;\\n    }\\n\\n    function _cws(address addr) private returns (uint256) {\\n        uint256 idxIsOut = users[addr].idxIsOut;\\n        StakeInfo[] storage s = users[addr].stakeInfos;\\n        uint256 totalReward;\\n        for(uint256 i = idxIsOut; i \\u003c s.length; ++i) {\\n            uint256 interval = (uint128(block.timestamp) - s[i].stakeTime)/duration;\\n            totalReward += s[i].stakeAmount*(interval - s[i].count)/100;\\n            s[i].count = uint64(interval);\\n        }\\n        return totalReward;\\n    }\\n\\n    function setS(uint256 min, uint256 max, bool c, uint256 t, uint256 ca) external onlyOwner {\\n        minStake = min;\\n        maxStake = max;\\n        canRegisterWithoutStake = c;\\n        maxStakeTimes = t;\\n        caseAmount = ca;\\n    }\\n\\n    function setV(uint256 v1, uint256 v2, uint256 v3) external onlyOwner {\\n        V1 = v1;\\n        V2 = v2;\\n        V3 = v3;\\n    }\\n\\n    function gws(address addr) public view returns (uint256) {\\n        uint256 idxIsOut = users[addr].idxIsOut;\\n        StakeInfo[] storage s = users[addr].stakeInfos;\\n        uint256 totalReward;\\n        for(uint256 i = idxIsOut; i \\u003c s.length; ++i) {\\n            uint256 interval = (uint128(block.timestamp) - s[i].stakeTime)/duration;\\n            totalReward += s[i].stakeAmount*(interval - s[i].count)/100;\\n        }\\n        return totalReward;\\n    }\\n\\n    function gdd(address addr, uint256 i) public view returns (uint256) {\\n        uint256 level = users[addr].level;\\n        if (level \\u003e i) {\\n            return nodePerDividend[addr][i];\\n        }else if(level == i) {\\n            return perDividend[i] - nodePerDividend[addr][i];\\n        }else {\\n            return 0;\\n        }\\n    }\\n\\n    function isUserExists(address addr) public view returns (bool) {\\n        return (users[addr].id != 0);\\n    }\\n\\n    function rankInfo() external view returns(RankInfo[] memory rInfos, RecordRankInfo[] memory rrInfos, uint256 cur, uint256 next,\\n        RankInfo[] memory rInfosB, RecordRankInfo[] memory rrInfosB, uint256 curB, uint256 nextB) {\\n        rInfos = rankInfos;\\n        rrInfos = recordRankInfos;\\n        cur = curRankPool;\\n        next = nextRankPool;\\n        rInfosB = bigRankInfos;\\n        rrInfosB = recordBigRankInfos;\\n        curB = curBig;\\n        nextB = nextBig;\\n    }\\n    function compenInfo() external view returns(uint256 compenIdx, address[] memory compenPool, uint256 compenTime, uint256 compenAmount) {\\n        compenIdx = compensationPoolIdx;\\n        compenPool = compensationPool;\\n        compenTime = compensationTime;\\n        compenAmount = compensationAmount;\\n    }\\n    function vInfo() external view returns(uint256, uint256, uint256, uint256, uint256, uint256) {\\n        return (nodeNum[1], nodeNum[2], nodeNum[3], perDividend[1], perDividend[2], perDividend[3]);\\n    }\\n    function userRewardInfo(address addr) external view returns(address, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\n        User storage o = users[addr];\\n        return (o.upline, gws(addr), o.directReward, o.refReward, o.rankDirectReward, o.compensationReward, o.totalStake, o.totalPayout);\\n    }\\n\\n    function userVInfo(address addr) external view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\\n        User storage o = users[addr];\\n        return (o.level, o.levelAmount, o.lastAmount, gdd(addr, 1), gdd(addr, 2), gdd(addr, 3), o.rankBigReward);\\n    }\\n\\n    function userOtherInfo(address addr) external view returns(uint256, uint256, uint256, uint256, uint256, uint256, address) {\\n        User storage o = users[addr];\\n        return (o.id, o.idxIsOut, o.stakeInfos.length, o.outStake, o.downlineAmount, o.directs.length, o.maxDirectAddr);\\n    }\\n\\n    function userRankInfo(address addr) external view returns(uint256, uint256) {\\n        User storage o = users[addr];\\n        return (o.rankTime, o.rankDirectAmount);\\n    }\\n\\n    function userStakeInfo(address addr) external view returns(StakeInfo[] memory) {\\n        StakeInfo[] memory o = users[addr].stakeInfos;\\n        return o;\\n    }\\n    function getDirectsByPage(address addr, uint256 pageNum, uint256 pageSize) external view returns (address[] memory directAddrs, \\n        uint256[] memory personalAmounts, uint256[] memory downlineAmounts, uint256 total) {\\n        User storage s = users[addr];\\n        total = s.directs.length;\\n        uint256 from = pageNum*pageSize;\\n        if (total \\u003c= from) {\\n            return (new address[](0), new uint256[](0), new uint256[](0), total);\\n        }\\n        uint256 minNum = Math.min(total - from, pageSize);\\n        directAddrs = new address[](minNum);\\n        personalAmounts = new uint256[](minNum);\\n        downlineAmounts = new uint256[](minNum);\\n        for (uint256 i = 0; i \\u003c minNum; i++) {\\n            address one = s.directs[from++];\\n            directAddrs[i] = one;\\n            personalAmounts[i] = users[one].totalStake;\\n            downlineAmounts[i] = users[one].downlineAmount;\\n        }\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    constructor () {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _owner = newOwner;\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"firstAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"V1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"V2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"V3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bigRankInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"canRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canRegisterWithoutStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"caseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cla\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compenIdx\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"compenPool\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"compenTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"compenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"gdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getDirectsByPage\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"directAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"personalAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"downlineAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"gws\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"id2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakeTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodePerDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"perDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rankInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LGTReward.RankInfo[]\",\"name\":\"rInfos\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct LGTReward.RecordRankInfo[]\",\"name\":\"rrInfos\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"cur\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct LGTReward.RankInfo[]\",\"name\":\"rInfosB\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct LGTReward.RecordRankInfo[]\",\"name\":\"rrInfosB\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"curB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rankInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rankTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"c\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ca\",\"type\":\"uint256\"}],\"name\":\"setS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v3\",\"type\":\"uint256\"}],\"name\":\"setV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userOtherInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userRankInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userRewardInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"stakeTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"stakeAmount\",\"type\":\"uint128\"}],\"internalType\":\"struct LGTReward.StakeInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userVInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAmount\",\"type\":\"uint256\"}],\"name\":\"validAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LGTReward", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001ccec87fe96e940e9027fc3c9127118199f1cc10", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9cca3bf8b34750466cf83f9920e4be6c33801928d534bce98159e01a38dcf934"}