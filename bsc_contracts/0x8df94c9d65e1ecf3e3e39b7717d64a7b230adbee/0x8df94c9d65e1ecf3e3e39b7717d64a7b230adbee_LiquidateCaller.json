{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/caller/LiquidateCaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.17;\\n\\n\\nimport \\\"../openzeppelin/Ownable.sol\\\";\\nimport \\\"../openzeppelin/Roles.sol\\\";\\n\\n\\nimport '../interfaces/IERC20.sol';\\n//\\nimport \\\"../interfaces/IThaiFi.sol\\\";\\n\\n\\n\\n\\ncontract LiquidateCaller is Ownable {\\n    IThaiFi private lendingProtocol;\\n\\n    address public receiver;\\n\\n\\n    using Roles for Roles.Role;\\n    Roles.Role private _liquidators;\\n    \\n    constructor(\\n      address _lendingProtocol,\\n      address _receiver\\n      ) public {\\n      lendingProtocol = IThaiFi(_lendingProtocol);\\n      receiver = _receiver;\\n    }\\n\\n    modifier onlyLiquidator() {\\n        require(isLiquidator(_msgSender()), \\\"DOES_NOT_HAVE_LIQUIDATOR_ROLE\\\");\\n        _;\\n    }\\n    \\n    function setProtocol(\\n      address _lendingProtocol\\n    )\\n      external\\n      onlyOwner\\n    {\\n      lendingProtocol = IThaiFi(_lendingProtocol);\\n    } \\n\\n    function setReceiver(\\n      address _receiver\\n    )\\n      external\\n      onlyOwner\\n    {\\n      receiver = _receiver;\\n    } \\n\\n    function setLiquidator(\\n        address liquidator\\n    )\\n        external\\n        onlyOwner\\n    {\\n        _liquidators.add(liquidator);\\n        \\n    }\\n\\n    function renounceLiquidator(\\n        address liquidator\\n    )\\n        external\\n        onlyOwner\\n    {\\n        _liquidators.remove(liquidator);\\n        \\n    }\\n\\n    function isLiquidator(address account) public view returns (bool) {\\n        return _liquidators.has(account);\\n    }\\n    \\n    \\n    function liquidateLoan(\\n        address borrowedToken,\\n        bytes32 loanId,\\n        uint256 amountToLiquidate\\n      )\\n        public\\n        onlyLiquidator\\n        returns (uint256 profitAmount)\\n\\n  {\\n\\n\\n    (,,,,profitAmount) = lendingProtocol.liquidate(\\n        loanId,\\n        address(this), //send back to sender\\n        amountToLiquidate\\n    );\\n\\n    IERC20 TokenBorrowed = IERC20(address(borrowedToken));\\n\\n    TokenBorrowed.transfer(receiver, profitAmount);\\n\\n\\n\\n  }\\n\\n\\n\\n}\"\r\n    },\r\n    \"contracts/openzeppelin/Ownable.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"unauthorized\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.17;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity >=0.5.0 <0.6.0;\\n\\n\\ncontract IERC20 {\\n    string public name;\\n    uint8 public decimals;\\n    string public symbol;\\n    function totalSupply() public view returns (uint256);\\n    function balanceOf(address _who) public view returns (uint256);\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n    function allowance(address _owner, address _spender) public view returns (uint256);\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\\n    function approve(address _spender, uint256 _value) public returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IThaiFi.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity >=0.5.0 <0.6.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../core/State.sol\\\";\\nimport \\\"../events/ProtocolSettingsEvents.sol\\\";\\nimport \\\"../events/LoanSettingsEvents.sol\\\";\\nimport \\\"../events/LoanOpeningsEvents.sol\\\";\\nimport \\\"../events/LoanMaintenanceEvents.sol\\\";\\nimport \\\"../events/LoanClosingsEvents.sol\\\";\\nimport \\\"../events/FeesEvents.sol\\\";\\nimport \\\"../events/SwapsEvents.sol\\\";\\n\\n\\ncontract IThaiFi is\\n    State,\\n    ProtocolSettingsEvents,\\n    LoanSettingsEvents,\\n    LoanOpeningsEvents,\\n    LoanMaintenanceEvents,\\n    LoanClosingsEvents,\\n    SwapsEvents {\\n\\n    ////// Protocol //////\\n\\n    function replaceContract(\\n        address target)\\n        external;\\n\\n    function setTargets(\\n        string[] calldata sigsArr,\\n        address[] calldata targetsArr)\\n        external;\\n\\n    function getTarget(\\n        string calldata sig)\\n        external\\n        view\\n        returns (address);\\n\\n\\n    ////// Protocol Settings //////\\n\\n    function setPriceFeedContract(\\n        address newContract)\\n        external;\\n\\n    function setSwapsImplContract(\\n        address newContract)\\n        external;\\n\\n    function setLoanPool(\\n        address[] calldata pools,\\n        address[] calldata assets)\\n        external;\\n\\n    function setSupportedTokens(\\n        address[] calldata addrs,\\n        bool[] calldata toggles)\\n        external;\\n\\n    function setLendingFeePercent(\\n        uint256 newValue)\\n        external;\\n\\n    function setTradingFeePercent(\\n        uint256 newValue)\\n        external;\\n\\n    function setBorrowingFeePercent(\\n        uint256 newValue)\\n        external;\\n\\n    function setAffiliateFeePercent(\\n        uint256 newValue)\\n        external;\\n\\n    function setLiquidationIncentivePercent(\\n        uint256 newAmount)\\n        external;\\n\\n    function setMaxDisagreement(\\n        uint256 newAmount)\\n        external;\\n\\n    function setSourceBuffer(\\n        uint256 newAmount)\\n        external;\\n\\n    function setMaxSwapSize(\\n        uint256 newAmount)\\n        external;\\n\\n    function setFeesController(\\n        address newController)\\n        external;\\n\\n    function withdrawLendingFees(\\n        address token,\\n        address receiver,\\n        uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function withdrawTradingFees(\\n        address token,\\n        address receiver,\\n        uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function withdrawBorrowingFees(\\n        address token,\\n        address receiver,\\n        uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function withdrawProtocolToken(\\n        address receiver,\\n        uint256 amount)\\n        external\\n        returns (address, bool);\\n\\n    function depositProtocolToken(\\n        uint256 amount)\\n        external;\\n\\n    function getLoanPoolsList(\\n        uint256 start,\\n        uint256 count)\\n        external;\\n\\n    function isLoanPool(\\n        address loanPool)\\n        external\\n        view\\n        returns (bool);\\n\\n    function setWbaseToken(\\n        address WbaseTokenAddress)\\n        external;\\n        \\n    function setThaiFiSwapContractRegistryAddress(\\n        address registryAddress)\\n        external;\\n\\n    function setProtocolTokenAddress(\\n        address _protocolTokenAddress)\\n        external;\\n\\n    function setRolloverBaseReward(\\n        uint256 transactionCost)\\n        external;\\n\\n    function setRebatePercent(\\n        uint256 rebatePercent) \\n        external; \\n\\n\\n    ////// Loan Settings //////\\n\\n    function setupLoanParams(\\n        LoanParams[] calldata loanParamsList)\\n        external\\n        returns (bytes32[] memory loanParamsIdList);\\n\\n    // Deactivates LoanParams for future loans. Active loans using it are unaffected.\\n    function disableLoanParams(\\n        bytes32[] calldata loanParamsIdList)\\n        external;\\n\\n    function getLoanParams(\\n        bytes32[] calldata loanParamsIdList)\\n        external\\n        view\\n        returns (LoanParams[] memory loanParamsList);\\n\\n    function getLoanParamsList(\\n        address owner,\\n        uint256 start,\\n        uint256 count)\\n        external\\n        view\\n        returns (bytes32[] memory loanParamsList);\\n\\n    function getTotalPrincipal(\\n        address lender,\\n        address loanToken)\\n        external\\n        view\\n        returns (uint256);\\n\\n\\n    ////// Loan Openings //////\\n\\n    function borrowOrTradeFromPool(\\n        bytes32 loanParamsId,\\n        bytes32 loanId, // if 0, start a new loan\\n        bool isTorqueLoan,\\n        uint256 initialMargin,\\n        address[4] calldata sentAddresses,\\n            // lender: must match loan if loanId provided\\n            // borrower: must match loan if loanId provided\\n            // receiver: receiver of funds (address(0) assumes borrower address)\\n            // manager: delegated manager of loan unless address(0)\\n        uint256[5] calldata sentValues,\\n            // newRate: new loan interest rate\\n            // newPrincipal: new loan size (borrowAmount + any borrowed interest)\\n            // torqueInterest: new amount of interest to escrow for Torque loan (determines initial loan length)\\n            // loanTokenReceived: total loanToken deposit (amount not sent to borrower in the case of Torque loans)\\n            // collateralTokenReceived: total collateralToken deposit\\n        bytes calldata loanDataBytes)\\n        external\\n        payable\\n        returns (uint256);\\n\\n    function setDelegatedManager(\\n        bytes32 loanId,\\n        address delegated,\\n        bool toggle)\\n        external;\\n\\n    function getEstimatedMarginExposure(\\n        address loanToken,\\n        address collateralToken,\\n        uint256 loanTokenSent,\\n        uint256 collateralTokenSent,\\n        uint256 interestRate,\\n        uint256 newPrincipal)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRequiredCollateral(\\n        address loanToken,\\n        address collateralToken,\\n        uint256 newPrincipal,\\n        uint256 marginAmount,\\n        bool isTorqueLoan)\\n        external\\n        view\\n        returns (uint256 collateralAmountRequired);\\n\\n    function getBorrowAmount(\\n        address loanToken,\\n        address collateralToken,\\n        uint256 collateralTokenAmount,\\n        uint256 marginAmount,\\n        bool isTorqueLoan)\\n        external\\n        view\\n        returns (uint256 borrowAmount);\\n\\n\\n    ////// Loan Closings //////\\n\\n    function getVersion()\\n        external view returns (uint);\\n\\n    function setParams(\\n        address _pancakeRouter,\\n        address _tokenPaired\\n    )\\n        external;\\n\\n    function setLiquidator(\\n        address liquidator\\n    )\\n        external;\\n\\n\\n    function renounceLiquidator(\\n        address liquidator\\n    )\\n        external;\\n\\n\\n    function isLiquidator(\\n        address account\\n        ) public view returns (bool);\\n\\n\\n\\n    function liquidate(\\n        bytes32 loanId,\\n        address receiver,\\n        uint256 closeAmount) // denominated in loanToken\\n        external\\n        payable\\n        returns (\\n            uint256 loanCloseAmount,\\n            uint256 seizedAmount,\\n            uint256 excessSeizedAmount,\\n            address seizedToken,\\n            uint256 profitAmount\\n        );\\n\\n\\n    function rollover(\\n        bytes32 loanId,\\n        bytes calldata loanDataBytes)\\n        external;\\n\\n    function closeWithDeposit(\\n        bytes32 loanId,\\n        address receiver,\\n        uint256 depositAmount) // denominated in loanToken\\n        external\\n        payable\\n        returns (\\n            uint256 loanCloseAmount,\\n            uint256 withdrawAmount,\\n            address withdrawToken\\n        );\\n\\n    function closeWithSwap(\\n        bytes32 loanId,\\n        address receiver,\\n        uint256 swapAmount, // denominated in collateralToken\\n        bool returnTokenIsCollateral, // true: withdraws collateralToken, false: withdraws loanToken\\n        bytes calldata loanDataBytes)\\n        external\\n        returns (\\n            uint256 loanCloseAmount,\\n            uint256 withdrawAmount,\\n            address withdrawToken\\n        );\\n\\n\\n    ////// Loan Maintenance //////\\n\\n    function depositCollateral(\\n        bytes32 loanId,\\n        uint256 depositAmount) // must match msg.value if ether is sent\\n        external\\n        payable;\\n\\n    function withdrawCollateral(\\n        bytes32 loanId,\\n        address receiver,\\n        uint256 withdrawAmount)\\n        external\\n        returns (uint256 actualWithdrawAmount);\\n\\n    function extendLoanByInterest(\\n        bytes32 loanId,\\n        address payer,\\n        uint256 depositAmount,\\n        bool useCollateral,\\n        bytes calldata loanDataBytes)\\n        external\\n        payable\\n        returns (uint256 secondsExtended);\\n\\n    function reduceLoanByInterest(\\n        bytes32 loanId,\\n        address receiver,\\n        uint256 withdrawAmount)\\n        external\\n        returns (uint256 secondsReduced);\\n\\n    function withdrawAccruedInterest(\\n        address loanToken)\\n        external;\\n\\n    function getLenderInterestData(\\n        address lender,\\n        address loanToken)\\n        external\\n        view\\n        returns (\\n            uint256 interestPaid,\\n            uint256 interestPaidDate,\\n            uint256 interestOwedPerDay,\\n            uint256 interestUnPaid,\\n            uint256 interestFeePercent,\\n            uint256 principalTotal);\\n\\n    function getLoanInterestData(\\n        bytes32 loanId)\\n        external\\n        view\\n        returns (\\n            address loanToken,\\n            uint256 interestOwedPerDay,\\n            uint256 interestDepositTotal,\\n            uint256 interestDepositRemaining);\\n\\n    struct LoanReturnData {\\n        bytes32 loanId;\\n        address loanToken;\\n        address collateralToken;\\n        uint256 principal;\\n        uint256 collateral;\\n        uint256 interestOwedPerDay;\\n        uint256 interestDepositRemaining;\\n        uint256 startRate; // collateralToLoanRate\\n        uint256 startMargin;\\n        uint256 maintenanceMargin;\\n        uint256 currentMargin;\\n        uint256 maxLoanTerm;\\n        uint256 endTimestamp;\\n        uint256 maxLiquidatable;\\n        uint256 maxSeizable;\\n    }\\n\\n    function getUserLoans(\\n        address user,\\n        uint256 start,\\n        uint256 count,\\n        uint256 loanType,\\n        bool isLender,\\n        bool unsafeOnly)\\n        external\\n        view\\n        returns (LoanReturnData[] memory loansData);\\n\\n    function getLoan(\\n        bytes32 loanId)\\n        external\\n        view\\n        returns (LoanReturnData memory loanData);\\n\\n    function getActiveLoans(\\n        uint256 start,\\n        uint256 count,\\n        bool unsafeOnly)\\n        external\\n        view\\n        returns (LoanReturnData[] memory loansData);\\n\\n\\n    ////// Protocol Migration //////\\n\\n    function setLegacyOracles(\\n        address[] calldata refs,\\n        address[] calldata oracles)\\n        external;\\n\\n    function getLegacyOracle(\\n        address ref)\\n        external\\n        view\\n        returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/Context.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/State.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\nimport \\\"./Objects.sol\\\";\\nimport \\\"../mixins/EnumerableBytes32Set.sol\\\";\\nimport \\\"../openzeppelin/ReentrancyGuard.sol\\\";\\nimport \\\"../openzeppelin/Ownable.sol\\\";\\nimport \\\"../openzeppelin/SafeMath.sol\\\";\\nimport \\\"../interfaces/IWbaseERC20.sol\\\";\\n\\n\\ncontract State is Objects, ReentrancyGuard, Ownable {\\n    using SafeMath for uint256;\\n    using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;\\n\\n    address public priceFeeds;                                                          // handles asset reference price lookups\\n    address public swapsImpl;                                                           // handles asset swaps using dex liquidity\\n    address public thaifiSwapContractRegistryAddress;                                       // contract registry address of the thaifi swap network\\n\\n    mapping (bytes4 => address) public logicTargets;                                    // implementations of protocol functions\\n\\n    mapping (bytes32 => Loan) public loans;                                             // loanId => Loan\\n    mapping (bytes32 => LoanParams) public loanParams;                                  // loanParamsId => LoanParams\\n\\n    mapping (address => mapping (bytes32 => Order)) public lenderOrders;                // lender => orderParamsId => Order\\n    mapping (address => mapping (bytes32 => Order)) public borrowerOrders;              // borrower => orderParamsId => Order\\n\\n    mapping (bytes32 => mapping (address => bool)) public delegatedManagers;            // loanId => delegated => approved\\n\\n    // Interest\\n    mapping (address => mapping (address => LenderInterest)) public lenderInterest;     // lender => loanToken => LenderInterest object\\n    mapping (bytes32 => LoanInterest) public loanInterest;                              // loanId => LoanInterest object\\n\\n    // Internals\\n    EnumerableBytes32Set.Bytes32Set internal logicTargetsSet;                           // implementations set\\n    EnumerableBytes32Set.Bytes32Set internal activeLoansSet;                            // active loans set\\n\\n    mapping (address => EnumerableBytes32Set.Bytes32Set) internal lenderLoanSets;       // lender loans set\\n    mapping (address => EnumerableBytes32Set.Bytes32Set) internal borrowerLoanSets;     // borrow loans set\\n    mapping (address => EnumerableBytes32Set.Bytes32Set) internal userLoanParamSets;    // user loan params set\\n\\n    address public feesController;                                                      // address controlling fee withdrawals\\n\\n    uint256 public lendingFeePercent = 10**19; // 10% fee                               // fee taken from lender interest payments\\n    mapping (address => uint256) public lendingFeeTokensHeld;                           // total interest fees received and not withdrawn per asset\\n    mapping (address => uint256) public lendingFeeTokensPaid;                           // total interest fees withdraw per asset (lifetime fees = lendingFeeTokensHeld + lendingFeeTokensPaid)\\n\\n    uint256 public tradingFeePercent = 15 * 10**16; // 0.15% fee                        // fee paid for each trade\\n    mapping (address => uint256) public tradingFeeTokensHeld;                           // total trading fees received and not withdrawn per asset\\n    mapping (address => uint256) public tradingFeeTokensPaid;                           // total trading fees withdraw per asset (lifetime fees = tradingFeeTokensHeld + tradingFeeTokensPaid)\\n\\n    uint256 public borrowingFeePercent = 9 * 10**16; // 0.09% fee                       // origination fee paid for each loan\\n    mapping (address => uint256) public borrowingFeeTokensHeld;                         // total borrowing fees received and not withdrawn per asset\\n    mapping (address => uint256) public borrowingFeeTokensPaid;                         // total borrowing fees withdraw per asset (lifetime fees = borrowingFeeTokensHeld + borrowingFeeTokensPaid)\\n\\n    uint256 public protocolTokenHeld;                                                   // current protocol token deposit balance\\n    uint256 public protocolTokenPaid;                                                   // lifetime total payout of protocol token\\n\\n    uint256 public affiliateFeePercent = 30 * 10**18; // 30% fee share                  // fee share for affiliate program\\n\\n    uint256 public liquidationIncentivePercent = 15 * 10**18; // 5% collateral discount  // discount on collateral for liquidators\\n\\n    mapping (address => address) public loanPoolToUnderlying;                            // loanPool => underlying\\n    mapping (address => address) public underlyingToLoanPool;                            // underlying => loanPool\\n    EnumerableBytes32Set.Bytes32Set internal loanPoolsSet;                               // loan pools set\\n\\n    mapping (address => bool) public supportedTokens;                                    // supported tokens for swaps\\n\\n    uint256 public maxDisagreement = 5 * 10**18;                                         // % disagreement between swap rate and reference rate\\n\\n    uint256 public sourceBuffer = 10000;                                                 // used as buffer for swap source amount estimations\\n\\n    uint256 public maxSwapSize = 50 ether;                                               // maximum support swap size in BTC\\n\\n    mapping(address => uint256) public borrowerNonce;                                    // nonce per borrower. used for loan id creation.\\n\\n    uint256 public rolloverBaseReward = 16800000000000;                                  // Rollover transaction costs around 0.0000168 rBTC, it is denominated in wBASE\\n    uint256 public rolloverFlexFeePercent = 0.1 ether;                                   // 0.1%\\n\\n    IWbaseERC20 public wbaseToken;\\n    address public protocolTokenAddress;\\n\\n    uint256 public feeRebatePercent = 50 * 10**18; // 50% fee rebate                     // potocolToken reward to user, it is worth % of trading/borrowing fee\\n\\n    function _setTarget(\\n        bytes4 sig,\\n        address target)\\n        internal\\n    {\\n        logicTargets[sig] = target;\\n\\n        if (target != address(0)) {\\n            logicTargetsSet.addBytes32(bytes32(sig));\\n        } else {\\n            logicTargetsSet.removeBytes32(bytes32(sig));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/events/ProtocolSettingsEvents.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract ProtocolSettingsEvents {\\n    event SetPriceFeedContract(\\n        address indexed sender,\\n        address oldValue,\\n        address newValue\\n    );\\n\\n    event SetSwapsImplContract(\\n        address indexed sender,\\n        address oldValue,\\n        address newValue\\n    );\\n\\n    event SetLoanPool(\\n        address indexed sender,\\n        address indexed loanPool,\\n        address indexed underlying\\n    );\\n\\n    event SetSupportedTokens(\\n        address indexed sender,\\n        address indexed token,\\n        bool isActive\\n    );\\n\\n    event SetLendingFeePercent(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetTradingFeePercent(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetBorrowingFeePercent(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetAffiliateFeePercent(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetLiquidationIncentivePercent(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetMaxSwapSize(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetFeesController(\\n        address indexed sender,\\n        address indexed oldController,\\n        address indexed newController\\n    );\\n\\n    event SetWbaseToken(\\n        address indexed sender,\\n        address indexed oldWethToken,\\n        address indexed newWethToken\\n    );\\n\\n    event SetThaiFiSwapContractRegistryAddress(\\n        address indexed sender,\\n        address indexed oldThaiFiSwapContractRegistryAddress,\\n        address indexed newThaiFiSwapContractRegistryAddress\\n    );\\n\\n    event SetProtocolTokenAddress(\\n        address indexed sender,\\n        address indexed oldProtocolToken,\\n        address indexed newProtocolToken\\n    );\\n\\n    event WithdrawLendingFees(\\n        address indexed sender,\\n        address indexed token,\\n        address indexed receiver,\\n        uint256 amount\\n    );\\n\\n    event WithdrawTradingFees(\\n        address indexed sender,\\n        address indexed token,\\n        address indexed receiver,\\n        uint256 amount\\n    );\\n\\n    event WithdrawBorrowingFees(\\n        address indexed sender,\\n        address indexed token,\\n        address indexed receiver,\\n        uint256 amount\\n    );\\n\\n    event SetRolloverBaseReward(\\n        address indexed sender,\\n        uint256 oldValue,\\n        uint256 newValue\\n    );\\n\\n    event SetRebatePercent(\\n        address indexed sender,\\n        uint256 oldRebatePercent,\\n        uint256 newRebatePercent\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/events/LoanSettingsEvents.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LoanSettingsEvents {\\n    event LoanParamsSetup(\\n        bytes32 indexed id,\\n        address owner,\\n        address indexed loanToken,\\n        address indexed collateralToken,\\n        uint256 minInitialMargin,\\n        uint256 maintenanceMargin,\\n        uint256 maxLoanTerm\\n    );\\n    event LoanParamsIdSetup(\\n        bytes32 indexed id,\\n        address indexed owner\\n    );\\n\\n    event LoanParamsDisabled(\\n        bytes32 indexed id,\\n        address owner,\\n        address indexed loanToken,\\n        address indexed collateralToken,\\n        uint256 minInitialMargin,\\n        uint256 maintenanceMargin,\\n        uint256 maxLoanTerm\\n    );\\n    event LoanParamsIdDisabled(\\n        bytes32 indexed id,\\n        address indexed owner\\n    );\\n}\"\r\n    },\r\n    \"contracts/events/LoanOpeningsEvents.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LoanOpeningsEvents {\\n\\n    // topic0: 0x7bd8cbb7ba34b33004f3deda0fd36c92fc0360acbd97843360037b467a538f90\\n    event Borrow(\\n        address indexed user,\\n        address indexed lender,\\n        bytes32 indexed loanId,\\n        address loanToken,\\n        address collateralToken,\\n        uint256 newPrincipal,\\n        uint256 newCollateral,\\n        uint256 interestRate,\\n        uint256 interestDuration,\\n        uint256 collateralToLoanRate,\\n        uint256 currentMargin\\n    );\\n\\n    // topic0: 0xf640c1cfe1a912a0b0152b5a542e5c2403142eed75b06cde526cee54b1580e5c\\n    event Trade(\\n        address indexed user,\\n        address indexed lender,\\n        bytes32 indexed loanId,\\n        address collateralToken,\\n        address loanToken,\\n        uint256 positionSize,\\n        uint256 borrowedAmount,\\n        uint256 interestRate,\\n        uint256 settlementDate,\\n        uint256 entryPrice, // one unit of collateralToken, denominated in loanToken\\n        uint256 entryLeverage,\\n        uint256 currentLeverage\\n    );\\n\\n    // topic0: 0x0eef4f90457a741c97d76fcf13fa231fefdcc7649bdb3cb49157c37111c98433\\n    event DelegatedManagerSet(\\n        bytes32 indexed loanId,\\n        address indexed delegator,\\n        address indexed delegated,\\n        bool isActive\\n    );\\n}\"\r\n    },\r\n    \"contracts/events/LoanMaintenanceEvents.sol\": {\r\n      \"content\": \"pragma solidity 0.5.17;\\n\\ncontract LoanMaintenanceEvents {\\n    \\n    event DepositCollateral(\\n        bytes32 loanId,\\n        uint256 depositAmount\\n    );\\n    \\n}\"\r\n    },\r\n    \"contracts/events/LoanClosingsEvents.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LoanClosingsEvents {\\n\\n    // topic0: 0x6349c1a02ec126f7f4fc6e6837e1859006e90e9901635c442d29271e77b96fb6\\n    event CloseWithDeposit(\\n        address indexed user,\\n        address indexed lender,\\n        bytes32 indexed loanId,\\n        address closer,\\n        address loanToken,\\n        address collateralToken,\\n        uint256 repayAmount,\\n        uint256 collateralWithdrawAmount,\\n        uint256 collateralToLoanRate,\\n        uint256 currentMargin\\n    );\\n\\n    // topic0: 0x2ed7b29b4ca95cf3bb9a44f703872a66e6aa5e8f07b675fa9a5c124a1e5d7352\\n    event CloseWithSwap(\\n        address indexed user,\\n        address indexed lender,\\n        bytes32 indexed loanId,\\n        address collateralToken,\\n        address loanToken,\\n        address closer,\\n        uint256 positionCloseSize,\\n        uint256 loanCloseAmount,\\n        uint256 exitPrice, // one unit of collateralToken, denominated in loanToken\\n        uint256 currentLeverage\\n    );\\n\\n    // topic0: 0x46fa03303782eb2f686515f6c0100f9a62dabe587b0d3f5a4fc0c822d6e532d3\\n    event Liquidate(\\n        address indexed user,\\n        address indexed liquidator,\\n        bytes32 indexed loanId,\\n        address lender,\\n        address loanToken,\\n        address collateralToken,\\n        uint256 repayAmount,\\n        uint256 collateralWithdrawAmount,\\n        uint256 collateralRepayingAmount,\\n        uint256 collateralToLoanRate,\\n        uint256 currentMargin\\n    );\\n    \\n    event swapExcess(\\n        bool shouldRefund, \\n        uint amount, \\n        uint amountInRbtc, \\n        uint threshold\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/events/FeesEvents.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract FeesEvents {\\n    event PayLendingFee(\\n        address indexed payer,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    event PayTradingFee(\\n        address indexed payer,\\n        address indexed token,\\n        bytes32 indexed loanId,\\n        uint256 amount\\n    );\\n\\n    event PayBorrowingFee(\\n        address indexed payer,\\n        address indexed token,\\n        bytes32 indexed loanId,\\n        uint256 amount\\n    );\\n\\n    event EarnReward(\\n        address indexed receiver,\\n        address indexed token,\\n        bytes32 indexed loanId,\\n        uint256 amount\\n    );\\n}\"\r\n    },\r\n    \"contracts/events/SwapsEvents.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract SwapsEvents {\\n    event LoanSwap(\\n        bytes32 indexed loanId,\\n        address indexed sourceToken,\\n        address indexed destToken,\\n        address borrower,\\n        uint256 sourceAmount,\\n        uint256 destAmount\\n    );\\n\\n    event ExternalSwap(\\n        address indexed user,\\n        address indexed sourceToken,\\n        address indexed destToken,\\n        uint256 sourceAmount,\\n        uint256 destAmount\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/core/Objects.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\nimport \\\"./objects/LoanStruct.sol\\\";\\nimport \\\"./objects/LoanParamsStruct.sol\\\";\\nimport \\\"./objects/OrderStruct.sol\\\";\\nimport \\\"./objects/LenderInterestStruct.sol\\\";\\nimport \\\"./objects/LoanInterestStruct.sol\\\";\\n\\n\\ncontract Objects is\\n    LoanStruct,\\n    LoanParamsStruct,\\n    OrderStruct,\\n    LenderInterestStruct,\\n    LoanInterestStruct\\n{}\"\r\n    },\r\n    \"contracts/mixins/EnumerableBytes32Set.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n/**\\n * @dev Library for managing loan sets\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * Include with `using EnumerableBytes32Set for EnumerableBytes32Set.Bytes32Set;`.\\n *\\n */\\nlibrary EnumerableBytes32Set {\\n\\n    struct Bytes32Set {\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) index;\\n        bytes32[] values;\\n    }\\n\\n    /**\\n     * @dev Add an address value to a set. O(1).\\n     * Returns false if the value was already in the set.\\n     */\\n    function addAddress(Bytes32Set storage set, address addrvalue)\\n        internal\\n        returns (bool)\\n    {\\n        bytes32 value;\\n        assembly {\\n            value := addrvalue\\n        }\\n        return addBytes32(set, value);\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     * Returns false if the value was already in the set.\\n     */\\n    function addBytes32(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        if (!contains(set, value)){\\n            set.index[value] = set.values.push(value);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes an address value from a set. O(1).\\n     * Returns false if the value was not present in the set.\\n     */\\n    function removeAddress(Bytes32Set storage set, address addrvalue)\\n        internal\\n        returns (bool)\\n    {\\n        bytes32 value;\\n        assembly {\\n            value := addrvalue\\n        }\\n        return removeBytes32(set, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     * Returns false if the value was not present in the set.\\n     */\\n    function removeBytes32(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        if (contains(set, value)){\\n            uint256 toDeleteIndex = set.index[value] - 1;\\n            uint256 lastIndex = set.values.length - 1;\\n\\n            // If the element we're deleting is the last one, we can just remove it without doing a swap\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set.values[lastIndex];\\n\\n                // Move the last value to the index where the deleted value is\\n                set.values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\\n            }\\n\\n            // Delete the index entry for the deleted value\\n            delete set.index[value];\\n\\n            // Delete the old entry for the moved value\\n            set.values.pop();\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return set.index[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns an array with all values in the set. O(N).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n\\n     * WARNING: This function may run out of gas on large sets: use {length} and\\n     * {get} instead in these cases.\\n     */\\n    function enumerate(Bytes32Set storage set, uint256 start, uint256 count)\\n        internal\\n        view\\n        returns (bytes32[] memory output)\\n    {\\n        uint256 end = start + count;\\n        require(end >= start, \\\"addition overflow\\\");\\n        end = set.values.length < end ? set.values.length : end;\\n        if (end == 0 || start >= end) {\\n            return output;\\n        }\\n\\n        output = new bytes32[](end-start);\\n        for (uint256 i; i < end-start; i++) {\\n            output[i] = set.values[i+start];\\n        }\\n        return output;\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements on the set. O(1).\\n     */\\n    function length(Bytes32Set storage set)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return set.values.length;\\n    }\\n\\n   /** @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function get(Bytes32Set storage set, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return set.values[index];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/ReentrancyGuard.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.6.0;\\n\\n\\n/**\\n * @title Helps contracts guard against reentrancy attacks.\\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\\n * @dev If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard {\\n\\n    /// @dev Constant for unlocked guard state - non-zero to prevent extra gas costs.\\n    /// See: https://github.com/OpenZeppelin/openzeppelin-solidity/issues/1056\\n    uint256 internal constant REENTRANCY_GUARD_FREE = 1;\\n\\n    /// @dev Constant for locked guard state\\n    uint256 internal constant REENTRANCY_GUARD_LOCKED = 2;\\n\\n    /**\\n    * @dev We use a single lock for the whole contract.\\n    */\\n    uint256 internal reentrancyLock = REENTRANCY_GUARD_FREE;\\n\\n    /**\\n    * @dev Prevents a contract from calling itself, directly or indirectly.\\n    * If you mark a function `nonReentrant`, you should also\\n    * mark it `external`. Calling one `nonReentrant` function from\\n    * another is not supported. Instead, you can implement a\\n    * `private` function doing the actual work, and an `external`\\n    * wrapper marked as `nonReentrant`.\\n    */\\n    modifier nonReentrant() {\\n        require(reentrancyLock == REENTRANCY_GUARD_FREE, \\\"nonReentrant\\\");\\n        reentrancyLock = REENTRANCY_GUARD_LOCKED;\\n        _;\\n        reentrancyLock = REENTRANCY_GUARD_FREE;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/SafeMath.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min256(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return _a < _b ? _a : _b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWbaseERC20.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity >=0.5.0 <0.6.0;\\n\\nimport \\\"./IWbase.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract IWbaseERC20 is IWbase, IERC20 {}\\n\"\r\n    },\r\n    \"contracts/core/objects/LoanStruct.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LoanStruct {\\n    struct Loan {\\n        bytes32 id;                 // id of the loan\\n        bytes32 loanParamsId;       // the linked loan params id\\n        bytes32 pendingTradesId;    // the linked pending trades id\\n        bool active;                // if false, the loan has been fully closed\\n        uint256 principal;          // total borrowed amount outstanding\\n        uint256 collateral;         // total collateral escrowed for the loan\\n        uint256 startTimestamp;     // loan start time\\n        uint256 endTimestamp;       // for active loans, this is the expected loan end time, for in-active loans, is the actual (past) end time\\n        uint256 startMargin;        // initial margin when the loan opened\\n        uint256 startRate;          // reference rate when the loan opened for converting collateralToken to loanToken\\n        address borrower;           // borrower of this loan\\n        address lender;             // lender of this loan\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/objects/LoanParamsStruct.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LoanParamsStruct {\\n    struct LoanParams {\\n        bytes32 id;                 // id of loan params object\\n        bool active;                // if false, this object has been disabled by the owner and can't be used for future loans\\n        address owner;              // owner of this object\\n        address loanToken;          // the token being loaned\\n        address collateralToken;    // the required collateral token\\n        uint256 minInitialMargin;   // the minimum allowed initial margin\\n        uint256 maintenanceMargin;  // an unhealthy loan when current margin is at or below this value\\n        uint256 maxLoanTerm;        // the maximum term for new loans (0 means there's no max term)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/objects/OrderStruct.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract OrderStruct {\\n    struct Order {\\n        uint256 lockedAmount;           // escrowed amount waiting for a counterparty\\n        uint256 interestRate;           // interest rate defined by the creator of this order\\n        uint256 minLoanTerm;            // minimum loan term allowed\\n        uint256 maxLoanTerm;            // maximum loan term allowed\\n        uint256 createdTimestamp;       // timestamp when this order was created\\n        uint256 expirationTimestamp;    // timestamp when this order expires\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/objects/LenderInterestStruct.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LenderInterestStruct {\\n    struct LenderInterest {\\n        uint256 principalTotal;     // total borrowed amount outstanding of asset\\n        uint256 owedPerDay;         // interest owed per day for all loans of asset\\n        uint256 owedTotal;          // total interest owed for all loans of asset (assuming they go to full term)\\n        uint256 paidTotal;          // total interest paid so far for asset\\n        uint256 updatedTimestamp;   // last update\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/objects/LoanInterestStruct.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity 0.5.17;\\n\\n\\ncontract LoanInterestStruct {\\n    struct LoanInterest {\\n        uint256 owedPerDay;         // interest owed per day for loan\\n        uint256 depositTotal;       // total escrowed interest for loan\\n        uint256 updatedTimestamp;   // last update\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWbase.sol\": {\r\n      \"content\": \"/**\\n * Copyright 2017-2020, bZeroX, LLC. All Rights Reserved.\\n * Licensed under the Apache License, Version 2.0.\\n */\\n\\npragma solidity >=0.5.0 <0.6.0;\\n\\n\\ninterface IWbase {\\n    function deposit() external payable;\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendingProtocol\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isLiquidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowedToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"loanId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountToLiquidate\",\"type\":\"uint256\"}],\"name\":\"liquidateLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"profitAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"renounceLiquidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"setLiquidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendingProtocol\",\"type\":\"address\"}],\"name\":\"setProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidateCaller", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000e1d89f326721939d89dc17e993afa4b335628c48000000000000000000000000bc0ee23c8a355f051a9309bce676f818d35743d1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}