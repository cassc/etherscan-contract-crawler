{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MultiWalletToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.19;\\nimport {Ownable, Context} from \\\"./Ownable.sol\\\";\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\nimport {InfoTokenSociety} from \\\"./InfoTokenSociety.sol\\\";\\nimport {Social} from \\\"./Social.sol\\\";\\nimport {IPancakeFactory} from \\\"./IPancakeFactory.sol\\\";\\nimport {IPancakePair} from \\\"./IPancakePair.sol\\\";\\nimport {IPancakeRouter02} from \\\"./IPancakeRouter02.sol\\\";\\nimport {Fee} from \\\"./Fee.sol\\\";\\nimport {AntiBotInterface} from \\\"./AntiBotInterface.sol\\\";\\nimport {ReflexDistributor} from \\\"./ReflexDistributor.sol\\\";\\nimport {RouterDex} from \\\"./RouterDex.sol\\\";\\nimport {IPancakeFactory} from \\\"./IPancakeFactory.sol\\\";\\n\\ncontract MultiWalletToken is Context, IERC20, Ownable{\\n    //Contrato Criado na:  www.prevenda.finance \\n    //voc\u00ea tamb\u00e9m pode criar seu lan\u00e7amento justo, sua pre-venda seu stake e muito mais... \\n    //suporte via telegram: @luiztoken\\n\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals = 18;\\n    address antibotManager;\\n    address public immutable deadAddress = address(0);\\n    mapping (address => uint256) _balances;\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n    mapping (address => bool) public noF;\\n    string public site;\\n    string public telegram;\\n    string public twitter;\\n    ReflexDistributor public distributor;\\n    uint256 distributorGas = 3000;\\n    bool public feeInBNB;\\n\\n    uint256 private _totalSupply;\\n    bool public sellTaxEnabled;\\n    bool public buyTaxEnabled;\\n    IPancakeRouter02 public uniswapV2Router;\\n    Fee[] public taxes;\\n    bool inSwapAndLiquify;\\n    uint256 public reflectionFee;\\n    uint256 public reflectionThreshold;\\n    mapping (address => bool) public isDividendExempt;\\n\\n    receive() external payable {}\\n\\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    constructor (\\n        InfoTokenSociety memory infoToken,\\n        address router,\\n        address creator,\\n        uint256 burnQuantity,\\n        Social memory social,\\n        Fee[] memory _taxes,\\n        address _antibotManager,\\n        address rewardToken,\\n        uint256 minStakeToRewardInHours,\\n        bool _feeInBNB,\\n        uint256 _reflectionFee\\n    )  {\\n        for(uint256 i = 0; i < _taxes.length; i++){\\n            if(_taxes[i].wallet == address(0)) continue;\\n            taxes.push(_taxes[i]);\\n            noF[_taxes[i].wallet] = true;\\n        }\\n        isDividendExempt[address(this)] = true;\\n        isDividendExempt[0x000000000000000000000000000000000000dEaD] = true;\\n        isDividendExempt[address(0)] = true;\\n        reflectionFee = _reflectionFee;\\n        feeInBNB = _feeInBNB;\\n        distributor = new ReflexDistributor(router,rewardToken, minStakeToRewardInHours);\\n        antibotManager = _antibotManager;\\n        buyTaxEnabled = infoToken.buyTax;\\n        sellTaxEnabled = infoToken.sellTax;\\n        site = social.site;\\n        telegram = social.telegram;\\n        twitter = social.twitter;\\n        _name = infoToken.name;\\n        _symbol = infoToken.symbol;\\n        _totalSupply = infoToken.totalSupply  * 10 ** _decimals;\\n        uniswapV2Router = IPancakeRouter02(router);\\n        _allowances[address(this)][address(uniswapV2Router)] = _totalSupply;\\n        noF[creator] = true;\\n        noF[address(this)] = true;\\n        noF[_msgSender()] = true;\\n        _balances[creator] = _totalSupply;\\n        reflectionThreshold = _totalSupply * 2 / 4000;\\n        emit Transfer(address(0), creator, _totalSupply);\\n        if(burnQuantity > 0){\\n            _burn(creator, burnQuantity * 10 ** _decimals);\\n        }\\n    }\\n    function toggleFeeInBNB(bool newValue) external onlyOwner {\\n        feeInBNB = newValue;\\n    }\\n    function toggleSellTax(bool newStatus) external onlyOwner {\\n        sellTaxEnabled = newStatus;\\n    }\\n    function toggleBuyTax(bool newStatus) external onlyOwner {\\n        buyTaxEnabled = newStatus;\\n    }\\n    function _totalTaxIfSelling() public view returns(uint256){\\n        if(!sellTaxEnabled) return 0;\\n        uint256 retorno = 0;\\n        for(uint256 i = 0; i < taxes.length; i++){\\n            retorno = retorno.add(taxes[i].percentage);\\n        }\\n        return retorno.add(reflectionFee);\\n    }\\n    function _totalTaxIfBuying() public view returns(uint256){\\n        if(!buyTaxEnabled) return 0;\\n        uint256 retorno = 0;\\n        for(uint256 i = 0; i < taxes.length; i++){\\n            retorno = retorno.add(taxes[i].percentage);\\n        }\\n        return retorno.add(reflectionFee);\\n    }\\n    function updateTax(address _wallet, uint256 _percentage) public onlyOwner {\\n        for(uint8 i = 0; i < taxes.length; i++ ){\\n            if(taxes[i].wallet == _wallet){\\n                taxes[i].percentage = _percentage;\\n            }\\n        }\\n    }\\n    function isMarketPair(address _pair) public view returns(bool){\\n        if(!_pair.isContract()) return false;\\n        try IPancakePair(_pair).token0() returns (address){\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n    function taxesList() external view returns(Fee[] memory){\\n        return taxes;\\n    }\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n    function setnoF(address account, bool newValue) public onlyOwner() {\\n        noF[account] = newValue;\\n    }\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply.sub(balanceOf(deadAddress));\\n    }\\n    function transferToAddressETH(address payable recipient, uint256 amount) private {\\n        recipient.transfer(amount);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n    function _transfer(address sender, address recipient, uint256 amount) private returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(amount > 0, \\\"Transfer amount must be greater than zero\\\");\\n        if(inSwapAndLiquify) return _basicTransfer(sender, recipient, amount);\\n\\n        if(!noF[sender] && !noF[recipient]){\\n            AntiBotInterface(antibotManager).safeTransfer(sender, recipient, amount);\\n        }\\n        \\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n        uint256 finalAmount = (noF[sender] || noF[recipient]) ?\\n                                        amount : takeFee(sender, recipient, amount);\\n        _balances[recipient] = _balances[recipient].add(finalAmount);\\n        if(!isDividendExempt[sender]) {\\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\\n        }\\n        if(!isDividendExempt[recipient]) {\\n            try distributor.setShare(recipient, _balances[recipient]) {} catch {} \\n        }\\n        try distributor.process(distributorGas) {} catch {}\\n\\n        emit Transfer(sender, recipient, finalAmount);\\n        return true;\\n    }\\n    function takeFee(address sender, address recipient, uint256 amount) internal  lockTheSwap returns (uint256) {\\n        uint256 feeAmount = 0;\\n        if(isMarketPair(sender)) {\\n            feeAmount = amount.mul(_totalTaxIfBuying()).div(1000);\\n        } else if(isMarketPair(recipient)) {\\n            feeAmount = amount.mul(_totalTaxIfSelling()).div(1000);\\n        }\\n        if(feeAmount > 0) {\\n            feeAmount = 0;\\n            uint256 amountReflection = amount.mul(reflectionFee).div(1000);\\n            _balances[address(this)] = _balances[address(this)].add(amountReflection);\\n            emit Transfer(sender, address(this), amountReflection);\\n            if(!isMarketPair(sender) && _balances[address(this)] >= reflectionThreshold){\\n                swapForBNB(address(this), _balances[address(this)]);\\n                if(address(this).balance > 0){\\n                    try distributor.deposit{value: address(this).balance}() {} catch {}\\n                }\\n            }\\n            feeAmount = amountReflection;\\n            for(uint8 i = 0; i < taxes.length; i++){\\n                uint256 _amountToTransfer = amount.mul(taxes[i].percentage).div(1000);\\n                if(feeInBNB){\\n                    uint256 amountBefore = address(this).balance;\\n                    swapForBNB(address(this), _amountToTransfer);\\n                    uint256 amountFinal = address(this).balance.sub(amountBefore);\\n                    if(amountFinal > 0){\\n                        payable(taxes[i].wallet).transfer(amountFinal);\\n                    }\\n                } else {\\n                    _balances[taxes[i].wallet] = _balances[taxes[i].wallet].add(_amountToTransfer);\\n                    emit Transfer(sender, taxes[i].wallet, _amountToTransfer);\\n                }\\n                feeAmount = feeAmount.add(_amountToTransfer);\\n            }\\n        }\\n        return amount.sub(feeAmount);\\n    }\\n    function swapForBNB(address to, uint256 amount) internal {\\n        if(!haveLiquidity(address(this),uniswapV2Router.WETH())) return;\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amount,\\n            0,\\n            path,\\n            to,\\n            block.timestamp\\n        );\\n    }\\n    function haveLiquidity(address tokenA, address tokenB) internal view returns(bool) {\\n        address pair = IPancakeFactory(uniswapV2Router.factory()).getPair(tokenA, tokenB);\\n        if(pair == address(0)) return false;\\n        if(IPancakePair(pair).totalSupply() > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _balances[deadAddress] = _balances[deadAddress] + amount;\\n        emit Transfer(account, deadAddress, amount);\\n    }\\n    function burn(uint256 _amount) external{\\n        _burn(_msgSender(), _amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/IPancakeFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\ninterface IPancakeFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n\\n    function INIT_CODE_PAIR_HASH() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"contracts/RouterDex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.19;\\n\\ninterface RouterDex {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/ReflexDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity 0.8.19;\\n\\nimport {IReflexDistributor} from \\\"./IReflexDistributor.sol\\\";\\nimport {SafeMath} from \\\"./SafeMath.sol\\\";\\nimport {RouterDex} from \\\"./RouterDex.sol\\\";\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IPancakeFactory} from \\\"./IPancakeFactory.sol\\\";\\nimport {IPancakePair} from \\\"./IPancakePair.sol\\\";\\n\\ncontract ReflexDistributor is IReflexDistributor {\\n\\n    using SafeMath for uint256;\\n    address _token;\\n\\n    struct Share {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n    }\\n\\n    RouterDex router;\\n    IERC20 public RewardToken;\\n\\n    address[] shareholders;\\n    mapping (address => uint256) shareholderIndexes;\\n    mapping (address => uint256) shareholderClaims;\\n    mapping (address => Share) public shares;\\n\\n    uint256 public totalShares;\\n    uint256 public totalDividends;\\n    uint256 public totalDistributed;\\n    uint256 public dividendsPerShare;\\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 2;\\n\\n    uint256 public minPeriod = 5 minutes;\\n    uint256 public minDistribution = 1 * (10 ** 2);\\n\\n    uint256 currentIndex;\\n\\n    bool initialized;\\n    modifier initialization() {\\n        require(!initialized);\\n        _;\\n        initialized = true;\\n    }\\n\\n    modifier onlyToken() {\\n        require(msg.sender == _token); _;\\n    }\\n\\n    constructor (address _router, address _rewardToken, uint256 _minPeriodInHours) {\\n        router = RouterDex(_router);\\n        RewardToken = IERC20(_rewardToken);\\n        minPeriod = _minPeriodInHours * 60 * 60;\\n        _token = msg.sender;\\n    }\\n\\n    function setDistributionCriteria(uint256 newMinPeriod, uint256 newMinDistribution) external override onlyToken {\\n        minPeriod = newMinPeriod;\\n        minDistribution = newMinDistribution;\\n    }\\n\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\n        //se o comprador  j\u00e1 tiver saldo, distribui os dividendos\\n        if(shares[shareholder].amount > 0){\\n            distributeDividend(shareholder);\\n        }\\n        // se a quantidade for maior que 0 e o comprador n\u00e3o tiver saldo, adiciona comprador a lista de acionistas\\n        if(amount > 0 && shares[shareholder].amount == 0){\\n            addShareholder(shareholder);\\n        // se a quantidade for 0 e o comprador tiver saldo, remove o comprador da lista de acionistas    \\n        }else if(amount == 0 && shares[shareholder].amount > 0){\\n            removeShareholder(shareholder);\\n        }\\n        // quantidade total de a\u00e7oes - quantidade de a\u00e7oes do comprador + quantidade (1000 - 100 + 200 = 1100)\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\n        // quantidade de a\u00e7oes do comprador = quantidade recebida na fun\u00e7\u00e3o\\n        shares[shareholder].amount = amount;\\n        // adiciona ao total de exclus\u00e3o do holder a quantidade de a\u00e7\u00f5es do holder\\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n    }\\n\\n    function deposit() external payable override onlyToken {\\n        if(!haveLiquidity(router.WETH(), address(RewardToken))) return;\\n\\n        // saldo inicial do token de recompensa\\n        uint256 balanceBefore = RewardToken.balanceOf(address(this));\\n\\n        address[] memory path = new address[](2);\\n        path[0] = router.WETH();\\n        path[1] = address(RewardToken);\\n        //troca BNB recebido na fun\u00e7\u00e3o por token de recompensa\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        // calcula a quantidade recebida de token de recompensa\\n        uint256 amount = RewardToken.balanceOf(address(this)).sub(balanceBefore);\\n        // total de dividendos + quantidade recebida (1000 + 200 = 1200)\\n        totalDividends = totalDividends.add(amount);\\n        // quantidade de dividendos por a\u00e7\u00e3o + quantdade por a\u00e7\u00e3o fator x quantidade recebida / quantidade total de a\u00e7\u00f5es (1000 + 100 x 200 / 1000 = 1020)\\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\n    }\\n\\n    function process(uint256 gas) external override onlyToken {\\n        // quantidade de acionistas\\n        uint256 shareholderCount = shareholders.length;\\n        // se n\u00e3o tiver acionistas, retorna\\n        if(shareholderCount == 0) { return; }\\n\\n        uint256 iterations = 0;\\n        uint256 gasUsed = 0;\\n        uint256 gasLeft = gasleft();\\n        // enquanto o g\u00e1s usado \u00e9 menor que o g\u00e1s passado & as itera\u00e7\u00f5es s\u00e3o menores que a quantidade de acionistas\\n        while(gasUsed < gas && iterations < shareholderCount) {\\n            // se o indice atual for maior ou igual a quantidade de acionistas, o indice atual \u00e9 0\\n            if(currentIndex >= shareholderCount){ currentIndex = 0; }\\n            // se tiver saldo para distribuir para o acionista atual\\n            if(shouldDistribute(shareholders[currentIndex])){\\n                // distribui os dividendos para o acionista atual\\n                distributeDividend(shareholders[currentIndex]);\\n            }\\n            // g\u00e1s usado + gas restante pr\u00e9 execu\u00e7\u00e3o - gas restante p\u00f3s execu\u00e7\u00e3o\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\n            // g\u00e1s restante = gas restante p\u00f3s execu\u00e7\u00e3o\\n            gasLeft = gasleft();\\n            currentIndex++;\\n            iterations++;\\n        }\\n    }\\n    \\n    function shouldDistribute(address shareholder) internal view returns (bool) {\\n        // se a ultima distribui\u00e7\u00e3o para o acionista + o periodo minimo para distribui\u00e7\u00e3o for menor que o timestamp atual\\n        // & a quantidade de dividendos n\u00e3o pagos para o acionista form maior que a quantidade minima de distribui\u00e7\u00e3o\\n        return shareholderClaims[shareholder] + minPeriod < block.timestamp\\n                && getUnpaidEarnings(shareholder) > minDistribution;\\n    }\\n\\n    function distributeDividend(address shareholder) internal {\\n        // se o holder n\u00e3o tiver saldo, retorna\\n        if(shares[shareholder].amount == 0){ return; }\\n        //pega a quantidade de dividendos n\u00e3o pagos para o holder\\n        uint256 amount = getUnpaidEarnings(shareholder);\\n\\n        if(amount > 0){\\n            //total distribuido + quantidade para distribuir\\n            totalDistributed = totalDistributed.add(amount);\\n            //transfere a quantidade do token de recompensa para o holder\\n            RewardToken.transfer(shareholder, amount);\\n            //atualiza a data do ultimo pagamento para o holder\\n            shareholderClaims[shareholder] = block.timestamp;\\n            //seta a quantidade paga = quantidade paga holder + quantidade para distribuir\\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\\n            //seta a quantidade excluida do holder = pega a quantidade cumulativa de dividendos do holder\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n        }\\n\\n    }\\n\\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\\n        //se o holder n\u00e3o tiver saldo, retorna 0\\n        if(shares[shareholder].amount == 0){ return 0; }\\n        //pega a quantiade cumulativa de dividendos do holder\\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\n        //pega a quantidade de dividendos j\u00e1 pagos\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\n        // se a quantidade de dividendos for menorou igual a quantidade paga retorna 0\\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\\n        //retorna a quantidade de dividendos - a quantidade paga\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\n    }\\n\\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\\n        //quantidae de dividendos x 511500 / 100 (200*511500/100 = 1023000)\\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\n    }\\n\\n    function addShareholder(address shareholder) internal {\\n        shareholderIndexes[shareholder] = shareholders.length;\\n        shareholders.push(shareholder);\\n    }\\n\\n    function removeShareholder(address shareholder) internal {\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\n        shareholders.pop();\\n    }\\n    \\n    function claimDividend(address holder) external override {\\n        distributeDividend(holder);\\n    }\\n    function haveLiquidity(address tokenA, address tokenB) internal view returns(bool) {\\n        address pair = IPancakeFactory(router.factory()).getPair(tokenA, tokenB);\\n        if(pair == address(0)) return false;\\n        if(IPancakePair(pair).totalSupply() > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\"\r\n    },\r\n    \"contracts/AntiBotInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity 0.8.19;\\ninterface AntiBotInterface {\\n    function safeTransfer(address from, address to, uint256 amount) external;\\n    function enableContractFromContract(address _newContract, address _tokenOwner) external;\\n}\"\r\n    },\r\n    \"contracts/Fee.sol\": {\r\n      \"content\": \"pragma solidity 0.8.19;\\n// SPDX-License-Identifier: Unlicensed\\n\\nstruct Fee {\\n    uint256 percentage;\\n    address wallet;\\n}\\n\"\r\n    },\r\n    \"contracts/IPancakeRouter02.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.6.2;\\nimport \\\"./IPancakeRouter01.sol\\\";\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/IPancakePair.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"contracts/Social.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.14;\\n\\nstruct Social {\\n    string site;\\n    string telegram;\\n    string twitter;\\n}\"\r\n    },\r\n    \"contracts/InfoTokenSociety.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nstruct InfoTokenSociety {\\n    string name;\\n    string symbol;\\n    uint256 totalSupply;\\n    bool buyTax;\\n    bool sellTax;\\n    address antibotManager;\\n}\"\r\n    },\r\n    \"contracts/Address.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\ncontract Ownable is Context {\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n        _;\\n    }\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/IReflexDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.19;\\n\\ninterface IReflexDistributor {\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\\n    function setShare(address shareholder, uint256 amount) external;\\n    function deposit() external payable;\\n    function process(uint256 gas) external;\\n    function claimDividend(address holder) external;\\n}\"\r\n    },\r\n    \"contracts/IPancakeRouter01.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buyTax\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sellTax\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"antibotManager\",\"type\":\"address\"}],\"internalType\":\"struct InfoTokenSociety\",\"name\":\"infoToken\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnQuantity\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"site\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"telegram\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"twitter\",\"type\":\"string\"}],\"internalType\":\"struct Social\",\"name\":\"social\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"internalType\":\"struct Fee[]\",\"name\":\"_taxes\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_antibotManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeToRewardInHours\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_feeInBNB\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_totalTaxIfBuying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalTaxIfSelling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"contract ReflexDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeInBNB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDividendExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"isMarketPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noF\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"setnoF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"site\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"taxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"internalType\":\"struct Fee[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"telegram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"toggleBuyTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"}],\"name\":\"toggleFeeInBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"toggleSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twitter\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"updateTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MultiWalletToken", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000016000000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000a4cbd4566916871ca8b81e7669edc47cb66e24f800000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000003600000000000000000000000005e1b8ab7740fe06ab0c7230aa4af6bf0c21f55d5000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000005e1b8ab7740fe06ab0c7230aa4af6bf0c21f55d500000000000000000000000000000000000000000000000000000000000000055441544154000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000354415400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000050000000000000000000000000a4cbd4566916871ca8b81e7669edc47cb66e24f8", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a9cd19fba2c7b8a1c3a234a86cc7758bdce8ee50c7e17e0003e58dd3dd5d08cf"}