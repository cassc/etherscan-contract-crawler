{"SourceCode": "/*\r\nSubmitted for verification at BscScan.com on 2022-02-05\r\n*/\r\n\r\n// owner 0x238BC8a032B6c06E2f015C3E60d43DA8Ac8115EB\r\n// busd  0xe9e7cea3dedca5984780bafc599bd69add087d56\r\n// elucks   0xd356e3Fa422970baBD05d9FE2D8571Dc39172Dde\r\n\r\n//  Elucks\r\n\r\npragma solidity 0.5.4;\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender)\r\n  external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value)\r\n  external returns (bool);\r\n  \r\n  function transferFrom(address from, address to, uint256 value)\r\n  external returns (bool);\r\n  function burn(uint256 value)\r\n  external returns (bool);\r\n  event Transfer(address indexed from,address indexed to,uint256 value);\r\n  event Approval(address indexed owner,address indexed spender,uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ElucksStakingProgram  {\r\n     using SafeMath for uint256;\r\n     \r\n    struct Staking {\r\n        uint256 programId;\r\n        uint256 stakingDate;\r\n        uint256 staking;\r\n        uint256 lastWithdrawalDate;\r\n        uint256 currentRewards;\r\n        bool    isExpired;\r\n        uint256 genRewards;\r\n        uint256 stakingToken;\r\n        bool    isAddedStaked;\r\n    }\r\n\r\n    struct Program {\r\n        uint256 dailyInterest;\r\n        uint256 term; //0 means unlimited\r\n        uint256 maxDailyInterest;\r\n    }\r\n  \r\n     \r\n    struct User {\r\n        uint id;\r\n        address referrer;\r\n        uint256 referralReward;\r\n        uint256 selfBuy;\r\nuint256 selfSell;\r\n        uint256 programCount;\r\n        uint256 totalStakingBusd;\r\n        uint256 totalStakingToken;\r\n        uint256 currentPercent;\r\n        uint256 compoundReward;\r\n        uint256 freeStakedToken;\r\n        mapping(uint256 => Staking) programs;\r\n        mapping(uint256 => uint256) refStake;\r\n        mapping(uint256 => uint256) refUser;\r\n    }\r\n    \r\n    \r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n    mapping(address => uint8) public position;\r\n    mapping(address => bool) public isStop;\r\n    Program[] private stakingPrograms_;\r\n    \r\n    uint256 private constant INTEREST_CYCLE = 1 days;\r\n\r\n    uint public lastUserId = 2;\r\n    uint256 public tokenPrice = 3*1e16;\r\n    uint256  priceIncPercent=230;\r\n    uint256  priceDecPercent=230;\r\n    bool public isAdminOpen;\r\n    \r\n    uint256 public  total_staking_token = 0;\r\n    uint256 public  total_staking_busd = 0;\r\n    uint256 public  total_virtual_staking = 0;\r\n    \r\n    uint256 public  total_withdraw_token = 0;\r\n    uint256 public  total_withdraw_busd = 0;\r\n    uint256 public  total_virtual_withdraw = 0;\r\n    \r\n    uint256 public  total_token_buy = 0;\r\nuint256 public  total_token_sell = 0;\r\n    \r\n    \r\n    uint64 public  priceIndex = 1;\r\n    bool   public  buyOn = true;\r\n    bool   public  sellOn = true;\r\n    bool   public  stakingOn = true;\r\n    bool   public  withdrawOn = true;\r\n    \r\n    uint256 public  MINIMUM_BUY = 1e18;\r\n    uint256 public  MINIMUM_SELL = 666*1e18;\r\n    uint256 public MAXIMUM_SELL = 1666*1e18;\r\n    uint256 public  priceUpdateGap = 100*1e18;\r\n    \r\n    address public owner;\r\n    \r\n    mapping(uint64 => uint) public buyLevel;\r\n    mapping(uint64 => uint) public sellLevel;\r\n    mapping(uint64 => uint) public priceLevel;\r\n    \r\n  \r\n    event Registration(address indexed user, address indexed referrer, uint indexed userId, uint referrerId);\r\n    event CycleStartedToken(address indexed user,uint256 stakeID, uint256 walletUsedToken, uint256 rewardUsedToken,uint256 compoundUsedToken,  uint256 tokenPrice);\r\n    event CycleStartedBusd(address indexed user,uint256 stakeID, uint256 walletUsedBusd, uint256 rewardUsedBusd,uint256 compoundUsedBusd, uint256 tokenPrice);\r\n    event TokenDistribution(address indexed sender, address indexed receiver, uint total_token, uint live_rate, uint busd_amount);\r\n    event onWithdraw(address  _user, uint256 withdrawalAmount,uint256 withdrawalAmountToken);\r\n    event ReferralReward(address  _user,address _from,uint256 reward);\r\n    IBEP20 private elucksToken; \r\n    IBEP20 private busdToken; \r\n\r\n    constructor(address ownerAddress, IBEP20 _busdToken, IBEP20 _elucksToken) public \r\n    {\r\n        owner = ownerAddress;\r\n        \r\n        elucksToken = _elucksToken;\r\n        busdToken = _busdToken;\r\n        \r\nstakingPrograms_.push(Program(33,300*24*60*60,33)); //300 days and 0.33%\r\n  \r\n        User memory user = User({\r\n            id: 1,\r\n            referrer: address(0),\r\n            referralReward: uint(0),\r\n            selfBuy: uint(0),\r\n            selfSell: uint(0),\r\n            programCount: uint(0),\r\n            totalStakingBusd: uint(0),\r\n            totalStakingToken: uint(0),\r\n            currentPercent: uint(0),\r\n            compoundReward:uint(0),\r\n            freeStakedToken:uint(0)\r\n        });\r\n        users[ownerAddress] = user;\r\n        idToAddress[1] = ownerAddress;\r\n    } \r\n    \r\n    function() external payable \r\n    {\r\n        if(msg.data.length == 0) {\r\n            return registration(msg.sender, owner);\r\n        }\r\n        \r\n        registration(msg.sender, bytesToAddress(msg.data));\r\n    }\r\n\r\n    function withdrawBalance(uint256 amt,uint8 _type) public \r\n    {\r\n        require(msg.sender == owner, \"onlyOwner\");\r\n        if(_type==1)\r\n        msg.sender.transfer(amt);\r\n        else if(_type==2)\r\n        busdToken.transfer(msg.sender,amt);\r\n        else\r\n        elucksToken.transfer(msg.sender,amt);\r\n    }\r\n    \r\n \r\n    function registration(address userAddress, address referrerAddress) public \r\n    {\r\n        require(!isUserExists(userAddress), \"user exists\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists\");\r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        \r\n        require(size == 0, \"cannot be a contract\");\r\n        \r\n        User memory user = User({\r\n            id: lastUserId,\r\n            referrer: referrerAddress,\r\n            referralReward: 0,\r\n            selfBuy: 0,\r\n            selfSell: 0,\r\n            programCount: 0,\r\n            totalStakingBusd: 0,\r\n            totalStakingToken: 0,\r\n            currentPercent: 0,\r\n            compoundReward: 0,\r\n            freeStakedToken:0\r\n        });\r\n        users[userAddress] = user;\r\n        idToAddress[lastUserId] = userAddress;\r\n        \r\n        users[userAddress].referrer = referrerAddress;\r\n        \r\n        lastUserId++;\r\n        \r\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\r\n    }\r\n    \r\n    // Staking Process\r\n    \r\n    function start_staking(uint256 walletUsedBusd,uint256 rewardUsedBusd,uint256 compoundUsedBusd,uint256 _programId,address referrer) public \r\n    {\r\n        require(stakingOn,\"Staking Stopped.\");\r\n        require(!isStop[msg.sender],\"Contact Support.\");\r\n        if(!isUserExists(msg.sender))\r\n        {\r\n            registration(msg.sender, referrer);   \r\n        }\r\n        else\r\n        {\r\n            updateRewards();\r\n        }\r\n        \r\n        \r\n        // ***wallet balance*** \r\n        uint256 walletUsed=(walletUsedBusd.mul(1e18)).div(tokenPrice);\r\n       require(elucksToken.balanceOf(msg.sender)>=walletUsed,\"Low wallet balance\");\r\n        require(elucksToken.allowance(msg.sender,address(this))>=walletUsed,\"Allow token first\");\r\n        \r\n        // ***level balance***\r\n        require(users[msg.sender].referralReward>=rewardUsedBusd,\"Low reward balance\");\r\n        uint256 rewardUsed=(rewardUsedBusd.mul(1e18)).div(tokenPrice);\r\n        \r\n        \r\n        // ***compound balance***\r\n        \r\n        require(users[msg.sender].compoundReward>=compoundUsedBusd,\"Low Compound balance\");\r\n        uint256 compoundUsed=(compoundUsedBusd.mul(1e18)).div(tokenPrice);\r\n        \r\n        require(_programId>=0 && _programId<stakingPrograms_.length, \"Wrong staking program id\");\r\n        \r\n        uint256 _amount=walletUsed+rewardUsed+compoundUsed;\r\n        elucksToken.transferFrom(msg.sender,address(this),walletUsed);\r\n       \r\n        uint256 _busdAmount=walletUsedBusd+rewardUsedBusd+compoundUsedBusd;\r\n        require(_busdAmount>=10*1e18, \"Minimum 10 BUSD\");\r\n        \r\n        \r\n        require(isUserExists(msg.sender), \"user not exists\");\r\n        uint256 programCount = users[msg.sender].programCount;\r\n        users[msg.sender].referralReward=users[msg.sender].referralReward-rewardUsedBusd;\r\n        users[msg.sender].compoundReward=users[msg.sender].compoundReward-compoundUsedBusd;\r\n        \r\n        users[msg.sender].programs[programCount].programId = _programId;\r\n        users[msg.sender].programs[programCount].stakingDate = block.timestamp;\r\n        users[msg.sender].programs[programCount].lastWithdrawalDate = block.timestamp;\r\n        users[msg.sender].programs[programCount].staking = _busdAmount;\r\n        users[msg.sender].programs[programCount].currentRewards = 0;\r\n        users[msg.sender].programs[programCount].genRewards = 0;\r\n        users[msg.sender].programs[programCount].isExpired = false;\r\n        users[msg.sender].programs[programCount].stakingToken = _amount;\r\n        users[msg.sender].programCount = users[msg.sender].programCount.add(1);\r\n        \r\n        users[msg.sender].totalStakingToken = users[msg.sender].totalStakingToken.add(_amount);\r\n        users[msg.sender].totalStakingBusd = users[msg.sender].totalStakingBusd.add(_busdAmount);\r\n        users[msg.sender].currentPercent=getStakingPercent(msg.sender);\r\n        address referrerAddress=users[msg.sender].referrer;\r\n        for(uint8 i=0;i<10;i++)\r\n        {\r\n          if(users[msg.sender].programCount==1)     \r\n          users[referrerAddress].refUser[i]=users[referrerAddress].refUser[i]+1;\r\n          users[referrerAddress].refStake[i]=users[referrerAddress].refStake[i]+_amount;\r\n             \r\n          if(users[referrerAddress].referrer!=address(0))\r\n          referrerAddress=users[referrerAddress].referrer;\r\n          else\r\n          break;\r\n        }\r\n        \r\n        \r\n        if(msg.sender!=owner)\r\n        _calculateReferrerReward(_busdAmount,users[msg.sender].referrer);\r\n        \r\n        total_staking_busd=total_staking_busd+_busdAmount;\r\n        total_virtual_staking=total_virtual_staking+_busdAmount;\r\n        total_staking_token=total_staking_token+_amount;\r\n        \r\n        if(total_virtual_staking>=priceUpdateGap && !isAdminOpen)\r\n        updateTokenPrice(1);\r\n        uint256 walletBusd=walletUsedBusd;\r\n        uint256 rewardBusd=rewardUsedBusd;\r\n        uint256 compoundBusd=compoundUsedBusd;\r\n        emit CycleStartedToken(msg.sender,users[msg.sender].programCount, walletUsed, rewardUsed,compoundUsed,tokenPrice);\r\n        emit CycleStartedBusd(msg.sender,users[msg.sender].programCount, walletBusd, rewardBusd,compoundBusd,tokenPrice);\r\n    }\r\n\r\n    function buyToken(uint256 tokenQty) public payable\r\n    {\r\n         require(buyOn,\"Buy Stopped.\");\r\n         require(!isContract(msg.sender),\"Can not be contract\");\r\n         require(isUserExists(msg.sender), \"user not exists\");\r\n         require(tokenQty>=MINIMUM_BUY,\"Invalid minimum quantity\");\r\n         uint256 buy_amt=(tokenQty/1e18)*tokenPrice;\r\n         require(busdToken.balanceOf(msg.sender)>=(buy_amt),\"Low Balance\");\r\n         require(busdToken.allowance(msg.sender,address(this))>=buy_amt,\"Invalid buy amount\");\r\n         \r\n         users[msg.sender].selfBuy=users[msg.sender].selfBuy+tokenQty;\r\n         busdToken.transferFrom(msg.sender ,address(this), (buy_amt));\r\n         elucksToken.transfer(msg.sender , tokenQty);\r\n         \r\n         total_token_buy=total_token_buy+tokenQty;\r\n         emit TokenDistribution(address(this), msg.sender, tokenQty, tokenPrice, buy_amt);                  \r\n     }\r\n\r\n    function sellToken(uint256 tokenQty) public payable\r\n    {\r\n         require(sellOn,\"sell Stopped.\");\r\n         require(!isContract(msg.sender),\"Can not be contract\");\r\n         require(isUserExists(msg.sender), \"user not exists\");\r\n         require(tokenQty>=MINIMUM_SELL,\"Invalid minimum quantity\");\r\n         require(tokenQty<=MAXIMUM_SELL,\"Invalid maximum quantity\");\r\n         uint256 sell_amt=(tokenQty/1e18)*tokenPrice;\r\n         require(elucksToken.balanceOf(msg.sender)>=(sell_amt),\"Low Balance\");\r\n         require(elucksToken.allowance(msg.sender,address(this))>=sell_amt,\"Invalid sell amount\");\r\n         \r\n         users[msg.sender].selfSell=users[msg.sender].selfSell+tokenQty;\r\n         elucksToken.transferFrom(msg.sender ,address(this), (tokenQty));\r\n         busdToken.transfer(msg.sender , sell_amt);\r\n         \r\n                  \r\n     }\r\n     \r\n     // ***Referral Program***\r\n     \r\n    function _calculateReferrerReward(uint256 _staking, address _referrer) private \r\n    {\r\n         uint256 oldPercent;\r\n         uint256 totalPercent;\r\n         for(uint8 i=0;i<10;i++)\r\n         {\r\n             uint256 refPercent=getPercent(_referrer);\r\n             if(refPercent>oldPercent && totalPercent<250)\r\n             {\r\n                uint256 left=refPercent-oldPercent;\r\n                totalPercent=totalPercent+left;\r\n                if(left>0)\r\n                {\r\n                    if(users[_referrer].totalStakingBusd>=_staking)\r\n                    users[_referrer].referralReward=users[_referrer].referralReward+((_staking.mul(left)).div(1000));\r\n                    else\r\n                    {\r\n                        uint256 rest=_staking-users[_referrer].totalStakingBusd;\r\n                        users[_referrer].referralReward=users[_referrer].referralReward+((users[_referrer].totalStakingBusd.mul(left)).div(1000)); \r\n                        users[_referrer].compoundReward=users[_referrer].compoundReward+((rest.mul(left)).div(1000)); \r\n                    }\r\n                    emit ReferralReward(_referrer,msg.sender,(_staking.mul(left)).div(1000));\r\n                }\r\n                oldPercent=refPercent;\r\n             }\r\n             \r\n             users[_referrer].refStake[i]=users[_referrer].refStake[i]+_staking;\r\n             if(users[_referrer].referrer!=address(0))\r\n             _referrer=users[_referrer].referrer;\r\n             else\r\n             break;\r\n         }\r\n     }\r\n    \r\n    function withdraw() public payable \r\n    {\r\n        require(withdrawOn,\"Withdraw Stopped.\");\r\n        require(!isStop[msg.sender],\"Contact Support.\");\r\n        require(msg.value == 0, \"withdrawal doesn't allow to transfer bnb simultaneously\");\r\n        uint256 uid = users[msg.sender].id;\r\n        require(uid != 0, \"Can not withdraw because no any stakings\");\r\n        uint256 withdrawalAmount = 0;\r\n        for (uint256 i = 0; i < users[msg.sender].programCount; i++) \r\n        {\r\n            if (users[msg.sender].programs[i].genRewards>0) {\r\n                withdrawalAmount += users[msg.sender].programs[i].genRewards;\r\n                users[msg.sender].programs[i].genRewards=0;\r\n            }\r\n            \r\n            if (users[msg.sender].programs[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n            Program storage program = stakingPrograms_[users[msg.sender].programs[i].programId];\r\n\r\n            bool isExpired = false;\r\n            bool isAddedStaked = false;\r\n            uint256 withdrawalDate = block.timestamp;\r\n            if (program.term > 0) {\r\n                uint256 endTime = users[msg.sender].programs[i].stakingDate.add(program.term);\r\n                if (withdrawalDate >= endTime) {\r\n                    withdrawalDate = endTime;\r\n                    isExpired = true;\r\n                    users[msg.sender].freeStakedToken=users[msg.sender].freeStakedToken+users[msg.sender].programs[i].stakingToken;\r\n                    isAddedStaked=true;\r\n                }\r\n            }\r\n\r\n            uint256 amount = _calculateRewards(users[msg.sender].programs[i].staking , users[msg.sender].currentPercent , withdrawalDate , users[msg.sender].programs[i].lastWithdrawalDate , users[msg.sender].currentPercent);\r\n\r\n            withdrawalAmount += amount;            \r\n            \r\n            users[msg.sender].programs[i].lastWithdrawalDate = withdrawalDate;\r\n            users[msg.sender].programs[i].isExpired = isExpired;\r\n            users[msg.sender].programs[i].isAddedStaked = isAddedStaked;\r\n            users[msg.sender].programs[i].currentRewards += amount;\r\n        }\r\n        uint256 referralToken;\r\n        uint256 roiToken=(withdrawalAmount.mul(1e18)).div(tokenPrice);\r\n        if(users[msg.sender].referralReward>0)\r\n        {\r\n            referralToken=(users[msg.sender].referralReward.mul(1e18)).div(tokenPrice);\r\n            users[msg.sender].referralReward=0;\r\n        }\r\n        \r\n        uint256 totalToken=users[msg.sender].freeStakedToken+referralToken+roiToken;\r\n        users[msg.sender].freeStakedToken=0;\r\n        if(totalToken>0)\r\n        {\r\n        elucksToken.transfer(msg.sender,totalToken);\r\n        total_withdraw_busd=total_withdraw_busd+(totalToken.mul(1e18)).div(tokenPrice);\r\n        total_withdraw_token=total_withdraw_token+(totalToken);\r\n        total_virtual_withdraw=total_virtual_withdraw+totalToken;\r\n        if(total_virtual_withdraw>priceUpdateGap && !isAdminOpen)\r\n        updateTokenPrice(2);\r\n        _calculateReferrerReward(withdrawalAmount, users[msg.sender].referrer);\r\n        emit onWithdraw(msg.sender, withdrawalAmount,totalToken);\r\n        }\r\n    }\r\n    \r\n    \r\n    function updateRewards() private\r\n    {\r\n        require(msg.value == 0, \"withdrawal doesn't allow to transfer bnb simultaneously\");\r\n        uint256 uid = users[msg.sender].id;\r\n        require(uid != 0, \"Can not withdraw because no any stakings\");\r\n        uint256 withdrawalAmount = 0;\r\n        for (uint256 i = 0; i < users[msg.sender].programCount; i++) \r\n        {\r\n            if (users[msg.sender].programs[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n            Program storage program = stakingPrograms_[users[msg.sender].programs[i].programId];\r\n\r\n            bool isExpired = false;\r\n            bool isAddedStaked = false;\r\n            uint256 withdrawalDate = block.timestamp;\r\n            if (program.term > 0) {\r\n                uint256 endTime = users[msg.sender].programs[i].stakingDate.add(program.term);\r\n                if (withdrawalDate >= endTime) {\r\n                    withdrawalDate = endTime;\r\n                    isExpired = true;\r\n                    isAddedStaked=true;\r\n                    users[msg.sender].freeStakedToken=users[msg.sender].freeStakedToken+users[msg.sender].programs[i].stakingToken;\r\n                }\r\n            }\r\n\r\n            uint256 amount = _calculateRewards(users[msg.sender].programs[i].staking , users[msg.sender].currentPercent , withdrawalDate , users[msg.sender].programs[i].lastWithdrawalDate , users[msg.sender].currentPercent);\r\n\r\n            withdrawalAmount += amount;\r\n            \r\n            users[msg.sender].programs[i].lastWithdrawalDate = withdrawalDate;\r\n            users[msg.sender].programs[i].isExpired = isExpired;\r\n            users[msg.sender].programs[i].isAddedStaked = isAddedStaked;\r\n            users[msg.sender].programs[i].currentRewards += amount;\r\n            users[msg.sender].programs[i].genRewards += amount;\r\n        }\r\n    }\r\n    \r\n    function getStakingProgramByUID(address _user) public view returns (uint256[] memory, uint256[] memory, uint256[] memory, uint256[] memory,uint256[] memory, bool[] memory, bool[] memory) \r\n    {\r\n       \r\n        User storage staker = users[_user];\r\n        uint256[] memory stakingDates = new  uint256[](staker.programCount);\r\n        uint256[] memory stakings = new  uint256[](staker.programCount);\r\n        uint256[] memory currentRewards = new  uint256[](staker.programCount);\r\n        bool[] memory isExpireds = new  bool[](staker.programCount);\r\n        uint256[] memory newRewards = new uint256[](staker.programCount);\r\n        uint256[] memory genRewards = new uint256[](staker.programCount);\r\n        bool[] memory isAddedStakeds = new bool[](staker.programCount);\r\n\r\n        for(uint256 i=0; i<staker.programCount; i++){\r\n            require(staker.programs[i].stakingDate!=0,\"wrong staking date\");\r\n            currentRewards[i] = staker.programs[i].currentRewards;\r\n            genRewards[i] = staker.programs[i].genRewards;\r\n            isAddedStakeds[i] = staker.programs[i].isAddedStaked;\r\n            stakingDates[i] = staker.programs[i].stakingDate;\r\n            stakings[i] = staker.programs[i].staking;\r\n            if (staker.programs[i].isExpired) {\r\n                isExpireds[i] = true;\r\n                newRewards[i] = 0;\r\n                \r\n            } else {\r\n                isExpireds[i] = false;\r\n                if (stakingPrograms_[staker.programs[i].programId].term > 0) {\r\n                    if (block.timestamp >= staker.programs[i].stakingDate.add(stakingPrograms_[staker.programs[i].programId].term)) {\r\n                        newRewards[i] = _calculateRewards(staker.programs[i].staking, staker.currentPercent, staker.programs[i].stakingDate.add(stakingPrograms_[staker.programs[i].programId].term), staker.programs[i].lastWithdrawalDate, staker.currentPercent);\r\n                        isExpireds[i] = true;\r\n                       \r\n                    }\r\n                    else{\r\n                        newRewards[i] = _calculateRewards(staker.programs[i].staking, staker.currentPercent, block.timestamp, staker.programs[i].lastWithdrawalDate, staker.currentPercent);\r\n                      \r\n                    }\r\n                } else {\r\n                    newRewards[i] = _calculateRewards(staker.programs[i].staking, staker.currentPercent, block.timestamp, staker.programs[i].lastWithdrawalDate, staker.currentPercent);\r\n                 \r\n                }\r\n            }\r\n        }\r\n\r\n        return\r\n        (\r\n        stakingDates,\r\n        stakings,\r\n        currentRewards,\r\n        newRewards,\r\n        genRewards,\r\n        isExpireds,\r\n        isAddedStakeds\r\n        );\r\n    }\r\n    \r\n    function getStakingToken(address _user) public view returns (uint256[] memory) \r\n    {\r\n       \r\n        User storage staker = users[_user];\r\n        uint256[] memory stakings = new  uint256[](staker.programCount);\r\n\r\n        for(uint256 i=0; i<staker.programCount; i++){\r\n            require(staker.programs[i].stakingDate!=0,\"wrong staking date\");\r\n            stakings[i] = staker.programs[i].stakingToken;\r\n        }\r\n\r\n        return\r\n        (\r\n            stakings\r\n        );\r\n    }\r\n\r\n    function _calculateRewards(uint256 _amount, uint256 _dailyInterestRate, uint256 _now, uint256 _start , uint256 _maxDailyInterest) private pure returns (uint256) {\r\n\r\n        uint256 numberOfDays =  (_now - _start) / INTEREST_CYCLE ;\r\n        uint256 result = 0;\r\n        uint256 index = 0;\r\n        if(numberOfDays > 0){\r\n          uint256 secondsLeft = (_now - _start);\r\n           for (index; index < numberOfDays; index++) {\r\n               if(_dailyInterestRate + index <= _maxDailyInterest ){\r\n                   secondsLeft -= INTEREST_CYCLE;\r\n                     result += (_amount * (_dailyInterestRate + index) / 10000 * INTEREST_CYCLE) / (60*60*24);\r\n               }\r\n               else\r\n               {\r\n                 break;\r\n               }\r\n            }\r\n\r\n            result += (_amount * (_dailyInterestRate + index) / 10000 * secondsLeft) / (60*60*24);\r\n\r\n            return result;\r\n\r\n        }else{\r\n            return (_amount * _dailyInterestRate / 10000 * (_now - _start)) / (60*60*24);\r\n        }\r\n\r\n    }\r\n    \r\n    // ***Token Price Algorithm***\r\n    \r\n    function updateTokenPrice(uint8 _type) private\r\n    {\r\n       if(_type==1)\r\n       {\r\n         while(true)\r\n         {\r\n             uint256 tempPrice=(tokenPrice*priceIncPercent)/1000000;\r\n             tokenPrice=tokenPrice+tempPrice;\r\n             total_virtual_staking=total_virtual_staking-priceUpdateGap;\r\n             if(total_virtual_staking<priceUpdateGap)\r\n             return;\r\n         }\r\n       }\r\n       else\r\n       {\r\n         while(true)\r\n         {\r\n             uint256 tempPrice=(tokenPrice.mul(priceDecPercent)).div(1000000);\r\n             tokenPrice=tokenPrice-tempPrice;\r\n             total_virtual_withdraw=total_virtual_withdraw-priceUpdateGap;\r\n             if(total_virtual_withdraw<priceUpdateGap)\r\n             return;\r\n         }\r\n       }\r\n    }\r\n    \r\n    \r\n    // ***Staking Percent***\r\n       function getStakingPercent(address _user) public view returns(uint16)\r\n    {\r\n        require(isUserExists(_user),\"User Not Exist\");\r\n        return 33;\r\n    }\r\n\r\n    //  ***Referral Reward Percent***\r\n    \r\nfunction getPercent(address _user) public view returns(uint16)\r\n    {\r\n        if(position[_user]==0)\r\n        {\r\n            if(!isUserExists(_user))\r\n            return 0;\r\n            uint256 totalDirect=users[_user].refUser[0];\r\n            uint256 totalTeam;\r\n            for(uint8 i=0;i<10;i++)\r\n            {\r\n               totalTeam=totalTeam+users[_user].refUser[i]; \r\n            }\r\n            \r\n            if(totalDirect>=20 && totalTeam>=1000)\r\n            return 250;\r\n            else if(totalDirect>=15 && totalTeam>=500)\r\n            return 200;\r\n            else if(totalDirect>=10 && totalTeam>=50)\r\n            return 150;\r\n            else\r\n            return 50;\r\n        }\r\n        else\r\n        {\r\n            if(position[_user]==1)\r\n            return 150;\r\n            else if(position[_user]==2)\r\n            return 200;\r\n            else if(position[_user]==3)\r\n            return 250;  \r\n        }\r\n    }\r\n\r\n    \r\n    function isContract(address _address) public view returns (bool _isContract)\r\n    {\r\n          uint32 size;\r\n          assembly {\r\n            size := extcodesize(_address)\r\n          }\r\n          return (size > 0);\r\n    }   \r\n   \r\n    \r\n    function openAdminPrice(uint8 _type) public payable\r\n    {\r\n              require(msg.sender==owner,\"Only Owner\");\r\n              if(_type==1)\r\n              isAdminOpen=true;\r\n              else\r\n              {\r\n                isAdminOpen=false;\r\n                total_virtual_staking=0;\r\n                total_virtual_withdraw=0;\r\n              }\r\n    }\r\n    \r\n    function updatePrice(uint256 _price) public payable\r\n    {\r\n              require(msg.sender==owner,\"Only Owner\");\r\n              require(isAdminOpen,\"Admin option not open.\");\r\n              tokenPrice=_price;\r\n    }\r\nfunction updateMaxSell(uint256 _maxsellprice) public payable\r\n    {\r\n              require(msg.sender==owner,\"Only Owner\");\r\n              MAXIMUM_SELL = _maxsellprice;\r\n    }\r\nfunction updateMinSell(uint256 _minsellprice) public payable\r\n    {\r\n              require(msg.sender==owner,\"Only Owner\");\r\n              MINIMUM_SELL = _minsellprice;\r\n    }\r\n\r\n    \r\n    function updatePosition(address user,uint8 _position) public payable\r\n    {\r\n        require(msg.sender==owner,\"Only Owner\");\r\n        position[user]=_position;\r\n    }\r\n    \r\n    \r\n    function switchStaking(uint8 _type) public payable\r\n    {\r\n        require(msg.sender==owner,\"Only Owner\");\r\n            if(_type==1)\r\n            stakingOn=true;\r\n            else\r\n            stakingOn=false;\r\n    }\r\n    \r\n    function switchBuy(uint8 _type) public payable\r\n    {\r\n        require(msg.sender==owner,\"Only Owner\");\r\n            if(_type==1)\r\n            buyOn=true;\r\n            else\r\n            buyOn=false;\r\n    }\r\n\r\n\r\n\r\n    function switchSell(uint8 _type) public payable\r\n    {\r\n        require(msg.sender==owner,\"Only Owner\");\r\n            if(_type==1)\r\n            sellOn=true;\r\n            else\r\n            sellOn=false;\r\n    }\r\n\r\n    function switchWithdraw(uint8 _type) public payable\r\n    {\r\n        require(msg.sender==owner,\"Only Owner\");\r\n            if(_type==1)\r\n            withdrawOn=true;\r\n            else\r\n            withdrawOn=false;\r\n    }\r\n    \r\n\r\n    function stopStaking(address _user,uint8 _type) public payable\r\n    {\r\n        require(msg.sender==owner,\"Only Owner\");\r\n            if(_type==1)\r\n            isStop[_user]=true;\r\n            else\r\n            isStop[_user]=false;\r\n    }\r\n    \r\n    function isUserExists(address user) public view returns (bool) \r\n    {\r\n        return (users[user].id != 0);\r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"withdrawOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_withdraw_token\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAdminOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"name\":\"_isContract\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"switchSell\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"openAdminPrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenQty\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenQty\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_virtual_staking\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"},{\"name\":\"referrerAddress\",\"type\":\"address\"}],\"name\":\"registration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"buyLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"switchBuy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_staking_busd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_BUY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceUpdateGap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"priceLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"stopStaking\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"_position\",\"type\":\"uint8\"}],\"name\":\"updatePosition\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"switchStaking\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxsellprice\",\"type\":\"uint256\"}],\"name\":\"updateMaxSell\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_token_sell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"sellLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_virtual_withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"walletUsedBusd\",\"type\":\"uint256\"},{\"name\":\"rewardUsedBusd\",\"type\":\"uint256\"},{\"name\":\"compoundUsedBusd\",\"type\":\"uint256\"},{\"name\":\"_programId\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"start_staking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amt\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"referralReward\",\"type\":\"uint256\"},{\"name\":\"selfBuy\",\"type\":\"uint256\"},{\"name\":\"selfSell\",\"type\":\"uint256\"},{\"name\":\"programCount\",\"type\":\"uint256\"},{\"name\":\"totalStakingBusd\",\"type\":\"uint256\"},{\"name\":\"totalStakingToken\",\"type\":\"uint256\"},{\"name\":\"currentPercent\",\"type\":\"uint256\"},{\"name\":\"compoundReward\",\"type\":\"uint256\"},{\"name\":\"freeStakedToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_token_buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minsellprice\",\"type\":\"uint256\"}],\"name\":\"updateMinSell\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"position\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_SELL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakingProgramByUID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bool[]\"},{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_staking_token\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_withdraw_busd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_SELL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"switchWithdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyOn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakingPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"},{\"name\":\"_busdToken\",\"type\":\"address\"},{\"name\":\"_elucksToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletUsedToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardUsedToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compoundUsedToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"CycleStartedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"walletUsedBusd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardUsedBusd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compoundUsedBusd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"CycleStartedBusd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total_token\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"live_rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"busd_amount\",\"type\":\"uint256\"}],\"name\":\"TokenDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdrawalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawalAmountToken\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ReferralReward\",\"type\":\"event\"}]", "ContractName": "ElucksStakingProgram", "CompilerVersion": "v0.5.4+commit.9549d8ff", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000238bc8a032b6c06e2f015c3e60d43da8ac8115eb000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000d356e3fa422970babd05d9fe2d8571dc39172dde", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://f01dc61632c255fc3a8b29bd024b81f78feea725f64ba5a8f4e60fbf5d39152a"}