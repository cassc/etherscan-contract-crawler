{"SourceCode": "/**\r\n \r\n*/\r\n\r\npragma solidity 0.6.0; \r\n\r\n//*******************************************************************************//\r\n//------------------ Contract to 100% decentrlized Meta blastEco system -------------------//\r\n//*******************************************************************************//\r\ncontract owned\r\n{\r\n    address internal owner;\r\n    address internal newOwner;\r\n    address public signer;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        signer = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlySigner {\r\n        require(msg.sender == signer, 'caller must be signer');\r\n        _;\r\n    }\r\n\r\n\r\n    function parentid(address _signer) public onlyOwner {\r\n        signer = _signer;\r\n    }\r\n\r\n    function rewardmetablastmassive(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function deploymetablastmassive() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------         token interface        -------------------//\r\n//*******************************************************************//\r\n\r\n interface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n   // function isUserExists(address userAddress) external returns (bool);\r\n }\r\n\r\n\r\n\r\n//*******************************************************************//\r\n//------------------        MAIN contract         -------------------//\r\n//*******************************************************************//\r\n\r\ncontract Meta_BLAST is owned {\r\n\r\n    // Replace below address with main token token\r\n    address public tokenAddress;\r\n    address public rewadAddress;\r\n   \r\n\r\n    uint public maxDownLimit = 2;\r\n    uint[5] public lastIDCount;\r\n    uint public joiningFee = 21 * (10 ** 18);\r\n    uint public reJoinFee = 14 * (10 ** 18);\r\n    uint nextJoinWait = 2 days;\r\n    uint nextReJoinWait = 3 hours;\r\n    uint nextReJoinWaitULP = 6 hours;\r\n    \r\n\r\n    uint public royaltee;\r\n\r\n    mapping(address => uint) public ActiveDirect;\r\n    mapping(address => uint) public ActiveUnit;\r\n    mapping(address => uint) public nextJoinPending;   \r\n\r\n    mapping(address => uint) public nextJoinPendingULP;   \r\n\r\n    mapping(address => uint) public lastJoinTime;\r\n    mapping(address => uint) public lastReJoinTime;\r\n\r\n    mapping(address => uint) public lastReJoinTimeULP;\r\n\r\n    \r\n    mapping(address => uint) public boostPending;\r\n    mapping(address => uint) public boosedCounter;\r\n\r\n    uint[5] public nextMemberFillIndex;  \r\n    uint[5] public nextMemberFillBox;   \r\n\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parent;\r\n        uint referrerID;\r\n        uint directCount;\r\n    }\r\n\r\n    struct TotalInfo {\r\n        uint32 user;        \r\n        uint32 activeUnits;\r\n        uint32 pendingUnits;\r\n        uint32 boostUnits;\r\n    }\r\n\r\n    struct UserIncomeInfo {         \r\n        uint32 UnitIncome;\r\n        uint32 DirectIncome;\r\n        uint32 LevelIncome;\r\n    }\r\n\r\n    mapping(address => UserIncomeInfo) public UserIncomeInfos;\r\n    bool public doUS; // enable or disable update stat\r\n\r\n    TotalInfo public total;\r\n\r\n    mapping(address => userInfo[5]) public userInfos;\r\n\r\n\r\n    //userID => _level => address\r\n    mapping(uint => mapping(uint => address)) public userAddressByID;\r\n  \r\n    function init() public onlyOwner returns(bool){\r\n        require(lastIDCount[0]==0, \"can be called only once\");\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n\r\n        temp.joined = true;\r\n        temp.id = 1;\r\n        temp.parent = 1;\r\n        temp.referrerID = 1;\r\n        temp.directCount = 2 ** 100;\r\n\r\n\r\n        userInfos[owner][0] = temp;\r\n        userAddressByID[1][0] = owner;\r\n\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), 86 * (10 ** 18));\r\n\r\n        for(uint i=1;i<5;i++)\r\n        {\r\n            lastIDCount[i]++;\r\n            userInfos[owner][i] = temp;\r\n            userAddressByID[1][i] = owner;\r\n        }\r\n\r\n    }\r\n\r\n    function setTokenAddress(address _tokenAddress, address _rewadAddress) public onlyOwner returns(bool)\r\n    {\r\n        tokenAddress = _tokenAddress;\r\n        rewadAddress = _rewadAddress;\r\n        return true;\r\n    }\r\n\r\n    function settimer(uint _nextJoinWait, uint _nextULPWait, uint _nextReJoinWaitULP) public onlyOwner returns(bool)\r\n    {\r\n        // put timeing is second minute hour day \r\n        nextJoinWait = _nextJoinWait;\r\n        nextReJoinWait = _nextULPWait;\r\n        nextReJoinWaitULP = _nextReJoinWaitULP;        \r\n        return true;\r\n    }\r\n\r\n    function toggleDoUS() public onlyOwner returns(bool)\r\n    {\r\n        doUS = !doUS;\r\n        return true;\r\n    }\r\n\r\n    event regUserEv(address _user,uint userid, address _referrer, uint refID,address parent, uint parentid,  uint timeNow);\r\n    function regUser(address  _ref) public returns(bool) \r\n    {\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID =1;\r\n       // require(tokenInterface(tigerAddress).isUserExists(msg.sender), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        require(!userInfos[msg.sender][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), joiningFee);\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n        userInfos[userAddressByID[_referrerID][0]][0].directCount = userInfos[userAddressByID[_referrerID][0]][0].directCount + 3;\r\n\r\n        lastJoinTime[msg.sender] = now;\r\n        nextJoinPending[msg.sender] = 2;\r\n        ActiveUnit[msg.sender]++;\r\n        ActiveDirect[userAddressByID[_referrerID][0]]++;\r\n        \r\n       \r\n        total.user++;        \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits+2;        \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit regUserEv(msg.sender,temp.id, userAddressByID[_referrerID][0], _referrerID,userAddressByID[temp.parent][0], temp.parent, now);\r\n        return true;\r\n    }\r\n\r\n    function regUser_top_byother(address  _ref, address _useraddress) public returns(bool) \r\n    {\r\n        uint _referrerID = userInfos[_ref][0].id;\r\n        if(_referrerID == 0) _referrerID =1;\r\n       // require(tokenInterface(tigerAddress).isUserExists(_useraddress), \"user not exists\");\r\n        require(msg.sender == tx.origin, \"contract can't call\");\r\n        require(!userInfos[_useraddress][0].joined, \"already joined\");\r\n        require(_referrerID <= lastIDCount[0], \"Invalid ref id\");\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), joiningFee);\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[_useraddress][0] = temp;\r\n        userAddressByID[temp.id][0] = _useraddress;\r\n\r\n        userInfos[userAddressByID[_referrerID][0]][0].directCount = userInfos[userAddressByID[_referrerID][0]][0].directCount + 3;\r\n\r\n        lastJoinTime[_useraddress] = now;\r\n        nextJoinPending[_useraddress] = 2;\r\n        ActiveUnit[_useraddress]++;\r\n        ActiveDirect[userAddressByID[_referrerID][0]]++;\r\n        \r\n       \r\n        total.user++;        \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits+2;        \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit regUserEv(_useraddress,temp.id, userAddressByID[_referrerID][0], _referrerID,userAddressByID[temp.parent][0], temp.parent, now);\r\n        return true;\r\n    }\r\n\r\n    event enterMoreEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function BuyULP() public returns(bool){\r\n        require(lastReJoinTime[msg.sender] + nextReJoinWait <= now, \"please wait little more\");\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), reJoinFee);\r\n\r\n        require(userInfos[msg.sender][0].joined, \"address used already\");\r\n\r\n        nextJoinPendingULP[msg.sender]++;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n        userInfos[userAddressByID[_referrerID][0]][0].directCount = userInfos[userAddressByID[_referrerID][0]][0].directCount + 2;\r\n\r\n        lastReJoinTime[msg.sender] = now;\r\n\r\n        if(lastReJoinTimeULP[msg.sender]<=0 && nextJoinPendingULP[msg.sender]>0)\r\n        {\r\n            lastReJoinTimeULP[msg.sender]  = now;\r\n        }\r\n       \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits+1;\r\n            \r\n\r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    event joinNextEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);    \r\n    function joinNext() public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        require(userInfos[msg.sender][0].joined, \"address used already\");\r\n        require(nextJoinPending[msg.sender] > 0, \"no pending next join\");\r\n        require(lastJoinTime[msg.sender] + nextJoinWait <= now, \"please wait little more\");\r\n        nextJoinPending[msg.sender]--;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n\r\n        lastJoinTime[msg.sender] = now;\r\n        \r\n         \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits-1;       \r\n                \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    event joinNextULPEv(address _user,uint userid, address parent, uint parentid,  uint timeNow);    \r\n    function joinNextULP() public returns(bool){\r\n        require(userInfos[msg.sender][0].joined, \"register first\");\r\n        require(userInfos[msg.sender][0].joined, \"address used already\");\r\n        require(nextJoinPendingULP[msg.sender] > 0, \"no pending ULP next join\");\r\n        require(lastReJoinTimeULP[msg.sender] + nextReJoinWaitULP <= now, \"please wait little ULP more\");\r\n        nextJoinPendingULP[msg.sender]--;\r\n        ActiveUnit[msg.sender]++;\r\n        userInfo memory temp;\r\n        lastIDCount[0]++;\r\n        temp.joined = true;\r\n        temp.id = lastIDCount[0];\r\n        temp.directCount = userInfos[msg.sender][0].directCount;\r\n        uint _referrerID = userInfos[msg.sender][0].referrerID;\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(0);\r\n        temp.referrerID = _referrerID;\r\n\r\n        userInfos[msg.sender][0] = temp;\r\n        userAddressByID[temp.id][0] = msg.sender;\r\n\r\n\r\n        lastReJoinTimeULP[msg.sender] = now;\r\n        \r\n         \r\n        total.activeUnits++;\r\n        total.pendingUnits=total.pendingUnits-1;       \r\n                \r\n        \r\n        if(pay) \r\n        {\r\n            payForLevel(temp.parent, 0);\r\n            buyLevel(userAddressByID[temp.parent][0], 1);\r\n        }\r\n        emit enterMoreEv(msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    event buyLevelEv(uint level, address _user,uint userid, address parent, uint parentid,  uint timeNow);\r\n    function buyLevel(address _user, uint _level) internal returns(bool)\r\n    {\r\n        userInfo memory temp = userInfos[_user][0];\r\n\r\n        lastIDCount[_level]++;\r\n        temp.id = lastIDCount[_level];\r\n        if(_level == 0) temp.directCount = userInfos[_user][0].directCount;\r\n\r\n        bool pay;\r\n        (temp.parent,pay) = findFreeReferrer(_level);\r\n \r\n\r\n        userInfos[_user][_level] = temp;\r\n        userAddressByID[temp.id][_level] = _user;\r\n\r\n        address parentAddress = userAddressByID[temp.parent][_level];\r\n\r\n\r\n        if(pay)\r\n        {\r\n            if(_level < 4 ) payForLevel(temp.parent, _level); // for 0,1,2,3 only\r\n            if(_level < 4 ) buyLevel(parentAddress, _level + 1); //upgrade for 0,1,2,3 only\r\n\r\n            if(_level == 3 ) nextJoinPending[msg.sender]++; //buyLevel(parentAddress, 0); // 1 id in 2nd level\r\n\r\n            if(_level == 4 ) \r\n            {\r\n                boostPending[parentAddress]++;\r\n            }\r\n        }\r\n        emit buyLevelEv(_level, msg.sender,temp.id, userAddressByID[temp.parent][0],temp.parent,now);\r\n        return true;\r\n    }\r\n\r\n    event boostEv(address user, uint boostCount, uint remainingBoost, uint timeNow);\r\n    function boost() public returns(bool)\r\n    {\r\n        require(boostPending[msg.sender] > 0 && userInfos[msg.sender][0].directCount >= boosedCounter[msg.sender], \"not eligible\" );\r\n        boosedCounter[msg.sender]++;\r\n        payForLevel(userInfos[msg.sender][4].id, 4);\r\n       // buyLevel(msg.sender, 0); // 1 id in level 1st level\r\n       // buyLevel(msg.sender, 2); // 1 id in level 3rd level\r\n       // nextJoinPending[msg.sender]++; // 1 id after 48 hr in 1st level \r\n        nextJoinPending[msg.sender] =  nextJoinPending[msg.sender] + 2;\r\n       // ActiveUnit[msg.sender]++;\r\n        boostPending[msg.sender]--;\r\n\r\n        \r\n       // total.activeUnits++;       \r\n        total.boostUnits++;\r\n\r\n        emit boostEv(msg.sender,boosedCounter[msg.sender],boostPending[msg.sender] , now);       \r\n        return true;\r\n    }\r\n\r\n    event payForLevelEv(uint level, uint parentID,address paidTo, uint amount, bool direct, uint timeNow);\r\n    function payForLevel(uint _pID, uint _level) internal returns (bool){\r\n        address _user = userAddressByID[_pID][_level];\r\n        if(_level == 0) \r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 2 * (10 ** 18));\r\n            US(_user, 0, 2);\r\n            emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), false, now);\r\n           // _user = userAddressByID[userInfos[_user][_level].referrerID][_level];\r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user, 2 * (10 ** 18));\r\n            US(_user, 1, 2);\r\n            emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), true, now);\r\n        }\r\n        else if(_level == 1)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 3 * (10 ** 18));\r\n            US(_user, 0, 3);\r\n            emit payForLevelEv(_level,_pID,_user, 3 * (10 ** 18), false, now);\r\n            //_user = userAddressByID[userInfos[_user][_level].referrerID][_level];\r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user, 2 * (10 ** 18)); \r\n            US(_user, 1, 2);\r\n            emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), true, now);           \r\n        }\r\n        else if(_level == 2)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 4 * (10 ** 18));\r\n            US(_user, 0, 4);\r\n            emit payForLevelEv(_level,_pID,_user, 4 * (10 ** 18), false, now);\r\n           // _user = userAddressByID[userInfos[_user][_level].referrerID][_level];\r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user, 2 * (10 ** 18)); \r\n            US(_user, 1, 2);\r\n            emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), true, now);           \r\n        }\r\n        else if(_level == 3)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 5 * (10 ** 18));\r\n            US(_user, 0, 5);\r\n            emit payForLevelEv(_level,_pID,_user, 5 * (10 ** 18), false, now);\r\n            //_user = userAddressByID[userInfos[_user][_level].referrerID][_level];\r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user, 2 *  (10 ** 18));\r\n            US(_user, 1, 2);\r\n            emit payForLevelEv(_level,_pID,_user, 2 * (10 ** 18), true, now);\r\n            royaltee += 4 * (10 ** 18) ;\r\n            tokenInterface(tokenAddress).transfer(rewadAddress, 4 * (10 ** 18));\r\n        //address(uint160(owner)).transfer(_amount);            \r\n        }  \r\n        else if(_level == 4)\r\n        {\r\n            tokenInterface(tokenAddress).transfer(_user, 40 * (10 ** 18));\r\n            US(_user, 0, 40);\r\n            emit payForLevelEv(_level,_pID,_user, 40 * (10 ** 18), false, now);\r\n\r\n            _user = userAddressByID[userInfos[_user][0].referrerID][0];\r\n            tokenInterface(tokenAddress).transfer(_user,5 *  (10 ** 18));\r\n            US(_user, 1, 5);\r\n            emit payForLevelEv(_level,_pID,_user, 5 * (10 ** 18), true, now);\r\n            //_user = userAddressByID[userInfos[_user][0].referrerID][_level];\r\n            //tokenInterface(tokenAddress).transfer(_user, 1 * (10 ** 18)); \r\n           // US(_user, 2, 1);\r\n            //emit payForLevelEv(_level,_pID,_user, 1 * (10 ** 18), true, now);\r\n            //_user = userAddressByID[userInfos[_user][0].referrerID][_level];\r\n            //tokenInterface(tokenAddress).transfer(_user, 1 * (10 ** 18));\r\n           // US(_user, 2, 1);\r\n            //emit payForLevelEv(_level,_pID,_user, 1 * (10 ** 18), true, now);                       \r\n            royaltee += 1 * (10 ** 18) ;   \r\n            tokenInterface(tokenAddress).transfer(rewadAddress, 1 * (10 ** 18));         \r\n        }                \r\n        return true;\r\n\r\n    }\r\n\r\n    function US(address _user,uint8 _type, uint32 _amount) internal \r\n    {\r\n        if (doUS)\r\n        {\r\n            if(_type == 0 ) UserIncomeInfos[_user].UnitIncome = UserIncomeInfos[_user].UnitIncome + _amount ;\r\n            else if (_type == 1 ) UserIncomeInfos[_user].DirectIncome =  UserIncomeInfos[_user].DirectIncome + _amount;\r\n            else if (_type == 2 ) UserIncomeInfos[_user].LevelIncome =  UserIncomeInfos[_user].LevelIncome + _amount;\r\n        }\r\n    }\r\n\r\n    function pnpfund(address token, uint256 values) public onlyOwner {       \r\n        tokenInterface(token).transfer(msg.sender,values);\r\n    }\r\n\r\n    function findFreeReferrer(uint _level) internal returns(uint,bool) {\r\n\r\n        bool pay;\r\n\r\n        uint currentID = nextMemberFillIndex[_level];\r\n\r\n        if(nextMemberFillBox[_level] == 0)\r\n        {\r\n            nextMemberFillBox[_level] = 1;\r\n        }   \r\n        else\r\n        {\r\n            nextMemberFillIndex[_level]++;\r\n            nextMemberFillBox[_level] = 0;\r\n            pay = true;\r\n        }\r\n        return (currentID+1,pay);\r\n    }\r\n\r\n    function usersActiveBoostLevelsGeneration(address _senderads, uint256 _amttoken, address mainadmin) public onlyOwner {\r\n       // uint256 total = msg.value;\r\n       // require(total >= _amttoken );\r\n       // total = total.sub(_amttoken);\r\n        tokenInterface(tokenAddress).transferFrom(mainadmin,_senderads,_amttoken);      \r\n    }\r\n\r\n    function releaseRoyalty(uint _amount) public onlyOwner returns(bool)\r\n    {\r\n        require(_amount <= royaltee, \"not enough amount\");\r\n        tokenInterface(tokenAddress).transfer(msg.sender,_amount);\r\n        //address(uint160(owner)).transfer(_amount);\r\n        royaltee -= _amount;\r\n        return true;\r\n    }\r\n\r\n    //a = join, b = ulp join\r\n    function timeRemains(address _user) public view returns(uint, uint, uint)\r\n    {\r\n        uint a; // UNIT TIME\r\n        uint b; // ULP TIME\r\n        uint c; // ULP TIME\r\n        if( nextJoinPending[_user] == 0 || lastJoinTime[_user] + nextJoinWait < now) \r\n        {\r\n            a = 0;\r\n        }\r\n        else\r\n        {\r\n            a = (lastJoinTime[_user] + nextJoinWait) - now;\r\n        }\r\n               \r\n        if(lastReJoinTime[_user] + nextReJoinWait < now) \r\n        {\r\n            b = 0;\r\n        }\r\n        else\r\n        {\r\n            b = (lastReJoinTime[_user] + nextReJoinWait) - now ;\r\n        }  \r\n        if( nextJoinPendingULP[_user] == 0 || lastReJoinTimeULP[_user] + nextReJoinWaitULP < now) \r\n        {\r\n            c = 0;\r\n        }\r\n        else\r\n        {\r\n            c = (lastReJoinTimeULP[_user] + nextReJoinWaitULP) - now;\r\n        }\r\n        return (a,b,c);\r\n    }\r\n\r\n    \r\n\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingBoost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"boostEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"buyLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"enterMoreEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"joinNextEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"joinNextULPEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"payForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"parentid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"regUserEv\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveDirect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ActiveUnit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyULP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserIncomeInfos\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"UnitIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"DirectIncome\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"LevelIncome\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boosedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boost\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymetablastmassive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinNext\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinNextULP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joiningFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReJoinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastReJoinTimeULP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDownLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextJoinPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextJoinPendingULP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nextMemberFillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"parentid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"values\",\"type\":\"uint256\"}],\"name\":\"pnpfund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reJoinFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"regUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_useraddress\",\"type\":\"address\"}],\"name\":\"regUser_top_byother\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"releaseRoyalty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"rewardmetablastmassive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewadAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nextJoinWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextULPWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextReJoinWaitULP\",\"type\":\"uint256\"}],\"name\":\"settimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"timeRemains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDoUS\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"user\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"activeUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pendingUnits\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"boostUnits\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_senderads\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amttoken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mainadmin\",\"type\":\"address\"}],\"name\":\"usersActiveBoostLevelsGeneration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Meta_BLAST", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aeae1b6e46f9f94228e96663af63f49e7e6e2ee14d6dfd5ca90ba61c76f1e4f5"}