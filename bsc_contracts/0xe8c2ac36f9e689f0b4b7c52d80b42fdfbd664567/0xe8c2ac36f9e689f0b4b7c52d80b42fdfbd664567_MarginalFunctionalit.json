{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libs/MarginalFunctionality.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\npragma experimental ABIEncoderV2;\\nimport \\\"../PriceOracleInterface.sol\\\";\\n\\nlibrary MarginalFunctionality {\\n\\t// We have the following approach: when liability is created we store\\n\\t// timestamp and size of liability. If the subsequent trade will deepen\\n\\t// this liability or won't fully cover it timestamp will not change.\\n\\t// However once outstandingAmount is covered we check whether balance on\\n\\t// that asset is positive or not. If not, liability still in the place but\\n\\t// time counter is dropped and timestamp set to `now`.\\n\\tstruct Liability {\\n\\t\\taddress asset;\\n\\t\\tuint64 timestamp;\\n\\t\\tuint192 outstandingAmount;\\n\\t}\\n\\n\\tenum PositionState {\\n\\t\\tPOSITIVE,\\n\\t\\tNEGATIVE, // weighted position below 0\\n\\t\\tOVERDUE, // liability is not returned for too long\\n\\t\\tNOPRICE, // some assets has no price or expired\\n\\t\\tINCORRECT // some of the basic requirements are not met: too many liabilities, no locked stake, etc\\n\\t}\\n\\n\\tstruct Position {\\n\\t\\tPositionState state;\\n\\t\\tint256 weightedPosition; // sum of weighted collateral minus liabilities\\n\\t\\tint256 totalPosition; // sum of unweighted (total) collateral minus liabilities\\n\\t\\tint256 totalLiabilities; // total liabilities value\\n\\t}\\n\\n\\t// Constants from Exchange contract used for calculations\\n\\tstruct UsedConstants {\\n\\t\\taddress user;\\n\\t\\taddress _oracleAddress;\\n\\t\\taddress _orionTokenAddress;\\n\\t\\tuint64 positionOverdue;\\n\\t\\tuint64 priceOverdue;\\n\\t\\tuint8 stakeRisk;\\n\\t\\tuint8 liquidationPremium;\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to multiply numbers with uint8 based percent numbers\\n\\t */\\n\\tfunction uint8Percent(int192 _a, uint8 _b) internal pure returns (int192 c) {\\n\\t\\tint a = int256(_a);\\n\\t\\tint b = int256(uint256(_b));\\n\\t\\tint d = 255;\\n\\t\\tc = int192((a > 65536) ? (a / d) * b : (a * b) / d);\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to fetch asset prices in ORN tokens\\n\\t */\\n\\tfunction getAssetPrice(address asset, address oracle) internal view returns (uint64 price, uint64 timestamp) {\\n\\t\\tPriceOracleInterface.PriceDataOut memory assetPriceData = PriceOracleInterface(oracle).assetPrices(asset);\\n\\t\\t(price, timestamp) = (assetPriceData.price, assetPriceData.timestamp);\\n\\t}\\n\\n\\t/**\\n     * @dev method to calc weighted and absolute collateral value\\n     * @notice it only count for assets in collateralAssets list, all other\\n               assets will add 0 to position.\\n     * @return outdated whether any price is outdated\\n     * @return weightedPosition in ORN\\n     * @return totalPosition in ORN\\n     */\\n\\tfunction calcAssets(\\n\\t\\taddress[] storage collateralAssets,\\n\\t\\tmapping(address => mapping(address => int192)) storage assetBalances,\\n\\t\\tmapping(address => uint8) storage assetRisks,\\n\\t\\taddress user,\\n\\t\\taddress orionTokenAddress,\\n\\t\\taddress oracleAddress,\\n\\t\\tuint64 priceOverdue\\n\\t) internal view returns (bool outdated, int192 weightedPosition, int192 totalPosition) {\\n\\t\\tuint256 collateralAssetsLength = collateralAssets.length;\\n\\t\\tfor (uint256 i = 0; i < collateralAssetsLength; i++) {\\n\\t\\t\\taddress asset = collateralAssets[i];\\n\\t\\t\\tif (assetBalances[user][asset] < 0) continue; // will be calculated in calcLiabilities\\n\\t\\t\\t(uint64 price, uint64 timestamp) = (1e8, 0xfffffff000000000);\\n\\n\\t\\t\\tif (asset != orionTokenAddress) {\\n\\t\\t\\t\\t(price, timestamp) = getAssetPrice(asset, oracleAddress);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// balance: i192, price u64 => balance*price fits i256\\n\\t\\t\\t// since generally balance <= N*maxInt112 (where N is number operations with it),\\n\\t\\t\\t// assetValue <= N*maxInt112*maxUInt64/1e8.\\n\\t\\t\\t// That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n\\n\\t\\t\\tuint8 specificRisk = assetRisks[asset];\\n\\t\\t\\tint192 balance = assetBalances[user][asset];\\n\\t\\t\\tint256 _assetValue = (int256(balance) * int256(uint256(price))) / 1e8;\\n\\t\\t\\tint192 assetValue = int192(_assetValue);\\n\\n\\t\\t\\t// Overflows logic holds here as well, except that N is the number of\\n\\t\\t\\t// operations for all assets\\n\\n\\t\\t\\tif (assetValue > 0) {\\n\\t\\t\\t\\tweightedPosition += uint8Percent(assetValue, specificRisk);\\n\\t\\t\\t\\ttotalPosition += assetValue;\\n\\t\\t\\t\\toutdated = outdated || ((timestamp + priceOverdue) < block.timestamp);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (outdated, weightedPosition, totalPosition);\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to calc liabilities\\n\\t * @return outdated whether any price is outdated\\n\\t * @return overdue whether any liability is overdue\\n\\t * @return weightedPosition weightedLiability == totalLiability in ORN\\n\\t * @return totalPosition totalLiability in ORN\\n\\t */\\n\\tfunction calcLiabilities(\\n\\t\\tmapping(address => Liability[]) storage liabilities,\\n\\t\\tmapping(address => mapping(address => int192)) storage assetBalances,\\n\\t\\taddress user,\\n\\t\\taddress oracleAddress,\\n\\t\\tuint64 positionOverdue,\\n\\t\\tuint64 priceOverdue\\n\\t) internal view returns (bool outdated, bool overdue, int192 weightedPosition, int192 totalPosition) {\\n\\t\\tuint256 liabilitiesLength = liabilities[user].length;\\n\\n\\t\\tfor (uint256 i = 0; i < liabilitiesLength; i++) {\\n\\t\\t\\tLiability storage liability = liabilities[user][i];\\n\\t\\t\\tint192 balance = assetBalances[user][liability.asset];\\n\\t\\t\\t(uint64 price, uint64 timestamp) = getAssetPrice(liability.asset, oracleAddress);\\n\\t\\t\\t// balance: i192, price u64 => balance*price fits i256\\n\\t\\t\\t// since generally balance <= N*maxInt112 (where N is number operations with it),\\n\\t\\t\\t// assetValue <= N*maxInt112*maxUInt64/1e8.\\n\\t\\t\\t// That is if N<= 2**17 *1e8 = 1.3e13  we can neglect overflows here\\n\\n\\t\\t\\tint192 liabilityValue = int192((int256(balance) * int256(uint256(price))) / 1e8);\\n\\t\\t\\tweightedPosition += liabilityValue; //already negative since balance is negative\\n\\t\\t\\ttotalPosition += liabilityValue;\\n\\t\\t\\toverdue = overdue || ((liability.timestamp + positionOverdue) < block.timestamp);\\n\\t\\t\\toutdated = outdated || ((timestamp + priceOverdue) < block.timestamp);\\n\\t\\t}\\n\\n\\t\\treturn (outdated, overdue, weightedPosition, totalPosition);\\n\\t}\\n\\n\\t/**\\n\\t * @dev method to calc Position\\n\\t * @return result position structure\\n\\t */\\n\\tfunction calcPosition(\\n\\t\\taddress[] storage collateralAssets,\\n\\t\\tmapping(address => Liability[]) storage liabilities,\\n\\t\\tmapping(address => mapping(address => int192)) storage assetBalances,\\n\\t\\tmapping(address => uint8) storage assetRisks,\\n\\t\\tUsedConstants memory constants\\n\\t) public view returns (Position memory result) {\\n\\t\\t(bool outdatedPrice, int192 weightedPosition, int192 totalPosition) = calcAssets(\\n\\t\\t\\tcollateralAssets,\\n\\t\\t\\tassetBalances,\\n\\t\\t\\tassetRisks,\\n\\t\\t\\tconstants.user,\\n\\t\\t\\tconstants._orionTokenAddress,\\n\\t\\t\\tconstants._oracleAddress,\\n\\t\\t\\tconstants.priceOverdue\\n\\t\\t);\\n\\n\\t\\t(bool _outdatedPrice, bool overdue, int192 _weightedPosition, int192 _totalPosition) = calcLiabilities(\\n\\t\\t\\tliabilities,\\n\\t\\t\\tassetBalances,\\n\\t\\t\\tconstants.user,\\n\\t\\t\\tconstants._oracleAddress,\\n\\t\\t\\tconstants.positionOverdue,\\n\\t\\t\\tconstants.priceOverdue\\n\\t\\t);\\n\\n\\t\\tweightedPosition += _weightedPosition;\\n\\t\\ttotalPosition += _totalPosition;\\n\\t\\toutdatedPrice = outdatedPrice || _outdatedPrice;\\n\\t\\tif (_totalPosition < 0) {\\n\\t\\t\\tresult.totalLiabilities = _totalPosition;\\n\\t\\t}\\n\\t\\tif (weightedPosition < 0) {\\n\\t\\t\\tresult.state = PositionState.NEGATIVE;\\n\\t\\t}\\n\\t\\tif (outdatedPrice) {\\n\\t\\t\\tresult.state = PositionState.NOPRICE;\\n\\t\\t}\\n\\t\\tif (overdue) {\\n\\t\\t\\tresult.state = PositionState.OVERDUE;\\n\\t\\t}\\n\\t\\tresult.weightedPosition = weightedPosition;\\n\\t\\tresult.totalPosition = totalPosition;\\n\\t}\\n\\n\\t/**\\n\\t * @dev method removes liability\\n\\t */\\n\\tfunction removeLiability(address user, address asset, mapping(address => Liability[]) storage liabilities) public {\\n\\t\\tuint256 length = liabilities[user].length;\\n\\n\\t\\tfor (uint256 i = 0; i < length; i++) {\\n\\t\\t\\tif (liabilities[user][i].asset == asset) {\\n\\t\\t\\t\\tif (length > 1) {\\n\\t\\t\\t\\t\\tliabilities[user][i] = liabilities[user][length - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tliabilities[user].pop();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev method update liability\\n\\t * @notice implement logic for outstandingAmount (see Liability description)\\n\\t */\\n\\tfunction updateLiability(\\n\\t\\taddress user,\\n\\t\\taddress asset,\\n\\t\\tmapping(address => Liability[]) storage liabilities,\\n\\t\\tuint112 depositAmount,\\n\\t\\tint192 currentBalance\\n\\t) internal {\\n\\t\\tif (currentBalance >= 0) {\\n\\t\\t\\tremoveLiability(user, asset, liabilities);\\n\\t\\t} else {\\n\\t\\t\\tuint256 i;\\n\\t\\t\\tuint256 liabilitiesLength = liabilities[user].length;\\n\\t\\t\\tfor (; i < liabilitiesLength - 1; i++) {\\n\\t\\t\\t\\tif (liabilities[user][i].asset == asset) break;\\n\\t\\t\\t}\\n\\t\\t\\tLiability storage liability = liabilities[user][i];\\n\\t\\t\\tif (depositAmount >= liability.outstandingAmount) {\\n\\t\\t\\t\\tliability.outstandingAmount = uint192(-currentBalance);\\n\\t\\t\\t\\tliability.timestamp = uint64(block.timestamp);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tliability.outstandingAmount -= depositAmount;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n     * @dev partially liquidate, that is cover some asset liability to get\\n            ORN from misbehavior broker\\n     */\\n\\tfunction partiallyLiquidate(\\n\\t\\taddress[] storage collateralAssets,\\n\\t\\tmapping(address => Liability[]) storage liabilities,\\n\\t\\tmapping(address => mapping(address => int192)) storage assetBalances,\\n\\t\\tmapping(address => uint8) storage assetRisks,\\n\\t\\tUsedConstants memory constants,\\n\\t\\taddress redeemedAsset,\\n\\t\\taddress collateralAsset,\\n\\t\\tuint112 amount\\n\\t) public {\\n\\t\\t//Note: constants.user - is broker who will be liquidated\\n\\t\\tPosition memory initialPosition = calcPosition(\\n\\t\\t\\tcollateralAssets,\\n\\t\\t\\tliabilities,\\n\\t\\t\\tassetBalances,\\n\\t\\t\\tassetRisks,\\n\\t\\t\\tconstants\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tinitialPosition.state == PositionState.NEGATIVE || initialPosition.state == PositionState.OVERDUE,\\n\\t\\t\\t\\\"E7\\\"\\n\\t\\t);\\n\\t\\taddress liquidator = msg.sender;\\n\\t\\trequire(assetBalances[liquidator][redeemedAsset] >= int192(uint192(amount)), \\\"E8\\\");\\n\\t\\trequire(assetBalances[constants.user][redeemedAsset] < 0, \\\"E15\\\");\\n\\t\\tassetBalances[liquidator][redeemedAsset] -= int192(uint192(amount));\\n\\t\\tassetBalances[constants.user][redeemedAsset] += int192(uint192(amount));\\n\\n\\t\\tif (assetBalances[constants.user][redeemedAsset] >= 0)\\n\\t\\t\\tremoveLiability(constants.user, redeemedAsset, liabilities);\\n\\n\\t\\t(uint64 price, uint64 ts1) = getAssetPrice(redeemedAsset, constants._oracleAddress);\\n\\t\\trequire(ts1 + constants.priceOverdue > block.timestamp, \\\"E9\\\"); //Price is outdated\\n\\n\\t\\tif (collateralAsset != constants._orionTokenAddress) { //\\n\\t\\t\\t(uint64 collateralPrice, uint64 ts2) = getAssetPrice(collateralAsset, constants._oracleAddress);\\n\\t\\t\\trequire(ts2 + constants.priceOverdue > block.timestamp, \\\"E9\\\"); //Price is outdated\\n\\t\\t\\tprice = (price * 1e8) / collateralPrice;\\n\\t\\t}\\n\\n\\t\\treimburseLiquidator(\\n\\t\\t\\tamount,\\n\\t\\t\\tprice,\\n\\t\\t\\tcollateralAsset,\\n\\t\\t\\tliquidator,\\n\\t\\t\\tassetBalances,\\n\\t\\t\\tconstants.liquidationPremium,\\n\\t\\t\\tconstants.user\\n\\t\\t);\\n\\n\\t\\tPosition memory finalPosition = calcPosition(\\n\\t\\t\\tcollateralAssets,\\n\\t\\t\\tliabilities,\\n\\t\\t\\tassetBalances,\\n\\t\\t\\tassetRisks,\\n\\t\\t\\tconstants\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tuint(finalPosition.state) < 3 && //POSITIVE,NEGATIVE or OVERDUE\\n\\t\\t\\t\\t(finalPosition.weightedPosition > initialPosition.weightedPosition),\\n\\t\\t\\t\\\"E10\\\"\\n\\t\\t); //Incorrect state position after liquidation\\n\\t\\tif (finalPosition.state == PositionState.POSITIVE)\\n\\t\\t\\trequire(finalPosition.weightedPosition < 10e8, \\\"Can not liquidate to very positive state\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev reimburse liquidator with collateral: first from stake, than from broker balance\\n\\t */\\n\\tfunction reimburseLiquidator(\\n\\t\\tuint112 amount,\\n\\t\\tuint64 price,\\n\\t\\taddress collateralAsset,\\n\\t\\taddress liquidator,\\n\\t\\tmapping(address => mapping(address => int192)) storage assetBalances,\\n\\t\\tuint8 liquidationPremium,\\n\\t\\taddress user\\n\\t) internal {\\n\\t\\tint192 collateralAmount = int192((int256(uint256(amount)) * int256(uint256(price))) / 1e8);\\n\\t\\tcollateralAmount += uint8Percent(collateralAmount, liquidationPremium); //Liquidation premium\\n\\n\\t\\tint192 onBalanceCollateral = assetBalances[user][collateralAsset];\\n\\n\\t\\trequire(onBalanceCollateral >= collateralAmount, \\\"E10\\\");\\n\\t\\tassetBalances[user][collateralAsset] -= collateralAmount;\\n\\t\\tassetBalances[liquidator][collateralAsset] += collateralAmount;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleDataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\ninterface PriceOracleDataTypes {\\n\\tstruct PriceDataOut {\\n\\t\\tuint64 price;\\n\\t\\tuint64 timestamp;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport \\\"./PriceOracleDataTypes.sol\\\";\\n\\ninterface PriceOracleInterface is PriceOracleDataTypes {\\n\\tfunction assetPrices(address) external view returns (PriceDataOut memory);\\n\\n\\tfunction givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "MarginalFunctionality", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}