{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Borrowable.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./BAllowance.sol\\\";\\nimport \\\"./BInterestRateModel.sol\\\";\\nimport \\\"./BSetter.sol\\\";\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/ITarotCallee.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/IBorrowTracker.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\n\\ncontract Borrowable is\\n    IBorrowable,\\n    PoolToken,\\n    BStorage,\\n    BSetter,\\n    BInterestRateModel,\\n    BAllowance\\n{\\n    uint256 public constant BORROW_FEE = 0.0001e18; //0.01%\\n\\n    event Borrow(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed receiver,\\n        uint256 borrowAmount,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n    event Liquidate(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed liquidator,\\n        uint256 seizeTokens,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    constructor() public {}\\n\\n    /*** PoolToken ***/\\n\\n    function _update() internal {\\n        super._update();\\n        _calculateBorrowRate();\\n    }\\n\\n    function _mintReserves(uint256 _exchangeRate, uint256 _totalSupply)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 _exchangeRateLast = exchangeRateLast;\\n        if (_exchangeRate > _exchangeRateLast) {\\n            uint256 _exchangeRateNew =\\n                _exchangeRate.sub(\\n                    _exchangeRate.sub(_exchangeRateLast).mul(reserveFactor).div(\\n                        1e18\\n                    )\\n                );\\n            uint256 liquidity =\\n                _totalSupply.mul(_exchangeRate).div(_exchangeRateNew).sub(\\n                    _totalSupply\\n                );\\n            if (liquidity > 0) {\\n                address reservesManager = IFactory(factory).reservesManager();\\n                _mint(reservesManager, liquidity);\\n            }\\n            exchangeRateLast = _exchangeRateNew;\\n            return _exchangeRateNew;\\n        } else return _exchangeRate;\\n    }\\n\\n    function exchangeRate() public accrue returns (uint256) {\\n        uint256 _totalSupply = totalSupply;\\n        uint256 _actualBalance = totalBalance.add(totalBorrows);\\n        if (_totalSupply == 0 || _actualBalance == 0)\\n            return initialExchangeRate;\\n        uint256 _exchangeRate = _actualBalance.mul(1e18).div(_totalSupply);\\n        return _mintReserves(_exchangeRate, _totalSupply);\\n    }\\n\\n    // force totalBalance to match real balance\\n    function sync() external nonReentrant update accrue {}\\n\\n    /*** Borrowable ***/\\n\\n    // this is the stored borrow balance; the current borrow balance may be slightly higher\\n    function borrowBalance(address borrower) public view returns (uint256) {\\n        BorrowSnapshot memory borrowSnapshot = borrowBalances[borrower];\\n        if (borrowSnapshot.interestIndex == 0) return 0; // not initialized\\n        return\\n            uint256(borrowSnapshot.principal).mul(borrowIndex).div(\\n                borrowSnapshot.interestIndex\\n            );\\n    }\\n\\n    function _trackBorrow(\\n        address borrower,\\n        uint256 accountBorrows,\\n        uint256 _borrowIndex\\n    ) internal {\\n        address _borrowTracker = borrowTracker;\\n        if (_borrowTracker == address(0)) return;\\n        IBorrowTracker(_borrowTracker).trackBorrow(\\n            borrower,\\n            accountBorrows,\\n            _borrowIndex\\n        );\\n    }\\n\\n    function _updateBorrow(\\n        address borrower,\\n        uint256 borrowAmount,\\n        uint256 repayAmount\\n    )\\n        private\\n        returns (\\n            uint256 accountBorrowsPrior,\\n            uint256 accountBorrows,\\n            uint256 _totalBorrows\\n        )\\n    {\\n        accountBorrowsPrior = borrowBalance(borrower);\\n        if (borrowAmount == repayAmount)\\n            return (accountBorrowsPrior, accountBorrowsPrior, totalBorrows);\\n        uint112 _borrowIndex = borrowIndex;\\n        if (borrowAmount > repayAmount) {\\n            BorrowSnapshot storage borrowSnapshot = borrowBalances[borrower];\\n            uint256 increaseAmount = borrowAmount - repayAmount;\\n            accountBorrows = accountBorrowsPrior.add(increaseAmount);\\n            borrowSnapshot.principal = safe112(accountBorrows);\\n            borrowSnapshot.interestIndex = _borrowIndex;\\n            _totalBorrows = uint256(totalBorrows).add(increaseAmount);\\n            totalBorrows = safe112(_totalBorrows);\\n        } else {\\n            BorrowSnapshot storage borrowSnapshot = borrowBalances[borrower];\\n            uint256 decreaseAmount = repayAmount - borrowAmount;\\n            accountBorrows = accountBorrowsPrior > decreaseAmount\\n                ? accountBorrowsPrior - decreaseAmount\\n                : 0;\\n            borrowSnapshot.principal = safe112(accountBorrows);\\n            if (accountBorrows == 0) {\\n                borrowSnapshot.interestIndex = 0;\\n            } else {\\n                borrowSnapshot.interestIndex = _borrowIndex;\\n            }\\n            uint256 actualDecreaseAmount =\\n                accountBorrowsPrior.sub(accountBorrows);\\n            _totalBorrows = totalBorrows; // gas savings\\n            _totalBorrows = _totalBorrows > actualDecreaseAmount\\n                ? _totalBorrows - actualDecreaseAmount\\n                : 0;\\n            totalBorrows = safe112(_totalBorrows);\\n        }\\n        _trackBorrow(borrower, accountBorrows, _borrowIndex);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function borrow(\\n        address borrower,\\n        address receiver,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external nonReentrant update accrue {\\n        uint256 _totalBalance = totalBalance;\\n        require(borrowAmount <= _totalBalance, \\\"Tarot: INSUFFICIENT_CASH\\\");\\n        _checkBorrowAllowance(borrower, msg.sender, borrowAmount);\\n\\n        // optimistically transfer funds\\n        if (borrowAmount > 0) _safeTransfer(receiver, borrowAmount);\\n        if (data.length > 0)\\n            ITarotCallee(receiver).tarotBorrow(\\n                msg.sender,\\n                borrower,\\n                borrowAmount,\\n                data\\n            );\\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\\n\\n        uint256 borrowFee = borrowAmount.mul(BORROW_FEE).div(1e18);\\n        uint256 adjustedBorrowAmount = borrowAmount.add(borrowFee);\\n        uint256 repayAmount = balance.add(borrowAmount).sub(_totalBalance);\\n        (\\n            uint256 accountBorrowsPrior,\\n            uint256 accountBorrows,\\n            uint256 _totalBorrows\\n        ) = _updateBorrow(borrower, adjustedBorrowAmount, repayAmount);\\n\\n        if (adjustedBorrowAmount > repayAmount)\\n            require(\\n                ICollateral(collateral).canBorrow(\\n                    borrower,\\n                    address(this),\\n                    accountBorrows\\n                ),\\n                \\\"Tarot: INSUFFICIENT_LIQUIDITY\\\"\\n            );\\n\\n        emit Borrow(\\n            msg.sender,\\n            borrower,\\n            receiver,\\n            borrowAmount,\\n            repayAmount,\\n            accountBorrowsPrior,\\n            accountBorrows,\\n            _totalBorrows\\n        );\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function liquidate(address borrower, address liquidator)\\n        external\\n        nonReentrant\\n        update\\n        accrue\\n        returns (uint256 seizeTokens)\\n    {\\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\\n        uint256 repayAmount = balance.sub(totalBalance);\\n\\n        uint256 actualRepayAmount =\\n            Math.min(borrowBalance(borrower), repayAmount);\\n        seizeTokens = ICollateral(collateral).seize(\\n            liquidator,\\n            borrower,\\n            actualRepayAmount\\n        );\\n        (\\n            uint256 accountBorrowsPrior,\\n            uint256 accountBorrows,\\n            uint256 _totalBorrows\\n        ) = _updateBorrow(borrower, 0, repayAmount);\\n\\n        emit Liquidate(\\n            msg.sender,\\n            borrower,\\n            liquidator,\\n            seizeTokens,\\n            repayAmount,\\n            accountBorrowsPrior,\\n            accountBorrows,\\n            _totalBorrows\\n        );\\n    }\\n\\n    function trackBorrow(address borrower) external {\\n        _trackBorrow(borrower, borrowBalance(borrower), borrowIndex);\\n    }\\n\\n    modifier accrue() {\\n        accrueInterest();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PoolToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./TarotERC20.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract PoolToken is IPoolToken, TarotERC20 {\\n    uint256 internal constant initialExchangeRate = 1e18;\\n    address public underlying;\\n    address public factory;\\n    uint256 public totalBalance;\\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    /*** Initialize ***/\\n\\n    // called once by the factory\\n    function _setFactory() external {\\n        require(factory == address(0), \\\"Tarot: FACTORY_ALREADY_SET\\\");\\n        factory = msg.sender;\\n    }\\n\\n    /*** PoolToken ***/\\n\\n    function _update() internal {\\n        totalBalance = IERC20(underlying).balanceOf(address(this));\\n        emit Sync(totalBalance);\\n    }\\n\\n    function exchangeRate() public returns (uint256) {\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        uint256 _totalBalance = totalBalance; // gas savings\\n        if (_totalSupply == 0 || _totalBalance == 0) return initialExchangeRate;\\n        return _totalBalance.mul(1e18).div(_totalSupply);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function mint(address minter)\\n        external\\n        nonReentrant\\n        update\\n        returns (uint256 mintTokens)\\n    {\\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\\n        uint256 mintAmount = balance.sub(totalBalance);\\n        mintTokens = mintAmount.mul(1e18).div(exchangeRate());\\n\\n        if (totalSupply == 0) {\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            mintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY);\\n        }\\n        require(mintTokens > 0, \\\"Tarot: MINT_AMOUNT_ZERO\\\");\\n        _mint(minter, mintTokens);\\n        emit Mint(msg.sender, minter, mintAmount, mintTokens);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function redeem(address redeemer)\\n        external\\n        nonReentrant\\n        update\\n        returns (uint256 redeemAmount)\\n    {\\n        uint256 redeemTokens = balanceOf[address(this)];\\n        redeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\\n\\n        require(redeemAmount > 0, \\\"Tarot: REDEEM_AMOUNT_ZERO\\\");\\n        require(redeemAmount <= totalBalance, \\\"Tarot: INSUFFICIENT_CASH\\\");\\n        _burn(address(this), redeemTokens);\\n        _safeTransfer(redeemer, redeemAmount);\\n        emit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    // force real balance to match totalBalance\\n    function skim(address to) external nonReentrant {\\n        _safeTransfer(\\n            to,\\n            IERC20(underlying).balanceOf(address(this)).sub(totalBalance)\\n        );\\n    }\\n\\n    // force totalBalance to match real balance\\n    function sync() external nonReentrant update {}\\n\\n    /*** Utilities ***/\\n\\n    // same safe transfer function used by UniSwapV2 (with fixed underlying)\\n    bytes4 private constant SELECTOR =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    function _safeTransfer(address to, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            underlying.call(abi.encodeWithSelector(SELECTOR, to, amount));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"Tarot: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    // prevents a contract from calling itself, directly or indirectly.\\n    bool internal _notEntered = true;\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"Tarot: REENTERED\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true;\\n    }\\n\\n    // update totalBalance with current balance\\n    modifier update() {\\n        _;\\n        _update();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BAllowance.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\n\\ncontract BAllowance is PoolToken, BStorage {\\n    event BorrowApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function _borrowApprove(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        borrowAllowance[owner][spender] = value;\\n        emit BorrowApproval(owner, spender, value);\\n    }\\n\\n    function borrowApprove(address spender, uint256 value)\\n        external\\n        returns (bool)\\n    {\\n        _borrowApprove(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function _checkBorrowAllowance(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 _borrowAllowance = borrowAllowance[owner][spender];\\n        if (spender != owner && _borrowAllowance != uint256(-1)) {\\n            require(_borrowAllowance >= value, \\\"Tarot: BORROW_NOT_ALLOWED\\\");\\n            borrowAllowance[owner][spender] = _borrowAllowance - value;\\n        }\\n    }\\n\\n    // keccak256(\\\"BorrowPermit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant BORROW_PERMIT_TYPEHASH =\\n        0xf6d86ed606f871fa1a557ac0ba607adce07767acf53f492fb215a1a4db4aea6f;\\n\\n    function borrowPermit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        _checkSignature(\\n            owner,\\n            spender,\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s,\\n            BORROW_PERMIT_TYPEHASH\\n        );\\n        _borrowApprove(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BInterestRateModel.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\n\\ncontract BInterestRateModel is PoolToken, BStorage {\\n\\n\\t// When utilization is 100% borrowRate is kinkBorrowRate * KINK_MULTIPLIER\\n\\t// kinkBorrowRate relative adjustment per second belongs to [1-adjustSpeed, 1+adjustSpeed*(KINK_MULTIPLIER-1)]\\n\\tuint public constant KINK_MULTIPLIER = 6;\\n\\tuint public constant KINK_BORROW_RATE_MAX = 8.87874172e9; //28% per year\\n\\tuint public constant KINK_BORROW_RATE_MIN = 0.31709792e9; //1% per year\\n\\n\\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\tevent CalculateKinkBorrowRate(uint kinkBorrowRate);\\n\\tevent CalculateBorrowRate(uint borrowRate);\\n\\t\\t\\n\\tfunction _calculateBorrowRate() internal {\\n\\t\\tuint _kinkUtilizationRateLower = kinkUtilizationRateLower;\\n\\t\\tuint _kinkUtilizationRateUpper = kinkUtilizationRateUpper;\\n\\t\\tuint _adjustSpeed = adjustSpeed;\\n\\t\\tuint _borrowRate = borrowRate;\\t\\n\\t\\tuint _kinkBorrowRate = kinkBorrowRate;\\n\\t\\tuint32 _rateUpdateTimestamp = rateUpdateTimestamp;\\t\\t\\n\\t\\n\\t\\t// update kinkBorrowRate using previous borrowRate\\n\\t\\tuint32 timeElapsed = getBlockTimestamp() - _rateUpdateTimestamp; // underflow is desired\\n\\t\\tif(timeElapsed > 0) {\\n\\t\\t\\trateUpdateTimestamp = getBlockTimestamp();\\n\\t\\t\\tuint adjustFactor;\\n\\t\\t\\t\\n\\t\\t\\tif (_borrowRate < _kinkBorrowRate) {\\n\\t\\t\\t\\t// never overflows, _kinkBorrowRate is never 0\\n\\t\\t\\t\\tuint tmp = (_kinkBorrowRate - _borrowRate) * 1e18 / _kinkBorrowRate * _adjustSpeed * timeElapsed / 1e18;\\n\\t\\t\\t\\tadjustFactor = tmp > 1e18 ? 0 : 1e18 - tmp;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// never overflows, _kinkBorrowRate is never 0\\n\\t\\t\\t\\tuint tmp = (_borrowRate - _kinkBorrowRate) * 1e18 / _kinkBorrowRate * _adjustSpeed * timeElapsed / 1e18;\\n\\t\\t\\t\\tadjustFactor = tmp + 1e18;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// never overflows\\n\\t\\t\\t_kinkBorrowRate = _kinkBorrowRate * adjustFactor / 1e18;\\n\\t\\t\\tif(_kinkBorrowRate > KINK_BORROW_RATE_MAX) _kinkBorrowRate = KINK_BORROW_RATE_MAX;\\n\\t\\t\\tif(_kinkBorrowRate < KINK_BORROW_RATE_MIN) _kinkBorrowRate = KINK_BORROW_RATE_MIN;\\n\\n\\t\\t\\tkinkBorrowRate = uint48(_kinkBorrowRate);\\n\\t\\t\\temit CalculateKinkBorrowRate(_kinkBorrowRate);\\n\\t\\t}\\n\\t\\t\\n\\t\\tuint _utilizationRate;\\n\\t\\t{ // avoid stack to deep\\n\\t\\tuint _totalBorrows = totalBorrows; // gas savings\\n\\t\\tuint _actualBalance = totalBalance.add(_totalBorrows);\\n\\t\\t_utilizationRate = (_actualBalance == 0) ? 0 : _totalBorrows * 1e18 / _actualBalance;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// update borrowRate using the new kinkBorrowRate\\t\\n\\t\\tif(_utilizationRate <= _kinkUtilizationRateLower) {\\n\\t\\t\\t// never overflows, _kinkUtilizationRateLower is never 0\\n\\t\\t\\t_borrowRate = _kinkBorrowRate * _utilizationRate / _kinkUtilizationRateLower;\\n\\t\\t} else if (_utilizationRate <= _kinkUtilizationRateUpper) {\\n\\t\\t\\t_borrowRate = _kinkBorrowRate;\\n\\t\\t} else {\\n\\t\\t\\t// never overflows, _kinkUtilizationRateUpper is always < 1e18\\n\\t\\t\\tuint overUtilization = (_utilizationRate - _kinkUtilizationRateUpper) * 1e18 / (1e18 - _kinkUtilizationRateUpper);\\n\\t\\t\\t// never overflows\\n\\t\\t\\t_borrowRate = ((KINK_MULTIPLIER - 1) * overUtilization + 1e18) * _kinkBorrowRate / 1e18;\\n\\t\\t}\\n\\t\\tborrowRate = uint48(_borrowRate);\\n\\t\\temit CalculateBorrowRate(_borrowRate);\\n\\t}\\n\\t\\n\\t// applies accrued interest to total borrows and reserves\\n\\tfunction accrueInterest() public {\\n\\t\\tuint _borrowIndex = borrowIndex;\\n\\t\\tuint _totalBorrows = totalBorrows;\\n\\t\\tuint32 _accrualTimestamp = accrualTimestamp;\\n\\t\\t\\n\\t\\tuint32 blockTimestamp = getBlockTimestamp();\\n\\t\\tif (_accrualTimestamp == blockTimestamp) return;\\n\\t\\tuint32 timeElapsed = blockTimestamp - _accrualTimestamp; // underflow is desired\\n\\t\\taccrualTimestamp = blockTimestamp;\\n\\t\\t\\n\\t\\tuint interestFactor = uint(borrowRate).mul(timeElapsed);\\t\\n\\t\\tuint interestAccumulated = interestFactor.mul(_totalBorrows).div(1e18);\\n\\t\\t_totalBorrows = _totalBorrows.add( interestAccumulated );\\n\\t\\t_borrowIndex = _borrowIndex.add( interestFactor.mul(_borrowIndex).div(1e18) );\\n\\t\\n\\t\\tborrowIndex = safe112(_borrowIndex);\\n\\t\\ttotalBorrows = safe112(_totalBorrows);\\n\\t\\temit AccrueInterest(interestAccumulated, _borrowIndex, _totalBorrows);\\n\\t}\\n\\t\\t\\n\\tfunction getBlockTimestamp() public view returns (uint32) {\\n\\t\\treturn uint32(block.timestamp % 2**32);\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/BSetter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\n\\ncontract BSetter is PoolToken, BStorage {\\n    uint256 public constant RESERVE_FACTOR_MAX = 0.20e18; //20%\\n    uint256 public constant KINK_UR_MIN = 0.50e18; //50%\\n    uint256 public constant KINK_UR_MAX = 0.99e18; //99%\\n    uint256 public constant ADJUST_SPEED_MIN = 0.05787037e12; //0.5% per day\\n    uint256 public constant ADJUST_SPEED_MAX = 115.74074e12; //1000% per day\\n\\n    event NewReserveFactor(uint256 newReserveFactor);\\n    event NewKinkUtilizationRates(uint256 newKinkUtilizationRateLower, uint256 newKinkUtilizationRateUpper);\\n    event NewAdjustSpeed(uint256 newAdjustSpeed);\\n    event NewBorrowTracker(address newBorrowTracker);\\n\\n    // called once by the factory at time of deployment\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _collateral\\n    ) external {\\n        require(msg.sender == factory, \\\"Tarot: UNAUTHORIZED\\\"); // sufficient check\\n        _setName(_name, _symbol);\\n        underlying = _underlying;\\n        collateral = _collateral;\\n        exchangeRateLast = initialExchangeRate;\\n    }\\n\\n    function _setReserveFactor(uint256 newReserveFactor) external nonReentrant {\\n        _checkSetting(newReserveFactor, 0, RESERVE_FACTOR_MAX);\\n        reserveFactor = newReserveFactor;\\n        emit NewReserveFactor(newReserveFactor);\\n    }\\n\\n    function _setKinkUtilizationRates(uint256 newKinkUtilizationRateLower, uint256 newKinkUtilizationRateUpper)\\n        external\\n        nonReentrant\\n    {\\n        _checkSetting(newKinkUtilizationRateLower, KINK_UR_MIN, newKinkUtilizationRateUpper);\\n        _checkSetting(newKinkUtilizationRateUpper, newKinkUtilizationRateLower, KINK_UR_MAX);\\n        kinkUtilizationRateLower = newKinkUtilizationRateLower;\\n        kinkUtilizationRateUpper = newKinkUtilizationRateUpper;\\n        emit NewKinkUtilizationRates(newKinkUtilizationRateLower, newKinkUtilizationRateUpper);\\n    }\\n\\n    function _setAdjustSpeed(uint256 newAdjustSpeed) external nonReentrant {\\n        _checkSetting(newAdjustSpeed, ADJUST_SPEED_MIN, ADJUST_SPEED_MAX);\\n        adjustSpeed = newAdjustSpeed;\\n        emit NewAdjustSpeed(newAdjustSpeed);\\n    }\\n\\n    function _setBorrowTracker(address newBorrowTracker) external nonReentrant {\\n        _checkAdmin();\\n        borrowTracker = newBorrowTracker;\\n        emit NewBorrowTracker(newBorrowTracker);\\n    }\\n\\n    function _checkSetting(\\n        uint256 parameter,\\n        uint256 min,\\n        uint256 max\\n    ) internal view {\\n        _checkAdmin();\\n        require(parameter >= min, \\\"Tarot: INVALID_SETTING\\\");\\n        require(parameter <= max, \\\"Tarot: INVALID_SETTING\\\");\\n    }\\n\\n    function _checkAdmin() internal view {\\n        require(msg.sender == IFactory(factory).admin(), \\\"Tarot: UNAUTHORIZED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BStorage.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\ncontract BStorage {\\n    address public collateral;\\n\\n    mapping(address => mapping(address => uint256)) public borrowAllowance;\\n\\n    struct BorrowSnapshot {\\n        uint112 principal; // amount in underlying when the borrow was last updated\\n        uint112 interestIndex; // borrow index when borrow was last updated\\n    }\\n    mapping(address => BorrowSnapshot) internal borrowBalances;\\n\\n    // use one memory slot\\n    uint112 public borrowIndex = 1e18;\\n    uint112 public totalBorrows;\\n    uint32 public accrualTimestamp = uint32(block.timestamp % 2**32);\\n\\n    uint256 public exchangeRateLast;\\n\\n    // use one memory slot\\n    uint48 public borrowRate;\\n    uint48 public kinkBorrowRate = 1.5854896e9; //5% per year\\n    uint32 public rateUpdateTimestamp = uint32(block.timestamp % 2**32);\\n\\n    uint256 public reserveFactor = 0.10e18; //10%\\n    uint256 public kinkUtilizationRateLower = 0.8e18; //80%\\n    uint256 public kinkUtilizationRateUpper = 0.9e18; //90%\\n    uint256 public adjustSpeed = 2.893518e12; //25% per day\\n    address public borrowTracker;\\n\\n    function safe112(uint256 n) internal pure returns (uint112) {\\n        require(n < 2**112, \\\"Tarot: SAFE112\\\");\\n        return uint112(n);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBorrowable.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBorrowable {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** Borrowable ***/\\n\\n    event BorrowApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Borrow(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed receiver,\\n        uint256 borrowAmount,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n    event Liquidate(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed liquidator,\\n        uint256 seizeTokens,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    function BORROW_FEE() external pure returns (uint256);\\n\\n    function collateral() external view returns (address);\\n\\n    function reserveFactor() external view returns (uint256);\\n\\n    function exchangeRateLast() external view returns (uint256);\\n\\n    function borrowIndex() external view returns (uint256);\\n\\n    function totalBorrows() external view returns (uint256);\\n\\n    function borrowAllowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function borrowBalance(address borrower) external view returns (uint256);\\n\\n    function borrowTracker() external view returns (address);\\n\\n    function BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function borrowApprove(address spender, uint256 value)\\n        external\\n        returns (bool);\\n\\n    function borrowPermit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function borrow(\\n        address borrower,\\n        address receiver,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function liquidate(address borrower, address liquidator)\\n        external\\n        returns (uint256 seizeTokens);\\n\\n    function trackBorrow(address borrower) external;\\n\\n    /*** Borrowable Interest Rate Model ***/\\n\\n    event AccrueInterest(\\n        uint256 interestAccumulated,\\n        uint256 borrowIndex,\\n        uint256 totalBorrows\\n    );\\n    event CalculateKink(uint256 kinkRate);\\n    event CalculateBorrowRate(uint256 borrowRate);\\n\\n    function KINK_BORROW_RATE_MAX() external pure returns (uint256);\\n\\n    function KINK_BORROW_RATE_MIN() external pure returns (uint256);\\n\\n    function KINK_MULTIPLIER() external pure returns (uint256);\\n\\n    function borrowRate() external view returns (uint256);\\n\\n    function kinkBorrowRate() external view returns (uint256);\\n\\n    function kinkUtilizationRateLower() external view returns (uint256);\\n\\n    function kinkUtilizationRateUpper() external view returns (uint256);\\n\\n    function adjustSpeed() external view returns (uint256);\\n\\n    function rateUpdateTimestamp() external view returns (uint32);\\n\\n    function accrualTimestamp() external view returns (uint32);\\n\\n    function accrueInterest() external;\\n\\n    /*** Borrowable Setter ***/\\n\\n    event NewReserveFactor(uint256 newReserveFactor);\\n    event NewKinkUtilizationRates(uint256 newKinkUtilizationRateLower, uint256 newKinkUtilizationRateUpper);\\n    event NewAdjustSpeed(uint256 newAdjustSpeed);\\n    event NewBorrowTracker(address newBorrowTracker);\\n\\n    function RESERVE_FACTOR_MAX() external pure returns (uint256);\\n\\n    function KINK_UR_MIN() external pure returns (uint256);\\n\\n    function KINK_UR_MAX() external pure returns (uint256);\\n\\n    function ADJUST_SPEED_MIN() external pure returns (uint256);\\n\\n    function ADJUST_SPEED_MAX() external pure returns (uint256);\\n\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _collateral\\n    ) external;\\n\\n    function _setReserveFactor(uint256 newReserveFactor) external;\\n\\n    function _setKinkUtilizationRates(uint256 newKinkUtilizationRateLower, uint256 newKinkUtilizationRateUpper) external;\\n\\n    function _setAdjustSpeed(uint256 newAdjustSpeed) external;\\n\\n    function _setBorrowTracker(address newBorrowTracker) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateral.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ICollateral {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** Collateral ***/\\n\\n    function borrowable0() external view returns (address);\\n\\n    function borrowable1() external view returns (address);\\n\\n    function tarotPriceOracle() external view returns (address);\\n\\n    function safetyMargin() external view returns (uint256);\\n\\n    function mTolerance() external view returns (uint256);\\n\\n    function liquidationIncentive() external view returns (uint256);\\n\\n    function liquidationFee() external view returns (uint256);\\n\\n    function liquidationPenalty() external view returns (uint256);\\n\\n    function getPrices() external returns (uint256 price0, uint256 price1);\\n\\n    function getReserves() external returns (uint112 reserve0, uint112 reserve1);\\n\\n    function tokensUnlocked(address from, uint256 value)\\n        external\\n        returns (bool);\\n\\n    function accountLiquidityAmounts(\\n        address account,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external returns (uint256 liquidity, uint256 shortfall);\\n\\n    function accountLiquidity(address account)\\n        external\\n        returns (uint256 liquidity, uint256 shortfall);\\n\\n    function canBorrow(\\n        address account,\\n        address borrowable,\\n        uint256 accountBorrows\\n    ) external returns (bool);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256 seizeTokens);\\n\\n    function flashRedeem(\\n        address redeemer,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    /*** Collateral Setter ***/\\n\\n    event NewSafetyMargin(uint256 newSafetyMarginSqrt);\\n    event NewLiquidationIncentive(uint256 newLiquidationIncentive);\\n    event NewLiquidationFee(uint256 newLiquidationFee);\\n    event NewMTolerance(uint256 mTolerance);\\n\\n    function M_TOLERANCE_MIN() external pure returns (uint256);\\n    \\n    function M_TOLERANCE_MAX() external pure returns (uint256);\\n\\n    function SAFETY_MARGIN_MIN() external pure returns (uint256);\\n\\n    function SAFETY_MARGIN_MAX() external pure returns (uint256);\\n\\n    function LIQUIDATION_INCENTIVE_MIN() external pure returns (uint256);\\n\\n    function LIQUIDATION_INCENTIVE_MAX() external pure returns (uint256);\\n\\n    function LIQUIDATION_FEE_MAX() external pure returns (uint256);\\n\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _borrowable0,\\n        address _borrowable1\\n    ) external;\\n\\n    function _setSafetyMargin(uint256 newSafetyMargin) external;\\n\\n    function _setLiquidationIncentive(uint256 newLiquidationIncentive) external;\\n\\n    function _setLiquidationFee(uint256 newLiquidationFee) external;\\n    \\n    function _setMTolerance(uint256 newMTolerance) external;\\n\\n    function isUnderlyingVaultToken() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITarotCallee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITarotCallee {\\n    function tarotBorrow(\\n        address sender,\\n        address borrower,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function tarotRedeem(\\n        address sender,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IFactory {\\n\\tevent LendingPoolInitialized(address indexed uniswapV2Pair, address indexed token0, address indexed token1,\\n\\t\\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\\n\\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\tevent NewAdmin(address oldAdmin, address newAdmin);\\n\\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\\n\\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\\n\\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\\n\\t\\n\\tfunction admin() external view returns (address);\\n\\tfunction pendingAdmin() external view returns (address);\\n\\tfunction reservesAdmin() external view returns (address);\\n\\tfunction reservesPendingAdmin() external view returns (address);\\n\\tfunction reservesManager() external view returns (address);\\n\\n\\tfunction getLendingPool(address uniswapV2Pair) external view returns (\\n\\t\\tbool initialized, \\n\\t\\tuint24 lendingPoolId, \\n\\t\\taddress collateral, \\n\\t\\taddress borrowable0, \\n\\t\\taddress borrowable1\\n\\t);\\n\\tfunction allLendingPools(uint) external view returns (address uniswapV2Pair);\\n\\tfunction allLendingPoolsLength() external view returns (uint);\\n\\t\\n\\tfunction bDeployer() external view returns (address);\\n\\tfunction cDeployer() external view returns (address);\\n\\tfunction tarotPriceOracle() external view returns (address);\\n\\n\\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral);\\n\\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0);\\n\\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1);\\n\\tfunction initializeLendingPool(address uniswapV2Pair) external;\\n\\n\\tfunction _setPendingAdmin(address newPendingAdmin) external;\\n\\tfunction _acceptAdmin() external;\\n\\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\\n\\tfunction _acceptReservesAdmin() external;\\n\\tfunction _setReservesManager(address newReservesManager) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBorrowTracker.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBorrowTracker {\\n\\tfunction trackBorrow(address borrower, uint borrowBalance, uint borrowIndex) external;\\n}\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing various math operations\\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TarotERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\n// This contract is basically UniswapV2ERC20 with small modifications\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\\n\\ncontract TarotERC20 {\\n    using SafeMath for uint256;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    mapping(address => uint256) public nonces;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    constructor() public {}\\n\\n    function _setName(string memory _name, string memory _symbol) internal {\\n        name = _name;\\n        symbol = _symbol;\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(_name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        balanceOf[from] = balanceOf[from].sub(\\n            value,\\n            \\\"Tarot: TRANSFER_TOO_HIGH\\\"\\n        );\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\\n                value,\\n                \\\"Tarot: TRANSFER_NOT_ALLOWED\\\"\\n            );\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _checkSignature(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes32 typehash\\n    ) internal {\\n        require(deadline >= block.timestamp, \\\"Tarot: EXPIRED\\\");\\n        bytes32 digest =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR,\\n                    keccak256(\\n                        abi.encode(\\n                            typehash,\\n                            owner,\\n                            spender,\\n                            value,\\n                            nonces[owner]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"Tarot: INVALID_SIGNATURE\\\"\\n        );\\n    }\\n\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        _checkSignature(\\n            owner,\\n            spender,\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s,\\n            PERMIT_TYPEHASH\\n        );\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IPoolToken {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BorrowApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"name\":\"CalculateBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kinkRate\",\"type\":\"uint256\"}],\"name\":\"CalculateKink\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kinkBorrowRate\",\"type\":\"uint256\"}],\"name\":\"CalculateKinkBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdjustSpeed\",\"type\":\"uint256\"}],\"name\":\"NewAdjustSpeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBorrowTracker\",\"type\":\"address\"}],\"name\":\"NewBorrowTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRateLower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRateUpper\",\"type\":\"uint256\"}],\"name\":\"NewKinkUtilizationRates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactor\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADJUST_SPEED_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADJUST_SPEED_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BORROW_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BORROW_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_BORROW_RATE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_BORROW_RATE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_UR_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_UR_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVE_FACTOR_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdjustSpeed\",\"type\":\"uint256\"}],\"name\":\"_setAdjustSpeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBorrowTracker\",\"type\":\"address\"}],\"name\":\"_setBorrowTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRateLower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRateUpper\",\"type\":\"uint256\"}],\"name\":\"_setKinkUtilizationRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactor\",\"type\":\"uint256\"}],\"name\":\"_setReserveFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adjustSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"borrowApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"borrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"borrowPermit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowRate\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkBorrowRate\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkUtilizationRateLower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkUtilizationRateUpper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"trackBorrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Borrowable", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}