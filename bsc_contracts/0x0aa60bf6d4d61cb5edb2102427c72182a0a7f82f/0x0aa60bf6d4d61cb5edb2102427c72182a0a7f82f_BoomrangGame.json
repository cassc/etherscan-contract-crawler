{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\n/*\r\n\u2705 BOOMRANG DeFi PROTOCOL - Official Smart Contract.\r\n\r\nWeb site - boomrang.io or check by the function - getOfficialWebsite.\r\n\r\nMutual Aid Fund.\r\n*/\r\n\r\ncontract BoomrangGame {\r\n \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    address public owner;\r\n    address private newOwner;\r\n\r\n    struct Player {\r\n        address payable addr; \r\n        uint8 position;\r\n    }\r\n\r\n    struct Table {\r\n        uint8 tableType; \r\n        bool isActive;\r\n        uint8 playerCount;\r\n        mapping(uint8 => Player) players;\r\n        mapping(address => bool) isPlayerPresent;\r\n    }\r\n  \r\n    uint8 constant MAX_PLAYERS = 15;\r\n    uint8 FEE_PERCENTAGE = 125;\r\n    uint256 constant ENTRY_FEE_1 = 0.1 ether;\r\n    uint256 constant ENTRY_FEE_2 = 1 ether;\r\n    uint256 constant ENTRY_FEE_3 = 5 ether;\r\n    uint256 public customFeeMultiplier = 115;\r\n    uint256 public numberOfTables;\r\n    string public officialWebsite;\r\n\r\n    mapping(bytes32 => Table) public tables;\r\n    mapping(address => uint256) public pendingWithdrawals;\r\n    mapping(address => address) public referrers;\r\n    mapping(address => uint256) public referralRewards;\r\n    mapping(address => bytes32[]) public playerTables;\r\n    bool public gameStarted = false;\r\n    bool private paused = false;\r\n    uint256 tableCounter = 0;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is not paused\");\r\n        _;\r\n    }\r\n    function pause() external onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    function unpause() external onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n\r\n   \r\n   \r\n    event Paused();\r\n    event Unpaused();\r\n    event PlayerJoined(address indexed playerAddress, bytes32 indexed tableId, uint8 indexed position);\r\n    event TableClosed(bytes32 indexed tableId, address winner);\r\n    event NewTableCreated(bytes32 tableId);\r\n    event CustomTableCreated(bytes32 tableId, address creator);\r\n    event OwnershipTransferProposed(address indexed currentOwner, address indexed proposedOwner);    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    function proposeNewOwner(address _newOwner) external onlyOwner {\r\n        require(_newOwner != address(0) && _newOwner != owner, \"Invalid new owner address\");\r\n        newOwner = _newOwner;\r\n        emit OwnershipTransferProposed(owner, newOwner);\r\n    }\r\n  \r\n    function acceptOwnership() external {\r\n        require(msg.sender == newOwner, \"Only the proposed owner can accept ownership\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n  \r\n    struct PlayerInfo {\r\n        address playerAddress;\r\n        uint8 position;\r\n    }\r\n\r\n    function claimReferralReward() external {\r\n        uint256 reward = referralRewards[msg.sender];\r\n        require(reward > 0, \"No referral rewards to claim\");\r\n\r\n        referralRewards[msg.sender] = 0;\r\n        payable(msg.sender).transfer(reward);\r\n    }\r\n\r\n    function claim() external {\r\n        uint256 amount = pendingWithdrawals[msg.sender];\r\n        require(amount > 0, \"No funds to withdraw\");\r\n\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    function startGame() external onlyOwner {\r\n        require(!gameStarted, \"The game has already been started.\");\r\n\r\n        uint8 tableTypeFirst = 1;\r\n        bytes32 firstTableId = getNextTableId(tableTypeFirst);  \r\n\r\n        Table storage table = tables[firstTableId];\r\n\r\n        Player memory ownerPlayer = Player({\r\n            addr: payable(owner),\r\n            position: 1\r\n        });\r\n\r\n        table.players[1] = ownerPlayer;\r\n        table.playerCount = 1;\r\n        table.isPlayerPresent[owner] = true;\r\n        table.tableType = tableTypeFirst;\r\n        gameStarted = true;  \r\n        playerTables[msg.sender].push(firstTableId);\r\n        emit PlayerJoined(owner, firstTableId, 1);  \r\n    }\r\n\r\n\r\n    function joinGame(bytes32 tableId, uint8 chosenPosition, address _referrer) external payable whenNotPaused {\r\n        require(tables[tableId].isActive, \"Table is not active.\");\r\n        \r\n        uint8 tableType = tables[tableId].tableType;\r\n        if (tableType == 1) require(msg.value == ENTRY_FEE_1, \"Incorrect BNB amount sent\");\r\n        if (tableType == 2) require(msg.value == ENTRY_FEE_2, \"Incorrect BNB amount sent\");\r\n        if (tableType == 3) require(msg.value == ENTRY_FEE_3, \"Incorrect BNB amount sent\");\r\n        require(tables[tableId].playerCount > 0, \"This table doesn't exist.\");\r\n        require(chosenPosition >= 2 && chosenPosition <= 15, \"Position should be between 2 and 15\");\r\n\r\n        Table storage table = tables[tableId];\r\n\r\n        require(!table.isPlayerPresent[msg.sender], \"You are already a player at this table.\");\r\n        require(table.players[chosenPosition].addr == address(0), \"Position is already taken\");\r\n\r\n        \r\n        Player memory newPlayer = Player({\r\n            addr: payable(msg.sender),\r\n            position: chosenPosition\r\n        });\r\n\r\n        table.players[chosenPosition] = newPlayer;\r\n        table.isPlayerPresent[msg.sender] = true;\r\n        emit PlayerJoined(msg.sender, tableId, chosenPosition);\r\n        table.playerCount++;\r\n        if (_referrer == address(0)) {\r\n            _referrer = owner;\r\n        }\r\n        require(_referrer != msg.sender, \"You cannot refer yourself\");\r\n        if (referrers[msg.sender] == address(0)) {\r\n            referrers[msg.sender] = _referrer;\r\n        }\r\n\r\n        address referrer = referrers[msg.sender];\r\n        uint256 reward = (msg.value * 3) / 100;\r\n        referralRewards[referrer] += reward;\r\n\r\n        playerTables[msg.sender].push(tableId);\r\n        if (table.playerCount == MAX_PLAYERS) {\r\n            closeTable(tableId);\r\n        }\r\n    }\r\n\r\n    function getTablePlayers(bytes32 tableId) external view returns (PlayerInfo[] memory) {\r\n        uint8 maxPosition = 15; \r\n        PlayerInfo[] memory playersList = new PlayerInfo[](maxPosition);\r\n\r\n        for (uint8 i = 1; i <= maxPosition; i++) {\r\n            if (tables[tableId].players[i].addr != address(0)) {\r\n                playersList[i-1] = PlayerInfo({\r\n                    playerAddress: tables[tableId].players[i].addr,\r\n                    position: tables[tableId].players[i].position\r\n                });\r\n            } else {\r\n                playersList[i-1] = PlayerInfo({\r\n                    playerAddress: address(0),\r\n                    position: 0\r\n                });\r\n            }\r\n        }\r\n\r\n        return playersList;\r\n    }\r\n\r\n    \r\n    function setReferrer(address _referrer) external {\r\n            require(_referrer != msg.sender, \"You cannot refer yourself\");\r\n            require(referrers[msg.sender] == address(0), \"You already have a referrer\");\r\n\r\n            referrers[msg.sender] = _referrer;\r\n          \r\n        }\r\n          \r\n    function getCustomEntryFee(uint8 tableType) public view returns (uint256) {\r\n        uint256 baseFee;\r\n        \r\n        if (tableType == 1) {\r\n            baseFee = ENTRY_FEE_1;\r\n        } else if (tableType == 2) {\r\n            baseFee = ENTRY_FEE_2 ;\r\n        } else if (tableType == 3) {\r\n            baseFee = ENTRY_FEE_3;\r\n        } else {\r\n            revert(\"Invalid table type.\");\r\n        }\r\n\r\n        return baseFee * customFeeMultiplier / 100;\r\n    }      \r\n        \r\n    function createCustomTable(uint8 tableType) external payable whenNotPaused {\r\n        require(tableType >= 1 && tableType <= 3, \"Invalid table type.\");\r\n        require(msg.value == getCustomEntryFee(tableType), \"Incorrect BNB amount sent for custom table creation.\");\r\n\r\n        bytes32 newTableId = createTable(tableType);\r\n\r\n        Table storage table = tables[newTableId];\r\n\r\n        Player memory customPlayer = Player({\r\n            addr: payable(msg.sender),\r\n            position: 1\r\n        });\r\n\r\n        table.players[1] = customPlayer;\r\n        table.isPlayerPresent[msg.sender] = true;\r\n        table.playerCount = 1;\r\n\r\n        playerTables[msg.sender].push(newTableId);\r\n        emit CustomTableCreated(newTableId, msg.sender);\r\n    }\r\n\r\n    \r\n\r\n    function getNextTableId(uint8 tableType) internal returns (bytes32) {\r\n    tableCounter++;\r\n    bytes32 newTableId = keccak256(abi.encodePacked(block.timestamp, block.prevrandao, msg.sender, tableCounter, tableType));\r\n    while(tables[newTableId].playerCount != 0) {\r\n        tableCounter++;\r\n        newTableId = keccak256(abi.encodePacked(block.timestamp, block.prevrandao, msg.sender, tableCounter, tableType));\r\n    }\r\n    numberOfTables++;\r\n    emit NewTableCreated(newTableId);\r\n    return newTableId;\r\n}\r\n     \r\n     function createTable(uint8 tableType) internal returns (bytes32) {\r\n            bytes32 newTableId = getNextTableId(tableType);\r\n            \r\n            tables[newTableId].isActive = true;\r\n            tables[newTableId].tableType = tableType;\r\n            \r\n            return newTableId;\r\n     }\r\n\r\n    \r\n    function closeTable(bytes32 tableId) internal {\r\n        Table storage table = tables[tableId];\r\n        table.isActive = false;\r\n\r\n        uint256 entryFee;\r\n        if (table.tableType == 1) entryFee = ENTRY_FEE_1;\r\n        else if (table.tableType == 2) entryFee = ENTRY_FEE_2;\r\n        else if (table.tableType == 3) entryFee = ENTRY_FEE_3;\r\n        else revert(\"Invalid table type.\");\r\n\r\n        address payable winner = table.players[1].addr;\r\n        uint256 prize = entryFee * 8;\r\n        uint256 fee = (prize * FEE_PERCENTAGE) / 1000;\r\n        prize -= fee;\r\n\r\n        pendingWithdrawals[winner] += prize;\r\n        emit TableClosed(tableId, winner);\r\n\r\n\r\n        bytes32 newTableId1 = createTable(table.tableType);\r\n        bytes32 newTableId2 = createTable(table.tableType);\r\n     \r\n        tables[newTableId1].isActive = true;\r\n        tables[newTableId1].tableType = table.tableType; \r\n        tables[newTableId1].players[1] = Player(table.players[2].addr, 1);\r\n        tables[newTableId1].players[2] = Player(table.players[4].addr, 2);\r\n        tables[newTableId1].players[3] = Player(table.players[5].addr, 3);\r\n        tables[newTableId1].players[4] = Player(table.players[8].addr, 4);\r\n        tables[newTableId1].players[5] = Player(table.players[9].addr, 5);\r\n        tables[newTableId1].players[6] = Player(table.players[10].addr, 6);\r\n        tables[newTableId1].players[7] = Player(table.players[11].addr, 7);\r\n        tables[newTableId1].playerCount += 7;\r\n        for (uint8 i = 1; i <= 7; i++) {\r\n            tables[newTableId1].isPlayerPresent[tables[newTableId1].players[i].addr] = true;\r\n            playerTables[tables[newTableId1].players[i].addr].push(newTableId1);\r\n        }\r\n\r\n      \r\n        tables[newTableId2].isActive = true; \r\n        tables[newTableId2].tableType = table.tableType; \r\n        tables[newTableId2].players[1] = Player(table.players[3].addr, 1);\r\n        tables[newTableId2].players[2] = Player(table.players[6].addr, 2);\r\n        tables[newTableId2].players[3] = Player(table.players[7].addr, 3);\r\n        tables[newTableId2].players[4] = Player(table.players[12].addr, 4);\r\n        tables[newTableId2].players[5] = Player(table.players[13].addr, 5);\r\n        tables[newTableId2].players[6] = Player(table.players[14].addr, 6);\r\n        tables[newTableId2].players[7] = Player(table.players[15].addr, 7);\r\n        tables[newTableId2].playerCount += 7;\r\n        for (uint8 i = 1; i <= 7; i++) {\r\n            tables[newTableId2].isPlayerPresent[tables[newTableId2].players[i].addr] = true;\r\n            playerTables[tables[newTableId2].players[i].addr].push(newTableId2);\r\n        }\r\n\r\n        for (uint8 i = 1; i <= MAX_PLAYERS; i++) {\r\n            removeTableIdFromPlayer(tableId, table.players[i].addr); \r\n            delete table.isPlayerPresent[table.players[i].addr];\r\n            delete table.players[i];\r\n        }\r\n    }\r\n\r\n\r\n    function getPlayerTables(address player) public view returns (bytes32[] memory) {\r\n        return playerTables[player];\r\n    }\r\n\r\n    function removeTableIdFromPlayer(bytes32 tableId, address player) internal {\r\n        bytes32[] storage tableList = playerTables[player];\r\n        for (uint256 i = 0; i < tableList.length; i++) {\r\n            if (tableList[i] == tableId) {\r\n                tableList[i] = tableList[tableList.length - 1];\r\n                tableList.pop();\r\n                break;\r\n            }\r\n        }\r\n    } \r\n\r\n    function changeFeePercentage(uint8 newPercentage) external onlyOwner {\r\n        require(newPercentage >= 0 && newPercentage <= 100, \"Percentage should be between 0 and 100\");\r\n        FEE_PERCENTAGE = newPercentage;\r\n    }\r\n  \r\n    function feeOut(uint256 amount) external onlyOwner {\r\n        require(address(this).balance >= amount, \"Try later\");\r\n        uint256 previousBalance = address(this).balance;\r\n        payable(owner).transfer(amount);\r\n        assert(address(this).balance == previousBalance - amount);\r\n    }\r\n\r\n    function getBalance(address player) public view returns (uint256) {\r\n        return pendingWithdrawals[player];\r\n    }\r\n\r\n    function setCustomFeeMultiplier(uint256 newMultiplier) external onlyOwner {\r\n        require(newMultiplier > 0, \"Multiplier should be greater than 0\");\r\n        customFeeMultiplier = newMultiplier;\r\n    }\r\n    function setOfficialWebsite(string calldata newWebsite) external onlyOwner {\r\n        officialWebsite = newWebsite;\r\n    }\r\n\r\n    function getOfficialWebsite() external view returns (string memory) {\r\n        return officialWebsite;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tableId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"CustomTableCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"tableId\",\"type\":\"bytes32\"}],\"name\":\"NewTableCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tableId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"}],\"name\":\"PlayerJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"tableId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"TableClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newPercentage\",\"type\":\"uint8\"}],\"name\":\"changeFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tableType\",\"type\":\"uint8\"}],\"name\":\"createCustomTable\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customFeeMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tableType\",\"type\":\"uint8\"}],\"name\":\"getCustomEntryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOfficialWebsite\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerTables\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tableId\",\"type\":\"bytes32\"}],\"name\":\"getTablePlayers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct BoomrangGame.PlayerInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tableId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"chosenPosition\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"joinGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfTables\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"officialWebsite\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerTables\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMultiplier\",\"type\":\"uint256\"}],\"name\":\"setCustomFeeMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newWebsite\",\"type\":\"string\"}],\"name\":\"setOfficialWebsite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"setReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"tables\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"tableType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"playerCount\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BoomrangGame", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0bf8c94af6b3fe1ba8dfaabd5bad483392654b6f6f4ad6797d3de4d6b645874e"}