{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/dripCustom/reservoir.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.25;\\n\\ninterface IToken {\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\\n\\ninterface ISwap {\\n\\n    /**\\n      * @dev Pricing function for converting between BNB && Tokens.\\n      * @param input_amount Amount of BNB or Tokens being sold.\\n      * @param input_reserve Amount of BNB or Tokens (input type) in exchange reserves.\\n      * @param output_reserve Amount of BNB or Tokens (output type) in exchange reserves.\\n      * @return Amount of BNB or Tokens bought.\\n      */\\n    function getInputPrice(uint256 input_amount, uint256 input_reserve, uint256 output_reserve) external view returns (uint256);\\n\\n    /**\\n      * @dev Pricing function for converting between BNB && Tokens.\\n      * @param output_amount Amount of BNB or Tokens being bought.\\n      * @param input_reserve Amount of BNB or Tokens (input type) in exchange reserves.\\n      * @param output_reserve Amount of BNB or Tokens (output type) in exchange reserves.\\n      * @return Amount of BNB or Tokens sold.\\n      */\\n    function getOutputPrice(uint256 output_amount, uint256 input_reserve, uint256 output_reserve) external view returns (uint256);\\n    /**\\n     * @notice Convert BNB to Tokens.\\n     * @dev User specifies exact input (msg.value) && minimum output.\\n     * @param min_tokens Minimum Tokens bought.\\n     * @return Amount of Tokens bought.\\n     */\\n    function bnbToTokenSwapInput(uint256 min_tokens) external payable returns (uint256);\\n\\n    /**\\n     * @notice Convert BNB to Tokens.\\n     * @dev User specifies maximum input (msg.value) && exact output.\\n     * @param tokens_bought Amount of tokens bought.\\n     * @return Amount of BNB sold.\\n     */\\n    function bnbToTokenSwapOutput(uint256 tokens_bought) external payable returns (uint256);\\n\\n    /**\\n     * @notice Convert Tokens to BNB.\\n     * @dev User specifies exact input && minimum output.\\n     * @param tokens_sold Amount of Tokens sold.\\n     * @param min_bnb Minimum BNB purchased.\\n     * @return Amount of BNB bought.\\n     */\\n    function tokenToBnbSwapInput(uint256 tokens_sold, uint256 min_bnb) external returns (uint256);\\n\\n    /**\\n     * @notice Convert Tokens to BNB.\\n     * @dev User specifies maximum input && exact output.\\n     * @param bnb_bought Amount of BNB purchased.\\n     * @param max_tokens Maximum Tokens sold.\\n     * @return Amount of Tokens sold.\\n     */\\n    function tokenToBnbSwapOutput(uint256 bnb_bought, uint256 max_tokens) external returns (uint256);\\n\\n    /***********************************|\\n    |         Getter Functions          |\\n    |__________________________________*/\\n\\n    /**\\n     * @notice Public price function for BNB to Token trades with an exact input.\\n     * @param bnb_sold Amount of BNB sold.\\n     * @return Amount of Tokens that can be bought with input BNB.\\n     */\\n    function getBnbToTokenInputPrice(uint256 bnb_sold) external view returns (uint256);\\n\\n    /**\\n     * @notice Public price function for BNB to Token trades with an exact output.\\n     * @param tokens_bought Amount of Tokens bought.\\n     * @return Amount of BNB needed to buy output Tokens.\\n     */\\n    function getBnbToTokenOutputPrice(uint256 tokens_bought) external view returns (uint256);\\n\\n    /**\\n     * @notice Public price function for Token to BNB trades with an exact input.\\n     * @param tokens_sold Amount of Tokens sold.\\n     * @return Amount of BNB that can be bought with input Tokens.\\n     */\\n    function getTokenToBnbInputPrice(uint256 tokens_sold) external view returns (uint256);\\n\\n    /**\\n     * @notice Public price function for Token to BNB trades with an exact output.\\n     * @param bnb_bought Amount of output BNB.\\n     * @return Amount of Tokens needed to buy output BNB.\\n     */\\n    function getTokenToBnbOutputPrice(uint256 bnb_bought) external view returns (uint256) ;\\n\\n    /**\\n     * @return Address of Token that is sold on this exchange.\\n     */\\n    function tokenAddress() external view returns (address) ;\\n\\n    function bnbBalance() external view returns (uint256);\\n\\n    function tokenBalance() external view returns (uint256);\\n\\n    function getBnbToLiquidityInputPrice(uint256 bnb_sold) external view returns (uint256);\\n\\n    function getLiquidityToReserveInputPrice(uint amount) external view returns (uint256, uint256);\\n\\n    function txs(address owner) external view returns (uint256) ;\\n\\n\\n    /***********************************|\\n    |        Liquidity Functions        |\\n    |__________________________________*/\\n\\n    /**\\n     * @notice Deposit BNB && Tokens (token) at current ratio to mint SWAP tokens.\\n     * @dev min_liquidity does nothing when total SWAP supply is 0.\\n     * @param min_liquidity Minimum number of SWAP sender will mint if total SWAP supply is greater than 0.\\n     * @param max_tokens Maximum number of tokens deposited. Deposits max amount if total SWAP supply is 0.\\n     * @return The amount of SWAP minted.\\n     */\\n    function addLiquidity(uint256 min_liquidity, uint256 max_tokens) external payable returns (uint256) ;\\n\\n    /**\\n     * @dev Burn SWAP tokens to withdraw BNB && Tokens at current ratio.\\n     * @param amount Amount of SWAP burned.\\n     * @param min_bnb Minimum BNB withdrawn.\\n     * @param min_tokens Minimum Tokens withdrawn.\\n     * @return The amount of BNB && Tokens withdrawn.\\n     */\\n    function removeLiquidity(uint256 amount, uint256 min_bnb, uint256 min_tokens) external returns (uint256, uint256);\\n}\\n\\ncontract Reservoir {\\n\\n    using SafeMath for uint;\\n\\n    /*=================================\\n    =            MODIFIERS            =\\n    =================================*/\\n\\n    /// @dev Only people with tokens\\n    modifier onlyBagholders {\\n        require(myTokens() > 0);\\n        _;\\n    }\\n\\n    /// @dev Only people with profits\\n    modifier onlyStronghands {\\n        require(myDividends() > 0);\\n        _;\\n    }\\n\\n\\n\\n    /*==============================\\n    =            EVENTS            =\\n    ==============================*/\\n\\n\\n    event onLeaderBoard(\\n        address indexed customerAddress,\\n        uint256 invested,\\n        uint256 tokens,\\n        uint256 soldTokens,\\n        uint256 timestamp\\n    );\\n\\n    event onTokenPurchase(\\n        address indexed customerAddress,\\n        uint256 incomingeth,\\n        uint256 tokensMinted,\\n        uint timestamp\\n    );\\n\\n    event onTokenSell(\\n        address indexed customerAddress,\\n        uint256 tokensBurned,\\n        uint256 ethEarned,\\n        uint timestamp\\n    );\\n\\n    event onReinvestment(\\n        address indexed customerAddress,\\n        uint256 ethReinvested,\\n        uint256 tokensMinted,\\n        uint256 timestamp\\n    );\\n\\n    event onWithdraw(\\n        address indexed customerAddress,\\n        uint256 ethWithdrawn,\\n        uint256 timestamp\\n    );\\n\\n    event onClaim(\\n        address indexed customerAddress,\\n        uint256 tokens,\\n        uint256 timestamp\\n    );\\n\\n    event onTransfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 tokens,\\n        uint256 timestamp\\n    );\\n\\n    event onBalance(\\n        uint256 bnbBalance,\\n        uint256 tokenBalance,\\n        uint256 timestamp\\n    );\\n\\n    event onLiquiditySweep(\\n        uint amount\\n    );\\n\\n    event onLiquidityProviderReward(\\n        uint amount\\n    );\\n\\n    // Onchain Stats!!!\\n    struct Stats {\\n        uint invested;\\n        uint reinvested;\\n        uint withdrawn;\\n        uint rewarded;\\n        uint taxes;\\n        uint contributed;\\n        uint transferredTokens;\\n        uint receivedTokens;\\n        uint xInvested;\\n        uint xReinvested;\\n        uint xRewarded;\\n        uint xContributed;\\n        uint xWithdrawn;\\n        uint xTransferredTokens;\\n        uint xReceivedTokens;\\n    }\\n\\n    /*=====================================\\n    =            CONFIGURABLES            =\\n    =====================================*/\\n\\n    /// @dev 15% dividends for token purchase\\n    uint8 constant internal entryFee_ = 10;\\n\\n    uint8 constant internal exitFee_  = 10;\\n\\n    uint8 constant internal dripFee = 50;\\n\\n    uint8 constant internal instantFee = 20;\\n\\n    uint8 constant payoutRate_ = 2;\\n\\n    uint256 constant internal magnitude = 2 ** 64;\\n\\n    uint constant MAX_UINT = 2**256 - 1;\\n\\n    /*=================================\\n     =            DATASETS            =\\n     ================================*/\\n\\n    // amount of shares for each address (scaled number)\\n    mapping(address => uint256) private tokenBalanceLedger_;\\n    mapping(address => int256) private payoutsTo_;\\n    mapping(address => Stats) private stats;\\n\\n    //on chain referral tracking\\n    uint256 private tokenSupply_;\\n    uint256 private profitPerShare_;\\n    uint256 public totalDeposits;\\n    uint256 public totalWithdrawn;\\n    uint256 internal lastBalance_;\\n    uint private lockedBalance;\\n\\n    uint public players;\\n    uint public totalTxs;\\n    uint public dividendBalance;\\n\\n    uint public lastPayout;\\n    uint public totalClaims;\\n\\n    uint256 public balanceInterval = 30 seconds;\\n    uint256 public distributionInterval = 3 seconds;\\n\\n    address public swapAddress;\\n    address public collateralAddress;\\n\\n    IToken private swapToken;\\n    IToken private cToken;\\n    ISwap private swap;\\n\\n\\n    /*=======================================\\n    =            PUBLIC FUNCTIONS           =\\n    =======================================*/\\n\\n    constructor(address _swapAddress, address _collateralAddress) public {\\n\\n        swapAddress = _swapAddress;\\n\\n        collateralAddress = _collateralAddress;\\n\\n        swapToken = IToken(_swapAddress);\\n\\n        swap = ISwap(_swapAddress);\\n\\n        cToken = IToken(_collateralAddress);\\n\\n        lastPayout = now;\\n\\n    }\\n\\n    /// @dev converts BNB into liquidity and buys\\n    function buy() public payable returns (uint256){\\n\\n        require(msg.value >= 1e16, \\\"min buy is 0.01 BNB\\\");\\n\\n        totalDeposits += msg.value;\\n\\n        //Refresh approvals\\n        approveSwap();\\n\\n        //use dust from previous txs\\n        uint balance = address(this).balance;\\n\\n        uint tokens = sellBnb(balance / 2);\\n\\n        //the secret sauce for adding liquidity properly\\n        uint bnbAmount = SafeMath.min(swap.getTokenToBnbInputPrice(tokens), address(this).balance);\\n\\n        //If you don't get bnbAmount from the contract you will have pain\\n        uint liquidAmount = swap.addLiquidity.value(bnbAmount)(1, tokens);\\n\\n        return buyFor(msg.sender, liquidAmount);\\n    }\\n\\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\\n    function buyFor(address _customerAddress, uint _buy_amount) internal returns (uint256)  {\\n\\n        uint amount = purchaseTokens(_customerAddress, _buy_amount);\\n\\n        emit onLeaderBoard(_customerAddress,\\n            stats[_customerAddress].invested,\\n            tokenBalanceLedger_[_customerAddress],\\n            stats[_customerAddress].withdrawn,\\n            now\\n        );\\n\\n        //distribute\\n        distribute();\\n\\n        return amount;\\n    }\\n\\n\\n    /**\\n     * @dev Fallback function to handle eth that was send straight to the contract\\n     *  Unfortunately we cannot use a referral address this way.\\n     */\\n    function() public payable  {\\n        //DO NOTHING!!! Swap will send BNB to us!!!\\n    }\\n\\n    /// @dev Converts all of caller's dividends to tokens.\\n    function reinvest() public onlyStronghands returns (uint) {\\n        // fetch dividends\\n        uint256 _dividends = myDividends();\\n        // retrieve ref. bonus later in the code\\n\\n        // pay out the dividends virtually\\n        address _customerAddress = msg.sender;\\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\\n\\n        // dispatch a buy order with the virtualized \\\"withdrawn dividends\\\"\\n        uint256 _tokens = purchaseTokens(msg.sender, _dividends);\\n\\n        uint bnbAmount = calculateLiquidityToBnb(_dividends);\\n\\n        // fire event\\n        emit onReinvestment(_customerAddress, bnbAmount, _tokens, now);\\n\\n        //Stats\\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, bnbAmount);\\n        stats[_customerAddress].xReinvested += 1;\\n\\n        emit onLeaderBoard(_customerAddress,\\n            stats[_customerAddress].invested,\\n            tokenBalanceLedger_[_customerAddress],\\n            stats[_customerAddress].withdrawn,\\n            now\\n        );\\n\\n        //distribute\\n        distribute();\\n\\n        return _tokens;\\n    }\\n\\n    /// @dev Withdraws all of the callers earnings.\\n    function withdraw() public onlyStronghands returns (uint) {\\n        // setup data\\n        address _customerAddress = msg.sender;\\n        uint256 _dividends = myDividends(); // 100% of divs\\n\\n        // update dividend tracker\\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\\n\\n        //remove liquidity and sell the tokens for BNB\\n        (uint bnbAmount, uint tokenAmount) = swap.removeLiquidity(_dividends,1,1);\\n        bnbAmount = bnbAmount.add(sellTokens(tokenAmount));\\n\\n        // lambo delivery service\\n        _customerAddress.transfer(bnbAmount);\\n\\n        totalWithdrawn += bnbAmount;\\n\\n        //stats\\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, bnbAmount);\\n        stats[_customerAddress].xWithdrawn += 1;\\n        totalTxs += 1;\\n        totalClaims += _dividends;\\n\\n        // fire event\\n        emit onWithdraw(_customerAddress, bnbAmount, now);\\n\\n        emit onLeaderBoard(_customerAddress,\\n            stats[_customerAddress].invested,\\n            tokenBalanceLedger_[_customerAddress],\\n            stats[_customerAddress].withdrawn,\\n            now\\n        );\\n\\n        //distribute\\n        distribute();\\n\\n        return bnbAmount;\\n    }\\n\\n    function sell(uint256 _amountOfTokens) onlyStronghands public {\\n        // setup data\\n        address _customerAddress = msg.sender;\\n\\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\\n\\n        // data setup\\n        uint256 _undividedDividends = SafeMath.mul(_amountOfTokens, exitFee_) / 100;\\n        uint256 _taxedeth = SafeMath.sub(_amountOfTokens, _undividedDividends);\\n\\n        // burn the sold tokens\\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\\n\\n        // update dividends tracker\\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens + (_taxedeth * magnitude));\\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\\n\\n        //drip and buybacks\\n        allocateFees(_undividedDividends);\\n\\n        // fire event\\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedeth, now);\\n\\n        //distribute\\n        distribute();\\n    }\\n\\n    /*=====================================\\n    =      HELPERS AND CALCULATORS        =\\n    =====================================*/\\n\\n    /**\\n     * @dev Method to view the current eth stored in the contract\\n     */\\n    function totalTokenBalance() public view returns (uint256) {\\n        return swapToken.balanceOf(address(this));\\n    }\\n\\n    function lockedTokenBalance() public view returns (uint256) {\\n        return lockedBalance;\\n    }\\n\\n    function collateralBalance() public view returns (uint256) {\\n        return cToken.balanceOf(address(this));\\n    }\\n\\n    /// @dev Retrieve the total token supply.\\n    function totalSupply() public view returns (uint256) {\\n        return tokenSupply_;\\n    }\\n\\n    /// @dev Retrieve the tokens owned by the caller.\\n    function myTokens() public view returns (uint256) {\\n        address _customerAddress = msg.sender;\\n        return balanceOf(_customerAddress);\\n    }\\n\\n    /**\\n     * @dev Retrieve the dividends owned by the caller.\\n     */\\n    function myDividends() public view returns (uint256) {\\n        address _customerAddress = msg.sender;\\n        return dividendsOf(_customerAddress);\\n    }\\n\\n\\n    /// @dev Retrieve the token balance of any single address.\\n    function balanceOf(address _customerAddress) public view returns (uint256) {\\n        return tokenBalanceLedger_[_customerAddress];\\n    }\\n\\n    /// @dev Retrieve the token balance of any single address.\\n    function bnbBalance(address _customerAddress) public view returns (uint256) {\\n        return _customerAddress.balance;\\n    }\\n\\n    /// @dev Retrieve the dividend balance of any single address.\\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\\n    }\\n\\n    function approveSwap() internal {\\n        require(cToken.approve(swapAddress, MAX_UINT), \\\"Need to approve swap before selling tokens\\\");\\n    }\\n\\n    function sellTokens(uint256 amount) internal returns (uint256) {\\n        approveSwap();\\n        return swap.tokenToBnbSwapInput(amount,1);\\n    }\\n\\n    function sellBnb(uint256 amount) internal returns (uint256){\\n        return swap.bnbToTokenSwapInput.value(amount)(1);\\n    }\\n\\n    function calculateLiquidityToBnb(uint256 _amount) public view returns (uint256) {\\n        if (_amount > 0){\\n            (uint bnbAmount, uint tokenAmount) = swap.getLiquidityToReserveInputPrice(_amount);\\n            return bnbAmount.add(swap.getTokenToBnbInputPrice(tokenAmount));\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function calculateTaxedBnbToTokenLiquidity(uint256 _amount) public view returns (uint256) {\\n        if (_amount > 0){\\n            uint amount = swap.getBnbToLiquidityInputPrice(_amount.div(2));\\n            return amount.mul(SafeMath.sub(100,entryFee_)).div(100);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n\\n    function calculateTaxedLiquidityToBnb(uint256 _amount) public view returns (uint256){\\n        if (_amount > 0){\\n            _amount = _amount.mul(SafeMath.sub(100,entryFee_)).div(100);\\n            (uint bnbAmount, uint tokenAmount) = swap.getLiquidityToReserveInputPrice(_amount);\\n            return bnbAmount.add(swap.getTokenToBnbInputPrice(tokenAmount));\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function sweep() public returns (uint256){\\n\\n        uint balanceOriginTokens = collateralBalance();\\n        if (balanceOriginTokens >= 1e18  && tokenSupply_ > 0){\\n\\n            uint halfTokens = balanceOriginTokens.div(2);\\n\\n            //We need to start with BNB so we can safely split and add liquidity; also collect BNB dust in the contract\\n            uint balanceBnb = sellTokens(halfTokens);\\n            uint balanceTokens = collateralBalance();\\n            //the secret sauce for adding liquidity properly\\n            uint bnbAmount = SafeMath.min(swap.getTokenToBnbInputPrice(balanceTokens), balanceBnb);\\n\\n            //If you don't get bnbAmount from the contract you will have pain\\n            uint liquidAmount = swap.addLiquidity.value(bnbAmount)(1, balanceTokens);\\n\\n            //half goes to lock and the other half goes to Stronghold LPs\\n            uint halfLiq = liquidAmount.div(2);\\n\\n            uint sweepBalance = liquidAmount.sub(halfLiq);\\n\\n            //Add the new liquidity to drip dividends;\\n            dividendBalance += sweepBalance;\\n\\n            //Add the new liquidity to locked; Stronghold should show up on the leaderboard\\n            lockedBalance += halfLiq;\\n\\n            emit onLiquiditySweep(halfLiq);\\n            emit onLiquidityProviderReward(halfLiq);\\n            return liquidAmount;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n\\n    /// @dev Stats of any single address\\n    function statsOf(address _customerAddress) public view returns (uint256[15] memory){\\n        Stats memory s = stats[_customerAddress];\\n        uint256[15] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.taxes, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested];\\n        return statArray;\\n    }\\n\\n    /// @dev Calculate daily estimate of swap tokens awarded in BNB\\n    function dailyEstimateBnb(address _customerAddress) public view returns (uint256){\\n        if (tokenSupply_ > 0){\\n            uint256 share = dividendBalance.mul(payoutRate_).div(100);\\n            uint256 estimate = share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_);\\n            (uint bnbAmount, uint tokenAmount) = swap.getLiquidityToReserveInputPrice(estimate);\\n            return bnbAmount.add(swap.getTokenToBnbInputPrice(tokenAmount));\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @dev Calculate daily estimate of swap tokens awarded\\n    function dailyEstimate(address _customerAddress) public view returns (uint256){\\n        uint256 share = dividendBalance.mul(payoutRate_).div(100);\\n        return (tokenSupply_ > 0) ? share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_) : 0;\\n    }\\n\\n    /*==========================================\\n    =            INTERNAL FUNCTIONS            =\\n    ==========================================*/\\n\\n    /// @dev Distribute undividend in and out fees across drip pools and instant divs\\n    function allocateFees(uint fee) private {\\n        uint _share = fee.div(100);\\n        uint _drip = _share.mul(dripFee);           //40 --> 50\\n        uint _instant = _share.mul(instantFee);     //40 --> 20\\n        uint _lock = fee.safeSub(_drip + _instant); //20 --> 30\\n\\n        if (tokenSupply_ > 0) {\\n            //Apply divs\\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_instant * magnitude) / tokenSupply_);\\n        }\\n        //Add to dividend drip pools\\n        dividendBalance += _drip;\\n\\n        //Add locked tokens to global count;\\n        lockedBalance += _lock;\\n\\n    }\\n\\n    // @dev Distribute drip pools\\n    function distribute() private {\\n\\n        // @Bb updates balance data of contract\\n        if (now.safeSub(lastBalance_) > balanceInterval && totalTokenBalance() > 0) {\\n            (uint bnbAmount, uint tokenAmount) = swap.getLiquidityToReserveInputPrice(totalTokenBalance());\\n            emit onBalance(bnbAmount, tokenAmount, now);\\n            lastBalance_ = now;\\n        }\\n\\n        if (SafeMath.safeSub(now, lastPayout) > distributionInterval && tokenSupply_ > 0) {\\n\\n            //A portion of the dividend is paid out according to the rate\\n            uint256 share = dividendBalance.mul(payoutRate_).div(100).div(24 hours);\\n            //divide the profit by seconds in the day\\n            uint256 profit = share * now.safeSub(lastPayout);\\n            //share times the amount of time elapsed\\n            dividendBalance = dividendBalance.safeSub(profit);\\n\\n            //Apply divs\\n            profitPerShare_ = SafeMath.add(profitPerShare_, (profit * magnitude) / tokenSupply_);\\n\\n            sweep();\\n\\n            lastPayout = now;\\n        }\\n    }\\n\\n    /// @dev Internal function to actually purchase the tokens.\\n    function purchaseTokens(address _customerAddress, uint256 _incomingtokens) internal returns (uint256) {\\n\\n        /* Members */\\n        if (stats[_customerAddress].invested == 0 && stats[_customerAddress].receivedTokens == 0) {\\n            players += 1;\\n        }\\n\\n        totalTxs += 1;\\n\\n        // data setup @bb _incomingtokens is 'LP token'\\n        uint256 _undividedDividends = SafeMath.mul(_incomingtokens, entryFee_) / 100;     // 10% of drops\\n        uint256 _amountOfTokens     = SafeMath.sub(_incomingtokens, _undividedDividends); // 90% of drops (100% - 10% above)\\n\\n        uint256 bnbAmount = calculateLiquidityToBnb(_incomingtokens); //total bnb worth of lp token\\n\\n        // fire event\\n        emit onTokenPurchase(_customerAddress, bnbAmount, _amountOfTokens, now);\\n\\n        // yes we know that the safemath function automatically rules out the \\\"greater then\\\" equation.\\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_, \\\"Tokens need to be positive\\\");\\n\\n        // we can't give people infinite eth\\n        if (tokenSupply_ > 0) {\\n            // add tokens to the pool\\n            tokenSupply_ += _amountOfTokens;\\n        } else {\\n            // add tokens to the pool\\n            tokenSupply_ = _amountOfTokens;\\n\\n        }\\n\\n\\n        //drip and buybacks; instant requires being called after supply is updated\\n        allocateFees(_undividedDividends);\\n\\n        // update circulating supply & the ledger address for the customer\\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\\n\\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens);\\n        payoutsTo_[_customerAddress] += _updatedPayouts;\\n\\n        //Stats\\n        stats[_customerAddress].taxes += _undividedDividends;\\n        stats[_customerAddress].invested += bnbAmount;\\n        stats[_customerAddress].xInvested += 1;\\n\\n        return _amountOfTokens;\\n    }\\n\\n}\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        // uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /* @dev Subtracts two numbers, else returns zero */\\n    function safeSub(uint a, uint b) internal pure returns (uint) {\\n        if (b > a) {\\n            return 0;\\n        } else {\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[15]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sweep\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalClaims\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateTaxedBnbToTokenLiquidity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateTaxedLiquidityToBnb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculateLiquidityToBnb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimateBnb\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"bnbBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_swapAddress\",\"type\":\"address\"},{\"name\":\"_collateralAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"invested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onLeaderBoard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingeth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bnbBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onLiquiditySweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onLiquidityProviderReward\",\"type\":\"event\"}]", "ContractName": "Reservoir", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004fe59adcf621489ced2d674978132a54d432653a00000000000000000000000020f663cea80face82acdfa3aae6862d246ce0333", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}