{"SourceCode": "pragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n/*\r\nBSN\r\n*/\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value)\r\n    external\r\n    returns (bool success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n    external\r\n    returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender)\r\n    external\r\n    view\r\n    returns (uint256 remaining);\r\n}\r\ncontract GaiaStaking is ReentrancyGuard{\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant day = 86400;//\u4e00\u5929\u7684\u79d2\u6570,\u6d4b\u8bd5\u73af\u5883\u8bbe\u7f6e\u4e3a1s\uff0c\u6b63\u5f0f\u73af\u5883\u4e3a 86400\r\n    uint256 private constant stakingType1=90;\r\n    uint256 private constant stakingType2=180;\r\n    uint256 private constant stakingType3=360;\r\n    uint256 private constant ONE = 10**18;\r\n    bool public isStartWithdraw=false;//\u662f\u5426\u5f00\u542f\u63d0\u73b0\r\n\r\n    struct Stream{\r\n        uint256 streamId;\r\n        address sender;//\u5b58\u5e01\u4eba\r\n        uint256 stakingType;//\u5b58\u5e01\u7c7b\u578b\r\n        uint256 stakingAmount;//\u6570\u91cf\r\n        uint256 stakingTime;//\u5b58\u5e01\u65f6\u95f4\r\n        uint256 endTime;//\u9884\u671f\u7ed3\u675f\u65f6\u95f4\r\n        uint256 withdrawable;//\u53ef\u63d0\u73b0\u6570\u91cf\r\n        bool finish;//\u662f\u5426\u5df2\u7ecf\u53d6\u51fa\r\n    }\r\n    struct UserStream{\r\n        uint256 amount;//\u5b58\u5165\u7684\u7b14\u6570\r\n        uint256 balance;//\u5b58\u5165\u7684\u603b\u989d\r\n        Stream[] streams;//\u7528\u6237\u5b58\u5165\u7684\u5177\u4f53\u4fe1\u606f\r\n    }\r\n    IERC20 stakingToken;//\u5141\u8bb8\u5b58\u5165\u7684\u5e01\u79cd\r\n    mapping(address=>UserStream) private userList;//\u7528\u6237\u5217\u8868\r\n\r\n    address owner;\r\n    event Staking(uint256 indexed streamId,address indexed user,uint256 indexed stakingAmount,uint256 stakingTime,uint256 endTime,address sender);\r\n    event Withdraw(uint256 indexed streamId,address indexed sender,uint256 indexed withdrawAmount,uint256 withdrawTime);\r\n    event ChangeWithdrawState(address indexed owner,bool indexed state);\r\n    event ChangeOwner(address indexed owner,address indexed user);\r\n\r\n    modifier streamExists(uint256 streamId) {\r\n        require(userList[msg.sender].streams[streamId].sender!=address(0), \"stream does not exist\");\r\n        _;\r\n    }\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n    constructor(address token) public{\r\n        stakingToken=IERC20(token);\r\n        owner=msg.sender;\r\n    }\r\n    /**\r\n    * \u81ea\u5df1\u5b58\u5e01\r\n    * stakingType=90 \u8868\u793a90\u5929\uff0c20%\u6536\u76ca\r\n    * stakingType=180 \u8868\u793a180\u5929\uff0c40%\u6536\u76ca\r\n    * stakingType=360 \u8868\u793a360\u5929\uff0c60%\u6536\u76ca\r\n    */\r\n    function staking(uint256 stakingType,uint256 stakingAmount) public nonReentrant{\r\n        stakingBase(msg.sender,stakingType, stakingAmount, block.timestamp);\r\n    }\r\n    // \u7ed9\u522b\u4eba\u5b58\r\n    function stakingTo(address toUser,uint256 stakingType,uint256 stakingAmount,uint256 stakingTime) public onlyOwner nonReentrant{\r\n        stakingBase(toUser,stakingType, stakingAmount, stakingTime);\r\n    }\r\n    function stakingBase(address _toUser,uint256 _stakingType,uint256 _stakingAmount,uint256 _stakingTime) internal{\r\n        require(_stakingAmount>=10*ONE,\"Less than minimum amount of deposit\");\r\n        require(_stakingType==stakingType1 || _stakingType==stakingType2 || _stakingType==stakingType3,\"Wrong Staking type\");\r\n        stakingToken.transferFrom(msg.sender, address(this), _stakingAmount);\r\n        uint256 _endTime;\r\n        _endTime=_stakingTime.add(_stakingType*day);\r\n        Stream memory stream=Stream({\r\n        streamId:userList[_toUser].amount,\r\n        sender: _toUser,\r\n        stakingType:_stakingType,\r\n        stakingAmount: _stakingAmount,\r\n        stakingTime: _stakingTime,\r\n        endTime:_endTime,\r\n        finish:false,\r\n        withdrawable:_stakingAmount\r\n        });\r\n        userList[_toUser].amount+=1;\r\n        userList[_toUser].balance+=_stakingAmount;\r\n        userList[_toUser].streams.push(stream);\r\n        emit Staking(stream.streamId,_toUser,_stakingAmount,_stakingTime,_endTime,msg.sender);\r\n    }\r\n    function computeAmount(uint256 stakingType,uint256 inAmount,uint256 stakingTime) internal view returns(uint256 outAmount){\r\n\r\n        uint256 rate;\r\n        if (stakingType==stakingType1){\r\n            rate=20;\r\n        }else if (stakingType==stakingType2){\r\n            rate=40;\r\n        }else if (stakingType==stakingType3){\r\n            rate=60;\r\n        }\r\n        //\u5f53\u524d\u65f6\u95f4\r\n        uint256 time=block.timestamp;\r\n        require(time>=stakingTime,\"The current time must be greater than the stakingtime time\");\r\n        if((time-stakingTime)>(stakingType*day)){\r\n            outAmount=inAmount+inAmount.mul(rate*stakingType).div(100*360);\r\n        }else{\r\n            outAmount=inAmount;\r\n        }\r\n    }\r\n    //\u53d6\u5e01\r\n    function withdraw(uint256 streamId) public streamExists(streamId) nonReentrant{\r\n        // \u53ea\u6709\u5f00\u542f\u63d0\u5e01\u540e\uff0c\u624d\u80fd\u63d0\u53d6\r\n        require(isStartWithdraw==true,\"isStartWithdraw is false\");\r\n        // \u53ea\u6709\u5b58\u5165\u7684\u4eba\u53ef\u4ee5\u53d6\u5e01\r\n        // require(stakingList[streamId].sender==msg.sender);\r\n        Stream memory stream=userList[msg.sender].streams[streamId];\r\n        require(stream.sender==msg.sender,\"msg.sender don't own this steam\");\r\n        // \u4e0d\u80fd\u5df2\u7ecf\u7ed3\u675f\r\n        require(stream.finish==false,\"the stream has finish\");\r\n\r\n        uint256 outAmount=computeAmount(stream.stakingType,stream.stakingAmount,stream.stakingTime);\r\n        //\u7ed9\u7528\u6237\u8f6c\u5e01\r\n        stakingToken.transfer(stream.sender, outAmount);\r\n        stream.finish=true;\r\n        stream.withdrawable=0;\r\n        require(userList[msg.sender].balance>=stream.stakingAmount,\"The total amount should be greater than stream amount \");\r\n        userList[msg.sender].balance-=stream.stakingAmount;\r\n        userList[msg.sender].streams[streamId]=stream;\r\n        emit Withdraw(streamId,msg.sender,outAmount,block.timestamp);\r\n    }\r\n    //\u83b7\u53d6\u6d41\u4fe1\u606f\r\n    function getStream(uint256 streamId) external view streamExists(streamId) returns(address sender,uint256 stakingType,uint256 stakingAmount,uint256 stakingTime,uint256 endTime,bool finish,uint256 nowAmount){\r\n        Stream memory stream=userList[msg.sender].streams[streamId];\r\n        sender=stream.sender;\r\n        stakingType=stream.stakingType;\r\n        stakingAmount=stream.stakingAmount;\r\n        stakingTime=stream.stakingTime;\r\n        endTime=stream.endTime;\r\n        finish=stream.finish;\r\n\t    if(stream.finish==true){\r\n            nowAmount=0;\r\n        }else{\r\n            nowAmount=computeAmount(stream.stakingType,stream.stakingAmount,stream.stakingTime);\r\n        }\r\n    }\r\n    // \u83b7\u53d6\u7528\u6237\u5b58\u5165\u603b\u989d\r\n    function getBalance(address user) public view returns(uint256){\r\n        return userList[user].balance;\r\n    }\r\n    //\u83b7\u53d6\u53ef\u63d0\u73b0\u6570\u91cf\r\n    function getWithdrawAmount(uint256 streamId) public streamExists(streamId) view returns(uint256 outAmount){\r\n        Stream memory stream=userList[msg.sender].streams[streamId];\r\n        // \u5982\u679c\u5df2\u7ecf\u7ed3\u675f\r\n        if(stream.finish==true){\r\n            return 0;\r\n        }\r\n        outAmount=computeAmount(stream.stakingType,stream.stakingAmount,stream.stakingTime);\r\n        return outAmount;\r\n    }\r\n    function getUserStreamList(address user) public view returns(Stream[] memory){\r\n        UserStream memory userStream=userList[user];\r\n        for(uint256 i=0;i<userStream.amount;i++){\r\n            Stream  memory stream=userStream.streams[i];\r\n            // \u5982\u679c\u5df2\u7ecf\u7ed3\u675f\r\n            if(stream.finish==true){\r\n                stream.withdrawable=0;\r\n            }else{\r\n                stream.withdrawable=computeAmount(stream.stakingType,stream.stakingAmount,stream.stakingTime);\r\n            }\r\n            userStream.streams[i]=stream;\r\n        }\r\n        return userStream.streams;\r\n    }\r\n\r\n    function changeOwner(address _owner) public onlyOwner{\r\n        require(_owner!=address(0),\"owner cannot be address(0)\");\r\n        owner=_owner;\r\n        emit ChangeOwner(msg.sender,_owner);\r\n    }\r\n    function getOwner() public view returns(address){\r\n        return owner;\r\n    }\r\n    function withdrawOwner() public onlyOwner{\r\n        uint256 balance=stakingToken.balanceOf(address(this));\r\n        stakingToken.transfer(owner, balance);\r\n    }\r\n\r\n    function startWithdraw() public onlyOwner{\r\n        isStartWithdraw=true;\r\n        emit ChangeWithdrawState(msg.sender,true);\r\n    }\r\n    function stopWithdraw() public onlyOwner{\r\n        isStartWithdraw=false;\r\n        emit ChangeWithdrawState(msg.sender,false);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"ChangeWithdrawState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"Staking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"day\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finish\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nowAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStreamList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawable\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finish\",\"type\":\"bool\"}],\"internalType\":\"struct GaiaStaking.Stream[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStartWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"}],\"name\":\"staking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingTime\",\"type\":\"uint256\"}],\"name\":\"stakingTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GaiaStaking", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004301a638fcb45c4bb65230b87f3797c213f832b8", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0ba84c01d189727241ac1d7b07070138d8b5781ce2bdec36a8f7b1ab61e905e9"}