{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface swap {\r\n    function getMidPrice() external view returns (uint);\r\n}\r\n\r\ninterface Old {\r\n    function checkUserInvitor(address addr_) external view returns (address out_);\r\n\r\n    function userInfo(address addr_) external view returns (address invitor,\r\n        uint refer,\r\n        uint inviteRewardBLK,\r\n        uint inviteRewardUSDB,\r\n        uint inviteBlkClaimed,\r\n        uint inviteUsdbClaimed,\r\n        uint claimedBLK,\r\n        uint claimedUSDB);\r\n}\r\n\r\ncontract Deposit is Ownable {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    IERC20 public BLK;\r\n    IERC20 public USDB;\r\n    IERC20 public FLY;\r\n    address public BLKPair;\r\n    uint public constant decimal = 1e18;\r\n    uint public constant delay = 30 days;\r\n    uint public constant acc = 1e10;\r\n    uint public currentRound = 1;\r\n    Old public  old;\r\n    // uint public constant e = 27182818284;\r\n\r\n    struct UserInfo {\r\n        address invitor;\r\n        uint refer;\r\n        uint inviteRewardBLK;\r\n        uint inviteRewardUSDB;\r\n        uint inviteBlkClaimed;\r\n        uint inviteUsdbClaimed;\r\n        uint claimedBLK;\r\n        uint claimedUSDB;\r\n    }\r\n\r\n    struct SlotInfo {\r\n        bool status;\r\n        uint round;\r\n        uint mode;\r\n        uint rate;\r\n        uint depositAmount;\r\n        uint depositTime;\r\n        uint endTime;\r\n        uint claimed;\r\n        uint startTime;\r\n        uint apy;\r\n        uint fly;\r\n        uint period;\r\n\r\n    }\r\n\r\n    struct RoundInfo {\r\n        uint quota;\r\n        uint apy;\r\n        uint contractPeriod;\r\n        uint depositAmount;\r\n\r\n\r\n    }\r\n\r\n    mapping(uint => uint) public e;\r\n    mapping(uint => RoundInfo) public roundInfo;\r\n    mapping(address => UserInfo) public userInfo;\r\n    mapping(address => mapping(uint => SlotInfo)) public userSlot;\r\n    mapping(address => bool)public Admin;\r\n\r\n\r\n    event Deposited(address indexed sender_, uint indexed amount_, uint round_, uint slot_, uint mode_);\r\n    event ClaimInterest(address indexed sender_, uint indexed amount_, uint slot_, uint mode_);\r\n    event UnDeposite(address indexed sender_, uint indexed slot_);\r\n    event BondInvitor(address indexed sender_, address indexed invitor_);\r\n\r\n    modifier isAdmin(){\r\n        require(Admin[msg.sender], 'not contract');\r\n        _;\r\n    }\r\n    constructor(){\r\n        roundInfo[1] = RoundInfo({\r\n        quota : 500000 * decimal,\r\n        apy : 6500,\r\n        contractPeriod : 90 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[2] = RoundInfo({\r\n        quota : 1500000 * decimal,\r\n        apy : 5500,\r\n        contractPeriod : 90 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[3] = RoundInfo({\r\n        quota : 3000000 * decimal,\r\n        apy : 4500,\r\n        contractPeriod : 90 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[4] = RoundInfo({\r\n        quota : 5000000 * decimal,\r\n        apy : 4000,\r\n        contractPeriod : 90 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[5] = RoundInfo({\r\n        quota : 0,\r\n        apy : 1938,\r\n        contractPeriod : 30 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[6] = RoundInfo({\r\n        quota : 0,\r\n        apy : 2468,\r\n        contractPeriod : 90 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[7] = RoundInfo({\r\n        quota : 0,\r\n        apy : 2978,\r\n        contractPeriod : 180 days,\r\n        depositAmount : 0\r\n        });\r\n        roundInfo[8] = RoundInfo({\r\n        quota : 0,\r\n        apy : 3600,\r\n        contractPeriod : 360 days,\r\n        depositAmount : 0\r\n        });\r\n        e[7] = 3468;\r\n        e[8] = 4333;\r\n    }\r\n\r\n    // function getUsdtPrice(address pair) public view returns (uint price){\r\n    //     (uint reserve0, uint reserve1,) = BSCswapPair(pair).getReserves();\r\n    //     price = reserve1 * 10 ** 18 / reserve0;\r\n    //     // reserve0 A, reserve 1 U, it is U price of A\r\n    //     return price;\r\n    // }\r\n\r\n    function setOld(address addr_) external onlyOwner {\r\n        old = Old(addr_);\r\n    }\r\n\r\n    function setToken(address BLK_, address USDB_, address FLY_, address pair_) public onlyOwner {\r\n        BLK = IERC20(BLK_);\r\n        USDB = IERC20(USDB_);\r\n        FLY = IERC20(FLY_);\r\n        BLKPair = pair_;\r\n    }\r\n\r\n    function getBLKPrice(address pair) public view returns (uint price_){\r\n        price_ = swap(pair).getMidPrice();\r\n        // reserve0 A, reserve 1 U, it is U price of A\r\n        return price_;\r\n    }\r\n\r\n    function updateRound() internal {\r\n        if (currentRound < 5) {\r\n            if (roundInfo[currentRound].quota - roundInfo[currentRound].depositAmount < 100 ether) {\r\n                currentRound++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //1 for BLK, 2 for USDB\r\n    function deposit(uint amount_, uint round_, uint slot_, uint mode_, address invitor_) public {\r\n        if (currentRound < 5) {\r\n            require(round_ == currentRound, 'wrong round');\r\n        }\r\n        if (checkUserInvitor(msg.sender) != address(0)&& userInfo[msg.sender].invitor == address(0)){\r\n            userInfo[msg.sender].invitor = checkUserInvitor(msg.sender);\r\n        }\r\n        require(!userSlot[msg.sender][slot_].status, 'staked');\r\n        require(round_ >= 1 && round_ <= 8, 'wrong round_');\r\n        require(mode_ == 1 || mode_ == 2, 'wrong type');\r\n        require(slot_ >= 0 && slot_ <= 4, 'wrong slot');\r\n        if (checkUserInvitor(msg.sender) == address(0)) {\r\n            require(userInfo[invitor_].invitor != address(0) || invitor_ == address(this), 'wrong invitor');\r\n            userInfo[msg.sender].invitor = invitor_;\r\n            emit BondInvitor(msg.sender, invitor_);\r\n            if (checkUserRefer(invitor_) != 0 && userInfo[invitor_].refer == 0) {\r\n                userInfo[invitor_].refer = checkUserRefer(invitor_);\r\n            }\r\n            userInfo[invitor_].refer ++;\r\n        }\r\n        if (mode_ == 1) {\r\n            uint temp = getBLKPrice(BLKPair) * amount_ / decimal;\r\n            require(temp >= 100 * decimal, 'too low');\r\n            if (round_ < 5) {\r\n                require(roundInfo[round_].depositAmount + temp < roundInfo[round_].quota, 'no quota');\r\n            }\r\n            BLK.transferFrom(msg.sender, address(this), amount_);\r\n            roundInfo[round_].depositAmount += temp;\r\n            userSlot[msg.sender][slot_] = SlotInfo({\r\n            status : true,\r\n            round : round_,\r\n            mode : mode_,\r\n            rate : amount_ * roundInfo[round_].apy * acc / 10000 / 360 days,\r\n            depositAmount : amount_,\r\n            depositTime : block.timestamp,\r\n            endTime : block.timestamp + 360 days,\r\n            claimed : 0,\r\n            startTime : block.timestamp,\r\n            apy : roundInfo[round_].apy,\r\n            fly : 0,\r\n            period : roundInfo[round_].contractPeriod\r\n            });\r\n        } else {\r\n            require(amount_ >= 100 * decimal, 'too low');\r\n            if (round_ < 5) {\r\n                require(roundInfo[round_].depositAmount + amount_ < roundInfo[round_].quota, 'no quota');\r\n            }\r\n            USDB.safeTransferFrom(msg.sender, address(this), amount_);\r\n            roundInfo[round_].depositAmount += amount_;\r\n            userSlot[msg.sender][slot_] = SlotInfo({\r\n            status : true,\r\n            round : round_,\r\n            mode : mode_,\r\n            rate : amount_ * (roundInfo[round_].apy * 7 / 10) * acc / 10000 / 360 days,\r\n            depositAmount : amount_,\r\n            depositTime : block.timestamp,\r\n            endTime : block.timestamp + 360 days,\r\n            claimed : 0,\r\n            startTime : block.timestamp,\r\n            apy : roundInfo[round_].apy * 7 / 10,\r\n            fly : 0,\r\n            period : roundInfo[round_].contractPeriod\r\n            });\r\n        }\r\n        updateRound();\r\n        emit Deposited(msg.sender, amount_, round_, slot_, mode_);\r\n    }\r\n\r\n    function countingFlyCostUSDB(uint amount_) public pure returns (uint){\r\n        uint _temp;\r\n        if (amount_ < 2000 * decimal) {\r\n            _temp = 0;\r\n        } else {\r\n            _temp = amount_ / (2000 * decimal);\r\n        }\r\n        uint cost = (_temp + 1) * 3000 * decimal;\r\n        return cost;\r\n    }\r\n\r\n    function countingFlyCostBLK(uint amount_) public view returns (uint){\r\n        uint _temp;\r\n        uint _amount = getBLKPrice(BLKPair) * amount_ / decimal;\r\n        if (_amount < 2000 * decimal) {\r\n            _temp = 0;\r\n        } else {\r\n            _temp = _amount / (2000 * decimal);\r\n        }\r\n        uint cost = (_temp + 1) * 3000 * decimal;\r\n        return cost;\r\n    }\r\n\r\n    function depositWithFly(uint amount_, uint round_, uint slot_, uint mode_, address invitor_) public {\r\n        if (currentRound < 5) {\r\n            require(round_ == currentRound, 'wrong round');\r\n        }\r\n        if (checkUserInvitor(msg.sender) != address(0)&& userInfo[msg.sender].invitor == address(0)){\r\n            userInfo[msg.sender].invitor = checkUserInvitor(msg.sender);\r\n        }\r\n        require(!userSlot[msg.sender][slot_].status, 'staked');\r\n        require(round_ >= 1 && round_ <= 8, 'wrong round_');\r\n        require(mode_ == 1 || mode_ == 2, 'wrong type');\r\n        require(slot_ >= 0 && slot_ <= 4, 'wrong slot');\r\n        if (checkUserInvitor(msg.sender) == address(0)) {\r\n            require(userInfo[invitor_].invitor != address(0) || invitor_ == address(this), 'wrong invitor');\r\n            userInfo[msg.sender].invitor = invitor_;\r\n            emit BondInvitor(msg.sender, invitor_);\r\n            if (checkUserRefer(invitor_) != 0 && userInfo[invitor_].refer == 0) {\r\n                userInfo[invitor_].refer = checkUserRefer(invitor_);\r\n            }\r\n            userInfo[invitor_].refer ++;\r\n        }\r\n        if (mode_ == 1) {\r\n            uint temp = getBLKPrice(BLKPair) * amount_ / decimal;\r\n            require(temp >= 500 * decimal, 'too low');\r\n            if (round_ < 5) {\r\n                require(roundInfo[round_].depositAmount + temp < roundInfo[round_].quota, 'no quota');\r\n            }\r\n            uint cost = countingFlyCostUSDB(temp);\r\n            BLK.safeTransferFrom(msg.sender, address(this), amount_);\r\n            roundInfo[round_].depositAmount += temp;\r\n            FLY.safeTransferFrom(msg.sender, address(this), cost);\r\n            userSlot[msg.sender][slot_] = SlotInfo({\r\n            status : true,\r\n            round : round_,\r\n            mode : mode_,\r\n            rate : amount_ * (roundInfo[round_].apy + 500) * acc / 10000 / 360 days,\r\n            depositAmount : amount_,\r\n            depositTime : block.timestamp,\r\n            endTime : block.timestamp + 360 days,\r\n            claimed : 0,\r\n            startTime : block.timestamp,\r\n            apy : roundInfo[round_].apy + 500,\r\n            fly : cost,\r\n            period : roundInfo[round_].contractPeriod\r\n            });\r\n        } else {\r\n            require(amount_ >= 500 * decimal, 'too low');\r\n            if (round_ < 5) {\r\n                require(roundInfo[round_].depositAmount + amount_ < roundInfo[round_].quota, 'no quota');\r\n            }\r\n            uint cost = countingFlyCostUSDB(amount_);\r\n            FLY.safeTransferFrom(msg.sender, address(this), cost);\r\n            roundInfo[round_].depositAmount += amount_;\r\n            USDB.safeTransferFrom(msg.sender, address(this), amount_);\r\n            userSlot[msg.sender][slot_] = SlotInfo({\r\n            status : true,\r\n            round : round_,\r\n            mode : mode_,\r\n            rate : amount_ * ((roundInfo[round_].apy + 500) * 7 / 10) * acc / 10000 / 360 days,\r\n            depositAmount : amount_,\r\n            depositTime : block.timestamp,\r\n            endTime : block.timestamp + 360 days,\r\n            claimed : 0,\r\n            startTime : block.timestamp,\r\n            apy : (roundInfo[round_].apy + 500) * 7 / 10,\r\n            fly : cost,\r\n            period : roundInfo[round_].contractPeriod\r\n            });\r\n        }\r\n        updateRound();\r\n        emit Deposited(msg.sender, amount_, round_, slot_, mode_);\r\n    }\r\n\r\n    function checkSlotNum(address addr_) public view returns (uint) {\r\n        for (uint i = 0; i <= 4; i++) {\r\n            if (!userSlot[addr_][i].status) {\r\n                return i;\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n        return 20;\r\n    }\r\n\r\n    function countingInterest(address addr_, uint slot_) public view returns (uint){\r\n        require(userSlot[addr_][slot_].status, 'wrong slot');\r\n        uint out;\r\n        if (block.timestamp < userSlot[addr_][slot_].endTime) {\r\n            out = userSlot[addr_][slot_].rate * (block.timestamp - userSlot[addr_][slot_].depositTime) / acc;\r\n\r\n        } else {\r\n            out = userSlot[addr_][slot_].rate * (userSlot[addr_][slot_].endTime - userSlot[addr_][slot_].depositTime) / acc;\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    function claimInterest(uint slot_) public {\r\n        require(userSlot[msg.sender][slot_].status, 'wrong slot');\r\n        require(userSlot[msg.sender][slot_].round < 5);\r\n        require(userSlot[msg.sender][slot_].endTime - block.timestamp < 330 days, 'too early');\r\n        uint temp;\r\n        if (userSlot[msg.sender][slot_].mode == 1) {\r\n            temp = countingInterest(msg.sender, slot_);\r\n            BLK.safeTransfer(msg.sender, temp);\r\n            userInfo[msg.sender].claimedBLK += temp;\r\n            userSlot[msg.sender][slot_].depositTime = block.timestamp;\r\n            userInfo[userInfo[msg.sender].invitor].inviteRewardBLK += temp * 3 / 100;\r\n            userSlot[msg.sender][slot_].claimed += temp;\r\n        } else {\r\n            temp = countingInterest(msg.sender, slot_);\r\n            USDB.safeTransfer(msg.sender, temp);\r\n            userInfo[msg.sender].claimedUSDB += temp;\r\n            userSlot[msg.sender][slot_].depositTime = block.timestamp;\r\n            userInfo[userInfo[msg.sender].invitor].inviteRewardUSDB += temp * 3 / 100;\r\n            userSlot[msg.sender][slot_].claimed += temp;\r\n        }\r\n        emit ClaimInterest(msg.sender, temp, slot_, userSlot[msg.sender][slot_].mode);\r\n    }\r\n\r\n    function claimAll() public {\r\n        for (uint i = 0; i < 5; i++) {\r\n            if (userSlot[msg.sender][i].status && userSlot[msg.sender][i].endTime - block.timestamp < 330 days) {\r\n                claimInterest(i);\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    function countingAll(address addr_) public view returns (uint){\r\n        uint out;\r\n        for (uint i = 0; i < 5; i++) {\r\n            if (userSlot[addr_][i].status && userSlot[addr_][i].endTime - block.timestamp < 330 days) {\r\n                out += countingInterest(addr_, i);\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function unDeposite(uint slot_) public {\r\n        uint temp;\r\n        SlotInfo storage info = userSlot[msg.sender][slot_];\r\n        require(info.endTime - block.timestamp < 330 days, 'too early');\r\n        if (info.round <= 4) {\r\n            if (block.timestamp < info.endTime - 270 days) {\r\n                temp = (block.timestamp - (info.endTime - 360 days)) * info.rate * 7 / 10 / acc;\r\n                if (temp < info.claimed) {\r\n                    if (info.mode == 1) {\r\n                        BLK.safeTransfer(msg.sender, info.depositAmount - (info.claimed - temp));\r\n\r\n                    } else {\r\n                        USDB.safeTransfer(msg.sender, info.depositAmount - (info.claimed - temp));\r\n                    }\r\n                } else {\r\n                    if (info.mode == 1) {\r\n                        BLK.safeTransfer(msg.sender, info.depositAmount + (temp - info.claimed));\r\n                        userInfo[userInfo[msg.sender].invitor].inviteRewardBLK += temp * 3 / 100;\r\n\r\n                    } else {\r\n                        USDB.safeTransfer(msg.sender, info.depositAmount + (temp - info.claimed));\r\n                        userInfo[userInfo[msg.sender].invitor].inviteRewardUSDB += temp * 3 / 100;\r\n\r\n                    }\r\n\r\n                    emit ClaimInterest(msg.sender, temp - info.claimed, slot_, userSlot[msg.sender][slot_].mode);\r\n                }\r\n            } else {\r\n                claimInterest(slot_);\r\n                if (info.mode == 1) {\r\n                    BLK.safeTransfer(msg.sender, info.depositAmount);\r\n                } else {\r\n                    USDB.safeTransfer(msg.sender, info.depositAmount);\r\n                }\r\n\r\n            }\r\n        } else if (info.round > 4 && info.round <= 6) {\r\n            uint rate = info.depositAmount * roundInfo[info.round].apy * acc / 10000 / roundInfo[info.round].contractPeriod;\r\n            if (block.timestamp < info.endTime - 360 days + roundInfo[info.round].contractPeriod) {\r\n                temp = (block.timestamp - (info.endTime - 360 days)) * rate * 7 / 10 / acc;\r\n            } else {\r\n                temp = (block.timestamp - (info.endTime - 360 days)) * rate / acc;\r\n            }\r\n            if (info.mode == 1) {\r\n                BLK.safeTransfer(msg.sender, info.depositAmount + temp);\r\n                userInfo[userInfo[msg.sender].invitor].inviteRewardBLK += temp * 3 / 100;\r\n\r\n            } else {\r\n                USDB.safeTransfer(msg.sender, info.depositAmount + temp);\r\n                userInfo[userInfo[msg.sender].invitor].inviteRewardUSDB += temp * 3 / 100;\r\n\r\n            }\r\n            emit ClaimInterest(msg.sender, temp, slot_, userSlot[msg.sender][slot_].mode);\r\n        } else if (info.round >= 7) {\r\n            if (block.timestamp < info.endTime - 360 days + 90 days) {\r\n                uint rate = info.depositAmount * roundInfo[info.round].apy * acc / 10000 / roundInfo[info.round].contractPeriod;\r\n                temp = (block.timestamp - (info.endTime - 360 days)) * rate * 7 / 10 / acc;\r\n            } else if (block.timestamp > info.endTime - 360 days + 90 days && block.timestamp < info.endTime - 360 days + roundInfo[info.round].contractPeriod) {\r\n                uint rate = info.depositAmount * e[info.round] * acc / 10000 / roundInfo[info.round].contractPeriod;\r\n                temp = (block.timestamp - (info.endTime - 360 days)) * rate * 7 / 10 / acc;\r\n            } else if (block.timestamp > info.endTime - 360 days + roundInfo[info.round].contractPeriod) {\r\n                uint rate = info.depositAmount * e[info.round] * acc / 10000 / roundInfo[info.round].contractPeriod;\r\n                temp = (block.timestamp - (info.endTime - 360 days)) * rate / acc;\r\n            }\r\n            if (info.mode == 1) {\r\n                BLK.safeTransfer(msg.sender, info.depositAmount + temp);\r\n                userInfo[userInfo[msg.sender].invitor].inviteRewardBLK += temp * 3 / 100;\r\n\r\n            } else {\r\n                USDB.safeTransfer(msg.sender, info.depositAmount + temp);\r\n                userInfo[userInfo[msg.sender].invitor].inviteRewardUSDB += temp * 3 / 100;\r\n\r\n            }\r\n            emit ClaimInterest(msg.sender, temp, slot_, userSlot[msg.sender][slot_].mode);\r\n        }\r\n        if (userSlot[msg.sender][slot_].fly != 0) {\r\n            FLY.transfer(msg.sender, userSlot[msg.sender][slot_].fly);\r\n        }\r\n\r\n        userSlot[msg.sender][slot_] = SlotInfo({\r\n        status : false,\r\n        round : 0,\r\n        mode : 0,\r\n        rate : 0,\r\n        depositAmount : 0,\r\n        depositTime : 0,\r\n        endTime : 0,\r\n        claimed : 0,\r\n        startTime : 0,\r\n        apy : 0,\r\n        fly : 0,\r\n        period : 0\r\n        });\r\n        emit UnDeposite(msg.sender, slot_);\r\n    }\r\n\r\n    function claimReward() public {\r\n        require(userInfo[msg.sender].inviteRewardBLK > 0 || userInfo[msg.sender].inviteRewardUSDB > 0, 'no rewareds');\r\n        if (userInfo[msg.sender].inviteRewardBLK > 0) {\r\n            BLK.safeTransfer(msg.sender, userInfo[msg.sender].inviteRewardBLK);\r\n            userInfo[msg.sender].inviteBlkClaimed += userInfo[msg.sender].inviteRewardBLK;\r\n        }\r\n        if (userInfo[msg.sender].inviteRewardUSDB > 0) {\r\n            USDB.safeTransfer(msg.sender, userInfo[msg.sender].inviteRewardUSDB);\r\n            userInfo[msg.sender].inviteUsdbClaimed += userInfo[msg.sender].inviteRewardUSDB;\r\n        }\r\n\r\n\r\n        userInfo[msg.sender].inviteRewardUSDB = 0;\r\n        userInfo[msg.sender].inviteRewardBLK = 0;\r\n    }\r\n\r\n    function checkUserInvitor(address addr_) public view returns (address out_){\r\n        if (old.checkUserInvitor(addr_) != address(0)) {\r\n            out_ = old.checkUserInvitor(addr_);\r\n        } else {\r\n            out_ = userInfo[addr_].invitor;\r\n        }\r\n\r\n    }\r\n\r\n    function checkUserRefer(address addr_) public view returns (uint){\r\n        (,uint out_,,,,,,) = old.userInfo(addr_);\r\n        if (out_ != 0 && userInfo[addr_].refer == 0) {\r\n            return out_;\r\n        }\r\n        return userInfo[addr_].refer;\r\n    }\r\n\r\n    function bondUserInvitor(address addr_, address invitor_) public isAdmin {\r\n        require(checkUserInvitor(addr_) == address(0), 'wrong');\r\n        userInfo[addr_].invitor = invitor_;\r\n        if (checkUserRefer(invitor_) != 0 && userInfo[invitor_].refer == 0) {\r\n            userInfo[invitor_].refer = checkUserRefer(invitor_);\r\n        }\r\n        userInfo[invitor_].refer++;\r\n    }\r\n\r\n\r\n    function setUserInvitorReward(address addr_, uint BLK_, uint USDB_) public isAdmin {\r\n        require(userInfo[addr_].invitor != address(0), 'wrong address');\r\n        userInfo[addr_].inviteRewardUSDB += USDB_;\r\n        userInfo[addr_].inviteRewardBLK += BLK_;\r\n    }\r\n\r\n    function setAdmin(address addr_, bool com_) public onlyOwner {\r\n        Admin[addr_] = com_;\r\n    }\r\n\r\n    function safePull(address addr_) public onlyOwner {\r\n        BLK.safeTransfer(addr_, BLK.balanceOf(address(this)));\r\n        USDB.safeTransfer(addr_, USDB.balanceOf(address(this)));\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {// Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {codehash := extcodehash(account)}\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"invitor_\",\"type\":\"address\"}],\"name\":\"BondInvitor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mode_\",\"type\":\"uint256\"}],\"name\":\"ClaimInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mode_\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"}],\"name\":\"UnDeposite\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Admin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLK\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLKPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLY\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"invitor_\",\"type\":\"address\"}],\"name\":\"bondUserInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"checkSlotNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"checkUserInvitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"out_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"checkUserRefer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"}],\"name\":\"claimInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"countingAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"countingFlyCostBLK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"countingFlyCostUSDB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"}],\"name\":\"countingInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"round_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mode_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"invitor_\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"round_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mode_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"invitor_\",\"type\":\"address\"}],\"name\":\"depositWithFly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"e\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getBLKPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"old\",\"outputs\":[{\"internalType\":\"contract Old\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quota\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"safePull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"com_\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"setOld\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"BLK_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"USDB_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"FLY_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair_\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"BLK_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"USDB_\",\"type\":\"uint256\"}],\"name\":\"setUserInvitorReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot_\",\"type\":\"uint256\"}],\"name\":\"unDeposite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteRewardBLK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteRewardUSDB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteBlkClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteUsdbClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedBLK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedUSDB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userSlot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fly\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Deposit", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a0113260f02318e1934d712049e93bbcc6ed589534bf4c4dc33511a7732df3b6"}