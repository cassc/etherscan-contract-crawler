{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/periphery/misc/LiquidationAdaptorPancakeV3FallBack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\ncontract LiquidationAdaptorPancakeV3FallBack is Ownable {\\n    // intended for pancakeRouter\\n    // address constant public pancakeRouter = 0x13f4EA83D0bd40E75C8222255bc855a974568Dd4;\\n\\n    address constant public ETH = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\\n    address constant public WBETH = 0xa2E3356610840701BDf5611a53974510Ae27E2e1;\\n    address constant public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address constant public BTC = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\\n    address constant public USDT = 0x55d398326f99059fF775485246999027B3197955;\\n    address constant public BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n    address constant public USDC = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\\n    address constant public TUSD = 0x40af3827F39D0EAcBF4A168f8D4ee67c121D11c9;\\n\\n    mapping(bytes32 => bytes) public callDataMap;\\n\\n    event NewPath(address _tokenIn, address _tokenOut, bytes path);\\n\\n    // with 8 assets there are 56 path pre-computed\\n    constructor() {\\n        \\n        // ETH => WBETH cross 0.05 V3 pool \\n        callDataMap[keccak256(abi.encode(ETH, WBETH))] = \\n        abi.encodePacked(ETH, uint24(500), WBETH);\\n        // ETH => BTC cross 0.3 V3 pool\\n        callDataMap[keccak256(abi.encode(ETH, BTC))] = \\n        abi.encodePacked(ETH, uint24(2500), BTC);\\n        // ETH => BNB\\n        callDataMap[keccak256(abi.encode(ETH, WBNB))] = \\n        abi.encodePacked(ETH, uint24(2500), WBNB);\\n        // ETH => USDT\\n        callDataMap[keccak256(abi.encode(ETH, USDT))] = \\n        abi.encodePacked(ETH, uint24(500), USDC, uint24(100), USDT);\\n        // ETH => USDC\\n        callDataMap[keccak256(abi.encode(ETH, USDC))] = \\n        abi.encodePacked(ETH, uint24(500), USDC);\\n        // ETH => BUSD\\n        callDataMap[keccak256(abi.encode(ETH, BUSD))] = \\n        abi.encodePacked(ETH, uint24(500), USDC, uint24(100), BUSD);\\n        // ETH => TUSD\\n        callDataMap[keccak256(abi.encode(ETH, TUSD))] = \\n        abi.encodePacked(ETH, uint24(500), USDC, uint24(100), USDT, uint24(100), TUSD);\\n\\n        // WBETH => ETH\\n        callDataMap[keccak256(abi.encode(WBETH, ETH))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH);\\n        // WBETH => BTC\\n        callDataMap[keccak256(abi.encode(WBETH, BTC))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH, uint24(2500), BTC);\\n        // WBETH => WBNB\\n        callDataMap[keccak256(abi.encode(WBETH, WBNB))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH, uint24(2500), WBNB);\\n        // WBETH => USDT\\n        callDataMap[keccak256(abi.encode(WBETH, USDT))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH, uint24(500), USDC, uint24(100), USDT);\\n        // WBETH => USDC\\n        callDataMap[keccak256(abi.encode(WBETH, USDC))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH, uint24(500), USDC);\\n        // WBETH => BUSD\\n        callDataMap[keccak256(abi.encode(WBETH, BUSD))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH, uint24(500), USDC, uint24(100), BUSD);\\n        // WBETH => TUSD\\n        callDataMap[keccak256(abi.encode(WBETH, USDC))] = \\n        abi.encodePacked(WBETH, uint24(500), ETH, uint24(500), USDC, uint24(100), USDT, uint24(100), TUSD);\\n\\n        // BTC => ETH\\n        callDataMap[keccak256(abi.encode(BTC, ETH))] = \\n        abi.encodePacked(BTC, uint24(2500), ETH);\\n        // BTC => WBETH\\n        callDataMap[keccak256(abi.encode(BTC, WBETH))] = \\n        abi.encodePacked(BTC, uint24(2500), ETH, uint24(500), WBETH);\\n        // BTC => BNB\\n        callDataMap[keccak256(abi.encode(BTC, WBNB))] = \\n        abi.encodePacked(BTC, uint24(2500), WBNB);\\n        // BTC => USDT\\n        callDataMap[keccak256(abi.encode(BTC, USDT))] = \\n        abi.encodePacked(BTC,  uint24(500), USDT);\\n        // BTC => USDC\\n        callDataMap[keccak256(abi.encode(BTC, USDC))] = \\n        abi.encodePacked(BTC,  uint24(500), USDT, uint24(100), USDC);\\n        // BTC => BUSD\\n        callDataMap[keccak256(abi.encode(BTC, BUSD))] = \\n        abi.encodePacked(BTC, uint24(500), BUSD);\\n        // BTC => TUSD\\n        callDataMap[keccak256(abi.encode(BTC, TUSD))] = \\n        abi.encodePacked(BTC,  uint24(500), USDT, uint24(100), TUSD);\\n\\n        // BNB => ETH\\n        callDataMap[keccak256(abi.encode(WBNB, ETH))] = \\n        abi.encodePacked(WBNB,  uint24(2500), ETH);\\n        // BNB => WBETH\\n        callDataMap[keccak256(abi.encode(WBNB, WBETH))] = \\n        abi.encodePacked(WBNB,  uint24(2500), ETH, uint24(500), WBETH);\\n        // BNB => BTC\\n        callDataMap[keccak256(abi.encode(WBNB, BTC))] = \\n        abi.encodePacked(WBNB,  uint24(2500), BTC);\\n        // BNB => USDT\\n        callDataMap[keccak256(abi.encode(WBNB, USDT))] = \\n        abi.encodePacked(WBNB,  uint24(500), USDT);\\n        // BNB => USDC\\n        callDataMap[keccak256(abi.encode(WBNB, USDC))] = \\n        abi.encodePacked(WBNB,  uint24(500), BUSD, uint24(100), USDC);\\n        // BNB => BUSD\\n        callDataMap[keccak256(abi.encode(WBNB, BUSD))] = \\n        abi.encodePacked(WBNB,  uint24(500), BUSD);\\n        // BNB => TUSD\\n        callDataMap[keccak256(abi.encode(WBNB, TUSD))] = \\n        abi.encodePacked(WBNB,  uint24(500), USDT, uint24(100), TUSD);\\n\\n        // USDT => ETH\\n        callDataMap[keccak256(abi.encode(USDT, ETH))] = \\n        abi.encodePacked(USDT, uint24(100), USDC, uint24(500), ETH);\\n        // USDT => WBETH\\n        callDataMap[keccak256(abi.encode(USDT, WBETH))] = \\n        abi.encodePacked(USDT, uint24(100), USDC, uint24(500), ETH, uint24(500), WBETH);\\n        // USDT => BNB\\n        callDataMap[keccak256(abi.encode(USDT, WBNB))] = \\n        abi.encodePacked(USDT, uint24(500), WBNB);\\n        // USDT => BTC\\n        callDataMap[keccak256(abi.encode(USDT, BTC))] = \\n        abi.encodePacked(USDT, uint24(500), BTC);\\n        // USDT => USDC\\n        callDataMap[keccak256(abi.encode(USDT, USDC))] = \\n        abi.encodePacked(USDT, uint24(100), USDC);\\n        // USDT => BUSD\\n        callDataMap[keccak256(abi.encode(USDT, BUSD))] = \\n        abi.encodePacked(USDT, uint24(100), BUSD);\\n        // USDT => TUSD\\n        callDataMap[keccak256(abi.encode(USDT, TUSD))] = \\n        abi.encodePacked(USDT, uint24(100), TUSD);\\n\\n        // USDC => ETH\\n        callDataMap[keccak256(abi.encode(USDC, ETH))] = \\n        abi.encodePacked(USDC, uint24(500), ETH);\\n        // USDC => WBETH\\n        callDataMap[keccak256(abi.encode(USDC, WBETH))] = \\n        abi.encodePacked(USDC, uint24(500), ETH, uint24(500), WBETH);\\n        // USDC => BNB\\n        callDataMap[keccak256(abi.encode(USDC, WBNB))] = \\n        abi.encodePacked(USDC, uint24(100), BUSD, uint24(500), WBNB);\\n        // USDC => USDT\\n        callDataMap[keccak256(abi.encode(USDC, USDT))] = \\n        abi.encodePacked(USDC, uint24(100), ETH);\\n        // USDC => BTC\\n        callDataMap[keccak256(abi.encode(USDC, BTC))] = \\n        abi.encodePacked(USDC, uint24(100), USDT, uint24(500), BTC);\\n        // USDC => BUSD\\n        callDataMap[keccak256(abi.encode(USDC, BUSD))] = \\n        abi.encodePacked(USDC, uint24(100), BUSD);\\n        // USDC => TUSD\\n        callDataMap[keccak256(abi.encode(USDC, TUSD))] = \\n        abi.encodePacked(USDC, uint24(100), USDT, uint24(100), TUSD);\\n\\n        // BUSD => ETH\\n        callDataMap[keccak256(abi.encode(BUSD, ETH))] = \\n        abi.encodePacked(BUSD, uint24(100), USDC, uint24(500), ETH);\\n        // BUSD => WBETH\\n        callDataMap[keccak256(abi.encode(BUSD, WBETH))] = \\n        abi.encodePacked(BUSD, uint24(100), USDC, uint24(500), ETH, uint24(500), WBETH);\\n        // BUSD => BNB\\n        callDataMap[keccak256(abi.encode(BUSD, WBNB))] = \\n        abi.encodePacked(BUSD, uint24(500), WBNB);\\n        // BUSD => USDT\\n        callDataMap[keccak256(abi.encode(BUSD, USDT))] = \\n        abi.encodePacked(BUSD, uint24(100), USDT);\\n        // BUSD => USDC\\n        callDataMap[keccak256(abi.encode(BUSD, USDC))] = \\n        abi.encodePacked(BUSD, uint24(100), USDC);\\n        // BUSD => BTC\\n        callDataMap[keccak256(abi.encode(BUSD, BTC))] = \\n        abi.encodePacked(BUSD, uint24(500), BTC);\\n        // BUSD => TUSD\\n        callDataMap[keccak256(abi.encode(BUSD, TUSD))] = \\n        abi.encodePacked(BUSD, uint24(100), USDT, uint24(100), TUSD);\\n\\n        // TUSD => ETH\\n        callDataMap[keccak256(abi.encode(TUSD, ETH))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT, uint24(100), USDC, uint24(500), ETH);\\n        // TUSD => WBETH\\n        callDataMap[keccak256(abi.encode(TUSD, ETH))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT, uint24(100), USDC, uint24(500), ETH, uint24(500), WBETH);\\n        // TUSD => BNB\\n        callDataMap[keccak256(abi.encode(TUSD, WBNB))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT, uint24(500), WBNB);\\n        // TUSD => USDT\\n        callDataMap[keccak256(abi.encode(TUSD, USDT))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT);\\n        // TUSD => USDC\\n        callDataMap[keccak256(abi.encode(TUSD, USDC))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT, uint24(100), USDC);\\n        // TUSD => BTC\\n        callDataMap[keccak256(abi.encode(TUSD, BTC))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT, uint24(500), BTC);\\n        // TUSD => BUSD\\n        callDataMap[keccak256(abi.encode(TUSD, BUSD))] = \\n        abi.encodePacked(TUSD, uint24(100), USDT, uint24(100), BUSD);\\n    }\\n    // path that is generalized off-chain, it's a deterministic path to go pass\\n    function getPath(address _tokenIn, address _tokenOut) public view returns(bytes memory) {\\n        require(_tokenIn != _tokenOut);\\n        bytes32 hash = keccak256(abi.encode(_tokenIn, _tokenOut));\\n        return callDataMap[hash];\\n    }\\n\\n    function updatePath(address _tokenIn, address _tokenOut, bytes memory newPath) external onlyOwner {\\n        require(_tokenIn != _tokenOut);\\n        bytes32 hash = keccak256(abi.encode(_tokenIn, _tokenOut));\\n        callDataMap[hash] = newPath;\\n        emit NewPath(_tokenIn, _tokenOut , newPath);\\n        \\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@aave/=node_modules/@aave/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"src/core/protocol/libraries/logic/BorrowLogic.sol\": {\r\n        \"BorrowLogic\": \"0xa6265a8cE6F89610d3f97851abcf7F8203B006FB\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/BridgeLogic.sol\": {\r\n        \"BridgeLogic\": \"0x342019c99EA2869E1233bB461420078C149a00f1\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/ConfiguratorLogic.sol\": {\r\n        \"ConfiguratorLogic\": \"0x306ca8E36c1DcC1E160f94d1Eb5Fd97CEa889871\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/EModeLogic.sol\": {\r\n        \"EModeLogic\": \"0xC8CB15Bc73B7f5f95Af33AEce738bC9B62Cb28D9\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/FlashLoanLogic.sol\": {\r\n        \"FlashLoanLogic\": \"0x7954F3efe905D4f2690a05a594886706F424327f\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/LiquidationLogic.sol\": {\r\n        \"LiquidationLogic\": \"0x54C33c8669D52Bb0cd6682dB419483a1e86D8e67\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/PoolLogic.sol\": {\r\n        \"PoolLogic\": \"0x30777a478886eCFcA0DC8B023e4Fd19b133D616F\"\r\n      },\r\n      \"src/core/protocol/libraries/logic/SupplyLogic.sol\": {\r\n        \"SupplyLogic\": \"0x763B2a4EbA91c3667a74Ba87A7142be3282FC1C2\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"}],\"name\":\"NewPath\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"callDataMap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"getPath\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"newPath\",\"type\":\"bytes\"}],\"name\":\"updatePath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidationAdaptorPancakeV3FallBack", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}