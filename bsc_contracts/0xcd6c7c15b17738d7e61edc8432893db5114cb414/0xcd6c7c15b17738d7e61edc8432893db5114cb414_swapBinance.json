{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contractBsc/swapBinance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n// import \\\"hardhat/console.sol\\\";\\r\\ninterface IUniswapFactoryV3{\\r\\n  function getPool(address tokenA, address tokenB,uint24 fee) external view returns (address pair);\\r\\n  function owner() external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IUniswapFactoryV2{\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapRouterV2 {\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline) external\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapRouterV3{\\r\\n        struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\\r\\n    function swapExactTokensForTokens(uint amountIn , uint amountOut , address [] memory path , address to )external payable returns(uint amonutOut);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouterV3{\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;}\\r\\n\\r\\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\\r\\n}\\r\\n\\r\\ninterface IUniswapPoolV2{\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0()external view returns(address);\\r\\n}\\r\\n\\r\\ninterface IUniswapPoolsV3 {\\r\\n    function slot0()external view returns (uint160 sqrtPriceX96 , \\r\\n                                      int24 tick, uint16 observationIndex,\\r\\n                                      uint16 observationCardinality,\\r\\n                                      uint16 observationCardinalityNext,\\r\\n                                      uint8 feeProtocol,\\r\\n                                      bool unlocked);// use for uniswap contracts\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0()external view returns(address);\\r\\n}\\r\\n\\r\\ninterface IBancorNetworkInfo{\\r\\n    function tradeInputByTargetAmount(address sourceToken, address targetToken, uint256 targetAmount)external view returns(uint);\\r\\n    function tradingFeePPM(address pool) external view returns (uint32);\\r\\n    function tradeOutputBySourceAmount(address sourceToken, address targetToken, uint256 sourceAmount)external view returns(uint);\\r\\n    function tradingEnabled(address pool) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface IBancorNetwork{\\r\\n        function tradeBySourceAmount(\\r\\n        address sourceToken,\\r\\n        address targetToken,\\r\\n        uint256 sourceAmount,\\r\\n        uint256 minReturnAmount,\\r\\n        uint256 deadline,\\r\\n        address beneficiary\\r\\n    ) external payable;\\r\\n        function version()external view returns(uint);\\r\\n        function pendingNetworkFeeAmount()external view returns(uint);\\r\\n}\\r\\n\\r\\ninterface IERC20{\\r\\n    function decimals() external view returns(uint8);\\r\\n    function balanceOf(address owner)external view returns(uint);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address to , uint value)external;\\r\\n\\r\\n}\\r\\n\\r\\n interface IWERC20{\\r\\n    function deposit()external payable;\\r\\n    function withdraw(uint256 amount) external payable;\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function balanceOf(address owner)external view returns(uint);\\r\\n    function transfer(address to , uint value)external view;\\r\\n }\\r\\n\\r\\ninterface ItypeData{\\r\\n\\r\\n    struct EndResult{\\r\\n        address pool;\\r\\n        uint price;\\r\\n        int decimalDifference;\\r\\n        uint amonutIn;\\r\\n        uint24 fee;\\r\\n        bool invert; \\r\\n        string dexVersion;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract swapBinance{\\r\\n\\r\\n    mapping(string =>mapping(string => address)) dexsToSymbols;\\r\\n    mapping(string => uint24)feeOfTheDex;\\r\\n\\r\\n    address immutable admin;\\r\\n    // address Weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; for ethereum main chain\\r\\n    // 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6;for goerli chain\\r\\n    address Weth;\\r\\n    string [] public totalDexs;\\r\\n    uint24 [] public DexFees;\\r\\n\\r\\n    // event SetNewAddress(string , string);\\r\\n    // event GotAllPrices();\\r\\n    // event SetFeeDex(string , uint24);\\r\\n\\r\\n\\r\\n    modifier onlyAdmin(){\\r\\n        require(msg.sender == admin , \\\"not the admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isAmount(){\\r\\n        require(msg.value > 0 , \\\"amount does not exist\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isToken(address token){\\r\\n        require(token !=address(0) , \\\"address token does not exits\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(address _weth){\\r\\n        admin = msg.sender;\\r\\n        Weth = _weth;\\r\\n    }\\r\\n\\r\\n    receive()external payable{}\\r\\n\\r\\n    function setDexSymbolContracts(string calldata dexName,string calldata symbol,address contractAddress) external onlyAdmin{\\r\\n        require(dexsToSymbols[dexName][symbol] == address(0) , \\\"dex address is set\\\");\\r\\n        dexsToSymbols[dexName][symbol] = contractAddress;\\r\\n        // emit SetNewAddress(dexName , symbol);\\r\\n    }\\r\\n\\r\\n    function setDexList(string [] memory _dexsName)external onlyAdmin returns(bool){\\r\\n        totalDexs = _dexsName;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setDexFeeList(uint24 [] memory _fees)external onlyAdmin returns(bool){\\r\\n        DexFees = _fees;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setFeeOfDex(string memory contractType , uint24 feeAmount)external onlyAdmin{\\r\\n        require(feeOfTheDex[contractType] == 0 ,\\\"fee is set\\\");\\r\\n        feeOfTheDex[contractType] = feeAmount;\\r\\n        // emit SetFeeDex(contractType , feeAmount);\\r\\n    }\\r\\n\\r\\n    function removeFeeOfDex(string memory contractType)external onlyAdmin{\\r\\n        delete feeOfTheDex[contractType];\\r\\n    }\\r\\n\\r\\n    function deletedexContractAddress(string  memory dex , string memory contractType)external onlyAdmin returns(bool){\\r\\n        \\r\\n        bool status = dexsToSymbols[dex][contractType] == address(0) ? false : true;\\r\\n        \\r\\n        delete dexsToSymbols[dex][contractType];\\r\\n\\r\\n        return status;\\r\\n    }\\r\\n\\r\\n    function getAllPrices(address token0,address token1 , uint amountIn)public isToken(token0) view returns(ItypeData.EndResult [] memory PriceRatios){\\r\\n\\r\\n        uint8 count;\\r\\n        ItypeData.EndResult[] memory totalPairs = new ItypeData.EndResult[](9);\\r\\n        \\r\\n        for (uint i = 0 ; i < totalDexs.length ; i++){\\r\\n            \\r\\n            ItypeData.EndResult memory res = getPrice(token0 , token1 , amountIn , totalDexs[i] , DexFees[i]);\\r\\n\\r\\n            if(res.pool != address(0)){\\r\\n                totalPairs[count] = res;\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        ItypeData.EndResult[] memory availablePools = new ItypeData.EndResult[](count);\\r\\n\\r\\n        for(uint8 i = 0 ; i < count ; i++){\\r\\n            availablePools[i] = totalPairs[i];\\r\\n        }\\r\\n\\r\\n        return availablePools;\\r\\n\\r\\n    }\\r\\n\\r\\n    function getPrice(address token0 , address token1 , uint amountIn , string memory dexName ,uint24 fee) public view returns(ItypeData.EndResult memory){\\r\\n        if(checkDexName(dexName , \\\"UNISWAPV3\\\") || checkDexName(dexName , \\\"PANCAKESWAPV3\\\")){\\r\\n            \\r\\n            require(fee != 0 , \\\"fee is not set\\\");\\r\\n            return uniswapV3GetPrice(token0 , token1 , amountIn , dexName , fee);\\r\\n        }else{\\r\\n            return uniswapV2GetPrice(token0 , token1 , amountIn , dexName);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function uniswapV3GetPrice(address token0,address token1 , uint amountIn , string memory contractType , uint24 fee)public view returns( ItypeData.EndResult memory ){\\r\\n        \\r\\n        address pairAddress = uniswapV3GetSinglePool(token0 , token1 , contractType , fee);\\r\\n        \\r\\n        if(pairAddress == address(0)){\\r\\n            return ItypeData.EndResult(pairAddress , 0 ,0 , amountIn , fee , false , contractType);\\r\\n        }\\r\\n\\r\\n        uint8 decimal0 = IERC20(token0).decimals();\\r\\n        uint8 decimal1 = IERC20(token1).decimals();\\r\\n\\r\\n        bool invert  = token0 == IUniswapPoolsV3(pairAddress).token0() ? true : false;\\r\\n        int decimalDifference = getDecimalDiffenrence(decimal0 , decimal1 , invert);\\r\\n    \\r\\n        (bool status , bytes memory data) = pairAddress.staticcall(abi.encodeWithSelector(IUniswapPoolsV3(pairAddress).slot0.selector));\\r\\n        require(status , \\\"not called\\\");\\r\\n        (uint160 sqrtPriceX96,,,,,,) = abi.decode(data , (uint160 , int24 , uint16, uint16,uint16,uint32 , bool));\\r\\n        \\r\\n        uint160 amountOut = sqrtPriceX96;\\r\\n\\r\\n        return ItypeData.EndResult(pairAddress , amountOut ,decimalDifference , amountIn , fee , invert , contractType);\\r\\n    }\\r\\n\\r\\n    function uniswapV3GetSinglePool(address token0 , address token1 , string memory contractType , uint24 fee)public view returns(address){\\r\\n        address  factoryAddress = dexsToSymbols[contractType][\\\"FACTORYV3\\\"];\\r\\n        require(factoryAddress != address(0) , \\\"facotry address not set\\\");\\r\\n\\r\\n        return IUniswapFactoryV3(factoryAddress).getPool(token0,token1,fee);\\r\\n    }\\r\\n\\r\\n    function getFeeOfDex(uint indx ,string memory contractType)internal pure returns(uint24){\\r\\n        uint24[3] memory uniswapFees = [uint24(500),3000,10000];\\r\\n        uint24[4] memory pancakeswapFees = [uint24(100),uint24(500),2500 ,10000];\\r\\n\\r\\n        if(checkDexName(contractType , \\\"UNISWAPV3\\\")){\\r\\n            return uniswapFees[indx];\\r\\n        }else if (checkDexName(contractType , \\\"PANCAKESWAPV3\\\")){\\r\\n            return pancakeswapFees[indx];\\r\\n        }\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function uniswapV2GetPrice(address token0,address token1 , uint amountIn , string memory contractType)public\\r\\n    isToken(token0) view returns(ItypeData.EndResult memory){\\r\\n        address factory = dexToContractAddress(contractType , \\\"FACTORYV2\\\");\\r\\n        address router  = dexToContractAddress(contractType ,\\\"ROUTERV2\\\");\\r\\n        uint24 feeDexV2 = feeOfTheDex[contractType];\\r\\n        address[] memory path = new address[](2);\\r\\n\\r\\n        path[0] = token0;\\r\\n        path[1] = token1;\\r\\n        \\r\\n        require(factory != address(0) , \\\"dex factory address is not set\\\");\\r\\n        require(router != address(0) , \\\"dex Router address is not set\\\");\\r\\n        \\r\\n        \\r\\n        address PairPool = UniswapV2GetPoolPair(token0 , token1 , factory);\\r\\n\\r\\n        if(PairPool == address(0)){\\r\\n            ItypeData.EndResult memory notFound = ItypeData.EndResult(PairPool , 0 , 0 , amountIn , feeDexV2 , false , contractType);\\r\\n            return notFound;\\r\\n        }\\r\\n        bool invert  = token0 == IUniswapPoolsV3(PairPool).token0() ? false : true;\\r\\n\\r\\n        uint256[] memory amounts = IUniswapRouterV2(router).getAmountsOut(amountIn , path);\\r\\n\\r\\n        ItypeData.EndResult memory endResult = ItypeData.EndResult(PairPool , amounts[1] , 0 , amounts[0], feeDexV2 , invert , contractType );\\r\\n\\r\\n        return endResult;\\r\\n    }\\r\\n\\r\\n    function UniswapV2GetPoolPair(address token0,address token1,address factoryAddress)\\r\\n    public view returns(address){\\r\\n        address poolAddress = IUniswapFactoryV2(factoryAddress).getPair(token0 , token1);\\r\\n        \\r\\n        return poolAddress;\\r\\n    }\\r\\n\\r\\n    function executeSwap(address tokenIn ,address tokenOut , uint amountIn,uint24 fee ,bool isCoin , string memory contractType)\\r\\n    public payable \\r\\n    isToken(tokenIn){\\r\\n\\r\\n        if(checkDexName(contractType , \\\"UNISWAPV3\\\")){\\r\\n            \\r\\n            UniswapV3Execute(tokenIn , tokenOut , amountIn , fee , isCoin , contractType);\\r\\n\\r\\n        }else if(checkDexName(contractType , \\\"PANCAKESWAPV3\\\")){\\r\\n\\r\\n            PancakeSwapExecute(tokenIn , tokenOut , amountIn , fee , isCoin , contractType);\\r\\n\\r\\n        }else{\\r\\n            UniswapV2Execute(tokenIn , tokenOut , amountIn, isCoin , contractType);\\r\\n        }\\r\\n    } \\r\\n\\r\\n    function UniswapV2Execute(address tokenIn ,address tokenOut , uint amountIn,bool isCoin, string memory contractType)\\r\\n    public payable \\r\\n    isToken(tokenIn){\\r\\n        \\r\\n        address payable RouterV2 = payable (dexToContractAddress(contractType ,\\\"ROUTERV2\\\"));\\r\\n        uint deadline =block.timestamp + 30 minutes;\\r\\n        uint amountOutMin = 0; //for testing\\r\\n        address [] memory path = new address[](2);\\r\\n        path[0] = tokenIn; \\r\\n        path[1] = tokenOut; \\r\\n\\r\\n        if(tokenIn == Weth && msg.value > 0 && isCoin){\\r\\n            require(msg.value > 0 ,\\\"not enough ETH\\\");\\r\\n            \\r\\n            IUniswapRouterV2(RouterV2).swapExactETHForTokens{value: msg.value}(amountOutMin , path, msg.sender , deadline);\\r\\n\\r\\n        }\\r\\n        else if(tokenOut == Weth && isCoin){\\r\\n            require(IERC20(tokenIn).balanceOf(msg.sender)  >= amountIn , \\\"not enough tokens\\\");\\r\\n\\r\\n            IERC20(tokenIn).transferFrom(msg.sender ,address(this) ,amountIn);\\r\\n            IERC20(tokenIn).approve(RouterV2 ,amountIn);\\r\\n\\r\\n            IUniswapRouterV2(RouterV2).swapExactTokensForETH(amountIn , amountOutMin ,path ,msg.sender ,deadline);\\r\\n        }\\r\\n        else{\\r\\n            require(msg.value == 0 , \\\"eth must not be send\\\");\\r\\n            require(IERC20(tokenIn).balanceOf(msg.sender)  >= amountIn , \\\"not enough tokens\\\");\\r\\n            \\r\\n            // IERC20(tokenIn).transferFrom(msg.sender ,address(this) ,amountIn);\\r\\n            IERC20(tokenIn).transferFrom(msg.sender ,address(this) ,amountIn);\\r\\n            \\r\\n            IERC20(tokenIn).approve(RouterV2 ,amountIn);\\r\\n\\r\\n            IUniswapRouterV2(RouterV2).swapExactTokensForTokens(amountIn , amountOutMin , path , msg.sender ,deadline);\\r\\n        }      \\r\\n    }\\r\\n\\r\\n    function ethToWeth( uint amount , bool zeroToOne)public payable returns(bool){\\r\\n        //zero for withdraw , one for deposit\\r\\n        if(zeroToOne){\\r\\n            require(amount == msg.value ,\\\"not the same amount for deposit\\\");\\r\\n            IWERC20(Weth).deposit{value:msg.value}();\\r\\n            return true;\\r\\n        }else{\\r\\n            IWERC20(Weth).withdraw(amount);\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function UniswapV3Execute(address tokenIn ,address tokenOut , uint amountIn , uint24 fee , bool isCoin , string memory contractType)\\r\\n    public payable \\r\\n    isToken(tokenIn) {\\r\\n\\r\\n        if(tokenIn == Weth && isCoin) require(msg.value == amountIn , \\\"not correct amount\\\");\\r\\n        \\r\\n        address  RouterV3 = dexToContractAddress(contractType , \\\"ROUTERV3\\\");\\r\\n        address sender = msg.sender;\\r\\n        uint256 amountOutMinimum = 0;// for testing\\r\\n        uint160 sqrtPriceLimitX96 = 0;//for testing\\r\\n        IUniswapRouterV3.ExactInputSingleParams memory params;\\r\\n        address[] memory path = new address[](2);\\r\\n\\r\\n        if(tokenOut == Weth && isCoin)sender = address(this);\\r\\n\\r\\n        path[0] = tokenIn;\\r\\n        path[1] = tokenOut;\\r\\n\\r\\n        params = IUniswapRouterV3.ExactInputSingleParams(tokenIn , tokenOut , fee \\r\\n                                                        ,sender , amountIn \\r\\n                                                        , amountOutMinimum ,sqrtPriceLimitX96);\\r\\n\\r\\n        if(tokenIn == Weth && isCoin){  \\r\\n            \\r\\n            IUniswapRouterV3(RouterV3).exactInputSingle{value : msg.value}(params);\\r\\n        }\\r\\n        else {\\r\\n\\r\\n            IERC20(tokenIn).transferFrom(msg.sender , address(this) , amountIn);\\r\\n            IERC20(tokenIn).approve(RouterV3 ,amountIn);\\r\\n\\r\\n            (bool status , bytes memory data) = RouterV3.call{value:0}(abi.encodeWithSelector(IUniswapRouterV3(RouterV3).exactInputSingle.selector,params));\\r\\n            require(status , \\\"swap failed\\\");\\r\\n            uint amountOut = abi.decode(data , (uint));\\r\\n\\r\\n            // IUniswapRouterV3(RouterV3).exactInputSingle(params);\\r\\n\\r\\n            if(tokenOut == Weth && isCoin){\\r\\n                ethToWeth(amountOut , false);\\r\\n                (payable(msg.sender)).transfer(amountOut);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function PancakeSwapExecute(address tokenIn ,address tokenOut , uint amountIn , uint24 fee , bool isCoin , string memory contractType)\\r\\n    public payable \\r\\n    isToken(tokenIn) { \\r\\n\\r\\n    if(tokenIn == Weth && isCoin) require(msg.value == amountIn , \\\"not correct amount\\\");\\r\\n    \\r\\n    address  RouterV3 = dexToContractAddress(contractType , \\\"ROUTERV3\\\");\\r\\n    address sender = msg.sender;\\r\\n    uint256 amountOutMinimum = 0;// for testing\\r\\n    uint160 sqrtPriceLimitX96 = 0;//for testing\\r\\n    IPancakeRouterV3.ExactInputSingleParams memory params;\\r\\n\\r\\n    params = IPancakeRouterV3.ExactInputSingleParams(tokenIn , tokenOut , fee \\r\\n                                                    ,sender , amountIn , amountOutMinimum \\r\\n                                                    ,sqrtPriceLimitX96);\\r\\n\\r\\n    if(tokenOut == Weth && isCoin)sender = address(this);\\r\\n\\r\\n    if(tokenIn == Weth && isCoin){\\r\\n            IPancakeRouterV3(RouterV3).exactInputSingle{value : msg.value}(params);\\r\\n        \\r\\n        }else {\\r\\n\\r\\n            IERC20(tokenIn).transferFrom(msg.sender , address(this) , amountIn);\\r\\n            IERC20(tokenIn).approve(RouterV3 ,amountIn);\\r\\n\\r\\n            (bool status , bytes memory data) = RouterV3.call{value:0}(abi.encodeWithSelector(IPancakeRouterV3(RouterV3).exactInputSingle.selector,params));\\r\\n            require(status , \\\"swap failed\\\");\\r\\n            uint amountOut = abi.decode(data , (uint));\\r\\n\\r\\n            if(tokenOut == Weth && isCoin){\\r\\n                ethToWeth(amountOut , false);\\r\\n                (payable(msg.sender)).transfer(amountOut);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    function getDecimalDiffenrence(uint decimal0,uint decimal1 , bool invertInputs)public pure returns(int){\\r\\n        \\r\\n        return decimal1>decimal0 ? int(decimal1 - decimal0) : int(decimal0 - decimal1);\\r\\n    }\\r\\n\\r\\n    function dexToContractAddress(string  memory dex , string memory contractType)public view returns(address){\\r\\n        return dexsToSymbols[dex][contractType];\\r\\n    }\\r\\n\\r\\n    function checkDexName(string memory name , string memory dex)public pure returns(bool){\\r\\n        return keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked(dex));\\r\\n    }\\r\\n\\r\\n    function destroyContract()external onlyAdmin{\\r\\n        selfdestruct(payable(admin));\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"DexFees\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"PancakeSwapExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"UniswapV2Execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factoryAddress\",\"type\":\"address\"}],\"name\":\"UniswapV2GetPoolPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"UniswapV3Execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"dex\",\"type\":\"string\"}],\"name\":\"checkDexName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dex\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"deletedexContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dex\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"dexToContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"zeroToOne\",\"type\":\"bool\"}],\"name\":\"ethToWeth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"isCoin\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"executeSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getAllPrices\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"decimalDifference\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"amonutIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"dexVersion\",\"type\":\"string\"}],\"internalType\":\"struct ItypeData.EndResult[]\",\"name\":\"PriceRatios\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"decimal0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimal1\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"invertInputs\",\"type\":\"bool\"}],\"name\":\"getDecimalDiffenrence\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"dexName\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"getPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"decimalDifference\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"amonutIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"dexVersion\",\"type\":\"string\"}],\"internalType\":\"struct ItypeData.EndResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"removeFeeOfDex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24[]\",\"name\":\"_fees\",\"type\":\"uint24[]\"}],\"name\":\"setDexFeeList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_dexsName\",\"type\":\"string[]\"}],\"name\":\"setDexList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dexName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setDexSymbolContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"feeAmount\",\"type\":\"uint24\"}],\"name\":\"setFeeOfDex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDexs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"}],\"name\":\"uniswapV2GetPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"decimalDifference\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"amonutIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"dexVersion\",\"type\":\"string\"}],\"internalType\":\"struct ItypeData.EndResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"uniswapV3GetPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"decimalDifference\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"amonutIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"dexVersion\",\"type\":\"string\"}],\"internalType\":\"struct ItypeData.EndResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractType\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"uniswapV3GetSinglePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "swapBinance", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}