{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2021-06-25\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2021-06-24\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.6.11;\r\npragma experimental ABIEncoderV2;\r\n\r\nabstract contract ERC20Token {\r\n    function symbol() public virtual view returns (string memory);\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Owner {\r\n\r\n    address private owner;\r\n\r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n\r\n    // modifier to check if caller is owner\r\n    modifier isOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address\r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract SafeKeep is Owner {\r\n  struct record {\r\n    uint256 starttime;\r\n    uint256 endtime;\r\n    uint256 cycle_time;\r\n    address contractaddr;\r\n    uint256 quantity;\r\n    string symbol;\r\n    bool repeat;\r\n    uint256 ex_id;\r\n  }\r\n\r\n  struct depositRecord {\r\n    uint256 starttime;\r\n    uint256 quantity;\r\n  }\r\n\r\n  struct addrFlag {\r\n    address addr;\r\n    bool deleted;\r\n  }\r\n\r\n  struct recordFlag {\r\n    uint256 starttime;\r\n    bool deleted;\r\n  }\r\n\r\n  struct tokenMsg {\r\n    address[] tokens;\r\n    mapping (address => uint256) index_map;\r\n    mapping (address => bool) token;\r\n  }\r\n  tokenMsg tokenData;\r\n\r\n  struct keepMsg {\r\n    mapping (address => record[]) keeps;\r\n    mapping (address => mapping (uint256 => uint256))  index_map;\r\n    mapping (address => mapping (uint256 => record))  records; \r\n  }\r\n  keepMsg keepData;\r\n\r\n  struct depositMsg {\r\n    mapping (address => depositRecord[]) deposits;\r\n    mapping (address => mapping (uint256 => uint256))  index_map;\r\n    mapping (address => mapping (uint256 => depositRecord))  depositRecords;\r\n  }\r\n  depositMsg depositData;\r\n\r\n  address public yefi_con; \r\n  uint256 public cycle_time; \r\n  uint256 public cycle_time2; \r\n  bool public allow_token;\r\n\r\n  event keepe(address indexed user, uint256 indexed starttime, uint256 endtime, address contractaddr, uint256 quantity, uint256 depositquantity, string symbol, bool repeat, uint256 ex_id);\r\n  event withdrawe(address indexed user, uint256 indexed starttime);\r\n\r\n  constructor(uint256 _cycleTime, uint256 _cycleTime2, bool _allowToken, address _yefi) public {\r\n      cycle_time = _cycleTime;\r\n      cycle_time2 = _cycleTime2;\r\n      allow_token = _allowToken;\r\n      yefi_con = _yefi;\r\n  }\r\n\r\n  function accept() public payable {\r\n  }\r\n\r\n  function setCycleTime(uint256 _time, uint256 _cycleTime2) public isOwner {\r\n    require(_time > 0, 'time must be greater than 0');\r\n    require(_cycleTime2 > 0, 'time must be greater than 0');\r\n    cycle_time = _time;\r\n    cycle_time2 = _cycleTime2;\r\n  }\r\n\r\n  function setAllowToken(bool _allow) public isOwner {\r\n    require(_allow != allow_token, 'cannot change to the same');\r\n    allow_token = _allow;\r\n  }\r\n\r\n  function addToken(address _contractaddr) public isOwner {\r\n    require(_contractaddr != address(0), 'wrong contractaddr');\r\n    require(!tokenData.token[_contractaddr], 'token already add');\r\n    uint256 indexKey = tokenData.index_map[_contractaddr];\r\n    tokenData.tokens.push(_contractaddr);\r\n    indexKey = tokenData.tokens.length - 1;\r\n    tokenData.index_map[_contractaddr] = indexKey;\r\n    tokenData.token[_contractaddr] = true;\r\n  }\r\n\r\n  function removeToken(address _contractaddr) public isOwner {\r\n    require(tokenData.token[_contractaddr], 'token not add');\r\n    uint256 indexKey = tokenData.index_map[_contractaddr];\r\n    if (indexKey < tokenData.tokens.length - 1) {\r\n      address lastAddr = tokenData.tokens[tokenData.tokens.length - 1];\r\n      tokenData.tokens[indexKey] = tokenData.tokens[tokenData.tokens.length - 1];\r\n      tokenData.tokens.pop();\r\n      tokenData.index_map[lastAddr] = indexKey;\r\n    } else {\r\n      tokenData.tokens.pop();\r\n    }\r\n    delete tokenData.index_map[_contractaddr];\r\n    delete tokenData.token[_contractaddr];\r\n  }\r\n\r\n  function getTokensCount() public view returns (uint256) {\r\n    return tokenData.tokens.length;\r\n  }\r\n\r\n  function getTokensArr() public view returns (address[] memory) {\r\n    return tokenData.tokens;\r\n  }\r\n\r\n  function getTokenAddr(uint256 indexKey) public view returns (address) {\r\n    require(indexKey < tokenData.tokens.length, 'wrong indexKey');\r\n    return tokenData.tokens[indexKey];\r\n  }\r\n\r\n  function isAddressAdd(address addr) public view returns (bool) {\r\n    return tokenData.token[addr];\r\n  }\r\n\r\n  function changeRepeat(uint256 _starttime, bool _repeat) public {\r\n    require(keepData.records[msg.sender][_starttime].starttime > 0, 'record of the starttime is not exists');\r\n    require(keepData.records[msg.sender][_starttime].repeat != _repeat, 'cannot change to the same repeat');\r\n\r\n    if (_repeat) {\r\n      require(keepData.records[msg.sender][_starttime].endtime >= now, 'It cannot be re opened after the end time');\r\n    } else {\r\n      while (keepData.records[msg.sender][_starttime].endtime < now) {\r\n        keepData.records[msg.sender][_starttime].endtime += keepData.records[msg.sender][_starttime].cycle_time;\r\n      }\r\n    }\r\n    keepData.records[msg.sender][_starttime].repeat = _repeat;\r\n    uint256 keyIndex = keepData.index_map[msg.sender][_starttime];\r\n    keepData.keeps[msg.sender][keyIndex].repeat = _repeat;\r\n    keepData.keeps[msg.sender][keyIndex].endtime = keepData.records[msg.sender][_starttime].endtime;\r\n  }\r\n\r\n  function keep(address _contractaddr, uint256 _value, bool _repeat, uint256 _depositValue, uint256 _exId, int8 _keepType) public {\r\n    require(tokenData.token[_contractaddr], 'token not add');\r\n\r\n    ERC20Token con = ERC20Token(_contractaddr);\r\n    safeTransferFrom(_contractaddr, msg.sender, address(this), _value);\r\n    string memory sym = con.symbol();\r\n\r\n    safeTransferFrom(yefi_con, msg.sender, address(this), _depositValue);\r\n\r\n    uint256 now_time = now;\r\n    while (keepData.records[msg.sender][now_time].starttime > 0) {\r\n        now_time += 1;\r\n    }\r\n\r\n    uint256 cycleTime;\r\n    if (_keepType == 1) {\r\n      cycleTime = cycle_time;\r\n    } else {\r\n      cycleTime = cycle_time2;\r\n    }\r\n\r\n    depositData.depositRecords[msg.sender][now_time] = depositRecord(now_time,  _depositValue);\r\n    depositData.deposits[msg.sender].push(depositRecord(now_time,  _depositValue));\r\n    depositData.index_map[msg.sender][now_time] = depositData.deposits[msg.sender].length - 1;\r\n    keepData.records[msg.sender][now_time] = record(now_time, now_time + cycleTime, cycleTime, _contractaddr, _value, sym, _repeat, _exId);\r\n    keepData.keeps[msg.sender].push(record(now_time, now_time + cycleTime, cycleTime, _contractaddr, _value, sym, _repeat, _exId));\r\n    keepData.index_map[msg.sender][now_time] = keepData.keeps[msg.sender].length - 1;\r\n\r\n    emit keepe(msg.sender, now_time, now_time + cycleTime, _contractaddr, _value, _depositValue, sym, _repeat, _exId);\r\n  }\r\n\r\n  function keepToken(uint256 _value, bool _repeat, uint256 _depositValue, uint256 _exId, int8 _keepType) public payable {\r\n    require(allow_token, 'This token is not supported');\r\n    require(_value == msg.value, 'wrong value');\r\n\r\n    safeTransferFrom(yefi_con, msg.sender, address(this), _depositValue);\r\n\r\n    uint256 now_time = now;\r\n    while (keepData.records[msg.sender][now_time].starttime > 0) {\r\n        now_time += 1;\r\n    }\r\n\r\n    uint256 cycleTime;\r\n    if (_keepType == 1) {\r\n      cycleTime = cycle_time;\r\n    } else {\r\n      cycleTime = cycle_time2;\r\n    }\r\n    depositData.depositRecords[msg.sender][now_time] = depositRecord(now_time,  _depositValue);\r\n    depositData.deposits[msg.sender].push(depositRecord(now_time,  _depositValue));\r\n    depositData.index_map[msg.sender][now_time] = depositData.deposits[msg.sender].length - 1;\r\n    keepData.records[msg.sender][now_time] = record(now_time, now_time + cycleTime, cycleTime, address(0), _value, 'BNB', _repeat, _exId);\r\n    keepData.keeps[msg.sender].push(record(now_time, now_time + cycleTime, cycleTime, address(0), _value, 'BNB', _repeat, _exId));\r\n    keepData.index_map[msg.sender][now_time] = keepData.keeps[msg.sender].length - 1;\r\n\r\n    emit keepe(msg.sender, now_time, now_time + cycleTime, address(0), _value, _depositValue, 'BNB', _repeat, _exId);\r\n  }\r\n\r\n  function withdraw(uint256 _starttime) public {\r\n    require(keepData.records[msg.sender][_starttime].starttime > 0, 'record of the starttime is not exists');\r\n    require(depositData.depositRecords[msg.sender][_starttime].starttime > 0, 'depositRecord of the starttime is not exists');\r\n    require(!keepData.records[msg.sender][_starttime].repeat, 'cannot withdraw when repeat is open');\r\n    require(now > keepData.records[msg.sender][_starttime].endtime, 'It is not due and cannot be retrieved');\r\n\r\n    address tokenContract = keepData.records[msg.sender][_starttime].contractaddr;\r\n    uint256 tokenValue = keepData.records[msg.sender][_starttime].quantity;\r\n    uint256 yefiValue = depositData.depositRecords[msg.sender][_starttime].quantity;\r\n\r\n    uint256 keyIndex = keepData.index_map[msg.sender][_starttime];\r\n    if (keyIndex < keepData.keeps[msg.sender].length - 1) {\r\n      uint256 lastStartTime = keepData.keeps[msg.sender][keepData.keeps[msg.sender].length - 1].starttime;\r\n      keepData.keeps[msg.sender][keyIndex] = keepData.keeps[msg.sender][keepData.keeps[msg.sender].length - 1];\r\n      keepData.keeps[msg.sender].pop();\r\n      keepData.index_map[msg.sender][lastStartTime] = keyIndex;\r\n    } else {\r\n      keepData.keeps[msg.sender].pop();\r\n      delete keepData.index_map[msg.sender][_starttime];\r\n    }\r\n    delete keepData.records[msg.sender][_starttime];\r\n\r\n    keyIndex = depositData.index_map[msg.sender][_starttime];\r\n    if (keyIndex < depositData.deposits[msg.sender].length - 1) {\r\n      uint256 lastStartTime = depositData.deposits[msg.sender][depositData.deposits[msg.sender].length - 1].starttime;\r\n      depositData.deposits[msg.sender][keyIndex] = depositData.deposits[msg.sender][depositData.deposits[msg.sender].length - 1];\r\n      depositData.deposits[msg.sender].pop();\r\n      depositData.index_map[msg.sender][lastStartTime] = keyIndex;\r\n    } else {\r\n      depositData.deposits[msg.sender].pop();\r\n      delete depositData.index_map[msg.sender][_starttime];\r\n    }\r\n    delete depositData.depositRecords[msg.sender][_starttime];\r\n    \r\n    safeTransfer(tokenContract, msg.sender, tokenValue);\r\n    safeTransfer(yefi_con, msg.sender, yefiValue);\r\n\r\n    emit withdrawe(msg.sender, _starttime);\r\n  }\r\n\r\n  function withdrawToken(uint256 _starttime) public {\r\n    require(keepData.records[msg.sender][_starttime].starttime > 0, 'record of the starttime is not exists');\r\n    require(depositData.depositRecords[msg.sender][_starttime].starttime > 0, 'depositRecord of the starttime is not exists');\r\n    require(!keepData.records[msg.sender][_starttime].repeat, 'cannot withdraw when repeat is open');\r\n    require(now > keepData.records[msg.sender][_starttime].endtime, 'It is not due and cannot be retrieved');\r\n    \r\n    uint256 tokenValue = keepData.records[msg.sender][_starttime].quantity;\r\n    uint256 yefiValue = depositData.depositRecords[msg.sender][_starttime].quantity;\r\n\r\n    uint256 keyIndex = keepData.index_map[msg.sender][_starttime];\r\n    if (keyIndex < keepData.keeps[msg.sender].length - 1) {\r\n      uint256 lastStartTime = keepData.keeps[msg.sender][keepData.keeps[msg.sender].length - 1].starttime;\r\n      keepData.keeps[msg.sender][keyIndex] = keepData.keeps[msg.sender][keepData.keeps[msg.sender].length - 1];\r\n      keepData.keeps[msg.sender].pop();\r\n      keepData.index_map[msg.sender][lastStartTime] = keyIndex;\r\n    } else {\r\n      keepData.keeps[msg.sender].pop();\r\n      delete keepData.index_map[msg.sender][_starttime];\r\n    }\r\n    delete keepData.records[msg.sender][_starttime];\r\n\r\n    keyIndex = depositData.index_map[msg.sender][_starttime];\r\n    if (keyIndex < depositData.deposits[msg.sender].length - 1) {\r\n      uint256 lastStartTime = depositData.deposits[msg.sender][depositData.deposits[msg.sender].length - 1].starttime;\r\n      depositData.deposits[msg.sender][keyIndex] = depositData.deposits[msg.sender][depositData.deposits[msg.sender].length - 1];\r\n      depositData.deposits[msg.sender].pop();\r\n      depositData.index_map[msg.sender][lastStartTime] = keyIndex;\r\n    } else {\r\n      depositData.deposits[msg.sender].pop();\r\n      delete depositData.index_map[msg.sender][_starttime];\r\n    }\r\n    delete depositData.depositRecords[msg.sender][_starttime];\r\n    \r\n    msg.sender.transfer(tokenValue);\r\n    safeTransfer(yefi_con, msg.sender, yefiValue);\r\n\r\n    emit withdrawe(msg.sender, _starttime);\r\n  }\r\n\r\n  function getKeepRecords(address addr) public view returns (record[] memory) {\r\n    return keepData.keeps[addr];\r\n  }\r\n\r\n  function getDepositRecords(address addr) public view returns (depositRecord[] memory) {\r\n    return depositData.deposits[addr];\r\n  }\r\n\r\n  function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferToken(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycleTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cycleTime2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_allowToken\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_yefi\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractaddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositquantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"repeat\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ex_id\",\"type\":\"uint256\"}],\"name\":\"keepe\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"}],\"name\":\"withdrawe\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accept\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractaddr\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allow_token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_starttime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_repeat\",\"type\":\"bool\"}],\"name\":\"changeRepeat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycle_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycle_time2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDepositRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeKeep.depositRecord[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getKeepRecords\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycle_time\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"repeat\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ex_id\",\"type\":\"uint256\"}],\"internalType\":\"struct SafeKeep.record[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"indexKey\",\"type\":\"uint256\"}],\"name\":\"getTokenAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensArr\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAddressAdd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractaddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_repeat\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_depositValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exId\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"_keepType\",\"type\":\"int8\"}],\"name\":\"keep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_repeat\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_depositValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exId\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"_keepType\",\"type\":\"int8\"}],\"name\":\"keepToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractaddr\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"setAllowToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cycleTime2\",\"type\":\"uint256\"}],\"name\":\"setCycleTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_starttime\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_starttime\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yefi_con\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SafeKeep", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000258000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000193b8230f594f63da50876eaf362177d1dca4a45", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4a10bcaa3fb349a4b1ded32840e9580e11b21f22764d6f2c652c6d8e09f20862"}