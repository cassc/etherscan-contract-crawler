{"SourceCode": "pragma solidity ^0.8.6;\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\ninterface IERC20 {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    function transfer(address to, uint256 value) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n}\r\n\r\ncontract SpinAdaStakingContract {\r\n    using SafeMath for uint256;\r\n    IERC20 public stakeToken;\r\n\r\n    address payable public owner;\r\n\r\n    uint256 public totalStakedToken;\r\n    uint256 public totalUnStakedToken;\r\n    uint256 public totalWithdrawanToken;\r\n    uint256 public totalClaimedRewardToken;\r\n    uint256 public totalStakers;\r\n    uint256 public percentDivider;\r\n\r\n    uint256[5] public Duration = [\r\n        30 days,\r\n        60 days,\r\n        90 days,\r\n        180 days,\r\n        365 days\r\n    ];\r\n    uint256[5] public Bonus = [33, 100, 200, 500, 1250];\r\n    uint256[5] public totalStakedPerPlan;\r\n    uint256[5] public totalStakersPerPlan;\r\n\r\n    struct Stake {\r\n        uint256 plan;\r\n        uint256 withdrawtime;\r\n        uint256 staketime;\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 persecondreward;\r\n        bool withdrawan;\r\n        bool unstaked;\r\n    }\r\n\r\n    struct User {\r\n        uint256 totalStakedTokenUser;\r\n        uint256 totalWithdrawanTokenUser;\r\n        uint256 totalUnStakedTokenUser;\r\n        uint256 totalClaimedRewardTokenUser;\r\n        uint256 stakeCount;\r\n        bool alreadyExists;\r\n    }\r\n\r\n    mapping(address => User) public Stakers;\r\n    mapping(uint256 => address) public StakersID;\r\n    mapping(address => mapping(uint256 => Stake)) public stakersRecord;\r\n    mapping(address => mapping(uint256 => uint256)) public userStakedPerPlan;\r\n\r\n    event STAKE(address Staker, uint256 amount);\r\n    event UNSTAKE(address Staker, uint256 amount);\r\n    event WITHDRAW(address Staker, uint256 amount);\r\n\r\n    modifier onlyowner() {\r\n        require(owner == msg.sender, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _owner, address _token) {\r\n        owner = payable(_owner);\r\n        stakeToken = IERC20(_token);\r\n        percentDivider = 1000;\r\n    }\r\n\r\n    function stake(uint256 amount, uint256 planIndex) public {\r\n        require(planIndex >= 0 && planIndex <= 4, \"Invalid Time Period\");\r\n        require(amount >= 0, \"stake more than 0\");\r\n\r\n        if (!Stakers[msg.sender].alreadyExists) {\r\n            Stakers[msg.sender].alreadyExists = true;\r\n            StakersID[totalStakers] = msg.sender;\r\n            totalStakers++;\r\n        }\r\n\r\n        stakeToken.transferFrom(msg.sender, address(this), amount);\r\n\r\n        uint256 index = Stakers[msg.sender].stakeCount;\r\n        Stakers[msg.sender].totalStakedTokenUser = Stakers[msg.sender]\r\n            .totalStakedTokenUser\r\n            .add(amount);\r\n        totalStakedToken = totalStakedToken.add(amount);\r\n        stakersRecord[msg.sender][index].withdrawtime = block.timestamp.add(\r\n            Duration[planIndex]\r\n        );\r\n        stakersRecord[msg.sender][index].staketime = block.timestamp;\r\n        stakersRecord[msg.sender][index].amount = amount;\r\n        stakersRecord[msg.sender][index].reward = amount\r\n            .mul(Bonus[planIndex])\r\n            .div(percentDivider);\r\n        stakersRecord[msg.sender][index].persecondreward = stakersRecord[\r\n            msg.sender\r\n        ][index].reward.div(Duration[planIndex]);\r\n        stakersRecord[msg.sender][index].plan = planIndex;\r\n        Stakers[msg.sender].stakeCount++;\r\n        userStakedPerPlan[msg.sender][planIndex] = userStakedPerPlan[\r\n            msg.sender\r\n        ][planIndex].add(amount);\r\n        totalStakedPerPlan[planIndex] = totalStakedPerPlan[planIndex].add(\r\n            amount\r\n        );\r\n        totalStakersPerPlan[planIndex]++;\r\n\r\n        emit STAKE(msg.sender, amount);\r\n    }\r\n\r\n    function unstake(uint256 index) public {\r\n        require(\r\n            !stakersRecord[msg.sender][index].withdrawan,\r\n            \"already withdrawan\"\r\n        );\r\n        require(!stakersRecord[msg.sender][index].unstaked, \"already unstaked\");\r\n        require(index < Stakers[msg.sender].stakeCount,\"Invalid index\");\r\n\r\n        stakersRecord[msg.sender][index].unstaked = true;\r\n        stakeToken.transfer(\r\n            msg.sender,\r\n            (stakersRecord[msg.sender][index].amount)\r\n        );\r\n        totalUnStakedToken = totalUnStakedToken.add(\r\n            stakersRecord[msg.sender][index].amount\r\n        );\r\n        Stakers[msg.sender].totalUnStakedTokenUser = Stakers[msg.sender]\r\n            .totalUnStakedTokenUser\r\n            .add(stakersRecord[msg.sender][index].amount);\r\n        uint256 planIndex = stakersRecord[msg.sender][index].plan;\r\n        userStakedPerPlan[msg.sender][planIndex] = userStakedPerPlan[\r\n            msg.sender\r\n        ][planIndex].sub(stakersRecord[msg.sender][index].amount, \"user stake\");\r\n        totalStakedPerPlan[planIndex] = totalStakedPerPlan[planIndex].sub(\r\n            stakersRecord[msg.sender][index].amount,\r\n            \"total stake\"\r\n        );\r\n        totalStakersPerPlan[planIndex]--;\r\n\r\n        emit UNSTAKE(msg.sender, stakersRecord[msg.sender][index].amount);\r\n    }\r\n\r\n    function withdraw(uint256 index) public {\r\n        require(\r\n            !stakersRecord[msg.sender][index].withdrawan,\r\n            \"already withdrawan\"\r\n        );\r\n        require(!stakersRecord[msg.sender][index].unstaked, \"already unstaked\");\r\n        require(\r\n            stakersRecord[msg.sender][index].withdrawtime < block.timestamp,\r\n            \"cannot withdraw before stake duration\"\r\n        );\r\n        require(index < Stakers[msg.sender].stakeCount,\"Invalid index\");\r\n\r\n        stakersRecord[msg.sender][index].withdrawan = true;\r\n        stakeToken.transfer(\r\n            msg.sender,\r\n            stakersRecord[msg.sender][index].amount\r\n        );\r\n        stakeToken.transferFrom(\r\n            owner,\r\n            msg.sender,\r\n            stakersRecord[msg.sender][index].reward\r\n        );\r\n        totalWithdrawanToken = totalWithdrawanToken.add(\r\n            stakersRecord[msg.sender][index].amount\r\n        );\r\n        totalClaimedRewardToken = totalClaimedRewardToken.add(\r\n            stakersRecord[msg.sender][index].reward\r\n        );\r\n        Stakers[msg.sender].totalWithdrawanTokenUser = Stakers[msg.sender]\r\n            .totalWithdrawanTokenUser\r\n            .add(stakersRecord[msg.sender][index].amount);\r\n        Stakers[msg.sender].totalClaimedRewardTokenUser = Stakers[msg.sender]\r\n            .totalClaimedRewardTokenUser\r\n            .add(stakersRecord[msg.sender][index].reward);\r\n        uint256 planIndex = stakersRecord[msg.sender][index].plan;\r\n        userStakedPerPlan[msg.sender][planIndex] = userStakedPerPlan[\r\n            msg.sender\r\n        ][planIndex].sub(stakersRecord[msg.sender][index].amount, \"user stake\");\r\n        totalStakedPerPlan[planIndex] = totalStakedPerPlan[planIndex].sub(\r\n            stakersRecord[msg.sender][index].amount,\r\n            \"total stake\"\r\n        );\r\n        totalStakersPerPlan[planIndex]--;\r\n\r\n        emit WITHDRAW(\r\n            msg.sender,\r\n            stakersRecord[msg.sender][index].reward.add(\r\n                stakersRecord[msg.sender][index].amount\r\n            )\r\n        );\r\n    }\r\n\r\n    function SetStakeDuration(\r\n        uint256 first,\r\n        uint256 second,\r\n        uint256 third,\r\n        uint256 fourth,\r\n        uint256 fifth\r\n    ) external onlyowner {\r\n        Duration[0] = first;\r\n        Duration[1] = second;\r\n        Duration[2] = third;\r\n        Duration[3] = fourth;\r\n        Duration[4] = fifth;\r\n    }\r\n\r\n    function SetStakeBonus(\r\n        uint256 first,\r\n        uint256 second,\r\n        uint256 third,\r\n        uint256 fourth,\r\n        uint256 fifth\r\n    ) external onlyowner {\r\n        Bonus[0] = first;\r\n        Bonus[1] = second;\r\n        Bonus[2] = third;\r\n        Bonus[3] = fourth;\r\n        Bonus[4] = fifth;\r\n    }\r\n\r\n    function realtimeReward(address user) public view returns (uint256) {\r\n        uint256 ret;\r\n        for (uint256 i; i < Stakers[user].stakeCount; i++) {\r\n            if (\r\n                !stakersRecord[user][i].withdrawan &&\r\n                !stakersRecord[user][i].unstaked\r\n            ) {\r\n                uint256 val;\r\n                val = block.timestamp - stakersRecord[user][i].staketime;\r\n                val = val.mul(stakersRecord[user][i].persecondreward);\r\n                if (val < stakersRecord[user][i].reward) {\r\n                    ret += val;\r\n                } else {\r\n                    ret += stakersRecord[user][i].reward;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"STAKE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UNSTAKE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WITHDRAW\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Bonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"third\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fourth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fifth\",\"type\":\"uint256\"}],\"name\":\"SetStakeBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"third\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fourth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fifth\",\"type\":\"uint256\"}],\"name\":\"SetStakeDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawanTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUnStakedTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedRewardTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alreadyExists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"StakersID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"realtimeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planIndex\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakersRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staketime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"persecondreward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawan\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalStakedPerPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalStakersPerPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawanToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakedPerPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SpinAdaStakingContract", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000078d36a9edd519647e7936c51da3415dd968e9b5f000000000000000000000000e19a9626aef55e20400a3b82a25c003403e88b7f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://66fc503a1a1cf1d05391eeb63298c20d5de4e28881bfd03a6fa3e1d6c3651eca"}