{"SourceCode": "// File: contracts/Ownable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.18;\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            _owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n// File: contracts/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity 0.8.18;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n// File: contracts/IERC20.sol\r\n\r\n\r\n\r\npragma solidity 0.8.18;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the ERC token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n// File: contracts/WorkAccurate.sol\r\n\r\n\r\n\r\npragma solidity 0.8.18;\r\n\r\n\r\n\r\n\r\ncontract WorkAccurate is Ownable {\r\n    // **********************************\r\n    // Primary Data\r\n    // **********************************\r\n    using SafeMath for uint256;\r\n    IERC20 public tether;\r\n    IERC20 public token;\r\n    address public dwbTokenAddress;\r\n    uint8 public plan1Percent;\r\n    uint8 public plan2Percent;\r\n    uint8 public tokenPercent;\r\n    uint256 public plan1Liquidity;\r\n    uint256 public plan2Liquidity;\r\n    uint256 public plan1LastDistribution;\r\n    uint256 public plan2LastDistribution;\r\n    mapping(uint256 => uint256) public _balances;\r\n    mapping(uint256 => uint8) public _userTokenPercent;\r\n    mapping(uint256 => uint256) public _userTokenCharge;\r\n    uint256 public accurateShare = 1000000;\r\n    uint256 public accurateSharePrice = 20000 ether;\r\n    mapping(uint256 => uint256) public _accurateShareBalances;\r\n    uint256 private lastReferral;\r\n    uint256 startTime = block.timestamp - 2 days;\r\n\r\n    struct Position {\r\n        address wallet;\r\n        address parent;\r\n        bool isLeft;\r\n        uint256 charged;\r\n        uint256 referral;\r\n        uint8 referralSide;\r\n        address leftChild;\r\n        address rightChild;\r\n        string name;\r\n        uint256 lastActivate;\r\n    }\r\n    Position[] public positions;\r\n\r\n    struct Commission {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    mapping(uint256 => Commission[]) public commissions;\r\n\r\n    struct Deposit {\r\n        uint256 pI;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    mapping(uint256 => Deposit[]) public leftDeposits;\r\n    mapping(uint256 => Deposit[]) public rightDeposits;\r\n    // uint256 Position index => struct Deposit\r\n\r\n    struct Transaction {\r\n        uint256 poIndex;\r\n        string txType;\r\n        uint256 amount;\r\n        uint256 time;\r\n    }\r\n    Transaction[] public transactions;\r\n\r\n    constructor() {\r\n        tether = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        token = IERC20(0x10f28281B99B3e20D4324C4F434FDdCC3DA5D7df);\r\n        dwbTokenAddress = address(0x10f28281B99B3e20D4324C4F434FDdCC3DA5D7df);\r\n        plan1Percent = 50;\r\n        plan2Percent = 50;\r\n        tokenPercent = 20;\r\n        plan1LastDistribution = plan2LastDistribution = startTime;\r\n        address wallet0 = 0xAB6BcCec0022FBBbee0F73012752365A9b61A255;\r\n        address wallet1 = 0x4D6cB99F0ED8D3ef7D6C2faD79a5690883447300;\r\n        address wallet2 = 0x03a7E3d24Abf448a62D86522F64B45f296DbC76f;\r\n        address wallet3 = 0x95EF8Cd4975400B8758D5Fe49DBF4620B9d957ee;\r\n        addPosition(wallet0, address(0), true, 100 ether);\r\n        reportsFun(\"Join\", wallet0, 100 ether);\r\n        addPosition(wallet1, wallet0, true, 100 ether);\r\n        reportsFun(\"Join\", wallet1, 100 ether);\r\n        positions[0].leftChild = wallet1;\r\n        addPosition(wallet2, wallet0, false, 100 ether);\r\n        positions[0].rightChild = wallet2;\r\n        reportsFun(\"Join\", wallet2, 100 ether);\r\n        addPosition(wallet3, wallet1, true, 100 ether);\r\n        positions[1].leftChild = wallet3;\r\n        reportsFun(\"Join\", wallet3, 100 ether);\r\n        leftDeposits[0].push(\r\n            Deposit({pI: 1, amount: 50 ether, timestamp: startTime})\r\n        );\r\n        rightDeposits[0].push(\r\n            Deposit({pI: 2, amount: 50 ether, timestamp: startTime})\r\n        );\r\n        leftDeposits[1].push(\r\n            Deposit({pI: 3, amount: 50 ether, timestamp: startTime})\r\n        );\r\n        leftDeposits[0].push(\r\n            Deposit({pI: 3, amount: 50 ether, timestamp: startTime})\r\n        );\r\n\r\n        plan1Liquidity = 200 ether;\r\n        plan2Liquidity = 200 ether;\r\n\r\n        addBalance(3, 4 ether);\r\n        _accurateShareBalances[0] = accurateShare;\r\n    }\r\n\r\n    // **********************************\r\n    // Setting\r\n    // **********************************\r\n\r\n    function setting() public {\r\n        if (SafeMath.sub(block.timestamp, startTime) >= 365 days) {\r\n            plan1Percent = 60;\r\n            plan2Percent = 40;\r\n        }\r\n        if (SafeMath.sub(block.timestamp, startTime) >= 2 * 365 days) {\r\n            plan1Percent = 70;\r\n            plan2Percent = 30;\r\n        }\r\n        if (SafeMath.sub(block.timestamp, startTime) >= 3 * 365 days) {\r\n            plan1Percent = 80;\r\n            plan2Percent = 20;\r\n        }\r\n    }\r\n\r\n    // **********************************\r\n    // Main Functions\r\n    // **********************************\r\n\r\n    function myPI() internal view returns (uint256 _myPI) {\r\n        _myPI = pIndex(_msgSender());\r\n    }\r\n\r\n    function pIndex(\r\n        address _address\r\n    ) internal view returns (uint256 positionIndex) {\r\n        for (uint i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _address) {\r\n                positionIndex = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addressExists(address _address) public view returns (bool) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _address) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getReferrer(\r\n        uint256 _referral\r\n    ) internal view returns (address positionAddress) {\r\n        positionAddress = address(0);\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            uint256 thisReferral = positions[i].referral;\r\n            if (thisReferral == _referral) {\r\n                positionAddress = positions[i].wallet;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getLastUser(\r\n        address _node\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address parentLeft,\r\n            uint256 leftCount,\r\n            address parentRight,\r\n            uint256 rightCount\r\n        )\r\n    {\r\n        parentLeft = _node;\r\n        parentRight = _node;\r\n        leftCount = 0;\r\n        rightCount = 0;\r\n        address currentLeft = positions[pIndex(_node)].leftChild;\r\n        address currentRight = positions[pIndex(_node)].rightChild;\r\n\r\n        while (currentLeft != address(0)) {\r\n            parentLeft = currentLeft;\r\n            leftCount++;\r\n            currentLeft = positions[pIndex(currentLeft)].leftChild;\r\n        }\r\n        while (currentRight != address(0)) {\r\n            parentRight = currentRight;\r\n            rightCount++;\r\n            currentRight = positions[pIndex(currentRight)].rightChild;\r\n        }\r\n    }\r\n\r\n    function getParentSide(\r\n        address _referrer\r\n    ) internal view returns (address, bool) {\r\n        (\r\n            address leftUser,\r\n            uint256 leftCount,\r\n            address rightUser,\r\n            uint256 rightCount\r\n        ) = getLastUser(_referrer);\r\n\r\n        uint8 referralSide = positions[pIndex(_referrer)].referralSide;\r\n        if (referralSide == 0) {\r\n            if (leftCount <= rightCount) {\r\n                return (leftUser, true);\r\n            } else {\r\n                return (rightUser, false);\r\n            }\r\n        } else if (referralSide == 1) {\r\n            return (leftUser, true);\r\n        } else {\r\n            return (rightUser, false);\r\n        }\r\n    }\r\n\r\n    function createReferral() internal returns (uint256 newReferral) {\r\n        newReferral = SafeMath.add(block.timestamp, positions.length);\r\n        while (newReferral == lastReferral) {\r\n            newReferral = SafeMath.add(newReferral, 1);\r\n        }\r\n        lastReferral = newReferral;\r\n    }\r\n\r\n    function addPosition(\r\n        address _wallet,\r\n        address _parentWallet,\r\n        bool _isLeft,\r\n        uint256 _amount\r\n    ) internal {\r\n        positions.push(\r\n            Position({\r\n                wallet: _wallet,\r\n                parent: _parentWallet,\r\n                isLeft: _isLeft,\r\n                charged: _amount,\r\n                referral: createReferral(),\r\n                referralSide: 0,\r\n                leftChild: address(0),\r\n                rightChild: address(0),\r\n                name: \"Unset\",\r\n                lastActivate: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function addChild(\r\n        uint256 _referral,\r\n        address _child,\r\n        uint256 _amount\r\n    ) internal returns (bool done) {\r\n        address referrer = getReferrer(_referral);\r\n        if (referrer != address(0)) {\r\n            (address parent, bool isLeft) = getParentSide(referrer);\r\n            if (isLeft) {\r\n                if (positions[pIndex(parent)].leftChild == address(0)) {\r\n                    positions[pIndex(parent)].leftChild = _child;\r\n                    done = true;\r\n                }\r\n            } else {\r\n                if (positions[pIndex(parent)].rightChild == address(0)) {\r\n                    positions[pIndex(parent)].rightChild = _child;\r\n                    done = true;\r\n                }\r\n            }\r\n            if (done) {\r\n                addPosition(_child, parent, isLeft, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function reportsFun(\r\n        string memory _title,\r\n        address _address,\r\n        uint256 _amount\r\n    ) internal {\r\n        transactions.push(\r\n            Transaction({\r\n                poIndex: pIndex(_address),\r\n                txType: _title,\r\n                amount: _amount,\r\n                time: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function preDistribution(address _address, uint256 _amount) internal {\r\n        bool isLeft = positions[pIndex(_address)].isLeft;\r\n        address parent = positions[pIndex(_address)].parent;\r\n        Deposit memory newDeposit = Deposit({\r\n            pI: pIndex(_address),\r\n            amount: _amount,\r\n            timestamp: block.timestamp\r\n        });\r\n        while (parent != address(0)) {\r\n            uint256 pI = pIndex(parent);\r\n            if (isLeft) {\r\n                leftDeposits[pI].push(newDeposit);\r\n            } else {\r\n                rightDeposits[pI].push(newDeposit);\r\n            }\r\n            positions[pI].lastActivate = block.timestamp;\r\n            isLeft = positions[pI].isLeft;\r\n            parent = positions[pI].parent;\r\n        }\r\n    }\r\n\r\n    function addBalance(uint256 _pIndex, uint256 _amount) internal {\r\n        _balances[_pIndex] = SafeMath.add(_balances[_pIndex], _amount);\r\n    }\r\n\r\n    function subBalance(uint256 _pIndex, uint256 _amount) internal {\r\n        _balances[_pIndex] = SafeMath.sub(_balances[_pIndex], _amount);\r\n    }\r\n\r\n    function addPlansLiquidity(uint256 _amount) internal {\r\n        plan1Liquidity = SafeMath.add(plan1Liquidity, _amount);\r\n        plan2Liquidity = SafeMath.add(plan2Liquidity, _amount);\r\n    }\r\n\r\n    function join(uint256 _referral, uint256 _amount) external payable {\r\n        require(!addressExists(_msgSender()), \"Registered before\");\r\n        require(\r\n            _amount == 101 ether ||\r\n                _amount == 201 ether ||\r\n                _amount == 301 ether ||\r\n                _amount == 401 ether ||\r\n                _amount == 501 ether,\r\n            \"Amount is not enough.\"\r\n        );\r\n        require(\r\n            tether.allowance(_msgSender(), address(this)) >= _amount,\r\n            \"Tether allowance not enough\"\r\n        );\r\n        require(\r\n            tether.balanceOf(_msgSender()) >= _amount,\r\n            \"Insufficient tether balance\"\r\n        );\r\n        tether.transferFrom(_msgSender(), address(this), _amount);\r\n\r\n        uint256 remain = SafeMath.sub(_amount, 1 ether);\r\n\r\n        bool done;\r\n        done = addChild(_referral, _msgSender(), remain);\r\n        if (done) {\r\n            addBalance(3, 1 ether);\r\n            addPlansLiquidity(SafeMath.div(remain, 2));\r\n            preDistribution(_msgSender(), SafeMath.div(remain, 2));\r\n            reportsFun(\"Join\", _msgSender(), remain);\r\n        } else {\r\n            addBalance(myPI(), _amount);\r\n        }\r\n    }\r\n\r\n    function charge(uint256 _amount) external payable {\r\n        require(_amount > 0, \"Zero amount.\");\r\n        require(\r\n            tether.allowance(_msgSender(), address(this)) >= _amount,\r\n            \"Tether allowance not enough\"\r\n        );\r\n        require(\r\n            tether.balanceOf(_msgSender()) >= _amount,\r\n            \"Insufficient tether balance\"\r\n        );\r\n        tether.transferFrom(_msgSender(), address(this), _amount);\r\n        addBalance(myPI(), _amount);\r\n    }\r\n\r\n    function topupAmount(\r\n        uint256 _amount\r\n    ) internal view returns (uint256 chargeAmount) {\r\n        uint256 maxAmount = SafeMath.sub(500 ether, positions[myPI()].charged);\r\n        chargeAmount = _amount;\r\n        if (_amount >= maxAmount) {\r\n            chargeAmount = maxAmount;\r\n        }\r\n    }\r\n\r\n    function topup(uint256 _amount) public {\r\n        require(\r\n            _amount == 100 ether ||\r\n                _amount == 200 ether ||\r\n                _amount == 300 ether ||\r\n                _amount == 400 ether,\r\n            \"Wrong amount.\"\r\n        );\r\n        require(\r\n            _balances[myPI()] >= SafeMath.add(_amount, 1 ether) &&\r\n                positions[myPI()].charged < 500 ether,\r\n            \"Amount is not enough.\"\r\n        );\r\n\r\n        uint256 chargeAmount = topupAmount(_amount);\r\n\r\n        addBalance(3, 1 ether);\r\n        subBalance(myPI(), SafeMath.add(chargeAmount, 1 ether));\r\n        positions[myPI()].charged = SafeMath.add(\r\n            positions[myPI()].charged,\r\n            chargeAmount\r\n        );\r\n        positions[myPI()].lastActivate = block.timestamp;\r\n        addPlansLiquidity(SafeMath.div(chargeAmount, 2));\r\n        preDistribution(_msgSender(), SafeMath.div(chargeAmount, 2));\r\n        reportsFun(\"Topup\", _msgSender(), chargeAmount);\r\n    }\r\n\r\n    //**********************************************************************************\r\n    function getPositionDiagramBalance(\r\n        uint256 _pIndex\r\n    ) public view returns (uint256 thisBalance) {\r\n        uint256 endTime = plan1LastDistribution + 30 days;\r\n\r\n        Deposit[] storage lefts = leftDeposits[_pIndex];\r\n        Deposit[] storage rights = rightDeposits[_pIndex];\r\n\r\n        uint256 leftAmount;\r\n        uint256 rightAmount;\r\n        for (uint256 j = 0; j < lefts.length; j++) {\r\n            if (\r\n                lefts[j].timestamp >= plan1LastDistribution &&\r\n                lefts[j].timestamp < endTime\r\n            ) {\r\n                leftAmount = SafeMath.add(leftAmount, lefts[j].amount);\r\n            }\r\n        }\r\n        for (uint256 k = 0; k < rights.length; k++) {\r\n            if (\r\n                rights[k].timestamp >= plan1LastDistribution &&\r\n                rights[k].timestamp < endTime\r\n            ) {\r\n                rightAmount = SafeMath.add(rightAmount, rights[k].amount);\r\n            }\r\n        }\r\n        thisBalance = leftAmount;\r\n        if (rightAmount < leftAmount) {\r\n            thisBalance = rightAmount;\r\n        }\r\n        thisBalance = SafeMath.div(thisBalance, 100 ether);\r\n    }\r\n\r\n    function getTotalDiagramBalance()\r\n        public\r\n        view\r\n        returns (uint256 totalDiagramBalance)\r\n    {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            uint256 thisBalance = getPositionDiagramBalance(i);\r\n            totalDiagramBalance = SafeMath.add(\r\n                totalDiagramBalance,\r\n                thisBalance\r\n            );\r\n        }\r\n    }\r\n\r\n    function checkCeiling(uint256 _pI) public view returns (uint256 ceilling) {\r\n        uint256 charged = positions[_pI].charged;\r\n        if (charged == 100 ether) {\r\n            ceilling = 15000 ether;\r\n        } else if (charged == 200 ether) {\r\n            ceilling = 30000 ether;\r\n        } else {\r\n            ceilling = 60000 ether;\r\n        }\r\n    }\r\n\r\n    function recivedCommission(\r\n        uint256 _pI\r\n    ) public view returns (uint256 recived) {\r\n        Commission[] storage com = commissions[_pI];\r\n        for (uint i = 0; i < com.length; i++) {\r\n            if (\r\n                com[i].timestamp >= plan1LastDistribution &&\r\n                com[i].timestamp < plan1LastDistribution + 30 days\r\n            ) {\r\n                recived = SafeMath.add(recived, com[i].amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function sendPlan1Commission(uint256 _pI, uint256 _commission) internal {\r\n        commissions[_pI].push(\r\n            Commission({\r\n                amount: _commission,\r\n                timestamp: plan1LastDistribution + 30 days - 1\r\n            })\r\n        );\r\n        addBalance(_pI, _commission);\r\n        reportsFun(\"Plan 1 Commission\", positions[_pI].wallet, _commission);\r\n    }\r\n\r\n    function getTotalPlan2() public view returns (uint256 totalPlan2) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (\r\n                SafeMath.sub(\r\n                    positions[i].lastActivate,\r\n                    SafeMath.sub(plan2LastDistribution, 52.5 * 1 days)\r\n                ) >=\r\n                0 ||\r\n                positions[i].charged == 500 ether\r\n            ) {\r\n                totalPlan2 = SafeMath.add(totalPlan2, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function positionPlan2(\r\n        uint256 _pI\r\n    ) public view returns (bool can, uint256 maxRecive) {\r\n        if (\r\n            SafeMath.sub(\r\n                positions[_pI].lastActivate,\r\n                SafeMath.sub(plan2LastDistribution, 52.5 * 1 days)\r\n            ) >=\r\n            0 ||\r\n            positions[_pI].charged == 500 ether\r\n        ) {\r\n            uint256 ceiling = checkCeiling(_pI);\r\n            uint256 recived = recivedCommission(_pI);\r\n            if (recived < ceiling) {\r\n                can = true;\r\n                maxRecive = SafeMath.sub(ceiling, recived);\r\n            } else {\r\n                maxRecive = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function sendPlan2Commission(uint256 _pI, uint256 _commission) internal {\r\n        commissions[_pI].push(\r\n            Commission({\r\n                amount: _commission,\r\n                timestamp: plan2LastDistribution + 7.5 * 1 days - 1\r\n            })\r\n        );\r\n\r\n        uint256 tokenAmount = commissionToken(\r\n            positions[_pI].wallet,\r\n            _commission\r\n        );\r\n\r\n        _userTokenCharge[_pI] = SafeMath.add(\r\n            _userTokenCharge[_pI],\r\n            tokenAmount\r\n        );\r\n        reportsFun(\"Plan2 DWB Commission\", positions[_pI].wallet, tokenAmount);\r\n\r\n        uint256 pureCommission = SafeMath.sub(_commission, tokenAmount);\r\n\r\n        addBalance(_pI, pureCommission);\r\n        reportsFun(\"Plan2 Commission\", positions[_pI].wallet, pureCommission);\r\n    }\r\n\r\n    function commissionToken(\r\n        address _address,\r\n        uint256 _amount\r\n    ) internal view returns (uint256 tokenAmount) {\r\n        uint256 pI = pIndex(_address);\r\n        uint256 thisCommissionTokenFee = tokenPercent;\r\n        if (_userTokenPercent[pI] > tokenPercent) {\r\n            thisCommissionTokenFee = _userTokenPercent[pI];\r\n        }\r\n        tokenAmount = SafeMath.div(\r\n            SafeMath.mul(_amount, thisCommissionTokenFee),\r\n            100\r\n        );\r\n    }\r\n\r\n    function distributionP2() internal {\r\n        if (plan2Liquidity != 0 && getTotalPlan2() != 0) {\r\n            uint256 perPerson = SafeMath.div(plan2Liquidity, getTotalPlan2());\r\n            uint256 totalCom;\r\n            for (uint256 i = 0; i < positions.length; i++) {\r\n                (bool can, uint256 maxRecive) = positionPlan2(i);\r\n                if (can) {\r\n                    uint256 thisCom = perPerson;\r\n                    if (perPerson > maxRecive) {\r\n                        thisCom = maxRecive;\r\n                    }\r\n                    sendPlan2Commission(i, thisCom);\r\n                    totalCom = SafeMath.add(totalCom, thisCom);\r\n                }\r\n            }\r\n            plan2Liquidity = SafeMath.sub(plan2Liquidity, totalCom);\r\n        }\r\n        plan2LastDistribution = SafeMath.add(\r\n            plan2LastDistribution,\r\n            7.5 * 1 days\r\n        );\r\n    }\r\n\r\n    function distributionP1() internal {\r\n        if (plan1Liquidity != 0 && getTotalDiagramBalance() != 0) {\r\n            uint256 perBalance = SafeMath.div(\r\n                plan1Liquidity,\r\n                getTotalDiagramBalance()\r\n            );\r\n            uint256 totalCom;\r\n            for (uint256 i = 0; i < positions.length; i++) {\r\n                uint256 balance = getPositionDiagramBalance(i);\r\n\r\n                if (balance != 0) {\r\n                    uint256 commission = SafeMath.mul(balance, perBalance);\r\n                    uint256 ceiling = checkCeiling(i);\r\n                    uint256 recived = recivedCommission(i);\r\n\r\n                    if (recived < ceiling) {\r\n                        uint256 thisCom = commission;\r\n                        if (SafeMath.add(recived, commission) > ceiling) {\r\n                            thisCom = SafeMath.sub(ceiling, recived);\r\n                        }\r\n                        sendPlan1Commission(i, thisCom);\r\n                        totalCom = SafeMath.add(totalCom, thisCom);\r\n                    }\r\n                }\r\n            }\r\n            plan1Liquidity = SafeMath.sub(plan1Liquidity, totalCom);\r\n        }\r\n        plan1LastDistribution = SafeMath.add(plan1LastDistribution, 30 days);\r\n    }\r\n\r\n    function distribution() public {\r\n        if (block.timestamp >= plan2LastDistribution + 7.5 * 1 days) {\r\n            distributionP2();\r\n        }\r\n        if (block.timestamp >= plan1LastDistribution + 30 days) {\r\n            distributionP1();\r\n        }\r\n    }\r\n\r\n    // **********************************\r\n    // User Setting\r\n    // **********************************\r\n\r\n    function setName(string memory _newName) public {\r\n        positions[myPI()].name = _newName;\r\n    }\r\n\r\n    function changePositionWallet(address _newWallet) public {\r\n        require(addressExists(_msgSender()), \"Not registered\");\r\n        require(!addressExists(_newWallet), \"Address exists\");\r\n        positions[myPI()].wallet = _newWallet;\r\n        address parent = positions[myPI()].parent;\r\n        bool isLeft = positions[myPI()].isLeft;\r\n        if (isLeft) {\r\n            positions[pIndex(parent)].leftChild = _newWallet;\r\n        } else {\r\n            positions[pIndex(parent)].rightChild = _newWallet;\r\n        }\r\n        address leftChild = positions[myPI()].leftChild;\r\n        address rightChild = positions[myPI()].rightChild;\r\n        positions[pIndex(leftChild)].parent = _newWallet;\r\n        positions[pIndex(rightChild)].parent = _newWallet;\r\n    }\r\n\r\n    function setReferralSide(uint8 _newSide) public {\r\n        require(_newSide == 0 || _newSide == 1 || _newSide == 2, \"Wrong side.\");\r\n        positions[myPI()].referralSide = _newSide;\r\n    }\r\n\r\n    function setUserTokenPercent(uint8 _newPercent) public {\r\n        require(\r\n            _newPercent >= tokenPercent,\r\n            \"Percent should be >= tokenPercent.\"\r\n        );\r\n        require(_newPercent <= 100, \"Token percent should be <= plan2Percent.\");\r\n        _userTokenPercent[myPI()] = _newPercent;\r\n    }\r\n\r\n    // **********************************\r\n    // Withdraw Tether\r\n    // **********************************\r\n    function withdraw(uint256 _amount) public {\r\n        // _amount is Tether\r\n        require(_amount > 0, \"Zero?\");\r\n        if (myPI() != 0 && myPI() != 1 && myPI() != 2) {\r\n            // Users\r\n            require(_balances[myPI()] >= _amount, \"Insufficient balance.\");\r\n            _balances[myPI()] = SafeMath.sub(_balances[myPI()], _amount);\r\n            require(\r\n                tether.transfer(_msgSender(), _amount),\r\n                \"Tether transfer failed\"\r\n            );\r\n            reportsFun(\"Withdraw\", _msgSender(), _amount);\r\n            buyToken(_msgSender(), _userTokenCharge[myPI()]);\r\n        } else {\r\n            // Owners\r\n            uint256 totalTokenCharg = SafeMath.add(\r\n                _userTokenCharge[0],\r\n                SafeMath.add(_userTokenCharge[1], _userTokenCharge[2])\r\n            );\r\n            if (totalTokenCharg > 0) {\r\n                buyToken(positions[0].wallet, SafeMath.div(totalTokenCharg, 3));\r\n                buyToken(positions[1].wallet, SafeMath.div(totalTokenCharg, 3));\r\n                buyToken(positions[2].wallet, SafeMath.div(totalTokenCharg, 3));\r\n            }\r\n            uint256 totalAmount = SafeMath.add(\r\n                _balances[0],\r\n                SafeMath.add(_balances[1], _balances[2])\r\n            );\r\n            if (totalAmount > 0) {\r\n                _balances[0] = _balances[1] = _balances[2] = 0;\r\n                uint256 per = SafeMath.div(totalAmount, 3);\r\n                require(\r\n                    tether.transfer(positions[0].wallet, per),\r\n                    \"Tether transfer failed\"\r\n                );\r\n                require(\r\n                    tether.transfer(positions[1].wallet, per),\r\n                    \"Tether transfer failed\"\r\n                );\r\n                require(\r\n                    tether.transfer(positions[2].wallet, per),\r\n                    \"Tether transfer failed\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyToken(address _address, uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            uint256 pI = pIndex(_address);\r\n            tether.approve(dwbTokenAddress, _amount);\r\n            (bool success, ) = address(dwbTokenAddress).call(\r\n                abi.encodeWithSignature(\r\n                    \"buy(address,uint256)\",\r\n                    _address,\r\n                    _amount\r\n                )\r\n            );\r\n            if (success) {\r\n                _userTokenCharge[pI] = 0;\r\n                reportsFun(\"Withdraw DWB\", _address, _amount);\r\n            } else {\r\n                _balances[pI] = SafeMath.add(_balances[pI], _amount);\r\n                reportsFun(\r\n                    \"Unsuccessful token purchase refund\",\r\n                    _address,\r\n                    _amount\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // **********************************\r\n    // Get Public Data\r\n    // **********************************\r\n\r\n    function getDeposits(\r\n        address _wallet\r\n    ) public view returns (Deposit[] memory, Deposit[] memory) {\r\n        return (leftDeposits[pIndex(_wallet)], rightDeposits[pIndex(_wallet)]);\r\n    }\r\n\r\n    function getPositions() public view returns (Position[] memory) {\r\n        return positions;\r\n    }\r\n\r\n    function getPositionIndex(address _wallet) public view returns (uint256) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _wallet) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getPositionByWallet(\r\n        address _wallet\r\n    ) public view returns (uint256, Position memory) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _wallet) {\r\n                return (i, positions[i]);\r\n            }\r\n        }\r\n        return (0, positions[0]);\r\n    }\r\n\r\n    function getPositionById(\r\n        uint256 _pI\r\n    ) public view returns (Position memory) {\r\n        return positions[_pI];\r\n    }\r\n\r\n    function getTransactions() public view returns (Transaction[] memory) {\r\n        return transactions;\r\n    }\r\n\r\n    function getPositionTransactions(\r\n        uint256 _pI\r\n    ) public view returns (Transaction[] memory) {\r\n        Transaction[] memory positionTransactions = new Transaction[](\r\n            transactions.length + 1\r\n        );\r\n        for (uint i = 0; i < transactions.length; i++) {\r\n            if (transactions[i].poIndex == _pI) {\r\n                positionTransactions[i] = transactions[i];\r\n            }\r\n        }\r\n        return positionTransactions;\r\n    }\r\n}\r\n// File: contracts/ICO.sol\r\n\r\n\r\n\r\npragma solidity 0.8.18;\r\n\r\n\r\ncontract ICO is WorkAccurate {\r\n    // ICO\r\n    function startICO(uint256 _amount) public payable {\r\n        // _amount is DWB Token\r\n        require(addressExists(_msgSender()), \"Not registered\");\r\n        require(_amount > 0, \"Zero?\");\r\n        require(_amount % accurateSharePrice == 0, \"Amount % SharePrice != 0\");\r\n\r\n        // Do not accept extra amount.\r\n        uint256 share = SafeMath.div(_amount, accurateSharePrice);\r\n\r\n        require(\r\n            _accurateShareBalances[0] >= share,\r\n            \"Insufficient Owner share!\"\r\n        );\r\n\r\n        require(\r\n            token.allowance(_msgSender(), address(this)) >=\r\n                SafeMath.div(SafeMath.mul(_amount, 102), 100),\r\n            \"Allowance not enough\"\r\n        );\r\n        require(\r\n            token.balanceOf(_msgSender()) >=\r\n                SafeMath.div(SafeMath.mul(_amount, 102), 100),\r\n            \"Insufficient balance\"\r\n        );\r\n\r\n        token.transferFrom(_msgSender(), address(this), _amount);\r\n\r\n        uint256 recivedAmount = SafeMath.div(SafeMath.mul(_amount, 99), 100);\r\n\r\n        distributionICO(recivedAmount);\r\n        signICO(share);\r\n    }\r\n\r\n    function distributionICO(uint256 _recivedAmount) private {\r\n        address current = positions[myPI()].parent;\r\n        uint i = 0;\r\n        uint256 parentShare = SafeMath.div(\r\n            SafeMath.mul(_recivedAmount, 5),\r\n            100\r\n        );\r\n        uint256 paidAmount;\r\n        while (current != address(0) && i < 3) {\r\n            require(\r\n                token.transfer(current, parentShare),\r\n                \"Parent DWB transfer failed\"\r\n            );\r\n            reportsFun(\"ICO Share\", current, parentShare);\r\n            paidAmount = SafeMath.add(\r\n                paidAmount,\r\n                SafeMath.div(SafeMath.mul(parentShare, 102), 100)\r\n            );\r\n            current = positions[pIndex(current)].parent;\r\n            i++;\r\n        }\r\n        uint256 ownerAmount = SafeMath.sub(_recivedAmount, paidAmount);\r\n        require(\r\n            token.transfer(\r\n                positions[0].wallet,\r\n                SafeMath.div(SafeMath.mul(ownerAmount, 100), 102)\r\n            ),\r\n            \"Owner DWB transfer failed\"\r\n        );\r\n        reportsFun(\"ICO Share\", positions[0].wallet, ownerAmount);\r\n    }\r\n\r\n    function signICO(uint256 _share) private {\r\n        _accurateShareBalances[myPI()] = SafeMath.add(\r\n            _accurateShareBalances[myPI()],\r\n            _share\r\n        );\r\n        reportsFun(\"Buy ICO\", _msgSender(), _share);\r\n        _accurateShareBalances[0] = SafeMath.sub(\r\n            _accurateShareBalances[0],\r\n            _share\r\n        );\r\n        reportsFun(\"Sell ICO\", positions[0].wallet, _share);\r\n    }\r\n\r\n    function transferICO(uint256 _amount, address recipient) public {\r\n        require(recipient != address(0), \"Mint to the zero\");\r\n        require(addressExists(recipient), \"Not registered.\");\r\n        require(_amount > 0, \"Zero?\");\r\n        require(_accurateShareBalances[myPI()] >= _amount, \"\");\r\n\r\n        _accurateShareBalances[myPI()] = SafeMath.sub(\r\n            _accurateShareBalances[myPI()],\r\n            _amount\r\n        );\r\n        reportsFun(\"Transfer Out ICO\", _msgSender(), _amount);\r\n        _accurateShareBalances[pIndex(recipient)] = SafeMath.add(\r\n            _accurateShareBalances[pIndex(recipient)],\r\n            _amount\r\n        );\r\n        reportsFun(\"Transfer In ICO\", recipient, _amount);\r\n    }\r\n\r\n    function getICOBalances()\r\n        public\r\n        view\r\n        returns (address[] memory addresses, uint256[] memory balances)\r\n    {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            address wallet = positions[i].wallet;\r\n            uint256 balance = _accurateShareBalances[pIndex(wallet)];\r\n            if (balance > 0) {\r\n                addresses = pushAddress(addresses, wallet);\r\n                balances = pushUint(balances, balance);\r\n            }\r\n        }\r\n        return (addresses, balances);\r\n    }\r\n\r\n    //Add projects Profit to liquidity\r\n    function projectsProfit(uint256 _amount) public payable {\r\n        // _amount is Tether\r\n        require(_amount > 0, \"zero?\");\r\n        require(\r\n            tether.allowance(_msgSender(), address(this)) >= _amount,\r\n            \"Tether allowance not enough\"\r\n        );\r\n        require(\r\n            tether.balanceOf(_msgSender()) >= _amount,\r\n            \"Insufficient tether balance\"\r\n        );\r\n        tether.transferFrom(_msgSender(), address(this), _amount);\r\n\r\n        uint256 thisShare = SafeMath.div(SafeMath.mul(_amount, 80), 100);\r\n        uint256 liquidityShare = SafeMath.div(SafeMath.mul(_amount, 20), 100);\r\n\r\n        (\r\n            address[] memory addresses,\r\n            uint256[] memory balances\r\n        ) = getICOBalances();\r\n\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            address wallet = addresses[i];\r\n            uint256 balance = balances[i];\r\n            uint256 walletShare = SafeMath.mul(\r\n                SafeMath.div(balance, accurateShare),\r\n                thisShare\r\n            );\r\n            _balances[pIndex(wallet)] = SafeMath.add(\r\n                _balances[pIndex(wallet)],\r\n                walletShare\r\n            );\r\n            reportsFun(\"ICO: Project Profit\", wallet, walletShare);\r\n        }\r\n\r\n        addTokenLiquidity(liquidityShare);\r\n    }\r\n\r\n    function addTokenLiquidity(uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            tether.approve(dwbTokenAddress, _amount);\r\n            (bool success, ) = address(dwbTokenAddress).call(\r\n                abi.encodeWithSignature(\"addLiquidity(uint256)\", _amount)\r\n            );\r\n            if (!success) {\r\n                _balances[0] = SafeMath.add(_balances[0], _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function pushAddress(\r\n        address[] memory array,\r\n        address newValue\r\n    ) internal pure returns (address[] memory) {\r\n        address[] memory newArray = new address[](array.length + 1);\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            newArray[i] = array[i];\r\n        }\r\n        newArray[array.length] = newValue;\r\n        return newArray;\r\n    }\r\n\r\n    function pushUint(\r\n        uint256[] memory array,\r\n        uint256 newValue\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256[] memory newArray = new uint256[](array.length + 1);\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            newArray[i] = array[i];\r\n        }\r\n        newArray[array.length] = newValue;\r\n        return newArray;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_accurateShareBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userTokenCharge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userTokenPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accurateShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accurateSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addressExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"changePositionWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"charge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"checkCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ceilling\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dwbTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getICOBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"getPositionById\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"leftChild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightChild\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getPositionByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"leftChild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightChild\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pIndex\",\"type\":\"uint256\"}],\"name\":\"getPositionDiagramBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"thisBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getPositionIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"getPositionTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"txType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"leftChild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightChild\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDiagramBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDiagramBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPlan2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPlan2\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"txType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"leftDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1LastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1Percent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2LastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2Percent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"positionPlan2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxRecive\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"leftChild\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rightChild\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"projectsProfit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"recivedCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"recived\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rightDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newSide\",\"type\":\"uint8\"}],\"name\":\"setReferralSide\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newPercent\",\"type\":\"uint8\"}],\"name\":\"setUserTokenPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"startICO\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tether\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"topup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"txType\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ICO", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://726fdebb509927b321a4cd87468b64d35726ec264971f5dc3ff60d03a9796cea"}