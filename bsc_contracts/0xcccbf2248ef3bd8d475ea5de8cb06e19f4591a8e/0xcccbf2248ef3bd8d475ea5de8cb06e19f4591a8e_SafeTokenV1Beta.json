{"SourceCode": "{\"goldenwspp.sol\":{\"content\":\"/**\\r\\n * Safetoken Fork (added Antiwhale, Antibot, Antidump Fuction) thx to 0f0crypto for a Safetoken rewrite!\\r\\n * \\r\\n * SPDX-License-Identifier: MIT\\r\\n */\\r\\n \\r\\n /**\\r\\n  * \\r\\n  * Super Low Liquidity Token\\r\\n  * \\r\\n\ud83d\udc8eMigration WSPP to Golden WSPP\\r\\n\u2705 Total Supply : 50.000.000\\r\\n\u2705 Initial Liquidity : 50 BNB\\r\\n\u2705 Burn when release 60%\\r\\n\\r\\n\ud83d\udc8e Fee:\\r\\n\u2705 4% Liquidity\\r\\n\u2705 4% Redistribution\\r\\n\u2705 1% Burn           \\r\\n\u2705 0,1% Tip to the Dev\\r\\n\u2705 5% Whale Only Fee (Only when your balance is \\u003e capWhaleWalletBalance)\\r\\n\u2705 Max Transaction : 2% From Total Supply (1.000.000)\\r\\n\u2705 Max Wallet Balance : 3 times Max Transaction (3.000.000)\\r\\n\\r\\n\ud83d\udc8e AntiWhale\\r\\n\u2705 CapWhaleWalletBalance : 80% From Max Wallet Balance (Balance \\u003e 24,000,000)\\r\\n\\r\\n\ud83d\udc8e AntiBot and Dump\\r\\n\u2705 15 seconds between each transaction per wallet.\\r\\n\u2705 Cant send multiple transaction in one block per wallet.\\r\\n\\r\\n\ud83d\udc8e AntiDump\\r\\n\u2705 Fee Multiplier after release only sell\\r\\n\u2705 x2 in 24 hours after released\\r\\n\u2705 x1 after 24 hours after released\\r\\n\\r\\n\ud83d\udc8e Security\\r\\n\u2705 LP Lock\\r\\n\\r\\nTG: https://t.me/robowolfproject\\r\\nTW: https://twitter.com/robowolf8\\r\\n\\r\\n */\\r\\n \\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n\\r\\n\\r\\nimport \\\"./safetoken-imports.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev If I did a good job you should not need to change anything apart from the values in the `Tokenomics`,\\r\\n * the actual name of the contract `SafeTokenV1Beta` at the very bottom **and** the `environment` into which\\r\\n * you are deploying the contract `SafeToken(Env.Testnet)` or `SafeToken(Env.MainnetV2)` etc.\\r\\n * \\r\\n * If you wish to disable a particular tax/fee just set it to zero (or comment it out/remove it).\\r\\n * \\r\\n * You can add (in theory) as many custom taxes/fees with dedicated wallet addresses if you want. \\r\\n * Nevertheless, I do not recommend using more than a few as the contract has not been tested \\r\\n * for more than the original number of taxes/fees, which is 6 (liquidity, redistribution, burn, \\r\\n * marketing, charity \\u0026 tip to the dev). Furthermore, exchanges may impose a limit on the total\\r\\n * transaction fee (so that, for example, you cannot claim 100%). Usually this is done by limiting the \\r\\n * max value of slippage, for example, PancakeSwap max slippage is 49.9% and the fees total of more than\\r\\n * 35% will most likely fail there.\\r\\n * \\r\\n * NOTE: You shouldn\\u0027t really remove the Rfi fee. If you do not wish to use RFI for your token, \\r\\n * you shouldn\\u0027t be using this contract at all (you\\u0027re just wasting gas if you do).\\r\\n *\\r\\n * NOTE: ignore the note below (anti-whale mech is not implemented yet)\\r\\n * If you wish to modify the anti-whale mech (progressive taxation) it will require a bit of coding. \\r\\n * I tried to make the integration as simple as possible via the `Antiwhale` contract, so the devs \\r\\n * know exactly where to look and what/how to make the necessary changes. There are many possibilites,\\r\\n * such as modifying the fees based on the tx amount (as % of TOTAL_SUPPLY), or sender\\u0027s wallet balance \\r\\n * (as % of TOTAL_SUPPLY), including (but not limited to):\\r\\n * - progressive taxation by tax brackets (e.g \\u003c1%, 1-2%, 2-5%, 5-10%)\\r\\n * - progressive taxation by the % over a threshold (e.g. 1%)\\r\\n * - extra fee (e.g. double) over a threshold \\r\\n */\\r\\nabstract contract Tokenomics {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    // --------------------- Token Settings ------------------- //\\r\\n\\r\\n    string internal constant NAME = \\\"GoldenWspp\\\";\\r\\n    string internal constant SYMBOL = \\\"GWSPP\\\";\\r\\n    \\r\\n    uint16 internal constant FEES_DIVISOR = 10**3;\\r\\n    uint8 internal constant DECIMALS = 6;\\r\\n    uint256 internal constant ZEROES = 10**DECIMALS;\\r\\n    \\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n    uint256 internal constant TOTAL_SUPPLY = 5 * 10 ** 7 * ZEROES;\\r\\n    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\\r\\n    \\r\\n    uint internal TIME_LIMIT_TRANSACTION = 15 seconds;\\r\\n    uint internal TimeContractStart = block.timestamp;\\r\\n    bool internal ANTI_DUMP_MULTIPLAYER = true;\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the maximum transaction amount allowed in a transfer.\\r\\n     * \\r\\n     * The default value is 1% of the total supply. \\r\\n     * \\r\\n     * NOTE: set the value to `TOTAL_SUPPLY` to have an unlimited max, i.e.\\r\\n     * `maxTransactionAmount = TOTAL_SUPPLY;`\\r\\n     */\\r\\n    uint256 internal constant maxTransactionAmount = (TOTAL_SUPPLY / 100); // 2% of the total supply\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the maximum allowed balance in a wallet.\\r\\n     * \\r\\n     * The default value is 2% of the total supply. \\r\\n     * \\r\\n     * NOTE: set the value to 0 to have an unlimited max.\\r\\n     *\\r\\n     * IMPORTANT: This value MUST be greater than `numberOfTokensToSwapToLiquidity` set below,\\r\\n     * otherwise the liquidity swap will never be executed\\r\\n     */\\r\\n    uint256 internal maxWalletBalance = maxTransactionAmount * 3; // 10 * maxTransactionAmount\\r\\n\\r\\n    /**\\r\\n     * @dev Set the Cap balance in a wallet to identification Whale.\\r\\n     * \\r\\n     * The default value is 75% of the maxWalletBalance. \\r\\n     * \\r\\n     * NOTE: set the value to maxWalletBalance to disable.\\r\\n     *\\r\\n     * IMPORTANT: This value MUST be greater than `numberOfTokensToSwapToLiquidity` set below,\\r\\n     * otherwise the liquidity swap will never be executed\\r\\n     */\\r\\n     uint16 internal constant WHALE_FEE_IN_PERCENT = 50;\\r\\n     uint256 internal capWhaleWalletBalance = (80 * maxWalletBalance) / 100; // 80% of the maxWalletBalance\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the number of tokens to swap and add to liquidity. \\r\\n     * \\r\\n     * Whenever the contract\\u0027s balance reaches this number of tokens, swap \\u0026 liquify will be \\r\\n     * executed in the very next transfer (via the `_beforeTokenTransfer`)\\r\\n     * \\r\\n     * If the `FeeType.Liquidity` is enabled in `FeesSettings`, the given % of each transaction will be first\\r\\n     * sent to the contract address. Once the contract\\u0027s balance reaches `numberOfTokensToSwapToLiquidity` the\\r\\n     * `swapAndLiquify` of `Liquifier` will be executed. Half of the tokens will be swapped for ETH \\r\\n     * (or BNB on BSC) and together with the other half converted into a Token-ETH/Token-BNB LP Token.\\r\\n     * \\r\\n     * See: `Liquifier`\\r\\n     */\\r\\n    uint256 internal constant numberOfTokensToSwapToLiquidity = TOTAL_SUPPLY / 1000; // 0.1% of the total supply\\r\\n\\r\\n    // --------------------- Fees Settings ------------------- //\\r\\n\\r\\n    /**\\r\\n     * @dev To add/edit/remove fees scroll down to the `addFees` function below\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev You can change the value of the burn address to pretty much anything\\r\\n     * that\\u0027s (clearly) a non-random address, i.e. for which the probability of \\r\\n     * someone having the private key is (virtually) 0. For example, 0x00.....1, \\r\\n     * 0x111...111, 0x12345.....12345, etc.\\r\\n     *\\r\\n     * NOTE: This does NOT need to be the zero address, adress(0) = 0x000...000;\\r\\n     *\\r\\n     * Trasfering tokens to the burn address is good for optics/marketing. Nevertheless\\r\\n     * if the burn address is excluded from rewards (unlike in Safemoon), sending tokens\\r\\n     * to the burn address actually improves redistribution to holders (as they will\\r\\n     * have a larger % of tokens in non-excluded accounts)\\r\\n     *\\r\\n     * p.s. the address below is the speed of light in vacuum in m/s (expressed in decimals),\\r\\n     * the hex value is 0x0000000000000000000000000000000011dE784A; :)\\r\\n     *\\r\\n     * Here are the values of some other fundamental constants to use:\\r\\n     * 0x0000000000000000000000000000000602214076 (Avogardo constant)\\r\\n     * 0x0000000000000000000000000000000001380649 (Boltzmann constant)\\r\\n     * 0x2718281828459045235360287471352662497757 (e)\\r\\n     * 0x0000000000000000000000000000001602176634 (elementary charge)\\r\\n     * 0x0000000000000000000000000200231930436256 (electron g-factor)\\r\\n     * 0x0000000000000000000000000000091093837015 (electron mass)\\r\\n     * 0x0000000000000000000000000000137035999084 (fine structure constant)\\r\\n     * 0x0577215664901532860606512090082402431042 (Euler-Mascheroni constant)\\r\\n     * 0x1618033988749894848204586834365638117720 (golden ratio)\\r\\n     * 0x0000000000000000000000000000009192631770 (hyperfine transition fq)\\r\\n     * 0x0000000000000000000000000000010011659208 (muom g-2)\\r\\n     * 0x3141592653589793238462643383279502884197 (pi)\\r\\n     * 0x0000000000000000000000000000000662607015 (Planck\\u0027s constant)\\r\\n     * 0x0000000000000000000000000000001054571817 (reduced Planck\\u0027s constant)\\r\\n     * 0x1414213562373095048801688724209698078569 (sqrt(2))\\r\\n     */\\r\\n    address internal burnAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    /**\\r\\n     * @dev You can disable this but if you feel generous I\\u0027d appreciate the 0.1%\\r\\n     * donation for rewriting Safemoon and making everyone\\u0027s life a little easier\\r\\n     *\\r\\n     * If you keep this tip enabled, let me know in Discord: https://discord.gg/zn86MDCQcM\\r\\n     * and you\\u0027ll be added to the partners section to promote your token. \\r\\n     */\\r\\n    address internal tipToTheDev = 0xc55A7183F6D060271010A4441c106f6a81D46E34;\\r\\n\\r\\n    enum FeeType { Antiwhale, Burn, Liquidity, Rfi, External, ExternalToETH }\\r\\n    struct Fee {\\r\\n        FeeType name;\\r\\n        uint256 value;\\r\\n        address recipient;\\r\\n        uint256 total;\\r\\n    }\\r\\n\\r\\n    Fee[] internal fees;\\r\\n    uint256 internal sumOfFees;\\r\\n\\r\\n    constructor() {\\r\\n        _addFees();\\r\\n    }\\r\\n\\r\\n    function _addFee(FeeType name, uint256 value, address recipient) private {\\r\\n        fees.push( Fee(name, value, recipient, 0 ) );\\r\\n        sumOfFees += value;\\r\\n    }\\r\\n\\r\\n    function _addFees() private {\\r\\n\\r\\n        /**\\r\\n         * The RFI recipient is ignored but we need to give a valid address value\\r\\n         *\\r\\n         * CAUTION: If you don\\u0027t want to use RFI this implementation isn\\u0027t really for you!\\r\\n         *      There are much more efficient and cleaner token contracts without RFI \\r\\n         *      so you should use one of those\\r\\n         *\\r\\n         * The value of fees is given in part per 1000 (based on the value of FEES_DIVISOR),\\r\\n         * e.g. for 5% use 50, for 3.5% use 35, etc. \\r\\n         */ \\r\\n        _addFee(FeeType.Rfi, 40, address(this) ); // 4% Redistribute to holders\\r\\n        _addFee(FeeType.Burn, 10, burnAddress ); // 1% Burn\\r\\n        _addFee(FeeType.Liquidity, 40, address(this) ); // 4% added to liquidity\\r\\n        _addFee(FeeType.ExternalToETH, 10, tipToTheDev ); // 0.1% Tips to the Dev\\r\\n        _addFee(FeeType.Antiwhale, WHALE_FEE_IN_PERCENT, tipToTheDev ); // 5% if you have balance more than capWhaleWalletBalance\\r\\n        \\r\\n    }\\r\\n\\r\\n    function _getFeesCount() internal view returns (uint256){ return fees.length; }\\r\\n\\r\\n    function _getFeeStruct(uint256 index) private view returns(Fee storage){\\r\\n        require( index \\u003e= 0 \\u0026\\u0026 index \\u003c fees.length, \\\"FeesSettings._getFeeStruct: Fee index out of bounds\\\");\\r\\n        return fees[index];\\r\\n    }\\r\\n    function _getFee(uint256 index) internal view returns (FeeType, uint256, address, uint256){\\r\\n        Fee memory fee = _getFeeStruct(index);\\r\\n        return ( fee.name, fee.value, fee.recipient, fee.total );\\r\\n    }\\r\\n    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\\r\\n        Fee storage fee = _getFeeStruct(index);\\r\\n        fee.total = fee.total.add(amount);\\r\\n    }\\r\\n\\r\\n    // function getCollectedFeeTotal(uint256 index) external view returns (uint256){\\r\\n    function getCollectedFeeTotal(uint256 index) internal view returns (uint256){\\r\\n        Fee memory fee = _getFeeStruct(index);\\r\\n        return fee.total;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Presaleable is Manageable {\\r\\n    bool internal isInPresale;\\r\\n    function setPreseableEnabled(bool value) external onlyManager {\\r\\n        isInPresale = value;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract BaseRfiToken is IERC20, IERC20Metadata, Ownable, Presaleable, Tokenomics {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _reflectedBalances;\\r\\n    mapping (address =\\u003e uint256) internal _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\r\\n    \\r\\n    mapping (address =\\u003e bool) internal _isExcludedFromFee;\\r\\n    mapping (address =\\u003e bool) internal _isExcludedFromRewards;\\r\\n    address[] private _excluded;\\r\\n    \\r\\n    constructor() {\\r\\n        \\r\\n        _reflectedBalances[owner()] = _reflectedSupply;\\r\\n        \\r\\n        // exclude owner and this contract from fee\\r\\n        _isExcludedFromFee[owner()] = true;\\r\\n        _isExcludedFromFee[address(this)] = true;\\r\\n        \\r\\n        // exclude the owner and this contract from rewards\\r\\n        _exclude(owner());\\r\\n        _exclude(address(this));\\r\\n\\r\\n        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    /** Functions required by IERC20Metadat **/\\r\\n        function name() external pure override returns (string memory) { return NAME; }\\r\\n        function symbol() external pure override returns (string memory) { return SYMBOL; }\\r\\n        function decimals() external pure override returns (uint8) { return DECIMALS; }\\r\\n        \\r\\n    /** Functions required by IERC20Metadat - END **/\\r\\n    /** Functions required by IERC20 **/\\r\\n        function totalSupply() external pure override returns (uint256) {\\r\\n            return TOTAL_SUPPLY;\\r\\n        }\\r\\n        \\r\\n        function balanceOf(address account) public view override returns (uint256){\\r\\n            if (_isExcludedFromRewards[account]) return _balances[account];\\r\\n            return tokenFromReflection(_reflectedBalances[account]);\\r\\n        }\\r\\n        \\r\\n        function transfer(address recipient, uint256 amount) external override returns (bool){\\r\\n            _transfer(_msgSender(), recipient, amount);\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        function allowance(address owner, address spender) external view override returns (uint256){\\r\\n            return _allowances[owner][spender];\\r\\n        }\\r\\n    \\r\\n        function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n            _approve(_msgSender(), spender, amount);\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        function getAddressLastTransaction(address owner ) external view returns(uint)\\r\\n        {\\r\\n            return _getLastTransaction(owner);\\r\\n        }\\r\\n        \\r\\n        function getContractStartTime() external view returns(uint){\\r\\n            return TimeContractStart;\\r\\n        }\\r\\n        \\r\\n        function setTimeLimitTransaction(uint inSecond) external onlyManager{\\r\\n            TIME_LIMIT_TRANSACTION = inSecond;\\r\\n        }\\r\\n        \\r\\n        function getTimeLimitTransaction() external view returns(uint) {\\r\\n            return TIME_LIMIT_TRANSACTION;\\r\\n        }\\r\\n        \\r\\n        function setMaxWalletBalance(uint256 amount) external onlyManager{\\r\\n            maxWalletBalance = amount;\\r\\n        }\\r\\n        \\r\\n        function getMaxWalletBalance() external view returns(uint256)\\r\\n        {\\r\\n            return maxWalletBalance;\\r\\n        }\\r\\n        \\r\\n        function setCapWhaleWalletBalance(uint256 amount) external onlyManager{\\r\\n            capWhaleWalletBalance = amount;\\r\\n        }\\r\\n        \\r\\n        function getCapWhaleWalletBalance() external view returns(uint256)\\r\\n        {\\r\\n            return capWhaleWalletBalance;\\r\\n        }\\r\\n        \\r\\n        function setIsAntiDump(bool isActive) external onlyManager{\\r\\n            ANTI_DUMP_MULTIPLAYER = isActive;\\r\\n        }\\r\\n        \\r\\n        function getAntiDump() external view returns(bool)\\r\\n        {\\r\\n            return ANTI_DUMP_MULTIPLAYER;\\r\\n        }\\r\\n        \\r\\n        function checkAddress(address checkAdd) external view returns(uint256)\\r\\n        {\\r\\n           return _getLastTransaction(checkAdd);\\r\\n        }\\r\\n        \\r\\n        function checkAddress2(address checkAdd) external view returns(uint256)\\r\\n        {\\r\\n           return _getLastBlock(checkAdd);\\r\\n        }\\r\\n        \\r\\n        function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\\r\\n            _transfer(sender, recipient, amount);\\r\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n            return true;\\r\\n        }\\r\\n    /** Functions required by IERC20 - END **/\\r\\n\\r\\n    /**\\r\\n     * @dev this is really a \\\"soft\\\" burn (total supply is not reduced). RFI holders\\r\\n     * get two benefits from burning tokens:\\r\\n     *\\r\\n     * 1) Tokens in the burn address increase the % of tokens held by holders not\\r\\n     *    excluded from rewards (assuming the burn address is excluded)\\r\\n     * 2) Tokens in the burn address cannot be sold (which in turn draing the \\r\\n     *    liquidity pool)\\r\\n     *\\r\\n     *\\r\\n     * In RFI holders already get % of each transaction so the value of their tokens \\r\\n     * increases (in a way). Therefore there is really no need to do a \\\"hard\\\" burn \\r\\n     * (reduce the total supply). What matters (in RFI) is to make sure that a large\\r\\n     * amount of tokens cannot be sold = draining the liquidity pool = lowering the\\r\\n     * value of tokens holders own. For this purpose, transfering tokens to a (vanity)\\r\\n     * burn address is the most appropriate way to \\\"burn\\\". \\r\\n     *\\r\\n     * There is an extra check placed into the `transfer` function to make sure the\\r\\n     * burn address cannot withdraw the tokens is has (although the chance of someone\\r\\n     * having/finding the private key is virtually zero).\\r\\n     */\\r\\n    function burn(uint256 amount) external {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n        require(sender != address(0), \\\"BaseRfiToken: burn from the zero address\\\");\\r\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: burn from the burn address\\\");\\r\\n\\r\\n        uint256 balance = balanceOf(sender);\\r\\n        require(balance \\u003e= amount, \\\"BaseRfiToken: burn amount exceeds balance\\\");\\r\\n\\r\\n        uint256 reflectedAmount = amount.mul(_getCurrentRate());\\r\\n\\r\\n        // remove the amount from the sender\\u0027s balance first\\r\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\\r\\n        if (_isExcludedFromRewards[sender])\\r\\n            _balances[sender] = _balances[sender].sub(amount);\\r\\n\\r\\n        _burnTokens( sender, amount, reflectedAmount );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev \\\"Soft\\\" burns the specified amount of tokens by sending them \\r\\n     * to the burn address\\r\\n     */\\r\\n    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal {\\r\\n\\r\\n        /**\\r\\n         * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\\r\\n         * tokens to the burn address (which should be excluded from rewards) is sufficient\\r\\n         * in RFI\\r\\n         */ \\r\\n        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(rBurn);\\r\\n        if (_isExcludedFromRewards[burnAddress])\\r\\n            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\\r\\n\\r\\n        /**\\r\\n         * @dev Emit the event so that the burn address balance is updated (on bscscan)\\r\\n         */\\r\\n        emit Transfer(sender, burnAddress, tBurn);\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function isExcludedFromReward(address account) external view returns (bool) {\\r\\n        return _isExcludedFromRewards[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and returns the reflected amount for the given amount with or without \\r\\n     * the transfer fees (deductTransferFee true/false)\\r\\n     */\\r\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\r\\n        require(tAmount \\u003c= TOTAL_SUPPLY, \\\"Amount must be less than supply\\\");\\r\\n        if (!deductTransferFee) {\\r\\n            (uint256 rAmount,,,,) = _getValues(tAmount,0);\\r\\n            return rAmount;\\r\\n        } else {\\r\\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount,_getSumOfFees(_msgSender(), tAmount));\\r\\n            return rTransferAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\\r\\n     */\\r\\n    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\\r\\n        require(rAmount \\u003c= _reflectedSupply, \\\"Amount must be less than total reflections\\\");\\r\\n        uint256 currentRate = _getCurrentRate();\\r\\n        return rAmount.div(currentRate);\\r\\n    }\\r\\n    \\r\\n    function excludeFromReward(address account) external onlyOwner() {\\r\\n        require(!_isExcludedFromRewards[account], \\\"Account is not included\\\");\\r\\n        _exclude(account);\\r\\n    }\\r\\n    \\r\\n    function _exclude(address account) internal {\\r\\n        if(_reflectedBalances[account] \\u003e 0) {\\r\\n            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\\r\\n        }\\r\\n        _isExcludedFromRewards[account] = true;\\r\\n        _excluded.push(account);\\r\\n    }\\r\\n\\r\\n    function includeInReward(address account) external onlyOwner() {\\r\\n        require(_isExcludedFromRewards[account], \\\"Account is not excluded\\\");\\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_excluded[i] == account) {\\r\\n                _excluded[i] = _excluded[_excluded.length - 1];\\r\\n                _balances[account] = 0;\\r\\n                _isExcludedFromRewards[account] = false;\\r\\n                _excluded.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function setExcludedFromFee(address account, bool value) external onlyOwner { _isExcludedFromFee[account] = value; }\\r\\n    function isExcludedFromFee(address account) public view returns(bool) { return _isExcludedFromFee[account]; }\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"BaseRfiToken: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"BaseRfiToken: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     */\\r\\n    function _isUnlimitedSender(address account) internal view returns(bool){\\r\\n        // the owner should be the only whitelisted sender\\r\\n        return (account == owner());\\r\\n    }\\r\\n    /**\\r\\n     */\\r\\n    function _isUnlimitedRecipient(address account) internal view returns(bool){\\r\\n        // the owner should be a white-listed recipient\\r\\n        // and anyone should be able to burn as many tokens as \\r\\n        // he/she wants\\r\\n        return (account == owner() || account == burnAddress);\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n        require(sender != address(0), \\\"BaseRfiToken: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"BaseRfiToken: transfer to the zero address\\\");\\r\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: transfer from the burn address\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        \\r\\n        // indicates whether or not feee should be deducted from the transfer\\r\\n        bool takeFee = true;\\r\\n\\r\\n        if ( isInPresale ){ takeFee = false; }\\r\\n        else {\\r\\n            /**\\r\\n            * Check the amount is within the max allowed limit as long as a\\r\\n            * unlimited sender/recepient is not involved in the transaction\\r\\n            */\\r\\n            if ( amount \\u003e maxTransactionAmount \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) ){\\r\\n                revert(\\\"Transfer amount exceeds the maxTxAmount.\\\");\\r\\n            }\\r\\n            /**\\r\\n            * The pair needs to excluded from the max wallet balance check; \\r\\n            * selling tokens is sending them back to the pair (without this\\r\\n            * check, selling tokens would not work if the pair\\u0027s balance \\r\\n            * was over the allowed max)\\r\\n            *\\r\\n            * Note: This does NOT take into account the fees which will be deducted \\r\\n            *       from the amount. As such it could be a bit confusing \\r\\n            */\\r\\n            if ( maxWalletBalance \\u003e 0 \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) \\u0026\\u0026 !_isV2Pair(recipient)){\\r\\n                uint256 recipientBalance = balanceOf(recipient);\\r\\n                require(recipientBalance + amount \\u003c= maxWalletBalance, \\\"New balance would exceed the maxWalletBalance\\\");\\r\\n            }\\r\\n            \\r\\n            if(TIME_LIMIT_TRANSACTION \\u003e 0 \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) \\u0026\\u0026 sender != address(this))\\r\\n            {\\r\\n                //AntiBot Using Block Check\\r\\n                require(block.number \\u003e _getLastBlock(tx.origin), \\\"You cant send more than one transaction in one block.\\\");\\r\\n                _setLastBlock(tx.origin);\\r\\n                \\r\\n                //AntiBot Using Time Between Transaction\\r\\n                if(_getLastTransaction(tx.origin) \\u003e 0)\\r\\n                {\\r\\n                    require(_getLastTransaction(tx.origin) \\u003c= block.timestamp, \\\"You need to wait TIME_LIMIT_TRANSACTION before perform another transaction.\\\");\\r\\n                }\\r\\n                _setLastTransaction(tx.origin);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){ takeFee = false; }\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount, takeFee);\\r\\n        _transferTokens(sender, recipient, amount, takeFee);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\\r\\n    \\r\\n        /**\\r\\n         * We don\\u0027t need to know anything about the individual fees here \\r\\n         * (like Safemoon does with `_getValues`). All that is required \\r\\n         * for the transfer is the sum of all fees to calculate the % of the total \\r\\n         * transaction amount which should be transferred to the recipient. \\r\\n         *\\r\\n         * The `_takeFees` call will/should take care of the individual fees\\r\\n         */\\r\\n        uint256 sumOfFees = _getSumOfFees(sender, amount);\\r\\n        \\r\\n        //Remove Whale Fee if sender is not whale\\r\\n        bool isWhale = true;\\r\\n        if(capWhaleWalletBalance \\u003e 0)\\r\\n        {\\r\\n            if(balanceOf(sender) \\u003c capWhaleWalletBalance || balanceOf(recipient) \\u003c capWhaleWalletBalance)\\r\\n            {\\r\\n                sumOfFees = sumOfFees - WHALE_FEE_IN_PERCENT;\\r\\n                isWhale = false;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        /**\\r\\n         * Only ANTI_DUMP_MULTIPLAYER when selling\\r\\n         * */\\r\\n        uint multiplier = 1 ;\\r\\n        if(_isV2Pair(recipient))\\r\\n        {\\r\\n            multiplier = _multiplier();\\r\\n            sumOfFees = sumOfFees.mul(multiplier);\\r\\n        }\\r\\n        \\r\\n        if ( !takeFee ){ sumOfFees = 0; }\\r\\n        \\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees);\\r\\n        \\r\\n        /** \\r\\n         * Sender\\u0027s and Recipient\\u0027s reflected balances must be always updated regardless of\\r\\n         * whether they are excluded from rewards or not.\\r\\n         */ \\r\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\\r\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\\r\\n\\r\\n        /**\\r\\n         * Update the true/nominal balances for excluded accounts\\r\\n         */        \\r\\n        if (_isExcludedFromRewards[sender]){ _balances[sender] = _balances[sender].sub(tAmount); }\\r\\n        if (_isExcludedFromRewards[recipient] ){ _balances[recipient] = _balances[recipient].add(tTransferAmount); }\\r\\n        \\r\\n         tokenFromReflection(_reflectedBalances[sender]) \\u003e= capWhaleWalletBalance;\\r\\n        \\r\\n        _takeFees( amount, currentRate, sumOfFees, isWhale, multiplier);\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees, bool isWhale, uint multiplier ) private {\\r\\n        if ( sumOfFees \\u003e 0 \\u0026\\u0026 !isInPresale ){\\r\\n            _takeTransactionFees(amount, currentRate, isWhale, multiplier);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {\\r\\n        \\r\\n        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\\r\\n        uint256 tTransferAmount = tAmount.sub(tTotalFees);\\r\\n        uint256 currentRate = _getCurrentRate();\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n        uint256 rTotalFees = tTotalFees.mul(currentRate);\\r\\n        uint256 rTransferAmount = rAmount.sub(rTotalFees);\\r\\n        \\r\\n        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\\r\\n    }\\r\\n    \\r\\n    function _getCurrentRate() internal view returns(uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply.div(tSupply);\\r\\n    }\\r\\n    \\r\\n    function _getCurrentSupply() internal view returns(uint256, uint256) {\\r\\n        uint256 rSupply = _reflectedSupply;\\r\\n        uint256 tSupply = TOTAL_SUPPLY;  \\r\\n\\r\\n        /**\\r\\n         * The code below removes balances of addresses excluded from rewards from\\r\\n         * rSupply and tSupply, which effectively increases the % of transaction fees\\r\\n         * delivered to non-excluded holders\\r\\n         */    \\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_reflectedBalances[_excluded[i]] \\u003e rSupply || _balances[_excluded[i]] \\u003e tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\\r\\n            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\\r\\n            tSupply = tSupply.sub(_balances[_excluded[i]]);\\r\\n        }\\r\\n        if (tSupply == 0 || rSupply \\u003c _reflectedSupply.div(TOTAL_SUPPLY)) return (_reflectedSupply, TOTAL_SUPPLY);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens.\\r\\n     */\\r\\n    function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the total sum of fees to be processed in each transaction. \\r\\n     * \\r\\n     * To separate concerns this contract (class) will take care of ONLY handling RFI, i.e. \\r\\n     * changing the rates and updating the holder\\u0027s balance (via `_redistribute`). \\r\\n     * It is the responsibility of the dev/user to handle all other fees and taxes \\r\\n     * in the appropriate contracts (classes).\\r\\n     */ \\r\\n    function _getSumOfFees(address sender, uint256 amount) internal view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev A delegate which should return true if the given address is the V2 Pair and false otherwise\\r\\n     */\\r\\n    function _isV2Pair(address account) internal view virtual returns(bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Redistributes the specified amount among the current holders via the reflect.finance\\r\\n     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\\r\\n     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`. \\r\\n     * This is the bit of clever math which allows rfi to redistribute the fee without \\r\\n     * having to iterate through all holders. \\r\\n     * \\r\\n     * Visit our discord at https://discord.gg/dAmr6eUTpM\\r\\n     */\\r\\n    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) internal {\\r\\n        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rFee = tFee.mul(currentRate);\\r\\n\\r\\n        _reflectedSupply = _reflectedSupply.sub(rFee);\\r\\n        _addFeeCollectedAmount(index, tFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted if fees are enabled for the transfer\\r\\n     */\\r\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate, bool isWhale, uint multiplier) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _getLastTransaction(address sender) internal view virtual returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _setLastTransaction(address sender) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _getLastBlock(address sender) internal view virtual returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _setLastBlock(address sender) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted every trabsaction\\r\\n     */\\r\\n    function _multiplier() internal  view virtual returns (uint);\\r\\n}\\r\\n\\r\\nabstract contract Liquifier is Ownable, Manageable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 private withdrawableBalance;\\r\\n\\r\\n    enum Env {Testnet, MainnetV1, MainnetV2}\\r\\n    Env private _env;\\r\\n\\r\\n    // PancakeSwap V1\\r\\n    address private _mainnetRouterV1Address = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\\r\\n    // PancakeSwap V2\\r\\n    address private _mainnetRouterV2Address = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    // Testnet\\r\\n    // address private _testnetRouterAddress = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\r\\n    // PancakeSwap Testnet = https://pancake.kiemtienonline360.com/\\r\\n    address private _testnetRouterAddress = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\\r\\n\\r\\n    IPancakeV2Router internal _router;\\r\\n    address internal _pair;\\r\\n    \\r\\n    bool private inSwapAndLiquify;\\r\\n    bool private swapAndLiquifyEnabled = true;\\r\\n\\r\\n    uint256 private maxTransactionAmount;\\r\\n    uint256 private numberOfTokensToSwapToLiquidity;\\r\\n\\r\\n    modifier lockTheSwap {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    event RouterSet(address indexed router);\\r\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\\r\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\r\\n    event LiquidityAdded(uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity);\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function initializeLiquiditySwapper(Env env, uint256 maxTx, uint256 liquifyAmount) internal {\\r\\n        _env = env;\\r\\n        if (_env == Env.MainnetV1){ _setRouterAddress(_mainnetRouterV1Address); }\\r\\n        else if (_env == Env.MainnetV2){ _setRouterAddress(_mainnetRouterV2Address); }\\r\\n        else /*(_env == Env.Testnet)*/{ _setRouterAddress(_testnetRouterAddress); }\\r\\n\\r\\n        maxTransactionAmount = maxTx;\\r\\n        numberOfTokensToSwapToLiquidity = liquifyAmount;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * NOTE: passing the `contractTokenBalance` here is preferred to creating `balanceOfDelegate`\\r\\n     */\\r\\n    function liquify(uint256 contractTokenBalance, address sender) internal {\\r\\n\\r\\n        if (contractTokenBalance \\u003e= maxTransactionAmount) contractTokenBalance = maxTransactionAmount;\\r\\n        \\r\\n        bool isOverRequiredTokenBalance = ( contractTokenBalance \\u003e= numberOfTokensToSwapToLiquidity );\\r\\n        \\r\\n        /**\\r\\n         * - first check if the contract has collected enough tokens to swap and liquify\\r\\n         * - then check swap and liquify is enabled\\r\\n         * - then make sure not to get caught in a circular liquidity event\\r\\n         * - finally, don\\u0027t swap \\u0026 liquify if the sender is the uniswap pair\\r\\n         */\\r\\n        if ( isOverRequiredTokenBalance \\u0026\\u0026 swapAndLiquifyEnabled \\u0026\\u0026 !inSwapAndLiquify \\u0026\\u0026 (sender != _pair) ){\\r\\n            // TODO check if the `(sender != _pair)` is necessary because that basically\\r\\n            // stops swap and liquify for all \\\"buy\\\" transactions\\r\\n            _swapAndLiquify(contractTokenBalance);            \\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets the router address and created the router, factory pair to enable\\r\\n     * swapping and liquifying (contract) tokens\\r\\n     */\\r\\n    function _setRouterAddress(address router) private {\\r\\n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(router);\\r\\n        _pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(address(this), _newPancakeRouter.WETH());\\r\\n        _router = _newPancakeRouter;\\r\\n        emit RouterSet(router);\\r\\n    }\\r\\n    \\r\\n    function _swapAndLiquify(uint256 amount) private lockTheSwap {\\r\\n        \\r\\n        // split the contract balance into halves\\r\\n        uint256 half = amount.div(2);\\r\\n        uint256 otherHalf = amount.sub(half);\\r\\n        \\r\\n        // capture the contract\\u0027s current ETH balance.\\r\\n        // this is so that we can capture exactly the amount of ETH that the\\r\\n        // swap creates, and not make the liquidity event include any ETH that\\r\\n        // has been manually sent to the contract\\r\\n        uint256 initialBalance = address(this).balance;\\r\\n        \\r\\n        // swap tokens for ETH\\r\\n        _swapTokensForEth(half); // \\u003c- this breaks the ETH -\\u003e HATE swap when swap+liquify is triggered\\r\\n\\r\\n        // how much ETH did we just swap into?\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n\\r\\n        // add liquidity to uniswap\\r\\n        _addLiquidity(otherHalf, newBalance);\\r\\n        \\r\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\r\\n    }\\r\\n    \\r\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\r\\n        \\r\\n        // generate the uniswap pair path of token -\\u003e weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _router.WETH();\\r\\n\\r\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            // The minimum amount of output tokens that must be received for the transaction not to revert.\\r\\n            // 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\r\\n\\r\\n        // add the liquidity\\r\\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) = _router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            // Bounds the extent to which the WETH/token price can go up before the transaction reverts. \\r\\n            // Must be \\u003c= amountTokenDesired; 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            // Bounds the extent to which the token/WETH price can go up before the transaction reverts.\\r\\n            // 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            // this is a centralized risk if the owner\\u0027s account is ever compromised (see Certik SSL-04)\\r\\n            owner(),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        // fix the forever locked BNBs as per the certik\\u0027s audit\\r\\n        /**\\r\\n         * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB. \\r\\n         * For every swapAndLiquify function call, a small amount of BNB remains in the contract. \\r\\n         * This amount grows over time with the swapAndLiquify function being called throughout the life \\r\\n         * of the contract. The Safemoon contract does not contain a method to withdraw these funds, \\r\\n         * and the BNB will be locked in the Safemoon contract forever.\\r\\n         */\\r\\n        withdrawableBalance = address(this).balance;\\r\\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n    * @dev Sets the uniswapV2 pair (router \\u0026 factory) for swapping and liquifying tokens\\r\\n    */\\r\\n    function setRouterAddress(address router) external onlyManager() {\\r\\n        _setRouterAddress(router);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sends the swap and liquify flag to the provided value. If set to `false` tokens collected in the contract will\\r\\n     * NOT be converted into liquidity.\\r\\n     */\\r\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyManager {\\r\\n        swapAndLiquifyEnabled = enabled;\\r\\n        emit SwapAndLiquifyEnabledUpdated(swapAndLiquifyEnabled);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev The owner can withdraw ETH(BNB) collected in the contract from `swapAndLiquify`\\r\\n     * or if someone (accidentally) sends ETH/BNB directly to the contract.\\r\\n     *\\r\\n     * Note: This addresses the contract flaw pointed out in the Certik Audit of Safemoon (SSL-03):\\r\\n     * \\r\\n     * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB. \\r\\n     * For every swapAndLiquify function call, a small amount of BNB remains in the contract. \\r\\n     * This amount grows over time with the swapAndLiquify function being called \\r\\n     * throughout the life of the contract. The Safemoon contract does not contain a method \\r\\n     * to withdraw these funds, and the BNB will be locked in the Safemoon contract forever.\\r\\n     * https://www.certik.org/projects/safemoon\\r\\n     */\\r\\n    function withdrawLockedEth(address payable recipient) external onlyManager(){\\r\\n        require(recipient != address(0), \\\"Cannot withdraw the ETH balance to the zero address\\\");\\r\\n        require(withdrawableBalance \\u003e 0, \\\"The ETH balance must be greater than 0\\\");\\r\\n\\r\\n        // prevent re-entrancy attacks\\r\\n        uint256 amount = withdrawableBalance;\\r\\n        withdrawableBalance = 0;\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Use this delegate instead of having (unnecessarily) extend `BaseRfiToken` to gained access \\r\\n     * to the `_approve` function.\\r\\n     */\\r\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal virtual;\\r\\n\\r\\n}\\r\\n\\r\\n//////////////////////////////////////////////////////////////////////////\\r\\nabstract contract Antiwhale is Tokenomics {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total sum of fees (in percents / per-mille - this depends on the FEES_DIVISOR value)\\r\\n     *\\r\\n     * NOTE: Currently this is just a placeholder. The parameters passed to this function are the\\r\\n     *      sender\\u0027s token balance and the transfer amount. An *antiwhale* mechanics can use these \\r\\n     *      values to adjust the fees total for each tx\\r\\n     */\\r\\n    // function _getAntiwhaleFees(uint256 sendersBalance, uint256 amount) internal view returns (uint256){\\r\\n    function _getAntiwhaleFees(uint256, uint256) internal view returns (uint256){\\r\\n        return sumOfFees;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract AntiBot is Tokenomics {\\r\\n    mapping (address =\\u003e uint) internal _lastTransaction;\\r\\n    mapping (address =\\u003e uint) internal _LastBlock;\\r\\n    /**\\r\\n     * @dev Returns the total sum of fees (in percents / per-mille - this depends on the FEES_DIVISOR value)\\r\\n     *\\r\\n     * NOTE: Currently this is just a placeholder. The parameters passed to this function are the\\r\\n     *      sender\\u0027s token balance and the transfer amount. An *antiwhale* mechanics can use these \\r\\n     *      values to adjust the fees total for each tx\\r\\n     */\\r\\n}\\r\\n\\r\\nabstract contract AntiDump is Tokenomics{\\r\\n    \\r\\n    function _getMultiplier() internal view returns (uint) {\\r\\n        uint multiplier = 1;\\r\\n        if(ANTI_DUMP_MULTIPLAYER == true){\\r\\n            if( block.timestamp \\u003c TimeContractStart + 24 * 1 hours)\\r\\n            {\\r\\n                multiplier = 2;\\r\\n            }\\r\\n        }\\r\\n        return multiplier;\\r\\n    }\\r\\n    \\r\\n}\\r\\n//////////////////////////////////////////////////////////////////////////\\r\\n\\r\\nabstract contract SafeToken is BaseRfiToken, Liquifier, Antiwhale, AntiBot, AntiDump {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // constructor(string memory _name, string memory _symbol, uint8 _decimals){\\r\\n    constructor(Env _env){\\r\\n\\r\\n        initializeLiquiditySwapper(_env, maxTransactionAmount, numberOfTokensToSwapToLiquidity);\\r\\n\\r\\n        // exclude the pair address from rewards - we don\\u0027t want to redistribute\\r\\n        // tx fees to these two; redistribution is only for holders, dah!\\r\\n        _exclude(_pair);\\r\\n        _exclude(burnAddress);\\r\\n    }\\r\\n    \\r\\n    function _isV2Pair(address account) internal view override returns(bool){\\r\\n        return (account == _pair);\\r\\n    }\\r\\n\\r\\n    function _getSumOfFees(address sender, uint256 amount) internal view override returns (uint256){ \\r\\n        return _getAntiwhaleFees(balanceOf(sender), amount); \\r\\n    }\\r\\n    \\r\\n    function _getLastTransaction(address sender) internal view override returns (uint256) {\\r\\n        return _lastTransaction[sender];\\r\\n    }\\r\\n    \\r\\n    function _setLastTransaction(address sender) internal override {\\r\\n        //_setLastTransaction(sender,block.timestamp + TIME_LIMIT_TRANSACTION);\\r\\n        _lastTransaction[sender] = block.timestamp + TIME_LIMIT_TRANSACTION;\\r\\n    }\\r\\n    \\r\\n    function _getLastBlock(address sender) internal view override returns (uint256) {\\r\\n        return _LastBlock[sender];\\r\\n    }\\r\\n    \\r\\n    function _setLastBlock(address sender) internal override {\\r\\n        _LastBlock[sender] = block.number;\\r\\n    }\\r\\n    \\r\\n    function _multiplier() internal  view override returns (uint multiplier){\\r\\n        return _getMultiplier();\\r\\n    }\\r\\n    \\r\\n    \\r\\n    // function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal override {\\r\\n    function _beforeTokenTransfer(address sender, address , uint256 , bool ) internal override {\\r\\n        if ( !isInPresale ){\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            liquify( contractTokenBalance, sender );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate, bool isWhale, uint multiplier) internal override {\\r\\n        \\r\\n        if( isInPresale ){ return; }\\r\\n\\r\\n        uint256 feesCount = _getFeesCount();\\r\\n        for (uint256 index = 0; index \\u003c feesCount; index++ ){\\r\\n            (FeeType name, uint256 value, address recipient,) = _getFee(index);\\r\\n            // no need to check value \\u003c 0 as the value is uint (i.e. from 0 to 2^256-1)\\r\\n            if ( value == 0 ) continue;\\r\\n\\r\\n            if ( name == FeeType.Rfi ){\\r\\n                _redistribute( amount.mul(multiplier), currentRate, value, index );\\r\\n            }\\r\\n            else if ( name == FeeType.Burn ){\\r\\n                _burn( amount.mul(multiplier), currentRate, value, index );\\r\\n            }\\r\\n            else if ( name == FeeType.Antiwhale){\\r\\n                if(isWhale)\\r\\n                {\\r\\n                    _takeFeeToETH( amount.mul(multiplier), currentRate, value, recipient, index );\\r\\n                }\\r\\n            }\\r\\n            else if ( name == FeeType.ExternalToETH){\\r\\n                _takeFeeToETH( amount.mul(multiplier), currentRate, value, recipient, index );\\r\\n            }\\r\\n            else {\\r\\n                _takeFee( amount.mul(multiplier), currentRate, value, recipient, index );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) private {\\r\\n        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rBurn = tBurn.mul(currentRate);\\r\\n\\r\\n        _burnTokens(address(this), tBurn, rBurn);\\r\\n        _addFeeCollectedAmount(index, tBurn);\\r\\n    }\\r\\n\\r\\n    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\r\\n\\r\\n        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n\\r\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\\r\\n        if(_isExcludedFromRewards[recipient])\\r\\n            _balances[recipient] = _balances[recipient].add(tAmount);\\r\\n\\r\\n        _addFeeCollectedAmount(index, tAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev When implemented this will convert the fee amount of tokens into ETH/BNB\\r\\n     * and send to the recipient\\u0027s wallet. Note that this reduces liquidity so it \\r\\n     * might be a good idea to add a % into the liquidity fee for % you take our through\\r\\n     * this method (just a suggestions)\\r\\n     */\\r\\n    function _takeFeeToETH(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\r\\n        _takeFee(amount, currentRate, fee, recipient, index);        \\r\\n    }\\r\\n\\r\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal override {\\r\\n        _approve(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract SafeTokenV1Beta is SafeToken{\\r\\n\\r\\n    constructor() SafeToken(Env.MainnetV2) {\\r\\n        // pre-approve the initial liquidity supply (to safe a bit of time)\\r\\n        _approve(owner(),address(_router), ~uint256(0));\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Todo (beta):\\r\\n *\\r\\n * - reorganize the sol file(s) to make put everything editable in a single .sol file\\r\\n *      and keep all other code in other .sol file(s)\\r\\n * - move variable values initialized in the contract to be constructor parameters\\r\\n * - add/remove setters/getter where appropriate\\r\\n * - add unit tests (via ganache-cli + truffle)\\r\\n * - add full dev evn (truffle) folders \\u0026 files\\r\\n *\\r\\n * Todo:\\r\\n * \\r\\n * - implement `_takeFeeToETH` (currently just calls `_takeFee`)\\r\\n * - implement anti whale mechanics (via different pre-created libraries?), eg progressive tax\\r\\n * - implement anti sell mechanics\\r\\n * - address SSL-04 | Centralized risk in addLiquidity - https://www.certik.org/projects/safemoon\\r\\n *      change the recipient to `address(this)` or implement a decentralized mechanism or \\r\\n *      smart-contract solution\\r\\n * - change Uniswap to PancakeSwap in contract/interface names and local var names\\r\\n * - change ETH to BNB in names and comments\\r\\n */\\r\\n\\r\\n/**\\r\\n * Tests to pass:\\r\\n * \\r\\n * - Tokenomics fees can be added/removed/edited \\r\\n * - Tokenomics fees are correctly taken from each (qualifying) transaction\\r\\n * - The RFI fee is correctly distributed among holders (which are not excluded from rewards)\\r\\n * - `swapAndLiquify` works correctly when the threshold balance is reached\\r\\n * - `maxTransactionAmount` works correctly and *unlimited* accounts are not subject to the limit\\r\\n * - `maxWalletBalance` works correctly and *unlimited* accounts are not subject to the limit\\r\\n * - accounts excluded from fees are not subjecto tx fees\\r\\n * - accounts excluded from rewards do not share in rewards\\r\\n * - ETH/BNB collected/stuck in the contract can be withdrawn (see)\\r\\n */\"},\"safetoken-imports.sol\":{\"content\":\"/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n */ \\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\\r\\n}\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked { require(b \\u003c= a, errorMessage); return a - b; }\\r\\n    }\\r\\n}\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size \\u003e 0;}\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, \\\"Address: low-level call failed\\\");}\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");}\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) { return returndata; } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {revert(errorMessage);}\\r\\n        }\\r\\n    }\\r\\n}\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    uint256 private _lockTime;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    function getUnlockTime() public view returns (uint256) {\\r\\n        return _lockTime;\\r\\n    }\\r\\n    function lock(uint256 time) public virtual onlyOwner {\\r\\n        _previousOwner = _owner;\\r\\n        _owner = address(0);\\r\\n        _lockTime = block.timestamp + time;\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n    }\\r\\n    function unlock() public virtual {\\r\\n        require(_previousOwner == msg.sender, \\\"Only the previous owner can unlock onwership\\\");\\r\\n        require(block.timestamp \\u003e _lockTime , \\\"The contract is still locked\\\");\\r\\n        emit OwnershipTransferred(_owner, _previousOwner);\\r\\n        _owner = _previousOwner;\\r\\n    }\\r\\n}\\r\\nabstract contract Manageable is Context {\\r\\n    address private _manager;\\r\\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\\r\\n    constructor(){\\r\\n        address msgSender = _msgSender();\\r\\n        _manager = msgSender;\\r\\n        emit ManagementTransferred(address(0), msgSender);\\r\\n    }\\r\\n    function manager() public view returns(address){ return _manager; }\\r\\n    modifier onlyManager(){\\r\\n        require(_manager == _msgSender(), \\\"Manageable: caller is not the manager\\\");\\r\\n        _;\\r\\n    }\\r\\n    function transferManagement(address newManager) external virtual onlyManager {\\r\\n        emit ManagementTransferred(_manager, newManager);\\r\\n        _manager = newManager;\\r\\n    }\\r\\n}\\r\\ninterface IPancakeV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\ninterface IPancakeV2Router {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"RouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkAdd\",\"type\":\"address\"}],\"name\":\"checkAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkAdd\",\"type\":\"address\"}],\"name\":\"checkAddress2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAddressLastTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAntiDump\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCapWhaleWalletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxWalletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeLimitTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setCapWhaleWalletBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"setIsAntiDump\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPreseableEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inSecond\",\"type\":\"uint256\"}],\"name\":\"setTimeLimitTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawLockedEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SafeTokenV1Beta", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5f47b243418baf2305e21351f53238d0aaf406fe55b3b567057a37cf2be4a8af"}