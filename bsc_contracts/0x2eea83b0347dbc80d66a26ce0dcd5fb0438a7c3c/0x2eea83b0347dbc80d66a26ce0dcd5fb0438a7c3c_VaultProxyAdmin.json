{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/VaultProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IUpgradeLogic} from \\\"./vault/interfaces/IUpgradeLogic.sol\\\";\\n\\nimport {IVaultFactory} from \\\"./IVaultFactory.sol\\\";\\nimport {IVaultProxyAdmin} from \\\"./IVaultProxyAdmin.sol\\\";\\n\\n/// @title VaultProxyAdmin\\n/// @notice This contract is a common proxy admin for all vaults deployed via factory.\\n/// @dev Through this contract, all vaults can be updated to a new implementation.\\ncontract VaultProxyAdmin is IVaultProxyAdmin {\\n    // =========================\\n    // Storage\\n    // =========================\\n\\n    IVaultFactory public immutable vaultFactory;\\n\\n    constructor(address _vaultFactory) {\\n        vaultFactory = IVaultFactory(_vaultFactory);\\n    }\\n\\n    // =========================\\n    // Vault implementation logic\\n    // =========================\\n\\n    /// @inheritdoc IVaultProxyAdmin\\n    function initializeImplementation(\\n        address vault,\\n        address implementation\\n    ) external {\\n        if (msg.sender != address(vaultFactory)) {\\n            revert VaultProxyAdmin_CallerIsNotFactory();\\n        }\\n\\n        IUpgradeLogic(vault).upgrade(implementation);\\n    }\\n\\n    /// @inheritdoc IVaultProxyAdmin\\n    function upgrade(address vault, uint256 version) external {\\n        if (IUpgradeLogic(vault).owner() != msg.sender) {\\n            revert VaultProxyAdmin_SenderIsNotVaultOwner();\\n        }\\n\\n        if (version > vaultFactory.versions() || version == 0) {\\n            revert VaultProxyAdmin_VersionDoesNotExist();\\n        }\\n\\n        address currentImplementation = IUpgradeLogic(vault).implementation();\\n        address implementation = vaultFactory.implementation(version);\\n\\n        if (currentImplementation == implementation) {\\n            revert VaultProxyAdmin_CannotUpdateToCurrentVersion();\\n        }\\n\\n        IUpgradeLogic(vault).upgrade(implementation);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/vault/interfaces/IUpgradeLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title IUpgradeLogic - UpgradeLogicinterface\\n/// @dev Logic for upgrading the implementation of a proxy clone contract.\\ninterface IUpgradeLogic {\\n    // =========================\\n    // Events\\n    // =========================\\n\\n    /// @notice Emits when the implementation address is changed.\\n    /// @param newImplementation The address of the new implementation.\\n    event ImplementationChanged(address newImplementation);\\n\\n    // =========================\\n    // Main functions\\n    // =========================\\n\\n    /// @notice Setting a `newImplementation` address for delegate calls\\n    /// from the proxy clone.\\n    /// @param newImplementation Address of the new implementation.\\n    function upgrade(address newImplementation) external;\\n\\n    /// @notice Returns the address of the current implementation to which\\n    /// the proxy clone delegates calls.\\n    /// @return impl_ Address of the current implementation.\\n    function implementation() external view returns (address impl_);\\n\\n    /// @notice Returns the address of the current owner of the vault.\\n    /// @return The address of the current owner.\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/IVaultFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IOwnable} from \\\"./external/IOwnable.sol\\\";\\n\\n/// @title IVaultFactory - VaultFactory Interface\\n/// @notice This contract is a vault factory that implements methods for creating new vaults\\n/// and updating them via the UpgradeLogic contract.\\ninterface IVaultFactory is IOwnable {\\n    // =========================\\n    // Storage\\n    // =========================\\n\\n    /// @notice The address of the immutable contract to which the `vault` call will be\\n    /// delegated if the call is made from `ProxyAdmin's` address.\\n    function upgradeLogic() external view returns (address);\\n\\n    /// @notice The address from which the call to `vault` will delegate it to the `updateLogic`.\\n    function vaultProxyAdmin() external view returns (address);\\n\\n    // =========================\\n    // Events\\n    // =========================\\n\\n    /// @notice Emits when the new `vault` has been created.\\n    /// @param creator The creator of the created vault\\n    /// @param vault The address of the created vault\\n    /// @param vaultId The unique identifier for the vault (for `creator` address)\\n    event VaultCreated(\\n        address indexed creator,\\n        address indexed vault,\\n        uint16 vaultId\\n    );\\n\\n    // =========================\\n    // Errors\\n    // =========================\\n\\n    /// @notice Thrown if an attempt is made to initialize the contract a second time.\\n    error VaultFactory_AlreadyInitialized();\\n\\n    /// @notice Thrown when a `creator` attempts to create a vault using\\n    /// a version of the implementation that doesn't exist.\\n    error VaultFactory_VersionDoesNotExist();\\n\\n    /// @notice Thrown when a `creator` tries to create a vault with an `vaultId`\\n    /// that's already in use.\\n    /// @param creator The address which tries to create the vault.\\n    /// @param vaultId The id that is already used.\\n    error VaultFactory_IdAlreadyUsed(address creator, uint16 vaultId);\\n\\n    /// @notice Thrown when a `creator` attempts to create a vault with an vaultId == `0`\\n    /// or when the `creator` address is the same as the `proxyAdmin`.\\n    error VaultFactory_InvalidDeployArguments();\\n\\n    // =========================\\n    // Vault implementation logic\\n    // =========================\\n\\n    /// @notice Adds a `newImplemetation` address to the list of implementations.\\n    /// @param newImplemetation The address of the new implementation to be added.\\n    ///\\n    /// @dev Only callable by the owner of the contract.\\n    /// @dev After adding, the new implementation will be at the last index\\n    /// (i.e., version is `_implementations.length`).\\n    function addNewImplementation(address newImplemetation) external;\\n\\n    /// @notice Retrieves the implementation address for a given `version`.\\n    /// @param version The version number of the desired implementation.\\n    /// @return impl_ The address of the specified implementation version.\\n    ///\\n    /// @dev If the `version` number is greater than the length of the `_implementations` array\\n    /// or the array is empty, `VaultFactory_VersionDoesNotExist` error is thrown.\\n    function implementation(uint256 version) external view returns (address);\\n\\n    /// @notice Returns the total number of available implementation versions.\\n    /// @return The total count of versions in the `_implementations` array.\\n    function versions() external view returns (uint256);\\n\\n    // =========================\\n    // Main functions\\n    // =========================\\n\\n    /// @notice Computes the address of a `vault` deployed using `deploy` method.\\n    /// @param creator The address of the creator of the vault.\\n    /// @param vaultId The id of the vault.\\n    /// @dev `creator` and `id` are part of the salt for the `create2` opcode.\\n    function predictDeterministicVaultAddress(\\n        address creator,\\n        uint16 vaultId\\n    ) external view returns (address predicted);\\n\\n    /// @notice Deploys a new `vault` based on a specified `version`.\\n    /// @param creator Address that will be set as the initial owner of the new vault.\\n    /// @param version The version number of the vault implementation to which\\n    ///        the new vault will delegate.\\n    /// @param vaultId A unique identifier for deterministic vault creation.\\n    ///        Used in combination with `creator` for `create2` salt.\\n    /// @return The address of the newly deployed `vault`.\\n    ///\\n    /// @dev Uses the `create2` opcode for deterministic address generation based on a salt that\\n    /// combines the `creator` and `vaultId`.\\n    /// @dev If the given `version` number is greater than the length of  the `_implementations`\\n    /// array or if the array is empty, it reverts with `VaultFactory_VersionDoesNotExist`.\\n    /// @dev If `vaultId` is zero, it reverts with`VaultFactory_InvalidDeployArguments`.\\n    /// @dev If the `vaultId` has already been used for the `creator`, it reverts with\\n    /// `VaultFactory_IdAlreadyUsed`.\\n    function deploy(\\n        address creator,\\n        uint256 version,\\n        uint16 vaultId\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"src/IVaultProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IVaultFactory} from \\\"./IVaultFactory.sol\\\";\\n\\n/// @title IVaultProxyAdmin - VaultProxyAdmin interface.\\n/// @notice This contract is a common proxy admin for all vaults deployed via factory.\\n/// @dev Through this contract, all vaults can be updated to a new implementation.\\ninterface IVaultProxyAdmin {\\n    // =========================\\n    // Storage\\n    // =========================\\n\\n    function vaultFactory() external view returns (IVaultFactory);\\n\\n    // =========================\\n    // Errors\\n    // =========================\\n\\n    /// @notice Thrown when an anyone other than the address of the factory tries calling the method.\\n    error VaultProxyAdmin_CallerIsNotFactory();\\n\\n    /// @notice Thrown when a non-owner of the vault tries to update its implementation.\\n    error VaultProxyAdmin_SenderIsNotVaultOwner();\\n\\n    /// @notice Thrown when an `owner` attempts to update a vault using\\n    /// a version of the implementation that doesn't exist.\\n    error VaultProxyAdmin_VersionDoesNotExist();\\n\\n    /// @notice Thrown when there's an attempt to update the vault to its\\n    /// current implementation address.\\n    error VaultProxyAdmin_CannotUpdateToCurrentVersion();\\n\\n    // =========================\\n    // Vault implementation logic\\n    // =========================\\n\\n    /// @notice Sets the `vault` implementation to an address from the factory.\\n    /// @param vault Address of the vault to be upgraded.\\n    /// @param implementation The new implementation from the factory.\\n    /// @dev Can only be called from the vault factory.\\n    function initializeImplementation(\\n        address vault,\\n        address implementation\\n    ) external;\\n\\n    /// @notice Updates the `vault` implementation to an address from the factory.\\n    /// @param vault Address of the vault to be upgraded.\\n    /// @param version The version number of the new implementation from the `_implementations` array.\\n    ///\\n    /// @dev This function can only be called by the owner of the vault.\\n    /// @dev The version specified should be an existing version in the factory\\n    /// and must not be the current implementation of the vault.\\n    /// @dev If the function caller is not the owner of the vault, it reverts with\\n    /// `VaultProxyAdmin_SenderIsNotVaultOwner`.\\n    /// @dev If the specified `version` number is outside the valid range of the implementations\\n    /// or is zero, it reverts with `VaultProxyAdmin_VersionDoesNotExist`.\\n    /// @dev If the specified version  is the current implementation, it reverts\\n    /// with `VaultProxyAdmin_CannotUpdateToCurrentVersion`.\\n    function upgrade(address vault, uint256 version) external;\\n}\\n\"\r\n    },\r\n    \"src/external/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title IOwnable - Ownable Interface\\n/// @dev Contract module which provides a basic access control mechanism, where\\n/// there is an account (an owner) that can be granted exclusive access to\\n/// specific functions.\\n///\\n/// By default, the owner account will be the one that deploys the contract. This\\n/// can later be changed with {transferOwnership}.\\n///\\n/// This module is used through inheritance. It will make available the modifier\\n/// `onlyOwner`, which can be applied to your functions to restrict their use to\\n/// the owner.\\ninterface IOwnable {\\n    // =========================\\n    // Events\\n    // =========================\\n\\n    /// @notice Emits when ownership of the contract is transferred from `previousOwner`\\n    /// to `newOwner`.\\n    /// @param previousOwner The address of the previous owner.\\n    /// @param newOwner The address of the new owner.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // =========================\\n    // Errors\\n    // =========================\\n\\n    /// @notice Thrown when the caller is not authorized to perform an operation.\\n    /// @param sender The address of the sender trying to access a restricted function.\\n    error Ownable_SenderIsNotOwner(address sender);\\n\\n    /// @notice Thrown when the new owner is not a valid owner account.\\n    error Ownable_NewOwnerCannotBeAddressZero();\\n\\n    // =========================\\n    // Main functions\\n    // =========================\\n\\n    /// @notice Returns the address of the current owner.\\n    /// @return The address of the current owner.\\n    function owner() external view returns (address);\\n\\n    /// @notice Leaves the contract without an owner. It will not be possible to call\\n    /// `onlyOwner` functions anymore.\\n    /// @dev Can only be called by the current owner.\\n    function renounceOwnership() external;\\n\\n    /// @notice Transfers ownership of the contract to a new account (`newOwner`).\\n    /// @param newOwner The address of the new owner.\\n    /// @dev Can only be called by the current owner.\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"@aave/=lib/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@gelato/=lib/gelato/\",\r\n      \"aave-v3-core/=lib/aave-v3-core/\",\r\n      \"aave-v3-periphery/=lib/aave-v3-periphery/contracts/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"erc4626-tests/=lib/chainlink/contracts/foundry-lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"gelato/=lib/gelato/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"VaultProxyAdmin_CallerIsNotFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultProxyAdmin_CannotUpdateToCurrentVersion\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultProxyAdmin_SenderIsNotVaultOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultProxyAdmin_VersionDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"initializeImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultFactory\",\"outputs\":[{\"internalType\":\"contract IVaultFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultProxyAdmin", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ab5f025297e40bd5ecf340d1709008eff230c6ca", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}