{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.9;\\n\\ninterface IERC20 {\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ITokenBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IWormhole.sol\\\";\\n\\ninterface ITokenBridge {\\n    struct Transfer {\\n        uint8 payloadID;\\n        uint256 amount;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        bytes32 to;\\n        uint16 toChain;\\n        uint256 fee;\\n    }\\n\\n    struct TransferWithPayload {\\n        uint8 payloadID;\\n        uint256 amount;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        bytes32 to;\\n        uint16 toChain;\\n        bytes32 fromAddress;\\n        bytes payload;\\n    }\\n\\n    struct AssetMeta {\\n        uint8 payloadID;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        uint8 decimals;\\n        bytes32 symbol;\\n        bytes32 name;\\n    }\\n\\n    struct RegisterChain {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chainId;\\n\\n        uint16 emitterChainID;\\n        bytes32 emitterAddress;\\n    }\\n\\n     struct UpgradeContract {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chainId;\\n\\n        bytes32 newContract;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n\\n    event TransferRedeemed(uint16 indexed emitterChainId, bytes32 indexed emitterAddress, uint64 indexed sequence);\\n\\n    function _parseTransferCommon(bytes memory encoded) external pure returns (Transfer memory transfer);\\n\\n    function attestToken(address tokenAddress, uint32 nonce) external payable returns (uint64 sequence);\\n\\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);\\n\\n    function wrapAndTransferETHWithPayload(uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);\\n\\n    function transferTokens(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce) external payable returns (uint64 sequence);\\n\\n    function transferTokensWithPayload(address token, uint256 amount, uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload) external payable returns (uint64 sequence);\\n\\n    function updateWrapped(bytes memory encodedVm) external returns (address token);\\n\\n    function createWrapped(bytes memory encodedVm) external returns (address token);\\n\\n    function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);\\n\\n    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) external returns (bytes memory);\\n\\n    function completeTransfer(bytes memory encodedVm) external;\\n\\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) external;\\n\\n    function encodeAssetMeta(AssetMeta memory meta) external pure returns (bytes memory encoded);\\n\\n    function encodeTransfer(Transfer memory transfer) external pure returns (bytes memory encoded);\\n\\n    function encodeTransferWithPayload(TransferWithPayload memory transfer) external pure returns (bytes memory encoded);\\n\\n    function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);\\n\\n    function parseAssetMeta(bytes memory encoded) external pure returns (AssetMeta memory meta);\\n\\n    function parseTransfer(bytes memory encoded) external pure returns (Transfer memory transfer);\\n\\n    function parseTransferWithPayload(bytes memory encoded) external pure returns (TransferWithPayload memory transfer);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\\n\\n    function wormhole() external view returns (IWormhole);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);\\n\\n    function bridgeContracts(uint16 chainId_) external view returns (bytes32);\\n\\n    function tokenImplementation() external view returns (address);\\n\\n    function WETH() external view returns (IWETH);\\n\\n    function outstandingBridged(address token) external view returns (uint256);\\n\\n    function isWrappedAsset(address token) external view returns (bool);\\n\\n    function finality() external view returns (uint8);\\n\\n    function implementation() external view returns (address);\\n\\n    function initialize() external;\\n\\n    function registerChain(bytes memory encodedVM) external;\\n\\n    function upgrade(bytes memory encodedVM) external;\\n\\n    function submitRecoverChainId(bytes memory encodedVM) external;\\n\\n    function parseRegisterChain(bytes memory encoded) external pure returns (RegisterChain memory chain);\\n\\n    function parseUpgrade(bytes memory encoded) external pure returns (UpgradeContract memory chain);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId) external pure returns (RecoverChainId memory rci);\\n}\\n\"\r\n    },\r\n    \"contracts/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20{\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/IWormhole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.9;\\n\\ninterface IWormhole {\\n  struct GuardianSet {\\n    address[] keys;\\n    uint32 expirationTime;\\n  }\\n\\n  struct Signature {\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n    uint8 guardianIndex;\\n  }\\n\\n  /**\\n  struct Signature {\\n    uint8 index;\\n    bytes signature;\\n    string name;\\n  }\\n   */\\n\\n  struct VM {\\n    uint8 version;\\n    uint32 timestamp;\\n    uint32 nonce;\\n    uint16 emitterChainId;\\n    bytes32 emitterAddress;\\n    uint64 sequence;\\n    uint8 consistencyLevel;\\n    bytes payload;\\n    uint32 guardianSetIndex;\\n    Signature[] signatures;\\n    bytes32 hash;\\n  }\\n\\n  struct ContractUpgrade {\\n    bytes32 module;\\n    uint8 action;\\n    uint16 chain;\\n    address newContract;\\n  }\\n\\n  struct GuardianSetUpgrade {\\n    bytes32 module;\\n    uint8 action;\\n    uint16 chain;\\n    GuardianSet newGuardianSet;\\n    uint32 newGuardianSetIndex;\\n  }\\n\\n  struct SetMessageFee {\\n    bytes32 module;\\n    uint8 action;\\n    uint16 chain;\\n    uint256 messageFee;\\n  }\\n\\n  struct TransferFees {\\n    bytes32 module;\\n    uint8 action;\\n    uint16 chain;\\n    uint256 amount;\\n    bytes32 recipient;\\n  }\\n\\n  struct RecoverChainId {\\n    bytes32 module;\\n    uint8 action;\\n    uint256 evmChainId;\\n    uint16 newChainId;\\n  }\\n\\n  event LogMessagePublished(address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel);\\n  event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n  event GuardianSetAdded(uint32 indexed index);\\n\\n  function publishMessage(uint32 nonce, bytes memory payload, uint8 consistencyLevel) external payable returns (uint64 sequence);\\n\\n  function testSigs() external returns (Signature[] memory signatures);\\n\\n  function test8() external returns (uint8 test);\\n\\n  function testBytes() external returns (bytes memory payload);\\n\\n  function testBigKahuna() external returns (VM memory vm);\\n\\n  function initialize() external;\\n\\n  function parseAndVerifyVM(bytes calldata encodedVM) external view returns (VM memory vm, bool valid, string memory reason);\\n\\n  function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\\n\\n  function verifySignatures(\\n    bytes32 hash,\\n    Signature[] memory signatures,\\n    GuardianSet memory guardianSet\\n  ) external pure returns (bool valid, string memory reason);\\n\\n  function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\\n\\n  function quorum(uint numGuardians) external pure returns (uint numSignaturesRequiredForQuorum);\\n\\n  function getGuardianSet(uint32 index) external view returns (GuardianSet memory);\\n\\n  function getCurrentGuardianSetIndex() external view returns (uint32);\\n\\n  function getGuardianSetExpiry() external view returns (uint32);\\n\\n  function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n  function isInitialized(address impl) external view returns (bool);\\n\\n  function chainId() external view returns (uint16);\\n\\n  function isFork() external view returns (bool);\\n\\n  function governanceChainId() external view returns (uint16);\\n\\n  function governanceContract() external view returns (bytes32);\\n\\n  function messageFee() external view returns (uint256);\\n\\n  function evmChainId() external view returns (uint256);\\n\\n  function nextSequence(address emitter) external view returns (uint64);\\n\\n  function parseContractUpgrade(bytes memory encodedUpgrade) external pure returns (ContractUpgrade memory cu);\\n\\n  function parseGuardianSetUpgrade(bytes memory encodedUpgrade) external pure returns (GuardianSetUpgrade memory gsu);\\n\\n  function parseSetMessageFee(bytes memory encodedSetMessageFee) external pure returns (SetMessageFee memory smf);\\n\\n  function parseTransferFees(bytes memory encodedTransferFees) external pure returns (TransferFees memory tf);\\n\\n  function parseRecoverChainId(bytes memory encodedRecoverChainId) external pure returns (RecoverChainId memory rci);\\n\\n  function submitContractUpgrade(bytes memory _vm) external;\\n\\n  function submitSetMessageFee(bytes memory _vm) external;\\n\\n  function submitNewGuardianSet(bytes memory _vm) external;\\n\\n  function submitTransferFees(bytes memory _vm) external;\\n\\n  function submitRecoverChainId(bytes memory _vm) external;\\n}\\n\"\r\n    },\r\n    \"contracts/oz/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/oz/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/oz/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"\r\n    },\r\n    \"contracts/oz/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {Context} from \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is set to the address provided by the deployer. This can\\r\\n * later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address initialOwner) {\\r\\n        if (initialOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/oz/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"contracts/oz/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\nimport {Address} from \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Portico.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.9;\\n\\nimport \\\"./PorticoStructs.sol\\\";\\nimport \\\"./ITokenBridge.sol\\\";\\nimport \\\"./IWormhole.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IWETH.sol\\\";\\n\\n//uniswap\\nimport \\\"./uniswap/ISwapRouter02.sol\\\";\\n\\n//oz\\nimport \\\"./oz/Ownable.sol\\\";\\nimport \\\"./oz/ReentrancyGuard.sol\\\";\\nimport \\\"./oz/SafeERC20.sol\\\";\\n\\ncontract PorticoBase is Ownable, ReentrancyGuard {\\n  using SafeERC20 for IERC20;\\n\\n  ISwapRouter02 public immutable ROUTERV3;\\n  ITokenBridge public immutable TOKENBRIDGE;\\n  IWETH public immutable WETH;\\n  IWormhole public immutable wormhole;\\n  uint16 public immutable wormholeChainId;\\n\\n  address public FEE_RECIPIENT;\\n\\n  constructor(ISwapRouter02 _routerV3, ITokenBridge _bridge, IWETH _weth, address _feeRecipient) Ownable(_msgSender()) {\\n    ROUTERV3 = _routerV3;\\n    TOKENBRIDGE = _bridge;\\n    wormhole = _bridge.wormhole();\\n    WETH = _weth;\\n    wormholeChainId = wormhole.chainId();\\n    FEE_RECIPIENT = _feeRecipient;\\n  }\\n\\n  function version() external pure returns (uint32) {\\n    return 1;\\n  }\\n\\n  ///@notice config recipient for relayer fees\\n  function setFeeRecipient(address newFeeRecipient) external onlyOwner {\\n    FEE_RECIPIENT = newFeeRecipient;\\n  }\\n\\n  ///@notice if current approval is insufficient, approve max\\n  ///@notice oz safeIncreaseAllowance controls for tokens that require allowance to be reset to 0 before increasing again\\n  function updateApproval(address spender, IERC20 token, uint256 amount) internal {\\n    // get current allowance\\n    uint256 currentAllowance = token.allowance(address(this), spender);\\n    if (currentAllowance < amount) {\\n      // amount is a delta, so need to pass max - current to avoid overflow\\n      token.safeIncreaseAllowance(spender, type(uint256).max - (currentAllowance + 1));\\n    }\\n  }\\n}\\n\\nabstract contract PorticoStart is PorticoBase {\\n  using PorticoFlagSetAccess for PorticoFlagSet;\\n  using SafeERC20 for IERC20;\\n\\n  function _start_v3swap(PorticoStructs.TradeParameters memory params, uint256 actualAmount) internal returns (uint256 amount) {\\n    updateApproval(address(ROUTERV3), params.startTokenAddress, actualAmount);\\n\\n    ROUTERV3.exactInputSingle(\\n      ISwapRouter02.ExactInputSingleParams(\\n        address(params.startTokenAddress), //tokenIn\\n        address(params.canonAssetAddress), //tokenOut\\n        params.flags.feeTierStart(), //fee\\n        address(this), //recipient\\n        actualAmount, //amountIn\\n        params.minAmountStart, //minAmountReceived\\n        0\\n      )\\n    );\\n\\n    amount = params.canonAssetAddress.balanceOf(address(this));\\n  }\\n\\n  event PorticoSwapStart(uint64 indexed sequence, uint16 indexed chainId);\\n\\n  function start(\\n    PorticoStructs.TradeParameters memory params\\n  ) external payable nonReentrant returns (address emitterAddress, uint16 chainId, uint64 sequence) {\\n    uint256 amount;\\n    uint256 whMessageFee = wormhole.messageFee();\\n    uint256 value = msg.value;\\n    // always check for native wrapping logic\\n    if (address(params.startTokenAddress) == address(WETH) && params.flags.shouldWrapNative()) {\\n      // if wrapping, msg.value should be exactly amountSpecified + wormhole message fee\\n      require(value == params.amountSpecified + whMessageFee, \\\"msg.value incorrect\\\");\\n      // if we are wrapping a token, we call WETH.deposit for the user, assuming we have been sent what we need.\\n      WETH.deposit{ value: params.amountSpecified }();\\n      // because wormhole rounds to 1e8, some dust may exist from previous txs\\n      // we use balanceOf to lump this in with future txs\\n      amount = WETH.balanceOf(address(this));\\n    } else {\\n      // ensure no eth needs to be refunded\\n      require(value == whMessageFee, \\\"msg.value incorrect\\\");\\n      // otherwise, just get the token we need to do the swap (if we are swapping, or just the token itself)\\n      params.startTokenAddress.safeTransferFrom(_msgSender(), address(this), params.amountSpecified);\\n      // Because wormhole rounds to 1e8, some dust may exist from previous txs\\n      // we use balanceOf to lump this in with future txs\\n      amount = params.startTokenAddress.balanceOf(address(this));\\n    }\\n\\n    // sanity check amount received\\n    require(amount >= params.amountSpecified, \\\"transfer insufficient\\\");\\n\\n    // if the start token is the canon token, we don't need to swap\\n    if (params.startTokenAddress != params.canonAssetAddress) {\\n      // do the swap, and amount is now the amount that we received from the swap\\n      amount = _start_v3swap(params, amount);\\n    }\\n\\n    // allow the token bridge to do its token bridge things\\n    updateApproval(address(TOKENBRIDGE), params.canonAssetAddress, amount);\\n\\n    // now we need to produce the payload we are sending\\n    PorticoStructs.DecodedVAA memory decodedVAA = PorticoStructs.DecodedVAA(\\n      params.flags,\\n      params.finalTokenAddress,\\n      params.recipientAddress,\\n      amount,\\n      params.minAmountFinish,\\n      params.relayerFee\\n    );\\n\\n    // send the actual transfer tx, and get the sequence\\n    sequence = TOKENBRIDGE.transferTokensWithPayload{ value: whMessageFee }(\\n      address(params.canonAssetAddress),\\n      amount,\\n      params.flags.recipientChain(),\\n      padAddress(params.recipientPorticoAddress),\\n      params.flags.bridgeNonce(),\\n      abi.encode(decodedVAA)\\n    );\\n\\n    // local chain id\\n    chainId = wormholeChainId;\\n\\n    // emitter is the local tokenbridge\\n    emitterAddress = address(TOKENBRIDGE);\\n\\n    // emit event\\n    emit PorticoSwapStart(sequence, chainId);\\n  }\\n\\n  ///@notice @return addr in bytes32 format, as required by Wormhole\\n  function padAddress(address addr) internal pure returns (bytes32) {\\n    return bytes32(uint256(uint160(addr)));\\n  }\\n}\\n\\nabstract contract PorticoFinish is PorticoBase {\\n  using PorticoFlagSetAccess for PorticoFlagSet;\\n  using SafeERC20 for IERC20;\\n\\n  event PorticoSwapFinish(bool swapCompleted, uint256 finaluserAmount, uint256 relayerFeeAmount, PorticoStructs.DecodedVAA data);\\n\\n  // receiveMessageAndSwap is the entrypoint for finishing the swap\\n  function receiveMessageAndSwap(bytes calldata encodedTransferMessage) external nonReentrant {\\n    // start by calling _completeTransfer, submitting the VAA to the token bridge\\n    (PorticoStructs.DecodedVAA memory message, PorticoStructs.BridgeInfo memory bridgeInfo) = _completeTransfer(encodedTransferMessage);\\n\\n    // we modify the message to set the relayerFee to 0 if the msgSender is the fee recipient\\n    // this allows users to self-relay and not pay the fee, even if the fee was set to non-zero at tx origin\\n    bridgeInfo.relayerFeeAmount = (_msgSender() == message.recipientAddress) ? 0 : message.relayerFee;\\n\\n    //now process\\n    (bool swapCompleted, uint256 finalUserAmount) = finish(message, bridgeInfo);\\n\\n    // simply emit the raw data bytes. it should be trivial to parse.\\n    emit PorticoSwapFinish(swapCompleted, finalUserAmount, bridgeInfo.relayerFeeAmount, message);\\n  }\\n\\n  // _completeTransfer takes the vaa for a payload3 token transfer, redeems it with the token bridge, and returns the decoded vaa payload\\n  function _completeTransfer(\\n    bytes calldata encodedTransferMessage\\n  ) internal returns (PorticoStructs.DecodedVAA memory message, PorticoStructs.BridgeInfo memory bridgeInfo) {\\n    /**\\n     * Call `completeTransferWithPayload` on the token bridge. This\\n     * method acts as a reentrancy protection since it does not allow\\n     * transfers to be redeemed more than once.\\n     */\\n    bytes memory transferPayload = TOKENBRIDGE.completeTransferWithPayload(encodedTransferMessage);\\n\\n    // parse the wormhole message payload into the `TransferWithPayload` struct, a payload3 token transfer\\n    ITokenBridge.TransferWithPayload memory transfer = TOKENBRIDGE.parseTransferWithPayload(transferPayload);\\n\\n    // ensure that the to address is this address\\n    require(unpadAddress(transfer.to) == address(this) && transfer.toChain == wormholeChainId, \\\"Token not sent to this address\\\");\\n\\n    // decode the payload3 we originally sent into the decodedVAA struct.\\n    message = abi.decode(transfer.payload, (PorticoStructs.DecodedVAA));\\n    // get the address for the token on this address.\\n    bridgeInfo.tokenReceived = IERC20(\\n      transfer.tokenChain == wormholeChainId\\n        ? unpadAddress(transfer.tokenAddress)\\n        : TOKENBRIDGE.wrappedAsset(transfer.tokenChain, transfer.tokenAddress)\\n    );\\n\\n    // put the transfer amount into amountReceived, knowing we may need to change it in a sec\\n    bridgeInfo.amountReceived = transfer.amount;\\n\\n    // if there are more than 8 decimals, we need to denormalize. wormhole token bridge truncates tokens of more than 8 decimals to 8 decimals.\\n    uint8 decimals = bridgeInfo.tokenReceived.decimals();\\n    if (decimals > 8) {\\n      bridgeInfo.amountReceived *= uint256(10) ** (decimals - 8);\\n    }\\n  }\\n\\n  ///@notice determines we need to swap and/or unwrap, does those things if needed, and sends tokens to user & pays relayer fee\\n  function finish(\\n    PorticoStructs.DecodedVAA memory params,\\n    PorticoStructs.BridgeInfo memory bridgeInfo\\n  ) internal returns (bool swapCompleted, uint256 finalUserAmount) {\\n    // see if the unwrap flag is set, and that the finalTokenAddress is the address we have set on deploy as our native weth9 address\\n    bool shouldUnwrap = params.flags.shouldUnwrapNative() && address(params.finalTokenAddress) == address(WETH);\\n    if ((params.finalTokenAddress) == bridgeInfo.tokenReceived) {\\n      // this means that we don't need to do a swap, aka, we received the canon asset.\\n      finalUserAmount = payOut(shouldUnwrap, params.finalTokenAddress, params.recipientAddress, bridgeInfo.relayerFeeAmount);\\n      return (false, finalUserAmount);\\n    }\\n\\n    // if we are here, if means we need to do the swap, resulting aset from the swap is sent to this contract\\n    swapCompleted = _finish_v3swap(params, bridgeInfo);\\n\\n    // if the swap fails, we just transfer the amount we received from the token bridge to the recipientAddress.\\n    if (!swapCompleted) {\\n      bridgeInfo.tokenReceived.transfer(params.recipientAddress, bridgeInfo.amountReceived);\\n      // we also mark swapCompleted to be false for PorticoSwapFinish event\\n      return (swapCompleted, bridgeInfo.amountReceived);\\n    }\\n    // we must call payout if the swap was completed\\n    finalUserAmount = payOut(shouldUnwrap, params.finalTokenAddress, params.recipientAddress, bridgeInfo.relayerFeeAmount);\\n  }\\n\\n  /**\\n   * @notice perform the swap via Uniswap V3 Router\\n   * if swap fails, we don't pay fees to the relayer\\n   * the reason is because that typically, the swap fails because of bad market conditions\\n   * in this case, it is in the best interest of the mev/relayer to NOT relay this message until conditions are good\\n   * the user of course, who if they self relay, does not pay a fee, does not have this problem, so they can force this if they wish\\n   * swap failed - return canon asset to recipient\\n   * it will return true if the swap was completed, indicating that funds need to be sent from this contract to the recipient\\n   */\\n  function _finish_v3swap(\\n    PorticoStructs.DecodedVAA memory params,\\n    PorticoStructs.BridgeInfo memory bridgeInfo\\n  ) internal returns (bool swapCompleted) {\\n    // set swap options with params decoded from the payload\\n    ISwapRouter02.ExactInputSingleParams memory swapParams = ISwapRouter02.ExactInputSingleParams({\\n      tokenIn: address(bridgeInfo.tokenReceived),\\n      tokenOut: address(params.finalTokenAddress),\\n      fee: params.flags.feeTierFinish(),\\n      recipient: address(this), // we need to receive the token in order to correctly split the fee. tragic.\\n      amountIn: bridgeInfo.amountReceived,\\n      amountOutMinimum: params.minAmountFinish,\\n      sqrtPriceLimitX96: 0 //sqrtPriceLimit is not used\\n    });\\n\\n    // update approval\\n    updateApproval(address(ROUTERV3), bridgeInfo.tokenReceived, bridgeInfo.amountReceived);\\n\\n    // try the swap\\n    try ROUTERV3.exactInputSingle(swapParams) {\\n      swapCompleted = true;\\n    } catch {}\\n  }\\n\\n  ///@notice pay out to user and relayer\\n  ///@notice this should always be called UNLESS swap fails, in which case payouts happen there\\n  // NOTE if relayerFeeAmount is incorrectly scaled, then the end user may receive nothing, and all proceeds go to relayer\\n  // it is incumbent upon the cross chain tx origin to ensure the relayerFeeAmount is passed correctly\\n  function payOut(bool unwrap, IERC20 finalToken, address recipient, uint256 relayerFeeAmount) internal returns (uint256 finalUserAmount) {\\n    uint256 totalBalance = finalToken.balanceOf(address(this));\\n\\n    // square up balances with what we actually have, don't trust reporting from the bridge\\n    if (relayerFeeAmount > totalBalance) {\\n      // control for underflow\\n      finalUserAmount = 0;\\n      relayerFeeAmount = totalBalance;\\n    } else {\\n      // user gets total - relayer fee\\n      finalUserAmount = totalBalance - relayerFeeAmount;\\n    }\\n\\n    // if feeRecipient is not set, then send fees to msg.sender\\n    address feeRecipient = FEE_RECIPIENT == address(0x0) ? _msgSender() : FEE_RECIPIENT;\\n\\n    if (unwrap) {\\n      WETH.withdraw(WETH.balanceOf(address(this)));\\n      if (finalUserAmount > 0) {\\n        // send to user\\n        sendEther(recipient, finalUserAmount);\\n      }\\n      if (relayerFeeAmount > 0) {\\n        // pay relayer fee\\n        sendEther(feeRecipient, relayerFeeAmount);\\n      }\\n    } else {\\n      // send to user\\n      if (finalUserAmount > 0) {\\n        finalToken.safeTransfer(recipient, finalUserAmount);\\n      }\\n      if (relayerFeeAmount > 0) {\\n        // pay relayer fee\\n        finalToken.safeTransfer(feeRecipient, relayerFeeAmount);\\n      }\\n    }\\n  }\\n\\n  receive() external payable {}\\n\\n  ///@dev https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/main/src/Utils.sol#L10-L15\\n  function unpadAddress(bytes32 whFormatAddress) internal pure returns (address) {\\n    if (uint256(whFormatAddress) >> 160 != 0) {\\n      revert(\\\"Not EVM Addr\\\");\\n    }\\n    return address(uint160(uint256(whFormatAddress)));\\n  }\\n\\n  ///@notice send ether without exposing to gas griefing attacks via returned bytes\\n  function sendEther(address to, uint256 value) internal {\\n    bool sent;\\n    assembly {\\n      sent := call(gas(), to, value, 0, 0, 0, 0)\\n    }\\n    if (!sent) {\\n      revert(\\\"failed to send ether\\\");\\n    }\\n  }\\n}\\n\\ncontract Portico is PorticoFinish, PorticoStart {\\n  constructor(\\n    ISwapRouter02 _routerV3,\\n    ITokenBridge _bridge,\\n    IWETH _weth,\\n    address _feeRecipient\\n  ) PorticoBase(_routerV3, _bridge, _weth, _feeRecipient) {}\\n}\\n\"\r\n    },\r\n    \"contracts/PorticoStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ntype PorticoFlagSet is bytes32;\\n\\nlibrary PorticoFlagSetAccess {\\n  // the portico uses one word (32 bytes) to represent a large amount of variables\\n\\n  // bytes 0-1 is the recipient chain\\n  function recipientChain(PorticoFlagSet flagset) internal pure returns (uint16 ans) {\\n    assembly {\\n      ans := add(byte(0, flagset), shl(8, byte(1, flagset)))\\n    }\\n  }\\n\\n  // bytes 2-5 is the bridge nonce\\n  function bridgeNonce(PorticoFlagSet flagset) internal pure returns (uint32 ans) {\\n    assembly {\\n      ans := add(add(add(byte(2, flagset), shl(8, byte(3, flagset))), shl(16, byte(4, flagset))), shl(24, byte(5, flagset)))\\n    }\\n  }\\n\\n  // bytes 6,7,8 is the fee tier for start path\\n  function feeTierStart(PorticoFlagSet flagset) internal pure returns (uint24 ans) {\\n    assembly {\\n      ans := add(add(byte(6, flagset), shl(8, byte(7, flagset))), shl(16, byte(8, flagset)))\\n    }\\n  }\\n\\n  // bytes 9,10,11 is the fee tier for finish path\\n  function feeTierFinish(PorticoFlagSet flagset) internal pure returns (uint24 ans) {\\n    assembly {\\n      ans := add(add(byte(9, flagset), shl(8, byte(10, flagset))), shl(16, byte(11, flagset)))\\n    }\\n  }\\n  \\n  // shouldWrapNative is the first bit of the byte 31\\n  function shouldWrapNative(PorticoFlagSet flagset) internal pure returns (bool) {\\n    bytes32 fs = PorticoFlagSet.unwrap(flagset);\\n    return uint8(fs[31]) & (1 << 0) > 0;\\n  }\\n\\n  // shouldUnwrapNative is the second bit of byte 31\\n  function shouldUnwrapNative(PorticoFlagSet flagset) internal pure returns (bool) {\\n    bytes32 fs = PorticoFlagSet.unwrap(flagset);\\n    return uint8(fs[31]) & (1 << 1) > 0;\\n  }\\n}\\n\\nlibrary PorticoStructs {\\n  //https://github.com/wormhole-foundation/wormhole-solidity-sdk/blob/main/src/WormholeRelayerSDK.sol#L177\\n  //https://docs.wormhole.com/wormhole/quick-start/tutorials/hello-token#receiving-a-token\\n  struct TokenReceived {\\n    bytes32 tokenHomeAddress;\\n    uint16 tokenHomeChain;\\n    IERC20 tokenAddress;\\n    uint256 amount;\\n  }\\n\\n  //268,090 - to beat\\n  struct TradeParameters {\\n    PorticoFlagSet flags;\\n    IERC20 startTokenAddress;\\n    IERC20 canonAssetAddress;\\n    IERC20 finalTokenAddress;\\n    // address of the recipient on the recipientChain\\n    address recipientAddress;\\n    // address of the portico on the recipient chain\\n    address recipientPorticoAddress;\\n    // the amount of the token that the person wishes to transfer\\n    uint256 amountSpecified;\\n    uint256 minAmountStart;\\n    uint256 minAmountFinish;\\n    uint256 relayerFee; // the amount of tokens of the recipient to give to the relayer\\n  }\\n  //268,041 158,788\\n  struct DecodedVAA {\\n    PorticoFlagSet flags;\\n    IERC20 finalTokenAddress;\\n    // the person to receive the token\\n    address recipientAddress;\\n    // the x asset amount expected to  be received\\n    uint256 canonAssetAmount;\\n    uint256 minAmountFinish;\\n    uint256 relayerFee;\\n  }\\n\\n  struct BridgeInfo {\\n    IERC20 tokenReceived;\\n    uint256 amountReceived;\\n    uint256 relayerFeeAmount;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswap/ISwapRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter02 {\\n  function factory() external view returns (address);\\n\\n  //frusturatingly, there is no deadline in this set of params\\n  //used on SwapRouter02 on Base chain\\n  struct ExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n  /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\\n  /// and swap the entire amount, enabling contracts to send tokens before calling this function.\\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISwapRouter02\",\"name\":\"_routerV3\",\"type\":\"address\"},{\"internalType\":\"contract ITokenBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swapCompleted\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finaluserAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relayerFeeAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"PorticoFlagSet\",\"name\":\"flags\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"finalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"canonAssetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountFinish\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct PorticoStructs.DecodedVAA\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"PorticoSwapFinish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"}],\"name\":\"PorticoSwapStart\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_RECIPIENT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTERV3\",\"outputs\":[{\"internalType\":\"contract ISwapRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKENBRIDGE\",\"outputs\":[{\"internalType\":\"contract ITokenBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTransferMessage\",\"type\":\"bytes\"}],\"name\":\"receiveMessageAndSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"PorticoFlagSet\",\"name\":\"flags\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"startTokenAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"canonAssetAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"finalTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipientPorticoAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountSpecified\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountFinish\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct PorticoStructs.TradeParameters\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"start\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"emitterAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"sequence\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wormhole\",\"outputs\":[{\"internalType\":\"contract IWormhole\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wormholeChainId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Portico", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b971ef87ede563556b2ed4b1c0b0019111dd85d2000000000000000000000000b6f6d86a8f9879a9c87f643768d9efc38c1da6e70000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f80000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}