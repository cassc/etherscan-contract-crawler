{"SourceCode": "{\"Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to array types.\\r\\n */\\r\\nlibrary Arrays {\\r\\n\\r\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\r\\n        if (array.length == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 low = 0;\\r\\n        uint256 high = array.length;\\r\\n\\r\\n        while (low \\u003c high) {\\r\\n            uint256 mid = average(low, high);\\r\\n            if (array[mid] \\u003e element) {\\r\\n                high = mid;\\r\\n            } else {\\r\\n                low = mid + 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (low \\u003e 0 \\u0026\\u0026 array[low - 1] == element) {\\r\\n            return low - 1;\\r\\n        } else {\\r\\n            return low;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow.\\r\\n        return (a \\u0026 b) + (a ^ b) / 2;\\r\\n    }\\r\\n\\r\\n}\"},\"AutomaticBuyback.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IPancakeSwap.sol\\\";\\r\\nimport \\\"./IAutomaticBuyback.sol\\\";\\r\\n\\r\\ncontract AutomaticBuyback is IAutomaticBuyback {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address private _token;                     // Caller Smart Contract\\r\\n    bool private initialized;\\r\\n\\r\\n    IBEP20 private cumulatedToken;              // Cumulated token (stablecoin BUSD)\\r\\n    IBEP20 private buybackToken;                // The token to buyback using all the cumulatedToken balance\\r\\n    uint256 private buybackPeriod;              // Buyback period in days. CAN ONLY BE 30 days, 60 days or 90 days\\r\\n    uint256 private buybackPeriodNew;           // Used to update the buyback period\\r\\n    uint256 private buyback_timestamp;          // The next buyback timestamp\\r\\n    uint256 private totalBuyedBackAlltime;      // Total bought back alltime\\r\\n    IPancakeRouter02 private pancakeRouter;     // The DEX router\\r\\n\\r\\n    uint256 private constant TIME_UNIT = 1 days;\\r\\n    uint256 private constant INSTANT_UPDATE_FORBIDDEN_TH = 7 * TIME_UNIT;          // Days before the buyback\\r\\n    uint256 private constant CUMULATED_TOKEN_CHANGE_PERIOD_TH = 5 * TIME_UNIT;     // Days after the buyback\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token, \\\"Unauthorized\\\"); _;\\r\\n    }\\r\\n\\r\\n    constructor () {}\\r\\n\\r\\n    function initialize(address _pancakeRouterAddress, address _cumulatedTokenAddress, address _buybackTokenAddress) external override {\\r\\n        require(!initialized, \\\"AutomaticBuyback: already initialized!\\\");\\r\\n        initialized = true;\\r\\n        _token = msg.sender;\\r\\n        cumulatedToken = IBEP20(_cumulatedTokenAddress);\\r\\n        buybackToken = IBEP20(_buybackTokenAddress);\\r\\n        pancakeRouter = IPancakeRouter02(_pancakeRouterAddress);\\r\\n        _changeBuybackPeriod(30);   // Set default period of 30 days\\r\\n        emit Initialized(_token, address(cumulatedToken), address(buybackToken), address(pancakeRouter));\\r\\n    }\\r\\n\\r\\n    // Trigger to call at every transaction. If the buyback timestamp is reached the buyback will be executed, returning true\\r\\n    // Otherwise nothing will be executed, returning false\\r\\n    function trigger() external override onlyToken returns (bool buyback_executed) {\\r\\n        if (block.timestamp \\u003e= buyback_timestamp) {\\r\\n            // Execute the buyback\\r\\n            _buybackAll();\\r\\n            // Set next buyback\\r\\n            if (buybackPeriodNew != buybackPeriod) {\\r\\n                buybackPeriod = buybackPeriodNew;\\r\\n            }\\r\\n            buyback_timestamp = buyback_timestamp + buybackPeriod * TIME_UNIT;\\r\\n            emit NewBuybackTimestampSet(buybackPeriod, buyback_timestamp);\\r\\n            buyback_executed = true;\\r\\n        } else {\\r\\n            buyback_executed = false;\\r\\n        } \\r\\n    }\\r\\n\\r\\n    // External function to change the buyback period between 30, 60 or 90 days\\r\\n    function changeBuybackPeriod(uint256 newPeriod) external override onlyToken {\\r\\n        require(newPeriod != buybackPeriod, \\\"AutomaticBuyback: the newPeriod must be different from the current period\\\");\\r\\n        require(newPeriod == 30 || newPeriod == 60 || newPeriod == 90, \\\"AutomaticBuyback: the period must be 30, 60 or 90 (days)\\\");\\r\\n        _changeBuybackPeriod(newPeriod);\\r\\n    }\\r\\n\\r\\n    // Change the buyback period. It will be done immediately only if the new period is greater than the old period and the change\\r\\n    // is done at least 7 days before the current buyback timestamp. Otherwise the change is done after the buyback\\r\\n    function _changeBuybackPeriod(uint256 newPeriod) internal {\\r\\n        if (buyback_timestamp == 0) {\\r\\n            buyback_timestamp = block.timestamp + newPeriod * TIME_UNIT;\\r\\n            emit ChangedBuybackPeriod(buybackPeriod, newPeriod, true);\\r\\n            buybackPeriod = newPeriod;\\r\\n            buybackPeriodNew = newPeriod;\\r\\n            emit NewBuybackTimestampSet(buybackPeriod, buyback_timestamp);\\r\\n            return;\\r\\n        }\\r\\n        if (newPeriod \\u003e buybackPeriod) {\\r\\n            if (block.timestamp \\u003c buyback_timestamp - INSTANT_UPDATE_FORBIDDEN_TH) {\\r\\n                // If before 7 days (INSTANT_UPDATE_FORBIDDEN_TH) from the buyback time, we can shift it, otherwise it will be changed after the buyback\\r\\n                buyback_timestamp = (buyback_timestamp - buybackPeriod * TIME_UNIT) + newPeriod * TIME_UNIT;\\r\\n                emit ChangedBuybackPeriod(buybackPeriod, newPeriod, true);\\r\\n                buybackPeriod = newPeriod;\\r\\n                buybackPeriodNew = newPeriod;\\r\\n                emit NewBuybackTimestampSet(buybackPeriod, buyback_timestamp);\\r\\n            } else {\\r\\n                buybackPeriodNew = newPeriod;\\r\\n                emit ChangedBuybackPeriod(buybackPeriod, newPeriod, false);\\r\\n            }\\r\\n        } else {\\r\\n            // Set to update after the next buyback\\r\\n            buybackPeriodNew = newPeriod;\\r\\n            emit ChangedBuybackPeriod(buybackPeriod, newPeriod, false);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    // Buy the buybackToken using all the cumulated cumulatedToken in the contract\\r\\n    // The buybackToken will be sent to the AutomatedBuyback contract (this) and can be burnt from the caller token\\r\\n    // using the internal _burn() function or kept locked forever inside the AutomatedBuyback contract\\r\\n    function _buybackAll() internal {\\r\\n        uint256 tokenAmount = cumulatedToken.balanceOf(address(this));\\r\\n        uint256 previousBuybackBalance = buybackToken.balanceOf(address(this));\\r\\n        if (tokenAmount \\u003e 0) {\\r\\n            address[] memory path = new address[](3);\\r\\n            path[0] = address(cumulatedToken);\\r\\n            path[1] = pancakeRouter.WETH();\\r\\n            path[2] = address(buybackToken);\\r\\n            cumulatedToken.approve(address(pancakeRouter), tokenAmount);\\r\\n            // make the swap\\r\\n            pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n                tokenAmount,\\r\\n                0,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n        uint256 currentBuybackBalance = buybackToken.balanceOf(address(this));\\r\\n        totalBuyedBackAlltime = totalBuyedBackAlltime.add(currentBuybackBalance).sub(previousBuybackBalance);\\r\\n        emit BuybackExecuted(tokenAmount, currentBuybackBalance.sub(previousBuybackBalance), currentBuybackBalance, totalBuyedBackAlltime);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Update the router address \\r\\n    function updateRouterAddress(address newAddress) external override onlyToken {\\r\\n        emit UpdatePancakeRouter(newAddress, address(pancakeRouter));\\r\\n        pancakeRouter = IPancakeRouter02(newAddress);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Change the cumulated token used for the automatic buyback. It must be called just before changing the cumulatedToken in the caller\\r\\n    // After changing the token, the AutomaticBuyback contract is expecting to cumulate and use the new token\\r\\n    function changeCumulatedToken(address newCumulatedTokenAddress) external override onlyToken {\\r\\n        require(newCumulatedTokenAddress != address(buybackToken), \\\"AutomaticBuyback: cumulatedToken cannot be buybackToken\\\");\\r\\n        // Only possible within the first 5 days (CUMULATED_TOKEN_CHANGE_PERIOD_TH) from the last buyback event\\r\\n        require(block.timestamp \\u003c= (buyback_timestamp - buybackPeriod * TIME_UNIT) + CUMULATED_TOKEN_CHANGE_PERIOD_TH, \\\"AutomaticBuyback: cannot change the cumulatedToken used NOW\\\");\\r\\n        emit ChangedAutomaticBuybackCumulatedToken(address(cumulatedToken), newCumulatedTokenAddress);\\r\\n        // Do a forced internal buyback, without changing the next timestamp\\r\\n        _buybackAll();\\r\\n        // Now the cumulatedToken balance is zero, we can switch to the new cumulatedToken\\r\\n        cumulatedToken = IBEP20(newCumulatedTokenAddress);\\r\\n    }\\r\\n\\r\\n    // Return the current status of the AutomaticBuyback and the countdown to the next automatic buyback event\\r\\n    function getAutomaticBuybackStatus() public view override returns (\\r\\n            address automatic_buyback_contract_address,\\r\\n            uint256 next_buyback_timestamp,\\r\\n            uint256 next_buyback_countdown,\\r\\n            uint256 current_buyback_period,\\r\\n            uint256 new_buyback_period,\\r\\n            address current_cumulated_token,\\r\\n            uint256 current_cumulated_balance,\\r\\n            uint256 current_buyback_token_balance,\\r\\n            uint256 total_buyed_back ) {\\r\\n        automatic_buyback_contract_address = address(this);\\r\\n        next_buyback_timestamp = buyback_timestamp;\\r\\n        next_buyback_countdown = block.timestamp \\u003c buyback_timestamp ? buyback_timestamp - block.timestamp : 0;\\r\\n        current_buyback_period = buybackPeriod;\\r\\n        new_buyback_period = buybackPeriodNew;\\r\\n        current_cumulated_token = address(cumulatedToken);\\r\\n        current_cumulated_balance = cumulatedToken.balanceOf(address(this));\\r\\n        current_buyback_token_balance = buybackToken.balanceOf(address(this));\\r\\n        total_buyed_back = totalBuyedBackAlltime;\\r\\n    }\\r\\n\\r\\n}\"},\"BEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./IBEP20Metadata.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IBEP20} interface. The good default one.\\n */\\ncontract BEP20 is Context, IBEP20, IBEP20Metadata {\\n    using SafeMath for uint256;\\n\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address(0), account, amount);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\n        _beforeTokenTransfer(account, address(0), amount);\\n        _balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"},\"BEP20Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// Derived from OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Snapshot.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./BEP20.sol\\\";\\r\\nimport \\\"./Arrays.sol\\\";\\r\\nimport \\\"./Counters.sol\\\";\\r\\n\\r\\nabstract contract BEP20Snapshot is BEP20 {\\r\\n    // Inspired by Jordi Baylina\\u0027s MiniMeToken to record historical balances:\\r\\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\r\\n\\r\\n    using Arrays for uint256[];\\r\\n    using Counters for Counters.Counter;\\r\\n\\r\\n    struct Snapshots {\\r\\n        uint256[] ids;\\r\\n        uint256[] values;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e Snapshots) private _accountBalanceSnapshots;\\r\\n    Snapshots private _totalSupplySnapshots;\\r\\n    Counters.Counter private _currentSnapshotId;\\r\\n\\r\\n    event Snapshot(uint256 id);\\r\\n\\r\\n    function _snapshot() internal virtual returns (uint256) {\\r\\n        _currentSnapshotId.increment();\\r\\n\\r\\n        uint256 currentId = _getCurrentSnapshotId();\\r\\n        emit Snapshot(currentId);\\r\\n        return currentId;\\r\\n    }\\r\\n\\r\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\r\\n        return _currentSnapshotId.current();\\r\\n    }\\r\\n\\r\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\r\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\r\\n\\r\\n        return snapshotted ? value : balanceOf(account);\\r\\n    }\\r\\n\\r\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\r\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\r\\n        return snapshotted ? value : totalSupply();\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual override {\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n        if (from == address(0)) {\\r\\n            // mint\\r\\n            _updateAccountSnapshot(to);\\r\\n            _updateTotalSupplySnapshot();\\r\\n        } else if (to == address(0)) {\\r\\n            // burn\\r\\n            _updateAccountSnapshot(from);\\r\\n            _updateTotalSupplySnapshot();\\r\\n        } else {\\r\\n            // transfer\\r\\n            _updateAccountSnapshot(from);\\r\\n            _updateAccountSnapshot(to);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\r\\n        require(snapshotId \\u003e 0, \\\"BEP0Snapshot: id is 0\\\");\\r\\n        require(snapshotId \\u003c= _getCurrentSnapshotId(), \\\"BEP20Snapshot: nonexistent id\\\");\\r\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\r\\n        if (index == snapshots.ids.length) {\\r\\n            return (false, 0);\\r\\n        } else {\\r\\n            return (true, snapshots.values[index]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateAccountSnapshot(address account) private {\\r\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\r\\n    }\\r\\n\\r\\n    function _updateTotalSupplySnapshot() private {\\r\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\r\\n    }\\r\\n\\r\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\r\\n        uint256 currentId = _getCurrentSnapshotId();\\r\\n        if (_lastSnapshotId(snapshots.ids) \\u003c currentId) {\\r\\n            snapshots.ids.push(currentId);\\r\\n            snapshots.values.push(currentValue);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\r\\n        if (ids.length == 0) {\\r\\n            return 0;\\r\\n        } else {\\r\\n            return ids[ids.length - 1];\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Context Functions to be used instead of msg.sender and msg.data directly (see the issue with GSN meta-transactions)\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Counters\\r\\n * @author Matt Condon (@shrugs)\\r\\n * @dev Provides counters that can only be incremented, decremented or reset.\\r\\n */\\r\\nlibrary Counters {\\r\\n    struct Counter {\\r\\n        uint256 _value; // default: 0\\r\\n    }\\r\\n\\r\\n    function current(Counter storage counter) internal view returns (uint256) {\\r\\n        return counter._value;\\r\\n    }\\r\\n\\r\\n    function increment(Counter storage counter) internal {\\r\\n        unchecked {\\r\\n            counter._value += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function decrement(Counter storage counter) internal {\\r\\n        uint256 value = counter._value;\\r\\n        require(value \\u003e 0, \\\"Counter: decrement overflow\\\");\\r\\n        unchecked {\\r\\n            counter._value = value - 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function reset(Counter storage counter) internal {\\r\\n        counter._value = 0;\\r\\n    }\\r\\n}\"},\"IAutomaticBuyback.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IAutomaticBuyback {\\r\\n    function initialize(address _pancakeRouterAddress, address _cumulatedTokenAddress, address _buybackTokenAddress) external;\\r\\n    function trigger() external returns (bool buyback_executed);\\r\\n    function changeBuybackPeriod(uint256 newPeriod) external;\\r\\n    function updateRouterAddress(address newAddress) external;\\r\\n    function changeCumulatedToken(address newCumulatedTokenAddress) external;\\r\\n    function getAutomaticBuybackStatus() external view returns (\\r\\n            address automatic_buyback_contract_address,\\r\\n            uint256 next_buyback_timestamp,\\r\\n            uint256 next_buyback_countdown,\\r\\n            uint256 current_buyback_period,\\r\\n            uint256 new_buyback_period,\\r\\n            address current_cumulated_token,\\r\\n            uint256 current_cumulated_balance,\\r\\n            uint256 current_buyback_token_balance,\\r\\n            uint256 total_buyed_back );\\r\\n    event Initialized(address indexed _token, address cumulatedToken, address buybackToken, address pancakeRouter);\\r\\n    event UpdatePancakeRouter(address new_router, address old_router);\\r\\n    event ChangedBuybackPeriod(uint256 old_period, uint256 new_period, bool immediate);\\r\\n    event NewBuybackTimestampSet(uint256 period, uint256 buyback_timestamp);\\r\\n    event BuybackExecuted(uint amount_cumulatedToken, uint256 amount_buybackToken, uint256 buybackToken_current_balance, uint256 total_buyed_back_alltime);\\r\\n    event ChangedAutomaticBuybackCumulatedToken(address old_cumulatedToken, address new_cumulatedToken);\\r\\n}\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the BEP20 standard as defined in the EIP.\\n */\\ninterface IBEP20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IBEP20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBEP20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the BEP20 standard.\\n */\\ninterface IBEP20Metadata is IBEP20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\n\"},\"ILPLocker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ILPLocker {\\r\\n    function initialize(uint256 _initial_unlock_ts) external;\\r\\n    function withdrawLP(address _LPaddress, uint256 _amount, address _to) external;\\r\\n    function updateLock(uint256 _newUnlockTimestamp) external;\\r\\n    function getInfoLP(address _LPaddress) external view returns (address locker_address, uint256 LPbalance, uint256 unlock_timestamp, bool unlocked);\\r\\n    event Initialized(address indexed _token, uint256 _initial_unlock_ts);\\r\\n    event LPWithdrawn(address indexed _LPaddress, uint256 _amount, address indexed _to);\\r\\n    event LPLockUpdated(uint256 _oldUnlockTimestamp, uint256 _newUnlockTimestamp);\\r\\n}\"},\"IPancakeSwap.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\n// Interface of the PancakeSwap Router01 (Uniswap Fork) \\n// https://docs.pancakeswap.finance/code/smart-contracts/pancakeswap-exchange/router-v2\\n// https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-01\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\n// SPDX-License-Identifier: MIT\\n// Interface of the PancakeSwap Router02 (Uniswap Fork) - Extends IPancakeSwapV2Router01\\n// https://docs.pancakeswap.finance/code/smart-contracts/pancakeswap-exchange/router-v2\\n// https://docs.uniswap.org/protocol/V2/reference/smart-contracts/router-02\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\n// https://docs.pancakeswap.finance/code/smart-contracts/pancakeswap-exchange/factory-v2\\n// https://docs.uniswap.org/protocol/V2/reference/smart-contracts/factory\\ninterface IPancakeFactory  {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\n// PancakeSwap equivalent of: https://docs.uniswap.org/protocol/V2/reference/smart-contracts/pair\\ninterface IPancakePair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    event Cast(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n    function initialize(address, address) external;\\n}\"},\"IReflectionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IReflectionManager {\\r\\n    function initialize(address _rewardToken) external;\\r\\n    function setShare(address shareholder, uint256 amount) external;\\r\\n    function update_deposit(uint256 amount) external;\\r\\n    function process(uint256 gas) external returns (uint256 currentIndex, uint256 iterations, uint256 claims, bool dismission_completed);\\r\\n    function claimDividend(address shareholder) external;\\r\\n    function dismissReflectionManager() external;\\r\\n    function getUnpaidEarnings(address shareholder) external view returns (uint256);\\r\\n    function setReflectionEnabledContract(address _contractAddress, bool _enableDisable) external;\\r\\n    function setReflectionDisabledWallet(address _walletAddress, bool _disableEnable) external;\\r\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution, uint256 _eligibilityThresholdShares) external;\\r\\n    function setAutoDistributionExcludeFlag(address _shareholder, bool _exclude) external;\\r\\n    function isDismission() external view returns (bool dismission_is_started, bool dismission_is_completed);\\r\\n    function getAccountInfo(address shareholder) external view returns (\\r\\n        uint256 index,\\r\\n        uint256 currentShares,\\r\\n        int256 iterationsUntilProcessed,\\r\\n        uint256 withdrawableDividends,\\r\\n        uint256 totalRealisedDividends,\\r\\n        uint256 totalExcludedDividends,\\r\\n        uint256 lastClaimTime,\\r\\n        uint256 nextClaimTime,\\r\\n        bool shouldAutoDistribute,\\r\\n        bool excludedAutoDistribution,\\r\\n        bool enabled );\\r\\n    function getReflectionManagerInfo() external view returns (\\r\\n        uint256 n_shareholders,\\r\\n        uint256 current_index,\\r\\n        uint256 manager_balance,\\r\\n        uint256 total_shares,\\r\\n        uint256 total_dividends,\\r\\n        uint256 total_distributed,\\r\\n        uint256 dividends_per_share,\\r\\n        uint256 eligibility_threshold_shares,\\r\\n        uint256 min_period,\\r\\n        uint256 min_distribution,\\r\\n        uint8 dismission );\\r\\n    function getShareholderAtIndex(uint256 index) external view returns (address);\\r\\n\\r\\n    event Initialized(address indexed caller, address _rewardToken);\\r\\n    event Claim(address indexed shareholder, uint256 amount, bool indexed automatic);\\r\\n    event setDistributionCriteriaUpdate(uint256 minPeriod, uint256 minDistribution, uint256 eligibilityThresholdShares);\\r\\n    event setReflectionEnabledContractUpdate(address indexed _contractAddress, bool indexed _enableDisable);\\r\\n    event setReflectionDisabledWalletUpdate(address indexed _walletAddress, bool indexed _disableEnable);\\r\\n    event setAutoDistributionExcludeFlagUpdate(address indexed _shareholder, bool indexed _exclude);\\r\\n\\r\\n}\"},\"LPLocker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./ILPLocker.sol\\\";\\r\\n\\r\\ncontract LPLocker is ILPLocker {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address private _token;      // Caller Smart Contract\\r\\n    bool private initialized;\\r\\n\\r\\n    uint256 private unlock_ts;\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token, \\\"Unauthorized\\\"); _;\\r\\n    }\\r\\n\\r\\n    constructor () {}\\r\\n\\r\\n    function initialize(uint256 _initial_unlock_ts) external override {\\r\\n        require(!initialized, \\\"LPLocker: already initialized!\\\");\\r\\n        initialized = true;\\r\\n        _token = msg.sender;\\r\\n        // Set initial lock\\r\\n        _updateLock(_initial_unlock_ts);\\r\\n        emit Initialized(_token, _initial_unlock_ts);\\r\\n    }\\r\\n\\r\\n    // Withdraw the specified token (LP token) from the LPLocker, sending the amount (coerced to the balance available, wei unit) t0 the _to address\\r\\n    // Possible only the lock expired (unlocked)\\r\\n    function withdrawLP(address _LPaddress, uint256 _amount, address _to) external override onlyToken {\\r\\n        require(block.timestamp \\u003e unlock_ts, \\\"LPLocker: Lock not expired!\\\");\\r\\n        IBEP20 token_out = IBEP20(_LPaddress);\\r\\n        if (token_out.balanceOf(address(this)) \\u003c _amount) {\\r\\n            _amount = token_out.balanceOf(address(this));   // coerce\\r\\n        }\\r\\n        token_out.transfer(_to, _amount);\\r\\n        emit LPWithdrawn(_LPaddress, _amount, _to);\\r\\n    }\\r\\n\\r\\n    // Update the Lock of the LPLocker\\r\\n    function updateLock(uint256 _newUnlockTimestamp) external override onlyToken {\\r\\n        _updateLock(_newUnlockTimestamp);\\r\\n    }\\r\\n\\r\\n    // Update the Lock of the LPLocker internal function\\r\\n    function _updateLock(uint256 _newUnlockTimestamp) internal {\\r\\n        // The new lock timestamp (in s) must be in the future (from now + 1 day) and greater than the stored unlock timestamp\\r\\n        require(_newUnlockTimestamp \\u003e block.timestamp + 1 days \\u0026\\u0026 _newUnlockTimestamp \\u003e unlock_ts, \\\"LPLocker: _newUnlockTimestamp must be \\u003e now + 1 day \\u0026\\u0026 \\u003e current unlock_ts\\\");\\r\\n        emit LPLockUpdated(unlock_ts, _newUnlockTimestamp);\\r\\n        unlock_ts = _newUnlockTimestamp;\\r\\n    }\\r\\n\\r\\n    // Return the status of the LPLock vault, its address and the balance of the provided _LPaddress (if different from NULL address)\\r\\n    function getInfoLP(address _LPaddress) public view override returns (address locker_address, uint256 LPbalance, uint256 unlock_timestamp, bool unlocked) {\\r\\n        locker_address = address(this);\\r\\n        if (_LPaddress != address(0)) {\\r\\n            LPbalance = IBEP20(_LPaddress).balanceOf(locker_address);\\r\\n        }\\r\\n        unlock_timestamp = unlock_ts;\\r\\n        unlocked = (block.timestamp \\u003e unlock_ts);\\r\\n    }\\r\\n\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n    \\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event LockOwnership(address indexed owner, uint256 unlockTime);\\n\\n    // The initial owner is the deployer\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    // Returns the owner\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    // Modifier used for the administrative (owner) functions\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    // Transfer the ownership to another address\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    // Internal function to manage the ownership transfer operation\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    // Get the unlock time\\n    function getUnlockTime() public view returns (uint256) {\\n        return _lockTime;\\n    }\\n\\n    // Locks the contract for owner for the amount of time provided (set a big time, like earth life, to lock forever)\\n    function lock(uint256 time) public virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _lockTime = block.timestamp + time;\\n        _transferOwnership(address(0));\\n        emit LockOwnership(_previousOwner, _lockTime);\\n    }\\n    \\n    //Unlocks the contract for owner when _lockTime is passed\\n    function unlock() public virtual {\\n        require(_previousOwner == _msgSender(), \\\"You don\\u0027t have permission to unlock\\\");\\n        require(block.timestamp \\u003e _lockTime , \\\"Contract is locked until UnlockTime\\\");\\n        _transferOwnership(_previousOwner);\\n    }\\n}\\n\"},\"POWERMADE.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/***\\r\\n *    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\r\\n *    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\r\\n *    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \\r\\n *    \u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \\r\\n *    \u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\r\\n *    \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\r\\n *                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557                  \\r\\n *                    \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551                  \\r\\n *                       \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551                  \\r\\n *                       \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551                  \\r\\n *                       \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551                  \\r\\n *                       \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d                  \\r\\n *                                                                                  \\r\\n */\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./BEP20.sol\\\";\\r\\nimport \\\"./BEP20Snapshot.sol\\\";\\r\\nimport \\\"./IPancakeSwap.sol\\\";\\r\\nimport \\\"./LPLocker.sol\\\";\\r\\nimport \\\"./ReflectionManager.sol\\\";\\r\\nimport \\\"./AutomaticBuyback.sol\\\";\\r\\n\\r\\ncontract POWERMADE is BEP20, BEP20Snapshot, Ownable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IPancakeRouter02 public pancakeRouter;              // The DEX router\\r\\n    address public pancakePair;                         // The liquidity pair\\r\\n    mapping (address =\\u003e bool) public automatedMarketMakerPairs;     // All the liquidity pairs (pancakePair included)\\r\\n    bool private swapping;                              // Swapping flag (re-entrancy protection)\\r\\n    uint256 public transactionsBeforeExecution = 10;    // Number of valid (only sells and valid transfers) transactions before execution of the internal features (eg. 10 = 7 dead + 3 executions)\\r\\n    uint256 public tx_counter;     // Tx counter (only sells and valid transfers)\\r\\n    uint256 public amountReflectionTax;\\r\\n    uint256 public amountBuybackTax;\\r\\n    uint256 public amountLiquidityTax;\\r\\n    mapping (address =\\u003e bool) private _isExcludedFromFees;      // Addresses excluded from the token tax\\r\\n    mapping (address =\\u003e bool) public multisenderSmartContract;  // Smart contracts or wallets used to send massive amount of tokens\\r\\n\\r\\n    ReflectionManager public reflectionManager;         // The current (main) Reflection Manager\\r\\n    ReflectionManager public reflectionManagerOld;      // Used if changing the reflection token\\r\\n    BEP20 public reflectionToken;                       // The reflection token (BTCB)\\r\\n    uint256 public gasForProcessing = 300000;           // Gas for processing the reflections\\r\\n\\r\\n    AutomaticBuyback public automaticBuyback;           // The Automatic Buyback Manager\\r\\n    BEP20 public automaticBuyback_cumulatedToken;       // The cumulated token for the buyback (BUSD)\\r\\n\\r\\n    LPLocker public LP_locker;                          // The locker contract for the Automatic liquidity feature (destination of the LP)\\r\\n\\r\\n    mapping(address =\\u003e bool) private _isExcludedFromAntiWhale;\\r\\n    uint256 public maxTransferAmountRate = 1000;    // default and minimum value will be 1000 / 1E6 = 0.001 (0.1% of the supply)\\r\\n    bool private enableAntiwhale;                   // Limit max TX except BUY. Default disabled (false)\\r\\n    mapping (address =\\u003e bool) private _isTimelockExempt;    // Addresses excluded from Cooldown feature\\r\\n    mapping (address =\\u003e uint) private cooldownCheckpoint;\\r\\n    bool private cooldownEnabled;                    // Deadtime between trades on AMM. Default disabled (false)\\r\\n    uint256 public cooldownSellInterval = 10 * 1 minutes;   // Default cooldown Sell interval is 10 minutes\\r\\n    uint256 public cooldownBuyInterval = 1 * 1 minutes;     // Default cooldown Buy interval is 1 minute\\r\\n\\r\\n    mapping(address =\\u003e bool) private _isBlacklisted;     // Blacklist for compliance\\r\\n    mapping(address =\\u003e bool) private _canSnapshot;       // Wallet allowed to do snapshots\\r\\n\\r\\n    // Constants\\r\\n    uint256 public constant REFLECTION_ELIGIBILITY_THRESHOLD = 2000 * (10**18);        // Amount of PWD needed for the reflection\\r\\n    uint256 public constant REFLECTION_TAX = 2;\\r\\n    uint256 public constant BUYBACK_AND_BURN_TAX = 3;\\r\\n    uint256 public constant AUTOMATED_LIQUIDITY_TAX = 3;\\r\\n\\r\\n    // Events\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\r\\n    event ExcludeFromAntiWhale(address indexed account, bool isExcluded);\\r\\n    event EnableDisableAntiWhale(bool indexed new_status);\\r\\n    event SetAntiWhaleMaxTransferRate(uint256 newRate, uint256 oldRate);\\r\\n    event ExcludeFromCooldown(address indexed account, bool isExcluded);\\r\\n    event EnableDisableCooldown(bool indexed new_status);\\r\\n    event SetCooldownSellPeriod(uint256 newPeriod, uint256 oldPeriod);\\r\\n    event SetCooldownBuyPeriod(uint256 newPeriod, uint256 oldPeriod);\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n    event SetMultisenderSmartContract(address indexed pair, bool indexed value);\\r\\n    event SetNumberOfTransaction(uint256 new_value, uint256 old_value);\\r\\n    event SetBlacklisted(address indexed account, bool old_status, bool new_status);\\r\\n    event SetCanSnapshotWallet(address indexed account, bool indexed can_snapshot);\\r\\n    event UpdatedPancakeRouter(address indexed newAddress, address indexed oldAddress, address indexed dexPair);\\r\\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\r\\n    event ReflectionTokenChanged(address old_token, address new_token, address old_manager, address new_manager);\\r\\n    event WithdrawnStuckTokens(address indexed token_address, uint256 amount, address recipient);\\r\\n    event ProcessedReflectionDistribution(\\r\\n        uint256 currentIndex,\\r\\n        uint256 iterations,\\r\\n        uint256 claims,\\r\\n        bool indexed automatic,\\r\\n        bool dismission_completed,\\r\\n        uint256 gas,\\r\\n        address indexed processor\\r\\n    );\\r\\n    event ProcessedReflectionDistributionOLD(\\r\\n        uint256 currentIndex,\\r\\n        uint256 iterations,\\r\\n        uint256 claims,\\r\\n        bool indexed automatic,\\r\\n        bool dismission_completed,\\r\\n        uint256 gas,\\r\\n        address indexed processor\\r\\n    );\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 BNBreceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n    event SwapAndSendAutomaticBuyback(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event SwapAndSendReflectionManager(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 amount\\r\\n    );\\r\\n    \\r\\n \\r\\n\\r\\n    constructor(address TGE_destination) BEP20(\\\"Powermade\\\", \\\"PWD\\\") {\\r\\n        uint256 totalSupply = (14000000) * (10**18);    // 14M PWD\\r\\n\\r\\n        // DEFAULT MAINNET TOKENS AND PANCAKESWAP ROUTER\\r\\n        reflectionToken = BEP20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);    // BTCB Mainnet\\r\\n        automaticBuyback_cumulatedToken = BEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);    // BUSD Mainnet\\r\\n        pancakeRouter = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);   // Router Mainnet\\r\\n        \\r\\n        // Configure router and create liquidity pair\\r\\n        pancakePair = IPancakeFactory(pancakeRouter.factory()).createPair(address(this), pancakeRouter.WETH());\\r\\n\\r\\n        // Create the Reflection Manager\\r\\n        reflectionManager = new ReflectionManager();\\r\\n        reflectionManager.initialize(address(reflectionToken));\\r\\n        reflectionManager.setDistributionCriteria(6 hours, 10**12, REFLECTION_ELIGIBILITY_THRESHOLD);   // 6 hours deadtime, 0.00001 BTCB threshold, 2000 PWD (immutable)\\r\\n        // Create the AutomaticBuyback manager\\r\\n        automaticBuyback = new AutomaticBuyback();\\r\\n        automaticBuyback.initialize(address(pancakeRouter), address(automaticBuyback_cumulatedToken), address(this));\\r\\n        // Create the Locker for the automated liquidity LP tokens\\r\\n        LP_locker = new LPLocker();   // initial lock for 2 years\\r\\n        LP_locker.initialize(block.timestamp + 2 * 365 days);\\r\\n\\r\\n        // Add the AMM pair\\r\\n        _setAutomatedMarketMakerPair(pancakePair, true);\\r\\n\\r\\n        // Exclude from Reflection\\r\\n        reflectionManager.setReflectionDisabledWallet(address(reflectionManager), true);\\r\\n        reflectionManager.setReflectionDisabledWallet(address(this), true);\\r\\n        reflectionManager.setReflectionDisabledWallet(owner(), true);\\r\\n        reflectionManager.setReflectionDisabledWallet(TGE_destination, true);\\r\\n        reflectionManager.setReflectionDisabledWallet(address(pancakeRouter), true);\\r\\n        reflectionManager.setReflectionDisabledWallet(address(pancakePair), true);\\r\\n        reflectionManager.setReflectionDisabledWallet(address(automaticBuyback), true);\\r\\n        reflectionManager.setReflectionDisabledWallet(address(LP_locker), true);\\r\\n        // Exclude from Tax system\\r\\n        _excludeFromFees(owner(), true);\\r\\n        _excludeFromFees(address(this), true);\\r\\n        _excludeFromFees(TGE_destination, true);\\r\\n        _excludeFromFees(address(automaticBuyback), true);\\r\\n        _excludeFromFees(address(LP_locker), true);\\r\\n        _excludeFromFees(address(reflectionManager), true);\\r\\n        // Exclude from Anti-Whale\\r\\n        _setExcludedFromAntiWhale(owner(), true);\\r\\n        _setExcludedFromAntiWhale(address(this), true);\\r\\n        _setExcludedFromAntiWhale(TGE_destination, true);\\r\\n        _setExcludedFromAntiWhale(address(automaticBuyback), true);\\r\\n        _setExcludedFromAntiWhale(address(LP_locker), true);\\r\\n        _setExcludedFromAntiWhale(address(reflectionManager), true);\\r\\n        // Exclude from Cooldown\\r\\n        _setExcludedFromCooldown(owner(), true);\\r\\n        _setExcludedFromCooldown(address(this), true);\\r\\n        _setExcludedFromCooldown(TGE_destination, true);\\r\\n        _setExcludedFromCooldown(address(automaticBuyback), true);\\r\\n        _setExcludedFromCooldown(address(LP_locker), true);\\r\\n        _setExcludedFromCooldown(address(reflectionManager), true);\\r\\n        // Snapshot feature\\r\\n        _setCanSnapshotWallet(owner(), true);\\r\\n        _setCanSnapshotWallet(TGE_destination, true);\\r\\n        \\r\\n        // Create the tokens\\r\\n        _mint(TGE_destination, totalSupply);\\r\\n\\r\\n    }\\r\\n\\r\\n    // Fallback to receive the BNB when converting PWD to BNB (inside _swapAndLiquify function)\\r\\n    receive() external payable {}\\r\\n\\r\\n    // Override needed for the BEP20Snapshot inheritance \\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(BEP20, BEP20Snapshot) {\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    // Override the _transferOwnership to add the extra settings when changing the owner\\r\\n    function _transferOwnership(address newOwner) internal override {\\r\\n        if (address(reflectionManager) == address(0)) {\\r\\n            super._transferOwnership(newOwner); \\r\\n            return;\\r\\n        }\\r\\n        // Previous owner will become a normal wallet\\r\\n        reflectionManager.setReflectionDisabledWallet(owner(), false);\\r\\n        _excludeFromFees(owner(), false);\\r\\n        _setExcludedFromAntiWhale(owner(), false);\\r\\n        _setExcludedFromCooldown(owner(), false);\\r\\n        _setCanSnapshotWallet(owner(), false);\\r\\n        // Call the parent, that will transfer the ownership\\r\\n        super._transferOwnership(newOwner);     \\r\\n        // Set the excludes for the new owner\\r\\n        reflectionManager.setReflectionDisabledWallet(owner(), true);\\r\\n        _excludeFromFees(owner(), true);\\r\\n        _setExcludedFromAntiWhale(owner(), true);\\r\\n        _setExcludedFromCooldown(owner(), true);\\r\\n        _setCanSnapshotWallet(owner(), true);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // ALL THE MAGIC IS HERE\\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n\\r\\n        require(from != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"BEP20: transfer to the zero address\\\");\\r\\n        require(!_isBlacklisted[from] \\u0026\\u0026 !_isBlacklisted[to], \\u0027Address Blacklisted\\u0027);\\r\\n        if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        \\r\\n        // Things to be processed only if not inside internal swapping (reentrancy) and if not from a multi-sender smart contract\\r\\n        if (!swapping \\u0026\\u0026 !multisenderSmartContract[from]) {\\r\\n            // Apply Anti-whale\\r\\n            _checkAntiWhale(from, to, amount);\\r\\n            // Apply Cooldown\\r\\n            _applyCooldown(from, to);\\r\\n        }\\r\\n\\r\\n        // Things to be processed only if not inside internal swapping (reentrancy), if not from a multi-sender smart contract AND NOT A BUY OPERATION\\r\\n        if (!swapping \\u0026\\u0026        // Not swapping internal\\r\\n            !automatedMarketMakerPairs[from] \\u0026\\u0026     // Not a buy operation (internal swaps will fail if during buy operations)\\r\\n            from != owner() \\u0026\\u0026      // Not owner as source/destination\\r\\n            to != owner() \\u0026\\u0026\\r\\n            !multisenderSmartContract[from]     // Not multi-send contract\\r\\n        ) {\\r\\n\\r\\n            // Process the automatic Buyback\\u0026Burn (if needed). The buyback has an internal swapping\\r\\n            swapping = true;\\r\\n            bool buyback_executed = automaticBuyback.trigger();\\r\\n            if (buyback_executed) {\\r\\n                // Burn all the tokens at the automaticBuyback address, reducing the supply\\r\\n                _burn(address(automaticBuyback), balanceOf(address(automaticBuyback)));\\r\\n            }\\r\\n            swapping = false;\\r\\n\\r\\n            // Decide if we have to process the cumulated tax, swapping to the needed tokens (BTCB and BUSD)\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            uint256 executeSwapFeature = tx_counter.mod(transactionsBeforeExecution);\\r\\n            bool canSwap = executeSwapFeature \\u003c 3 \\u0026\\u0026 contractTokenBalance \\u003e 0;\\r\\n            tx_counter++;   // Increase the counter\\r\\n            if (canSwap) {\\r\\n                swapping = true;\\r\\n                if (amountBuybackTax \\u003e 0 \\u0026\\u0026 executeSwapFeature == 0) {\\r\\n                    _swapAndSendAutomaticBuyback(amountBuybackTax);\\r\\n                }\\r\\n                if (amountLiquidityTax \\u003e 0 \\u0026\\u0026 executeSwapFeature == 1) {\\r\\n                    _swapAndLiquify(amountLiquidityTax);\\r\\n                }\\r\\n                if (amountReflectionTax \\u003e 0 \\u0026\\u0026 executeSwapFeature == 2) {\\r\\n                    _swapAndSendReflectionManager(amountReflectionTax);\\r\\n                }\\r\\n                swapping = false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If not swapping, take the tax. This will happen on all transactions, buy and sell\\r\\n        bool takeFee = !swapping;\\r\\n        // if any account belongs to _isExcludedFromFee account or is a multi-sender smart contract then remove the tax\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to] || multisenderSmartContract[from]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        if(takeFee) {\\r\\n            uint256 reflection_amount = amount.mul(REFLECTION_TAX).div(100);\\r\\n            uint256 buyback_amount = amount.mul(BUYBACK_AND_BURN_TAX).div(100);\\r\\n            uint256 liquidity_amount = amount.mul(AUTOMATED_LIQUIDITY_TAX).div(100);\\r\\n            uint256 total_tax_amount = reflection_amount.add(buyback_amount).add(liquidity_amount);\\r\\n            // Apply tax\\r\\n            amount = amount.sub(total_tax_amount);\\r\\n            // Cumulate the tax (PWD) inside the contract\\r\\n            super._transfer(from, address(this), total_tax_amount);\\r\\n            // Update the storage variables\\r\\n            amountReflectionTax = amountReflectionTax.add(reflection_amount);\\r\\n            amountBuybackTax = amountBuybackTax.add(buyback_amount);\\r\\n            amountLiquidityTax = amountLiquidityTax.add(liquidity_amount);\\r\\n        }\\r\\n\\r\\n        // Do the transfer\\r\\n        super._transfer(from, to, amount);\\r\\n\\r\\n        // Update and process the ReflectionManager (if not swapping, see the internal function)\\r\\n        _updateAndProcessReflectionManagers(from, to);\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    // Swap the given amount of PWD to the automaticBuyback_cumulatedToken (BUSD) and send it to the AutomaticBuyback SC address\\r\\n    function _swapAndSendAutomaticBuyback(uint256 amount) private {\\r\\n        // Swap amount and send it to the Automatic buyback SC\\r\\n        uint256 received_amount = _swapPWDtoTokenAndSendToRecipient(automaticBuyback_cumulatedToken, amount, address(automaticBuyback));\\r\\n        // Update the local variable\\r\\n        amountBuybackTax = amountBuybackTax.sub(amount);\\r\\n        emit SwapAndSendAutomaticBuyback(amount, received_amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Swap the given amount of PWD to the reflectionToken (BTCB) and send it to the ReflectionManager, updating the dividend-per-shares\\r\\n    function _swapAndSendReflectionManager(uint256 amount) private {\\r\\n        // Swap amount and send it to the reflection manager directly \\r\\n        uint256 received_amount = _swapPWDtoTokenAndSendToRecipient(reflectionToken, amount, address(reflectionManager));\\r\\n        // Update the reflection manager\\r\\n        reflectionManager.update_deposit(received_amount);\\r\\n        // Update the local variable\\r\\n        amountReflectionTax = amountReflectionTax.sub(amount);\\r\\n        emit SwapAndSendReflectionManager(amount, received_amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Swap half of the PWD amount to BNB and use the two to add liquidity on the DEX pair\\r\\n    function _swapAndLiquify(uint256 amount) private {\\r\\n       // split the contract balance into halves\\r\\n        uint256 half = amount.div(2);\\r\\n        uint256 otherHalf = amount.sub(half);\\r\\n        uint256 initialBalance = address(this).balance;     // To exclude BNB already present in the contract\\r\\n        uint256 initialBalancePWD = balanceOf(address(this));     // To count remaining in PWD\\r\\n        // swap the first half to BNB\\r\\n        _swapPWDtoBNB(half);\\r\\n        // Get the obtained BNBs\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n        // add liquidity to the pair\\r\\n        _addLiquidityPWDandBNBpair(otherHalf, newBalance);\\r\\n        // Real amount of PWD used to provide liquidity, ideally equal to amount (half+otherHalf)\\r\\n        uint256 realPWDamountUsed = initialBalancePWD.sub(balanceOf(address(this)));\\r\\n        amountLiquidityTax = amountLiquidityTax.sub(realPWDamountUsed);\\r\\n        emit SwapAndLiquify(half, newBalance, realPWDamountUsed);\\r\\n    }    \\r\\n\\r\\n\\r\\n    // Swap PWD to the specified BEP20 Token, for tokenAmount quantity of PWD, and send the received tokens to the recipient address\\r\\n    function _swapPWDtoTokenAndSendToRecipient(BEP20 token, uint256 tokenAmount, address recipient) private returns (uint256 amount_received) {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(this);\\r\\n        path[1] = pancakeRouter.WETH();\\r\\n        path[2] = address(token);\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n        uint256 initialBalance = token.balanceOf(recipient);\\r\\n        // make the swap\\r\\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,      // Accept any amount of converted Token\\r\\n            path,\\r\\n            recipient,      // Send to the given recipient address\\r\\n            block.timestamp\\r\\n        );\\r\\n        return token.balanceOf(recipient).sub(initialBalance);\\r\\n    }    \\r\\n\\r\\n\\r\\n    // Swap PWD to BNB (WBNB) sending the BNB to the PWD token address (that has the receive() fallback)\\r\\n    function _swapPWDtoBNB(uint256 tokenAmount) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = pancakeRouter.WETH();\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n        // make the swap\\r\\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,      // accept any amount of BNB\\r\\n            path,\\r\\n            address(this),      // Receive the BNB in the contract (fallback function)\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    // Add the liquidity to the PWD-WBNB pair on the DEX, sending the LP tokens directly to the LPLocker Vault\\r\\n    function _addLiquidityPWDandBNBpair(uint256 tokenAmount, uint256 BNBamount) private {\\r\\n        _approve(address(this), address(pancakeRouter), tokenAmount);\\r\\n        // add the liquidity\\r\\n        pancakeRouter.addLiquidityETH{value: BNBamount}(\\r\\n            address(this),      // PWD\\r\\n            tokenAmount,\\r\\n            0,      // slippage is unavoidable\\r\\n            0,      // slippage is unavoidable\\r\\n            address(LP_locker),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n    // Internal private function to update the shares in the ReflectionManager ad process the distribution with the configured gas (if not in swapping)\\r\\n    function _updateAndProcessReflectionManagers(address from, address to) private {\\r\\n\\r\\n        // Update the shares \\r\\n        reflectionManager.setShare(from, balanceOf(from));\\r\\n        reflectionManager.setShare(to, balanceOf(to));\\r\\n\\r\\n        // Continue only if not swapping and not from a multi-sender contract\\r\\n        if (!swapping \\u0026\\u0026 !multisenderSmartContract[from]) {  \\r\\n            uint256 gas = gasForProcessing;\\r\\n            // Process the distribution (managing also the condition of reflectionToken change)\\r\\n            if (address(reflectionManagerOld) != address(0)) {\\r\\n                bool is_old_dismission_completed;\\r\\n                ( , is_old_dismission_completed) = reflectionManagerOld.isDismission();\\r\\n                if (is_old_dismission_completed) {\\r\\n                    delete reflectionManagerOld;        // Clear the variable (it will return to address(0))\\r\\n                } else {\\r\\n                    gas = gas.div(2);      // Split the gas between the processes (Old and New)\\r\\n                    // Process old\\r\\n                    try reflectionManagerOld.process(gas) returns (uint256 currentIndex, uint256 iterations, uint256 claims, bool dismission_completed) {\\r\\n                        emit ProcessedReflectionDistributionOLD(currentIndex, iterations, claims, true, dismission_completed, gas, tx.origin);\\r\\n                    } catch { }\\r\\n                }\\r\\n            }\\r\\n            // Process the current (Always) \\r\\n            try reflectionManager.process(gas) returns (uint256 currentIndex, uint256 iterations, uint256 claims, bool dismission_completed) {\\r\\n                emit ProcessedReflectionDistribution(currentIndex, iterations, claims, true, dismission_completed, gas, tx.origin);\\r\\n            } catch { }            \\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    // Anti-Whale check: applied to ALL transaction except BUY from AMM pairs\\r\\n    function _checkAntiWhale(address sender, address recipient, uint256 amount) view private {\\r\\n        uint256 maxTransferAmount = totalSupply().mul(maxTransferAmountRate).div(1000000);\\r\\n        if (enableAntiwhale \\u0026\\u0026 !automatedMarketMakerPairs[sender]) {\\r\\n            if (!_isExcludedFromAntiWhale[sender] \\u0026\\u0026 !_isExcludedFromAntiWhale[recipient]) {\\r\\n                require(amount \\u003c= maxTransferAmount, \\\"AntiWhale: amount too high!\\\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    // Cooldown feature applied only to buy and sell operations on the defined automatedMarketMakerPairs\\r\\n    // Applied only if feature enabled and addresses are not exempt\\r\\n    function _applyCooldown(address sender, address recipient) private {\\r\\n        if (cooldownEnabled \\u0026\\u0026 !_isTimelockExempt[sender] \\u0026\\u0026 !_isTimelockExempt[recipient] \\r\\n        ) {\\r\\n            if (automatedMarketMakerPairs[sender]) {\\r\\n                // Buy event - the sender is the pair\\r\\n                // Require the Buy cooldown time from the last buy or sell event of the user\\r\\n                require(block.timestamp \\u003e cooldownCheckpoint[recipient] + cooldownBuyInterval,\\\"Cooldown: please wait!\\\");\\r\\n                cooldownCheckpoint[recipient] = block.timestamp;\\r\\n            } else if (automatedMarketMakerPairs[recipient]) {\\r\\n                // Sell event - the recipient is the pair\\r\\n                // Require the Sell cooldown time from the last buy or sell event of the user\\r\\n                require(block.timestamp \\u003e cooldownCheckpoint[sender] + cooldownSellInterval,\\\"Cooldown: please wait!\\\");\\r\\n                cooldownCheckpoint[sender] = block.timestamp;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Trigger the execution of the Tax conversion manually\\r\\n    function swapManual() public onlyOwner {\\r\\n        uint256 contractTokenBalance = balanceOf(address(this));\\r\\n        require(contractTokenBalance \\u003e 0 , \\\"token balance zero\\\");\\r\\n        swapping = true;\\r\\n        if (amountBuybackTax \\u003e 0) {\\r\\n            _swapAndSendAutomaticBuyback(amountBuybackTax);\\r\\n        }\\r\\n        if (amountLiquidityTax \\u003e 0) {\\r\\n            _swapAndLiquify(amountLiquidityTax);\\r\\n        }\\r\\n        if (amountReflectionTax \\u003e 0) {\\r\\n            _swapAndSendReflectionManager(amountReflectionTax);\\r\\n        }\\r\\n        swapping = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    // Set a liquidity pair\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n        if(value) {\\r\\n            reflectionManager.setReflectionDisabledWallet(pair, true);\\r\\n        }\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n\\r\\n    // Set a Multi-sender smart contract (i.e. used to send airdrops). In this case the gas-intensive features won\\u0027t be triggered during the transaction\\r\\n    function setMultisenderSmartContract(address multisender_sc, bool value) external onlyOwner {\\r\\n        _requireNotInternalAddresses(multisender_sc, true);\\r\\n        require(!automatedMarketMakerPairs[multisender_sc], \\\"Configuration: multisender_sc unallowed\\\");\\r\\n        multisenderSmartContract[multisender_sc] = value;\\r\\n        emit SetMultisenderSmartContract(multisender_sc, value);\\r\\n    }\\r\\n\\r\\n    // Exclude (or re-include) a single wallet (or smart contract) from the tax system \\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        _requireNotInternalAddresses(account, false);\\r\\n        _excludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    // _excludeFromFees internal function\\r\\n    function _excludeFromFees(address account, bool excluded) internal {\\r\\n        if (_isExcludedFromFees[account] != excluded) {\\r\\n            _isExcludedFromFees[account] = excluded;\\r\\n            emit ExcludeFromFees(account, excluded);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Exclude (or re-include) multiple wallets (or smart contracts) from the tax system \\r\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) external onlyOwner {\\r\\n        require(accounts.length \\u003c= 10, \\\"Configuration: max 10 accounts\\\");\\r\\n        for(uint256 i = 0; i \\u003c accounts.length; i++) {\\r\\n            _requireNotInternalAddresses(accounts[i], false);\\r\\n            _isExcludedFromFees[accounts[i]] = excluded;\\r\\n        }\\r\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\r\\n    }\\r\\n\\r\\n    // Check if an address is excluded from the tax system\\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n\\r\\n    // Exclude (or re-include) a single wallet (or smart contract) from the anti-whale system \\r\\n    function setExcludedFromAntiWhale(address account, bool excluded) public onlyOwner {\\r\\n        _requireNotInternalAddresses(account, false);\\r\\n        _setExcludedFromAntiWhale(account, excluded);\\r\\n    }\\r\\n\\r\\n    // _setExcludedFromAntiWhale internal function\\r\\n    function _setExcludedFromAntiWhale(address account, bool excluded) internal {\\r\\n        if (_isExcludedFromAntiWhale[account] != excluded) {\\r\\n            _isExcludedFromAntiWhale[account] = excluded;\\r\\n            emit ExcludeFromAntiWhale(account, excluded);\\r\\n        }  \\r\\n    }\\r\\n\\r\\n    // Check if an address is excluded from the anti-whale system\\r\\n    function isExcludedFromAntiWhale(address account) public view returns(bool) {\\r\\n        return _isExcludedFromAntiWhale[account];\\r\\n    }\\r\\n\\r\\n    // Enable or disable Anti-Whale system\\r\\n    function setEnableAntiwhale(bool _val) public onlyOwner {\\r\\n        enableAntiwhale = _val;\\r\\n        emit EnableDisableAntiWhale(_val);\\r\\n    }\\r\\n\\r\\n    // Exclude (or re-include) a single wallet (or smart contract) from the cooldown system\\r\\n    function setExcludedFromCooldown(address account, bool excluded) public onlyOwner {\\r\\n        _requireNotInternalAddresses(account, false);\\r\\n        _setExcludedFromCooldown(account, excluded);\\r\\n    }\\r\\n\\r\\n    // _setExcludedFromCooldown internal function\\r\\n    function _setExcludedFromCooldown(address account, bool excluded) internal {\\r\\n        if (_isTimelockExempt[account] != excluded) {\\r\\n            _isTimelockExempt[account] = excluded;\\r\\n            emit ExcludeFromCooldown(account, excluded);\\r\\n        }  \\r\\n    }\\r\\n\\r\\n    // Enable or Disable a wallet that can call the makeSnapshot() function\\r\\n    function setCanSnapshotWallet(address account, bool can_snapshot) public onlyOwner {\\r\\n        _requireNotInternalAddresses(account, true);\\r\\n        _setCanSnapshotWallet(account, can_snapshot);\\r\\n    }\\r\\n\\r\\n    // _setCanSnapshotWallet internal function\\r\\n    function _setCanSnapshotWallet(address account, bool can_snapshot) internal {\\r\\n        _canSnapshot[account] = can_snapshot;\\r\\n        emit SetCanSnapshotWallet(account, can_snapshot);\\r\\n    }\\r\\n\\r\\n    // Check if an address is excluded from the Cooldown system\\r\\n    function isExcludedFromCooldown(address account) public view returns(bool) {\\r\\n        return _isTimelockExempt[account];\\r\\n    }\\r\\n\\r\\n    // Enable or disable Cooldown system\\r\\n    function setEnableCooldown(bool _val) public onlyOwner {\\r\\n        cooldownEnabled = _val;\\r\\n        emit EnableDisableCooldown(_val);\\r\\n    }\\r\\n\\r\\n    // Set the transaction amount that is considered a \\\"Whale\\\" in terms of a percentage of the supply (minimum 0.1%)\\r\\n    function setMaxTransferAmountRate(uint256 _val) external onlyOwner {\\r\\n        // Minimum value is 1000, the 0.1% of the supply\\r\\n        require(_val \\u003e= 1000, \\\"AntiWhale: minimum value is 1000\\\");\\r\\n        emit SetAntiWhaleMaxTransferRate(_val, maxTransferAmountRate);\\r\\n        maxTransferAmountRate = _val;\\r\\n    }\\r\\n\\r\\n    // Set the cooldown period when selling on the AMM pair (for the cooldown feature)\\r\\n    function setCooldownSellPeriod(uint256 _period_seconds) external onlyOwner {\\r\\n        require(_period_seconds \\u003e= 1 minutes \\u0026\\u0026 _period_seconds \\u003c= 24 hours, \\\"Cooldown: period \\u003e= 1m and \\u003c= 24h\\\");\\r\\n        emit SetCooldownSellPeriod(_period_seconds, cooldownSellInterval);\\r\\n        cooldownSellInterval = _period_seconds;\\r\\n    }\\r\\n\\r\\n    // Set the cooldown period when buying on the AMM pair (for the cooldown feature)\\r\\n    function setCooldownBuyPeriod(uint256 _period_seconds) external onlyOwner {\\r\\n        require(_period_seconds \\u003e= 0 \\u0026\\u0026 _period_seconds \\u003c= 1 hours, \\\"Cooldown: period \\u003c= 1h\\\");\\r\\n        cooldownBuyInterval = _period_seconds;\\r\\n        emit SetCooldownBuyPeriod(_period_seconds, cooldownBuyInterval);\\r\\n    }\\r\\n\\r\\n    // Add or remove a new AMM pair (PancakeSwap and/or different DEXs)\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {\\r\\n        _requireNotInternalAddresses(pair, true);\\r\\n        require(!multisenderSmartContract[pair], \\\"Configuration: pair unallowed\\\");\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n\\r\\n    // Set the number of transactions between each feature execution sequence\\r\\n    function setNumberOfTransactionsBeforeExecution(uint256 _numberOfTransactions) external onlyOwner {\\r\\n        require(_numberOfTransactions \\u003e= 3 \\u0026\\u0026 _numberOfTransactions \\u003c 100, \\\"Configuration: value \\u003e=3 and \\u003c= 99\\\");\\r\\n        emit SetNumberOfTransaction(_numberOfTransactions, transactionsBeforeExecution);\\r\\n        transactionsBeforeExecution = _numberOfTransactions;\\r\\n    }\\r\\n\\r\\n    // Add an account to the blacklist in case of hacks or regulatory compliance\\r\\n    function blacklistAddress(address account, bool value) external onlyOwner {\\r\\n        _requireNotInternalAddresses(account, true);\\r\\n        emit SetBlacklisted(account, _isBlacklisted[account], value);\\r\\n        _isBlacklisted[account] = value;\\r\\n    }\\r\\n\\r\\n    // Check if an account is blacklisted\\r\\n    function isBlacklistedAddress(address account) public view returns (bool) {\\r\\n        return _isBlacklisted[account];\\r\\n    }\\r\\n\\r\\n    // Change the gas used for the Reflection distribution\\r\\n    function updateGasForProcessing(uint256 newValue) external onlyOwner {\\r\\n        require(newValue \\u003e= 200000 \\u0026\\u0026 newValue \\u003c= 700000, \\\"Configuration: GasForProcessing must be between 200,000 and 700,000\\\");\\r\\n        if (gasForProcessing != newValue) {\\r\\n            emit GasForProcessingUpdated(newValue, gasForProcessing);\\r\\n            gasForProcessing = newValue;\\r\\n        } \\r\\n    }\\r\\n\\r\\n    // Change the thresholds for the automatic reflection distribution\\r\\n    function setReflectionDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external onlyOwner {\\r\\n        reflectionManager.setDistributionCriteria(_minPeriod, _minDistribution, REFLECTION_ELIGIBILITY_THRESHOLD);\\r\\n    }\\r\\n\\r\\n    // Enable or disable a reflection-receiving smart contract (other contracts excluded by default)\\r\\n    function setReflectionEnabledContract(address _contractAddress, bool _enableDisable) external onlyOwner {\\r\\n        _requireNotInternalAddresses(_contractAddress, true);\\r\\n        reflectionManager.setReflectionEnabledContract(_contractAddress, _enableDisable);\\r\\n    }\\r\\n\\r\\n    // Disable or re-enable a reflection-receiving wallet\\r\\n    function setReflectionDisabledWallet(address _walletAddress, bool _disableEnable) external onlyOwner {\\r\\n        _requireNotInternalAddresses(_walletAddress, true);\\r\\n        reflectionManager.setReflectionDisabledWallet(_walletAddress, _disableEnable);\\r\\n    }\\r\\n\\r\\n    function _requireNotInternalAddresses(address _walletAddress, bool includePancake) internal view {\\r\\n        require(_walletAddress != owner() \\u0026\\u0026 \\r\\n                _walletAddress != address(0) \\u0026\\u0026 \\r\\n                _walletAddress != address(this) \\u0026\\u0026 \\r\\n                _walletAddress != address(automaticBuyback) \\u0026\\u0026\\r\\n                _walletAddress != address(LP_locker) \\u0026\\u0026\\r\\n                _walletAddress != address(reflectionManager), \\r\\n                \\\"Configuration: cannot modify the given address\\\");\\r\\n        if (includePancake) {\\r\\n            require(_walletAddress != address(pancakeRouter) \\u0026\\u0026 \\r\\n                    _walletAddress != address(pancakePair), \\r\\n                    \\\"Configuration: cannot modify the given address\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Enable or disable the Reflection automatic claim for an address/shareholder\\r\\n    function setReflectionAutoDistributionExcludeFlag(address _shareholder, bool _exclude) external  onlyOwner {\\r\\n        reflectionManager.setAutoDistributionExcludeFlag(_shareholder, _exclude);\\r\\n    }\\r\\n\\r\\n    // Return Reflection Info of an account (shareholder)\\r\\n    function getReflectionAccountInfo(address shareholder) public view returns (\\r\\n            uint256 shareholder_id,     // it is index+1, zero if shareholder not in list\\r\\n            uint256 currentShares,\\r\\n            int256 iterationsUntilProcessed,\\r\\n            uint256 withdrawableDividends,\\r\\n            uint256 totalRealisedDividends,\\r\\n            uint256 totalExcludedDividends,\\r\\n            uint256 lastClaimTime,\\r\\n            uint256 nextClaimTime,\\r\\n            bool shouldAutoDistribute,\\r\\n            bool excludedAutoDistribution,\\r\\n            bool enabled ) {\\r\\n        return reflectionManager.getAccountInfo(shareholder);\\r\\n    }\\r\\n\\r\\n    // Get the address of a Reflection shareholder given the index (from 0)\\r\\n    function getReflectionShareholderAtIndex(uint256 index) public view returns (address) {\\r\\n        return reflectionManager.getShareholderAtIndex(index);\\r\\n    }\\r\\n\\r\\n    // Returns global info of the reflection manager\\r\\n    function getReflectionManagerInfo() public view returns (\\r\\n            uint256 n_shareholders,\\r\\n            uint256 current_index,\\r\\n            uint256 manager_balance,\\r\\n            uint256 total_shares,\\r\\n            uint256 total_dividends,\\r\\n            uint256 total_distributed,\\r\\n            uint256 dividends_per_share,\\r\\n            uint256 eligibility_threshold_shares,\\r\\n            uint256 min_period,\\r\\n            uint256 min_distribution,\\r\\n            uint8 dismission ) {\\r\\n        return reflectionManager.getReflectionManagerInfo();\\r\\n    }\\r\\n\\r\\n    // Manually process the dividend distribution (everyone can call this function). Suggested gas between 200,000 and 700,000\\r\\n    function processReflectionDistribution(uint256 gas) external {\\r\\n        (uint256 currentIndex, uint256 iterations, uint256 claims, bool dismission_completed) = reflectionManager.process(gas);\\r\\n        emit ProcessedReflectionDistribution(currentIndex, iterations, claims, false, dismission_completed, gas, tx.origin);\\r\\n    }\\r\\n\\r\\n    // Manually process the dividend distribution of the OLD (marked for dismission) Reflection Manager (everyone can call this function). Suggested gas between 200,000 and 700,000\\r\\n    function processReflectionDistributionOLD(uint256 gas) external {\\r\\n        require(address(reflectionManagerOld) != address(0), \\\"reflectionManagerOld not exists\\\");\\r\\n        (uint256 currentIndex, uint256 iterations, uint256 claims, bool dismission_completed) = reflectionManagerOld.process(gas);\\r\\n        if (dismission_completed) {\\r\\n            // Clear the old Reflection Manager (set the address to NULL address)\\r\\n            delete reflectionManagerOld;\\r\\n        }\\r\\n        emit ProcessedReflectionDistributionOLD(currentIndex, iterations, claims, false, dismission_completed, gas, tx.origin);\\r\\n    }\\r\\n\\r\\n    function changeReflectionManager(address newUninitializedReflectionManager, address newReflectionToken, uint256 _minDistribution) external onlyOwner {\\r\\n        require(address(reflectionManagerOld) == address(0), \\\"Configuration: reflectionManagerOld still exists\\\");\\r\\n        _check_get_pair(pancakeRouter, newReflectionToken, true);\\r\\n        // Initialize the passed uninitialized reflection manager, using the provided token address and the given min distribution value\\r\\n        ReflectionManager new_reflection_manager = ReflectionManager(newUninitializedReflectionManager);\\r\\n        new_reflection_manager.initialize(newReflectionToken);\\r\\n        // Configure the new reflection manager\\r\\n        new_reflection_manager.setDistributionCriteria(6 hours, _minDistribution, REFLECTION_ELIGIBILITY_THRESHOLD);\\r\\n        // Exclude from Reflection. Remember to add manually the other addresses if any\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(reflectionManager), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(reflectionManagerOld), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(this), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(owner(), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(pancakeRouter), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(pancakePair), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(automaticBuyback), true);\\r\\n        new_reflection_manager.setReflectionDisabledWallet(address(LP_locker), true);\\r\\n        // Other excludes\\r\\n        _excludeFromFees(address(new_reflection_manager), true);\\r\\n        _setExcludedFromAntiWhale(address(new_reflection_manager), true);\\r\\n        _setExcludedFromCooldown(address(new_reflection_manager), true);\\r\\n        // Change the reflection token \\r\\n        BEP20 old_reflectionToken = reflectionToken;\\r\\n        reflectionToken = BEP20(newReflectionToken);\\r\\n        // Set the current ReflectionManager as OLD and assign the new ReflectionManager\\r\\n        reflectionManagerOld = reflectionManager;   \\r\\n        reflectionManager = new_reflection_manager;\\r\\n        // Dismiss the old reflection manager\\r\\n        reflectionManagerOld.dismissReflectionManager();\\r\\n        emit ReflectionTokenChanged(address(old_reflectionToken), address(reflectionToken), address(reflectionManagerOld), address(reflectionManager));\\r\\n    }\\r\\n\\r\\n    // Manually claim the reflection rewards of the sender\\r\\n    function claimReflection() external {\\r\\n        reflectionManager.claimDividend(_msgSender());\\r\\n    }\\r\\n\\r\\n    // Manually claim the reflection rewards of a shareholder\\r\\n    function claimReflectionShareholder(address shareholder) external {\\r\\n        reflectionManager.claimDividend(shareholder);\\r\\n    }\\r\\n\\r\\n    // Withdraw LP tokens from the Lp vault (if unlocked)\\r\\n    function LPLockerWithdrawLP(address _LPaddress, uint256 _amount, address _to) external onlyOwner {\\r\\n        LP_locker.withdrawLP(_LPaddress, _amount, _to);\\r\\n    }\\r\\n\\r\\n    // Update the Lock timestamp of the LPLocker\\r\\n    function LPLockerUpdateLock(uint256 _newUnlockTimestamp) external onlyOwner {\\r\\n        LP_locker.updateLock(_newUnlockTimestamp);\\r\\n    }\\r\\n\\r\\n    // Return the status of the LPLock vault, its address and the balance of the provided _LPaddress (if different from NULL address)\\r\\n    function getLPLockerInfoLP(address _LPaddress) public view returns (address locker_address, uint256 LPbalance, uint256 unlock_timestamp, bool unlocked) {\\r\\n        return LP_locker.getInfoLP(_LPaddress);\\r\\n    }\\r\\n\\r\\n    // External function to change the automatic buyback period between 30, 60 or 90 days\\r\\n    function changeBuybackPeriod(uint256 newPeriod) external onlyOwner {\\r\\n        automaticBuyback.changeBuybackPeriod(newPeriod);\\r\\n    }\\r\\n\\r\\n    // Change the cumulated token used for the automatic buyback\\r\\n    function changeBuybackCumulatedToken(address newCumulatedTokenAddress) external onlyOwner {\\r\\n        _check_get_pair(pancakeRouter, newCumulatedTokenAddress, true);\\r\\n        automaticBuyback.changeCumulatedToken(newCumulatedTokenAddress);\\r\\n        automaticBuyback_cumulatedToken = BEP20(newCumulatedTokenAddress);\\r\\n    }\\r\\n\\r\\n    // Return the current status of the AutomaticBuyback and the countdown to the next automatic buyback event\\r\\n    function getAutomaticBuybackStatus() public view returns (\\r\\n            address automatic_buyback_contract_address,\\r\\n            uint256 next_buyback_timestamp,\\r\\n            uint256 next_buyback_countdown,\\r\\n            uint256 current_buyback_period,\\r\\n            uint256 new_buyback_period,\\r\\n            address current_cumulated_token,\\r\\n            uint256 current_cumulated_balance,\\r\\n            uint256 current_buyback_token_balance,\\r\\n            uint256 total_buyed_back ) {\\r\\n        return automaticBuyback.getAutomaticBuybackStatus();\\r\\n    }\\r\\n\\r\\n    // Switch/Change PancakeSwap Router\\r\\n    function updatePancakeRouter(address newAddress) external onlyOwner {\\r\\n        require(newAddress != address(pancakeRouter), \\\"The router already has that address\\\");\\r\\n        IPancakeRouter02 _newRouter = IPancakeRouter02(newAddress);\\r\\n        (bool pair_exists, address get_pair) = _check_get_pair(_newRouter, address(this), false);\\r\\n        //checks if pair already exists\\r\\n        if (!pair_exists) {\\r\\n            // Create the new pair\\r\\n            pancakePair = IPancakeFactory(_newRouter.factory()).createPair(address(this), _newRouter.WETH());\\r\\n        }\\r\\n        else {\\r\\n            pancakePair = get_pair;\\r\\n        }\\r\\n        _setAutomatedMarketMakerPair(pancakePair, true);\\r\\n        emit UpdatedPancakeRouter(newAddress, address(pancakeRouter), address(pancakePair));\\r\\n        pancakeRouter = _newRouter;\\r\\n        // Update address for the automatic buyback manager\\r\\n        automaticBuyback.updateRouterAddress(address(pancakeRouter));\\r\\n    }\\r\\n\\r\\n    // Helper function to check a pair on Pancake\\r\\n    function _check_get_pair(IPancakeRouter02 router, address token_addr, bool required) internal view returns (bool pair_exists, address pair) {\\r\\n        pair = IPancakeFactory(router.factory()).getPair(token_addr, router.WETH());\\r\\n        pair_exists = (pair != address(0));\\r\\n        if (required) {\\r\\n            require(pair_exists, \\\"Configuration: not existent pair\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Withdraw stuck tokens inside the contract. Stuck tokens can be BNB or another token\\r\\n    // It will be impossible to withdraw the PWD cumulated inside the token itself\\r\\n    // The refection (BTCB) and the Buyback (BUSD) are managed by separated contract so the only allowed token inside this contract is PWD\\r\\n    function withdrawStuckTokens(address token_address, uint256 amount, address recipient) external onlyOwner {\\r\\n        if (token_address == address(0)) {\\r\\n            // Withdraw stuck BNB\\r\\n            uint256 available_amount = address(this).balance;\\r\\n            amount = amount \\u003e available_amount ? available_amount : amount;     //coerce\\r\\n            payable(recipient).transfer(amount);\\r\\n        } else {\\r\\n            // Withdraw Stuck tokens\\r\\n            require(token_address != address(this), \\\"Cannot withdraw the PWD!\\\");\\r\\n            BEP20 token_bep20 = BEP20(token_address);\\r\\n            uint256 available_amount = token_bep20.balanceOf(address(this));\\r\\n            amount = amount \\u003e available_amount ? available_amount : amount;     //coerce\\r\\n            token_bep20.transfer(recipient, amount);\\r\\n        }\\r\\n        emit WithdrawnStuckTokens(token_address, amount, recipient);\\r\\n    }\\r\\n\\r\\n    // Function used to create a Snapshot by allowed people \\r\\n    function makeSnapshot() external {\\r\\n        require(_canSnapshot[_msgSender()], \\\"Not authorized\\\");\\r\\n        _snapshot();\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"ReflectionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IReflectionManager.sol\\\";\\r\\n\\r\\ncontract ReflectionManager is IReflectionManager {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    address private _token;      // Caller Smart Contract\\r\\n    IBEP20 public RWRD;         // Reward Token\\r\\n    bool private initialized;\\r\\n\\r\\n    struct Share {\\r\\n        uint256 amount;\\r\\n        uint256 totalExcluded;\\r\\n        uint256 totalRealised;\\r\\n        uint256 totalRemainings;\\r\\n    }\\r\\n    // shareholders MAP\\r\\n    address[] private shareholders;\\r\\n    mapping (address =\\u003e uint256) private shareholderIndexes;    // starts from 1\\r\\n    mapping (address =\\u003e uint256) private shareholderClaims;\\r\\n    mapping (address =\\u003e Share) private shares;\\r\\n    mapping (address =\\u003e bool) private enabled_contracts;\\r\\n    mapping (address =\\u003e bool) private disabled_wallets;\\r\\n    mapping (address =\\u003e bool) private excluded_auto_distribution;\\r\\n\\r\\n    uint256 private currentIndex;\\r\\n    uint256 private totalShares;\\r\\n    uint256 private totalDividends;\\r\\n    uint256 private totalDistributed;\\r\\n    uint256 private dividendsPerShare;\\r\\n    uint256 private constant dividendsPerShareAccuracyFactor = 10 ** 36;\\r\\n\\r\\n    uint256 private eligibilityThresholdShares = 2000 * (10**18);       // Min shares to be added as shareholder\\r\\n    uint256 private minPeriod = 60 * 60;                     // Min period (s) between distributions (single shareholder)\\r\\n    uint256 private minDistribution = 1 * (10**12);          // Min cumulated amount before distribution (single shareholder)\\r\\n\\r\\n    bool private dismission_reflection_manager = false;     // Set to dismiss the reflection manager (before trashing it, eg. when migrating to a new RWRD token)\\r\\n    bool private dismission_completed = false;              // Flag indicating the dismission is completed\\r\\n\\r\\n\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token, \\\"Unauthorized\\\"); _;\\r\\n    }\\r\\n\\r\\n    constructor () {}\\r\\n\\r\\n    function initialize(address _rewardToken) external override {\\r\\n        require(!initialized, \\\"ReflectionManager: already initialized!\\\");\\r\\n        initialized = true;\\r\\n        _token = msg.sender;\\r\\n        RWRD = IBEP20(_rewardToken);\\r\\n        emit Initialized(_token, _rewardToken);\\r\\n    }\\r\\n\\r\\n    // Set or change the distribution parameters (minPeriod and minDistribution affect only for automatic distribution)\\r\\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution, uint256 _eligibilityThresholdShares) external override onlyToken {\\r\\n        require(_minPeriod \\u003e= 10 minutes \\u0026\\u0026 _minPeriod \\u003c= 24 hours, \\\"ReflectionManager: _minPeriod must be updated to between 10 minutes and 24 hours\\\");\\r\\n        eligibilityThresholdShares = _eligibilityThresholdShares;\\r\\n        minPeriod = _minPeriod;\\r\\n        minDistribution = _minDistribution;\\r\\n        emit setDistributionCriteriaUpdate(minPeriod, minDistribution, eligibilityThresholdShares);\\r\\n    }\\r\\n\\r\\n    // Set the share of a user, with internal check of eligibility\\r\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\r\\n        if (dismission_reflection_manager) { return; }\\r\\n        // Distribute the reflection to the shareholder, if it has shares and not excluded from auto-distribution\\r\\n        if(shares[shareholder].amount \\u003e 0) {\\r\\n            if (!excluded_auto_distribution[shareholder]) {\\r\\n                distributeDividend(shareholder, true);      // Discard outcome\\r\\n            } else {\\r\\n                // update unpaid remaining because we will \\\"reshape\\\" the slice of the cake\\r\\n                shares[shareholder].totalRemainings = getUnpaidEarnings(shareholder);\\r\\n            }  \\r\\n        } \\r\\n        // Exclude all contracts not in enabled_contracts list, exclude all disabled wallets, exclude all shareholders below the threshold\\r\\n        if (amount \\u003c eligibilityThresholdShares || disabled_wallets[shareholder] || (isContract(shareholder) \\u0026\\u0026 !enabled_contracts[shareholder]) || shareholder == address(0)) { \\r\\n            removeShareholder(shareholder);\\r\\n            amount = 0;\\r\\n        } else if (amount \\u003e= eligibilityThresholdShares) {\\r\\n            addShareholder(shareholder);\\r\\n        } else {\\r\\n            removeShareholder(shareholder);\\r\\n            amount = 0;\\r\\n        }\\r\\n    \\t// Update Shares\\r\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\r\\n        shares[shareholder].amount = amount;\\r\\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);     // reshape\\r\\n    }\\r\\n\\r\\n    // Add a Shareholder to the map (do nothing if already exists)\\r\\n    function addShareholder(address shareholder) internal {\\r\\n        // Add only if not exists\\r\\n        if (shareholderIndexes[shareholder] == 0) {\\r\\n            shareholderIndexes[shareholder] = shareholders.length + 1;\\r\\n            shareholders.push(shareholder);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Remove a Shareholder from the map (do nothing if not exists)\\r\\n    function removeShareholder(address shareholder) internal {\\r\\n        if (shareholderIndexes[shareholder] == 0) {\\r\\n            return;     // Not exists\\r\\n        }\\r\\n        shareholders[shareholderIndexes[shareholder] - 1] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholderIndexes[shareholder] = 0;\\r\\n        shareholders.pop();\\r\\n    }\\r\\n\\r\\n    // Update the Reflection state variable after a transfer into the contract. MUST always be called after a transfer into the ReflectionManager address, passing the exact transferred amount\\r\\n    // The tokens transferred must be RWRD (token used for the reflection)\\r\\n    function update_deposit(uint256 amount) external override onlyToken {\\r\\n        if (dismission_reflection_manager) { return; }\\r\\n        totalDividends = totalDividends.add(amount);\\r\\n        dividendsPerShare = totalShares \\u003e 0 ? dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares)) : 0;\\r\\n    }\\r\\n\\r\\n    // Process a certain number of accounts using the provided gas, saving the pointer (currentIndex) for the next call\\r\\n    function process(uint256 gas) external override onlyToken returns (uint256, uint256, uint256, bool) {\\r\\n        if (dismission_completed) { return (currentIndex, 0, 0, dismission_completed); }\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n        if (shareholderCount == 0) { return (currentIndex, 0, 0, dismission_completed); }\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n        uint256 iterations = 0;\\r\\n        uint256 claims = 0;\\r\\n        while (gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c shareholderCount) {\\r\\n            if (currentIndex \\u003e= shareholderCount) {\\r\\n                // Restart from the first\\r\\n                currentIndex = 0;\\r\\n                if (dismission_reflection_manager) {\\r\\n                    // Set dismission completed (the contract can be dismissed and a new reflection manager,\\r\\n                    // also with a new token, can be created by the caller contract).  \\r\\n                    dismission_completed = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            // Distribute the reflection for the indexed shareholder\\r\\n            address shareholder_current_index = shareholders[currentIndex];\\r\\n            if (shouldDistribute(shareholder_current_index) || (dismission_reflection_manager \\u0026\\u0026 !excluded_auto_distribution[shareholder_current_index])){\\r\\n                bool distributed = distributeDividend(shareholder_current_index, true);\\r\\n                if (distributed) { claims++; }\\r\\n            }\\r\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n        return (currentIndex, iterations, claims, dismission_completed);\\r\\n    }\\r\\n    \\r\\n    // Check if minPeriod passed and minDistribution amount reached, and if excluded from auto-distribution\\r\\n    function shouldDistribute(address shareholder) internal view returns (bool) {\\r\\n        return shareholderClaims[shareholder] + minPeriod \\u003c block.timestamp\\r\\n                \\u0026\\u0026 getUnpaidEarnings(shareholder) \\u003e minDistribution\\r\\n                \\u0026\\u0026 !excluded_auto_distribution[shareholder];\\r\\n    }\\r\\n\\r\\n    // Distribute the dividends of the shareholder\\r\\n    // It can return false of the shares are zero, if there is nothing to distribute OR if the contract has not enough balance to process the shareholder\\r\\n    // The last case can occur due to rounding issues. We have to simply wait for other deposits. The amount is moved to totalRemainings variable\\r\\n    function distributeDividend(address shareholder, bool automatic) internal returns (bool) {\\r\\n        if(shares[shareholder].amount == 0) { return false; }\\r\\n        uint256 amount = getUnpaidEarnings(shareholder);\\r\\n        if(amount \\u003e 0 \\u0026\\u0026 RWRD.balanceOf(address(this)) \\u003e= amount) {\\r\\n            totalDistributed = totalDistributed.add(amount);\\r\\n            RWRD.transfer(shareholder, amount);\\r\\n            shareholderClaims[shareholder] = block.timestamp;\\r\\n            shares[shareholder].totalRemainings = 0;\\r\\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\\r\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\r\\n            emit Claim(shareholder, amount, automatic);\\r\\n            return true;\\r\\n        } else if (amount \\u003e 0 \\u0026\\u0026 RWRD.balanceOf(address(this)) \\u003c amount) {\\r\\n            shares[shareholder].totalRemainings = amount;\\r\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\r\\n            return false;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Manual claim the reflection for a specific user (sending it to the user)\\r\\n    function claimDividend(address shareholder) external override {\\r\\n        distributeDividend(shareholder, false);     // discard outcome\\r\\n    }\\r\\n\\r\\n    // Start the dismission of the reflection manager (when migrating to a new reward token)\\r\\n    function dismissReflectionManager() external override onlyToken {\\r\\n        dismission_reflection_manager = true;   // Enable dismission mode\\r\\n        currentIndex = 0;   // Restart the counter\\r\\n    }\\r\\n\\r\\n    // Calculate the unpaid dividends\\r\\n    function getUnpaidEarnings(address shareholder) public view override returns (uint256) {\\r\\n        if (shares[shareholder].amount == 0) { return 0; }\\r\\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\r\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\r\\n        uint256 shareholdertotalRemainings = shares[shareholder].totalRemainings;\\r\\n        if (shareholderTotalDividends \\u003c= shareholderTotalExcluded) { return shareholdertotalRemainings; }\\r\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded).add(shareholdertotalRemainings);\\r\\n    }\\r\\n\\r\\n    // Calculate the cumulative dividends\\r\\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\\r\\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\r\\n    }\\r\\n\\r\\n    // Enable or disable a reflection-receiving smart contract (other contracts excluded by default)\\r\\n    function setReflectionEnabledContract(address _contractAddress, bool _enableDisable) external override onlyToken {\\r\\n        require(isContract(_contractAddress), \\\"ReflectionManager: _contractAddress is not a contract\\\");\\r\\n        enabled_contracts[_contractAddress] = _enableDisable;\\r\\n        emit setReflectionEnabledContractUpdate(_contractAddress, _enableDisable);\\r\\n    }\\r\\n\\r\\n    // Disable or re-enable a reflection-receiving wallet\\r\\n    function setReflectionDisabledWallet(address _walletAddress, bool _disableEnable) external override onlyToken {\\r\\n        disabled_wallets[_walletAddress] = _disableEnable;\\r\\n        emit setReflectionDisabledWalletUpdate(_walletAddress, _disableEnable);\\r\\n    }\\r\\n\\r\\n    // Enable or disable the automatic claim for an address/shareholder\\r\\n    function setAutoDistributionExcludeFlag(address _shareholder, bool _exclude) external override onlyToken {\\r\\n        excluded_auto_distribution[_shareholder] = _exclude;\\r\\n        emit setAutoDistributionExcludeFlagUpdate(_shareholder, _exclude);\\r\\n    }\\r\\n\\r\\n    // Get different information about a shareholder\\r\\n    function getAccountInfo(address shareholder) public view override returns (\\r\\n            uint256 shareholder_id,     // it is index+1, zero if shareholder not in list\\r\\n            uint256 currentShares,\\r\\n            int256 iterationsUntilProcessed,\\r\\n            uint256 withdrawableDividends,\\r\\n            uint256 totalRealisedDividends,\\r\\n            uint256 totalExcludedDividends,\\r\\n            uint256 lastClaimTime,\\r\\n            uint256 nextClaimTime,\\r\\n            bool shouldAutoDistribute,\\r\\n            bool excludedAutoDistribution,\\r\\n            bool enabled ) {\\r\\n        shareholder_id = shareholderIndexes[shareholder];\\r\\n        currentShares = shares[shareholder].amount;\\r\\n        iterationsUntilProcessed = -1;\\r\\n        if (shareholder_id \\u003e= 1) {\\r\\n            if ((shareholder_id - 1) \\u003e= currentIndex) {\\r\\n                iterationsUntilProcessed = int256(shareholder_id - currentIndex);\\r\\n            }\\r\\n            else {\\r\\n                uint256 processesUntilEndOfArray = shareholders.length \\u003e currentIndex ? (shareholders.length - currentIndex) : 0;\\r\\n                iterationsUntilProcessed = int256(shareholder_id + processesUntilEndOfArray);\\r\\n            }\\r\\n        }\\r\\n        withdrawableDividends = getUnpaidEarnings(shareholder);\\r\\n        totalRealisedDividends = shares[shareholder].totalRealised;\\r\\n        totalExcludedDividends = shares[shareholder].totalExcluded;\\r\\n        lastClaimTime = shareholderClaims[shareholder];\\r\\n        nextClaimTime = lastClaimTime \\u003e 0 ? lastClaimTime.add(minPeriod) : 0;\\r\\n        shouldAutoDistribute = shouldDistribute(shareholder);\\r\\n        excludedAutoDistribution = excluded_auto_distribution[shareholder];\\r\\n        enabled = isContract(shareholder) ? enabled_contracts[shareholder] : !disabled_wallets[shareholder];\\r\\n    }\\r\\n\\r\\n    // Return dismission status\\r\\n    function isDismission() public view override returns (bool dismission_is_started, bool dismission_is_completed) {\\r\\n        dismission_is_started = dismission_reflection_manager;\\r\\n        dismission_is_completed = dismission_completed;\\r\\n    }\\r\\n\\r\\n    // Returns global info of the reflection manager\\r\\n    function getReflectionManagerInfo() public view override returns (\\r\\n            uint256 n_shareholders,\\r\\n            uint256 current_index,\\r\\n            uint256 manager_balance,\\r\\n            uint256 total_shares,\\r\\n            uint256 total_dividends,\\r\\n            uint256 total_distributed,\\r\\n            uint256 dividends_per_share,\\r\\n            uint256 eligibility_threshold_shares,\\r\\n            uint256 min_period,\\r\\n            uint256 min_distribution,\\r\\n            uint8 dismission ) {\\r\\n        n_shareholders = shareholders.length;\\r\\n        current_index = currentIndex;\\r\\n        manager_balance = RWRD.balanceOf(address(this));\\r\\n        total_shares = totalShares;\\r\\n        total_dividends = totalDividends;\\r\\n        total_distributed = totalDistributed;\\r\\n        dividends_per_share = dividendsPerShare;\\r\\n        eligibility_threshold_shares = eligibilityThresholdShares;\\r\\n        min_period = minPeriod;\\r\\n        min_distribution = minDistribution;\\r\\n        dismission = dismission_reflection_manager ? (dismission_completed ? 2 : 1) : 0;\\r\\n    }\\r\\n\\r\\n    // Get the address of a shareholder given the index (from 0)\\r\\n    function getShareholderAtIndex(uint256 index) public view override returns (address) {\\r\\n        return shareholders[index];\\r\\n    }\\r\\n\\r\\n    // Check if smart contract\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length \\u003e 0;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow checks (not available in Solidity as default)\\n * Library to be used with unsigned integers (256 bit)\\n */\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\\n        int256 b = int256(a);\\n        require(b \\u003e= 0);\\n        return b;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TGE_destination\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"new_status\",\"type\":\"bool\"}],\"name\":\"EnableDisableAntiWhale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"new_status\",\"type\":\"bool\"}],\"name\":\"EnableDisableCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromAntiWhale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"LockOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"dismission_completed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedReflectionDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"dismission_completed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedReflectionDistributionOLD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_manager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_manager\",\"type\":\"address\"}],\"name\":\"ReflectionTokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"}],\"name\":\"SetAntiWhaleMaxTransferRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"old_status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"new_status\",\"type\":\"bool\"}],\"name\":\"SetBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"can_snapshot\",\"type\":\"bool\"}],\"name\":\"SetCanSnapshotWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPeriod\",\"type\":\"uint256\"}],\"name\":\"SetCooldownBuyPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPeriod\",\"type\":\"uint256\"}],\"name\":\"SetCooldownSellPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetMultisenderSmartContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"old_value\",\"type\":\"uint256\"}],\"name\":\"SetNumberOfTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Snapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BNBreceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapAndSendAutomaticBuyback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SwapAndSendReflectionManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dexPair\",\"type\":\"address\"}],\"name\":\"UpdatedPancakeRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"WithdrawnStuckTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUTOMATED_LIQUIDITY_TAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUYBACK_AND_BURN_TAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newUnlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"LPLockerUpdateLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_LPaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"LPLockerWithdrawLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_locker\",\"outputs\":[{\"internalType\":\"contract LPLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFLECTION_ELIGIBILITY_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFLECTION_TAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountBuybackTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountLiquidityTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountReflectionTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automaticBuyback\",\"outputs\":[{\"internalType\":\"contract AutomaticBuyback\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automaticBuyback_cumulatedToken\",\"outputs\":[{\"internalType\":\"contract BEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCumulatedTokenAddress\",\"type\":\"address\"}],\"name\":\"changeBuybackCumulatedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"changeBuybackPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUninitializedReflectionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newReflectionToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"changeReflectionManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReflection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"claimReflectionShareholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownBuyInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownSellInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutomaticBuybackStatus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"automatic_buyback_contract_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"next_buyback_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"next_buyback_countdown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current_buyback_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"new_buyback_period\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"current_cumulated_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"current_cumulated_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current_buyback_token_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_buyed_back\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_LPaddress\",\"type\":\"address\"}],\"name\":\"getLPLockerInfoLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"locker_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"LPbalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlock_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getReflectionAccountInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shareholder_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentShares\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"iterationsUntilProcessed\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealisedDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcludedDividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextClaimTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"shouldAutoDistribute\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"excludedAutoDistribution\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReflectionManagerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"n_shareholders\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"manager_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_distributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividends_per_share\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eligibility_threshold_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_distribution\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"dismission\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getReflectionShareholderAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklistedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromAntiWhale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromCooldown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeSnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferAmountRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"multisenderSmartContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakePair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processReflectionDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processReflectionDistributionOLD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionManager\",\"outputs\":[{\"internalType\":\"contract ReflectionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionManagerOld\",\"outputs\":[{\"internalType\":\"contract ReflectionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionToken\",\"outputs\":[{\"internalType\":\"contract BEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"can_snapshot\",\"type\":\"bool\"}],\"name\":\"setCanSnapshotWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period_seconds\",\"type\":\"uint256\"}],\"name\":\"setCooldownBuyPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period_seconds\",\"type\":\"uint256\"}],\"name\":\"setCooldownSellPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_val\",\"type\":\"bool\"}],\"name\":\"setEnableAntiwhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_val\",\"type\":\"bool\"}],\"name\":\"setEnableCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromAntiWhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"setExcludedFromCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setMaxTransferAmountRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multisender_sc\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setMultisenderSmartContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfTransactions\",\"type\":\"uint256\"}],\"name\":\"setNumberOfTransactionsBeforeExecution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shareholder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exclude\",\"type\":\"bool\"}],\"name\":\"setReflectionAutoDistributionExcludeFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_disableEnable\",\"type\":\"bool\"}],\"name\":\"setReflectionDisabledWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setReflectionDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enableDisable\",\"type\":\"bool\"}],\"name\":\"setReflectionEnabledContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionsBeforeExecution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tx_counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updatePancakeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "POWERMADE", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d9d15c9a660f62f7c41c3271a8a06570a3f5abaf", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://947bf7053079738155092b726c355bf3c1499f9b24b61820363795be556400a7"}