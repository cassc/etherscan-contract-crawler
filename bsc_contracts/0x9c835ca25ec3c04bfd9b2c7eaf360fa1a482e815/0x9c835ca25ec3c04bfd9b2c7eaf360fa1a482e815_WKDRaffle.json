{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBase {\\n    address private immutable vrfCoordinator;\\n\\n    /**\\n     * @param _vrfCoordinator address of VRFCoordinator contract\\n     */\\n    constructor(address _vrfCoordinator) {\\n        vrfCoordinator = _vrfCoordinator;\\n    }\\n\\n    /**\\n     * @notice fulfillRandomness handles the VRF response. Your contract must\\n     * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n     * @notice principles to keep in mind when implementing your fulfillRandomness\\n     * @notice method.\\n     *\\n     * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n     * @dev signature, and will call it once it has verified the proof\\n     * @dev associated with the randomness. (It is triggered via a call to\\n     * @dev rawFulfillRandomness, below.)\\n     *\\n     * @param requestId The Id initially returned by requestRandomness\\n     * @param randomWords the VRF output expanded to the requested number of words\\n     */\\n    function fulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords\\n    ) internal virtual;\\n\\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n    // the origin of the call\\n    function rawFulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords\\n    ) external {\\n        if (msg.sender != vrfCoordinator) {\\n            revert(\\\"OnlyCoordinatorCanFulfill\\\");\\n        }\\n        fulfillRandomWords(requestId, randomWords);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVRFCoordinator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorInterface {\\n    /**\\n     * @notice Get configuration relevant for making requests\\n     * @return minimumRequestConfirmations global min for request confirmations\\n     * @return maxGasLimit global max for request gas limit\\n     * @return s_provingKeyHashes list of registered key hashes\\n     */\\n    function getRequestConfig()\\n        external\\n        view\\n        returns (uint16, uint32, bytes32[] memory);\\n\\n    /**\\n     * @notice Request a set of random words.\\n     * @param keyHash - Corresponds to a particular oracle job which uses\\n     * that key for generating the VRF proof. Different keyHash's have different gas price\\n     * ceilings, so you can select a specific one to bound your maximum per request cost.\\n     * @param subId  - The ID of the VRF subscription. Must be funded\\n     * with the minimum subscription balance required for the selected keyHash.\\n     * @param minimumRequestConfirmations - How many blocks you'd like the\\n     * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n     * for why you may want to request more. The acceptable range is\\n     * [minimumRequestBlockConfirmations, 200].\\n     * @param callbackGasLimit - How much gas you'd like to receive in your\\n     * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n     * may be slightly less than this amount because of gas used calling the function\\n     * (argument decoding etc.), so you may need to request slightly more than you expect\\n     * to have inside fulfillRandomWords. The acceptable range is\\n     * [0, maxGasLimit]\\n     * @param numWords - The number of uint256 random values you'd like to receive\\n     * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n     * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n     * @return requestId - A unique identifier of the request. Can be used to match\\n     * a request to a response in fulfillRandomWords.\\n     */\\n    function requestRandomWords(\\n        bytes32 keyHash,\\n        uint64 subId,\\n        uint16 minimumRequestConfirmations,\\n        uint32 callbackGasLimit,\\n        uint32 numWords\\n    ) external returns (uint256 requestId);\\n\\n    /**\\n     * @notice Create a VRF subscription.\\n     * @return subId - A unique subscription id.\\n     * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n     * @dev Note to fund the subscription, use transferAndCall. For example\\n     */\\n    function createSubscription() external returns (uint64 subId);\\n\\n    /**\\n     * @notice Get a VRF subscription.\\n     * @param subId - ID of the subscription\\n     * @return balance - BNB balance of the subscription in juels.\\n     * @return reqCount - number of requests for this subscription, determines fee tier.\\n     * @return owner - owner of the subscription.\\n     * @return consumers - list of consumer address which are able to use this subscription.\\n     */\\n    function getSubscription(\\n        uint64 subId\\n    )\\n        external\\n        view\\n        returns (\\n            uint96 balance,\\n            uint64 reqCount,\\n            address owner,\\n            address[] memory consumers\\n        );\\n\\n    /**\\n     * @notice Request subscription owner transfer.\\n     * @param subId - ID of the subscription\\n     * @param newOwner - proposed new owner of the subscription\\n     */\\n    function requestSubscriptionOwnerTransfer(\\n        uint64 subId,\\n        address newOwner\\n    ) external;\\n\\n    /**\\n     * @notice Request subscription owner transfer.\\n     * @param subId - ID of the subscription\\n     * @dev will revert if original owner of subId has\\n     * not requested that msg.sender become the new owner.\\n     */\\n    function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n    /**\\n     * @notice Add a consumer to a VRF subscription.\\n     * @param subId - ID of the subscription\\n     * @param consumer - New consumer which can use the subscription\\n     */\\n    function addConsumer(uint64 subId, address consumer) external;\\n\\n    /**\\n     * @notice Remove a consumer from a VRF subscription.\\n     * @param subId - ID of the subscription\\n     * @param consumer - Consumer to remove from the subscription\\n     */\\n    function removeConsumer(uint64 subId, address consumer) external;\\n\\n    /**\\n     * @notice Cancel a subscription\\n     * @param subId - ID of the subscription\\n     * @param to - Where to send the remaining BNB to\\n     */\\n    function cancelSubscription(uint64 subId, address to) external;\\n\\n    /*\\n     * @notice Check to see if there exists a request commitment consumers\\n     * for all consumers and keyhashes for a given sub.\\n     * @param subId - ID of the subscription\\n     * @return true if there exists at least one unfulfilled request for the subscription, false\\n     * otherwise.\\n     */\\n    function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWKDNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IWKDNFT {\\n    function mint(address account, uint256 amount) external;\\n\\n    function burnWinningTokens(address account, uint256 value) external;\\n\\n    function HATUT_ZERAZ_E() external view returns (uint256);\\n\\n    function KIMOYO() external view returns (uint256);\\n\\n    function DORA_MILAJ_E() external view returns (uint256);\\n\\n    function TAIFA_NAGA_O() external view returns (uint256);\\n\\n    function NEGUS() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWKDRaffle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IWKDRaffle {\\n    function startCycle(uint256 price, uint256 winsPer20) external;\\n    function isDeprecated(uint256 price, uint256 winsPer20) external view returns(bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IRouter {\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function WETH() external pure returns (address);\\n\\n    function factory() external pure returns (address);\\n}\\n\\ninterface IFactory {\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n}\\n\\ninterface IWKDRaffleTopCadre {\\n    function totals()\\n        external\\n        view\\n        returns (\\n            uint256 kimoyo,\\n            uint256 doramilaje,\\n            uint256 taifaNagao,\\n            uint negus\\n        );\\n\\n    function getPendingFor(\\n        address account,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    function onTransferHook(address account, uint256[] calldata ids) external;\\n\\n    // function setDeprecated(bool deprecatedStatus) external;\\n\\n    function version() external view returns (string memory);\\n\\n    function claim(uint256 id) external;\\n}\\n\\n\\ninterface IWKDNFT {\\n    function totalSupply(uint256) external view returns (uint256);\\n\\n    function balanceOf(address, uint256) external view returns (uint256);\\n\\n    function KIMOYO() external view returns (uint256);\\n\\n    function DORA_MILAJ_E() external view returns (uint256);\\n\\n    function TAIFA_NAGA_O() external view returns (uint256);\\n\\n    function NEGUS() external view returns (uint256);\\n}\\n\\ninterface ITopCadre {\\n    function onTransferHook(\\n        address account,\\n        uint256[] calldata tokenIds\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/WKDRaffle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {Counters} from \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport {WKDVRFManager} from \\\"./WKDVRFManager.sol\\\";\\nimport {IWKDRaffle} from \\\"./interfaces/IWKDRaffle.sol\\\";\\nimport {IWKDNFT} from \\\"./interfaces/IWKDNFT.sol\\\";\\nimport {IRouter, IFactory} from \\\"./interfaces/utils.sol\\\";\\n\\nerror Winners_Too_Few();\\nerror Too_Many_Winners();\\nerror Cannot_Process_At_This_Time();\\nerror Exceeds_Allowable();\\nerror Insufficient_Payment();\\nerror Refund_Failed();\\nerror Transfer_Failed();\\nerror Invalid_Address_Detected();\\nerror Nothing_To_Claim();\\nerror Too_Early();\\nerror Invalid_Pair();\\nerror Price_Too_Low();\\nerror Amount_Too_High();\\nerror Same_As_Before();\\nerror Withdraw_Pending_Claim();\\nerror Inaccurate_Raffle_State(uint256 expected, uint256 actual);\\nerror Used_RequestId();\\nerror VRF_Funding_Failed();\\n\\ncontract WKDRaffle is AccessControl, ReentrancyGuard {\\n    using Counters for Counters.Counter;\\n    Counters.Counter public cycleCounter;\\n    IWKDNFT public immutable _wkdNFT;\\n    WKDVRFManager public wkdVRFManager;\\n\\n    event ClaimReferralBonus(address ref, uint256 amount);\\n    event ClaimWinPrize(address account, uint256 amount, uint256 tokensBurnt);\\n    event StartCycle(uint256 cycleId, uint256 price, uint256 winsPer20);\\n    event JoinedCycle(uint256 cycleId, address account, uint256 entryId);\\n    event DAOChanged(address from, address to);\\n    event PlatformChanged(address from, address to);\\n    event TopCadreChanged(address from, address to);\\n    event DrawResult(\\n        uint256 cycleId,\\n        uint256 currentDraw,\\n        uint256 targetDrawCount,\\n        uint256 currentWiners,\\n        uint256 subId,\\n        uint256 requestId\\n    );\\n    event PostDrawCall(uint256 cycleId, uint256 entries, uint256 winners);\\n    event BuyBackAndBurn(address router, uint256 bnbAmount, uint256 wkdAmount);\\n    event ReadyForDraws(\\n        uint256 cycleId,\\n        uint256 entries,\\n        uint256 prize,\\n        uint256 daoRake,\\n        uint256 buyBackRake\\n    );\\n    event VRFManagerUpdated(address wkdVrfManager, uint64 subscriptionId);\\n    event OperationFailedWithString(string reasonString);\\n    event OperationFailedWithData(bytes reasonData);\\n\\n    address private _dao;\\n    address private _platform;\\n    address private _topCadre;\\n\\n    address public immutable WKD;\\n    address public constant BURN_ADDRESS =\\n        0x000000000000000000000000000000000000dEaD;\\n\\n    uint256 private constant MIN_WINS_PER_20 = 3;\\n    uint256 private constant MAX_WINS_PER_20 = 5;\\n    uint256 private constant MAX_SIZE = 2000;\\n    uint256 private constant MAX_MINT = 200;\\n    uint256 private constant SAMPLE_SIZE = 20;\\n    bytes32 public constant RAFFLE_MANAGER = keccak256(\\\"RAFFLE_MANAGER\\\");\\n    bytes32 public constant ADMIN = keccak256(\\\"ADMIN\\\"); // multisig2\\n    uint256 public constant WINNERS_PCT = 50;\\n    uint256 public constant REF_PCT = 5;\\n    uint256 private constant VRF_FUNDING_AMOUNT = 0.2 ether;\\n    uint256 public constant TOP_RANK_PCT = 3;\\n    uint256 public constant DAO_PCT = 12;\\n    uint256 public constant BUY_BACK_PCT = 15;\\n    uint256 public constant PLATFORM_PCT = 15;\\n\\n    uint256 private _topCadreFund;\\n    uint256 private _buybackAndBurnFund;\\n    uint256 private _referralFund;\\n    uint256 private _platformFund;\\n    uint256 private _daoFund;\\n    uint256 public lastBurnAt;\\n    uint256 public lastRequestId;\\n    uint256 public lastRequestMadeAt;\\n    uint64 public subscriptionId;\\n\\n    mapping(address => address) private _referrals;\\n    mapping(address => address[]) private _myRefs;\\n    mapping(address => uint256) private _winnersRake;\\n    // referral bonus tracker\\n    mapping(address => uint256) private _refRake;\\n    mapping(uint256 => Cycle) private _cycles;\\n    mapping(uint256 => Draw) private _draws;\\n    // guaranty unique indexes are selected during draws\\n    mapping(uint256 => mapping(uint256 => bool)) private _drawnIndexForCycle;\\n    mapping(uint256 => address[]) private _entries;\\n    mapping(address => bool) private _existing;\\n    mapping(uint256 => bool) public usedReqIds;\\n    // tracks number of mints per cycle for each account\\n    mapping(uint256 => mapping(address => uint256)) private _mints;\\n    // tracks a winners pending winning cycle\\n    mapping(address => Win) private _cycleOfPendingRewardFor;\\n\\n    struct Win {\\n        bool exists;\\n        uint256 cycle;\\n    }\\n    enum Status {\\n        CLOSED,\\n        OPEN,\\n        DRAWING_WINNERS,\\n        POST_DRAW\\n    }\\n    struct Cycle {\\n        uint256 price;\\n        uint256 openedAt;\\n        uint256 expectedWins;\\n        uint256 possibleWinsBasedOnEntry;\\n        uint256 prize;\\n        uint256 rakePerRef;\\n    }\\n    struct Draw {\\n        uint256 current;\\n        uint256 target;\\n        uint256[] winners;\\n    }\\n\\n    Status private _status;\\n\\n    // multisig1\\n    constructor(\\n        address multisig,\\n        address wkdNFT,\\n        address payable wkdVrfManager,\\n        address wkdAddress,\\n        uint64 subId\\n    ) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, multisig);\\n        _setRoleAdmin(ADMIN, DEFAULT_ADMIN_ROLE);\\n        _setRoleAdmin(RAFFLE_MANAGER, DEFAULT_ADMIN_ROLE);\\n        _wkdNFT = IWKDNFT(wkdNFT);\\n        wkdVRFManager = WKDVRFManager(wkdVrfManager);\\n        WKD = wkdAddress;\\n        subscriptionId = subId;\\n        lastBurnAt = block.timestamp + 7 days;\\n    }\\n\\n    /// @notice show the current state of the contract circuit\\n    function status() external view returns (uint256) {\\n        return uint256(_status);\\n    }\\n\\n    /// @notice validation of inputs when creating a new cycle\\n    function _preStartCheck(uint256 winsPer20) internal view {\\n        if (winsPer20 < MIN_WINS_PER_20) revert Winners_Too_Few();\\n        if (winsPer20 > MAX_WINS_PER_20) revert Too_Many_Winners();\\n        if (_status != Status.CLOSED)\\n            revert Inaccurate_Raffle_State({\\n                expected: uint256(Status.CLOSED),\\n                actual: uint256(_status)\\n            });\\n    }\\n\\n    /// @notice to create a new cycle\\n    /// @dev contract must be in a CLOSED state, winsPer20 must be from 3 to 5\\n    function startCycle(\\n        uint256 price,\\n        uint256 winsPer20\\n    ) external onlyRole(RAFFLE_MANAGER) {\\n        if (price == 0) revert Price_Too_Low();\\n        _preStartCheck(winsPer20);\\n        cycleCounter.increment();\\n        uint256 cycleId = cycleCounter.current();\\n        _cycles[cycleId].price = price;\\n        _cycles[cycleId].expectedWins = 100 * winsPer20;\\n        _cycles[cycleId].openedAt = block.timestamp;\\n        _status = Status.OPEN;\\n        emit StartCycle(cycleId, price, winsPer20);\\n    }\\n\\n    /// @notice gets the information about a cycle given its id\\n    function showCycle(uint256 cycleId) external view returns (Cycle memory) {\\n        return _cycles[cycleId];\\n    }\\n\\n    /// @notice lets an account join the current cycle\\n    /// @dev for easy tracking of pending wins, it is important\\n    /// for accounts to claim their pending wins before joining again\\n    /// this can be resolved easily from the client but added check\\n    /// is provided in case user connects through other interfaces\\n    /// @param account address of the beneficiary of the minted token\\n    /// @param referral address of the referee\\n    /// @param amount number of tokens to be minted, multiples of of the price of minting 1 token in this cycle\\n    function join(\\n        address account,\\n        address referral,\\n        uint256 amount\\n    ) external payable nonReentrant {\\n        (uint256 totalPendingAmount, ) = unclaimedBNB(account);\\n        if (totalPendingAmount != 0) revert Withdraw_Pending_Claim();\\n        uint256 cycleId = cycleCounter.current();\\n        Cycle memory cycle = _cycles[cycleId];\\n        if (_status != Status.OPEN)\\n            revert Inaccurate_Raffle_State({\\n                expected: uint256(Status.OPEN),\\n                actual: uint256(_status)\\n            });\\n        uint256 _value = msg.value;\\n        (uint256 mintableQty, uint256 refund) = _checkMintableFor(\\n            account,\\n            amount,\\n            _value,\\n            _entries[cycleId].length,\\n            cycleId,\\n            cycle.price\\n        );\\n        _joinCycleFor(account, referral, cycleId, mintableQty, refund);\\n    }\\n\\n    /// @notice util function to check if an account is not minting more than 10% of the available\\n    /// @dev when an account is overpaying, this function calculates the refund\\n    function _checkMintableFor(\\n        address account,\\n        uint256 desiredMintAmount,\\n        uint256 value,\\n        uint256 entryCount,\\n        uint256 cycleId,\\n        uint256 price\\n    ) internal view returns (uint256 mintableQty, uint256 refund) {\\n        if (desiredMintAmount > MAX_MINT) revert Amount_Too_High();\\n        mintableQty = MAX_MINT - _mints[cycleId][account];\\n        if (mintableQty == 0) revert Exceeds_Allowable();\\n        if (desiredMintAmount <= mintableQty) {\\n            mintableQty = desiredMintAmount;\\n        }\\n        uint256 possibleTotal = entryCount + mintableQty;\\n        if (possibleTotal > MAX_SIZE) {\\n            mintableQty = MAX_SIZE - entryCount;\\n        }\\n        uint256 requiredAmount = mintableQty * price;\\n        if (value < requiredAmount) revert Insufficient_Payment();\\n        if (value > requiredAmount) {\\n            refund = value - requiredAmount;\\n        }\\n    }\\n\\n    /// @notice util function to process the minting call\\n    function _joinCycleFor(\\n        address account,\\n        address ref,\\n        uint256 cycleId,\\n        uint256 mintableQty,\\n        uint256 refund\\n    ) internal {\\n        _wkdNFT.mint(account, mintableQty);\\n        if (mintableQty > 0) {\\n            if (!_existing[account]) {\\n                _referrals[account] = ref;\\n                _existing[account] = true;\\n                _myRefs[ref].push(account);\\n            }\\n            for (uint256 i = 0; i < mintableQty; ) {\\n                // winners are selected based on the index of\\n                // the entry in the array\\n                _entries[cycleId].push(account);\\n                unchecked {\\n                    i++; // cannot overflow due to loop constraint\\n                }\\n            }\\n            _mints[cycleId][account] += mintableQty;\\n            emit JoinedCycle(cycleId, account, mintableQty);\\n        }\\n        if (refund > 0) {\\n            (bool ok, ) = _msgSender().call{value: refund}(\\\"\\\");\\n            if (!ok) revert Refund_Failed();\\n        }\\n    }\\n\\n    /// @notice used by the {RAFFLE_MANAGER} to end a cycle in preparation for starting the draws\\n    /// @dev the function emite {RequiredRandomRequest} that should be used to know how many\\n    /// requests to the VRFManager will be required to draw all winners\\n    function processForWinners() external onlyRole(RAFFLE_MANAGER) {\\n        uint256 cycleId = cycleCounter.current();\\n        _preDrawCheck(cycleId);\\n        (\\n            uint256 prize,\\n            uint256 prizePerWin,\\n            uint256 daoRake,\\n            uint256 platformRake,\\n            uint256 buyBackRake,\\n            uint256 refRake,\\n            uint256 rakePerRef,\\n            uint256 topCadreRake,\\n            uint256 possibleWinners\\n        ) = winningPrize(cycleId);\\n\\n        _cycles[cycleId].prize = prizePerWin;\\n        _cycles[cycleId].rakePerRef = rakePerRef;\\n        _cycles[cycleId].possibleWinsBasedOnEntry = possibleWinners;\\n\\n        _topCadreFund += topCadreRake;\\n        _buybackAndBurnFund += buyBackRake;\\n        _referralFund += refRake;\\n        _platformFund += platformRake;\\n        _daoFund += daoRake;\\n\\n        uint256 drawCount = possibleWinners / 100; // batch of random numbers\\n        _draws[cycleId].target = drawCount == 0 ? 1 : drawCount; // we need at least 1 draw\\n        _status = Status.DRAWING_WINNERS;\\n        emit ReadyForDraws(\\n            cycleId,\\n            _entries[cycleId].length,\\n            prize,\\n            daoRake,\\n            buyBackRake\\n        );\\n    }\\n\\n    /// @dev util function to check some parameters are available beofore proceeding to draw winners\\n    function _preDrawCheck(uint256 cycleId) internal view {\\n        if (_status != Status.OPEN)\\n            revert Inaccurate_Raffle_State({\\n                expected: uint256(Status.OPEN),\\n                actual: uint256(_status)\\n            });\\n        if (_entries[cycleId].length % 20 != 0)\\n            revert Cannot_Process_At_This_Time();\\n    }\\n\\n    function requestRandomWordsForCycle() external onlyRole(RAFFLE_MANAGER) {\\n        if (_status != Status.DRAWING_WINNERS)\\n            revert Inaccurate_Raffle_State({\\n                expected: uint256(Status.DRAWING_WINNERS),\\n                actual: uint256(_status)\\n            });\\n        // will replace the previous one\\n        // raffle manager must ensure enough time has\\n        // passed in-between calls and there is no\\n        if (block.timestamp < (lastRequestMadeAt + 5 minutes))\\n            revert Too_Early();\\n\\n        try\\n            wkdVRFManager.requestRandomWords(\\n                subscriptionId,\\n                2500000 /* Use max callback gas limit*/,\\n                100 /* number of words */,\\n                3 /* number of confirmations */\\n            )\\n        returns (uint256 requestId) {\\n            lastRequestId = requestId;\\n            lastRequestMadeAt = block.timestamp;\\n        } catch Error(string memory revertReason) {\\n            emit OperationFailedWithString(revertReason);\\n        } catch (bytes memory returnData) {\\n            emit OperationFailedWithData(returnData);\\n        }\\n    }\\n\\n    /// @notice shows the available funds in the contract shared to different beneficiaries\\n    function availableFunds()\\n        external\\n        view\\n        returns (\\n            uint256 topCadre,\\n            uint256 buybackAndBurn,\\n            uint256 referralFund,\\n            uint256 platform,\\n            uint256 dao\\n        )\\n    {\\n        return (\\n            _topCadreFund,\\n            _buybackAndBurnFund,\\n            _referralFund,\\n            _platformFund,\\n            _daoFund\\n        );\\n    }\\n\\n    /// @notice computes the winning prize of a given cycle\\n    /// @param cycleId id of the cycle of interest\\n    function winningPrize(\\n        uint256 cycleId\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 prize,\\n            uint256 prizePerWin,\\n            uint256 daoRake,\\n            uint256 platformRake,\\n            uint256 buyBackRake,\\n            uint256 refRake,\\n            uint256 rakePerRef,\\n            uint256 topRankersRake,\\n            uint256 possibleWinners\\n        )\\n    {\\n        Cycle memory cycle = _cycles[cycleId];\\n        uint256 entryCount = _entries[cycleId].length;\\n        uint256 totalPay = entryCount * cycle.price;\\n        uint256 roundToNext20 = entryCount % SAMPLE_SIZE;\\n        if (roundToNext20 != 0) {\\n            entryCount = entryCount + (SAMPLE_SIZE - roundToNext20);\\n        }\\n        prize = (totalPay * WINNERS_PCT) / 100;\\n        possibleWinners =\\n            ((entryCount / SAMPLE_SIZE) * cycle.expectedWins) /\\n            100;\\n        prizePerWin = prize / possibleWinners;\\n        daoRake = (totalPay * DAO_PCT) / 100;\\n        platformRake = (totalPay * PLATFORM_PCT) / 100;\\n        buyBackRake = (totalPay * BUY_BACK_PCT) / 100;\\n        refRake = (totalPay * REF_PCT) / 100;\\n        rakePerRef = refRake / possibleWinners;\\n        topRankersRake = (totalPay * TOP_RANK_PCT) / 100;\\n    }\\n\\n    /// @notice used by the {RAFFLE_MANAGER} to draw winners from the on-going cycle\\n    function drawWinners() external onlyRole(RAFFLE_MANAGER) {\\n        if (_status != Status.DRAWING_WINNERS)\\n            revert Inaccurate_Raffle_State({\\n                expected: uint256(Status.DRAWING_WINNERS),\\n                actual: uint256(_status)\\n            });\\n        uint256 cycleId = cycleCounter.current();\\n        _creditWinnersAndReferrals(cycleId);\\n    }\\n\\n    /// @dev uses random words generated from the vrf manager to credit players\\n    /// it will never choose a winning number more than once\\n    /// winner is selected based on the index from the _entries[cycleId] array\\n    /// Can emit {RequiredRandomRequest} in case all winners aren't selected\\n    /// due to duplicated numbers from VRF call\\n    function _creditWinnersAndReferrals(uint256 cycleId) internal {\\n        Cycle memory cycle = _cycles[cycleId];\\n        uint256 expectedWinners = cycle.possibleWinsBasedOnEntry;\\n        address[] memory entries = _entries[cycleId];\\n        if (usedReqIds[lastRequestId]) revert Used_RequestId();\\n        (bool fulfilled, uint256[] memory randomWords) = wkdVRFManager\\n            .getRequestStatus(lastRequestId);\\n        if (fulfilled) {\\n            uint256 rakePerRef = cycle.rakePerRef;\\n            uint256 prize = cycle.prize;\\n            for (uint256 i = 0; i < randomWords.length; ) {\\n                uint256 n = randomWords[i] % entries.length;\\n                if (!_drawnIndexForCycle[cycleId][n]) {\\n                    _drawnIndexForCycle[cycleId][n] = true; // ensures number isn't selected twice\\n                    address winner = entries[n];\\n                    // for any unforseen reason\\n                    if (winner != address(0)) {\\n                        if (!_cycleOfPendingRewardFor[winner].exists) {\\n                            _cycleOfPendingRewardFor[winner].cycle = cycleId;\\n                            _cycleOfPendingRewardFor[winner].exists = true;\\n                        }\\n                        address referee = _referrals[winner];\\n                        if (referee != address(0)) {\\n                            _referralFund -= rakePerRef;\\n                            _refRake[referee] += rakePerRef;\\n                        }\\n                        _winnersRake[winner] += prize;\\n                        _draws[cycleId].winners.push(n); // for winner index verification\\n                    }\\n                }\\n                if (_draws[cycleId].winners.length == expectedWinners) {\\n                    _status = Status.POST_DRAW;\\n                    break;\\n                }\\n                i++;\\n            }\\n            if (_status != Status.POST_DRAW) {\\n                // request for more random numbers\\n                // if all winners haven't been selected at this point,\\n                // increase target by one\\n                _draws[cycleId].target++;\\n            }\\n            _draws[cycleId].current++;\\n            usedReqIds[lastRequestId] = true;\\n            Draw memory draw = _draws[cycleId];\\n            emit DrawResult(\\n                cycleId,\\n                draw.current,\\n                draw.target,\\n                draw.winners.length,\\n                subscriptionId,\\n                lastRequestId\\n            );\\n        }\\n        // silently pass without doing anything,\\n        // try again after some time\\n    }\\n\\n    /// @notice used by {RAFFLE_MANAGER} to complete the cycle and close it, transferring funds to\\n    /// specially configured addreses such as the DAO\\n    function postDrawCall(\\n        bool fundVRFManager\\n    ) external nonReentrant onlyRole(RAFFLE_MANAGER) {\\n        if (_status != Status.POST_DRAW)\\n            revert Inaccurate_Raffle_State({\\n                expected: uint256(Status.POST_DRAW),\\n                actual: uint256(_status)\\n            });\\n        uint256 platformAmount = _platformFund;\\n        uint256 daoAmount = _daoFund;\\n        uint256 topCadreAmount = _topCadreFund;\\n        uint256 referralAmount = _referralFund; // unclaimed funds\\n        _topCadreFund = 0;\\n        _referralFund = 0;\\n        _platformFund = 0;\\n        _daoFund = 0;\\n        if (fundVRFManager) {\\n            if (platformAmount < VRF_FUNDING_AMOUNT)\\n                revert VRF_Funding_Failed();\\n            platformAmount -= VRF_FUNDING_AMOUNT;\\n            _closingCycleFundTransferTo(\\n                address(wkdVRFManager),\\n                VRF_FUNDING_AMOUNT\\n            );\\n        }\\n        _closingCycleFundTransferTo(_dao, daoAmount);\\n        _closingCycleFundTransferTo(_platform, platformAmount);\\n        _closingCycleFundTransferTo(_topCadre, topCadreAmount + referralAmount); // send unclaimed referral bonus along with top cadre\\n        _status = Status.CLOSED;\\n        uint256 cycleId = cycleCounter.current();\\n        emit PostDrawCall(\\n            cycleId,\\n            _entries[cycleId].length,\\n            _draws[cycleId].winners.length\\n        );\\n    }\\n\\n    function _closingCycleFundTransferTo(\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        (bool ok, ) = account.call{value: amount}(\\\"\\\");\\n        if (!ok) revert Transfer_Failed();\\n    }\\n\\n    /// @notice for {RAFFLE_MANAGER} to  perform buy backoperations\\n    function buyAndBurn(\\n        IRouter router\\n    ) external nonReentrant onlyRole(RAFFLE_MANAGER) {\\n        uint256 moment = block.timestamp;\\n        if (moment < lastBurnAt) revert Too_Early();\\n        uint256 burnAmount = _buybackAndBurnFund;\\n        _buybackAndBurnFund = 0;\\n        address factory = router.factory();\\n        address weth = router.WETH();\\n        address pair = IFactory(factory).getPair(weth, WKD);\\n        if (pair == address(0)) revert Invalid_Pair();\\n        address[] memory path = new address[](2);\\n        path[0] = weth;\\n        path[1] = WKD;\\n        uint256[] memory outs = router.getAmountsOut(burnAmount, path);\\n\\n        try\\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{\\n                value: burnAmount\\n            }(outs[1], path, BURN_ADDRESS, moment + 5 minutes)\\n        {\\n            lastBurnAt = moment;\\n            emit BuyBackAndBurn(address(router), outs[0], outs[1]);\\n        } catch Error(string memory revertReason) {\\n            emit OperationFailedWithString(revertReason);\\n        } catch (bytes memory returnData) {\\n            emit OperationFailedWithData(returnData);\\n        }\\n    }\\n\\n    /// @notice shows the referral bonus for a given address\\n    function pendingReferralBonus(\\n        address account\\n    ) external view returns (uint256) {\\n        return _refRake[account];\\n    }\\n\\n    /// @notice shows the total pending winning amount for an address and the amount of\\n    /// tokens required to burn for the claim to be withdrawn.\\n    /// @param account is the address under consideration\\n    function unclaimedBNB(\\n        address account\\n    ) public view returns (uint256 totalPendingAmount, uint256 tokensRequired) {\\n        totalPendingAmount = _winnersRake[account];\\n        uint256 winCycle = _cycleOfPendingRewardFor[account].cycle;\\n        if (winCycle != 0) {\\n            Cycle memory cycle = _cycles[winCycle];\\n            tokensRequired = totalPendingAmount / cycle.prize; // should be multiples of the prize won, otherwise, is zero\\n        }\\n    }\\n\\n    /// @notice used to claim the referral bomus available for an address\\n    function claimReferralBonus() external nonReentrant {\\n        address to = _msgSender();\\n        uint256 amount = _refRake[to];\\n        if (amount == 0) revert Nothing_To_Claim();\\n        _refRake[to] = 0;\\n        (bool ok, ) = to.call{value: amount}(\\\"\\\");\\n        if (!ok) revert Transfer_Failed();\\n        emit ClaimReferralBonus(to, amount);\\n    }\\n\\n    /// @notice to claim the price.\\n    /// @dev cycleId must be provided because the price for each token is differnt in all cycles.\\n    /// a winning token is burnt during claim\\n    function claimPrize(address account) external nonReentrant {\\n        (uint256 totalPendingAmount, uint256 tokensRequired) = unclaimedBNB(\\n            account\\n        );\\n        if (totalPendingAmount != 0) {\\n            _claimPrize(account, totalPendingAmount, tokensRequired);\\n        }\\n    }\\n\\n    function _claimPrize(\\n        address account,\\n        uint256 totalPendingAmount,\\n        uint256 tokensRequired\\n    ) internal {\\n        _wkdNFT.burnWinningTokens(account, tokensRequired);\\n        // clear storage\\n        delete _cycleOfPendingRewardFor[account];\\n        delete _winnersRake[account];\\n        (bool ok, ) = account.call{value: totalPendingAmount}(\\\"\\\");\\n        if (!ok) revert Transfer_Failed();\\n        emit ClaimWinPrize(account, totalPendingAmount, tokensRequired);\\n    }\\n\\n    /// @notice shows all the entries in a given cycle\\n    function showEntriesFor(\\n        uint256 cycleId\\n    ) external view returns (address[] memory entries) {\\n        return _entries[cycleId];\\n    }\\n\\n    /// @notice get information about the draw on a cycle\\n    function showDrawFor(uint256 cycleId) external view returns (Draw memory) {\\n        return _draws[cycleId];\\n    }\\n\\n    /// @notice shows the referee of an account\\n    function showReferralFor(address account) external view returns (address) {\\n        return _referrals[account];\\n    }\\n\\n    /// @notice used to set the DAO address as specified by the {ADMIN}\\n    function updateDAO(address dao) external onlyRole(ADMIN) {\\n        if (dao == address(0)) revert Invalid_Address_Detected();\\n        emit DAOChanged(_dao, dao);\\n        _dao = dao;\\n    }\\n\\n    /// @notice used to set the Platform address as specified by the {ADMIN}\\n    function updatePlatform(address platform) external onlyRole(ADMIN) {\\n        if (platform == address(0)) revert Invalid_Address_Detected();\\n        emit PlatformChanged(_platform, platform);\\n        _platform = platform;\\n    }\\n\\n    /// @notice used to set the Top Cadre (contract) address as specified by the {ADMIN}\\n    function updateTopCadre(address topCadre) external onlyRole(ADMIN) {\\n        if (topCadre == address(0)) revert Invalid_Address_Detected();\\n        emit TopCadreChanged(_topCadre, topCadre);\\n        _topCadre = topCadre;\\n    }\\n\\n    /// @notice used to set the vrf manager as specified by the {ADMIN}\\n    function updateVRFManager(\\n        address payable vrfManager,\\n        uint64 subId\\n    ) public onlyRole(ADMIN) {\\n        if (address(wkdVRFManager) == vrfManager && subscriptionId == subId)\\n            revert Same_As_Before();\\n        if (vrfManager == address(0)) revert Invalid_Address_Detected();\\n        emit VRFManagerUpdated(vrfManager, subId);\\n        wkdVRFManager = WKDVRFManager(vrfManager);\\n        subscriptionId = subId;\\n    }\\n\\n    function showMyReferrals(\\n        address account\\n    ) external view returns (address[] memory myReferrals) {\\n        return _myRefs[account];\\n    }\\n\\n    /// @notice shows the DAO wallet and the top cadre contract wallets\\n    function showManagementWallets()\\n        external\\n        view\\n        returns (address dao, address pplatform, address topcadre)\\n    {\\n        return (_dao, _platform, _topCadre);\\n    }\\n\\n    /// @notice shows the version number of this contract\\n    function version() external pure returns (string memory) {\\n        return \\\"v1\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/WKDVRFManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport {VRFConsumerBase} from \\\"./interfaces/IVRFConsumerBase.sol\\\";\\nimport {VRFCoordinatorInterface} from \\\"./interfaces/IVRFCoordinator.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nerror Same_As_Before();\\nerror Not_Authorized();\\nerror Funding_Failed();\\nerror Invalid_Request();\\n\\ncontract WKDVRFManager is VRFConsumerBase, Ownable {\\n    VRFCoordinatorInterface private immutable COORDINATOR;\\n    mapping(address => bool) public authorized;\\n    struct RequestStatus {\\n        bool fulfilled; // whether the request has been successfully fulfilled\\n        bool exists; // whether a requestId exists\\n        uint256[] randomWords;\\n    }\\n    uint256[] public requestIds;\\n    uint256 private _lastRequestId;\\n    uint64 private _subscriptionId;\\n\\n    mapping(uint256 => RequestStatus) private requests;\\n\\n    event AuthorizationUpdated(address previousController, bool status);\\n    event RequestSent(uint256 requestId, uint64 subId, uint32 numWords);\\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\\n    event SubscriptionIdChanged(uint64 previous, uint64 current);\\n\\n    bytes32 public immutable keyHash;\\n\\n    constructor(\\n        address coordinator,\\n        bytes32 _keyHash,\\n        uint64 _subId\\n    ) VRFConsumerBase(coordinator) {\\n        COORDINATOR = VRFCoordinatorInterface(coordinator);\\n        _subscriptionId = _subId;\\n        keyHash = _keyHash;\\n    }\\n\\n    receive() external payable {\\n        _fund(msg.value);\\n    }\\n\\n    function updateAuthAccount(\\n        address account,\\n        bool status\\n    ) external onlyOwner {\\n        if (authorized[account] == status) revert Same_As_Before();\\n        authorized[account] = status;\\n        emit AuthorizationUpdated(account, status);\\n    }\\n\\n    function requestRandomWords(\\n        uint64 subId,\\n        uint32 callbackGasLimit,\\n        uint32 numWords,\\n        uint16 confirmations\\n    ) external returns (uint256 requestId) {\\n        if (!authorized[_msgSender()]) revert Not_Authorized();\\n        requestId = COORDINATOR.requestRandomWords(\\n            keyHash,\\n            subId,\\n            confirmations,\\n            callbackGasLimit,\\n            numWords\\n        );\\n        requests[requestId] = RequestStatus({\\n            randomWords: new uint256[](0),\\n            exists: true,\\n            fulfilled: false\\n        });\\n        requestIds.push(requestId);\\n        _lastRequestId = requestId;\\n        emit RequestSent(requestId, subId, numWords);\\n    }\\n\\n    function fulfillRandomWords(\\n        uint256 requestId,\\n        uint256[] memory randomWords\\n    ) internal override {\\n        if (!requests[requestId].exists) revert Invalid_Request();\\n        requests[requestId].fulfilled = true;\\n        requests[requestId].randomWords = randomWords;\\n        emit RequestFulfilled(requestId, randomWords);\\n    }\\n\\n    function getRequestStatus(\\n        uint256 _requestId\\n    ) external view returns (bool fulfilled, uint256[] memory randomWords) {\\n        if (!requests[_requestId].exists) revert Invalid_Request();\\n        RequestStatus memory request = requests[_requestId];\\n        return (request.fulfilled, request.randomWords);\\n    }\\n\\n    function _fund(uint256 amount) internal {\\n        (bool ok, ) = address(COORDINATOR).call{value: amount}(\\n            abi.encodeWithSignature(\\\"deposit(uint64)\\\", _subscriptionId)\\n        );\\n        if (!ok) revert Funding_Failed();\\n    }\\n\\n    function updateSubId(uint64 newSubId) external onlyOwner {\\n        if (_subscriptionId == newSubId) revert Same_As_Before();\\n        emit SubscriptionIdChanged(_subscriptionId, newSubId);\\n        _subscriptionId = newSubId;\\n    }\\n\\n    function subscriptionId() external view returns (uint64) {\\n        return _subscriptionId;\\n    }\\n\\n    function lastRequestId() external view returns (uint256) {\\n        return _lastRequestId;\\n    }\\n}\\n\\n// 0x0b43eFa3478b02ADA6783d523b0A89F5a2F81fCb - working condition\\n// 0xd11a9d04642bE7b1BA6E25A5311b1fE312Cf04c1 - improved conditon\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multisig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wkdNFT\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"wkdVrfManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wkdAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Amount_Too_High\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Cannot_Process_At_This_Time\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exceeds_Allowable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"Inaccurate_Raffle_State\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Insufficient_Payment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid_Address_Detected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid_Pair\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Nothing_To_Claim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Price_Too_Low\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Refund_Failed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Same_As_Before\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Too_Early\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Too_Many_Winners\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Transfer_Failed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Used_RequestId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VRF_Funding_Failed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Winners_Too_Few\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Withdraw_Pending_Claim\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wkdAmount\",\"type\":\"uint256\"}],\"name\":\"BuyBackAndBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReferralBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurnt\",\"type\":\"uint256\"}],\"name\":\"ClaimWinPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DAOChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentDraw\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetDrawCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentWiners\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"DrawResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryId\",\"type\":\"uint256\"}],\"name\":\"JoinedCycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reasonData\",\"type\":\"bytes\"}],\"name\":\"OperationFailedWithData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reasonString\",\"type\":\"string\"}],\"name\":\"OperationFailedWithString\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PlatformChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entries\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winners\",\"type\":\"uint256\"}],\"name\":\"PostDrawCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entries\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoRake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyBackRake\",\"type\":\"uint256\"}],\"name\":\"ReadyForDraws\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winsPer20\",\"type\":\"uint256\"}],\"name\":\"StartCycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TopCadreChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wkdVrfManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"VRFManagerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUY_BACK_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAO_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RAFFLE_MANAGER\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REF_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOP_RANK_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WINNERS_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WKD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_wkdNFT\",\"outputs\":[{\"internalType\":\"contract IWKDNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"topCadre\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buybackAndBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralFund\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platform\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dao\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"buyAndBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReferralBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drawWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBurnAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRequestMadeAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingReferralBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"fundVRFManager\",\"type\":\"bool\"}],\"name\":\"postDrawCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processForWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestRandomWordsForCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"showCycle\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedWins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"possibleWinsBasedOnEntry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rakePerRef\",\"type\":\"uint256\"}],\"internalType\":\"struct WKDRaffle.Cycle\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"showDrawFor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"winners\",\"type\":\"uint256[]\"}],\"internalType\":\"struct WKDRaffle.Draw\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"showEntriesFor\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"entries\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showManagementWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pplatform\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"topcadre\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"showMyReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"myReferrals\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"showReferralFor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winsPer20\",\"type\":\"uint256\"}],\"name\":\"startCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unclaimedBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPendingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensRequired\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"updateDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"platform\",\"type\":\"address\"}],\"name\":\"updatePlatform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"topCadre\",\"type\":\"address\"}],\"name\":\"updateTopCadre\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"vrfManager\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"updateVRFManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedReqIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleId\",\"type\":\"uint256\"}],\"name\":\"winningPrize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizePerWin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daoRake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"platformRake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBackRake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refRake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rakePerRef\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"topRankersRake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"possibleWinners\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wkdVRFManager\",\"outputs\":[{\"internalType\":\"contract WKDVRFManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WKDRaffle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "0000000000000000000000000ce1b0c109a751a1ee9475603e531cf7dcad66620000000000000000000000000861ea680a59226f3d570a3c3ab2b1b2f1cf21f1000000000000000000000000e90885a26c54a1f4c7f614b3f2871fbdc01d9a530000000000000000000000005344c20fd242545f31723689662ac12b9556fc3d0000000000000000000000000000000000000000000000000000000000000015", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}