{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n    * @dev Initializes the contract setting the deployer as the initial owner.\\n    */\\n    constructor () {\\n      address msgSender = _msgSender();\\n      _owner = msgSender;\\n      emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n    * @dev Returns the address of the current owner.\\n    */\\n    function owner() public view returns (address) {\\n      return _owner;\\n    }\\n\\n    \\n    modifier onlyOwner() {\\n      require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n      _;\\n    }\\n\\n    function renounceOwnership() public onlyOwner {\\n      emit OwnershipTransferred(_owner, address(0));\\n      _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n      _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal {\\n      require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n      emit OwnershipTransferred(_owner, newOwner);\\n      _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/Miners/ILottery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\ninterface ILottery {\\n    function minerPays(uint _amount) external payable;\\n}\"\r\n    },\r\n    \"contracts/Miners/MinerV1Native.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\nimport \\\"../Libs/SafeMath.sol\\\";\\nimport \\\"../Libs/Ownable.sol\\\";\\nimport \\\"./ILottery.sol\\\";\\n\\n//   ____                         ____  _                                 _ \\n//  / ___| _ __   __ _  ___ ___  |  _ \\\\(_) __ _ _ __ ___   ___  _ __   __| |\\n//  \\\\___ \\\\| '_ \\\\ / _` |/ __/ _ \\\\ | | | | |/ _` | '_ ` _ \\\\ / _ \\\\| '_ \\\\ / _` |\\n//   ___) | |_) | (_| | (_|  __/ | |_| | | (_| | | | | | | (_) | | | | (_| |\\n//  |____/| .__/ \\\\__,_|\\\\___\\\\___| |____/|_|\\\\__,_|_| |_| |_|\\\\___/|_| |_|\\\\__,_|\\n//        |_|                                                               \\n                                                                     \\ncontract MinerV1Native is Context, Ownable {\\n    using SafeMath for uint256;\\n\\n    \\n    address payable public devAddress;\\n    uint256 private EGGS_TO_HATCH_1MINERS = 2592000;\\n    uint256 private PSN = 10000;\\n    uint256 private PSNH = 5000;\\n    uint256 private devFeeVal = 5;\\n    uint256 private lottFeeVal = 10;\\n    uint256 private refFee = 5;\\n    bool private initialized = false;\\n    mapping (address => uint256) public hatcheryMiners;\\n    mapping (address => uint256) public claimedEggs;\\n    mapping (address => uint256) public lastHatch;\\n    mapping (address => address) public referrals;\\n    uint256 public marketEggs;\\n    address public lotteryAddr;\\n\\n    event BuyEggs(address _from, uint256 _amount);\\n    event SellEggs(address _from, uint256 _eggsValues);\\n    event HatchEggs(address _from, uint256 _newMiners);\\n    event ReceivedFromLottery(address _from, uint _lotteryValue);\\n    \\n    constructor() {\\n        devAddress = payable(msg.sender);\\n    }\\n    \\n    function hatchEggs(address ref) public {\\n        require(initialized, \\\"Contract is not initialized\\\");\\n        \\n        if(ref == msg.sender) {\\n            ref = address(0);\\n        }\\n\\n        if(referrals[msg.sender] == address(0) && referrals[msg.sender] != msg.sender) {\\n            referrals[msg.sender] = ref;\\n        }\\n\\n        uint256 eggsUsed = getMyEggs(msg.sender);\\n        uint256 newMiners = SafeMath.div(eggsUsed,EGGS_TO_HATCH_1MINERS);\\n        hatcheryMiners[msg.sender] = SafeMath.add(hatcheryMiners[msg.sender],newMiners);\\n        claimedEggs[msg.sender] = 0;\\n        lastHatch[msg.sender] = block.timestamp;\\n        \\n        //send referral eggs\\n        claimedEggs[referrals[msg.sender]] = SafeMath.add( claimedEggs[referrals[msg.sender]], SafeMath.div(SafeMath.mul(eggsUsed, refFee), 100));\\n        \\n        //boost market to nerf miners hoarding\\n        marketEggs=SafeMath.add(marketEggs,SafeMath.div(eggsUsed,5));\\n        \\n        emit HatchEggs(msg.sender, newMiners);\\n    }\\n    \\n    function sellEggs() public {\\n        require(initialized, \\\"Contract is not initialized\\\");\\n        uint256 hasEggs = getMyEggs(msg.sender);\\n        uint256 eggValue = calculateEggSell(hasEggs);\\n        uint256 fee = devFee(eggValue);\\n        claimedEggs[msg.sender] = 0;\\n        lastHatch[msg.sender] = block.timestamp;\\n        marketEggs = SafeMath.add(marketEggs, hasEggs);\\n        devAddress.transfer(fee);\\n        payable (msg.sender).transfer(SafeMath.sub(eggValue, fee));\\n        emit SellEggs(msg.sender, eggValue - fee);\\n    }\\n\\n    function beanRewards(address adr) public view returns(uint256) {\\n        uint256 hasEggs = getMyEggs(adr);\\n        if (hasEggs == 0) { return 0; }\\n        uint256 eggValue = calculateEggSell(hasEggs);\\n        return eggValue;\\n    }\\n\\n    function buyEggs(address ref) public payable {\\n        require(initialized, \\\"Contract is not initialized\\\");\\n        // Get purchase total eggs\\n        uint256 eggsBoughtTx = calculateEggBuy(msg.value, SafeMath.sub(address(this).balance, msg.value));\\n\\n        // Substract eggs according to dev fee\\n        uint256 new_SubDevEggsBought = SafeMath.sub(eggsBoughtTx, devFee(eggsBoughtTx));\\n\\n        // Calculate Dev Fee & Transfer\\n        uint256 devFeeAmount = devFee(msg.value);\\n        devAddress.transfer(devFeeAmount);\\n\\n        // Substract eggs according to lottery pool fee\\n        uint256 new_SubLottPoolEggsBought = SafeMath.sub(new_SubDevEggsBought, lottPoolFee(eggsBoughtTx));\\n\\n        // Calculate Lottery Fee & Transfer\\n        uint256 lottFeeAmount = lottPoolFee(msg.value);\\n        ILottery(lotteryAddr).minerPays{value: lottFeeAmount}(lottFeeAmount);\\n\\n        // Assign Correct Eggs Value to user\\n        claimedEggs[msg.sender] = SafeMath.add(claimedEggs[msg.sender], new_SubLottPoolEggsBought);\\n        emit BuyEggs(msg.sender, msg.value - devFeeAmount - lottFeeAmount);\\n        hatchEggs(ref);\\n    }\\n\\n    function getMyEggs(address adr) public view returns(uint256) {\\n        return SafeMath.add(claimedEggs[adr], getEggsSinceLastHatch(adr));\\n    }\\n\\n    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) private view returns(uint256) {\\n        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));\\n    }\\n\\n    function calculateEggSell(uint256 eggs) public view returns(uint256) {\\n        return calculateTrade(eggs, marketEggs, address(this).balance);\\n    }\\n\\n    function calculateEggBuy(uint256 eth,uint256 contractBalance) public view returns(uint256) {\\n        return calculateTrade(eth, contractBalance, marketEggs);\\n    }\\n\\n    function calculateEggBuySimple(uint256 eth) public view returns(uint256) {\\n        return calculateEggBuy(eth, address(this).balance);\\n    }\\n\\n    function devFee(uint256 amount) private view returns(uint256) {\\n        return SafeMath.div(SafeMath.mul(amount, devFeeVal),100);\\n    }\\n\\n    function lottPoolFee(uint256 amount) private view returns(uint256) {\\n        return SafeMath.div(SafeMath.mul(amount, lottFeeVal),100);\\n    }\\n\\n    function seedMarket() public payable onlyOwner {\\n        require(marketEggs == 0);\\n        initialized = true;\\n        marketEggs = 108000000000;\\n    }\\n\\n    function getBalance() public view returns(uint256) {\\n        return address(this).balance;\\n    }\\n    \\n    function getMyMiners(address adr) public view returns(uint256) {\\n        return hatcheryMiners[adr];\\n    }\\n    \\n    function getEggsSinceLastHatch(address adr) public view returns(uint256) {\\n        uint256 secondsPassed=min(EGGS_TO_HATCH_1MINERS,SafeMath.sub(block.timestamp,lastHatch[adr]));\\n        return SafeMath.mul(secondsPassed,hatcheryMiners[adr]);\\n    }\\n    \\n    function setLotteryAddr(address _lotteryAddr) public onlyOwner {\\n        lotteryAddr = _lotteryAddr;\\n    }\\n    \\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function lotteryPays(uint _amount) public payable {\\n        require(msg.sender == lotteryAddr, \\\"Miner can only be funded within lottery contract\\\");\\n        emit ReceivedFromLottery(msg.sender, _amount);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 8000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BuyEggs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newMiners\",\"type\":\"uint256\"}],\"name\":\"HatchEggs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lotteryValue\",\"type\":\"uint256\"}],\"name\":\"ReceivedFromLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_eggsValues\",\"type\":\"uint256\"}],\"name\":\"SellEggs\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"beanRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"buyEggs\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"calculateEggBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"calculateEggBuySimple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eggs\",\"type\":\"uint256\"}],\"name\":\"calculateEggSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getEggsSinceLastHatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMyEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getMyMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"hatchEggs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hatcheryMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastHatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lotteryPays\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seedMarket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellEggs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lotteryAddr\",\"type\":\"address\"}],\"name\":\"setLotteryAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MinerV1Native", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}