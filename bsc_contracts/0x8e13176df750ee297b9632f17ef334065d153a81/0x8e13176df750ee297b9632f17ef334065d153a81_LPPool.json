{"SourceCode": "pragma solidity 0.6.12;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n   \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    constructor () public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract LPPool is Ownable {\r\n    IERC20 private constant c_erc20_usdt_pair = IERC20(0xE2ebDFe188C8Ed5E25C79a16E7Fb2ED45896c9E3);\r\n    IERC20 private constant c_erc20 = IERC20(0x379f29911956052899E09233A3914f4e1eca075C);\r\n\r\n    uint256 private constant DURATION = 3000 days;\r\n    uint256 public immutable starttime = block.timestamp;\r\n    uint256 public immutable periodFinish = block.timestamp + DURATION;\r\n\r\n    uint256 public immutable rewardRate = 26620370370370370;\r\n    uint256 public lastUpdateTime;\r\n    uint256 public rewardPerTokenStored;\r\n\r\n    mapping(address => uint256) public userRewardPerTokenPaid;\r\n    mapping(address => uint256) public rewards;\r\n\r\n    uint256 private _totalSupply;\r\n    mapping(address => uint256) private _balances;\r\n    using SafeMath for uint256;\r\n\r\n    struct User {\r\n        uint256 id;\r\n        address upline;\r\n        uint256 reward;\r\n        uint256 downlineAmount;\r\n        uint256 withdrawn;\r\n    }\r\n    mapping(address => User) public users;\r\n    address private immutable firstAddress;\r\n    mapping(uint256 => address) public id2Address;\r\n    uint256 public nextUserId = 2;\r\n\r\n    mapping (uint256 => uint256) public refRewardRates;\r\n\r\n    constructor(address first) public {\r\n        firstAddress = first;\r\n        id2Address[1] = first;\r\n        refRewardRates[0] = 0;\r\n    }\r\n\r\n    modifier updateReward(address account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdateTime = lastTimeRewardApplicable();\r\n        \r\n        rewards[account] = _balances[account].mul(rewardPerTokenStored.sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\r\n        userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n        _;\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return Math.min(block.timestamp, periodFinish);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (_totalSupply == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n        return rewardPerTokenStored.add( lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply) );\r\n    }\r\n\r\n    function register(address referrer) public {\r\n        require(!isUserExists(msg.sender), \"user already register\");\r\n        require(isUserExists(referrer), \"referrer not exists\");\r\n        uint256 id = nextUserId++;\r\n        users[msg.sender].id = id;\r\n        users[msg.sender].upline = referrer;\r\n        id2Address[id] = msg.sender;\r\n    }\r\n\r\n    function stake(address referrer, uint256 amount) external updateReward(msg.sender) {\r\n        require(amount > 0, 'LPPool: Cannot stake 0');\r\n        c_erc20_usdt_pair.transferFrom(msg.sender, address(this), amount);\r\n        if (!isUserExists(msg.sender)) {\r\n            register(referrer);\r\n        }\r\n        _mint(msg.sender, amount);\r\n    }\r\n\r\n    function isUserExists(address addr) public view returns (bool) {\r\n        return (addr == firstAddress || users[addr].upline != address(0));\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        _addGen(account, amount);\r\n    }\r\n\r\n    function _addGen(address addr, uint256 amount) private {\r\n        address up = users[addr].upline;\r\n        for(; up != address(0);) {\r\n            users[up].downlineAmount += amount;\r\n            up = users[up].upline;\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 amount) public updateReward(msg.sender) {\r\n        if (amount > 0) {\r\n            _burn(msg.sender, amount);\r\n            c_erc20_usdt_pair.transfer(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        _balances[account] = _balances[account].sub(amount, \"burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _removeGen(account, amount);\r\n    }\r\n\r\n    function _removeGen(address addr, uint256 amount) private {\r\n        address up = users[addr].upline;\r\n        for(; up != address(0);) {\r\n            users[up].downlineAmount -= amount;\r\n            up = users[up].upline;\r\n        }\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(_balances[msg.sender]);\r\n        getReward();\r\n    }\r\n\r\n    function getReward() public updateReward(msg.sender) {\r\n        uint256 reward = rewards[msg.sender];\r\n        if (reward > 0) {\r\n            _refPayout(msg.sender, reward);\r\n            rewards[msg.sender] = 0;\r\n        }\r\n\r\n        reward += users[msg.sender].reward;\r\n        users[msg.sender].reward = 0;\r\n\r\n        if (reward > 0) {\r\n            c_erc20.transfer(msg.sender, reward);\r\n            users[msg.sender].withdrawn += reward;\r\n        }\r\n    }\r\n\r\n    function _refPayout(address addr, uint256 amount) private {\r\n        address up = users[addr].upline;\r\n        for(uint8 i = 0; i < 1; i++) {\r\n            if(up == address(0)) break;\r\n            users[up].reward += amount * refRewardRates[i] / 1000;\r\n            up = users[up].upline;\r\n        }\r\n    }\r\n\r\n    function setRate(uint256 newR) external onlyOwner {\r\n        refRewardRates[0] = newR;\r\n    }\r\n\r\n    function contractInfo() external view returns(uint256, uint256, uint256) {\r\n        return (_totalSupply, c_erc20.balanceOf(address(this)), nextUserId);\r\n    }\r\n\r\n    function userInfo(address account) public view returns(uint256, uint256, uint256, uint256, address, uint256) {\r\n        uint256 earned = _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\r\n        return (users[account].downlineAmount, _balances[account], earned, users[account].reward, users[account].upline, users[account].withdrawn);\r\n    }\r\n\r\n    function userInfoById(uint256 id) external view returns(uint256, uint256, uint256, uint256, address, uint256) {\r\n        address account = id2Address[id];\r\n        return userInfo(account);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"first\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"id2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refRewardRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newR\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starttime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"userInfoById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downlineAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LPPool", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000df622af9ffa18c2650bd48280e31bda4e9c47ce8", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://596af771d513dabb3b6b1f51e9d6fa74860a870daacd23a95d6835db9233b915"}