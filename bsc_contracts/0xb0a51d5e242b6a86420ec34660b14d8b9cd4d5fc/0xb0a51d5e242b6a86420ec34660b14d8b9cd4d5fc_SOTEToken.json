{"SourceCode": "pragma solidity 0.5.17;\r\n\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract ISOTEMaster {\r\n\r\n    address public tokenAddress;\r\n\r\n    address public owner;\r\n\r\n    uint public pauseTime;\r\n\r\n    function delegateCallBack(bytes32 myid) external;\r\n\r\n    function masterInitialized() public view returns(bool);\r\n    \r\n    function isInternal(address _add) public view returns(bool);\r\n\r\n    function isPause() public view returns(bool check);\r\n\r\n    function isOwner(address _add) public view returns(bool);\r\n\r\n    function isMember(address _add) public view returns(bool);\r\n    \r\n    function checkIsAuthToGoverned(address _add) public view returns(bool);\r\n\r\n    function updatePauseTime(uint _time) public;\r\n\r\n    function dAppLocker() public view returns(address _add);\r\n\r\n    function dAppToken() public view returns(address _add);\r\n\r\n    function getLatestAddress(bytes2 _contractName) public view returns(address payable contractAddress);\r\n}\r\n\r\ncontract Iupgradable {\r\n\r\n    ISOTEMaster public ms;\r\n    address public soteMasterAddress;\r\n\r\n    modifier onlyInternal {\r\n        require(ms.isInternal(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier isMemberAndcheckPause {\r\n        require(ms.isPause() == false && ms.isMember(msg.sender) == true);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(ms.isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier checkPause {\r\n        require(ms.isPause() == false);\r\n        _;\r\n    }\r\n\r\n    modifier isMember {\r\n        require(ms.isMember(msg.sender), \"Not member\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function  changeDependentContractAddress() public;\r\n\r\n    /**\r\n     * @dev change master address\r\n     * @param _masterAddress is the new address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (address(ms) != address(0)) {\r\n            require(address(ms) == msg.sender, \"Not master\");\r\n        }\r\n        ms = ISOTEMaster(_masterAddress);\r\n        soteMasterAddress = _masterAddress;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract ClaimsData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    struct Claim {\r\n        uint coverId;\r\n        uint dateUpd;\r\n    }\r\n\r\n    struct Vote {\r\n        address voter;\r\n        uint tokens;\r\n        uint claimId;\r\n        int8 verdict;\r\n        bool rewardClaimed;\r\n    }\r\n\r\n    struct ClaimsPause {\r\n        uint coverid;\r\n        uint dateUpd;\r\n        bool submit;\r\n    }\r\n\r\n    struct ClaimPauseVoting {\r\n        uint claimid;\r\n        uint pendingTime;\r\n        bool voting;\r\n    }\r\n\r\n    struct RewardDistributed {\r\n        uint lastCAvoteIndex;\r\n        uint lastMVvoteIndex;\r\n\r\n    }\r\n\r\n    struct ClaimRewardDetails {\r\n        uint percCA;\r\n        uint percMV;\r\n        uint tokenToBeDist;\r\n\r\n    }\r\n\r\n    struct ClaimTotalTokens {\r\n        uint accept;\r\n        uint deny;\r\n    }\r\n\r\n    struct ClaimRewardStatus {\r\n        uint percCA;\r\n        uint percMV;\r\n    }\r\n\r\n    ClaimRewardStatus[] internal rewardStatus;\r\n\r\n    Claim[] internal allClaims;\r\n    Vote[] internal allvotes;\r\n    ClaimsPause[] internal claimPause;\r\n    ClaimPauseVoting[] internal claimPauseVotingEP;\r\n\r\n    mapping(address => RewardDistributed) internal voterVoteRewardReceived;\r\n    mapping(uint => ClaimRewardDetails) internal claimRewardDetail;\r\n    mapping(uint => ClaimTotalTokens) internal claimTokensCA;\r\n    mapping(uint => ClaimTotalTokens) internal claimTokensMV;\r\n    mapping(uint => int8) internal claimVote;\r\n    mapping(uint => uint) internal claimsStatus;\r\n    mapping(uint => uint) internal claimState12Count;\r\n    mapping(uint => uint[]) internal claimVoteCA;\r\n    mapping(uint => uint[]) internal claimVoteMember;\r\n    mapping(address => uint[]) internal voteAddressCA;\r\n    mapping(address => uint[]) internal voteAddressMember;\r\n    mapping(address => uint[]) internal allClaimsByAddress;\r\n    mapping(address => mapping(uint => uint)) internal userClaimVoteCA;\r\n    mapping(address => mapping(uint => uint)) internal userClaimVoteMember;\r\n    mapping(address => uint) public userClaimVotePausedOn;\r\n\r\n    uint internal claimPauseLastsubmit;\r\n    uint internal claimStartVotingFirstIndex;\r\n    uint public pendingClaimStart;\r\n    uint public claimDepositTime;\r\n    uint public maxVotingTime;\r\n    uint public minVotingTime;\r\n    uint public payoutRetryTime;\r\n    uint public claimRewardPerc;\r\n    uint public minVoteThreshold;\r\n    uint public maxVoteThreshold;\r\n    uint public majorityConsensus;\r\n    uint public pauseDaysCA;\r\n   \r\n    event ClaimRaise(\r\n        uint indexed coverId,\r\n        address indexed userAddress,\r\n        uint claimId,\r\n        uint dateSubmit\r\n    );\r\n\r\n    event VoteCast(\r\n        address indexed userAddress,\r\n        uint indexed claimId,\r\n        bytes4 indexed typeOf,\r\n        uint tokens,\r\n        uint submitDate,\r\n        int8 verdict\r\n    );\r\n\r\n    constructor() public {\r\n        pendingClaimStart = 1;\r\n        maxVotingTime = 48 * 1 hours;\r\n        minVotingTime = 12 * 1 hours;\r\n        payoutRetryTime = 24 * 1 hours;\r\n        allvotes.push(Vote(address(0), 0, 0, 0, false));\r\n        allClaims.push(Claim(0, 0));\r\n        claimDepositTime = 7 days;\r\n        claimRewardPerc = 20;\r\n        minVoteThreshold = 5;\r\n        maxVoteThreshold = 10;\r\n        majorityConsensus = 70;\r\n        pauseDaysCA = 3 days;\r\n        _addRewardIncentive();\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the pending claim start variable, \r\n     * the lowest claim id with a pending decision/payout.\r\n     */ \r\n    function setpendingClaimStart(uint _start) external onlyInternal {\r\n        require(pendingClaimStart <= _start);\r\n        pendingClaimStart = _start;\r\n    }\r\n\r\n    /** \r\n     * @dev Updates the max vote index for which claim assessor has received reward \r\n     * @param _voter address of the voter.\r\n     * @param caIndex last index till which reward was distributed for CA\r\n     */ \r\n    function setRewardDistributedIndexCA(address _voter, uint caIndex) external onlyInternal {\r\n        voterVoteRewardReceived[_voter].lastCAvoteIndex = caIndex;\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Used to pause claim assessor activity for 3 days \r\n     * @param user Member address whose claim voting ability needs to be paused\r\n     */ \r\n    function setUserClaimVotePausedOn(address user) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        userClaimVotePausedOn[user] = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the max vote index for which member has received reward \r\n     * @param _voter address of the voter.\r\n     * @param mvIndex last index till which reward was distributed for member \r\n     */ \r\n    function setRewardDistributedIndexMV(address _voter, uint mvIndex) external onlyInternal {\r\n\r\n        voterVoteRewardReceived[_voter].lastMVvoteIndex = mvIndex;\r\n    }\r\n\r\n    /**\r\n     * @param claimid claim id.\r\n     * @param percCA reward Percentage reward for claim assessor\r\n     * @param percMV reward Percentage reward for members\r\n     * @param tokens total tokens to be rewarded\r\n     */ \r\n    function setClaimRewardDetail(\r\n        uint claimid,\r\n        uint percCA,\r\n        uint percMV,\r\n        uint tokens\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimRewardDetail[claimid].percCA = percCA;\r\n        claimRewardDetail[claimid].percMV = percMV;\r\n        claimRewardDetail[claimid].tokenToBeDist = tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the reward claim status against a vote id.\r\n     * @param _voteid vote Id.\r\n     * @param claimed true if reward for vote is claimed, else false.\r\n     */ \r\n    function setRewardClaimed(uint _voteid, bool claimed) external onlyInternal {\r\n        allvotes[_voteid].rewardClaimed = claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the final vote's result(either accepted or declined)of a claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 if claim is accepted,-1 if declined.\r\n     */ \r\n    function changeFinalVerdict(uint _claimId, int8 _verdict) external onlyInternal {\r\n        claimVote[_claimId] = _verdict;\r\n    }\r\n    \r\n    /**\r\n     * @dev Creates a new claim.\r\n     */ \r\n    function addClaim(\r\n        uint _claimId,\r\n        uint _coverId,\r\n        address _from,\r\n        uint _nowtime\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        allClaims.push(Claim(_coverId, _nowtime));\r\n        allClaimsByAddress[_from].push(_claimId);\r\n    }\r\n\r\n    /**\r\n     * @dev Add Vote's details of a given claim.\r\n     */ \r\n    function addVote(\r\n        address _voter,\r\n        uint _tokens,\r\n        uint claimId,\r\n        int8 _verdict\r\n    ) \r\n        external\r\n        onlyInternal\r\n    {\r\n        allvotes.push(Vote(_voter, _tokens, claimId, _verdict, false));\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id of the claim assessor vote given to a claim.\r\n     * Maintains record of all votes given by all the CA to a claim.\r\n     * @param _claimId Claim Id to which vote has given by the CA.\r\n     * @param _voteid Vote Id.\r\n     */\r\n    function addClaimVoteCA(uint _claimId, uint _voteid) external onlyInternal {\r\n        claimVoteCA[_claimId].push(_voteid);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the id of the vote.\r\n     * @param _from Claim assessor's address who has given the vote.\r\n     * @param _claimId Claim Id for which vote has been given by the CA.\r\n     * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n     */ \r\n    function setUserClaimVoteCA(\r\n        address _from,\r\n        uint _claimId,\r\n        uint _voteid\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        userClaimVoteCA[_from][_claimId] = _voteid;\r\n        voteAddressCA[_from].push(_voteid);\r\n    }\r\n\r\n    /**\r\n     * @dev Stores the tokens locked by the Claim Assessors during voting of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n     * -1 for deny and increases the tokens of claim as deny.\r\n     * @param _tokens Number of tokens.\r\n     */ \r\n    function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n        if (_vote == 1)\r\n            claimTokensCA[_claimId].accept = claimTokensCA[_claimId].accept.add(_tokens);\r\n        if (_vote == -1)\r\n            claimTokensCA[_claimId].deny = claimTokensCA[_claimId].deny.add(_tokens);\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the tokens locked by the Members during voting of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _vote 1 for accept and increases the tokens of claim as accept,\r\n     * -1 for deny and increases the tokens of claim as deny.\r\n     * @param _tokens Number of tokens.\r\n     */ \r\n    function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external onlyInternal {\r\n        if (_vote == 1)\r\n            claimTokensMV[_claimId].accept = claimTokensMV[_claimId].accept.add(_tokens);\r\n        if (_vote == -1)\r\n            claimTokensMV[_claimId].deny = claimTokensMV[_claimId].deny.add(_tokens);\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id of the member vote given to a claim.\r\n     * Maintains record of all votes given by all the Members to a claim.\r\n     * @param _claimId Claim Id to which vote has been given by the Member.\r\n     * @param _voteid Vote Id.\r\n     */ \r\n    function addClaimVotemember(uint _claimId, uint _voteid) external onlyInternal {\r\n        claimVoteMember[_claimId].push(_voteid);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the id of the vote.\r\n     * @param _from Member's address who has given the vote.\r\n     * @param _claimId Claim Id for which vote has been given by the Member.\r\n     * @param _voteid Vote Id which will be stored against the given _from and claimid.\r\n     */ \r\n    function setUserClaimVoteMember(\r\n        address _from,\r\n        uint _claimId,\r\n        uint _voteid\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        userClaimVoteMember[_from][_claimId] = _voteid;\r\n        voteAddressMember[_from].push(_voteid);\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Increases the count of failure until payout of a claim is successful.\r\n     */ \r\n    function updateState12Count(uint _claimId, uint _cnt) external onlyInternal {\r\n        claimState12Count[_claimId] = claimState12Count[_claimId].add(_cnt);\r\n    }\r\n\r\n    /** \r\n     * @dev Sets status of a claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _stat Status number.\r\n     */\r\n    function setClaimStatus(uint _claimId, uint _stat) external onlyInternal {\r\n        claimsStatus[_claimId] = _stat;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the timestamp of a given claim at which the Claim's details has been updated.\r\n     * @param _claimId Claim Id of claim which has been changed.\r\n     * @param _dateUpd timestamp at which claim is updated.\r\n     */ \r\n    function setClaimdateUpd(uint _claimId, uint _dateUpd) external onlyInternal {\r\n        allClaims[_claimId].dateUpd = _dateUpd;\r\n    }\r\n\r\n    /** \r\n     @dev Queues Claims during Emergency Pause.\r\n     */ \r\n    function setClaimAtEmergencyPause(\r\n        uint _coverId,\r\n        uint _dateUpd,\r\n        bool _submit\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPause.push(ClaimsPause(_coverId, _dateUpd, _submit));\r\n    }\r\n\r\n    /** \r\n     * @dev Set submission flag for Claims queued during emergency pause.\r\n     * Set to true after EP is turned off and the claim is submitted .\r\n     */ \r\n    function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external onlyInternal {\r\n        claimPause[_index].submit = _submit;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the index from which claim needs to be \r\n     * submitted when emergency pause is swithched off.\r\n     */ \r\n    function setFirstClaimIndexToSubmitAfterEP(\r\n        uint _firstClaimIndexToSubmit\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPauseLastsubmit = _firstClaimIndexToSubmit;\r\n    }\r\n\r\n    /** \r\n     * @dev Sets the pending vote duration for a claim in case of emergency pause.\r\n     */ \r\n    function setPendingClaimDetails(\r\n        uint _claimId,\r\n        uint _pendingTime,\r\n        bool _voting\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimPauseVotingEP.push(ClaimPauseVoting(_claimId, _pendingTime, _voting));\r\n    }\r\n\r\n    /** \r\n     * @dev Sets voting flag true after claim is reopened for voting after emergency pause.\r\n     */ \r\n    function setPendingClaimVoteStatus(uint _claimId, bool _vote) external onlyInternal {\r\n        claimPauseVotingEP[_claimId].voting = _vote;\r\n    }\r\n    \r\n    /** \r\n     * @dev Sets the index from which claim needs to be \r\n     * reopened when emergency pause is swithched off. \r\n     */ \r\n    function setFirstClaimIndexToStartVotingAfterEP(\r\n        uint _claimStartVotingFirstIndex\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        claimStartVotingFirstIndex = _claimStartVotingFirstIndex;\r\n    }\r\n\r\n    /** \r\n     * @dev Calls Vote Event.\r\n     */ \r\n    function callVoteEvent(\r\n        address _userAddress,\r\n        uint _claimId,\r\n        bytes4 _typeOf,\r\n        uint _tokens,\r\n        uint _submitDate,\r\n        int8 _verdict\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        emit VoteCast(\r\n            _userAddress,\r\n            _claimId,\r\n            _typeOf,\r\n            _tokens,\r\n            _submitDate,\r\n            _verdict\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Calls Claim Event. \r\n     */ \r\n    function callClaimEvent(\r\n        uint _coverId,\r\n        address _userAddress,\r\n        uint _claimId,\r\n        uint _datesubmit\r\n    ) \r\n        external\r\n        onlyInternal\r\n    {\r\n        emit ClaimRaise(_coverId, _userAddress, _claimId, _datesubmit);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters by parameter code\r\n     * @param code whose details we want\r\n     * @return string value of the parameter\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"CAMAXVT\") {\r\n            val = maxVotingTime / (1 hours);\r\n\r\n        } else if (code == \"CAMINVT\") {\r\n\r\n            val = minVotingTime / (1 hours);\r\n\r\n        } else if (code == \"CAPRETRY\") {\r\n\r\n            val = payoutRetryTime / (1 hours);\r\n\r\n        } else if (code == \"CADEPT\") {\r\n\r\n            val = claimDepositTime / (1 days);\r\n\r\n        } else if (code == \"CAREWPER\") {\r\n\r\n            val = claimRewardPerc;\r\n\r\n        } else if (code == \"CAMINTH\") {\r\n\r\n            val = minVoteThreshold;\r\n\r\n        } else if (code == \"CAMAXTH\") {\r\n\r\n            val = maxVoteThreshold;\r\n\r\n        } else if (code == \"CACONPER\") {\r\n\r\n            val = majorityConsensus;\r\n\r\n        } else if (code == \"CAPAUSET\") {\r\n            val = pauseDaysCA / (1 days);\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * @dev Get claim queued during emergency pause by index.\r\n     */ \r\n    function getClaimOfEmergencyPauseByIndex(\r\n        uint _index\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint coverId,\r\n            uint dateUpd,\r\n            bool submit\r\n        )\r\n    {\r\n        coverId = claimPause[_index].coverid;\r\n        dateUpd = claimPause[_index].dateUpd;\r\n        submit = claimPause[_index].submit;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Claim's details of given claimid.   \r\n     */ \r\n    function getAllClaimsByIndex(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint coverId,\r\n            int8 vote,\r\n            uint status,\r\n            uint dateUpd,\r\n            uint state12Count\r\n        )\r\n    {\r\n        return(\r\n            allClaims[_claimId].coverId,\r\n            claimVote[_claimId],\r\n            claimsStatus[_claimId],\r\n            allClaims[_claimId].dateUpd,\r\n            claimState12Count[_claimId]\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the vote id of a given claim of a given Claim Assessor.\r\n     */ \r\n    function getUserClaimVoteCA(\r\n        address _add,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(uint idVote)\r\n    {\r\n        return userClaimVoteCA[_add][_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the vote id of a given claim of a given member.\r\n     */\r\n    function getUserClaimVoteMember(\r\n        address _add,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(uint idVote)\r\n    {\r\n        return userClaimVoteMember[_add][_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the count of all votes.\r\n     */ \r\n    function getAllVoteLength() external view returns(uint voteCount) {\r\n        return allvotes.length.sub(1); //Start Index always from 1.\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the status number of a given claim.\r\n     * @param _claimId Claim id.\r\n     * @return statno Status Number. \r\n     */ \r\n    function getClaimStatusNumber(uint _claimId) external view returns(uint claimId, uint statno) {\r\n        return (_claimId, claimsStatus[_claimId]);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the reward percentage to be distributed for a given status id\r\n     * @param statusNumber the number of type of status\r\n     * @return percCA reward Percentage for claim assessor\r\n     * @return percMV reward Percentage for members\r\n     */\r\n    function getRewardStatus(uint statusNumber) external view returns(uint percCA, uint percMV) {\r\n        return (rewardStatus[statusNumber].percCA, rewardStatus[statusNumber].percMV);\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the number of tries that have been made for a successful payout of a Claim.\r\n     */ \r\n    function getClaimState12Count(uint _claimId) external view returns(uint num) {\r\n        num = claimState12Count[_claimId];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the last update date of a claim.\r\n     */ \r\n    function getClaimDateUpd(uint _claimId) external view returns(uint dateupd) {\r\n        dateupd = allClaims[_claimId].dateUpd;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all Claims created by a user till date.\r\n     * @param _member user's address.\r\n     * @return claimarr List of Claims id.\r\n     */ \r\n    function getAllClaimsByAddress(address _member) external view returns(uint[] memory claimarr) {\r\n        return allClaimsByAddress[_member];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of tokens that has been locked \r\n     * while giving vote to a claim by  Claim Assessors.\r\n     * @param _claimId Claim Id.\r\n     * @return accept Total number of tokens when CA accepts the claim.\r\n     * @return deny Total number of tokens when CA declines the claim.\r\n     */ \r\n    function getClaimsTokenCA(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint accept,\r\n            uint deny\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            claimTokensCA[_claimId].accept,\r\n            claimTokensCA[_claimId].deny\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the number of tokens that have been\r\n     * locked while assessing a claim as a member.\r\n     * @param _claimId Claim Id.\r\n     * @return accept Total number of tokens in acceptance of the claim.\r\n     * @return deny Total number of tokens against the claim.\r\n     */ \r\n    function getClaimsTokenMV(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint accept,\r\n            uint deny\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            claimTokensMV[_claimId].accept,\r\n            claimTokensMV[_claimId].deny\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of votes cast as Claims assessor for/against a given claim\r\n     */ \r\n    function getCaClaimVotesToken(uint _claimId) external view returns(uint claimId, uint cnt) {\r\n        claimId = _claimId;\r\n        cnt = 0;\r\n        for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\r\n            cnt = cnt.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of tokens cast as a member for/against a given claim  \r\n     */ \r\n    function getMemberClaimVotesToken(\r\n        uint _claimId\r\n    )   \r\n        external\r\n        view\r\n        returns(uint claimId, uint cnt)\r\n    {\r\n        claimId = _claimId;\r\n        cnt = 0;\r\n        for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\r\n            cnt = cnt.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Provides information of a vote when given its vote id.\r\n     * @param _voteid Vote Id.\r\n     */\r\n    function getVoteDetails(uint _voteid)\r\n    external view\r\n    returns(\r\n        uint tokens,\r\n        uint claimId,\r\n        int8 verdict,\r\n        bool rewardClaimed\r\n        )\r\n    {\r\n        return (\r\n            allvotes[_voteid].tokens,\r\n            allvotes[_voteid].claimId,\r\n            allvotes[_voteid].verdict,\r\n            allvotes[_voteid].rewardClaimed\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the voter's address of a given vote id.\r\n     */ \r\n    function getVoterVote(uint _voteid) external view returns(address voter) {\r\n        return allvotes[_voteid].voter;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides information of a Claim when given its claim id.\r\n     * @param _claimId Claim Id.\r\n     */ \r\n    function getClaim(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint coverId,\r\n            int8 vote,\r\n            uint status,\r\n            uint dateUpd,\r\n            uint state12Count\r\n        )\r\n    {\r\n        return (\r\n            _claimId,\r\n            allClaims[_claimId].coverId,\r\n            claimVote[_claimId],\r\n            claimsStatus[_claimId],\r\n            allClaims[_claimId].dateUpd,\r\n            claimState12Count[_claimId]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total number of votes of a given claim.\r\n     * @param _claimId Claim Id.\r\n     * @param _ca if 1: votes given by Claim Assessors to a claim,\r\n     * else returns the number of votes of given by Members to a claim.\r\n     * @return len total number of votes for/against a given claim.\r\n     */ \r\n    function getClaimVoteLength(\r\n        uint _claimId,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(uint claimId, uint len)\r\n    {\r\n        claimId = _claimId;\r\n        if (_ca == 1)\r\n            len = claimVoteCA[_claimId].length;\r\n        else\r\n            len = claimVoteMember[_claimId].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the verdict of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return ver 1 if vote was given in favour,-1 if given in against.\r\n     */ \r\n    function getVoteVerdict(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(int8 ver)\r\n    {\r\n        if (_ca == 1)\r\n            ver = allvotes[claimVoteCA[_claimId][_index]].verdict;\r\n        else\r\n            ver = allvotes[claimVoteMember[_claimId][_index]].verdict;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Number of tokens of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return tok Number of tokens.\r\n     */ \r\n    function getVoteToken(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )   \r\n        external\r\n        view\r\n        returns(uint tok)\r\n    {\r\n        if (_ca == 1)\r\n            tok = allvotes[claimVoteCA[_claimId][_index]].tokens;\r\n        else\r\n            tok = allvotes[claimVoteMember[_claimId][_index]].tokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Voter's address of a vote using claim id and index.\r\n     * @param _ca 1 for vote given as a CA, else for vote given as a member.\r\n     * @return voter Voter's address.\r\n     */ \r\n    function getVoteVoter(\r\n        uint _claimId,\r\n        uint _index,\r\n        uint8 _ca\r\n    )\r\n        external\r\n        view\r\n        returns(address voter)\r\n    {\r\n        if (_ca == 1)\r\n            voter = allvotes[claimVoteCA[_claimId][_index]].voter;\r\n        else\r\n            voter = allvotes[claimVoteMember[_claimId][_index]].voter;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets total number of Claims created by a user till date.\r\n     * @param _add User's address.\r\n     */ \r\n    function getUserClaimCount(address _add) external view returns(uint len) {\r\n        len = allClaimsByAddress[_add].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates number of Claims that are in pending state.\r\n     */ \r\n    function getClaimLength() external view returns(uint len) {\r\n        len = allClaims.length.sub(pendingClaimStart);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Number of all the Claims created till date.\r\n     */ \r\n    function actualClaimLength() external view returns(uint len) {\r\n        len = allClaims.length;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets details of a claim.\r\n     * @param _index claim id = pending claim start + given index\r\n     * @param _add User's address.\r\n     * @return coverid cover against which claim has been submitted.\r\n     * @return claimId Claim  Id.\r\n     * @return voteCA verdict of vote given as a Claim Assessor.  \r\n     * @return voteMV verdict of vote given as a Member.\r\n     * @return statusnumber Status of claim.\r\n     */ \r\n    function getClaimFromNewStart(\r\n        uint _index,\r\n        address _add\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint coverid,\r\n            uint claimId,\r\n            int8 voteCA,\r\n            int8 voteMV,\r\n            uint statusnumber\r\n        )\r\n    {\r\n        uint i = pendingClaimStart.add(_index);\r\n        coverid = allClaims[i].coverId;\r\n        claimId = i;\r\n        if (userClaimVoteCA[_add][i] > 0)\r\n            voteCA = allvotes[userClaimVoteCA[_add][i]].verdict;\r\n        else\r\n            voteCA = 0;\r\n\r\n        if (userClaimVoteMember[_add][i] > 0)\r\n            voteMV = allvotes[userClaimVoteMember[_add][i]].verdict;\r\n        else\r\n            voteMV = 0;\r\n\r\n        statusnumber = claimsStatus[i];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a claim of a user at a given index.  \r\n     */ \r\n    function getUserClaimByIndex(\r\n        uint _index,\r\n        address _add\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint status,\r\n            uint coverid,\r\n            uint claimId\r\n        )\r\n    {\r\n        claimId = allClaimsByAddress[_add][_index];\r\n        status = claimsStatus[claimId];\r\n        coverid = allClaims[claimId].coverId;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Id of all the votes given to a claim.\r\n     * @param _claimId Claim Id.\r\n     * @return ca id of all the votes given by Claim assessors to a claim.\r\n     * @return mv id of all the votes given by members to a claim.\r\n     */ \r\n    function getAllVotesForClaim(\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint[] memory ca,\r\n            uint[] memory mv\r\n        )\r\n    {\r\n        return (_claimId, claimVoteCA[_claimId], claimVoteMember[_claimId]);\r\n    }\r\n\r\n    /** \r\n     * @dev Gets Number of tokens deposit in a vote using\r\n     * Claim assessor's address and claim id.\r\n     * @return tokens Number of deposited tokens.\r\n     */ \r\n    function getTokensClaim(\r\n        address _of,\r\n        uint _claimId\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint tokens\r\n        )\r\n    {\r\n        return (_claimId, allvotes[userClaimVoteCA[_of][_claimId]].tokens);\r\n    }\r\n\r\n    /**\r\n     * @param _voter address of the voter.\r\n     * @return lastCAvoteIndex last index till which reward was distributed for CA\r\n     * @return lastMVvoteIndex last index till which reward was distributed for member\r\n     */ \r\n    function getRewardDistributedIndex(\r\n        address _voter\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint lastCAvoteIndex,\r\n            uint lastMVvoteIndex\r\n        )\r\n    {\r\n        return (\r\n            voterVoteRewardReceived[_voter].lastCAvoteIndex,\r\n            voterVoteRewardReceived[_voter].lastMVvoteIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @param claimid claim id.\r\n     * @return perc_CA reward Percentage for claim assessor\r\n     * @return perc_MV reward Percentage for members\r\n     * @return tokens total tokens to be rewarded \r\n     */ \r\n    function getClaimRewardDetail(\r\n        uint claimid\r\n    ) \r\n        external\r\n        view\r\n        returns(\r\n            uint percCA,\r\n            uint percMV,\r\n            uint tokens\r\n        )\r\n    {\r\n        return (\r\n            claimRewardDetail[claimid].percCA,\r\n            claimRewardDetail[claimid].percMV,\r\n            claimRewardDetail[claimid].tokenToBeDist\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets cover id of a claim.\r\n     */ \r\n    function getClaimCoverId(uint _claimId) external view returns(uint claimId, uint coverid) {\r\n        return (_claimId, allClaims[_claimId].coverId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total number of tokens staked during voting by Claim Assessors.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 to get total number of accept tokens, -1 to get total number of deny tokens.\r\n     * @return token token Number of tokens(either accept or deny on the basis of verdict given as parameter).\r\n     */ \r\n    function getClaimVote(uint _claimId, int8 _verdict) external view returns(uint claimId, uint token) {\r\n        claimId = _claimId;\r\n        token = 0;\r\n        for (uint i = 0; i < claimVoteCA[_claimId].length; i++) {\r\n            if (allvotes[claimVoteCA[_claimId][i]].verdict == _verdict)\r\n                token = token.add(allvotes[claimVoteCA[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total number of tokens staked during voting by Members.\r\n     * @param _claimId Claim Id.\r\n     * @param _verdict 1 to get total number of accept tokens,\r\n     *  -1 to get total number of deny tokens.\r\n     * @return token token Number of tokens(either accept or \r\n     * deny on the basis of verdict given as parameter).\r\n     */ \r\n    function getClaimMVote(uint _claimId, int8 _verdict) external view returns(uint claimId, uint token) {\r\n        claimId = _claimId;\r\n        token = 0;\r\n        for (uint i = 0; i < claimVoteMember[_claimId].length; i++) {\r\n            if (allvotes[claimVoteMember[_claimId][i]].verdict == _verdict)\r\n                token = token.add(allvotes[claimVoteMember[_claimId][i]].tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voteid\r\n     * @param index index to get voteid in CA\r\n     */ \r\n    function getVoteAddressCA(address _voter, uint index) external view returns(uint) {\r\n        return voteAddressCA[_voter][index];\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter\r\n     * @param index index to get voteid in member vote\r\n     */ \r\n    function getVoteAddressMember(address _voter, uint index) external view returns(uint) {\r\n        return voteAddressMember[_voter][index];\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter   \r\n     */ \r\n    function getVoteAddressCALength(address _voter) external view returns(uint) {\r\n        return voteAddressCA[_voter].length;\r\n    }\r\n\r\n    /**\r\n     * @param _voter address  of voter   \r\n     */ \r\n    function getVoteAddressMemberLength(address _voter) external view returns(uint) {\r\n        return voteAddressMember[_voter].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Final result of voting of a claim.\r\n     * @param _claimId Claim id.\r\n     * @return verdict 1 if claim is accepted, -1 if declined.\r\n     */ \r\n    function getFinalVerdict(uint _claimId) external view returns(int8 verdict) {\r\n        return claimVote[_claimId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of Claims queued for submission during emergency pause.\r\n     */ \r\n    function getLengthOfClaimSubmittedAtEP() external view returns(uint len) {\r\n        len = claimPause.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the index from which claim needs to be \r\n     * submitted when emergency pause is swithched off.\r\n     */ \r\n    function getFirstClaimIndexToSubmitAfterEP() external view returns(uint indexToSubmit) {\r\n        indexToSubmit = claimPauseLastsubmit;\r\n    }\r\n    \r\n    /**\r\n     * @dev Gets number of Claims to be reopened for voting post emergency pause period.\r\n     */ \r\n    function getLengthOfClaimVotingPause() external view returns(uint len) {\r\n        len = claimPauseVotingEP.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets claim details to be reopened for voting after emergency pause.\r\n     */ \r\n    function getPendingClaimDetailsByIndex(\r\n        uint _index\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint claimId,\r\n            uint pendingTime,\r\n            bool voting\r\n        )\r\n    {\r\n        claimId = claimPauseVotingEP[_index].claimid;\r\n        pendingTime = claimPauseVotingEP[_index].pendingTime;\r\n        voting = claimPauseVotingEP[_index].voting;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the index from which claim needs to be reopened when emergency pause is swithched off.\r\n     */ \r\n    function getFirstClaimIndexToStartVotingAfterEP() external view returns(uint firstindex) {\r\n        firstindex = claimStartVotingFirstIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"CAMAXVT\") {\r\n            _setMaxVotingTime(val * 1 hours);\r\n\r\n        } else if (code == \"CAMINVT\") {\r\n\r\n            _setMinVotingTime(val * 1 hours);\r\n\r\n        } else if (code == \"CAPRETRY\") {\r\n\r\n            _setPayoutRetryTime(val * 1 hours);\r\n\r\n        } else if (code == \"CADEPT\") {\r\n\r\n            _setClaimDepositTime(val * 1 days);\r\n\r\n        } else if (code == \"CAREWPER\") {\r\n\r\n            _setClaimRewardPerc(val);\r\n\r\n        } else if (code == \"CAMINTH\") {\r\n\r\n            _setMinVoteThreshold(val);\r\n\r\n        } else if (code == \"CAMAXTH\") {\r\n\r\n            _setMaxVoteThreshold(val);\r\n\r\n        } else if (code == \"CACONPER\") {\r\n\r\n            _setMajorityConsensus(val);\r\n\r\n        } else if (code == \"CAPAUSET\") {\r\n            _setPauseDaysCA(val * 1 days);\r\n        } else {\r\n\r\n            revert(\"Invalid param code\");\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {}\r\n\r\n    /**\r\n     * @dev Adds status under which a claim can lie.\r\n     * @param percCA reward percentage for claim assessor\r\n     * @param percMV reward percentage for members\r\n     */\r\n    function _pushStatus(uint percCA, uint percMV) internal {\r\n        rewardStatus.push(ClaimRewardStatus(percCA, percMV));\r\n    }\r\n\r\n    /**\r\n     * @dev adds reward incentive for all possible claim status for Claim assessors and members\r\n     */\r\n    function _addRewardIncentive() internal {\r\n        _pushStatus(0, 0); //0  Pending-Claim Assessor Vote\r\n        _pushStatus(0, 0); //1 Pending-Claim Assessor Vote Denied, Pending Member Vote\r\n        _pushStatus(0, 0); //2 Pending-CA Vote Threshold not Reached Accept, Pending Member Vote\r\n        _pushStatus(0, 0); //3 Pending-CA Vote Threshold not Reached Deny, Pending Member Vote\r\n        _pushStatus(0, 0); //4 Pending-CA Consensus not reached Accept, Pending Member Vote\r\n        _pushStatus(0, 0); //5 Pending-CA Consensus not reached Deny, Pending Member Vote\r\n        _pushStatus(100, 0); //6 Final-Claim Assessor Vote Denied\r\n        _pushStatus(100, 0); //7 Final-Claim Assessor Vote Accepted\r\n        _pushStatus(0, 100); //8 Final-Claim Assessor Vote Denied, MV Accepted\r\n        _pushStatus(0, 100); //9 Final-Claim Assessor Vote Denied, MV Denied\r\n        _pushStatus(0, 0); //10 Final-Claim Assessor Vote Accept, MV Nodecision\r\n        _pushStatus(0, 0); //11 Final-Claim Assessor Vote Denied, MV Nodecision\r\n        _pushStatus(0, 0); //12 Claim Accepted Payout Pending\r\n        _pushStatus(0, 0); //13 Claim Accepted No Payout \r\n        _pushStatus(0, 0); //14 Claim Accepted Payout Done\r\n    }\r\n\r\n    /**\r\n     * @dev Sets Maximum time(in seconds) for which claim assessment voting is open\r\n     */ \r\n    function _setMaxVotingTime(uint _time) internal {\r\n        maxVotingTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Minimum time(in seconds) for which claim assessment voting is open\r\n     */ \r\n    function _setMinVotingTime(uint _time) internal {\r\n        minVotingTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Minimum vote threshold required\r\n     */ \r\n    function _setMinVoteThreshold(uint val) internal {\r\n        minVoteThreshold = val;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets Maximum vote threshold required\r\n     */ \r\n    function _setMaxVoteThreshold(uint val) internal {\r\n        maxVoteThreshold = val;\r\n    }\r\n    \r\n    /**\r\n     *  @dev Sets the value considered as Majority Consenus in voting\r\n     */ \r\n    function _setMajorityConsensus(uint val) internal {\r\n        majorityConsensus = val;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the payout retry time\r\n     */ \r\n    function _setPayoutRetryTime(uint _time) internal {\r\n        payoutRetryTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets percentage of reward given for claim assessment\r\n     */ \r\n    function _setClaimRewardPerc(uint _val) internal {\r\n\r\n        claimRewardPerc = _val;\r\n    }\r\n  \r\n    /** \r\n     * @dev Sets the time for which claim is deposited.\r\n     */ \r\n    function _setClaimDepositTime(uint _time) internal {\r\n\r\n        claimDepositTime = _time;\r\n    }\r\n\r\n    /**\r\n     *  @dev Sets number of days claim assessment will be paused\r\n     */ \r\n    function _setPauseDaysCA(uint val) internal {\r\n        pauseDaysCA = val;\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract IProposalCategory {\r\n\r\n    event Category(\r\n        uint indexed categoryId,\r\n        string categoryName,\r\n        string actionHash\r\n    );\r\n\r\n    /// @dev Adds new category\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function addCategory(\r\n        string calldata _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc, \r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev gets category details\r\n    function category(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            uint memberRoleToVote,\r\n            uint majorityVotePerc,\r\n            uint quorumPerc,\r\n            uint[] memory allowedToCreateProposal,\r\n            uint closingTime,\r\n            uint minStake\r\n        );\r\n    \r\n    ///@dev gets category action details\r\n    function categoryAction(uint _categoryId)\r\n        external\r\n        view\r\n        returns(\r\n            uint categoryId,\r\n            address contractAddress,\r\n            bytes2 contractName,\r\n            uint defaultIncentive\r\n        );\r\n    \r\n    /// @dev Gets Total number of categories added till now\r\n    function totalCategories() external view returns(uint numberOfCategories);\r\n\r\n    /// @dev Updates category details\r\n    /// @param _categoryId Category id that needs to be updated\r\n    /// @param _name Category name\r\n    /// @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    /// @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    /// @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    /// @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    /// @param _closingTime Vote closing time for Each voting layer\r\n    /// @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    /// @param _contractAddress address of contract to call after proposal is accepted\r\n    /// @param _contractName name of contract to be called after proposal is accepted\r\n    /// @param _incentives rewards to distributed after proposal is accepted\r\n    function updateCategory(\r\n        uint _categoryId, \r\n        string memory _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives\r\n    )\r\n        public;\r\n\r\n}\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract IMaster {\r\n    function getLatestAddress(bytes2 _module) public view returns(address);\r\n}\r\n\r\ncontract Governed {\r\n\r\n    address public masterAddress; // Name of the dApp, needs to be set by contracts inheriting this contract\r\n\r\n    /// @dev modifier that allows only the authorized addresses to execute the function\r\n    modifier onlyAuthorizedToGovern() {\r\n        IMaster ms = IMaster(masterAddress);\r\n        require(ms.getLatestAddress(\"GV\") == msg.sender, \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @dev checks if an address is authorized to govern\r\n    function isAuthorizedToGovern(address _toCheck) public view returns(bool) {\r\n        IMaster ms = IMaster(masterAddress);\r\n        return (ms.getLatestAddress(\"GV\") == _toCheck);\r\n    } \r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n        external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n        external returns (bool);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external view returns (uint256);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract SOTEToken is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    event WhiteListed(address indexed member);\r\n\r\n    event BlackListed(address indexed member);\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    mapping (address => bool) public whiteListed;\r\n\r\n    mapping(address => uint) public isLockedForMV;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string public name = \"SOTE\";\r\n    string public symbol = \"SOTE\";\r\n    uint8 public decimals = 18;\r\n    address public operator;\r\n\r\n    modifier canTransfer(address _to) {\r\n        require(whiteListed[_to]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        if (operator != address(0))\r\n            require(msg.sender == operator);\r\n        _;\r\n    }\r\n\r\n    constructor(address _founderAddress, uint _initialSupply) public {\r\n        _mint(_founderAddress, _initialSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param owner address The address which owns the funds.\r\n    * @param spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param spender The address which will spend the funds.\r\n    * @param value The amount of tokens to be spent.\r\n    */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param spender The address which will spend the funds.\r\n    * @param addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = (\r\n        _allowed[msg.sender][spender].add(addedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param spender The address which will spend the funds.\r\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = (\r\n        _allowed[msg.sender][spender].sub(subtractedValue));\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds a user to whitelist\r\n    * @param _member address to add to whitelist\r\n    */\r\n    function addToWhiteList(address _member) public onlyOperator returns (bool) {\r\n        whiteListed[_member] = true;\r\n        emit WhiteListed(_member);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev removes a user from whitelist\r\n    * @param _member address to remove from whitelist\r\n    */\r\n    function removeFromWhiteList(address _member) public onlyOperator returns (bool) {\r\n        whiteListed[_member] = false;\r\n        emit BlackListed(_member);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev change operator address \r\n    * @param _newOperator address of new operator\r\n    */\r\n    function changeOperator(address _newOperator) public onlyOperator returns (bool) {\r\n        operator = _newOperator;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev burns an amount of the tokens of the message sender\r\n    * account.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function burn(uint256 amount) public returns (bool) {\r\n        _burn(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n    * @param from address The address which you want to send tokens from\r\n    * @param value uint256 The amount of token to be burned\r\n    */\r\n    function burnFrom(address from, uint256 value) public returns (bool) {\r\n        _burnFrom(from, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev function that mints an amount of the token and assigns it to\r\n    * an account.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function mint(address account, uint256 amount) public onlyOperator {\r\n        _mint(account, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) public canTransfer(to) returns (bool) {\r\n\r\n        require(isLockedForMV[msg.sender] < now); // if not voted under governance\r\n        require(value <= _balances[msg.sender]);\r\n        _transfer(to, value); \r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens to the operator from the specified address\r\n    * @param from The address to transfer from.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function operatorTransfer(address from, uint256 value) public onlyOperator returns (bool) {\r\n        require(value <= _balances[from]);\r\n        _transferFrom(from, operator, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        public\r\n        canTransfer(to)\r\n        returns (bool)\r\n    {\r\n        require(isLockedForMV[from] < now); // if not voted under governance\r\n        require(value <= _balances[from]);\r\n        require(value <= _allowed[from][msg.sender]);\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Lock the user's tokens \r\n     * @param _of user's address.\r\n     */\r\n    function lockForMemberVote(address _of, uint _days) public onlyOperator {\r\n        if (_days.add(now) > isLockedForMV[_of])\r\n            isLockedForMV[_of] = _days.add(now);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function _transfer(address to, uint256 value) internal {\r\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        emit Transfer(msg.sender, to, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param from address The address which you want to send tokens from\r\n    * @param to address The address which you want to transfer to\r\n    * @param value uint256 the amount of tokens to be transferred\r\n    */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        internal\r\n    {\r\n        _balances[from] = _balances[from].sub(value);\r\n        _balances[to] = _balances[to].add(value);\r\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param account The account that will receive the created tokens.\r\n    * @param amount The amount that will be created.\r\n    */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0));\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account.\r\n    * @param account The account whose tokens will be burnt.\r\n    * @param amount The amount that will be burnt.\r\n    */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(amount <= _balances[account]);\r\n\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[account] = _balances[account].sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account, deducting from the sender's allowance for said account. Uses the\r\n    * internal burn function.\r\n    * @param account The account whose tokens will be burnt.\r\n    * @param value The amount that will be burnt.\r\n    */\r\n    function _burnFrom(address account, uint256 value) internal {\r\n        require(value <= _allowed[account][msg.sender]);\r\n\r\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n        // this function needs to emit an event with the updated approval.\r\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n        value);\r\n        _burn(account, value);\r\n    }\r\n}\r\n\r\ninterface IPooledStaking {\r\n\r\n    function accumulateReward(address contractAddress, uint amount) external;\r\n    function pushBurn(address contractAddress, uint amount) external;\r\n    function hasPendingActions() external view returns (bool);\r\n\r\n    function contractStake(address contractAddress) external view returns (uint);\r\n    function stakerReward(address staker) external view returns (uint);\r\n    function stakerDeposit(address staker) external view returns (uint);\r\n    function stakerContractStake(address staker, address contractAddress) external view returns (uint);\r\n\r\n    function withdraw(uint amount) external;\r\n    function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\r\n    function withdrawReward(address stakerAddress) external;\r\n}\r\n\r\n/* Copyright (C) 2020 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract TokenFunctions is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    MCR internal m1;\r\n    MemberRoles internal mr;\r\n    SOTEToken public tk;\r\n    TokenController internal tc;\r\n    TokenData internal td;\r\n    QuotationData internal qd;\r\n    ClaimsReward internal cr;\r\n    Governance internal gv;\r\n    PoolData internal pd;\r\n    IPooledStaking pooledStaking;\r\n\r\n    event BurnCATokens(uint claimId, address addr, uint amount);\r\n\r\n    /**\r\n     * @dev Rewards stakers on purchase of cover on smart contract.\r\n     * @param _contractAddress smart contract address.\r\n     * @param _coverPriceSOTE cover price in SOTE.\r\n     */\r\n    function pushStakerRewards(address _contractAddress, uint _coverPriceSOTE) external onlyInternal {\r\n        uint rewardValue = _coverPriceSOTE.mul(td.stakerCommissionPer()).div(100);\r\n        pooledStaking.accumulateReward(_contractAddress, rewardValue);\r\n    }\r\n\r\n    /**\r\n    * @dev Deprecated in favor of burnStakedTokens\r\n    */\r\n    function burnStakerLockedToken(uint, bytes4, uint) external {\r\n        // noop\r\n    }\r\n\r\n    /**\r\n    * @dev Burns tokens staked on smart contract covered by coverId. Called when a payout is succesfully executed.\r\n    * @param coverId cover id\r\n    * @param coverCurrency cover currency\r\n    * @param sumAssured amount of $curr to burn\r\n    */\r\n    function burnStakedTokens(uint coverId, bytes4 coverCurrency, uint sumAssured) external onlyInternal {\r\n        (, address scAddress) = qd.getscAddressOfCover(coverId);\r\n        uint tokenPrice = m1.calculateTokenPrice(coverCurrency);\r\n        uint burnSOTEAmount = sumAssured.mul(1e18).div(tokenPrice);\r\n        pooledStaking.pushBurn(scAddress, burnSOTEAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total staked SOTE tokens against\r\n     * Smart contract by all stakers\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @return amount total staked SOTE tokens.\r\n     */\r\n    function deprecated_getTotalStakedTokensOnSmartContract(\r\n        address _stakedContractAddress\r\n    )\r\n        external\r\n        view\r\n        returns(uint)\r\n    {\r\n        uint stakedAmount = 0;\r\n        address stakerAddress;\r\n        uint staketLen = td.getStakedContractStakersLength(_stakedContractAddress);\r\n\r\n        for (uint i = 0; i < staketLen; i++) {\r\n            stakerAddress = td.getStakedContractStakerByIndex(_stakedContractAddress, i);\r\n            uint stakerIndex = td.getStakedContractStakerIndex(\r\n                _stakedContractAddress, i);\r\n            uint currentlyStaked;\r\n            (, currentlyStaked) = _deprecated_unlockableBeforeBurningAndCanBurn(stakerAddress,\r\n                _stakedContractAddress, stakerIndex);\r\n            stakedAmount = stakedAmount.add(currentlyStaked);\r\n        }\r\n\r\n        return stakedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of SOTE Tokens locked as Cover Note for given coverId.\r\n     * @param _of address of the coverHolder.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function getUserLockedCNTokens(address _of, uint _coverId) external view returns(uint) {\r\n        return _getUserLockedCNTokens(_of, _coverId);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the all the cover locked tokens of a user\r\n     * @param _of is the user address in concern\r\n     * @return amount locked\r\n     */\r\n    function getUserAllLockedCNTokens(address _of) external view returns(uint amount) {\r\n        for (uint i = 0; i < qd.getUserCoverLength(_of); i++) {\r\n            amount = amount.add(_getUserLockedCNTokens(_of, qd.getAllCoversOfUser(_of)[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of SOTE Tokens locked as Cover Note against given coverId.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function getLockedCNAgainstCover(uint _coverId) external view returns(uint) {\r\n        return _getLockedCNAgainstCover(_coverId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total amount of staked SOTE Tokens on all smart contracts.\r\n     * @param _stakerAddress address of the Staker.\r\n     */\r\n    function deprecated_getStakerAllLockedTokens(address _stakerAddress) external view returns (uint amount) {\r\n        uint stakedAmount = 0;\r\n        address scAddress;\r\n        uint scIndex;\r\n        for (uint i = 0; i < td.getStakerStakedContractLength(_stakerAddress); i++) {\r\n            scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\r\n            scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\r\n            uint currentlyStaked;\r\n            (, currentlyStaked) = _deprecated_unlockableBeforeBurningAndCanBurn(_stakerAddress, scAddress, i);\r\n            stakedAmount = stakedAmount.add(currentlyStaked);\r\n        }\r\n        amount = stakedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns total unlockable amount of staked SOTE Tokens on all smart contract .\r\n     * @param _stakerAddress address of the Staker.\r\n     */\r\n    function deprecated_getStakerAllUnlockableStakedTokens(\r\n        address _stakerAddress\r\n    )\r\n    external\r\n    view\r\n    returns (uint amount)\r\n    {\r\n        uint unlockableAmount = 0;\r\n        address scAddress;\r\n        uint scIndex;\r\n        for (uint i = 0; i < td.getStakerStakedContractLength(_stakerAddress); i++) {\r\n            scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\r\n            scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\r\n            unlockableAmount = unlockableAmount.add(\r\n                _deprecated_getStakerUnlockableTokensOnSmartContract(_stakerAddress, scAddress,\r\n                scIndex));\r\n        }\r\n        amount = unlockableAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Change Dependent Contract Address\r\n     */\r\n    function changeDependentContractAddress() public {\r\n        tk = SOTEToken(ms.tokenAddress());\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        gv = Governance(ms.getLatestAddress(\"GV\"));\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Token price in a given currency\r\n     * @param curr Currency name.\r\n     * @return price Token Price.\r\n     */\r\n    function getTokenPrice(bytes4 curr) public view returns(uint price) {\r\n        price = m1.calculateTokenPrice(curr);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the flag to check if cover note is deposited against the cover id\r\n     * @param coverId Cover Id.\r\n     */\r\n    function depositCN(uint coverId) public onlyInternal returns (bool success) {\r\n        require(_getLockedCNAgainstCover(coverId) > 0, \"No cover note available\");\r\n        td.setDepositCN(coverId, true);\r\n        success = true;\r\n    }\r\n\r\n    /**\r\n     * @param _of address of Member\r\n     * @param _coverId Cover Id\r\n     * @param _lockTime Pending Time + Cover Period 7*1 days\r\n     */\r\n    function extendCNEPOff(address _of, uint _coverId, uint _lockTime) public onlyInternal {\r\n        uint timeStamp = now.add(_lockTime);\r\n        uint coverValidUntil = qd.getValidityOfCover(_coverId);\r\n        if (timeStamp >= coverValidUntil) {\r\n            bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\r\n            tc.extendLockOf(_of, reason, timeStamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to burn the deposited cover tokens\r\n     * @param coverId is id of cover whose tokens have to be burned\r\n     * @return the status of the successful burning\r\n     */\r\n    function burnDepositCN(uint coverId) public onlyInternal returns (bool success) {\r\n        address _of = qd.getCoverMemberAddress(coverId);\r\n        uint amount;\r\n        (amount, ) = td.depositedCN(coverId);\r\n        amount = (amount.mul(50)).div(100);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n        tc.burnLockedTokens(_of, reason, amount);\r\n        success = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Unlocks covernote locked against a given cover\r\n     * @param coverId id of cover\r\n     */\r\n    function unlockCN(uint coverId) public onlyInternal {\r\n        (, bool isDeposited) = td.depositedCN(coverId);\r\n        require(!isDeposited,\"Cover note is deposited and can not be released\");\r\n        uint lockedCN = _getLockedCNAgainstCover(coverId);\r\n        if (lockedCN != 0) {\r\n            address coverHolder = qd.getCoverMemberAddress(coverId);\r\n            bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, coverId));\r\n            tc.releaseLockedTokens(coverHolder, reason, lockedCN);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Burns tokens used for fraudulent voting against a claim\r\n     * @param claimid Claim Id.\r\n     * @param _value number of tokens to be burned\r\n     * @param _of Claim Assessor's address.\r\n     */\r\n    function burnCAToken(uint claimid, uint _value, address _of) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        tc.burnLockedTokens(_of, \"CLA\", _value);\r\n        emit BurnCATokens(claimid, _of, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev to lock cover note tokens\r\n     * @param coverNoteAmount is number of tokens to be locked\r\n     * @param coverPeriod is cover period in concern\r\n     * @param coverId is the cover id of cover in concern\r\n     * @param _of address whose tokens are to be locked\r\n     */\r\n    function lockCN(\r\n        uint coverNoteAmount,\r\n        uint coverPeriod,\r\n        uint coverId,\r\n        address _of\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        uint validity = (coverPeriod * 1 days).add(td.lockTokenTimeAfterCoverExp());\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, coverId));\r\n        td.setDepositCNAmount(coverId, coverNoteAmount);\r\n        tc.lockOf(_of, reason, coverNoteAmount, validity);\r\n    }\r\n\r\n    /**\r\n     * @dev to check if a  member is locked for member vote\r\n     * @param _of is the member address in concern\r\n     * @return the boolean status\r\n     */\r\n    function isLockedForMemberVote(address _of) public view returns(bool) {\r\n        return now < tk.isLockedForMV(_of);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to gets amount of locked SOTE tokens,\r\n     * staked against smartcontract by index\r\n     * @param _stakerAddress address of user\r\n     * @param _stakedContractAddress staked contract address\r\n     * @param _stakedContractIndex index of staking\r\n     */\r\n    function deprecated_getStakerLockedTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        public\r\n        view\r\n        returns\r\n        (uint amount)\r\n    {\r\n        amount = _deprecated_getStakerLockedTokensOnSmartContract(_stakerAddress,\r\n            _stakedContractAddress, _stakedContractIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to gets unlockable amount of locked SOTE\r\n     * tokens, staked against smartcontract by index\r\n     * @param stakerAddress address of staker\r\n     * @param stakedContractAddress staked contract address\r\n     * @param stakerIndex index of staking\r\n     */\r\n    function deprecated_getStakerUnlockableTokensOnSmartContract (\r\n        address stakerAddress,\r\n        address stakedContractAddress,\r\n        uint stakerIndex\r\n    )\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return _deprecated_getStakerUnlockableTokensOnSmartContract(stakerAddress, stakedContractAddress,\r\n        td.getStakerStakedContractIndex(stakerAddress, stakerIndex));\r\n    }\r\n\r\n    /**\r\n     * @dev releases unlockable staked tokens to staker\r\n     */\r\n    function deprecated_unlockStakerUnlockableTokens(address _stakerAddress) public checkPause {\r\n        uint unlockableAmount;\r\n        address scAddress;\r\n        bytes32 reason;\r\n        uint scIndex;\r\n        for (uint i = 0; i < td.getStakerStakedContractLength(_stakerAddress); i++) {\r\n            scAddress = td.getStakerStakedContractByIndex(_stakerAddress, i);\r\n            scIndex = td.getStakerStakedContractIndex(_stakerAddress, i);\r\n            unlockableAmount = _deprecated_getStakerUnlockableTokensOnSmartContract(\r\n            _stakerAddress, scAddress,\r\n            scIndex);\r\n            td.setUnlockableBeforeLastBurnTokens(_stakerAddress, i, 0);\r\n            td.pushUnlockedStakedTokens(_stakerAddress, i, unlockableAmount);\r\n            reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress, scAddress, scIndex));\r\n            tc.releaseLockedTokens(_stakerAddress, reason, unlockableAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to get tokens of staker locked before burning that are allowed to burn\r\n     * @param stakerAdd is the address of the staker\r\n     * @param stakedAdd is the address of staked contract in concern\r\n     * @param stakerIndex is the staker index in concern\r\n     * @return amount of unlockable tokens\r\n     * @return amount of tokens that can burn\r\n     */\r\n    function _deprecated_unlockableBeforeBurningAndCanBurn(\r\n        address stakerAdd,\r\n        address stakedAdd,\r\n        uint stakerIndex\r\n    )\r\n    public\r\n    view\r\n    returns\r\n    (uint amount, uint canBurn) {\r\n\r\n        uint dateAdd;\r\n        uint initialStake;\r\n        uint totalBurnt;\r\n        uint ub;\r\n        (, , dateAdd, initialStake, , totalBurnt, ub) = td.stakerStakedContracts(stakerAdd, stakerIndex);\r\n        canBurn = _deprecated_calculateStakedTokens(initialStake, now.sub(dateAdd).div(1 days), td.scValidDays());\r\n        // Can't use SafeMaths for int.\r\n        int v = int(initialStake - (canBurn) - (totalBurnt) - (\r\n            td.getStakerUnlockedStakedTokens(stakerAdd, stakerIndex)) - (ub));\r\n        uint currentLockedTokens = _deprecated_getStakerLockedTokensOnSmartContract(\r\n            stakerAdd, stakedAdd, td.getStakerStakedContractIndex(stakerAdd, stakerIndex));\r\n        if (v < 0) {\r\n            v = 0;\r\n        }\r\n        amount = uint(v);\r\n        if (canBurn > currentLockedTokens.sub(amount).sub(ub)) {\r\n            canBurn = currentLockedTokens.sub(amount).sub(ub);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to get tokens of staker that are unlockable\r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakedContractAddress is the address of staked contract in concern\r\n     * @param _stakedContractIndex is the staked contract index in concern\r\n     * @return amount of unlockable tokens\r\n     */\r\n    function _deprecated_getStakerUnlockableTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        public\r\n        view\r\n        returns\r\n        (uint amount)\r\n    {\r\n        uint initialStake;\r\n        uint stakerIndex = td.getStakedContractStakerIndex(\r\n            _stakedContractAddress, _stakedContractIndex);\r\n        uint burnt;\r\n        (, , , initialStake, , burnt,) = td.stakerStakedContracts(_stakerAddress, stakerIndex);\r\n        uint alreadyUnlocked = td.getStakerUnlockedStakedTokens(_stakerAddress, stakerIndex);\r\n        uint currentStakedTokens;\r\n        (, currentStakedTokens) = _deprecated_unlockableBeforeBurningAndCanBurn(_stakerAddress,\r\n            _stakedContractAddress, stakerIndex);\r\n        amount = initialStake.sub(currentStakedTokens).sub(alreadyUnlocked).sub(burnt);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get the amount of locked SOTE tokens,\r\n     * staked against smartcontract by index\r\n     * @param _stakerAddress address of user\r\n     * @param _stakedContractAddress staked contract address\r\n     * @param _stakedContractIndex index of staking\r\n     */\r\n    function _deprecated_getStakerLockedTokensOnSmartContract (\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        internal\r\n        view\r\n        returns\r\n        (uint amount)\r\n    {\r\n        bytes32 reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress,\r\n            _stakedContractAddress, _stakedContractIndex));\r\n        amount = tc.tokensLocked(_stakerAddress, reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of SOTE Tokens locked as Cover Note for given coverId.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function _getLockedCNAgainstCover(uint _coverId) internal view returns(uint) {\r\n        address coverHolder = qd.getCoverMemberAddress(_coverId);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", coverHolder, _coverId));\r\n        return tc.tokensLockedAtTime(coverHolder, reason, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns amount of SOTE Tokens locked as Cover Note for given coverId.\r\n     * @param _of address of the coverHolder.\r\n     * @param _coverId coverId of the cover.\r\n     */\r\n    function _getUserLockedCNTokens(address _of, uint _coverId) internal view returns(uint) {\r\n        bytes32 reason = keccak256(abi.encodePacked(\"CN\", _of, _coverId));\r\n        return tc.tokensLockedAtTime(_of, reason, now);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to gets remaining amount of staked SOTE tokens,\r\n     * against smartcontract by index\r\n     * @param _stakeAmount address of user\r\n     * @param _stakeDays staked contract address\r\n     * @param _validDays index of staking\r\n     */\r\n    function _deprecated_calculateStakedTokens(\r\n        uint _stakeAmount,\r\n        uint _stakeDays,\r\n        uint _validDays\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint amount)\r\n    {\r\n        if (_validDays > _stakeDays) {\r\n            uint rf = ((_validDays.sub(_stakeDays)).mul(100000)).div(_validDays);\r\n            amount = (rf.mul(_stakeAmount)).div(100000);\r\n        } else {\r\n            amount = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the total staked SOTE tokens against Smart contract\r\n     * by all stakers\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @return amount total staked SOTE tokens.\r\n     */\r\n    function _deprecated_burnStakerTokenLockedAgainstSmartContract(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex,\r\n        uint _amount\r\n    )\r\n        internal\r\n    {\r\n        uint stakerIndex = td.getStakedContractStakerIndex(\r\n            _stakedContractAddress, _stakedContractIndex);\r\n        td.pushBurnedTokens(_stakerAddress, stakerIndex, _amount);\r\n        bytes32 reason = keccak256(abi.encodePacked(\"UW\", _stakerAddress,\r\n            _stakedContractAddress, _stakedContractIndex));\r\n        tc.burnLockedTokens(_stakerAddress, reason, _amount);\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract IMemberRoles {\r\n\r\n    event MemberRole(uint256 indexed roleId, bytes32 roleName, string roleDescription);\r\n    \r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole(bytes32 _roleName, string memory _roleDescription, address _authorized) public;\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole(address _memberAddress, uint _roleId, bool _active) public;\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _authorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _authorized) public;\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256);\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory allMemberAddress);\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberAddress.length Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint);\r\n    \r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address);\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory assignedRoles);\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool);   \r\n}\r\n\r\n/**\r\n * @title ERC1132 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/1132\r\n */\r\ncontract IERC1132 {\r\n    /**\r\n     * @dev Reasons why a user's tokens have been locked\r\n     */\r\n    mapping(address => bytes32[]) public lockReason;\r\n\r\n    /**\r\n     * @dev locked token structure\r\n     */\r\n    struct LockToken {\r\n        uint256 amount;\r\n        uint256 validity;\r\n        bool claimed;\r\n    }\r\n\r\n    /**\r\n     * @dev Holds number & validity of tokens locked for a given reason for\r\n     *      a specified address\r\n     */\r\n    mapping(address => mapping(bytes32 => LockToken)) public locked;\r\n\r\n    /**\r\n     * @dev Records data of all the tokens Locked\r\n     */\r\n    event Locked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount,\r\n        uint256 _validity\r\n    );\r\n\r\n    /**\r\n     * @dev Records data of all the tokens unlocked\r\n     */\r\n    event Unlocked(\r\n        address indexed _of,\r\n        bytes32 indexed _reason,\r\n        uint256 _amount\r\n    );\r\n    \r\n    /**\r\n     * @dev Locks a specified amount of tokens against an address,\r\n     *      for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be locked\r\n     * @param _time Lock time in seconds\r\n     */\r\n    function lock(bytes32 _reason, uint256 _amount, uint256 _time)\r\n        public returns (bool);\r\n  \r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n        public view returns (uint256 amount);\r\n    \r\n    /**\r\n     * @dev Returns tokens locked for a specified address for a\r\n     *      specified reason at a specific time\r\n     *\r\n     * @param _of The address whose tokens are locked\r\n     * @param _reason The reason to query the lock tokens for\r\n     * @param _time The timestamp to query the lock tokens for\r\n     */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public view returns (uint256 amount);\r\n    \r\n    /**\r\n     * @dev Returns total tokens held by an address (locked + transferable)\r\n     * @param _of The address to query the total balance of\r\n     */\r\n    function totalBalanceOf(address _of)\r\n        public view returns (uint256 amount);\r\n    \r\n    /**\r\n     * @dev Extends lock for a specified reason and time\r\n     * @param _reason The reason to lock tokens\r\n     * @param _time Lock extension time in seconds\r\n     */\r\n    function extendLock(bytes32 _reason, uint256 _time)\r\n        public returns (bool);\r\n    \r\n    /**\r\n     * @dev Increase number of tokens locked for a specified reason\r\n     * @param _reason The reason to lock tokens\r\n     * @param _amount Number of tokens to be increased\r\n     */\r\n    function increaseLockAmount(bytes32 _reason, uint256 _amount)\r\n        public returns (bool);\r\n\r\n    /**\r\n     * @dev Returns unlockable tokens for a specified address for a specified reason\r\n     * @param _of The address to query the the unlockable token count of\r\n     * @param _reason The reason to query the unlockable tokens for\r\n     */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n        public view returns (uint256 amount);\r\n \r\n    /**\r\n     * @dev Unlocks the unlockable tokens of a specified address\r\n     * @param _of Address of user, claiming back unlockable tokens\r\n     */\r\n    function unlock(address _of)\r\n        public returns (uint256 unlockableTokens);\r\n\r\n    /**\r\n     * @dev Gets the unlockable tokens of a specified address\r\n     * @param _of The address to query the the unlockable token count of\r\n     */\r\n    function getUnlockableTokens(address _of)\r\n        public view returns (uint256 unlockableTokens);\r\n\r\n}\r\n\r\n/* Copyright (C) 2020 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU General Public License as published by\r\n  the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n  along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract TokenController is IERC1132, Iupgradable {\r\n    using SafeMath for uint256;\r\n\r\n    event Burned(address indexed member, bytes32 lockedUnder, uint256 amount);\r\n\r\n    SOTEToken public token;\r\n    IPooledStaking public pooledStaking;\r\n    uint public minCALockTime = uint(30).mul(1 days);\r\n    bytes32 private constant CLA = bytes32(\"CLA\");\r\n\r\n    /**\r\n    * @dev Just for interface\r\n    */\r\n    function changeDependentContractAddress() public {\r\n        token = SOTEToken(ms.tokenAddress());\r\n        pooledStaking = IPooledStaking(ms.getLatestAddress('PS'));\r\n    }\r\n\r\n    /**\r\n     * @dev to change the operator address\r\n     * @param _newOperator is the new address of operator\r\n     */\r\n    function changeOperator(address _newOperator) public onlyInternal {\r\n        token.changeOperator(_newOperator);\r\n    }\r\n\r\n    /**\r\n     * @dev Proxies token transfer through this contract to allow staking when members are locked for voting\r\n     * @param _from   Source address\r\n     * @param _to     Destination address\r\n     * @param _value  Amount to transfer\r\n     */\r\n    function operatorTransfer(address _from, address _to, uint _value) onlyInternal external returns (bool) {\r\n        require(msg.sender == address(pooledStaking), \"Call is only allowed from PooledStaking address\");\r\n        require(token.operatorTransfer(_from, _value), \"Operator transfer failed\");\r\n        require(token.transfer(_to, _value), \"Internal transfer failed\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Locks a specified amount of tokens,\r\n    *    for CLA reason and for a specified time\r\n    * @param _reason The reason to lock tokens, currently restricted to CLA\r\n    * @param _amount Number of tokens to be locked\r\n    * @param _time Lock time in seconds\r\n    */\r\n    function lock(bytes32 _reason, uint256 _amount, uint256 _time) public checkPause returns (bool)\r\n    {\r\n        require(_reason == CLA,\"Restricted to reason CLA\");\r\n        require(minCALockTime <= _time,\"Should lock for minimum time\");\r\n        // If tokens are already locked, then functions extendLock or\r\n        // increaseLockAmount should be used to make any changes\r\n        _lock(msg.sender, _reason, _amount, _time);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Locks a specified amount of tokens against an address,\r\n    *    for a specified reason and time\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be locked\r\n    * @param _time Lock time in seconds\r\n    * @param _of address whose tokens are to be locked\r\n    */\r\n    function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time)\r\n        public\r\n        onlyInternal\r\n        returns (bool)\r\n    {\r\n        // If tokens are already locked, then functions extendLock or\r\n        // increaseLockAmount should be used to make any changes\r\n        _lock(_of, _reason, _amount, _time);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Extends lock for reason CLA for a specified time\r\n    * @param _reason The reason to lock tokens, currently restricted to CLA\r\n    * @param _time Lock extension time in seconds\r\n    */\r\n    function extendLock(bytes32 _reason, uint256 _time)\r\n        public\r\n        checkPause\r\n        returns (bool)\r\n    {\r\n        require(_reason == CLA,\"Restricted to reason CLA\");\r\n        _extendLock(msg.sender, _reason, _time);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Extends lock for a specified reason and time\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock extension time in seconds\r\n    */\r\n    function extendLockOf(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        onlyInternal\r\n        returns (bool)\r\n    {\r\n        _extendLock(_of, _reason, _time);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Increase number of tokens locked for a CLA reason\r\n    * @param _reason The reason to lock tokens, currently restricted to CLA\r\n    * @param _amount Number of tokens to be increased\r\n    */\r\n    function increaseLockAmount(bytes32 _reason, uint256 _amount)\r\n        public\r\n        checkPause\r\n        returns (bool)\r\n    {    \r\n        require(_reason == CLA,\"Restricted to reason CLA\");\r\n        require(_tokensLocked(msg.sender, _reason) > 0);\r\n        token.operatorTransfer(msg.sender, _amount);\r\n\r\n        locked[msg.sender][_reason].amount = locked[msg.sender][_reason].amount.add(_amount);\r\n        emit Locked(msg.sender, _reason, _amount, locked[msg.sender][_reason].validity);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev burns tokens of an address\r\n     * @param _of is the address to burn tokens of\r\n     * @param amount is the amount to burn\r\n     * @return the boolean status of the burning process\r\n     */\r\n    function burnFrom (address _of, uint amount) public onlyInternal returns (bool) {\r\n        return token.burnFrom(_of, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Burns locked tokens of a user\r\n    * @param _of address whose tokens are to be burned\r\n    * @param _reason lock reason for which tokens are to be burned\r\n    * @param _amount amount of tokens to burn\r\n    */\r\n    function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) public onlyInternal {\r\n        _burnLockedTokens(_of, _reason, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev reduce lock duration for a specified reason and time\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock reduction time in seconds\r\n    */\r\n    function reduceLock(address _of, bytes32 _reason, uint256 _time) public onlyInternal {\r\n        _reduceLock(_of, _reason, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Released locked tokens of an address locked for a specific reason\r\n    * @param _of address whose tokens are to be released from lock\r\n    * @param _reason reason of the lock\r\n    * @param _amount amount of tokens to release\r\n    */\r\n    function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount)\r\n        public\r\n        onlyInternal\r\n    {\r\n        _releaseLockedTokens(_of, _reason, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Adds an address to whitelist maintained in the contract\r\n    * @param _member address to add to whitelist\r\n    */\r\n    function addToWhitelist(address _member) public onlyInternal {\r\n        token.addToWhiteList(_member);\r\n    }\r\n\r\n    /**\r\n    * @dev Removes an address from the whitelist in the token\r\n    * @param _member address to remove\r\n    */\r\n    function removeFromWhitelist(address _member) public onlyInternal {\r\n        token.removeFromWhiteList(_member);\r\n    }\r\n\r\n    /**\r\n    * @dev Mints new token for an address\r\n    * @param _member address to reward the minted tokens\r\n    * @param _amount number of tokens to mint\r\n    */\r\n    function mint(address _member, uint _amount) public onlyInternal {\r\n        token.mint(_member, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Lock the user's tokens\r\n     * @param _of user's address.\r\n     */\r\n    function lockForMemberVote(address _of, uint _days) public onlyInternal {\r\n        token.lockForMemberVote(_of, _days);\r\n    }\r\n\r\n    /**\r\n    * @dev Unlocks the unlockable tokens against CLA of a specified address\r\n    * @param _of Address of user, claiming back unlockable tokens against CLA\r\n    */\r\n    function unlock(address _of)\r\n        public\r\n        checkPause\r\n        returns (uint256 unlockableTokens)\r\n    {\r\n        unlockableTokens = _tokensUnlockable(_of, CLA);\r\n        if (unlockableTokens > 0) {\r\n            locked[_of][CLA].claimed = true;\r\n            emit Unlocked(_of, CLA, unlockableTokens);\r\n            require(token.transfer(_of, unlockableTokens));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"MNCLT\") {\r\n            minCALockTime = val.mul(1 days);\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the validity of locked tokens of a specified address\r\n    * @param _of The address to query the validity\r\n    * @param reason reason for which tokens were locked\r\n    */\r\n    function getLockedTokensValidity(address _of, bytes32 reason)\r\n        public\r\n        view\r\n        returns (uint256 validity)\r\n    {\r\n        validity = locked[_of][reason].validity;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the unlockable tokens of a specified address\r\n    * @param _of The address to query the the unlockable token count of\r\n    */\r\n    function getUnlockableTokens(address _of)\r\n        public\r\n        view\r\n        returns (uint256 unlockableTokens)\r\n    {\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            unlockableTokens = unlockableTokens.add(_tokensUnlockable(_of, lockReason[_of][i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    */\r\n    function tokensLocked(address _of, bytes32 _reason)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return _tokensLocked(_of, _reason);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns unlockable tokens for a specified address for a specified reason\r\n    * @param _of The address to query the the unlockable token count of\r\n    * @param _reason The reason to query the unlockable tokens for\r\n    */\r\n    function tokensUnlockable(address _of, bytes32 _reason)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return _tokensUnlockable(_of, _reason);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256)\r\n    {\r\n        return token.totalSupply();\r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason at a specific time\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    * @param _time The timestamp to query the lock tokens for\r\n    */\r\n    function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return _tokensLockedAtTime(_of, _reason, _time);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the total amount of tokens held by an address:\r\n    *   transferable + locked + staked for pooled staking - pending burns.\r\n    *   Used by Claims and Governance in member voting to calculate the user's vote weight.\r\n    *\r\n    * @param _of The address to query the total balance of\r\n    * @param _of The address to query the total balance of\r\n    */\r\n    function totalBalanceOf(address _of) public view returns (uint256 amount) {\r\n\r\n        amount = token.balanceOf(_of);\r\n\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            amount = amount.add(_tokensLocked(_of, lockReason[_of][i]));\r\n        }\r\n\r\n        uint stakerReward = pooledStaking.stakerReward(_of);\r\n        uint stakerDeposit = pooledStaking.stakerDeposit(_of);\r\n\r\n        amount = amount.add(stakerDeposit).add(stakerReward);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the total locked tokens at time\r\n    *   Returns the total amount of locked and staked tokens at a given time. Used by MemberRoles to check eligibility\r\n    *   for withdraw / switch membership. Includes tokens locked for Claim Assessment and staked for Risk Assessment.\r\n    *   Does not take into account pending burns.\r\n    *\r\n    * @param _of member whose locked tokens are to be calculate\r\n    * @param _time timestamp when the tokens should be locked\r\n    */\r\n    function totalLockedBalance(address _of, uint256 _time) public view returns (uint256 amount) {\r\n\r\n        for (uint256 i = 0; i < lockReason[_of].length; i++) {\r\n            amount = amount.add(_tokensLockedAtTime(_of, lockReason[_of][i], _time));\r\n        }\r\n\r\n        amount = amount.add(pooledStaking.stakerDeposit(_of));\r\n    }\r\n\r\n    /**\r\n    * @dev Locks a specified amount of tokens against an address,\r\n    *    for a specified reason and time\r\n    * @param _of address whose tokens are to be locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _amount Number of tokens to be locked\r\n    * @param _time Lock time in seconds\r\n    */\r\n    function _lock(address _of, bytes32 _reason, uint256 _amount, uint256 _time) internal {\r\n        require(_tokensLocked(_of, _reason) == 0);\r\n        require(_amount != 0);\r\n\r\n        if (locked[_of][_reason].amount == 0) {\r\n            lockReason[_of].push(_reason);\r\n        }\r\n\r\n        require(token.operatorTransfer(_of, _amount));\r\n\r\n        uint256 validUntil = now.add(_time); //solhint-disable-line\r\n        locked[_of][_reason] = LockToken(_amount, validUntil, false);\r\n        emit Locked(_of, _reason, _amount, validUntil);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    */\r\n    function _tokensLocked(address _of, bytes32 _reason)\r\n        internal\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (!locked[_of][_reason].claimed) {\r\n            amount = locked[_of][_reason].amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns tokens locked for a specified address for a\r\n    *    specified reason at a specific time\r\n    *\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to query the lock tokens for\r\n    * @param _time The timestamp to query the lock tokens for\r\n    */\r\n    function _tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time)\r\n        internal\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        if (locked[_of][_reason].validity > _time) {\r\n            amount = locked[_of][_reason].amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Extends lock for a specified reason and time\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock extension time in seconds\r\n    */\r\n    function _extendLock(address _of, bytes32 _reason, uint256 _time) internal {\r\n        require(_tokensLocked(_of, _reason) > 0);\r\n        emit Unlocked(_of, _reason, locked[_of][_reason].amount);\r\n        locked[_of][_reason].validity = locked[_of][_reason].validity.add(_time);\r\n        emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\r\n    }\r\n\r\n    /**\r\n    * @dev reduce lock duration for a specified reason and time\r\n    * @param _of The address whose tokens are locked\r\n    * @param _reason The reason to lock tokens\r\n    * @param _time Lock reduction time in seconds\r\n    */\r\n    function _reduceLock(address _of, bytes32 _reason, uint256 _time) internal {\r\n        require(_tokensLocked(_of, _reason) > 0);\r\n        emit Unlocked(_of, _reason, locked[_of][_reason].amount);\r\n        locked[_of][_reason].validity = locked[_of][_reason].validity.sub(_time);\r\n        emit Locked(_of, _reason, locked[_of][_reason].amount, locked[_of][_reason].validity);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns unlockable tokens for a specified address for a specified reason\r\n    * @param _of The address to query the the unlockable token count of\r\n    * @param _reason The reason to query the unlockable tokens for\r\n    */\r\n    function _tokensUnlockable(address _of, bytes32 _reason) internal view returns (uint256 amount)\r\n    {\r\n        if (locked[_of][_reason].validity <= now && !locked[_of][_reason].claimed) {\r\n            amount = locked[_of][_reason].amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Burns locked tokens of a user\r\n    * @param _of address whose tokens are to be burned\r\n    * @param _reason lock reason for which tokens are to be burned\r\n    * @param _amount amount of tokens to burn\r\n    */\r\n    function _burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal {\r\n        uint256 amount = _tokensLocked(_of, _reason);\r\n        require(amount >= _amount);\r\n\r\n        if (amount == _amount) {\r\n            locked[_of][_reason].claimed = true;\r\n        }\r\n\r\n        locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\r\n        if (locked[_of][_reason].amount == 0) {\r\n            _removeReason(_of, _reason);\r\n        }\r\n        token.burn(_amount);\r\n        emit Burned(_of, _reason, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Released locked tokens of an address locked for a specific reason\r\n    * @param _of address whose tokens are to be released from lock\r\n    * @param _reason reason of the lock\r\n    * @param _amount amount of tokens to release\r\n    */\r\n    function _releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) internal\r\n    {\r\n        uint256 amount = _tokensLocked(_of, _reason);\r\n        require(amount >= _amount);\r\n\r\n        if (amount == _amount) {\r\n            locked[_of][_reason].claimed = true;\r\n        }\r\n\r\n        locked[_of][_reason].amount = locked[_of][_reason].amount.sub(_amount);\r\n        if (locked[_of][_reason].amount == 0) {\r\n            _removeReason(_of, _reason);\r\n        }\r\n        require(token.transfer(_of, _amount));\r\n        emit Unlocked(_of, _reason, _amount);\r\n    }\r\n\r\n    function _removeReason(address _of, bytes32 _reason) internal {\r\n        uint len = lockReason[_of].length;\r\n        for (uint i = 0; i < len; i++) {\r\n            if (lockReason[_of][i] == _reason) {\r\n                lockReason[_of][i] = lockReason[_of][len.sub(1)];\r\n                lockReason[_of].pop();\r\n                break;\r\n            }\r\n        }   \r\n    }\r\n}\r\n\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract DSValue {\r\n    function peek() public view returns (bytes32, bool);\r\n    function read() public view returns (bytes32);\r\n}\r\n\r\ncontract PoolData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    struct ApiId {\r\n        bytes4 typeOf;\r\n        bytes4 currency;\r\n        uint id;\r\n        uint64 dateAdd;\r\n        uint64 dateUpd;\r\n    }\r\n\r\n    struct CurrencyAssets {\r\n        address currAddress;\r\n        uint baseMin;\r\n        uint varMin;\r\n    }\r\n\r\n    struct InvestmentAssets {\r\n        address currAddress;\r\n        bool status;\r\n        uint64 minHoldingPercX100;\r\n        uint64 maxHoldingPercX100;\r\n        uint8 decimals;\r\n    }\r\n\r\n    struct IARankDetails {\r\n        bytes4 maxIACurr;\r\n        uint64 maxRate;\r\n        bytes4 minIACurr;\r\n        uint64 minRate;\r\n    }\r\n\r\n    struct McrData {\r\n        uint mcrPercx100;\r\n        uint mcrEther;\r\n        uint vFull; //Pool funds\r\n        uint64 date;\r\n    }\r\n\r\n    IARankDetails[] internal allIARankDetails;\r\n    McrData[] public allMCRData;\r\n\r\n    bytes4[] internal allInvestmentCurrencies;\r\n    bytes4[] internal allCurrencies;\r\n    bytes32[] public allAPIcall;\r\n    mapping(bytes32 => ApiId) public allAPIid;\r\n    mapping(uint64 => uint) internal datewiseId;\r\n    mapping(bytes16 => uint) internal currencyLastIndex;\r\n    mapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\r\n    mapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\r\n    mapping(bytes4 => uint) internal caAvgRate;\r\n    mapping(bytes4 => uint) internal iaAvgRate;\r\n\r\n    address public notariseMCR;\r\n    address public daiFeedAddress;\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n    uint public uniswapDeadline;\r\n    uint public liquidityTradeCallbackTime;\r\n    uint public lastLiquidityTradeTrigger;\r\n    uint64 internal lastDate;\r\n    uint public variationPercX100;\r\n    uint public iaRatesTime;\r\n    uint public minCap;\r\n    uint public mcrTime;\r\n    uint public a;\r\n    uint public shockParameter;\r\n    uint public c;\r\n    uint public mcrFailTime; \r\n    uint public ethVolumeLimit;\r\n    uint public capReached;\r\n    uint public capacityLimit;\r\n    \r\n    constructor(address _notariseAdd, address _daiFeedAdd, address _daiAdd) public {\r\n        notariseMCR = _notariseAdd;\r\n        daiFeedAddress = _daiFeedAdd;\r\n        c = 5800000;\r\n        a = 1028;\r\n        mcrTime = 24 hours;\r\n        mcrFailTime = 6 hours;\r\n        allMCRData.push(McrData(0, 0, 0, 0));\r\n        minCap = 7;\r\n        shockParameter = 50;\r\n        variationPercX100 = 100; //1%\r\n        iaRatesTime = 24 hours; //24 hours in seconds\r\n        uniswapDeadline = 20 minutes;\r\n        liquidityTradeCallbackTime = 4 hours;\r\n        ethVolumeLimit = 4;\r\n        capacityLimit = 10;\r\n        allCurrencies.push(\"BNB\");\r\n        allCurrencyAssets[\"BNB\"] = CurrencyAssets(address(0), 1000 * DECIMAL1E18, 0);\r\n        allInvestmentCurrencies.push(\"BNB\");\r\n        allInvestmentAssets[\"BNB\"] = InvestmentAssets(address(0), true, 2500, 10000, 18);\r\n    }\r\n\r\n    /**\r\n     * @dev to set the maximum cap allowed \r\n     * @param val is the new value\r\n     */\r\n    function setCapReached(uint val) external onlyInternal {\r\n        capReached = val;\r\n    }\r\n    \r\n    /// @dev Updates the 3 day average rate of a IA currency.\r\n    /// To be replaced by MakerDao's on chain rates\r\n    /// @param curr IA Currency Name.\r\n    /// @param rate Average exchange rate X 100 (of last 3 days).\r\n    function updateIAAvgRate(bytes4 curr, uint rate) external onlyInternal {\r\n        iaAvgRate[curr] = rate;\r\n    }\r\n\r\n    /// @dev Updates the 3 day average rate of a CA currency.\r\n    /// To be replaced by MakerDao's on chain rates\r\n    /// @param curr Currency Name.\r\n    /// @param rate Average exchange rate X 100 (of last 3 days).\r\n    function updateCAAvgRate(bytes4 curr, uint rate) external onlyInternal {\r\n        caAvgRate[curr] = rate;\r\n    }\r\n\r\n    /// @dev Adds details of (Minimum Capital Requirement)MCR.\r\n    /// @param mcrp Minimum Capital Requirement percentage (MCR% * 100 ,Ex:for 54.56% ,given 5456)\r\n    /// @param vf Pool fund value in Ether used in the last full daily calculation from the Capital model.\r\n    function pushMCRData(uint mcrp, uint mcre, uint vf, uint64 time) external onlyInternal {\r\n        allMCRData.push(McrData(mcrp, mcre, vf, time));\r\n    }\r\n\r\n    /** \r\n     * @dev Updates the Timestamp at which result of oracalize call is received.\r\n     */  \r\n    function updateDateUpdOfAPI(bytes32 myid) external onlyInternal {\r\n        allAPIid[myid].dateUpd = uint64(now);\r\n    }\r\n\r\n    /** \r\n     * @dev Saves the details of the Oraclize API.\r\n     * @param myid Id return by the oraclize query.\r\n     * @param _typeof type of the query for which oraclize call is made.\r\n     * @param id ID of the proposal,quote,cover etc. for which oraclize call is made \r\n     */  \r\n    function saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) external onlyInternal {\r\n        allAPIid[myid] = ApiId(_typeof, \"\", id, uint64(now), uint64(now));\r\n    }\r\n\r\n    /** \r\n     * @dev Stores the id return by the oraclize query. \r\n     * Maintains record of all the Ids return by oraclize query.\r\n     * @param myid Id return by the oraclize query.\r\n     */  \r\n    function addInAllApiCall(bytes32 myid) external onlyInternal {\r\n        allAPIcall.push(myid);\r\n    }\r\n    \r\n    /**\r\n     * @dev Saves investment asset rank details.\r\n     * @param maxIACurr Maximum ranked investment asset currency.\r\n     * @param maxRate Maximum ranked investment asset rate.\r\n     * @param minIACurr Minimum ranked investment asset currency.\r\n     * @param minRate Minimum ranked investment asset rate.\r\n     * @param date in yyyymmdd.\r\n     */  \r\n    function saveIARankDetails(\r\n        bytes4 maxIACurr,\r\n        uint64 maxRate,\r\n        bytes4 minIACurr,\r\n        uint64 minRate,\r\n        uint64 date\r\n    )\r\n        external\r\n        onlyInternal\r\n    {\r\n        allIARankDetails.push(IARankDetails(maxIACurr, maxRate, minIACurr, minRate));\r\n        datewiseId[date] = allIARankDetails.length.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the time for the laste liquidity trade trigger\r\n     */\r\n    function setLastLiquidityTradeTrigger() external onlyInternal {\r\n        lastLiquidityTradeTrigger = now;\r\n    }\r\n\r\n    /** \r\n     * @dev Updates Last Date.\r\n     */  \r\n    function updatelastDate(uint64 newDate) external onlyInternal {\r\n        lastDate = newDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds currency asset currency. \r\n     * @param curr currency of the asset\r\n     * @param currAddress address of the currency\r\n     * @param baseMin base minimum in 10^18. \r\n     */  \r\n    function addCurrencyAssetCurrency(\r\n        bytes4 curr,\r\n        address currAddress,\r\n        uint baseMin\r\n    ) \r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allCurrencies.push(curr);\r\n        allCurrencyAssets[curr] = CurrencyAssets(currAddress, baseMin, 0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Adds investment asset. \r\n     */  \r\n    function addInvestmentAssetCurrency(\r\n        bytes4 curr,\r\n        address currAddress,\r\n        bool status,\r\n        uint64 minHoldingPercX100,\r\n        uint64 maxHoldingPercX100,\r\n        uint8 decimals\r\n    ) \r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentCurrencies.push(curr);\r\n        allInvestmentAssets[curr] = InvestmentAssets(currAddress, status,\r\n            minHoldingPercX100, maxHoldingPercX100, decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes base minimum of a given currency asset.\r\n     */ \r\n    function changeCurrencyAssetBaseMin(bytes4 curr, uint baseMin) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allCurrencyAssets[curr].baseMin = baseMin;\r\n    }\r\n\r\n    /**\r\n     * @dev changes variable minimum of a given currency asset.\r\n     */  \r\n    function changeCurrencyAssetVarMin(bytes4 curr, uint varMin) external onlyInternal {\r\n        allCurrencyAssets[curr].varMin = varMin;\r\n    }\r\n\r\n    /** \r\n     * @dev Changes the investment asset status.\r\n     */ \r\n    function changeInvestmentAssetStatus(bytes4 curr, bool status) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentAssets[curr].status = status;\r\n    }\r\n\r\n    /** \r\n     * @dev Changes the investment asset Holding percentage of a given currency.\r\n     */\r\n    function changeInvestmentAssetHoldingPerc(\r\n        bytes4 curr,\r\n        uint64 minPercX100,\r\n        uint64 maxPercX100\r\n    )\r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentAssets[curr].minHoldingPercX100 = minPercX100;\r\n        allInvestmentAssets[curr].maxHoldingPercX100 = maxPercX100;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Currency asset token address. \r\n     */  \r\n    function changeCurrencyAssetAddress(bytes4 curr, address currAdd) external {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allCurrencyAssets[curr].currAddress = currAdd;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes Investment asset token address.\r\n     */ \r\n    function changeInvestmentAssetAddressAndDecimal(\r\n        bytes4 curr,\r\n        address currAdd,\r\n        uint8 newDecimal\r\n    )\r\n        external\r\n    {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        allInvestmentAssets[curr].currAddress = currAdd;\r\n        allInvestmentAssets[curr].decimals = newDecimal;\r\n    }\r\n\r\n    /// @dev Changes address allowed to post MCR.\r\n    function changeNotariseAddress(address _add) external onlyInternal {\r\n        notariseMCR = _add;\r\n    }\r\n\r\n    /// @dev updates daiFeedAddress address.\r\n    /// @param _add address of DAI feed.\r\n    function changeDAIfeedAddress(address _add) external onlyInternal {\r\n        daiFeedAddress = _add;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"MCRTIM\") {\r\n            val = mcrTime / (1 hours);\r\n\r\n        } else if (code == \"MCRFTIM\") {\r\n\r\n            val = mcrFailTime / (1 hours);\r\n\r\n        } else if (code == \"MCRMIN\") {\r\n\r\n            val = minCap;\r\n\r\n        } else if (code == \"MCRSHOCK\") {\r\n\r\n            val = shockParameter;\r\n\r\n        } else if (code == \"MCRCAPL\") {\r\n\r\n            val = capacityLimit;\r\n\r\n        } else if (code == \"IMZ\") {\r\n\r\n            val = variationPercX100;\r\n\r\n        } else if (code == \"IMRATET\") {\r\n\r\n            val = iaRatesTime / (1 hours);\r\n\r\n        } else if (code == \"IMUNIDL\") {\r\n\r\n            val = uniswapDeadline / (1 minutes);\r\n\r\n        } else if (code == \"IMLIQT\") {\r\n\r\n            val = liquidityTradeCallbackTime / (1 hours);\r\n\r\n        } else if (code == \"IMETHVL\") {\r\n\r\n            val = ethVolumeLimit;\r\n\r\n        } else if (code == \"C\") {\r\n            val = c;\r\n\r\n        } else if (code == \"A\") {\r\n\r\n            val = a;\r\n\r\n        }\r\n            \r\n    }\r\n \r\n    /// @dev Checks whether a given address can notaise MCR data or not.\r\n    /// @param _add Address.\r\n    /// @return res Returns 0 if address is not authorized, else 1.\r\n    function isnotarise(address _add) external view returns(bool res) {\r\n        res = false;\r\n        if (_add == notariseMCR)\r\n            res = true;\r\n    }\r\n\r\n    /// @dev Gets the details of last added MCR.\r\n    /// @return mcrPercx100 Total Minimum Capital Requirement percentage of that month of year(multiplied by 100).\r\n    /// @return vFull Total Pool fund value in Ether used in the last full daily calculation.\r\n    function getLastMCR() external view returns(uint mcrPercx100, uint mcrEtherx1E18, uint vFull, uint64 date) {\r\n        uint index = allMCRData.length.sub(1);\r\n        return (\r\n            allMCRData[index].mcrPercx100,\r\n            allMCRData[index].mcrEther,\r\n            allMCRData[index].vFull,\r\n            allMCRData[index].date\r\n        );\r\n    }\r\n\r\n    /// @dev Gets last Minimum Capital Requirement percentage of Capital Model\r\n    /// @return val MCR% value,multiplied by 100.\r\n    function getLastMCRPerc() external view returns(uint) {\r\n        return allMCRData[allMCRData.length.sub(1)].mcrPercx100;\r\n    }\r\n\r\n    /// @dev Gets last Ether price of Capital Model\r\n    /// @return val ether value,multiplied by 100.\r\n    function getLastMCREther() external view returns(uint) {\r\n        return allMCRData[allMCRData.length.sub(1)].mcrEther;\r\n    }\r\n\r\n    /// @dev Gets Pool fund value in Ether used in the last full daily calculation from the Capital model.\r\n    function getLastVfull() external view returns(uint) {\r\n        return allMCRData[allMCRData.length.sub(1)].vFull;\r\n    }\r\n\r\n    /// @dev Gets last Minimum Capital Requirement in Ether.\r\n    /// @return date of MCR.\r\n    function getLastMCRDate() external view returns(uint64 date) {\r\n        date = allMCRData[allMCRData.length.sub(1)].date;\r\n    }\r\n\r\n    /// @dev Gets details for token price calculation.\r\n    function getTokenPriceDetails(bytes4 curr) external view returns(uint _a, uint _c, uint rate) {\r\n        _a = a;\r\n        _c = c;\r\n        rate = _getAvgRate(curr, false);\r\n    }\r\n    \r\n    /// @dev Gets the total number of times MCR calculation has been made.\r\n    function getMCRDataLength() external view returns(uint len) {\r\n        len = allMCRData.length;\r\n    }\r\n \r\n    /**\r\n     * @dev Gets investment asset rank details by given date.\r\n     */  \r\n    function getIARankDetailsByDate(\r\n        uint64 date\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 maxIACurr,\r\n            uint64 maxRate,\r\n            bytes4 minIACurr,\r\n            uint64 minRate\r\n        )\r\n    {\r\n        uint index = datewiseId[date];\r\n        return (\r\n            allIARankDetails[index].maxIACurr,\r\n            allIARankDetails[index].maxRate,\r\n            allIARankDetails[index].minIACurr,\r\n            allIARankDetails[index].minRate\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets Last Date.\r\n     */ \r\n    function getLastDate() external view returns(uint64 date) {\r\n        return lastDate;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment currency for a given index.\r\n     */  \r\n    function getInvestmentCurrencyByIndex(uint index) external view returns(bytes4 currName) {\r\n        return allInvestmentCurrencies[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets count of investment currency.\r\n     */  \r\n    function getInvestmentCurrencyLen() external view returns(uint len) {\r\n        return allInvestmentCurrencies.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all the investment currencies.\r\n     */ \r\n    function getAllInvestmentCurrencies() external view returns(bytes4[] memory currencies) {\r\n        return allInvestmentCurrencies;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets All currency for a given index.\r\n     */  \r\n    function getCurrenciesByIndex(uint index) external view returns(bytes4 currName) {\r\n        return allCurrencies[index];\r\n    }\r\n\r\n    /** \r\n     * @dev Gets count of All currency.\r\n     */  \r\n    function getAllCurrenciesLen() external view returns(uint len) {\r\n        return allCurrencies.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all currencies \r\n     */  \r\n    function getAllCurrencies() external view returns(bytes4[] memory currencies) {\r\n        return allCurrencies;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets currency asset details for a given currency.\r\n     */  \r\n    function getCurrencyAssetVarBase(\r\n        bytes4 curr\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 currency,\r\n            uint baseMin,\r\n            uint varMin\r\n        )\r\n    {\r\n        return (\r\n            curr,\r\n            allCurrencyAssets[curr].baseMin,\r\n            allCurrencyAssets[curr].varMin\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets minimum variable value for currency asset.\r\n     */  \r\n    function getCurrencyAssetVarMin(bytes4 curr) external view returns(uint varMin) {\r\n        return allCurrencyAssets[curr].varMin;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets base minimum of  a given currency asset.\r\n     */  \r\n    function getCurrencyAssetBaseMin(bytes4 curr) external view returns(uint baseMin) {\r\n        return allCurrencyAssets[curr].baseMin;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets investment asset maximum and minimum holding percentage of a given currency.\r\n     */  \r\n    function getInvestmentAssetHoldingPerc(\r\n        bytes4 curr\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            uint64 minHoldingPercX100,\r\n            uint64 maxHoldingPercX100\r\n        )\r\n    {\r\n        return (\r\n            allInvestmentAssets[curr].minHoldingPercX100,\r\n            allInvestmentAssets[curr].maxHoldingPercX100\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Gets investment asset decimals.\r\n     */  \r\n    function getInvestmentAssetDecimals(bytes4 curr) external view returns(uint8 decimal) {\r\n        return allInvestmentAssets[curr].decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset maximum holding percentage of a given currency.\r\n     */  \r\n    function getInvestmentAssetMaxHoldingPerc(bytes4 curr) external view returns(uint64 maxHoldingPercX100) {\r\n        return allInvestmentAssets[curr].maxHoldingPercX100;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset minimum holding percentage of a given currency.\r\n     */  \r\n    function getInvestmentAssetMinHoldingPerc(bytes4 curr) external view returns(uint64 minHoldingPercX100) {\r\n        return allInvestmentAssets[curr].minHoldingPercX100;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets investment asset details of a given currency\r\n     */  \r\n    function getInvestmentAssetDetails(\r\n        bytes4 curr\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 currency,\r\n            address currAddress,\r\n            bool status,\r\n            uint64 minHoldingPerc,\r\n            uint64 maxHoldingPerc,\r\n            uint8 decimals\r\n        )\r\n    {\r\n        return (\r\n            curr,\r\n            allInvestmentAssets[curr].currAddress,\r\n            allInvestmentAssets[curr].status,\r\n            allInvestmentAssets[curr].minHoldingPercX100,\r\n            allInvestmentAssets[curr].maxHoldingPercX100,\r\n            allInvestmentAssets[curr].decimals\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Currency asset token address.\r\n     */  \r\n    function getCurrencyAssetAddress(bytes4 curr) external view returns(address) {\r\n        return allCurrencyAssets[curr].currAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset token address.\r\n     */  \r\n    function getInvestmentAssetAddress(bytes4 curr) external view returns(address) {\r\n        return allInvestmentAssets[curr].currAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets investment asset active Status of a given currency.\r\n     */  \r\n    function getInvestmentAssetStatus(bytes4 curr) external view returns(bool status) {\r\n        return allInvestmentAssets[curr].status;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets type of oraclize query for a given Oraclize Query ID.\r\n     * @param myid Oraclize Query ID identifying the query for which the result is being received.\r\n     * @return _typeof It could be of type \"quote\",\"quotation\",\"cover\",\"claim\" etc.\r\n     */  \r\n    function getApiIdTypeOf(bytes32 myid) external view returns(bytes4) {\r\n        return allAPIid[myid].typeOf;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets ID associated to oraclize query for a given Oraclize Query ID.\r\n     * @param myid Oraclize Query ID identifying the query for which the result is being received.\r\n     * @return id1 It could be the ID of \"proposal\",\"quotation\",\"cover\",\"claim\" etc.\r\n     */  \r\n    function getIdOfApiId(bytes32 myid) external view returns(uint) {\r\n        return allAPIid[myid].id;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets the Timestamp of a oracalize call.\r\n     */  \r\n    function getDateAddOfAPI(bytes32 myid) external view returns(uint64) {\r\n        return allAPIid[myid].dateAdd;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the Timestamp at which result of oracalize call is received.\r\n     */  \r\n    function getDateUpdOfAPI(bytes32 myid) external view returns(uint64) {\r\n        return allAPIid[myid].dateUpd;\r\n    }\r\n\r\n    /** \r\n     * @dev Gets currency by oracalize id. \r\n     */  \r\n    function getCurrOfApiId(bytes32 myid) external view returns(bytes4) {\r\n        return allAPIid[myid].currency;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets ID return by the oraclize query of a given index.\r\n     * @param index Index.\r\n     * @return myid ID return by the oraclize query.\r\n     */  \r\n    function getApiCallIndex(uint index) external view returns(bytes32 myid) {\r\n        myid = allAPIcall[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Length of API call. \r\n     */  \r\n    function getApilCallLength() external view returns(uint) {\r\n        return allAPIcall.length;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get Details of Oraclize API when given Oraclize Id.\r\n     * @param myid ID return by the oraclize query.\r\n     * @return _typeof ype of the query for which oraclize \r\n     * call is made.(\"proposal\",\"quote\",\"quotation\" etc.) \r\n     */  \r\n    function getApiCallDetails(\r\n        bytes32 myid\r\n    )\r\n        external\r\n        view\r\n        returns(\r\n            bytes4 _typeof,\r\n            bytes4 curr,\r\n            uint id,\r\n            uint64 dateAdd,\r\n            uint64 dateUpd\r\n        )\r\n    {\r\n        return (\r\n            allAPIid[myid].typeOf,\r\n            allAPIid[myid].currency,\r\n            allAPIid[myid].id,\r\n            allAPIid[myid].dateAdd,\r\n            allAPIid[myid].dateUpd\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"MCRTIM\") {\r\n            _changeMCRTime(val * 1 hours);\r\n\r\n        } else if (code == \"MCRFTIM\") {\r\n\r\n            _changeMCRFailTime(val * 1 hours);\r\n\r\n        } else if (code == \"MCRMIN\") {\r\n\r\n            _changeMinCap(val);\r\n\r\n        } else if (code == \"MCRSHOCK\") {\r\n\r\n            _changeShockParameter(val);\r\n\r\n        } else if (code == \"MCRCAPL\") {\r\n\r\n            _changeCapacityLimit(val);\r\n\r\n        } else if (code == \"IMZ\") {\r\n\r\n            _changeVariationPercX100(val);\r\n\r\n        } else if (code == \"IMRATET\") {\r\n\r\n            _changeIARatesTime(val * 1 hours);\r\n\r\n        } else if (code == \"IMUNIDL\") {\r\n\r\n            _changeUniswapDeadlineTime(val * 1 minutes);\r\n\r\n        } else if (code == \"IMLIQT\") {\r\n\r\n            _changeliquidityTradeCallbackTime(val * 1 hours);\r\n\r\n        } else if (code == \"IMETHVL\") {\r\n\r\n            _setEthVolumeLimit(val);\r\n\r\n        } else if (code == \"C\") {\r\n            _changeC(val);\r\n\r\n        } else if (code == \"A\") {\r\n\r\n            _changeA(val);\r\n\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        }\r\n            \r\n    }\r\n\r\n    /**\r\n     * @dev to get the average rate of currency rate \r\n     * @param curr is the currency in concern\r\n     * @return required rate\r\n     */\r\n    function getCAAvgRate(bytes4 curr) public view returns(uint rate) {\r\n        return _getAvgRate(curr, false);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the average rate of investment rate \r\n     * @param curr is the investment in concern\r\n     * @return required rate\r\n     */\r\n    function getIAAvgRate(bytes4 curr) public view returns(uint rate) {\r\n        return _getAvgRate(curr, true);\r\n    }\r\n\r\n    function changeDependentContractAddress() public onlyInternal {}\r\n\r\n    /// @dev Gets the average rate of a CA currency.\r\n    /// @param curr Currency Name.\r\n    /// @return rate Average rate X 100(of last 3 days).\r\n    function _getAvgRate(bytes4 curr, bool isIA) internal view returns(uint rate) {\r\n        if (curr == \"DAI\") {\r\n            DSValue ds = DSValue(daiFeedAddress);\r\n            rate = uint(ds.read()).div(uint(10) ** 16);\r\n        } else if (isIA) {\r\n            rate = iaAvgRate[curr];\r\n        } else {\r\n            rate = caAvgRate[curr];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to set the ethereum volume limit \r\n     * @param val is the new limit value\r\n     */\r\n    function _setEthVolumeLimit(uint val) internal {\r\n        ethVolumeLimit = val;\r\n    }\r\n\r\n    /// @dev Sets minimum Cap.\r\n    function _changeMinCap(uint newCap) internal {\r\n        minCap = newCap;\r\n    }\r\n\r\n    /// @dev Sets Shock Parameter.\r\n    function _changeShockParameter(uint newParam) internal {\r\n        shockParameter = newParam;\r\n    }\r\n    \r\n    /// @dev Changes time period for obtaining new MCR data from external oracle query.\r\n    function _changeMCRTime(uint _time) internal {\r\n        mcrTime = _time;\r\n    }\r\n\r\n    /// @dev Sets MCR Fail time.\r\n    function _changeMCRFailTime(uint _time) internal {\r\n        mcrFailTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev to change the uniswap deadline time \r\n     * @param newDeadline is the value\r\n     */\r\n    function _changeUniswapDeadlineTime(uint newDeadline) internal {\r\n        uniswapDeadline = newDeadline;\r\n    }\r\n\r\n    /**\r\n     * @dev to change the liquidity trade call back time \r\n     * @param newTime is the new value to be set\r\n     */\r\n    function _changeliquidityTradeCallbackTime(uint newTime) internal {\r\n        liquidityTradeCallbackTime = newTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes time after which investment asset rates need to be fed.\r\n     */  \r\n    function _changeIARatesTime(uint _newTime) internal {\r\n        iaRatesTime = _newTime;\r\n    }\r\n    \r\n    /**\r\n     * @dev Changes the variation range percentage.\r\n     */  \r\n    function _changeVariationPercX100(uint newPercX100) internal {\r\n        variationPercX100 = newPercX100;\r\n    }\r\n\r\n    /// @dev Changes Growth Step\r\n    function _changeC(uint newC) internal {\r\n        c = newC;\r\n    }\r\n\r\n    /// @dev Changes scaling factor.\r\n    function _changeA(uint val) internal {\r\n        a = val;\r\n    }\r\n    \r\n    /**\r\n     * @dev to change the capacity limit \r\n     * @param val is the new value\r\n     */\r\n    function _changeCapacityLimit(uint val) internal {\r\n        capacityLimit = val;\r\n    }    \r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract QuotationData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    enum HCIDStatus { NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover }\r\n\r\n    enum CoverStatus { Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested }\r\n\r\n    struct Cover {\r\n        address payable memberAddress;\r\n        bytes4 currencyCode;\r\n        uint sumAssured;\r\n        uint16 coverPeriod;\r\n        uint validUntil;\r\n        address scAddress;\r\n        uint premiumSOTE;\r\n    }\r\n\r\n    struct HoldCover {\r\n        uint holdCoverId;\r\n        address payable userAddress;\r\n        address scAddress;\r\n        bytes4 coverCurr;\r\n        uint[] coverDetails;\r\n        uint16 coverPeriod;\r\n    }\r\n\r\n    address public authQuoteEngine;\r\n  \r\n    mapping(bytes4 => uint) internal currencyCSA;\r\n    mapping(address => uint[]) internal userCover;\r\n    mapping(address => uint[]) public userHoldedCover;\r\n    mapping(address => bool) public refundEligible;\r\n    mapping(address => mapping(bytes4 => uint)) internal currencyCSAOfSCAdd;\r\n    mapping(uint => uint8) public coverStatus;\r\n    mapping(uint => uint) public holdedCoverIDStatus;\r\n    mapping(uint => bool) public timestampRepeated; \r\n    \r\n\r\n    Cover[] internal allCovers;\r\n    HoldCover[] internal allCoverHolded;\r\n\r\n    uint public stlp;\r\n    uint public stl;\r\n    uint public pm;\r\n    uint public minDays;\r\n    uint public tokensRetained;\r\n    address public kycAuthAddress;\r\n\r\n    event CoverDetailsEvent(\r\n        uint indexed cid,\r\n        address scAdd,\r\n        uint sumAssured,\r\n        uint expiry,\r\n        uint premium,\r\n        uint premiumSOTE,\r\n        bytes4 curr\r\n    );\r\n\r\n    event CoverStatusEvent(uint indexed cid, uint8 statusNum);\r\n\r\n    constructor(address _authQuoteAdd, address _kycAuthAdd) public {\r\n        authQuoteEngine = _authQuoteAdd;\r\n        kycAuthAddress = _kycAuthAdd;\r\n        stlp = 90;\r\n        stl = 100;\r\n        pm = 30;\r\n        minDays = 30;\r\n        tokensRetained = 10;\r\n        allCovers.push(Cover(address(0), \"0x00\", 0, 0, 0, address(0), 0));\r\n        uint[] memory arr = new uint[](1);\r\n        allCoverHolded.push(HoldCover(0, address(0), address(0), 0x00, arr, 0));\r\n\r\n    }\r\n    \r\n    /// @dev Adds the amount in Total Sum Assured of a given currency of a given smart contract address.\r\n    /// @param _add Smart Contract Address.\r\n    /// @param _amount Amount to be added.\r\n    function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].add(_amount);\r\n    }\r\n\r\n    /// @dev Subtracts the amount from Total Sum Assured of a given currency and smart contract address.\r\n    /// @param _add Smart Contract Address.\r\n    /// @param _amount Amount to be subtracted.\r\n    function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSAOfSCAdd[_add][_curr] = currencyCSAOfSCAdd[_add][_curr].sub(_amount);\r\n    }\r\n    \r\n    /// @dev Subtracts the amount from Total Sum Assured of a given currency.\r\n    /// @param _curr Currency Name.\r\n    /// @param _amount Amount to be subtracted.\r\n    function subFromTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSA[_curr] = currencyCSA[_curr].sub(_amount);\r\n    }\r\n\r\n    /// @dev Adds the amount in Total Sum Assured of a given currency.\r\n    /// @param _curr Currency Name.\r\n    /// @param _amount Amount to be added.\r\n    function addInTotalSumAssured(bytes4 _curr, uint _amount) external onlyInternal {\r\n        currencyCSA[_curr] = currencyCSA[_curr].add(_amount);\r\n    }\r\n\r\n    /// @dev sets bit for timestamp to avoid replay attacks.\r\n    function setTimestampRepeated(uint _timestamp) external onlyInternal {\r\n        timestampRepeated[_timestamp] = true;\r\n    }\r\n    \r\n    /// @dev Creates a blank new cover.\r\n    function addCover(\r\n        uint16 _coverPeriod,\r\n        uint _sumAssured,\r\n        address payable _userAddress,\r\n        bytes4 _currencyCode,\r\n        address _scAddress,\r\n        uint premium,\r\n        uint premiumSOTE\r\n    )   \r\n        external\r\n        onlyInternal\r\n    {\r\n        uint expiryDate = now.add(uint(_coverPeriod).mul(1 days));\r\n        allCovers.push(Cover(_userAddress, _currencyCode,\r\n                _sumAssured, _coverPeriod, expiryDate, _scAddress, premiumSOTE));\r\n        uint cid = allCovers.length.sub(1);\r\n        userCover[_userAddress].push(cid);\r\n        emit CoverDetailsEvent(cid, _scAddress, _sumAssured, expiryDate, premium, premiumSOTE, _currencyCode);\r\n    }\r\n\r\n    /// @dev create holded cover which will process after verdict of KYC.\r\n    function addHoldCover(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr, \r\n        uint[] calldata coverDetails,\r\n        uint16 coverPeriod\r\n    )   \r\n        external\r\n        onlyInternal\r\n    {\r\n        uint holdedCoverLen = allCoverHolded.length;\r\n        holdedCoverIDStatus[holdedCoverLen] = uint(HCIDStatus.kycPending);             \r\n        allCoverHolded.push(HoldCover(holdedCoverLen, from, scAddress, \r\n            coverCurr, coverDetails, coverPeriod));\r\n        userHoldedCover[from].push(allCoverHolded.length.sub(1));\r\n    \r\n    }\r\n\r\n    ///@dev sets refund eligible bit.\r\n    ///@param _add user address.\r\n    ///@param status indicates if user have pending kyc.\r\n    function setRefundEligible(address _add, bool status) external onlyInternal {\r\n        refundEligible[_add] = status;\r\n    }\r\n\r\n    /// @dev to set current status of particular holded coverID (1 for not completed KYC,\r\n    /// 2 for KYC passed, 3 for failed KYC or full refunded,\r\n    /// 4 for KYC completed but cover not processed)\r\n    function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external onlyInternal {\r\n        holdedCoverIDStatus[holdedCoverID] = status;\r\n    }\r\n\r\n    /**\r\n     * @dev to set address of kyc authentication \r\n     * @param _add is the new address\r\n     */\r\n    function setKycAuthAddress(address _add) external onlyInternal {\r\n        kycAuthAddress = _add;\r\n    }\r\n\r\n    /// @dev Changes authorised address for generating quote off chain.\r\n    function changeAuthQuoteEngine(address _add) external onlyInternal {\r\n        authQuoteEngine = _add;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n\r\n        if (code == \"STLP\") {\r\n            val = stlp;\r\n\r\n        } else if (code == \"STL\") {\r\n            \r\n            val = stl;\r\n\r\n        } else if (code == \"PM\") {\r\n\r\n            val = pm;\r\n\r\n        } else if (code == \"QUOMIND\") {\r\n\r\n            val = minDays;\r\n\r\n        } else if (code == \"QUOTOK\") {\r\n\r\n            val = tokensRetained;\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    /// @dev Gets Product details.\r\n    /// @return  _minDays minimum cover period.\r\n    /// @return  _PM Profit margin.\r\n    /// @return  _STL short term Load.\r\n    /// @return  _STLP short term load period.\r\n    function getProductDetails()\r\n        external\r\n        view\r\n        returns (\r\n            uint _minDays,\r\n            uint _pm,\r\n            uint _stl,\r\n            uint _stlp\r\n        )\r\n    {\r\n\r\n        _minDays = minDays;\r\n        _pm = pm;\r\n        _stl = stl;\r\n        _stlp = stlp;\r\n    }\r\n\r\n    /// @dev Gets total number covers created till date.\r\n    function getCoverLength() external view returns(uint len) {\r\n        return (allCovers.length);\r\n    }\r\n\r\n    /// @dev Gets Authorised Engine address.\r\n    function getAuthQuoteEngine() external view returns(address _add) {\r\n        _add = authQuoteEngine;\r\n    }\r\n\r\n    /// @dev Gets the Total Sum Assured amount of a given currency.\r\n    function getTotalSumAssured(bytes4 _curr) external view returns(uint amount) {\r\n        amount = currencyCSA[_curr];\r\n    }\r\n\r\n    /// @dev Gets all the Cover ids generated by a given address.\r\n    /// @param _add User's address.\r\n    /// @return allCover array of covers.\r\n    function getAllCoversOfUser(address _add) external view returns(uint[] memory allCover) {\r\n        return (userCover[_add]);\r\n    }\r\n\r\n    /// @dev Gets total number of covers generated by a given address\r\n    function getUserCoverLength(address _add) external view returns(uint len) {\r\n        len = userCover[_add].length;\r\n    }\r\n\r\n    /// @dev Gets the status of a given cover.\r\n    function getCoverStatusNo(uint _cid) external view returns(uint8) {\r\n        return coverStatus[_cid];\r\n    }\r\n\r\n    /// @dev Gets the Cover Period (in days) of a given cover.\r\n    function getCoverPeriod(uint _cid) external view returns(uint32 cp) {\r\n        cp = allCovers[_cid].coverPeriod;\r\n    }\r\n\r\n    /// @dev Gets the Sum Assured Amount of a given cover.\r\n    function getCoverSumAssured(uint _cid) external view returns(uint sa) {\r\n        sa = allCovers[_cid].sumAssured;\r\n    }\r\n\r\n    /// @dev Gets the Currency Name in which a given cover is assured.\r\n    function getCurrencyOfCover(uint _cid) external view returns(bytes4 curr) {\r\n        curr = allCovers[_cid].currencyCode;\r\n    }\r\n\r\n    /// @dev Gets the validity date (timestamp) of a given cover.\r\n    function getValidityOfCover(uint _cid) external view returns(uint date) {\r\n        date = allCovers[_cid].validUntil;\r\n    }\r\n\r\n    /// @dev Gets Smart contract address of cover.\r\n    function getscAddressOfCover(uint _cid) external view returns(uint, address) {\r\n        return (_cid, allCovers[_cid].scAddress);\r\n    }\r\n\r\n    /// @dev Gets the owner address of a given cover.\r\n    function getCoverMemberAddress(uint _cid) external view returns(address payable _add) {\r\n        _add = allCovers[_cid].memberAddress;\r\n    }\r\n\r\n    /// @dev Gets the premium amount of a given cover in SOTE.\r\n    function getCoverPremiumSOTE(uint _cid) external view returns(uint _premiumSOTE) {\r\n        _premiumSOTE = allCovers[_cid].premiumSOTE;\r\n    }\r\n\r\n    /// @dev Provides the details of a cover Id\r\n    /// @param _cid cover Id\r\n    /// @return memberAddress cover user address.\r\n    /// @return scAddress smart contract Address \r\n    /// @return currencyCode currency of cover\r\n    /// @return sumAssured sum assured of cover\r\n    /// @return premiumSOTE premium in SOTE\r\n    function getCoverDetailsByCoverID1(\r\n        uint _cid\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            address _memberAddress,\r\n            address _scAddress,\r\n            bytes4 _currencyCode,\r\n            uint _sumAssured,  \r\n            uint premiumSOTE \r\n        ) \r\n    {\r\n        return (\r\n            _cid,\r\n            allCovers[_cid].memberAddress,\r\n            allCovers[_cid].scAddress,\r\n            allCovers[_cid].currencyCode,\r\n            allCovers[_cid].sumAssured,\r\n            allCovers[_cid].premiumSOTE\r\n        );\r\n    }\r\n\r\n    /// @dev Provides details of a cover Id\r\n    /// @param _cid cover Id\r\n    /// @return status status of cover.\r\n    /// @return sumAssured Sum assurance of cover.\r\n    /// @return coverPeriod Cover Period of cover (in days).\r\n    /// @return validUntil is validity of cover.\r\n    function getCoverDetailsByCoverID2(\r\n        uint _cid\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint cid,\r\n            uint8 status,\r\n            uint sumAssured,\r\n            uint16 coverPeriod,\r\n            uint validUntil\r\n        ) \r\n    {\r\n\r\n        return (\r\n            _cid,\r\n            coverStatus[_cid],\r\n            allCovers[_cid].sumAssured,\r\n            allCovers[_cid].coverPeriod,\r\n            allCovers[_cid].validUntil\r\n        );\r\n    }\r\n\r\n    /// @dev Provides details of a holded cover Id\r\n    /// @param _hcid holded cover Id\r\n    /// @return scAddress SmartCover address of cover.\r\n    /// @return coverCurr currency of cover.\r\n    /// @return coverPeriod Cover Period of cover (in days).\r\n    function getHoldedCoverDetailsByID1(\r\n        uint _hcid\r\n    )\r\n        external \r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address scAddress,\r\n            bytes4 coverCurr,\r\n            uint16 coverPeriod\r\n        )\r\n    {\r\n        return (\r\n            _hcid,\r\n            allCoverHolded[_hcid].scAddress,\r\n            allCoverHolded[_hcid].coverCurr, \r\n            allCoverHolded[_hcid].coverPeriod\r\n        );\r\n    }\r\n\r\n    /// @dev Gets total number holded covers created till date.\r\n    function getUserHoldedCoverLength(address _add) external view returns (uint) {\r\n        return userHoldedCover[_add].length;\r\n    }\r\n\r\n    /// @dev Gets holded cover index by index of user holded covers.\r\n    function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint) {\r\n        return userHoldedCover[_add][index];\r\n    }\r\n\r\n    /// @dev Provides the details of a holded cover Id\r\n    /// @param _hcid holded cover Id\r\n    /// @return memberAddress holded cover user address.\r\n    /// @return coverDetails array contains SA, Cover Currency Price,Price in SOTE, Expiration time of Qoute.    \r\n    function getHoldedCoverDetailsByID2(\r\n        uint _hcid\r\n    ) \r\n        external\r\n        view\r\n        returns (\r\n            uint hcid,\r\n            address payable memberAddress, \r\n            uint[] memory coverDetails\r\n        )\r\n    {\r\n        return (\r\n            _hcid,\r\n            allCoverHolded[_hcid].userAddress,\r\n            allCoverHolded[_hcid].coverDetails\r\n        );\r\n    }\r\n\r\n    /// @dev Gets the Total Sum Assured amount of a given currency and smart contract address.\r\n    function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns(uint amount) {\r\n        amount = currencyCSAOfSCAdd[_add][_curr];\r\n    }\r\n\r\n    //solhint-disable-next-line\r\n    function changeDependentContractAddress() public {}\r\n\r\n    /// @dev Changes the status of a given cover.\r\n    /// @param _cid cover Id.\r\n    /// @param _stat New status.\r\n    function changeCoverStatusNo(uint _cid, uint8 _stat) public onlyInternal {\r\n        coverStatus[_cid] = _stat;\r\n        emit CoverStatusEvent(_cid, _stat);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"STLP\") {\r\n            _changeSTLP(val);\r\n\r\n        } else if (code == \"STL\") {\r\n            \r\n            _changeSTL(val);\r\n\r\n        } else if (code == \"PM\") {\r\n\r\n            _changePM(val);\r\n\r\n        } else if (code == \"QUOMIND\") {\r\n\r\n            _changeMinDays(val);\r\n\r\n        } else if (code == \"QUOTOK\") {\r\n\r\n            _setTokensRetained(val);\r\n\r\n        } else {\r\n\r\n            revert(\"Invalid param code\");\r\n        }\r\n        \r\n    }\r\n    \r\n    /// @dev Changes the existing Profit Margin value\r\n    function _changePM(uint _pm) internal {\r\n        pm = _pm;\r\n    }\r\n\r\n    /// @dev Changes the existing Short Term Load Period (STLP) value.\r\n    function _changeSTLP(uint _stlp) internal {\r\n        stlp = _stlp;\r\n    }\r\n\r\n    /// @dev Changes the existing Short Term Load (STL) value.\r\n    function _changeSTL(uint _stl) internal {\r\n        stl = _stl;\r\n    }\r\n\r\n    /// @dev Changes the existing Minimum cover period (in days)\r\n    function _changeMinDays(uint _days) internal {\r\n        minDays = _days;\r\n    }\r\n    \r\n    /**\r\n     * @dev to set the the amount of tokens retained \r\n     * @param val is the amount retained\r\n     */\r\n    function _setTokensRetained(uint val) internal {\r\n        tokensRetained = val;\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract TokenData is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    address payable public walletAddress;\r\n    uint public lockTokenTimeAfterCoverExp;\r\n    uint public bookTime;\r\n    uint public lockCADays;\r\n    uint public lockMVDays;\r\n    uint public scValidDays;\r\n    uint public joiningFee;\r\n    uint public stakerCommissionPer;\r\n    uint public stakerMaxCommissionPer;\r\n    uint public tokenExponent;\r\n    uint public priceStep;\r\n\r\n    struct StakeCommission {\r\n        uint commissionEarned;\r\n        uint commissionRedeemed;\r\n    }\r\n\r\n    struct Stake {\r\n        address stakedContractAddress;\r\n        uint stakedContractIndex;\r\n        uint dateAdd;\r\n        uint stakeAmount;\r\n        uint unlockedAmount;\r\n        uint burnedAmount;\r\n        uint unLockableBeforeLastBurn;\r\n    }\r\n\r\n    struct Staker {\r\n        address stakerAddress;\r\n        uint stakerIndex;\r\n    }\r\n\r\n    struct CoverNote {\r\n        uint amount;\r\n        bool isDeposited;\r\n    }\r\n\r\n    /**\r\n     * @dev mapping of uw address to array of sc address to fetch \r\n     * all staked contract address of underwriter, pushing\r\n     * data into this array of Stake returns stakerIndex \r\n     */ \r\n    mapping(address => Stake[]) public stakerStakedContracts; \r\n\r\n    /** \r\n     * @dev mapping of sc address to array of UW address to fetch\r\n     * all underwritters of the staked smart contract\r\n     * pushing data into this mapped array returns scIndex \r\n     */\r\n    mapping(address => Staker[]) public stakedContractStakers;\r\n\r\n    /**\r\n     * @dev mapping of staked contract Address to the array of StakeCommission\r\n     * here index of this array is stakedContractIndex\r\n     */ \r\n    mapping(address => mapping(uint => StakeCommission)) public stakedContractStakeCommission;\r\n\r\n    mapping(address => uint) public lastCompletedStakeCommission;\r\n\r\n    /** \r\n     * @dev mapping of the staked contract address to the current \r\n     * staker index who will receive commission.\r\n     */ \r\n    mapping(address => uint) public stakedContractCurrentCommissionIndex;\r\n\r\n    /** \r\n     * @dev mapping of the staked contract address to the \r\n     * current staker index to burn token from.\r\n     */ \r\n    mapping(address => uint) public stakedContractCurrentBurnIndex;\r\n\r\n    /** \r\n     * @dev mapping to return true if Cover Note deposited against coverId\r\n     */ \r\n    mapping(uint => CoverNote) public depositedCN;\r\n\r\n    mapping(address => uint) internal isBookedTokens;\r\n\r\n    event Commission(\r\n        address indexed stakedContractAddress,\r\n        address indexed stakerAddress,\r\n        uint indexed scIndex,\r\n        uint commissionAmount\r\n    );\r\n\r\n    constructor(address payable _walletAdd) public {\r\n        walletAddress = _walletAdd;\r\n        bookTime = 12 hours;\r\n        joiningFee = 100000000000000000; // 0.1 BNB\r\n        lockTokenTimeAfterCoverExp = 35 days;\r\n        scValidDays = 250;\r\n        lockCADays = 7 days;\r\n        lockMVDays = 2 days;\r\n        stakerCommissionPer = 20;\r\n        stakerMaxCommissionPer = 50;\r\n        tokenExponent = 4;\r\n        priceStep = 1000;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Change the wallet address which receive Joining Fee\r\n     */\r\n    function changeWalletAddress(address payable _address) external onlyInternal {\r\n        walletAddress = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"TOKEXP\") {\r\n\r\n            val = tokenExponent; \r\n\r\n        } else if (code == \"TOKSTEP\") {\r\n\r\n            val = priceStep;\r\n\r\n        } else if (code == \"RALOCKT\") {\r\n\r\n            val = scValidDays;\r\n\r\n        } else if (code == \"RACOMM\") {\r\n\r\n            val = stakerCommissionPer;\r\n\r\n        } else if (code == \"RAMAXC\") {\r\n\r\n            val = stakerMaxCommissionPer;\r\n\r\n        } else if (code == \"CABOOKT\") {\r\n\r\n            val = bookTime / (1 hours);\r\n\r\n        } else if (code == \"CALOCKT\") {\r\n\r\n            val = lockCADays / (1 days);\r\n\r\n        } else if (code == \"MVLOCKT\") {\r\n\r\n            val = lockMVDays / (1 days);\r\n\r\n        } else if (code == \"QUOLOCKT\") {\r\n\r\n            val = lockTokenTimeAfterCoverExp / (1 days);\r\n\r\n        } else if (code == \"JOINFEE\") {\r\n\r\n            val = joiningFee;\r\n\r\n        } \r\n    }\r\n\r\n    /**\r\n    * @dev Just for interface\r\n    */\r\n    function changeDependentContractAddress() public { //solhint-disable-line\r\n    }\r\n    \r\n    /**\r\n     * @dev to get the contract staked by a staker \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return the address of staked contract\r\n     */\r\n    function getStakerStakedContractByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (address stakedContractAddress) \r\n    {\r\n        stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker's staked burned \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount burned\r\n     */\r\n    function getStakerStakedBurnedByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint burnedAmount) \r\n    {\r\n        burnedAmount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].burnedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker's staked unlockable before the last burn \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return unlockable staked tokens\r\n     */\r\n    function getStakerStakedUnlockableBeforeLastBurnByIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint unlockable) \r\n    {\r\n        unlockable = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].unLockableBeforeLastBurn;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker's staked contract index \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return is the index of the smart contract address\r\n     */\r\n    function getStakerStakedContractIndex(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint scIndex) \r\n    {\r\n        scIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker index of the staked contract\r\n     * @param _stakedContractAddress is the address of the staked contract\r\n     * @param _stakedContractIndex is the index of staked contract\r\n     * @return is the index of the staker\r\n     */\r\n    function getStakedContractStakerIndex(\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    ) \r\n        public\r\n        view\r\n        returns (uint sIndex) \r\n    {\r\n        sIndex = stakedContractStakers[\r\n            _stakedContractAddress][_stakedContractIndex].stakerIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker's initial staked amount on the contract \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return staked amount\r\n     */\r\n    function getStakerInitialStakedAmountOnContract(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint amount)\r\n    {\r\n        amount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakeAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker's staked contract length \r\n     * @param _stakerAddress is the address of the staker\r\n     * @return length of staked contract\r\n     */\r\n    function getStakerStakedContractLength(\r\n        address _stakerAddress\r\n    ) \r\n        public\r\n        view\r\n        returns (uint length)\r\n    {\r\n        length = stakerStakedContracts[_stakerAddress].length;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker's unlocked tokens which were staked \r\n     * @param _stakerAddress is the address of the staker\r\n     * @param _stakerIndex is the index of staker\r\n     * @return amount\r\n     */\r\n    function getStakerUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint amount)\r\n    {\r\n        amount = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].unlockedAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the unlocked staked tokens by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker to distribute commission.\r\n     * @param _amount amount to be given as commission.\r\n     */ \r\n    function pushUnlockedStakedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unlockedAmount = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].unlockedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the Burned tokens for a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be burned.\r\n     */ \r\n    function pushBurnedTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].burnedAmount = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].burnedAmount.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the unLockable tokens for a staker before last burn.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be added to unlockable.\r\n     */ \r\n    function pushUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unLockableBeforeLastBurn = stakerStakedContracts[_stakerAddress][\r\n                _stakerIndex].unLockableBeforeLastBurn.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev sets the unLockable tokens for a staker before last burn.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker.\r\n     * @param _amount amount to be added to unlockable.\r\n     */ \r\n    function setUnlockableBeforeLastBurnTokens(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        stakerStakedContracts[_stakerAddress][\r\n            _stakerIndex].unLockableBeforeLastBurn = _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the earned commission earned by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakedContractAddress address of smart contract.\r\n     * @param _stakedContractIndex index of the staker to distribute commission.\r\n     * @param _commissionAmount amount to be given as commission.\r\n     */ \r\n    function pushEarnedStakeCommissions(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex,\r\n        uint _commissionAmount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractStakeCommission[_stakedContractAddress][_stakedContractIndex].\r\n            commissionEarned = stakedContractStakeCommission[_stakedContractAddress][\r\n                _stakedContractIndex].commissionEarned.add(_commissionAmount);\r\n                \r\n        emit Commission(\r\n            _stakerAddress,\r\n            _stakedContractAddress,\r\n            _stakedContractIndex,\r\n            _commissionAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev pushes the redeemed commission redeemed by a staker.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker to distribute commission.\r\n     * @param _amount amount to be given as commission.\r\n     */ \r\n    function pushRedeemedStakeCommissions(\r\n        address _stakerAddress,\r\n        uint _stakerIndex,\r\n        uint _amount\r\n    )   \r\n        public\r\n        onlyInternal\r\n    {   \r\n        uint stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        address stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        stakedContractStakeCommission[stakedContractAddress][stakedContractIndex].\r\n            commissionRedeemed = stakedContractStakeCommission[\r\n                stakedContractAddress][stakedContractIndex].commissionRedeemed.add(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets stake commission given to an underwriter\r\n     * for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function getStakerEarnedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint) \r\n    {\r\n        return _getStakerEarnedStakeCommission(_stakerAddress, _stakerIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets stake commission redeemed by an underwriter\r\n     * for particular staked contract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     * @return commissionEarned total amount given to staker.\r\n     */ \r\n    function getStakerRedeemedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        public \r\n        view\r\n        returns (uint) \r\n    {\r\n        return _getStakerRedeemedStakeCommission(_stakerAddress, _stakerIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total stake commission given to an underwriter\r\n     * @param _stakerAddress address of staker.\r\n     * @return totalCommissionEarned total commission earned by staker.\r\n     */ \r\n    function getStakerTotalEarnedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n        public \r\n        view\r\n        returns (uint totalCommissionEarned) \r\n    {\r\n        totalCommissionEarned = 0;\r\n        for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\r\n            totalCommissionEarned = totalCommissionEarned.\r\n                add(_getStakerEarnedStakeCommission(_stakerAddress, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets total stake commission given to an underwriter\r\n     * @param _stakerAddress address of staker.\r\n     * @return totalCommissionEarned total commission earned by staker.\r\n     */ \r\n    function getStakerTotalReedmedStakeCommission(\r\n        address _stakerAddress\r\n    )\r\n        public \r\n        view\r\n        returns(uint totalCommissionRedeemed) \r\n    {\r\n        totalCommissionRedeemed = 0;\r\n        for (uint i = 0; i < stakerStakedContracts[_stakerAddress].length; i++) {\r\n            totalCommissionRedeemed = totalCommissionRedeemed.add(\r\n                _getStakerRedeemedStakeCommission(_stakerAddress, i));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev set flag to deposit/ undeposit cover note \r\n     * against a cover Id\r\n     * @param coverId coverId of Cover\r\n     * @param flag true/false for deposit/undeposit\r\n     */\r\n    function setDepositCN(uint coverId, bool flag) public onlyInternal {\r\n\r\n        if (flag == true) {\r\n            require(!depositedCN[coverId].isDeposited, \"Cover note already deposited\");    \r\n        }\r\n\r\n        depositedCN[coverId].isDeposited = flag;\r\n    }\r\n\r\n    /**\r\n     * @dev set locked cover note amount\r\n     * against a cover Id\r\n     * @param coverId coverId of Cover\r\n     * @param amount amount of sote to be locked\r\n     */\r\n    function setDepositCNAmount(uint coverId, uint amount) public onlyInternal {\r\n\r\n        depositedCN[coverId].amount = amount;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the staker address on a staked contract \r\n     * @param _stakedContractAddress is the address of the staked contract in concern\r\n     * @param _stakedContractIndex is the index of staked contract's index\r\n     * @return address of staker\r\n     */\r\n    function getStakedContractStakerByIndex(\r\n        address _stakedContractAddress,\r\n        uint _stakedContractIndex\r\n    )\r\n        public\r\n        view\r\n        returns (address stakerAddress)\r\n    {\r\n        stakerAddress = stakedContractStakers[\r\n            _stakedContractAddress][_stakedContractIndex].stakerAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev to get the length of stakers on a staked contract \r\n     * @param _stakedContractAddress is the address of the staked contract in concern\r\n     * @return length in concern\r\n     */\r\n    function getStakedContractStakersLength(\r\n        address _stakedContractAddress\r\n    ) \r\n        public\r\n        view\r\n        returns (uint length)\r\n    {\r\n        length = stakedContractStakers[_stakedContractAddress].length;\r\n    } \r\n    \r\n    /**\r\n     * @dev Adds a new stake record.\r\n     * @param _stakerAddress staker address.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _amount amountof SOTE to be staked.\r\n     */\r\n    function addStake(\r\n        address _stakerAddress,\r\n        address _stakedContractAddress,\r\n        uint _amount\r\n    ) \r\n        public\r\n        onlyInternal\r\n        returns(uint scIndex) \r\n    {\r\n        scIndex = (stakedContractStakers[_stakedContractAddress].push(\r\n            Staker(_stakerAddress, stakerStakedContracts[_stakerAddress].length))).sub(1);\r\n        stakerStakedContracts[_stakerAddress].push(\r\n            Stake(_stakedContractAddress, scIndex, now, _amount, 0, 0, 0));\r\n    }\r\n\r\n    /**\r\n     * @dev books the user's tokens for maintaining Assessor Velocity, \r\n     * i.e. once a token is used to cast a vote as a Claims assessor,\r\n     * @param _of user's address.\r\n     */\r\n    function bookCATokens(address _of) public onlyInternal {\r\n        require(!isCATokensBooked(_of), \"Tokens already booked\");\r\n        isBookedTokens[_of] = now.add(bookTime);\r\n    }\r\n\r\n    /**\r\n     * @dev to know if claim assessor's tokens are booked or not \r\n     * @param _of is the claim assessor's address in concern\r\n     * @return boolean representing the status of tokens booked\r\n     */\r\n    function isCATokensBooked(address _of) public view returns(bool res) {\r\n        if (now < isBookedTokens[_of])\r\n            res = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the index which will receive commission.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setStakedContractCurrentCommissionIndex(\r\n        address _stakedContractAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractCurrentCommissionIndex[_stakedContractAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the last complete commission index\r\n     * @param _stakerAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setLastCompletedStakeCommissionIndex(\r\n        address _stakerAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        lastCompletedStakeCommission[_stakerAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the index till which commission is distrubuted.\r\n     * @param _stakedContractAddress smart contract address.\r\n     * @param _index current index.\r\n     */\r\n    function setStakedContractCurrentBurnIndex(\r\n        address _stakedContractAddress,\r\n        uint _index\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        stakedContractCurrentBurnIndex[_stakedContractAddress] = _index;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"TOKEXP\") {\r\n\r\n            _setTokenExponent(val); \r\n\r\n        } else if (code == \"TOKSTEP\") {\r\n\r\n            _setPriceStep(val);\r\n\r\n        } else if (code == \"RALOCKT\") {\r\n\r\n            _changeSCValidDays(val);\r\n\r\n        } else if (code == \"RACOMM\") {\r\n\r\n            _setStakerCommissionPer(val);\r\n\r\n        } else if (code == \"RAMAXC\") {\r\n\r\n            _setStakerMaxCommissionPer(val);\r\n\r\n        } else if (code == \"CABOOKT\") {\r\n\r\n            _changeBookTime(val * 1 hours);\r\n\r\n        } else if (code == \"CALOCKT\") {\r\n\r\n            _changelockCADays(val * 1 days);\r\n\r\n        } else if (code == \"MVLOCKT\") {\r\n\r\n            _changelockMVDays(val * 1 days);\r\n\r\n        } else if (code == \"QUOLOCKT\") {\r\n\r\n            _setLockTokenTimeAfterCoverExp(val * 1 days);\r\n\r\n        } else if (code == \"JOINFEE\") {\r\n\r\n            _setJoiningFee(val);\r\n\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        } \r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get stake commission given to an \r\n     * underwriter for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function _getStakerEarnedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        internal\r\n        view \r\n        returns (uint amount) \r\n    {\r\n        uint _stakedContractIndex;\r\n        address _stakedContractAddress;\r\n        _stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        _stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        amount = stakedContractStakeCommission[\r\n            _stakedContractAddress][_stakedContractIndex].commissionEarned;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to get stake commission redeemed by an \r\n     * underwriter for particular stakedcontract on given index.\r\n     * @param _stakerAddress address of staker.\r\n     * @param _stakerIndex index of the staker commission.\r\n     */ \r\n    function _getStakerRedeemedStakeCommission(\r\n        address _stakerAddress,\r\n        uint _stakerIndex\r\n    )\r\n        internal\r\n        view \r\n        returns (uint amount) \r\n    {\r\n        uint _stakedContractIndex;\r\n        address _stakedContractAddress;\r\n        _stakedContractAddress = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractAddress;\r\n        _stakedContractIndex = stakerStakedContracts[\r\n            _stakerAddress][_stakerIndex].stakedContractIndex;\r\n        amount = stakedContractStakeCommission[\r\n            _stakedContractAddress][_stakedContractIndex].commissionRedeemed;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the percentage of staker commission \r\n     * @param _val is new percentage value\r\n     */\r\n    function _setStakerCommissionPer(uint _val) internal {\r\n        stakerCommissionPer = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the max percentage of staker commission \r\n     * @param _val is new percentage value\r\n     */\r\n    function _setStakerMaxCommissionPer(uint _val) internal {\r\n        stakerMaxCommissionPer = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the token exponent value \r\n     * @param _val is new value\r\n     */\r\n    function _setTokenExponent(uint _val) internal {\r\n        tokenExponent = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev to set the price step \r\n     * @param _val is new value\r\n     */\r\n    function _setPriceStep(uint _val) internal {\r\n        priceStep = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes number of days for which SOTE needs to staked in case of underwriting\r\n     */ \r\n    function _changeSCValidDays(uint _days) internal {\r\n        scValidDays = _days;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the time period up to which tokens will be locked.\r\n     *      Used to generate the validity period of tokens booked by\r\n     *      a user for participating in claim's assessment/claim's voting.\r\n     */ \r\n    function _changeBookTime(uint _time) internal {\r\n        bookTime = _time;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes lock CA days - number of days for which tokens \r\n     * are locked while submitting a vote.\r\n     */ \r\n    function _changelockCADays(uint _val) internal {\r\n        lockCADays = _val;\r\n    }\r\n    \r\n    /**\r\n     * @dev Changes lock MV days - number of days for which tokens are locked\r\n     * while submitting a vote.\r\n     */ \r\n    function _changelockMVDays(uint _val) internal {\r\n        lockMVDays = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes extra lock period for a cover, post its expiry.\r\n     */ \r\n    function _setLockTokenTimeAfterCoverExp(uint time) internal {\r\n        lockTokenTimeAfterCoverExp = time;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the joining fee for membership\r\n     */\r\n    function _setJoiningFee(uint _amount) internal {\r\n        joiningFee = _amount;\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract Quotation is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    TokenFunctions internal tf;\r\n    TokenController internal tc;\r\n    TokenData internal td;\r\n    Pool1 internal p1;\r\n    PoolData internal pd;\r\n    QuotationData internal qd;\r\n    MCR internal m1;\r\n    MemberRoles internal mr;\r\n    bool internal locked;\r\n\r\n    event RefundEvent(address indexed user, bool indexed status, uint holdedCoverID, bytes32 reason);\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n    \r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    }\r\n\r\n    function sendEther() public payable {\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Expires a cover after a set period of time.\r\n     * Changes the status of the Cover and reduces the current\r\n     * sum assured of all areas in which the quotation lies\r\n     * Unlocks the CN tokens of the cover. Updates the Total Sum Assured value.\r\n     * @param _cid Cover Id.\r\n     */ \r\n    function expireCover(uint _cid) public {\r\n        require(checkCoverExpired(_cid) && qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.CoverExpired));\r\n        \r\n        tf.unlockCN(_cid);\r\n        bytes4 curr;\r\n        address scAddress;\r\n        uint sumAssured;\r\n        (, , scAddress, curr, sumAssured, ) = qd.getCoverDetailsByCoverID1(_cid);\r\n        if (qd.getCoverStatusNo(_cid) != uint(QuotationData.CoverStatus.ClaimAccepted))\r\n            _removeSAFromCSA(_cid, sumAssured);\r\n        qd.changeCoverStatusNo(_cid, uint8(QuotationData.CoverStatus.CoverExpired));       \r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a cover should get expired/closed or not.\r\n     * @param _cid Cover Index.\r\n     * @return expire true if the Cover's time has expired, false otherwise.\r\n     */ \r\n    function checkCoverExpired(uint _cid) public view returns(bool expire) {\r\n\r\n        expire = qd.getValidityOfCover(_cid) < uint64(now);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the Sum Assured Amount of all the quotation.\r\n     * @param _cid Cover id\r\n     * @param _amount that will get subtracted Current Sum Assured \r\n     * amount that comes under a quotation.\r\n     */ \r\n    function removeSAFromCSA(uint _cid, uint _amount) public onlyInternal {\r\n        _removeSAFromCSA(_cid, _amount);        \r\n    }\r\n\r\n    /**\r\n     * @dev Makes Cover funded via SOTE tokens.\r\n     * @param smartCAdd Smart Contract Address\r\n     */ \r\n    function makeCoverUsingSOTETokens(\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        bytes4 coverCurr,\r\n        address smartCAdd,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        isMemberAndcheckPause\r\n    {\r\n        \r\n        tc.burnFrom(msg.sender, coverDetails[2]); //need burn allowance\r\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies cover details signed off chain.\r\n     * @param from address of funder.\r\n     * @param scAddress Smart Contract Address\r\n     */\r\n    function verifyCoverDetails(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        onlyInternal\r\n    {\r\n        _verifyCoverDetails(\r\n            from,\r\n            scAddress,\r\n            coverCurr,\r\n            coverDetails,\r\n            coverPeriod,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev Verifies signature.\r\n     * @param coverDetails details related to cover.\r\n     * @param coverPeriod validity of cover.\r\n     * @param smaratCA smarat contract address.\r\n     * @param _v argument from vrs hash.\r\n     * @param _r argument from vrs hash.\r\n     * @param _s argument from vrs hash.\r\n     */ \r\n    function verifySign(\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        bytes4 curr,\r\n        address smaratCA,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        require(smaratCA != address(0));\r\n        require(pd.capReached() == 1, \"Can not buy cover until cap reached for 1st time\");\r\n        bytes32 hash = getOrderHash(coverDetails, coverPeriod, curr, smaratCA);\r\n        return isValidSignature(hash, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets order hash for given cover details.\r\n     * @param coverDetails details realted to cover.\r\n     * @param coverPeriod validity of cover.\r\n     * @param smaratCA smarat contract address.\r\n     */ \r\n    function getOrderHash(\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        bytes4 curr,\r\n        address smaratCA\r\n    ) \r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                coverDetails[0],\r\n                curr, coverPeriod,\r\n                smaratCA,\r\n                coverDetails[1],\r\n                coverDetails[2],\r\n                coverDetails[3],\r\n                coverDetails[4],\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Verifies signature.\r\n     * @param hash order hash\r\n     * @param v argument from vrs hash.\r\n     * @param r argument from vrs hash.\r\n     * @param s argument from vrs hash.\r\n     */  \r\n    function isValidSignature(bytes32 hash, uint8 v, bytes32 r, bytes32 s) public view returns(bool) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\r\n        address a = ecrecover(prefixedHash, v, r, s);\r\n        return (a == qd.getAuthQuoteEngine());\r\n    }\r\n\r\n    /**\r\n     * @dev to get the status of recently holded coverID \r\n     * @param userAdd is the user address in concern\r\n     * @return the status of the concerned coverId\r\n     */\r\n    function getRecentHoldedCoverIdStatus(address userAdd) public view returns(int) {\r\n\r\n        uint holdedCoverLen = qd.getUserHoldedCoverLength(userAdd);\r\n        if (holdedCoverLen == 0) {\r\n            return -1;\r\n        } else {\r\n            uint holdedCoverID = qd.getUserHoldedCoverByIndex(userAdd, holdedCoverLen.sub(1));\r\n            return int(qd.holdedCoverIDStatus(holdedCoverID));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev to initiate the membership and the cover \r\n     * @param smartCAdd is the smart contract address to make cover on\r\n     * @param coverCurr is the currency used to make cover\r\n     * @param coverDetails list of details related to cover like cover amount, expire time, coverCurrPrice and priceSOTE\r\n     * @param coverPeriod is cover period for which cover is being bought\r\n     * @param _v argument from vrs hash \r\n     * @param _r argument from vrs hash \r\n     * @param _s argument from vrs hash \r\n     */\r\n    function initiateMembershipAndCover(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public\r\n        payable\r\n        checkPause\r\n    {\r\n        require(coverDetails[3] > now);\r\n        require(!qd.timestampRepeated(coverDetails[4]));\r\n        qd.setTimestampRepeated(coverDetails[4]);\r\n        require(!ms.isMember(msg.sender));\r\n        require(qd.refundEligible(msg.sender) == false);\r\n        uint joinFee = td.joiningFee();\r\n        uint totalFee = joinFee;\r\n        if (coverCurr == \"BNB\") {\r\n            totalFee = joinFee.add(coverDetails[1]);\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\r\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\r\n        }\r\n        require(msg.value == totalFee);\r\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\r\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\r\n        qd.setRefundEligible(msg.sender, true);\r\n    }\r\n\r\n    /**\r\n     * @dev to get the verdict of kyc process \r\n     * @param status is the kyc status\r\n     * @param _add is the address of member\r\n     */\r\n    function kycVerdict(address _add, bool status) public checkPause noReentrancy {\r\n        require(msg.sender == qd.kycAuthAddress());\r\n        _kycTrigger(status, _add);\r\n    }\r\n\r\n    /**\r\n     * @dev transfering Ethers to newly created quotation contract.\r\n     */  \r\n    function transferAssetsToNewContract(address newAdd) public onlyInternal noReentrancy {\r\n        uint amount = address(this).balance;\r\n        IERC20 erc20;\r\n        if (amount > 0) {\r\n            // newAdd.transfer(amount);   \r\n            Quotation newQT = Quotation(newAdd);\r\n            newQT.sendEther.value(amount)();\r\n        }\r\n        uint currAssetLen = pd.getAllCurrenciesLen();\r\n        for (uint64 i = 1; i < currAssetLen; i++) {\r\n            bytes4 currName = pd.getCurrenciesByIndex(i);\r\n            address currAddr = pd.getCurrencyAssetAddress(currName);\r\n            erc20 = IERC20(currAddr); //solhint-disable-line\r\n            if (erc20.balanceOf(address(this)) > 0) {\r\n                require(erc20.transfer(newAdd, erc20.balanceOf(address(this))));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates cover of the quotation, changes the status of the quotation ,\r\n     * updates the total sum assured and locks the tokens of the cover against a quote.\r\n     * @param from Quote member Ethereum address.\r\n     */  \r\n\r\n    function _makeCover ( //solhint-disable-line\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod\r\n    )\r\n        internal\r\n    {\r\n        uint cid = qd.getCoverLength();\r\n        qd.addCover(coverPeriod, coverDetails[0],\r\n            from, coverCurr, scAddress, coverDetails[1], coverDetails[2]);\r\n        // if cover period of quote is less than 60 days.\r\n        if (coverPeriod <= 60) {\r\n            p1.closeCoverOraclise(cid, uint64(uint(coverPeriod).mul(1 days)));\r\n        }\r\n        uint coverNoteAmount = (coverDetails[2].mul(qd.tokensRetained())).div(100);\r\n        tc.mint(from, coverNoteAmount);\r\n        tf.lockCN(coverNoteAmount, coverPeriod, cid, from);\r\n        qd.addInTotalSumAssured(coverCurr, coverDetails[0]);\r\n        qd.addInTotalSumAssuredSC(scAddress, coverCurr, coverDetails[0]);\r\n\r\n\r\n        tf.pushStakerRewards(scAddress, coverDetails[2]);\r\n    }\r\n\r\n    /**\r\n     * @dev Makes a vover.\r\n     * @param from address of funder.\r\n     * @param scAddress Smart Contract Address\r\n     */  \r\n    function _verifyCoverDetails(\r\n        address payable from,\r\n        address scAddress,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        internal\r\n    {\r\n        require(coverDetails[3] > now);\r\n        require(!qd.timestampRepeated(coverDetails[4]));\r\n        qd.setTimestampRepeated(coverDetails[4]);\r\n        require(verifySign(coverDetails, coverPeriod, coverCurr, scAddress, _v, _r, _s));\r\n        _makeCover(from, scAddress, coverCurr, coverDetails, coverPeriod);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the Sum Assured Amount of all the quotation.\r\n     * @param _cid Cover id\r\n     * @param _amount that will get subtracted Current Sum Assured \r\n     * amount that comes under a quotation.\r\n     */ \r\n    function _removeSAFromCSA(uint _cid, uint _amount) internal checkPause {\r\n        address _add;\r\n        bytes4 coverCurr;\r\n        (, , _add, coverCurr, , ) = qd.getCoverDetailsByCoverID1(_cid);\r\n        qd.subFromTotalSumAssured(coverCurr, _amount);        \r\n        qd.subFromTotalSumAssuredSC(_add, coverCurr, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev to trigger the kyc process \r\n     * @param status is the kyc status\r\n     * @param _add is the address of member\r\n     */\r\n    function _kycTrigger(bool status, address _add) internal {\r\n\r\n        uint holdedCoverLen = qd.getUserHoldedCoverLength(_add).sub(1);\r\n        uint holdedCoverID = qd.getUserHoldedCoverByIndex(_add, holdedCoverLen);\r\n        address payable userAdd;\r\n        address scAddress;\r\n        bytes4 coverCurr;\r\n        uint16 coverPeriod;\r\n        uint[]  memory coverDetails = new uint[](4);\r\n        IERC20 erc20;\r\n\r\n        (, userAdd, coverDetails) = qd.getHoldedCoverDetailsByID2(holdedCoverID);\r\n        (, scAddress, coverCurr, coverPeriod) = qd.getHoldedCoverDetailsByID1(holdedCoverID);\r\n        require(qd.refundEligible(userAdd));\r\n        qd.setRefundEligible(userAdd, false);\r\n        require(qd.holdedCoverIDStatus(holdedCoverID) == uint(QuotationData.HCIDStatus.kycPending));\r\n        uint joinFee = td.joiningFee();\r\n        if (status) {\r\n            mr.payJoiningFee.value(joinFee)(userAdd);\r\n            if (coverDetails[3] > now) { \r\n                qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPass));\r\n                address poolAdd = ms.getLatestAddress(\"P1\");\r\n                if (coverCurr == \"BNB\") {\r\n                    p1.sendEther.value(coverDetails[1])();\r\n                } else {\r\n                    erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); //solhint-disable-line\r\n                    require(erc20.transfer(poolAdd, coverDetails[1]));\r\n                }\r\n                emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Passed\");               \r\n                _makeCover(userAdd, scAddress, coverCurr, coverDetails, coverPeriod);\r\n\r\n            } else {\r\n                qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycPassNoCover));\r\n                if (coverCurr == \"BNB\") {\r\n                    userAdd.transfer(coverDetails[1]);\r\n                } else {\r\n                    erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); //solhint-disable-line\r\n                    require(erc20.transfer(userAdd, coverDetails[1]));\r\n                }\r\n                emit RefundEvent(userAdd, status, holdedCoverID, \"Cover Failed\");\r\n            }\r\n        } else {\r\n            qd.setHoldedCoverIDStatus(holdedCoverID, uint(QuotationData.HCIDStatus.kycFailedOrRefunded));\r\n            uint totalRefund = joinFee;\r\n            if (coverCurr == \"BNB\") {\r\n                totalRefund = coverDetails[1].add(joinFee);\r\n            } else {\r\n                erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr)); //solhint-disable-line\r\n                require(erc20.transfer(userAdd, coverDetails[1]));\r\n            }\r\n            userAdd.transfer(totalRefund);\r\n            emit RefundEvent(userAdd, status, holdedCoverID, \"KYC Failed\");\r\n        }\r\n              \r\n    }\r\n}\r\n\r\ncontract Factory {\r\n    function getExchange(address token) public view returns (address);\r\n    function getToken(address exchange) public view returns (address);\r\n}\r\n\r\ncontract Exchange { \r\n    function getEthToTokenInputPrice(uint256 ethSold) public view returns(uint256);\r\n\r\n    function getTokenToEthInputPrice(uint256 tokensSold) public view returns(uint256);\r\n\r\n    function ethToTokenSwapInput(uint256 minTokens, uint256 deadline) public payable returns (uint256);\r\n\r\n    function ethToTokenTransferInput(uint256 minTokens, uint256 deadline, address recipient)\r\n        public payable returns (uint256);\r\n\r\n    function tokenToEthSwapInput(uint256 tokensSold, uint256 minEth, uint256 deadline)\r\n        public payable returns (uint256);\r\n\r\n    function tokenToEthTransferInput(uint256 tokensSold, uint256 minEth, uint256 deadline, address recipient) \r\n        public payable returns (uint256);\r\n\r\n    function tokenToTokenSwapInput(\r\n        uint256 tokensSold,\r\n        uint256 minTokensBought,\r\n        uint256 minEthBought,\r\n        uint256 deadline,\r\n        address tokenAddress\r\n    ) \r\n        public returns (uint256);\r\n\r\n    function tokenToTokenTransferInput(\r\n        uint256 tokensSold,\r\n        uint256 minTokensBought,\r\n        uint256 minEthBought,\r\n        uint256 deadline,\r\n        address recipient,\r\n        address tokenAddress\r\n    )\r\n        public returns (uint256);\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract Pool2 is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    MCR internal m1;\r\n    Pool1 internal p1;\r\n    PoolData internal pd;\r\n    Factory internal factory;\r\n    address public uniswapFactoryAddress;\r\n    uint internal constant DECIMAL1E18 = uint(10) ** 18;\r\n    bool internal locked;\r\n\r\n    constructor(address _uniswapFactoryAdd) public {\r\n       \r\n        uniswapFactoryAddress = _uniswapFactoryAdd;\r\n        factory = Factory(_uniswapFactoryAdd);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    event Liquidity(bytes16 typeOf, bytes16 functionName);\r\n\r\n    event Rebalancing(bytes4 iaCurr, uint tokenAmount);\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    /**\r\n     * @dev to change the uniswap factory address \r\n     * @param newFactoryAddress is the new factory address in concern\r\n     * @return the status of the concerned coverId\r\n     */\r\n    function changeUniswapFactoryAddress(address newFactoryAddress) external onlyInternal {\r\n        // require(ms.isOwner(msg.sender) || ms.checkIsAuthToGoverned(msg.sender));\r\n        uniswapFactoryAddress = newFactoryAddress;\r\n        factory = Factory(uniswapFactoryAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev On upgrade transfer all investment assets and ether to new Investment Pool\r\n     * @param newPoolAddress New Investment Assest Pool address\r\n     */\r\n    function upgradeInvestmentPool(address payable newPoolAddress) external onlyInternal noReentrancy {\r\n        uint len = pd.getInvestmentCurrencyLen();\r\n        for (uint64 i = 1; i < len; i++) {\r\n            bytes4 iaName = pd.getInvestmentCurrencyByIndex(i);\r\n            _upgradeInvestmentPool(iaName, newPoolAddress);\r\n        }\r\n\r\n        if (address(this).balance > 0) {\r\n            Pool2 newP2 = Pool2(newPoolAddress);\r\n            newP2.sendEther.value(address(this).balance)();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal Swap of assets between Capital \r\n     * and Investment Sub pool for excess or insufficient  \r\n     * liquidity conditions of a given currency.\r\n     */ \r\n    function internalLiquiditySwap(bytes4 curr) external onlyInternal noReentrancy {\r\n        uint caBalance;\r\n        uint baseMin;\r\n        uint varMin;\r\n        (, baseMin, varMin) = pd.getCurrencyAssetVarBase(curr);\r\n        caBalance = _getCurrencyAssetsBalance(curr);\r\n\r\n        if (caBalance > uint(baseMin).add(varMin).mul(2)) {\r\n            _internalExcessLiquiditySwap(curr, baseMin, varMin, caBalance);\r\n        } else if (caBalance < uint(baseMin).add(varMin)) {\r\n            _internalInsufficientLiquiditySwap(curr, baseMin, varMin, caBalance);\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Saves a given investment asset details. To be called daily.\r\n     * @param curr array of Investment asset name.\r\n     * @param rate array of investment asset exchange rate.\r\n     * @param date current date in yyyymmdd.\r\n     */ \r\n    function saveIADetails(bytes4[] calldata curr, uint64[] calldata rate, uint64 date, bool bit) \r\n    external checkPause noReentrancy {\r\n        bytes4 maxCurr;\r\n        bytes4 minCurr;\r\n        uint64 maxRate;\r\n        uint64 minRate;\r\n        //ONLY NOTARZIE ADDRESS CAN POST\r\n        require(pd.isnotarise(msg.sender));\r\n        (maxCurr, maxRate, minCurr, minRate) = _calculateIARank(curr, rate);\r\n        pd.saveIARankDetails(maxCurr, maxRate, minCurr, minRate, date);\r\n        pd.updatelastDate(date);\r\n        uint len = curr.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            pd.updateIAAvgRate(curr[i], rate[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev External Trade for excess or insufficient  \r\n     * liquidity conditions of a given currency.\r\n     */ \r\n    function externalLiquidityTrade() external onlyInternal {\r\n        \r\n        bool triggerTrade;\r\n        bytes4 curr;\r\n        bytes4 minIACurr;\r\n        bytes4 maxIACurr;\r\n        uint amount;\r\n        uint minIARate;\r\n        uint maxIARate;\r\n        uint baseMin;\r\n        uint varMin;\r\n        uint caBalance;\r\n\r\n\r\n        (maxIACurr, maxIARate, minIACurr, minIARate) = pd.getIARankDetailsByDate(pd.getLastDate());\r\n        uint len = pd.getAllCurrenciesLen();\r\n        for (uint64 i = 0; i < len; i++) {\r\n            curr = pd.getCurrenciesByIndex(i);\r\n            (, baseMin, varMin) = pd.getCurrencyAssetVarBase(curr);\r\n            caBalance = _getCurrencyAssetsBalance(curr);\r\n\r\n            if (caBalance > uint(baseMin).add(varMin).mul(2)) { //excess\r\n                amount = caBalance.sub(((uint(baseMin).add(varMin)).mul(3)).div(2)); //*10**18;\r\n                triggerTrade = _externalExcessLiquiditySwap(curr, minIACurr, amount);\r\n            } else if (caBalance < uint(baseMin).add(varMin)) { // insufficient\r\n                amount = (((uint(baseMin).add(varMin)).mul(3)).div(2)).sub(caBalance);\r\n                triggerTrade = _externalInsufficientLiquiditySwap(curr, maxIACurr, amount);\r\n            }\r\n\r\n            if (triggerTrade) {\r\n                p1.triggerExternalLiquidityTrade();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n    }\r\n\r\n    function sendEther() public payable {\r\n        \r\n    }\r\n\r\n    /** \r\n     * @dev Gets currency asset balance for a given currency name.\r\n     */   \r\n    function _getCurrencyAssetsBalance(bytes4 _curr) public view returns(uint caBalance) {\r\n        if (_curr == \"BNB\") {\r\n            caBalance = address(p1).balance;\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr));\r\n            caBalance = erc20.balanceOf(address(p1));\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Transfers ERC20 investment asset from this Pool to another Pool.\r\n     */ \r\n    function _transferInvestmentAsset(\r\n        bytes4 _curr,\r\n        address _transferTo,\r\n        uint _amount\r\n    ) \r\n        internal\r\n    {\r\n        if (_curr == \"BNB\") {\r\n            if (_amount > address(this).balance)\r\n                _amount = address(this).balance;\r\n            p1.sendEther.value(_amount)();\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\r\n            if (_amount > erc20.balanceOf(address(this)))\r\n                _amount = erc20.balanceOf(address(this));\r\n            require(erc20.transfer(_transferTo, _amount));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to perform rebalancing \r\n     * @param iaCurr is the investment asset currency\r\n     * @param iaRate is the investment asset rate\r\n     */\r\n    function _rebalancingLiquidityTrading(\r\n        bytes4 iaCurr,\r\n        uint64 iaRate\r\n    ) \r\n        internal\r\n        checkPause\r\n    {\r\n        uint amountToSell;\r\n        uint totalRiskBal = pd.getLastVfull();\r\n        uint intermediaryEth;\r\n        uint ethVol = pd.ethVolumeLimit();\r\n\r\n        totalRiskBal = (totalRiskBal.mul(100000)).div(DECIMAL1E18);\r\n        Exchange exchange;\r\n        if (totalRiskBal > 0) {\r\n            amountToSell = ((totalRiskBal.mul(2).mul(\r\n                iaRate)).mul(pd.variationPercX100())).div(100 * 100 * 100000);\r\n            amountToSell = (amountToSell.mul(\r\n                10**uint(pd.getInvestmentAssetDecimals(iaCurr)))).div(100); // amount of asset to sell\r\n\r\n            if (iaCurr != \"BNB\" && _checkTradeConditions(iaCurr, iaRate, totalRiskBal)) { \r\n                exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(iaCurr)));\r\n                intermediaryEth = exchange.getTokenToEthInputPrice(amountToSell);\r\n                if (intermediaryEth > (address(exchange).balance.mul(ethVol)).div(100)) { \r\n                    intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\r\n                    amountToSell = (exchange.getEthToTokenInputPrice(intermediaryEth).mul(995)).div(1000);\r\n                }\r\n                IERC20 erc20;\r\n                erc20 = IERC20(pd.getCurrencyAssetAddress(iaCurr));\r\n                erc20.approve(address(exchange), amountToSell);\r\n                exchange.tokenToEthSwapInput(amountToSell, (exchange.getTokenToEthInputPrice(\r\n                    amountToSell).mul(995)).div(1000), pd.uniswapDeadline().add(now));\r\n            } else if (iaCurr == \"BNB\" && _checkTradeConditions(iaCurr, iaRate, totalRiskBal)) {\r\n\r\n                _transferInvestmentAsset(iaCurr, ms.getLatestAddress(\"P1\"), amountToSell);\r\n            }\r\n            emit Rebalancing(iaCurr, amountToSell); \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether trading is required for a  \r\n     * given investment asset at a given exchange rate.\r\n     */ \r\n    function _checkTradeConditions(\r\n        bytes4 curr,\r\n        uint64 iaRate,\r\n        uint totalRiskBal\r\n    )\r\n        internal\r\n        view\r\n        returns(bool check)\r\n    {\r\n        if (iaRate > 0) {\r\n            uint iaBalance =  _getInvestmentAssetBalance(curr).div(DECIMAL1E18);\r\n            if (iaBalance > 0 && totalRiskBal > 0) {\r\n                uint iaMax;\r\n                uint iaMin;\r\n                uint checkNumber;\r\n                uint z;\r\n                (iaMin, iaMax) = pd.getInvestmentAssetHoldingPerc(curr);\r\n                z = pd.variationPercX100();\r\n                checkNumber = (iaBalance.mul(100 * 100000)).div(totalRiskBal.mul(iaRate));\r\n                if ((checkNumber > ((totalRiskBal.mul(iaMax.add(z))).mul(100000)).div(100)) ||\r\n                    (checkNumber < ((totalRiskBal.mul(iaMin.sub(z))).mul(100000)).div(100)))\r\n                    check = true; //eligibleIA\r\n            }\r\n        }\r\n    }    \r\n\r\n    /** \r\n     * @dev Gets the investment asset rank.\r\n     */ \r\n    function _getIARank(\r\n        bytes4 curr,\r\n        uint64 rateX100,\r\n        uint totalRiskPoolBalance\r\n    ) \r\n        internal\r\n        view\r\n        returns (int rhsh, int rhsl) //internal function\r\n    {\r\n\r\n        uint currentIAmaxHolding;\r\n        uint currentIAminHolding;\r\n        uint iaBalance = _getInvestmentAssetBalance(curr);\r\n        (currentIAminHolding, currentIAmaxHolding) = pd.getInvestmentAssetHoldingPerc(curr);\r\n        \r\n        if (rateX100 > 0) {\r\n            uint rhsf;\r\n            rhsf = (iaBalance.mul(1000000)).div(totalRiskPoolBalance.mul(rateX100));\r\n            rhsh = int(rhsf - currentIAmaxHolding);\r\n            rhsl = int(rhsf - currentIAminHolding);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Calculates the investment asset rank.\r\n     */  \r\n    function _calculateIARank(\r\n        bytes4[] memory curr,\r\n        uint64[] memory rate\r\n    )\r\n        internal\r\n        view\r\n        returns(\r\n            bytes4 maxCurr,\r\n            uint64 maxRate,\r\n            bytes4 minCurr,\r\n            uint64 minRate\r\n        )  \r\n    {\r\n        int max = 0;\r\n        int min = -1;\r\n        int rhsh;\r\n        int rhsl;\r\n        uint totalRiskPoolBalance;\r\n        (totalRiskPoolBalance, ) = m1.calVtpAndMCRtp();\r\n        uint len = curr.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            rhsl = 0;\r\n            rhsh = 0;\r\n            if (pd.getInvestmentAssetStatus(curr[i])) {\r\n                (rhsh, rhsl) = _getIARank(curr[i], rate[i], totalRiskPoolBalance);\r\n                if (rhsh > max || i == 0) {\r\n                    max = rhsh;\r\n                    maxCurr = curr[i];\r\n                    maxRate = rate[i];\r\n                }\r\n                if (rhsl < min || rhsl == 0 || i == 0) {\r\n                    min = rhsl;\r\n                    minCurr = curr[i];\r\n                    minRate = rate[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to get balance of an investment asset \r\n     * @param _curr is the investment asset in concern\r\n     * @return the balance\r\n     */\r\n    function _getInvestmentAssetBalance(bytes4 _curr) internal view returns (uint balance) {\r\n        if (_curr == \"BNB\") {\r\n            balance = address(this).balance;\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\r\n            balance = erc20.balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates Excess liquidity trading order for a given currency and a given balance.\r\n     */  \r\n    function _internalExcessLiquiditySwap(bytes4 _curr, uint _baseMin, uint _varMin, uint _caBalance) internal {\r\n        // require(ms.isInternal(msg.sender) || md.isnotarise(msg.sender));\r\n        bytes4 minIACurr;\r\n        // uint amount;\r\n        \r\n        (, , minIACurr, ) = pd.getIARankDetailsByDate(pd.getLastDate());\r\n        if (_curr == minIACurr) {\r\n            // amount = _caBalance.sub(((_baseMin.add(_varMin)).mul(3)).div(2)); //*10**18;\r\n            p1.transferCurrencyAsset(_curr, _caBalance.sub(((_baseMin.add(_varMin)).mul(3)).div(2)));\r\n        } else {\r\n            p1.triggerExternalLiquidityTrade();\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev insufficient liquidity swap  \r\n     * for a given currency and a given balance.\r\n     */ \r\n    function _internalInsufficientLiquiditySwap(bytes4 _curr, uint _baseMin, uint _varMin, uint _caBalance) internal {\r\n        \r\n        bytes4 maxIACurr;\r\n        uint amount;\r\n        \r\n        (maxIACurr, , , ) = pd.getIARankDetailsByDate(pd.getLastDate());\r\n        \r\n        if (_curr == maxIACurr) {\r\n            amount = (((_baseMin.add(_varMin)).mul(3)).div(2)).sub(_caBalance);\r\n            _transferInvestmentAsset(_curr, ms.getLatestAddress(\"P1\"), amount);\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(maxIACurr));\r\n            if ((maxIACurr == \"BNB\" && address(this).balance > 0) || \r\n            (maxIACurr != \"BNB\" && erc20.balanceOf(address(this)) > 0))\r\n                p1.triggerExternalLiquidityTrade();\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates External excess liquidity trading  \r\n     * order for a given currency and a given balance.\r\n     * @param curr Currency Asset to Sell\r\n     * @param minIACurr Investment Asset to Buy  \r\n     * @param amount Amount of Currency Asset to Sell\r\n     */  \r\n    function _externalExcessLiquiditySwap(\r\n        bytes4 curr,\r\n        bytes4 minIACurr,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool trigger)\r\n    {\r\n        uint intermediaryEth;\r\n        Exchange exchange;\r\n        IERC20 erc20;\r\n        uint ethVol = pd.ethVolumeLimit();\r\n        if (curr == minIACurr) {\r\n            p1.transferCurrencyAsset(curr, amount);\r\n        } else if (curr == \"BNB\" && minIACurr != \"BNB\") {\r\n            \r\n            exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(minIACurr)));\r\n            if (amount > (address(exchange).balance.mul(ethVol)).div(100)) { // 4% BNB volume limit \r\n                amount = (address(exchange).balance.mul(ethVol)).div(100);\r\n                trigger = true;\r\n            }\r\n            p1.transferCurrencyAsset(curr, amount);\r\n            exchange.ethToTokenSwapInput.value(amount)\r\n            (exchange.getEthToTokenInputPrice(amount).mul(995).div(1000), pd.uniswapDeadline().add(now));    \r\n        } else if (curr != \"BNB\" && minIACurr == \"BNB\") {\r\n            exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(curr));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n\r\n            if (intermediaryEth > (address(exchange).balance.mul(ethVol)).div(100)) { \r\n                intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\r\n                amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n                trigger = true;\r\n            }\r\n            p1.transferCurrencyAsset(curr, amount);\r\n            // erc20.decreaseAllowance(address(exchange), erc20.allowance(address(this), address(exchange)));\r\n            erc20.approve(address(exchange), amount);\r\n            \r\n            exchange.tokenToEthSwapInput(amount, (\r\n                intermediaryEth.mul(995)).div(1000), pd.uniswapDeadline().add(now));   \r\n        } else {\r\n            \r\n            exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n\r\n            if (intermediaryEth > (address(exchange).balance.mul(ethVol)).div(100)) { \r\n                intermediaryEth = (address(exchange).balance.mul(ethVol)).div(100);\r\n                amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                trigger = true;\r\n            }\r\n            \r\n            Exchange tmp = Exchange(factory.getExchange(\r\n                pd.getInvestmentAssetAddress(minIACurr))); // minIACurr exchange\r\n\r\n            if (intermediaryEth > address(tmp).balance.mul(ethVol).div(100)) { \r\n                intermediaryEth = address(tmp).balance.mul(ethVol).div(100);\r\n                amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                trigger = true;   \r\n            }\r\n            p1.transferCurrencyAsset(curr, amount);\r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(curr));\r\n            erc20.approve(address(exchange), amount);\r\n            \r\n            exchange.tokenToTokenSwapInput(amount, (tmp.getEthToTokenInputPrice(\r\n                intermediaryEth).mul(995)).div(1000), (intermediaryEth.mul(995)).div(1000), \r\n                    pd.uniswapDeadline().add(now), pd.getInvestmentAssetAddress(minIACurr));\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev insufficient liquidity swap  \r\n     * for a given currency and a given balance.\r\n     * @param curr Currency Asset to buy\r\n     * @param maxIACurr Investment Asset to sell\r\n     * @param amount Amount of Investment Asset to sell\r\n     */ \r\n    function _externalInsufficientLiquiditySwap(\r\n        bytes4 curr,\r\n        bytes4 maxIACurr,\r\n        uint256 amount\r\n    ) \r\n        internal\r\n        returns (bool trigger)\r\n    {   \r\n\r\n        Exchange exchange;\r\n        IERC20 erc20;\r\n        uint intermediaryEth;\r\n        // uint ethVol = pd.ethVolumeLimit();\r\n        if (curr == maxIACurr) {\r\n            _transferInvestmentAsset(curr, ms.getLatestAddress(\"P1\"), amount);\r\n        } else if (curr == \"BNB\" && maxIACurr != \"BNB\") { \r\n            exchange = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(maxIACurr)));\r\n            intermediaryEth = exchange.getEthToTokenInputPrice(amount);\r\n\r\n\r\n            if (amount > (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100)) { \r\n                amount = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\r\n                // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                intermediaryEth = exchange.getEthToTokenInputPrice(amount);\r\n                trigger = true;\r\n            }\r\n            \r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(maxIACurr));\r\n            if (intermediaryEth > erc20.balanceOf(address(this))) {\r\n                intermediaryEth = erc20.balanceOf(address(this));\r\n            }\r\n            // erc20.decreaseAllowance(address(exchange), erc20.allowance(address(this), address(exchange)));\r\n            erc20.approve(address(exchange), intermediaryEth);\r\n            exchange.tokenToEthTransferInput(intermediaryEth, (\r\n                exchange.getTokenToEthInputPrice(intermediaryEth).mul(995)).div(1000), \r\n                pd.uniswapDeadline().add(now), address(p1)); \r\n\r\n        } else if (curr != \"BNB\" && maxIACurr == \"BNB\") {\r\n            exchange = Exchange(factory.getExchange(pd.getCurrencyAssetAddress(curr)));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n            if (intermediaryEth > address(this).balance)\r\n                intermediaryEth = address(this).balance;\r\n            if (intermediaryEth > (address(exchange).balance.mul\r\n            (pd.ethVolumeLimit())).div(100)) { // 4% BNB volume limit \r\n                intermediaryEth = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\r\n                trigger = true;\r\n            }\r\n            exchange.ethToTokenTransferInput.value(intermediaryEth)((exchange.getEthToTokenInputPrice(\r\n                intermediaryEth).mul(995)).div(1000), pd.uniswapDeadline().add(now), address(p1));   \r\n        } else {\r\n            address currAdd = pd.getCurrencyAssetAddress(curr);\r\n            exchange = Exchange(factory.getExchange(currAdd));\r\n            intermediaryEth = exchange.getTokenToEthInputPrice(amount);\r\n            if (intermediaryEth > (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100)) { \r\n                intermediaryEth = (address(exchange).balance.mul(pd.ethVolumeLimit())).div(100);\r\n                trigger = true;\r\n            }\r\n            Exchange tmp = Exchange(factory.getExchange(pd.getInvestmentAssetAddress(maxIACurr)));\r\n\r\n            if (intermediaryEth > address(tmp).balance.mul(pd.ethVolumeLimit()).div(100)) { \r\n                intermediaryEth = address(tmp).balance.mul(pd.ethVolumeLimit()).div(100);\r\n                // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n                trigger = true;\r\n            }\r\n\r\n            uint maxIAToSell = tmp.getEthToTokenInputPrice(intermediaryEth);\r\n\r\n            erc20 = IERC20(pd.getInvestmentAssetAddress(maxIACurr));\r\n            uint maxIABal = erc20.balanceOf(address(this));\r\n            if (maxIAToSell > maxIABal) {\r\n                maxIAToSell = maxIABal;\r\n                intermediaryEth = tmp.getTokenToEthInputPrice(maxIAToSell);\r\n                // amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n            }\r\n            amount = exchange.getEthToTokenInputPrice(intermediaryEth);\r\n            erc20.approve(address(tmp), maxIAToSell);\r\n            tmp.tokenToTokenTransferInput(maxIAToSell, (\r\n                amount.mul(995)).div(1000), (\r\n                    intermediaryEth), pd.uniswapDeadline().add(now), address(p1), currAdd);\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Transfers ERC20 investment asset from this Pool to another Pool.\r\n     */ \r\n    function _upgradeInvestmentPool(\r\n        bytes4 _curr,\r\n        address _newPoolAddress\r\n    ) \r\n        internal\r\n    {\r\n        IERC20 erc20 = IERC20(pd.getInvestmentAssetAddress(_curr));\r\n        if (erc20.balanceOf(address(this)) > 0)\r\n            require(erc20.transfer(_newPoolAddress, erc20.balanceOf(address(this))));\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract Pool1 is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    Quotation internal q2;\r\n    SOTEToken internal tk;\r\n    TokenController internal tc;\r\n    TokenFunctions internal tf;\r\n    Pool2 internal p2;\r\n    PoolData internal pd;\r\n    MCR internal m1;\r\n    Claims public c1;\r\n    TokenData internal td;\r\n    bool internal locked;\r\n\r\n    uint internal constant DECIMAL1E18 = uint(10) ** 18;\r\n    // uint internal constant PRICE_STEP = uint(1000) * DECIMAL1E18;\r\n\r\n    event Apiresult(address indexed sender, string msg, bytes32 myid);\r\n    event Payout(address indexed to, uint coverId, uint tokens);\r\n\r\n    modifier noReentrancy() {\r\n        require(!locked, \"Reentrant call.\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    function () external payable {} //solhint-disable-line\r\n\r\n    /**\r\n     * @dev Pays out the sum assured in case a claim is accepted\r\n     * @param coverid Cover Id.\r\n     * @param claimid Claim Id.\r\n     * @return succ true if payout is successful, false otherwise. \r\n     */ \r\n    function sendClaimPayout(\r\n        uint coverid,\r\n        uint claimid,\r\n        uint sumAssured,\r\n        address payable coverHolder,\r\n        bytes4 coverCurr\r\n    )\r\n        external\r\n        onlyInternal\r\n        noReentrancy\r\n        returns(bool succ)\r\n    {\r\n        \r\n        uint sa = sumAssured.div(DECIMAL1E18);\r\n        bool check;\r\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\r\n\r\n        //Payout\r\n        if (coverCurr == \"BNB\" && address(this).balance >= sumAssured) {\r\n            // check = _transferCurrencyAsset(coverCurr, coverHolder, sumAssured);\r\n            coverHolder.transfer(sumAssured);\r\n            check = true;\r\n        } else if (coverCurr == \"DAI\" && erc20.balanceOf(address(this)) >= sumAssured) {\r\n            erc20.transfer(coverHolder, sumAssured);\r\n            check = true;\r\n        }\r\n        \r\n        if (check == true) {\r\n            q2.removeSAFromCSA(coverid, sa);\r\n            pd.changeCurrencyAssetVarMin(coverCurr, \r\n                pd.getCurrencyAssetVarMin(coverCurr).sub(sumAssured));\r\n            emit Payout(coverHolder, coverid, sumAssured);\r\n            succ = true;\r\n        } else {\r\n            c1.setClaimStatus(claimid, 12);\r\n        }\r\n        _triggerExternalLiquidityTrade();\r\n        // p2.internalLiquiditySwap(coverCurr);\r\n\r\n        tf.burnStakerLockedToken(coverid, coverCurr, sumAssured);\r\n    }\r\n\r\n    /**\r\n     * @dev to trigger external liquidity trade\r\n     */\r\n    function triggerExternalLiquidityTrade() external onlyInternal {\r\n        _triggerExternalLiquidityTrade();\r\n    }\r\n\r\n    ///@dev Oraclize call to close emergency pause.\r\n    function closeEmergencyPause(uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery();\r\n        _saveApiDetails(myid, \"EP\", 0);\r\n    }\r\n\r\n    /// @dev Calls the Oraclize Query to close a given Claim after a given period of time.\r\n    /// @param id Claim Id to be closed\r\n    /// @param time Time (in seconds) after which Claims assessment voting needs to be closed\r\n    function closeClaimsOraclise(uint id, uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery();\r\n        _saveApiDetails(myid, \"CLA\", id);\r\n    }\r\n\r\n    /// @dev Calls Oraclize Query to expire a given Cover after a given period of time.\r\n    /// @param id Quote Id to be expired\r\n    /// @param time Time (in seconds) after which the cover should be expired\r\n    function closeCoverOraclise(uint id, uint64 time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery();\r\n        _saveApiDetails(myid, \"COV\", id);\r\n    }\r\n\r\n    /// @dev Calls the Oraclize Query to initiate MCR calculation.\r\n    /// @param time Time (in milliseconds) after which the next MCR calculation should be initiated\r\n    function mcrOraclise(uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery();\r\n        _saveApiDetails(myid, \"MCR\", 0);\r\n    }\r\n\r\n    /// @dev Calls the Oraclize Query in case MCR calculation fails.\r\n    /// @param time Time (in seconds) after which the next MCR calculation should be initiated\r\n    function mcrOracliseFail(uint id, uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery();\r\n        _saveApiDetails(myid, \"MCRF\", id);\r\n    }\r\n\r\n    /// @dev Oraclize call to update investment asset rates.\r\n    function saveIADetailsOracalise(uint time) external onlyInternal {\r\n        bytes32 myid = _oraclizeQuery();\r\n        _saveApiDetails(myid, \"IARB\", 0);\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfers all assest (i.e BNB balance, Currency Assest) from old Pool to new Pool\r\n     * @param newPoolAddress Address of the new Pool\r\n     */\r\n    function upgradeCapitalPool(address payable newPoolAddress) external noReentrancy onlyInternal {\r\n        for (uint64 i = 1; i < pd.getAllCurrenciesLen(); i++) {\r\n            bytes4 caName = pd.getCurrenciesByIndex(i);\r\n            _upgradeCapitalPool(caName, newPoolAddress);\r\n        }\r\n        if (address(this).balance > 0) {\r\n            Pool1 newP1 = Pool1(newPoolAddress);\r\n            newP1.sendEther.value(address(this).balance)();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public {\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n        tk = SOTEToken(ms.tokenAddress());\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        q2 = Quotation(ms.getLatestAddress(\"QT\"));\r\n        p2 = Pool2(ms.getLatestAddress(\"P2\"));\r\n        c1 = Claims(ms.getLatestAddress(\"CL\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n    }\r\n\r\n    function sendEther() public payable {\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev transfers currency asset to an address\r\n     * @param curr is the currency of currency asset to transfer\r\n     * @param amount is amount of currency asset to transfer\r\n     * @return boolean to represent success or failure\r\n     */\r\n    function transferCurrencyAsset(\r\n        bytes4 curr,\r\n        uint amount\r\n    )\r\n        public\r\n        onlyInternal\r\n        noReentrancy\r\n        returns(bool)\r\n    {\r\n    \r\n        return _transferCurrencyAsset(curr, amount);\r\n    } \r\n\r\n    /// @dev Handles callback of external oracle query.\r\n    function __callback(bytes32 myid, string memory result) public {\r\n        result; //silence compiler warning\r\n        // owner will be removed from production build\r\n        ms.delegateCallBack(myid);\r\n    }\r\n\r\n    /// @dev Enables user to purchase cover with funding in BNB.\r\n    /// @param smartCAdd Smart Contract Address\r\n    function makeCoverBegin(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    )\r\n        public\r\n        isMember\r\n        checkPause\r\n        payable\r\n    {\r\n        require(msg.value == coverDetails[1]);\r\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n    }\r\n\r\n    /**\r\n     * @dev Enables user to purchase cover via currency asset eg DAI\r\n     */ \r\n    function makeCoverUsingCA(\r\n        address smartCAdd,\r\n        bytes4 coverCurr,\r\n        uint[] memory coverDetails,\r\n        uint16 coverPeriod,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) \r\n        public\r\n        isMember\r\n        checkPause\r\n    {\r\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\r\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\r\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\r\n    }\r\n\r\n    /// @dev Enables user to purchase SOTE at the current token price.\r\n    function buyToken() public payable isMember checkPause returns(bool success) {\r\n        require(msg.value > 0);\r\n        uint tokenPurchased = _getToken(address(this).balance, msg.value);\r\n        tc.mint(msg.sender, tokenPurchased);\r\n        success = true;\r\n    }\r\n\r\n    /// @dev Sends a given amount of Ether to a given address.\r\n    /// @param amount amount (in wei) to send.\r\n    /// @param _add Receiver's address.\r\n    /// @return succ True if transfer is a success, otherwise False.\r\n    function transferEther(uint amount, address payable _add) public noReentrancy checkPause returns(bool succ) {\r\n        require(ms.checkIsAuthToGoverned(msg.sender), \"Not authorized to Govern\");\r\n        succ = _add.send(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows selling of SOTE for ether.\r\n     * Seller first needs to give this contract allowance to\r\n     * transfer/burn tokens in the SOTEToken contract\r\n     * @param  _amount Amount of SOTE to sell\r\n     * @return success returns true on successfull sale\r\n     */\r\n    function sellSOTETokens(uint _amount) public isMember noReentrancy checkPause returns(bool success) {\r\n        require(tk.balanceOf(msg.sender) >= _amount, \"Not enough balance\");\r\n        require(!tf.isLockedForMemberVote(msg.sender), \"Member voted\");\r\n        require(_amount <= m1.getMaxSellTokens(), \"exceeds maximum token sell limit\");\r\n        uint sellingPrice = _getWei(_amount);\r\n        tc.burnFrom(msg.sender, _amount);\r\n        msg.sender.transfer(sellingPrice);\r\n        success = true;\r\n    }\r\n\r\n    /**\r\n     * @dev gives the investment asset balance\r\n     * @return investment asset balance\r\n     */\r\n    function getInvestmentAssetBalance() public view returns (uint balance) {\r\n        IERC20 erc20;\r\n        uint currTokens;\r\n        for (uint i = 1; i < pd.getInvestmentCurrencyLen(); i++) {\r\n            bytes4 currency = pd.getInvestmentCurrencyByIndex(i);\r\n            erc20 = IERC20(pd.getInvestmentAssetAddress(currency));\r\n            currTokens = erc20.balanceOf(address(p2));\r\n            if (pd.getIAAvgRate(currency) > 0)\r\n                balance = balance.add((currTokens.mul(100)).div(pd.getIAAvgRate(currency)));\r\n        }\r\n\r\n        balance = balance.add(address(p2).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of wei a seller will get for selling SOTE\r\n     * @param amount Amount of SOTE to sell\r\n     * @return weiToPay Amount of wei the seller will get\r\n     */\r\n    function getWei(uint amount) public view returns(uint weiToPay) {\r\n        return _getWei(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of token a buyer will get for corresponding wei\r\n     * @param weiPaid Amount of wei \r\n     * @return tokenToGet Amount of tokens the buyer will get\r\n     */\r\n    function getToken(uint weiPaid) public view returns(uint tokenToGet) {\r\n        return _getToken((address(this).balance).add(weiPaid), weiPaid);\r\n    }\r\n\r\n    /**\r\n     * @dev to trigger external liquidity trade\r\n     */\r\n    function _triggerExternalLiquidityTrade() internal {\r\n        if (now > pd.lastLiquidityTradeTrigger().add(pd.liquidityTradeCallbackTime())) {\r\n            pd.setLastLiquidityTradeTrigger();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of wei a seller will get for selling SOTE\r\n     * @param _amount Amount of SOTE to sell\r\n     * @return weiToPay Amount of wei the seller will get\r\n     */\r\n    function _getWei(uint _amount) internal view returns(uint weiToPay) {\r\n        uint tokenPrice;\r\n        uint weiPaid;\r\n        uint tokenSupply = tk.totalSupply();\r\n        uint vtp;\r\n        uint mcrFullperc;\r\n        uint vFull;\r\n        uint mcrtp;\r\n        (mcrFullperc, , vFull, ) = pd.getLastMCR();\r\n        (vtp, ) = m1.calVtpAndMCRtp();\r\n\r\n        while (_amount > 0) {\r\n            mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\r\n            tokenPrice = m1.calculateStepTokenPrice(\"BNB\", mcrtp);\r\n            tokenPrice = (tokenPrice.mul(975)).div(1000); //97.5%\r\n            if (_amount <= td.priceStep().mul(DECIMAL1E18)) {\r\n                weiToPay = weiToPay.add((tokenPrice.mul(_amount)).div(DECIMAL1E18));\r\n                break;\r\n            } else {\r\n                _amount = _amount.sub(td.priceStep().mul(DECIMAL1E18));\r\n                tokenSupply = tokenSupply.sub(td.priceStep().mul(DECIMAL1E18));\r\n                weiPaid = (tokenPrice.mul(td.priceStep().mul(DECIMAL1E18))).div(DECIMAL1E18);\r\n                vtp = vtp.sub(weiPaid);\r\n                weiToPay = weiToPay.add(weiPaid);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives the token\r\n     * @param _poolBalance is the pool balance\r\n     * @param _weiPaid is the amount paid in wei\r\n     * @return the token to get\r\n     */\r\n    function _getToken(uint _poolBalance, uint _weiPaid) internal view returns(uint tokenToGet) {\r\n        uint tokenPrice;\r\n        uint superWeiLeft = (_weiPaid).mul(DECIMAL1E18);\r\n        uint tempTokens;\r\n        uint superWeiSpent;\r\n        uint tokenSupply = tk.totalSupply();\r\n        uint vtp;\r\n        uint mcrFullperc;   \r\n        uint vFull;\r\n        uint mcrtp;\r\n        (mcrFullperc, , vFull, ) = pd.getLastMCR();\r\n        (vtp, ) = m1.calculateVtpAndMCRtp((_poolBalance).sub(_weiPaid));\r\n\r\n        require(m1.calculateTokenPrice(\"BNB\") > 0, \"Token price can not be zero\");\r\n        while (superWeiLeft > 0) {\r\n            mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\r\n            tokenPrice = m1.calculateStepTokenPrice(\"BNB\", mcrtp);            \r\n            tempTokens = superWeiLeft.div(tokenPrice);\r\n            if (tempTokens <= td.priceStep().mul(DECIMAL1E18)) {\r\n                tokenToGet = tokenToGet.add(tempTokens);\r\n                break;\r\n            } else {\r\n                tokenToGet = tokenToGet.add(td.priceStep().mul(DECIMAL1E18));\r\n                tokenSupply = tokenSupply.add(td.priceStep().mul(DECIMAL1E18));\r\n                superWeiSpent = td.priceStep().mul(DECIMAL1E18).mul(tokenPrice);\r\n                superWeiLeft = superWeiLeft.sub(superWeiSpent);\r\n                vtp = vtp.add((td.priceStep().mul(DECIMAL1E18).mul(tokenPrice)).div(DECIMAL1E18));\r\n            }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Save the details of the Oraclize API.\r\n     * @param myid Id return by the oraclize query.\r\n     * @param _typeof type of the query for which oraclize call is made.\r\n     * @param id ID of the proposal, quote, cover etc. for which oraclize call is made.\r\n     */ \r\n    function _saveApiDetails(bytes32 myid, bytes4 _typeof, uint id) internal {\r\n        pd.saveApiDetails(myid, _typeof, id);\r\n        pd.addInAllApiCall(myid);\r\n    }\r\n\r\n    /**\r\n     * @dev transfers currency asset\r\n     * @param _curr is currency of asset to transfer\r\n     * @param _amount is the amount to be transferred\r\n     * @return boolean representing the success of transfer\r\n     */\r\n    function _transferCurrencyAsset(bytes4 _curr, uint _amount) internal returns(bool succ) {\r\n        if (_curr == \"BNB\") {\r\n            if (address(this).balance < _amount)\r\n                _amount = address(this).balance;\r\n            p2.sendEther.value(_amount)();\r\n            succ = true;\r\n        } else {\r\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr)); //solhint-disable-line\r\n            if (erc20.balanceOf(address(this)) < _amount) \r\n                _amount = erc20.balanceOf(address(this));\r\n            require(erc20.transfer(address(p2), _amount)); \r\n            succ = true;\r\n            \r\n        }\r\n    } \r\n\r\n    /** \r\n     * @dev Transfers ERC20 Currency asset from this Pool to another Pool on upgrade.\r\n     */ \r\n    function _upgradeCapitalPool(\r\n        bytes4 _curr,\r\n        address _newPoolAddress\r\n    ) \r\n        internal\r\n    {\r\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(_curr));\r\n        if (erc20.balanceOf(address(this)) > 0)\r\n            require(erc20.transfer(_newPoolAddress, erc20.balanceOf(address(this))));\r\n    }\r\n    \r\n    // step for ApiId\r\n    uint256 public reqc;\r\n\r\n    /**\r\n     * @dev oraclize query\r\n     * @return id of oraclize query\r\n     */\r\n    function _oraclizeQuery() \r\n        internal\r\n        returns (bytes32 id)\r\n    {\r\n        id = keccak256(abi.encodePacked(this, msg.sender, reqc));\r\n        reqc++;\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract MCR is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    Pool1 internal p1;\r\n    PoolData internal pd;\r\n    SOTEToken internal tk;\r\n    QuotationData internal qd;\r\n    MemberRoles internal mr;\r\n    TokenData internal td;\r\n    ProposalCategory internal proposalCategory;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n    uint private constant DECIMAL1E05 = uint(10) ** 5;\r\n    uint private constant DECIMAL1E19 = uint(10) ** 19;\r\n    uint private constant minCapFactor = uint(10) ** 21;\r\n\r\n    uint public variableMincap;\r\n    uint public dynamicMincapThresholdx100 = 13000;\r\n    uint public dynamicMincapIncrementx100 = 100;\r\n\r\n    event MCREvent(\r\n        uint indexed date,\r\n        uint blockNumber,\r\n        bytes4[] allCurr,\r\n        uint[] allCurrRates,\r\n        uint mcrEtherx100,\r\n        uint mcrPercx100,\r\n        uint vFull\r\n    );\r\n\r\n    /** \r\n     * @dev Adds new MCR data.\r\n     * @param mcrP  Minimum Capital Requirement in percentage.\r\n     * @param vF Pool1 fund value in Ether used in the last full daily calculation of the Capital model.\r\n     * @param onlyDate  Date(yyyymmdd) at which MCR details are getting added.\r\n     */ \r\n    function addMCRData(\r\n        uint mcrP,\r\n        uint mcrE,\r\n        uint vF,\r\n        bytes4[] calldata curr,\r\n        uint[] calldata _threeDayAvg,\r\n        uint64 onlyDate\r\n    )\r\n        external\r\n        checkPause\r\n    {\r\n        // require(proposalCategory.constructorCheck());\r\n        require(pd.isnotarise(msg.sender));\r\n        if (mr.launched() && pd.capReached() != 1) {\r\n            \r\n            if (mcrP >= 10000)\r\n                pd.setCapReached(1);  \r\n\r\n        }\r\n        uint len = pd.getMCRDataLength();\r\n        _addMCRData(len, onlyDate, curr, mcrE, mcrP, vF, _threeDayAvg);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds MCR Data for last failed attempt.\r\n     */  \r\n    function addLastMCRData(uint64 date) external checkPause  onlyInternal {\r\n        uint64 lastdate = uint64(pd.getLastMCRDate());\r\n        uint64 failedDate = uint64(date);\r\n        if (failedDate >= lastdate) {\r\n            uint mcrP;\r\n            uint mcrE;\r\n            uint vF;\r\n            (mcrP, mcrE, vF, ) = pd.getLastMCR();\r\n            uint len = pd.getAllCurrenciesLen();\r\n            pd.pushMCRData(mcrP, mcrE, vF, date);\r\n            for (uint j = 0; j < len; j++) {\r\n                bytes4 currName = pd.getCurrenciesByIndex(j);\r\n                pd.updateCAAvgRate(currName, pd.getCAAvgRate(currName));\r\n            }\r\n\r\n            emit MCREvent(date, block.number, new bytes4[](0), new uint[](0), mcrE, mcrP, vF);\r\n            // Oraclize call for next MCR calculation\r\n            _callOracliseForMCR();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        tk = SOTEToken(ms.tokenAddress());\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        // proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n    }\r\n\r\n    /** \r\n     * @dev Gets total sum assured(in BNB).\r\n     * @return amount of sum assured\r\n     */  \r\n    function getAllSumAssurance() public view returns(uint amount) {\r\n        uint len = pd.getAllCurrenciesLen();\r\n        for (uint i = 0; i < len; i++) {\r\n            bytes4 currName = pd.getCurrenciesByIndex(i);\r\n            if (currName == \"BNB\") {\r\n                amount = amount.add(qd.getTotalSumAssured(currName));\r\n            } else {\r\n                if (pd.getCAAvgRate(currName) > 0)\r\n                    amount = amount.add((qd.getTotalSumAssured(currName).mul(100)).div(pd.getCAAvgRate(currName)));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates V(Tp) and MCR%(Tp), i.e, Pool Fund Value in Ether \r\n     * and MCR% used in the Token Price Calculation.\r\n     * @return vtp  Pool Fund Value in Ether used for the Token Price Model\r\n     * @return mcrtp MCR% used in the Token Price Model. \r\n     */ \r\n    function _calVtpAndMCRtp(uint poolBalance) public view returns(uint vtp, uint mcrtp) {\r\n        vtp = 0;\r\n        IERC20 erc20;\r\n        uint currTokens = 0;\r\n        uint i;\r\n        for (i = 1; i < pd.getAllCurrenciesLen(); i++) {\r\n            bytes4 currency = pd.getCurrenciesByIndex(i);\r\n            erc20 = IERC20(pd.getCurrencyAssetAddress(currency));\r\n            currTokens = erc20.balanceOf(address(p1));\r\n            if (pd.getCAAvgRate(currency) > 0)\r\n                vtp = vtp.add((currTokens.mul(100)).div(pd.getCAAvgRate(currency)));\r\n        }\r\n\r\n        vtp = vtp.add(poolBalance).add(p1.getInvestmentAssetBalance());\r\n        uint mcrFullperc;\r\n        uint vFull;\r\n        (mcrFullperc, , vFull, ) = pd.getLastMCR();\r\n        if (vFull > 0) {\r\n            mcrtp = (mcrFullperc.mul(vtp)).div(vFull);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the Token Price of SOTE in a given currency.\r\n     * @param curr Currency name.\r\n     \r\n     */\r\n    function calculateStepTokenPrice(\r\n        bytes4 curr,\r\n        uint mcrtp\r\n    ) \r\n        public\r\n        view\r\n        onlyInternal\r\n        returns(uint tokenPrice)\r\n    {\r\n        return _calculateTokenPrice(curr, mcrtp);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the Token Price of SOTE in a given currency \r\n     * with provided token supply for dynamic token price calculation\r\n     * @param curr Currency name.\r\n     */ \r\n    function calculateTokenPrice (bytes4 curr) public view returns(uint tokenPrice) {\r\n        uint mcrtp;\r\n        (, mcrtp) = _calVtpAndMCRtp(address(p1).balance); \r\n        return _calculateTokenPrice(curr, mcrtp);\r\n    }\r\n    \r\n    function calVtpAndMCRtp() public view returns(uint vtp, uint mcrtp) {\r\n        return _calVtpAndMCRtp(address(p1).balance);\r\n    }\r\n\r\n    function calculateVtpAndMCRtp(uint poolBalance) public view returns(uint vtp, uint mcrtp) {\r\n        return _calVtpAndMCRtp(poolBalance);\r\n    }\r\n\r\n    function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) public view returns(uint lowerThreshold, uint upperThreshold)\r\n    {\r\n        minCap = (minCap.mul(minCapFactor)).add(variableMincap);\r\n        uint lower = 0;\r\n        if (vtp >= vF) {\r\n                upperThreshold = vtp.mul(120).mul(100).div((minCap));     //Max Threshold = [MAX(Vtp, Vfull) x 120] / mcrMinCap\r\n            } else {\r\n                upperThreshold = vF.mul(120).mul(100).div((minCap));\r\n            }\r\n\r\n            if (vtp > 0) {\r\n                lower = totalSA.mul(DECIMAL1E18).mul(pd.shockParameter()).div(100);\r\n                if(lower < minCap.mul(11).div(10))\r\n                    lower = minCap.mul(11).div(10);\r\n            }\r\n            if (lower > 0) {                                       //Min Threshold = [Vtp / MAX(TotalActiveSA x ShockParameter, mcrMinCap x 1.1)] x 100\r\n                lowerThreshold = vtp.mul(100).mul(100).div(lower);\r\n            }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets max numbers of tokens that can be sold at the moment.\r\n     */ \r\n    function getMaxSellTokens() public view returns(uint maxTokens) {\r\n        uint baseMin = pd.getCurrencyAssetBaseMin(\"BNB\");\r\n        uint maxTokensAccPoolBal;\r\n        if (address(p1).balance > baseMin.mul(50).div(100)) {\r\n            maxTokensAccPoolBal = address(p1).balance.sub(\r\n            (baseMin.mul(50)).div(100));        \r\n        }\r\n        maxTokensAccPoolBal = (maxTokensAccPoolBal.mul(DECIMAL1E18)).div(\r\n            (calculateTokenPrice(\"BNB\").mul(975)).div(1000));\r\n        uint lastMCRPerc = pd.getLastMCRPerc();\r\n        if (lastMCRPerc > 10000)\r\n            maxTokens = (((uint(lastMCRPerc).sub(10000)).mul(2000)).mul(DECIMAL1E18)).div(10000);\r\n        if (maxTokens > maxTokensAccPoolBal)\r\n            maxTokens = maxTokensAccPoolBal;     \r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n        codeVal = code;\r\n        if (code == \"DMCT\") {\r\n            val = dynamicMincapThresholdx100;\r\n\r\n        } else if (code == \"DMCI\") {\r\n\r\n            val = dynamicMincapIncrementx100;\r\n\r\n        }\r\n            \r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"DMCT\") {\r\n           dynamicMincapThresholdx100 = val;\r\n\r\n        } else if (code == \"DMCI\") {\r\n\r\n            dynamicMincapIncrementx100 = val;\r\n\r\n        }\r\n         else {\r\n            revert(\"Invalid param code\");\r\n        }\r\n            \r\n    }\r\n\r\n    /** \r\n     * @dev Calls oraclize query to calculate MCR details after 24 hours.\r\n     */ \r\n    function _callOracliseForMCR() internal {\r\n        p1.mcrOraclise(pd.mcrTime());\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the Token Price of SOTE in a given currency \r\n     * with provided token supply for dynamic token price calculation\r\n     * @param _curr Currency name.  \r\n     * @return tokenPrice Token price.\r\n     */ \r\n    function _calculateTokenPrice(\r\n        bytes4 _curr,\r\n        uint mcrtp\r\n    )\r\n        internal\r\n        view\r\n        returns(uint tokenPrice)\r\n    {\r\n        uint getA;\r\n        uint getC;\r\n        uint getCAAvgRate;\r\n        uint tokenExponentValue = td.tokenExponent();\r\n        // uint max = (mcrtp.mul(mcrtp).mul(mcrtp).mul(mcrtp));\r\n        uint max = mcrtp ** tokenExponentValue;\r\n        uint dividingFactor = tokenExponentValue.mul(4); \r\n        (getA, getC, getCAAvgRate) = pd.getTokenPriceDetails(_curr);\r\n        uint mcrEth = pd.getLastMCREther();\r\n        getC = getC.mul(DECIMAL1E18);\r\n        tokenPrice = (mcrEth.mul(DECIMAL1E18).mul(max).div(getC)).div(10 ** dividingFactor);\r\n        tokenPrice = tokenPrice.add(getA.mul(DECIMAL1E18).div(DECIMAL1E05));\r\n        tokenPrice = tokenPrice.mul(getCAAvgRate * 10); \r\n        tokenPrice = (tokenPrice).div(10**3);\r\n    } \r\n    \r\n    /**\r\n     * @dev Adds MCR Data. Checks if MCR is within valid \r\n     * thresholds in order to rule out any incorrect calculations \r\n     */  \r\n    function _addMCRData(\r\n        uint len,\r\n        uint64 newMCRDate,\r\n        bytes4[] memory curr,\r\n        uint mcrE,\r\n        uint mcrP,\r\n        uint vF,\r\n        uint[] memory _threeDayAvg\r\n    ) \r\n        internal\r\n    {\r\n        uint vtp = 0;\r\n        uint lowerThreshold = 0;\r\n        uint upperThreshold = 0;\r\n        if (len > 1) {\r\n            (vtp, ) = _calVtpAndMCRtp(address(p1).balance);\r\n            (lowerThreshold, upperThreshold) = getThresholdValues(vtp, vF, getAllSumAssurance(), pd.minCap());\r\n\r\n        }\r\n        if(mcrP > dynamicMincapThresholdx100)\r\n            variableMincap =  (variableMincap.mul(dynamicMincapIncrementx100.add(10000)).add(minCapFactor.mul(pd.minCap().mul(dynamicMincapIncrementx100)))).div(10000);\r\n\r\n\r\n        // Explanation for above formula :- \r\n        // actual formula -> variableMinCap =  variableMinCap + (variableMinCap+minCap)*dynamicMincapIncrement/100\r\n        // Implemented formula is simplified form of actual formula.\r\n        // Let consider above formula as b = b + (a+b)*c/100\r\n        // here, dynamicMincapIncrement is in x100 format. \r\n        // so b+(a+b)*cx100/10000 can be written as => (10000.b + b.cx100 + a.cx100)/10000.\r\n        // It can further simplify to (b.(10000+cx100) + a.cx100)/10000.\r\n        if (len == 1 || (mcrP) >= lowerThreshold \r\n            && (mcrP) <= upperThreshold) {\r\n            vtp = pd.getLastMCRDate(); // due to stack to deep error,we are reusing already declared variable\r\n            pd.pushMCRData(mcrP, mcrE, vF, newMCRDate);\r\n            for (uint i = 0; i < curr.length; i++) {\r\n                pd.updateCAAvgRate(curr[i], _threeDayAvg[i]);\r\n            }\r\n            emit MCREvent(newMCRDate, block.number, curr, _threeDayAvg, mcrE, mcrP, vF);\r\n            // Oraclize call for next MCR calculation\r\n            if (vtp < newMCRDate) {\r\n                _callOracliseForMCR();\r\n            }\r\n        } else {\r\n            p1.mcrOracliseFail(newMCRDate, pd.mcrFailTime());\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/* Copyright (C) 2017 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract Claims is Iupgradable {\r\n    using SafeMath for uint;\r\n\r\n    \r\n    TokenFunctions internal tf;\r\n    SOTEToken internal tk;\r\n    TokenController internal tc;\r\n    ClaimsReward internal cr;\r\n    Pool1 internal p1;\r\n    ClaimsData internal cd;\r\n    TokenData internal td;\r\n    PoolData internal pd;\r\n    Pool2 internal p2;\r\n    QuotationData internal qd;\r\n    MCR internal m1;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n    \r\n    /**\r\n     * @dev Sets the status of claim using claim id.\r\n     * @param claimId claim id.\r\n     * @param stat status to be set.\r\n     */ \r\n    function setClaimStatus(uint claimId, uint stat) external onlyInternal {\r\n        _setClaimStatus(claimId, stat);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets claim details of claim id = pending claim start + given index\r\n     */ \r\n    function getClaimFromNewStart(\r\n        uint index\r\n    )\r\n        external \r\n        view \r\n        returns (\r\n            uint coverId,\r\n            uint claimId,\r\n            int8 voteCA,\r\n            int8 voteMV,\r\n            uint statusnumber\r\n        ) \r\n    {\r\n        (coverId, claimId, voteCA, voteMV, statusnumber) = cd.getClaimFromNewStart(index, msg.sender);\r\n        // status = rewardStatus[statusnumber].claimStatusDesc;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a claim submitted by the calling user, at a given index\r\n     */\r\n    function getUserClaimByIndex(\r\n        uint index\r\n    )\r\n        external\r\n        view \r\n        returns(\r\n            uint status,\r\n            uint coverId,\r\n            uint claimId\r\n        )\r\n    {\r\n        uint statusno;\r\n        (statusno, coverId, claimId) = cd.getUserClaimByIndex(index, msg.sender);\r\n        status = statusno;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets details of a given claim id.\r\n     * @param _claimId Claim Id.\r\n     * @return status Current status of claim id\r\n     * @return finalVerdict Decision made on the claim, 1 -> acceptance, -1 -> denial\r\n     * @return claimOwner Address through which claim is submitted\r\n     * @return coverId Coverid associated with the claim id\r\n     */\r\n    function getClaimbyIndex(uint _claimId) external view returns (\r\n        uint claimId,\r\n        uint status,\r\n        int8 finalVerdict,\r\n        address claimOwner,\r\n        uint coverId\r\n    )\r\n    {\r\n        uint stat;\r\n        claimId = _claimId;\r\n        (, coverId, finalVerdict, stat, , ) = cd.getClaim(_claimId);\r\n        claimOwner = qd.getCoverMemberAddress(coverId);\r\n        status = stat;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates total amount that has been used to assess a claim.\r\n     * Computaion:Adds acceptCA(tokens used for voting in favor of a claim)\r\n     * denyCA(tokens used for voting against a claim) *  current token price.\r\n     * @param claimId Claim Id.\r\n     * @param member Member type 0 -> Claim Assessors, else members.\r\n     * @return tokens Total Amount used in Claims assessment.\r\n     */ \r\n    function getCATokens(uint claimId, uint member) external view returns(uint tokens) {\r\n        uint coverId;\r\n        (, coverId) = cd.getClaimCoverId(claimId);\r\n        bytes4 curr = qd.getCurrencyOfCover(coverId);\r\n        uint tokenx1e18 = m1.calculateTokenPrice(curr);\r\n        uint accept;\r\n        uint deny;\r\n        if (member == 0) {\r\n            (, accept, deny) = cd.getClaimsTokenCA(claimId);\r\n        } else {\r\n            (, accept, deny) = cd.getClaimsTokenMV(claimId);\r\n        }\r\n        tokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18); // amount (not in tokens)\r\n    }\r\n\r\n    /**\r\n     * Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        tk = SOTEToken(ms.tokenAddress());\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        p2 = Pool2(ms.getLatestAddress(\"P2\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n        cd = ClaimsData(ms.getLatestAddress(\"CD\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        m1 = MCR(ms.getLatestAddress(\"MC\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the pending claim start variable,\r\n     * the lowest claim id with a pending decision/payout.\r\n     */ \r\n    function changePendingClaimStart() public onlyInternal {\r\n\r\n        uint origstat;\r\n        uint state12Count;\r\n        uint pendingClaimStart = cd.pendingClaimStart();\r\n        uint actualClaimLength = cd.actualClaimLength();\r\n        for (uint i = pendingClaimStart; i < actualClaimLength; i++) {\r\n            (, , , origstat, , state12Count) = cd.getClaim(i);\r\n\r\n            if (origstat > 5 && ((origstat != 12) || (origstat == 12 && state12Count >= 60)))\r\n                cd.setpendingClaimStart(i);\r\n            else\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for a given cover note.\r\n     * Adds claim to queue incase of emergency pause else directly submits the claim.\r\n     * @param coverId Cover Id.\r\n     */ \r\n    function submitClaim(uint coverId) public {\r\n        address qadd = qd.getCoverMemberAddress(coverId);\r\n        require(qadd == msg.sender);\r\n        uint8 cStatus;\r\n        (, cStatus, , , ) = qd.getCoverDetailsByCoverID2(coverId);\r\n        require(cStatus != uint8(QuotationData.CoverStatus.ClaimSubmitted), \"Claim already submitted\");\r\n        require(cStatus != uint8(QuotationData.CoverStatus.CoverExpired), \"Cover already expired\");\r\n        if (ms.isPause() == false) {\r\n            _addClaim(coverId, now, qadd);\r\n        } else {\r\n            cd.setClaimAtEmergencyPause(coverId, now, false);\r\n            qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.Requested));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits the Claims queued once the emergency pause is switched off.\r\n     */\r\n    function submitClaimAfterEPOff() public onlyInternal {\r\n        uint lengthOfClaimSubmittedAtEP = cd.getLengthOfClaimSubmittedAtEP();\r\n        uint firstClaimIndexToSubmitAfterEP = cd.getFirstClaimIndexToSubmitAfterEP();\r\n        uint coverId;\r\n        uint dateUpd;\r\n        bool submit;\r\n        address qadd;\r\n        for (uint i = firstClaimIndexToSubmitAfterEP; i < lengthOfClaimSubmittedAtEP; i++) {\r\n            (coverId, dateUpd, submit) = cd.getClaimOfEmergencyPauseByIndex(i);\r\n            require(submit == false);\r\n            qadd = qd.getCoverMemberAddress(coverId);\r\n            _addClaim(coverId, dateUpd, qadd);\r\n            cd.setClaimSubmittedAtEPTrue(i, true);\r\n        }\r\n        cd.setFirstClaimIndexToSubmitAfterEP(lengthOfClaimSubmittedAtEP);\r\n    }\r\n\r\n    /**\r\n     * @dev Castes vote for members who have tokens locked under Claims Assessment\r\n     * @param claimId  claim id.\r\n     * @param verdict 1 for Accept,-1 for Deny.\r\n     */ \r\n    function submitCAVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\r\n        require(checkVoteClosing(claimId) != 1); \r\n        require(cd.userClaimVotePausedOn(msg.sender).add(cd.pauseDaysCA()) < now);  \r\n        uint tokens = tc.tokensLockedAtTime(msg.sender, \"CLA\", now.add(cd.claimDepositTime()));\r\n        require(tokens > 0);\r\n        uint stat;\r\n        (, stat) = cd.getClaimStatusNumber(claimId);\r\n        require(stat == 0);\r\n        require(cd.getUserClaimVoteCA(msg.sender, claimId) == 0);\r\n        td.bookCATokens(msg.sender);\r\n        cd.addVote(msg.sender, tokens, claimId, verdict);\r\n        cd.callVoteEvent(msg.sender, claimId, \"CAV\", tokens, now, verdict);\r\n        uint voteLength = cd.getAllVoteLength();\r\n        cd.addClaimVoteCA(claimId, voteLength);\r\n        cd.setUserClaimVoteCA(msg.sender, claimId, voteLength);\r\n        cd.setClaimTokensCA(claimId, verdict, tokens);\r\n        tc.extendLockOf(msg.sender, \"CLA\", td.lockCADays());\r\n        int close = checkVoteClosing(claimId);\r\n        if (close == 1) {\r\n            cr.changeClaimStatus(claimId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a member vote for assessing a claim.\r\n     * Tokens other than those locked under Claims\r\n     * Assessment can be used to cast a vote for a given claim id.\r\n     * @param claimId Selected claim id.\r\n     * @param verdict 1 for Accept,-1 for Deny.\r\n     */ \r\n    function submitMemberVote(uint claimId, int8 verdict) public isMemberAndcheckPause {\r\n        require(checkVoteClosing(claimId) != 1);\r\n        uint stat;\r\n        uint tokens = tc.totalBalanceOf(msg.sender);\r\n        (, stat) = cd.getClaimStatusNumber(claimId);\r\n        require(stat >= 1 && stat <= 5);\r\n        require(cd.getUserClaimVoteMember(msg.sender, claimId) == 0);\r\n        cd.addVote(msg.sender, tokens, claimId, verdict);\r\n        cd.callVoteEvent(msg.sender, claimId, \"MV\", tokens, now, verdict);\r\n        tc.lockForMemberVote(msg.sender, td.lockMVDays());\r\n        uint voteLength = cd.getAllVoteLength();\r\n        cd.addClaimVotemember(claimId, voteLength);\r\n        cd.setUserClaimVoteMember(msg.sender, claimId, voteLength);\r\n        cd.setClaimTokensMV(claimId, verdict, tokens);\r\n        int close = checkVoteClosing(claimId);\r\n        if (close == 1) {\r\n            cr.changeClaimStatus(claimId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Pause Voting of All Pending Claims when Emergency Pause Start.\r\n    */ \r\n    function pauseAllPendingClaimsVoting() public onlyInternal {\r\n        uint firstIndex = cd.pendingClaimStart();\r\n        uint actualClaimLength = cd.actualClaimLength();\r\n        for (uint i = firstIndex; i < actualClaimLength; i++) {\r\n            if (checkVoteClosing(i) == 0) {\r\n                uint dateUpd = cd.getClaimDateUpd(i);\r\n                cd.setPendingClaimDetails(i, (dateUpd.add(cd.maxVotingTime())).sub(now), false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Resume the voting phase of all Claims paused due to an emergency pause.\r\n     */\r\n    function startAllPendingClaimsVoting() public onlyInternal {\r\n        uint firstIndx = cd.getFirstClaimIndexToStartVotingAfterEP();\r\n        uint i;\r\n        uint lengthOfClaimVotingPause = cd.getLengthOfClaimVotingPause();\r\n        for (i = firstIndx; i < lengthOfClaimVotingPause; i++) {\r\n            uint pendingTime;\r\n            uint claimID;\r\n            (claimID, pendingTime, ) = cd.getPendingClaimDetailsByIndex(i);\r\n            uint pTime = (now.sub(cd.maxVotingTime())).add(pendingTime);\r\n            cd.setClaimdateUpd(claimID, pTime);\r\n            cd.setPendingClaimVoteStatus(i, true);\r\n            uint coverid;\r\n            (, coverid) = cd.getClaimCoverId(claimID);\r\n            address qadd = qd.getCoverMemberAddress(coverid);\r\n            tf.extendCNEPOff(qadd, coverid, pendingTime.add(cd.claimDepositTime()));\r\n            p1.closeClaimsOraclise(claimID, uint64(pTime));\r\n        }\r\n        cd.setFirstClaimIndexToStartVotingAfterEP(i);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if voting of a claim should be closed or not.\r\n     * @param claimId Claim Id.\r\n     * @return close 1 -> voting should be closed, 0 -> if voting should not be closed,\r\n     * -1 -> voting has already been closed.\r\n     */ \r\n    function checkVoteClosing(uint claimId) public view returns(int8 close) {\r\n        close = 0;\r\n        uint status;\r\n        (, status) = cd.getClaimStatusNumber(claimId);\r\n        uint dateUpd = cd.getClaimDateUpd(claimId);\r\n        if (status == 12 && dateUpd.add(cd.payoutRetryTime()) < now) {\r\n            if (cd.getClaimState12Count(claimId) < 60)\r\n                close = 1;\r\n        } \r\n        \r\n        if (status > 5 && status != 12) {\r\n            close = -1;\r\n        }  else if (status != 12 && dateUpd.add(cd.maxVotingTime()) <= now) {\r\n            close = 1;\r\n        } else if (status != 12 && dateUpd.add(cd.minVotingTime()) >= now) {\r\n            close = 0;\r\n        } else if (status == 0 || (status >= 1 && status <= 5)) {\r\n            close = _checkVoteClosingFinal(claimId, status);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Checks if voting of a claim should be closed or not.\r\n     * Internally called by checkVoteClosing method\r\n     * for Claims whose status number is 0 or status number lie between 2 and 6.\r\n     * @param claimId Claim Id.\r\n     * @param status Current status of claim.\r\n     * @return close 1 if voting should be closed,0 in case voting should not be closed,\r\n     * -1 if voting has already been closed.\r\n     */\r\n    function _checkVoteClosingFinal(uint claimId, uint status) internal view returns(int8 close) {\r\n        close = 0;\r\n        uint coverId;\r\n        (, coverId) = cd.getClaimCoverId(claimId);\r\n        bytes4 curr = qd.getCurrencyOfCover(coverId);\r\n        uint tokenx1e18 = m1.calculateTokenPrice(curr);\r\n        uint accept;\r\n        uint deny;\r\n        (, accept, deny) = cd.getClaimsTokenCA(claimId);\r\n        uint caTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\r\n        (, accept, deny) = cd.getClaimsTokenMV(claimId);\r\n        uint mvTokens = ((accept.add(deny)).mul(tokenx1e18)).div(DECIMAL1E18);\r\n        uint sumassured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\r\n        if (status == 0 && caTokens >= sumassured.mul(10)) {\r\n            close = 1;\r\n        } else if (status >= 1 && status <= 5 && mvTokens >= sumassured.mul(10)) {\r\n            close = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the status of an existing claim id, based on current \r\n     * status and current conditions of the system\r\n     * @param claimId Claim Id.\r\n     * @param stat status number.  \r\n     */\r\n    function _setClaimStatus(uint claimId, uint stat) internal {\r\n\r\n        uint origstat;\r\n        uint state12Count;\r\n        uint dateUpd;\r\n        uint coverId;\r\n        (, coverId, , origstat, dateUpd, state12Count) = cd.getClaim(claimId);\r\n        (, origstat) = cd.getClaimStatusNumber(claimId);\r\n\r\n        if (stat == 12 && origstat == 12) {\r\n            cd.updateState12Count(claimId, 1);\r\n        }\r\n        cd.setClaimStatus(claimId, stat);\r\n\r\n        if (state12Count >= 60 && stat == 12) {\r\n            cd.setClaimStatus(claimId, 13);\r\n            qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimDenied));\r\n        }\r\n        uint time = now;\r\n        cd.setClaimdateUpd(claimId, time);\r\n\r\n        if (stat >= 2 && stat <= 5) {\r\n            p1.closeClaimsOraclise(claimId, cd.maxVotingTime());\r\n        }\r\n\r\n        if (stat == 12 && (dateUpd.add(cd.payoutRetryTime()) <= now) && (state12Count < 60)) {\r\n            p1.closeClaimsOraclise(claimId, cd.payoutRetryTime());\r\n        } else if (stat == 12 && (dateUpd.add(cd.payoutRetryTime()) > now) && (state12Count < 60)) {\r\n            uint64 timeLeft = uint64((dateUpd.add(cd.payoutRetryTime())).sub(now));\r\n            p1.closeClaimsOraclise(claimId, timeLeft);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a claim for a given cover note.\r\n     * Set deposits flag against cover.\r\n     */\r\n    function _addClaim(uint coverId, uint time, address add) internal {\r\n        tf.depositCN(coverId);\r\n        uint len = cd.actualClaimLength();\r\n        cd.addClaim(len, coverId, add, now);\r\n        cd.callClaimEvent(coverId, add, len, time);\r\n        qd.changeCoverStatusNo(coverId, uint8(QuotationData.CoverStatus.ClaimSubmitted));\r\n        bytes4 curr = qd.getCurrencyOfCover(coverId);\r\n        uint sumAssured = qd.getCoverSumAssured(coverId).mul(DECIMAL1E18);\r\n        pd.changeCurrencyAssetVarMin(curr, pd.getCurrencyAssetVarMin(curr).add(sumAssured));\r\n        p2.internalLiquiditySwap(curr);\r\n        p1.closeClaimsOraclise(len, cd.maxVotingTime());\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2020 Soteria.fund\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n//Claims Reward Contract contains the functions for calculating number of tokens\r\n// that will get rewarded, unlocked or burned depending upon the status of claim.\r\ncontract ClaimsReward is Iupgradable {\r\n     using SafeMath for uint;\r\n\r\n    SOTEToken internal tk;\r\n    TokenController internal tc;\r\n    TokenFunctions internal tf;\r\n    TokenData internal td;\r\n    QuotationData internal qd;\r\n    Claims internal c1;\r\n    ClaimsData internal cd;\r\n    Pool1 internal p1;\r\n    Pool2 internal p2;\r\n    PoolData internal pd;\r\n    Governance internal gv;\r\n    IPooledStaking internal pooledStaking;\r\n\r\n    uint private constant DECIMAL1E18 = uint(10) ** 18;\r\n\r\n    function changeDependentContractAddress() public onlyInternal {\r\n        c1 = Claims(ms.getLatestAddress(\"CL\"));\r\n        cd = ClaimsData(ms.getLatestAddress(\"CD\"));\r\n        tk = SOTEToken(ms.tokenAddress());\r\n        tc = TokenController(ms.getLatestAddress(\"TC\"));\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        p1 = Pool1(ms.getLatestAddress(\"P1\"));\r\n        p2 = Pool2(ms.getLatestAddress(\"P2\"));\r\n        pd = PoolData(ms.getLatestAddress(\"PD\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        gv = Governance(ms.getLatestAddress(\"GV\"));\r\n        pooledStaking = IPooledStaking(ms.getLatestAddress(\"PS\"));\r\n    }\r\n\r\n    /// @dev Decides the next course of action for a given claim.\r\n    function changeClaimStatus(uint claimid) public checkPause onlyInternal {\r\n\r\n        uint coverid;\r\n        (, coverid) = cd.getClaimCoverId(claimid);\r\n\r\n        uint status;\r\n        (, status) = cd.getClaimStatusNumber(claimid);\r\n\r\n        // when current status is \"Pending-Claim Assessor Vote\"\r\n        if (status == 0) {\r\n            _changeClaimStatusCA(claimid, coverid, status);\r\n        } else if (status >= 1 && status <= 5) {\r\n            _changeClaimStatusMV(claimid, coverid, status);\r\n        } else if (status == 12) { // when current status is \"Claim Accepted Payout Pending\"\r\n\r\n            uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n            address payable coverHolder = qd.getCoverMemberAddress(coverid);\r\n            bytes4 coverCurrency = qd.getCurrencyOfCover(coverid);\r\n            bool success = p1.sendClaimPayout(coverid, claimid, sumAssured, coverHolder, coverCurrency);\r\n\r\n            if (success) {\r\n                tf.burnStakedTokens(coverid, coverCurrency, sumAssured);\r\n                c1.setClaimStatus(claimid, 14);\r\n            }\r\n        }\r\n\r\n        c1.changePendingClaimStart();\r\n    }\r\n\r\n    /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\r\n    /// @param check 1 -> CA vote, else member vote\r\n    /// @param voteid vote id for which reward has to be Calculated\r\n    /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\r\n    /// @return tokenCalculated reward to be given for vote id\r\n    /// @return lastClaimedCheck true if final verdict is still pending for that voteid\r\n    /// @return tokens number of tokens locked under that voteid\r\n    /// @return perc percentage of reward to be given.\r\n    function getRewardToBeGiven(\r\n        uint check,\r\n        uint voteid,\r\n        uint flag\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint tokenCalculated,\r\n            bool lastClaimedCheck,\r\n            uint tokens,\r\n            uint perc\r\n        )\r\n\r\n    {\r\n        uint claimId;\r\n        int8 verdict;\r\n        bool claimed;\r\n        uint tokensToBeDist;\r\n        uint totalTokens;\r\n        (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\r\n        lastClaimedCheck = false;\r\n        int8 claimVerdict = cd.getFinalVerdict(claimId);\r\n        if (claimVerdict == 0) {\r\n            lastClaimedCheck = true;\r\n        }\r\n\r\n        if (claimVerdict == verdict && (claimed == false || flag == 1)) {\r\n\r\n            if (check == 1) {\r\n                (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\r\n            } else {\r\n                (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\r\n            }\r\n\r\n            if (perc > 0) {\r\n                if (check == 1) {\r\n                    if (verdict == 1) {\r\n                        (, totalTokens, ) = cd.getClaimsTokenCA(claimId);\r\n                    } else {\r\n                        (, , totalTokens) = cd.getClaimsTokenCA(claimId);\r\n                    }\r\n                } else {\r\n                    if (verdict == 1) {\r\n                        (, totalTokens, ) = cd.getClaimsTokenMV(claimId);\r\n                    }else {\r\n                        (, , totalTokens) = cd.getClaimsTokenMV(claimId);\r\n                    }\r\n                }\r\n                tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\r\n    function upgrade(address _newAdd) public onlyInternal {\r\n        uint amount = tk.balanceOf(address(this));\r\n        if (amount > 0) {\r\n            require(tk.transfer(_newAdd, amount));\r\n        }\r\n\r\n    }\r\n\r\n    /// @dev Total reward in token due for claim by a user.\r\n    /// @return total total number of tokens\r\n    function getRewardToBeDistributedByUser(address _add) public view returns(uint total) {\r\n        uint lengthVote = cd.getVoteAddressCALength(_add);\r\n        uint lastIndexCA;\r\n        uint lastIndexMV;\r\n        uint tokenForVoteId;\r\n        uint voteId;\r\n        (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\r\n\r\n        for (uint i = lastIndexCA; i < lengthVote; i++) {\r\n            voteId = cd.getVoteAddressCA(_add, i);\r\n            (tokenForVoteId, , , ) = getRewardToBeGiven(1, voteId, 0);\r\n            total = total.add(tokenForVoteId);\r\n        }\r\n\r\n        lengthVote = cd.getVoteAddressMemberLength(_add);\r\n\r\n        for (uint j = lastIndexMV; j < lengthVote; j++) {\r\n            voteId = cd.getVoteAddressMember(_add, j);\r\n            (tokenForVoteId, , , ) = getRewardToBeGiven(0, voteId, 0);\r\n            total = total.add(tokenForVoteId);\r\n        }\r\n        return (total);\r\n    }\r\n\r\n    /// @dev Gets reward amount and claiming status for a given claim id.\r\n    /// @return reward amount of tokens to user.\r\n    /// @return claimed true if already claimed false if yet to be claimed.\r\n    function getRewardAndClaimedStatus(uint check, uint claimId) public view returns(uint reward, bool claimed) {\r\n        uint voteId;\r\n        uint claimid;\r\n        uint lengthVote;\r\n\r\n        if (check == 1) {\r\n            lengthVote = cd.getVoteAddressCALength(msg.sender);\r\n            for (uint i = 0; i < lengthVote; i++) {\r\n                voteId = cd.getVoteAddressCA(msg.sender, i);\r\n                (, claimid, , claimed) = cd.getVoteDetails(voteId);\r\n                if (claimid == claimId) { break; }\r\n            }\r\n        } else {\r\n            lengthVote = cd.getVoteAddressMemberLength(msg.sender);\r\n            for (uint j = 0; j < lengthVote; j++) {\r\n                voteId = cd.getVoteAddressMember(msg.sender, j);\r\n                (, claimid, , claimed) = cd.getVoteDetails(voteId);\r\n                if (claimid == claimId) { break; }\r\n            }\r\n        }\r\n        (reward, , , ) = getRewardToBeGiven(check, voteId, 1);\r\n\r\n    }\r\n    \r\n    function claimPendingReward(uint records) public isMemberAndcheckPause {\r\n        _claimRewardToBeDistributed(records);\r\n        pooledStaking.withdrawReward(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to get pending rewards of a particular user address.\r\n     * @param _add user address.\r\n     * @return total reward amount of the user\r\n     */\r\n    function getPendingRewardOfUser(address _add) public view returns(uint) {\r\n        uint caReward = getRewardToBeDistributedByUser(_add);\r\n        uint pooledStakingReward = pooledStaking.stakerReward(_add);\r\n        return caReward.add(pooledStakingReward);\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\r\n     * Claim assesment, Risk assesment, Governance rewards\r\n     */\r\n    function claimAllPendingReward(uint records) public isMemberAndcheckPause {\r\n        _claimRewardToBeDistributed(records);\r\n        pooledStaking.withdrawReward(msg.sender);\r\n        uint governanceRewards = gv.claimReward(msg.sender, records);\r\n        if (governanceRewards > 0) {\r\n            require(tk.transfer(msg.sender, governanceRewards));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to get pending rewards of a particular user address.\r\n     * @param _add user address.\r\n     * @return total reward amount of the user\r\n     */\r\n    function getAllPendingRewardOfUser(address _add) public view returns(uint) {\r\n        uint caReward = getRewardToBeDistributedByUser(_add);\r\n        uint pooledStakingReward = pooledStaking.stakerReward(_add);\r\n        uint governanceReward = gv.getPendingReward(_add);\r\n        return caReward.add(pooledStakingReward).add(governanceReward);\r\n    }\r\n\r\n    /// @dev Rewards/Punishes users who  participated in Claims assessment.\r\n    //    Unlocking and burning of the tokens will also depend upon the status of claim.\r\n    /// @param claimid Claim Id.\r\n    function _rewardAgainstClaim(uint claimid, uint coverid, uint sumAssured, uint status) internal {\r\n        uint premiumSOTE = qd.getCoverPremiumSOTE(coverid);\r\n        bytes4 curr = qd.getCurrencyOfCover(coverid);\r\n        uint distributableTokens = premiumSOTE.mul(cd.claimRewardPerc()).div(100);//  20% of premium\r\n\r\n        uint percCA;\r\n        uint percMV;\r\n\r\n        (percCA, percMV) = cd.getRewardStatus(status);\r\n        cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\r\n        if (percCA > 0 || percMV > 0) {\r\n            tc.mint(address(this), distributableTokens);\r\n        }\r\n\r\n        if (status == 6 || status == 9 || status == 11) {\r\n            cd.changeFinalVerdict(claimid, -1);\r\n            td.setDepositCN(coverid, false); // Unset flag\r\n            tf.burnDepositCN(coverid); // burn Deposited CN\r\n\r\n            pd.changeCurrencyAssetVarMin(curr, pd.getCurrencyAssetVarMin(curr).sub(sumAssured));\r\n            p2.internalLiquiditySwap(curr);\r\n\r\n        } else if (status == 7 || status == 8 || status == 10) {\r\n            cd.changeFinalVerdict(claimid, 1);\r\n            td.setDepositCN(coverid, false); // Unset flag\r\n            tf.unlockCN(coverid);\r\n            bool success = p1.sendClaimPayout(coverid, claimid, sumAssured, qd.getCoverMemberAddress(coverid), curr);\r\n            if (success) {\r\n                tf.burnStakedTokens(coverid, curr, sumAssured);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Computes the result of Claim Assessors Voting for a given claim id.\r\n    function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\r\n        // Check if voting should be closed or not\r\n        if (c1.checkVoteClosing(claimid) == 1) {\r\n            uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\r\n            uint accept;\r\n            uint deny;\r\n            uint acceptAndDeny;\r\n            bool rewardOrPunish;\r\n            uint sumAssured;\r\n            (, accept) = cd.getClaimVote(claimid, 1);\r\n            (, deny) = cd.getClaimVote(claimid, -1);\r\n            acceptAndDeny = accept.add(deny);\r\n            accept = accept.mul(100);\r\n            deny = deny.mul(100);\r\n\r\n            if (caTokens == 0) {\r\n                status = 3;\r\n            } else {\r\n                sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n                // Min threshold reached tokens used for voting > 5* sum assured\r\n                if (caTokens > sumAssured.mul(5)) {\r\n\r\n                    if (accept.div(acceptAndDeny) > 70) {\r\n                        status = 7;\r\n                        qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimAccepted));\r\n                        rewardOrPunish = true;\r\n                    } else if (deny.div(acceptAndDeny) > 70) {\r\n                        status = 6;\r\n                        qd.changeCoverStatusNo(coverid, uint8(QuotationData.CoverStatus.ClaimDenied));\r\n                        rewardOrPunish = true;\r\n                    } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\r\n                        status = 4;\r\n                    } else {\r\n                        status = 5;\r\n                    }\r\n\r\n                } else {\r\n\r\n                    if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\r\n                        status = 2;\r\n                    } else {\r\n                        status = 3;\r\n                    }\r\n                }\r\n            }\r\n\r\n            c1.setClaimStatus(claimid, status);\r\n\r\n            if (rewardOrPunish) {\r\n                _rewardAgainstClaim(claimid, coverid, sumAssured, status);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Computes the result of Member Voting for a given claim id.\r\n    function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\r\n\r\n        // Check if voting should be closed or not\r\n        if (c1.checkVoteClosing(claimid) == 1) {\r\n            uint8 coverStatus;\r\n            uint statusOrig = status;\r\n            uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\r\n\r\n            // If tokens used for acceptance >50%, claim is accepted\r\n            uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\r\n            uint thresholdUnreached = 0;\r\n            // Minimum threshold for member voting is reached only when\r\n            // value of tokens used for voting > 5* sum assured of claim id\r\n            if (mvTokens < sumAssured.mul(5)) {\r\n                thresholdUnreached = 1;\r\n            }\r\n\r\n            uint accept;\r\n            (, accept) = cd.getClaimMVote(claimid, 1);\r\n            uint deny;\r\n            (, deny) = cd.getClaimMVote(claimid, -1);\r\n\r\n            if (accept.add(deny) > 0) {\r\n                if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\r\n                    statusOrig <= 5 && thresholdUnreached == 0) {\r\n                    status = 8;\r\n                    coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\r\n                } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\r\n                    statusOrig <= 5 && thresholdUnreached == 0) {\r\n                    status = 9;\r\n                    coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\r\n                }\r\n            }\r\n\r\n            if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\r\n                status = 10;\r\n                coverStatus = uint8(QuotationData.CoverStatus.ClaimAccepted);\r\n            } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\r\n                status = 11;\r\n                coverStatus = uint8(QuotationData.CoverStatus.ClaimDenied);\r\n            }\r\n\r\n            c1.setClaimStatus(claimid, status);\r\n            qd.changeCoverStatusNo(coverid, uint8(coverStatus));\r\n            // Reward/Punish Claim Assessors and Members who participated in Claims assessment\r\n            _rewardAgainstClaim(claimid, coverid, sumAssured, status);\r\n        }\r\n    }\r\n\r\n    /// @dev Allows a user to claim all pending  Claims assessment rewards.\r\n    function _claimRewardToBeDistributed(uint _records) internal {\r\n        uint lengthVote = cd.getVoteAddressCALength(msg.sender);\r\n        uint voteid;\r\n        uint lastIndex;\r\n        (lastIndex, ) = cd.getRewardDistributedIndex(msg.sender);\r\n        uint total = 0;\r\n        uint tokenForVoteId = 0;\r\n        bool lastClaimedCheck;\r\n        uint _days = td.lockCADays();\r\n        bool claimed;\r\n        uint counter = 0;\r\n        uint claimId;\r\n        uint perc;\r\n        uint i;\r\n        uint lastClaimed = lengthVote;\r\n\r\n        for (i = lastIndex; i < lengthVote && counter < _records; i++) {\r\n            voteid = cd.getVoteAddressCA(msg.sender, i);\r\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\r\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\r\n                lastClaimed = i;\r\n            }\r\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\r\n\r\n            if (perc > 0 && !claimed) {\r\n                counter++;\r\n                cd.setRewardClaimed(voteid, true);\r\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\r\n                (perc, , ) = cd.getClaimRewardDetail(claimId);\r\n                if (perc == 0) {\r\n                    counter++;\r\n                }\r\n                cd.setRewardClaimed(voteid, true);\r\n            }\r\n            if (tokenForVoteId > 0) {\r\n                total = tokenForVoteId.add(total);\r\n            }\r\n        }\r\n        if (lastClaimed == lengthVote) {\r\n            cd.setRewardDistributedIndexCA(msg.sender, i);\r\n        }\r\n        else {\r\n            cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\r\n        }\r\n        lengthVote = cd.getVoteAddressMemberLength(msg.sender);\r\n        lastClaimed = lengthVote;\r\n        _days = _days.mul(counter);\r\n        if (tc.tokensLockedAtTime(msg.sender, \"CLA\", now) > 0) {\r\n            tc.reduceLock(msg.sender, \"CLA\", _days);\r\n        }\r\n        (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\r\n        lastClaimed = lengthVote;\r\n        counter = 0;\r\n        for (i = lastIndex; i < lengthVote && counter < _records; i++) {\r\n            voteid = cd.getVoteAddressMember(msg.sender, i);\r\n            (tokenForVoteId, lastClaimedCheck, , ) = getRewardToBeGiven(0, voteid, 0);\r\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\r\n                lastClaimed = i;\r\n            }\r\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\r\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\r\n                cd.setRewardClaimed(voteid, true);\r\n                counter++;\r\n            }\r\n            if (tokenForVoteId > 0) {\r\n                total = tokenForVoteId.add(total);\r\n            }\r\n        }\r\n        if (total > 0) {\r\n            require(tk.transfer(msg.sender, total));\r\n        }\r\n        if (lastClaimed == lengthVote) {\r\n            cd.setRewardDistributedIndexMV(msg.sender, i);\r\n        }\r\n        else {\r\n            cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function used to claim the commission earned by the staker.\r\n     */\r\n    function _claimStakeCommission(uint _records, address _user) external onlyInternal {\r\n        uint total=0;\r\n        uint len = td.getStakerStakedContractLength(_user);\r\n        uint lastCompletedStakeCommission = td.lastCompletedStakeCommission(_user);\r\n        uint commissionEarned;\r\n        uint commissionRedeemed;\r\n        uint maxCommission;\r\n        uint lastCommisionRedeemed = len;\r\n        uint counter;\r\n        uint i;\r\n\r\n        for (i = lastCompletedStakeCommission; i < len && counter < _records; i++) {\r\n            commissionRedeemed = td.getStakerRedeemedStakeCommission(_user, i);\r\n            commissionEarned = td.getStakerEarnedStakeCommission(_user, i);\r\n            maxCommission = td.getStakerInitialStakedAmountOnContract(\r\n                _user, i).mul(td.stakerMaxCommissionPer()).div(100);\r\n            if (lastCommisionRedeemed == len && maxCommission != commissionEarned)\r\n                lastCommisionRedeemed = i;\r\n            td.pushRedeemedStakeCommissions(_user, i, commissionEarned.sub(commissionRedeemed));\r\n            total = total.add(commissionEarned.sub(commissionRedeemed));\r\n            counter++;\r\n        }\r\n        if (lastCommisionRedeemed == len) {\r\n            td.setLastCompletedStakeCommissionIndex(_user, i);\r\n        } else {\r\n            td.setLastCompletedStakeCommissionIndex(_user, lastCommisionRedeemed);\r\n        }\r\n\r\n        if (total > 0)\r\n            require(tk.transfer(_user, total)); //solhint-disable-line\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract MemberRoles is IMemberRoles, Governed, Iupgradable {\r\n\r\n    TokenController public dAppToken;\r\n    TokenData internal td;\r\n    QuotationData internal qd;\r\n    ClaimsReward internal cr;\r\n    Governance internal gv;\r\n    TokenFunctions internal tf;\r\n    SOTEToken public tk;\r\n\r\n    struct MemberRoleDetails {\r\n        uint memberCounter;\r\n        mapping(address => bool) memberActive;\r\n        address[] memberAddress;\r\n        address authorized;\r\n    }\r\n\r\n    enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\r\n\r\n    event switchedMembership(address indexed previousMember, address indexed newMember, uint timeStamp);\r\n\r\n    MemberRoleDetails[] internal memberRoleData;\r\n    bool internal constructorCheck;\r\n    uint public maxABCount;\r\n    bool public launched;\r\n    uint public launchedOn;\r\n    modifier checkRoleAuthority(uint _memberRoleId) {\r\n        if (memberRoleData[_memberRoleId].authorized != address(0))\r\n            require(msg.sender == memberRoleData[_memberRoleId].authorized);\r\n        else\r\n            require(isAuthorizedToGovern(msg.sender), \"Not Authorized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev to swap advisory board member\r\n     * @param _newABAddress is address of new AB member\r\n     * @param _removeAB is advisory board member to be removed\r\n     */\r\n    function swapABMember (\r\n        address _newABAddress,\r\n        address _removeAB\r\n    )\r\n    external\r\n    checkRoleAuthority(uint(Role.AdvisoryBoard)) {\r\n\r\n        _updateRole(_newABAddress, uint(Role.AdvisoryBoard), true);\r\n        _updateRole(_removeAB, uint(Role.AdvisoryBoard), false);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev to swap the owner address\r\n     * @param _newOwnerAddress is the new owner address\r\n     */\r\n    function swapOwner (\r\n        address _newOwnerAddress\r\n    )\r\n    external {\r\n        require(msg.sender == address(ms));\r\n        _updateRole(ms.owner(), uint(Role.Owner), false);\r\n        _updateRole(_newOwnerAddress, uint(Role.Owner), true);\r\n    }\r\n\r\n    /**\r\n     * @dev is used to add initital advisory board members\r\n     * @param abArray is the list of initial advisory board members\r\n     */\r\n    function addInitialABMembers(address[] calldata abArray) external onlyOwner {\r\n\r\n        //Ensure that SOTEMaster has initialized.\r\n        require(ms.masterInitialized());\r\n\r\n        require(maxABCount >= \r\n            SafeMath.add(numberOfMembers(uint(Role.AdvisoryBoard)), abArray.length)\r\n        );\r\n        //AB count can't exceed maxABCount\r\n        for (uint i = 0; i < abArray.length; i++) {\r\n            require(checkRole(abArray[i], uint(MemberRoles.Role.Member)));\r\n            _updateRole(abArray[i], uint(Role.AdvisoryBoard), true);   \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to change max number of AB members allowed\r\n     * @param _val is the new value to be set\r\n     */\r\n    function changeMaxABCount(uint _val) external onlyInternal {\r\n        maxABCount = _val;\r\n    }\r\n\r\n    /**\r\n     * @dev Iupgradable Interface to update dependent contract address\r\n     */\r\n    function changeDependentContractAddress() public {\r\n        td = TokenData(ms.getLatestAddress(\"TD\"));\r\n        cr = ClaimsReward(ms.getLatestAddress(\"CR\"));\r\n        qd = QuotationData(ms.getLatestAddress(\"QD\"));\r\n        gv = Governance(ms.getLatestAddress(\"GV\"));\r\n        tf = TokenFunctions(ms.getLatestAddress(\"TF\"));\r\n        tk = SOTEToken(ms.tokenAddress());\r\n        dAppToken = TokenController(ms.getLatestAddress(\"TC\"));\r\n    }\r\n\r\n    /**\r\n     * @dev to change the master address\r\n     * @param _masterAddress is the new master address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (masterAddress != address(0))\r\n            require(masterAddress == msg.sender);\r\n        masterAddress = _masterAddress;\r\n        ms = ISOTEMaster(_masterAddress);\r\n        soteMasterAddress = _masterAddress;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @dev to initiate the member roles\r\n     * @param _firstAB is the address of the first AB member\r\n     * @param memberAuthority is the authority (role) of the member\r\n     */\r\n    function memberRolesInitiate (address _firstAB, address memberAuthority) public {\r\n        require(!constructorCheck);\r\n        _addInitialMemberRoles(_firstAB, memberAuthority);\r\n        constructorCheck = true;\r\n    }\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function addRole( //solhint-disable-line\r\n        bytes32 _roleName,\r\n        string memory _roleDescription,\r\n        address _authorized\r\n    )\r\n    public\r\n    onlyAuthorizedToGovern {\r\n        _addRole(_roleName, _roleDescription, _authorized);\r\n    }\r\n\r\n    /// @dev Assign or Delete a member from specific role.\r\n    /// @param _memberAddress Address of Member\r\n    /// @param _roleId RoleId to update\r\n    /// @param _active active is set to be True if we want to assign this role to member, False otherwise!\r\n    function updateRole( //solhint-disable-line\r\n        address _memberAddress,\r\n        uint _roleId,\r\n        bool _active\r\n    )\r\n    public\r\n    checkRoleAuthority(_roleId) {\r\n        _updateRole(_memberAddress, _roleId, _active);\r\n    }\r\n\r\n    /**\r\n     * @dev to add members before launch\r\n     * @param userArray is list of addresses of members\r\n     * @param tokens is list of tokens minted for each array element\r\n     */\r\n    function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\r\n        require(!launched);\r\n\r\n        for (uint i=0; i < userArray.length; i++) {\r\n            require(!ms.isMember(userArray[i]));\r\n            dAppToken.addToWhitelist(userArray[i]);\r\n            _updateRole(userArray[i], uint(Role.Member), true);\r\n            dAppToken.mint(userArray[i], tokens[i]);\r\n        }\r\n        launched = true;\r\n        launchedOn = now;\r\n\r\n    }\r\n\r\n   /** \r\n     * @dev Called by user to pay joining membership fee\r\n     */ \r\n    function payJoiningFee(address _userAddress) public payable {\r\n        require(_userAddress != address(0));\r\n        require(!ms.isPause(), \"Emergency Pause Applied\");\r\n        if (msg.sender == address(ms.getLatestAddress(\"QT\"))) {\r\n            require(td.walletAddress() != address(0), \"No walletAddress present\");\r\n            dAppToken.addToWhitelist(_userAddress);\r\n            _updateRole(_userAddress, uint(Role.Member), true);            \r\n            td.walletAddress().transfer(msg.value); \r\n        } else {\r\n            require(!qd.refundEligible(_userAddress));\r\n            require(!ms.isMember(_userAddress));\r\n            require(msg.value == td.joiningFee());\r\n            // auto verdict user\r\n            qd.setRefundEligible(_userAddress, false);\r\n            dAppToken.addToWhitelist(_userAddress);\r\n            _updateRole(_userAddress, uint(Role.Member), true);\r\n            td.walletAddress().transfer(msg.value); //solhint-disable-line\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to perform kyc verdict\r\n     * @param _userAddress whose kyc is being performed\r\n     * @param verdict of kyc process\r\n     */\r\n    function kycVerdict(address payable _userAddress, bool verdict) public {\r\n\r\n        require(msg.sender == qd.kycAuthAddress());\r\n        require(!ms.isPause());\r\n        require(_userAddress != address(0));\r\n        require(!ms.isMember(_userAddress));\r\n        require(qd.refundEligible(_userAddress));\r\n        if (verdict) {\r\n            qd.setRefundEligible(_userAddress, false);\r\n            uint fee = td.joiningFee();\r\n            dAppToken.addToWhitelist(_userAddress);\r\n            _updateRole(_userAddress, uint(Role.Member), true);\r\n            td.walletAddress().transfer(fee); //solhint-disable-line\r\n            \r\n        } else {\r\n            qd.setRefundEligible(_userAddress, false);\r\n            _userAddress.transfer(td.joiningFee()); //solhint-disable-line\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Called by existed member if wish to Withdraw membership.\r\n     */\r\n    function withdrawMembership() public {\r\n        require(!ms.isPause() && ms.isMember(msg.sender));\r\n        require(dAppToken.totalLockedBalance(msg.sender, now) == 0); //solhint-disable-line\r\n        require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\r\n        // require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\r\n        require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\r\n        // gv.removeDelegation(msg.sender);\r\n        dAppToken.burnFrom(msg.sender, tk.balanceOf(msg.sender));\r\n        _updateRole(msg.sender, uint(Role.Member), false);\r\n        dAppToken.removeFromWhitelist(msg.sender); // need clarification on whitelist        \r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Called by existed member if wish to switch membership to other address.\r\n     * @param _add address of user to forward membership.\r\n     */\r\n    function switchMembership(address _add) external {\r\n        require(!ms.isPause() && ms.isMember(msg.sender) && !ms.isMember(_add));\r\n        require(dAppToken.totalLockedBalance(msg.sender, now) == 0); //solhint-disable-line\r\n        require(!tf.isLockedForMemberVote(msg.sender)); // No locked tokens for Member/Governance voting\r\n        require(cr.getAllPendingRewardOfUser(msg.sender) == 0); // No pending reward to be claimed(claim assesment).\r\n        require(dAppToken.tokensUnlockable(msg.sender, \"CLA\") == 0, \"Member should have no CLA unlockable tokens\");\r\n        gv.removeDelegation(msg.sender);\r\n        dAppToken.addToWhitelist(_add);\r\n        _updateRole(_add, uint(Role.Member), true);\r\n        tk.transferFrom(msg.sender, _add, tk.balanceOf(msg.sender));\r\n        _updateRole(msg.sender, uint(Role.Member), false);\r\n        dAppToken.removeFromWhitelist(msg.sender);\r\n        emit switchedMembership(msg.sender, _add, now);\r\n    }\r\n\r\n    /// @dev Return number of member roles\r\n    function totalRoles() public view returns(uint256) { //solhint-disable-line\r\n        return memberRoleData.length;\r\n    }\r\n\r\n    /// @dev Change Member Address who holds the authority to Add/Delete any member from specific role.\r\n    /// @param _roleId roleId to update its Authorized Address\r\n    /// @param _newAuthorized New authorized address against role id\r\n    function changeAuthorized(uint _roleId, address _newAuthorized) public checkRoleAuthority(_roleId) { //solhint-disable-line\r\n        memberRoleData[_roleId].authorized = _newAuthorized;\r\n    }\r\n\r\n    /// @dev Gets the member addresses assigned by a specific role\r\n    /// @param _memberRoleId Member role id\r\n    /// @return roleId Role id\r\n    /// @return allMemberAddress Member addresses of specified role id\r\n    function members(uint _memberRoleId) public view returns(uint, address[] memory memberArray) { //solhint-disable-line\r\n        uint length = memberRoleData[_memberRoleId].memberAddress.length;\r\n        uint i;\r\n        uint j = 0;\r\n        memberArray = new address[](memberRoleData[_memberRoleId].memberCounter);\r\n        for (i = 0; i < length; i++) {\r\n            address member = memberRoleData[_memberRoleId].memberAddress[i];\r\n            if (memberRoleData[_memberRoleId].memberActive[member] && !_checkMemberInArray(member, memberArray)) { //solhint-disable-line\r\n                memberArray[j] = member;\r\n                j++;\r\n            }\r\n        }\r\n\r\n        return (_memberRoleId, memberArray);\r\n    }\r\n\r\n    /// @dev Gets all members' length\r\n    /// @param _memberRoleId Member role id\r\n    /// @return memberRoleData[_memberRoleId].memberCounter Member length\r\n    function numberOfMembers(uint _memberRoleId) public view returns(uint) { //solhint-disable-line\r\n        return memberRoleData[_memberRoleId].memberCounter;\r\n    }\r\n\r\n    /// @dev Return member address who holds the right to add/remove any member from specific role.\r\n    function authorized(uint _memberRoleId) public view returns(address) { //solhint-disable-line\r\n        return memberRoleData[_memberRoleId].authorized;\r\n    }\r\n\r\n    /// @dev Get All role ids array that has been assigned to a member so far.\r\n    function roles(address _memberAddress) public view returns(uint[] memory) { //solhint-disable-line\r\n        uint length = memberRoleData.length;\r\n        uint[] memory assignedRoles = new uint[](length);\r\n        uint counter = 0; \r\n        for (uint i = 1; i < length; i++) {\r\n            if (memberRoleData[i].memberActive[_memberAddress]) {\r\n                assignedRoles[counter] = i;\r\n                counter++;\r\n            }\r\n        }\r\n        return assignedRoles;\r\n    }\r\n\r\n    /// @dev Returns true if the given role id is assigned to a member.\r\n    /// @param _memberAddress Address of member\r\n    /// @param _roleId Checks member's authenticity with the roleId.\r\n    /// i.e. Returns true if this roleId is assigned to member\r\n    function checkRole(address _memberAddress, uint _roleId) public view returns(bool) { //solhint-disable-line\r\n        if (_roleId == uint(Role.UnAssigned))\r\n            return true;\r\n        else\r\n            if (memberRoleData[_roleId].memberActive[_memberAddress]) //solhint-disable-line\r\n                return true;\r\n            else\r\n                return false;\r\n    }\r\n\r\n    /// @dev Return total number of members assigned against each role id.\r\n    /// @return totalMembers Total members in particular role id\r\n    function getMemberLengthForAllRoles() public view returns(uint[] memory totalMembers) { //solhint-disable-line\r\n        totalMembers = new uint[](memberRoleData.length);\r\n        for (uint i = 0; i < memberRoleData.length; i++) {\r\n            totalMembers[i] = numberOfMembers(i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to update the member roles\r\n     * @param _memberAddress in concern\r\n     * @param _roleId the id of role\r\n     * @param _active if active is true, add the member, else remove it \r\n     */\r\n    function _updateRole(address _memberAddress,\r\n        uint _roleId,\r\n        bool _active) internal {\r\n        // require(_roleId != uint(Role.TokenHolder), \"Membership to Token holder is detected automatically\");\r\n        if (_active) {\r\n            require(!memberRoleData[_roleId].memberActive[_memberAddress]);\r\n            memberRoleData[_roleId].memberCounter = SafeMath.add(memberRoleData[_roleId].memberCounter, 1);\r\n            memberRoleData[_roleId].memberActive[_memberAddress] = true;\r\n            memberRoleData[_roleId].memberAddress.push(_memberAddress);\r\n        } else {\r\n            require(memberRoleData[_roleId].memberActive[_memberAddress]);\r\n            memberRoleData[_roleId].memberCounter = SafeMath.sub(memberRoleData[_roleId].memberCounter, 1);\r\n            delete memberRoleData[_roleId].memberActive[_memberAddress];\r\n        }\r\n    }\r\n\r\n    /// @dev Adds new member role\r\n    /// @param _roleName New role name\r\n    /// @param _roleDescription New description hash\r\n    /// @param _authorized Authorized member against every role id\r\n    function _addRole(\r\n        bytes32 _roleName,\r\n        string memory _roleDescription,\r\n        address _authorized\r\n    ) internal {\r\n        emit MemberRole(memberRoleData.length, _roleName, _roleDescription);\r\n        memberRoleData.push(MemberRoleDetails(0, new address[](0), _authorized));\r\n    }\r\n\r\n    /**\r\n     * @dev to check if member is in the given member array\r\n     * @param _memberAddress in concern\r\n     * @param memberArray in concern\r\n     * @return boolean to represent the presence\r\n     */\r\n    function _checkMemberInArray(\r\n        address _memberAddress,\r\n        address[] memory memberArray\r\n    )\r\n        internal\r\n        pure\r\n        returns(bool memberExists)\r\n    {\r\n        uint i;\r\n        for (i = 0; i < memberArray.length; i++) {\r\n            if (memberArray[i] == _memberAddress) {\r\n                memberExists = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to add initial member roles\r\n     * @param _firstAB is the member address to be added\r\n     * @param memberAuthority is the member authority(role) to be added for\r\n     */\r\n    function _addInitialMemberRoles(address _firstAB, address memberAuthority) internal {\r\n        maxABCount = 5;\r\n        _addRole(\"Unassigned\", \"Unassigned\", address(0));\r\n        _addRole(\r\n            \"Advisory Board\",\r\n            \"Selected few members that are deeply entrusted by the dApp. An ideal advisory board should be a mix of skills of domain, governance, research, technology, consulting etc to improve the performance of the dApp.\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n        _addRole(\r\n            \"Member\",\r\n            \"Represents all users of Mutual.\", //solhint-disable-line\r\n            memberAuthority\r\n        );\r\n        _addRole(\r\n            \"Owner\",\r\n            \"Represents Owner of Mutual.\", //solhint-disable-line\r\n            address(0)\r\n        );\r\n        // _updateRole(_firstAB, uint(Role.AdvisoryBoard), true);\r\n        _updateRole(_firstAB, uint(Role.Owner), true);\r\n        // _updateRole(_firstAB, uint(Role.Member), true);\r\n        launchedOn = 0;\r\n    }\r\n\r\n    function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool) {\r\n        address memberAddress = memberRoleData[_memberRoleId].memberAddress[index];\r\n        return (memberAddress, memberRoleData[_memberRoleId].memberActive[memberAddress]);\r\n    }\r\n\r\n    function membersLength(uint _memberRoleId) external view returns (uint) {\r\n        return memberRoleData[_memberRoleId].memberAddress.length;\r\n    }\r\n}\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract ProposalCategory is  Governed, IProposalCategory, Iupgradable {\r\n\r\n    bool public constructorCheck;\r\n    MemberRoles internal mr;\r\n\r\n    struct CategoryStruct {\r\n        uint memberRoleToVote;\r\n        uint majorityVotePerc;\r\n        uint quorumPerc;\r\n        uint[] allowedToCreateProposal;\r\n        uint closingTime;\r\n        uint minStake;\r\n    }\r\n\r\n    struct CategoryAction {\r\n        uint defaultIncentive;\r\n        address contractAddress;\r\n        bytes2 contractName;\r\n    }\r\n    \r\n    CategoryStruct[] internal allCategory;\r\n    mapping (uint => CategoryAction) internal categoryActionData;\r\n    mapping (uint => uint) public categoryABReq;\r\n    mapping (uint => uint) public isSpecialResolution;\r\n    mapping (uint => bytes) public categoryActionHashes;\r\n\r\n    bool public categoryActionHashUpdated;\r\n\r\n    /**\r\n    * @dev Restricts calls to deprecated functions\r\n    */\r\n    modifier deprecated() {\r\n        revert(\"Function deprecated\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds new category (Discontinued, moved functionality to newCategory)\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    */\r\n    function addCategory(\r\n        string calldata _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] calldata _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string calldata _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] calldata _incentives\r\n    ) \r\n        external\r\n        deprecated \r\n    {\r\n    }\r\n\r\n    /**\r\n    * @dev Initiates Default action function hashes for existing categories\r\n    * To be called after the contract has been upgraded by governance\r\n    */\r\n    function updateCategoryActionHashes() external onlyOwner {\r\n\r\n        require(!categoryActionHashUpdated, \"Category action hashes already updated\");\r\n        categoryActionHashUpdated = true;\r\n        categoryActionHashes[1] = abi.encodeWithSignature(\"addRole(bytes32,string,address)\");\r\n        categoryActionHashes[2] = abi.encodeWithSignature(\"updateRole(address,uint256,bool)\");\r\n        categoryActionHashes[3] = abi.encodeWithSignature(\"newCategory(string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\");//solhint-disable-line\r\n        categoryActionHashes[4] = abi.encodeWithSignature(\"editCategory(uint256,string,uint256,uint256,uint256,uint256[],uint256,string,address,bytes2,uint256[],string)\");//solhint-disable-line\r\n        categoryActionHashes[5] = abi.encodeWithSignature(\"upgradeContractImplementation(bytes2,address)\");\r\n        categoryActionHashes[6] = abi.encodeWithSignature(\"startEmergencyPause()\");\r\n        categoryActionHashes[7] = abi.encodeWithSignature(\"addEmergencyPause(bool,bytes4)\");\r\n        categoryActionHashes[8] = abi.encodeWithSignature(\"burnCAToken(uint256,uint256,address)\");\r\n        categoryActionHashes[9] = abi.encodeWithSignature(\"setUserClaimVotePausedOn(address)\");\r\n        categoryActionHashes[12] = abi.encodeWithSignature(\"transferEther(uint256,address)\");\r\n        categoryActionHashes[13] = abi.encodeWithSignature(\"addInvestmentAssetCurrency(bytes4,address,bool,uint64,uint64,uint8)\");//solhint-disable-line\r\n        categoryActionHashes[14] = abi.encodeWithSignature(\"changeInvestmentAssetHoldingPerc(bytes4,uint64,uint64)\");\r\n        categoryActionHashes[15] = abi.encodeWithSignature(\"changeInvestmentAssetStatus(bytes4,bool)\");\r\n        categoryActionHashes[16] = abi.encodeWithSignature(\"swapABMember(address,address)\");\r\n        categoryActionHashes[17] = abi.encodeWithSignature(\"addCurrencyAssetCurrency(bytes4,address,uint256)\");\r\n        categoryActionHashes[20] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[21] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[22] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[23] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[24] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[25] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[26] = abi.encodeWithSignature(\"updateUintParameters(bytes8,uint256)\");\r\n        categoryActionHashes[27] = abi.encodeWithSignature(\"updateAddressParameters(bytes8,address)\");\r\n        categoryActionHashes[28] = abi.encodeWithSignature(\"updateOwnerParameters(bytes8,address)\");\r\n        categoryActionHashes[29] = abi.encodeWithSignature(\"upgradeContract(bytes2,address)\");\r\n        categoryActionHashes[30] = abi.encodeWithSignature(\"changeCurrencyAssetAddress(bytes4,address)\");\r\n        categoryActionHashes[31] = abi.encodeWithSignature(\"changeCurrencyAssetBaseMin(bytes4,uint256)\");\r\n        categoryActionHashes[32] = abi.encodeWithSignature(\"changeInvestmentAssetAddressAndDecimal(bytes4,address,uint8)\");//solhint-disable-line\r\n        categoryActionHashes[33] = abi.encodeWithSignature(\"externalLiquidityTrade()\");\r\n    }\r\n\r\n    /**\r\n    * @dev Gets Total number of categories added till now\r\n    */\r\n    function totalCategories() external view returns(uint) {\r\n        return allCategory.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets category details\r\n    */\r\n    function category(uint _categoryId) external view returns(uint, uint, uint, uint, uint[] memory, uint, uint) {\r\n        return(\r\n            _categoryId,\r\n            allCategory[_categoryId].memberRoleToVote,\r\n            allCategory[_categoryId].majorityVotePerc,\r\n            allCategory[_categoryId].quorumPerc,\r\n            allCategory[_categoryId].allowedToCreateProposal,\r\n            allCategory[_categoryId].closingTime,\r\n            allCategory[_categoryId].minStake\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Gets category ab required and isSpecialResolution\r\n    * @return the category id\r\n    * @return if AB voting is required\r\n    * @return is category a special resolution\r\n    */\r\n    function categoryExtendedData(uint _categoryId) external view returns(uint, uint, uint) {\r\n        return(\r\n            _categoryId,\r\n            categoryABReq[_categoryId],\r\n            isSpecialResolution[_categoryId]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the category acion details\r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     */\r\n    function categoryAction(uint _categoryId) external view returns(uint, address, bytes2, uint) {\r\n\r\n        return(\r\n            _categoryId,\r\n            categoryActionData[_categoryId].contractAddress,\r\n            categoryActionData[_categoryId].contractName,\r\n            categoryActionData[_categoryId].defaultIncentive\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the category acion details of a category id \r\n     * @param _categoryId is the category id in concern\r\n     * @return the category id\r\n     * @return the contract address\r\n     * @return the contract name\r\n     * @return the default incentive\r\n     * @return action function hash\r\n     */\r\n    function categoryActionDetails(uint _categoryId) external view returns(uint, address, bytes2, uint, bytes memory) {\r\n        return(\r\n            _categoryId,\r\n            categoryActionData[_categoryId].contractAddress,\r\n            categoryActionData[_categoryId].contractName,\r\n            categoryActionData[_categoryId].defaultIncentive,\r\n            categoryActionHashes[_categoryId]\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Updates dependant contract addresses\r\n    */\r\n    function changeDependentContractAddress() public {\r\n        mr = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Adds new category\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    * @param _functionHash function signature to be executed\r\n    */\r\n    function newCategory(\r\n        string memory _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives,\r\n        string memory _functionHash\r\n    ) \r\n        public\r\n        onlyAuthorizedToGovern \r\n    {\r\n\r\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\r\n\r\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\r\n        \r\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\r\n        \r\n        //If category is special resolution role authorized should be member\r\n        if (_incentives[3] == 1) {\r\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\r\n            _majorityVotePerc = 0;\r\n            _quorumPerc = 0;\r\n        }\r\n\r\n        _addCategory(\r\n            _name, \r\n            _memberRoleToVote,\r\n            _majorityVotePerc, \r\n            _quorumPerc,\r\n            _allowedToCreateProposal,\r\n            _closingTime,\r\n            _actionHash,\r\n            _contractAddress,\r\n            _contractName,\r\n            _incentives\r\n        );\r\n\r\n\r\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\r\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the master address and update it's instance\r\n     * @param _masterAddress is the new master address\r\n     */\r\n    function changeMasterAddress(address _masterAddress) public {\r\n        if (masterAddress != address(0))\r\n            require(masterAddress == msg.sender);\r\n        masterAddress = _masterAddress;\r\n        ms = ISOTEMaster(_masterAddress);\r\n        soteMasterAddress = _masterAddress;\r\n        \r\n    }\r\n\r\n    /**\r\n    * @dev Updates category details (Discontinued, moved functionality to editCategory)\r\n    * @param _categoryId Category id that needs to be updated\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    */\r\n    function updateCategory(\r\n        uint _categoryId, \r\n        string memory _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives\r\n    )\r\n        public\r\n        deprecated\r\n    {\r\n    }\r\n\r\n    /**\r\n    * @dev Updates category details\r\n    * @param _categoryId Category id that needs to be updated\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    * @param _functionHash function signature to be executed\r\n    */\r\n    function editCategory(\r\n        uint _categoryId, \r\n        string memory _name, \r\n        uint _memberRoleToVote, \r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives,\r\n        string memory _functionHash\r\n    )\r\n        public\r\n        onlyAuthorizedToGovern\r\n    {\r\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\r\n\r\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\r\n\r\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\r\n\r\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\r\n        \r\n        //If category is special resolution role authorized should be member\r\n        if (_incentives[3] == 1) {\r\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\r\n            _majorityVotePerc = 0;\r\n            _quorumPerc = 0;\r\n        }\r\n\r\n        delete categoryActionHashes[_categoryId];\r\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\r\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\r\n        }\r\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\r\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\r\n        allCategory[_categoryId].closingTime = _closingTime;\r\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\r\n        allCategory[_categoryId].minStake = _incentives[0];\r\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\r\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\r\n        categoryActionData[_categoryId].contractName = _contractName;\r\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\r\n        categoryABReq[_categoryId] = _incentives[2];\r\n        isSpecialResolution[_categoryId] = _incentives[3];\r\n        emit Category(_categoryId, _name, _actionHash);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal call to add new category\r\n    * @param _name Category name\r\n    * @param _memberRoleToVote Voting Layer sequence in which the voting has to be performed.\r\n    * @param _majorityVotePerc Majority Vote threshold for Each voting layer\r\n    * @param _quorumPerc minimum threshold percentage required in voting to calculate result\r\n    * @param _allowedToCreateProposal Member roles allowed to create the proposal\r\n    * @param _closingTime Vote closing time for Each voting layer\r\n    * @param _actionHash hash of details containing the action that has to be performed after proposal is accepted\r\n    * @param _contractAddress address of contract to call after proposal is accepted\r\n    * @param _contractName name of contract to be called after proposal is accepted\r\n    * @param _incentives rewards to distributed after proposal is accepted\r\n    */\r\n    function _addCategory(\r\n        string memory _name, \r\n        uint _memberRoleToVote,\r\n        uint _majorityVotePerc, \r\n        uint _quorumPerc,\r\n        uint[] memory _allowedToCreateProposal,\r\n        uint _closingTime,\r\n        string memory _actionHash,\r\n        address _contractAddress,\r\n        bytes2 _contractName,\r\n        uint[] memory _incentives\r\n    ) \r\n        internal\r\n    {\r\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\r\n        allCategory.push(\r\n            CategoryStruct(\r\n                _memberRoleToVote,\r\n                _majorityVotePerc,\r\n                _quorumPerc,\r\n                _allowedToCreateProposal,\r\n                _closingTime,\r\n                _incentives[0]\r\n            )\r\n        );\r\n        uint categoryId = allCategory.length - 1;\r\n        categoryActionData[categoryId] = CategoryAction(_incentives[1], _contractAddress, _contractName);\r\n        categoryABReq[categoryId] = _incentives[2];\r\n        isSpecialResolution[categoryId] = _incentives[3];\r\n        emit Category(categoryId, _name, _actionHash);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal call to check if given roles are valid or not\r\n    */\r\n    function _verifyMemberRoles(uint _memberRoleToVote, uint[] memory _allowedToCreateProposal) \r\n    internal view returns(uint) { \r\n        uint totalRoles = mr.totalRoles();\r\n        if (_memberRoleToVote >= totalRoles) {\r\n            return 0;\r\n        }\r\n        for (uint i = 0; i < _allowedToCreateProposal.length; i++) {\r\n            if (_allowedToCreateProposal[i] >= totalRoles) {\r\n                return 0;\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n\r\n}\r\n\r\n/* Copyright (C) 2017 GovBlocks.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract IGovernance { \r\n\r\n    event Proposal(\r\n        address indexed proposalOwner,\r\n        uint256 indexed proposalId,\r\n        uint256 dateAdd,\r\n        string proposalTitle,\r\n        string proposalSD,\r\n        string proposalDescHash\r\n    );\r\n\r\n    event Solution(\r\n        uint256 indexed proposalId,\r\n        address indexed solutionOwner,\r\n        uint256 indexed solutionId,\r\n        string solutionDescHash,\r\n        uint256 dateAdd\r\n    );\r\n\r\n    event Vote(\r\n        address indexed from,\r\n        uint256 indexed proposalId,\r\n        uint256 indexed voteId,\r\n        uint256 dateAdd,\r\n        uint256 solutionChosen\r\n    );\r\n\r\n    event RewardClaimed(\r\n        address indexed member,\r\n        uint gbtReward\r\n    );\r\n\r\n    /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal. \r\n    event VoteCast (uint256 proposalId);\r\n\r\n    /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can \r\n    ///      call any offchain actions\r\n    event ProposalAccepted (uint256 proposalId);\r\n\r\n    /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\r\n    event CloseProposalOnTime (\r\n        uint256 indexed proposalId,\r\n        uint256 time\r\n    );\r\n\r\n    /// @dev ActionSuccess event is called whenever an onchain action is executed.\r\n    event ActionSuccess (\r\n        uint256 proposalId\r\n    );\r\n\r\n    /// @dev Creates a new proposal\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    function createProposal(\r\n        string calldata _proposalTitle,\r\n        string calldata _proposalSD,\r\n        string calldata _proposalDescHash,\r\n        uint _categoryId\r\n    ) \r\n        external;\r\n\r\n    /// @dev Edits the details of an existing proposal and creates new version\r\n    /// @param _proposalId Proposal id that details needs to be updated\r\n    /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n    function updateProposal(\r\n        uint _proposalId, \r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash\r\n    ) \r\n        external;\r\n\r\n    /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    function categorizeProposal(\r\n        uint _proposalId, \r\n        uint _categoryId,\r\n        uint _incentives\r\n    ) \r\n        external;\r\n\r\n    /// @dev Initiates add solution \r\n    /// @param _solutionHash Solution hash having required data against adding solution\r\n    function addSolution(\r\n        uint _proposalId,\r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external; \r\n\r\n    /// @dev Opens proposal for voting\r\n    function openProposalForVoting(uint _proposalId) external;\r\n\r\n    /// @dev Submit proposal with solution\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Creates a new proposal with solution and votes for the solution\r\n    /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external;\r\n\r\n    /// @dev Casts vote\r\n    /// @param _proposalId Proposal id\r\n    /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external;\r\n\r\n    function closeProposal(uint _proposalId) external;\r\n\r\n    function claimReward(address _memberAddress, uint _maxRecords) external returns(uint pendingDAppReward); \r\n\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalReward\r\n        );\r\n\r\n    function canCloseProposal(uint _proposalId) public view returns(uint closeValue);\r\n\r\n    function pauseProposal(uint _proposalId) public;\r\n    \r\n    function resumeProposal(uint _proposalId) public;\r\n    \r\n    function allowedToCatgorize() public view returns(uint roleId);\r\n\r\n}\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n */\r\ncontract Proxy {\r\n    /**\r\n    * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n    * This function will return whatever the implementation call returns\r\n    */\r\n    function () external payable {\r\n        address _impl = implementation();\r\n        require(_impl != address(0));\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize)\r\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n            let size := returndatasize\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n            }\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the implementation where every call will be delegated.\r\n    * @return address of the implementation to which it will be delegated\r\n    */\r\n    function implementation() public view returns (address);\r\n}\r\n\r\ncontract UpgradeabilityProxy is Proxy {\r\n    /**\r\n    * @dev This event will be emitted every time the implementation gets upgraded\r\n    * @param implementation representing the address of the upgraded implementation\r\n    */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    // Storage position of the address of the current implementation\r\n    bytes32 private constant IMPLEMENTATION_POSITION = keccak256(\"org.govblocks.proxy.implementation\");\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {}\r\n\r\n    /**\r\n    * @dev Tells the address of the current implementation\r\n    * @return address of the current implementation\r\n    */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n            impl := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the address of the current implementation\r\n    * @param _newImplementation address representing the new implementation to be set\r\n    */\r\n    function _setImplementation(address _newImplementation) internal {\r\n        bytes32 position = IMPLEMENTATION_POSITION;\r\n        assembly {\r\n        sstore(position, _newImplementation)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Upgrades the implementation address\r\n    * @param _newImplementation representing the address of the new implementation to be set\r\n    */\r\n    function _upgradeTo(address _newImplementation) internal {\r\n        address currentImplementation = implementation();\r\n        require(currentImplementation != _newImplementation);\r\n        _setImplementation(_newImplementation);\r\n        emit Upgraded(_newImplementation);\r\n    }\r\n}\r\n\r\n/**\r\n * @title OwnedUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n */\r\ncontract OwnedUpgradeabilityProxy is UpgradeabilityProxy {\r\n    /**\r\n    * @dev Event to show ownership has been transferred\r\n    * @param previousOwner representing the address of the previous owner\r\n    * @param newOwner representing the address of the new owner\r\n    */\r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    // Storage position of the owner of the contract\r\n    bytes32 private constant PROXY_OWNER_POSITION = keccak256(\"org.govblocks.proxy.owner\");\r\n\r\n    /**\r\n    * @dev the constructor sets the original owner of the contract to the sender account.\r\n    */\r\n    constructor(address _implementation) public {\r\n        _setUpgradeabilityOwner(msg.sender);\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Tells the address of the owner\r\n    * @return the address of the owner\r\n    */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\r\n        require(_newOwner != address(0));\r\n        _setUpgradeabilityOwner(_newOwner);\r\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the proxy owner to upgrade the current version of the proxy.\r\n    * @param _implementation representing the address of the new implementation to be set.\r\n    */\r\n    function upgradeTo(address _implementation) public onlyProxyOwner {\r\n        _upgradeTo(_implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n    */\r\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\r\n        bytes32 position = PROXY_OWNER_POSITION;\r\n        assembly {\r\n            sstore(position, _newProxyOwner)\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract SOTEMaster is Governed {\r\n    using SafeMath for uint;\r\n\r\n    struct EmergencyPause {\r\n        bool pause;\r\n        uint time;\r\n        bytes4 by;\r\n    }\r\n\r\n    EmergencyPause[] public emergencyPaused;\r\n\r\n    bytes2[] internal allContractNames;\r\n    mapping(address => bool) public contractsActive;\r\n    mapping(bytes2 => address payable) internal allContractVersions;\r\n    mapping(bytes2 => bool) public isProxy;\r\n    mapping(bytes2 => bool) public isUpgradable;\r\n\r\n    address public tokenAddress;\r\n\r\n    bool internal reentrancyLock;\r\n\r\n\r\n    bool public masterInitialized;\r\n    address public owner;\r\n    uint public pauseTime;\r\n    bool constructorCheck;\r\n\r\n    modifier noReentrancy() {\r\n        require(!reentrancyLock, \"Reentrant call.\");\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n    /// @dev to initiate master data\r\n    /// @param _tokenAdd SOTE token address.\r\n    function initiateMaster(address _tokenAdd,address payable _govAdd) external {\r\n\r\n        OwnedUpgradeabilityProxy proxy =  OwnedUpgradeabilityProxy(address(uint160(address(this))));\r\n        require(msg.sender == proxy.proxyOwner(),\"Sender is not proxy owner.\");\r\n        require(!constructorCheck,\"Constructor already ran.\");\r\n        constructorCheck = true;\r\n        tokenAddress = _tokenAdd;\r\n        owner = msg.sender;\r\n        masterAddress = address(this);\r\n        contractsActive[address(this)] = true;\r\n        pauseTime = 28 days; //4 weeks\r\n        \r\n        // 1. init gov \r\n        allContractNames.push(\"GV\");\r\n        allContractVersions[\"GV\"] = _govAdd;\r\n        contractsActive[_govAdd] = true;\r\n        isProxy[\"GV\"] = true;\r\n        \r\n        // 2. set masterInitialized\r\n        masterInitialized = true;\r\n        \r\n    }\r\n\r\n    function upgradeMultipleImplementations(\r\n        bytes2[] calldata _contractNames,\r\n        address[] calldata _contractAddresses\r\n        ) \r\n        external \r\n        onlyAuthorizedToGovern \r\n    {\r\n        require(_contractNames.length == _contractAddresses.length,\"Array length should be equal.\");\r\n        for (uint i=0; i < _contractNames.length; i++) {\r\n            require(_contractAddresses[i] != address(0),\"null address is not allowed.\");\r\n            require(isProxy[_contractNames[i]],\"Contract should be proxy.\");\r\n            OwnedUpgradeabilityProxy proxy = OwnedUpgradeabilityProxy(allContractVersions[_contractNames[i]]);\r\n            proxy.upgradeTo(_contractAddresses[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Adds new internal contract\r\n    /// @param _type pass 1 if contract is upgradable, 2 if contract is proxy, any other uint if none.\r\n    function addNewInternalContract(\r\n        bytes2 _contractName,\r\n        address payable _contractAddress,\r\n        uint _type\r\n        ) \r\n    external \r\n    onlyAuthorizedToGovern {\r\n        require(allContractVersions[_contractName] == address(0),\"Contract code is already available.\");\r\n        require(_contractAddress != address(0),\"NULL address is not allowed.\");\r\n        allContractNames.push(_contractName);\r\n        address newInternalContract = _contractAddress; // Using extra varible to get rid of if condition.\r\n        if (_type == 1) {\r\n            isUpgradable[_contractName] = true;\r\n        } else if (_type == 2) {\r\n            newInternalContract = _generateProxy(_contractAddress);\r\n            isProxy[_contractName] = true;\r\n        }\r\n        allContractVersions[_contractName] = address(uint160(newInternalContract));\r\n        contractsActive[newInternalContract] = true;\r\n        Iupgradable up = Iupgradable(allContractVersions[_contractName]);\r\n        up.changeMasterAddress(address(this));\r\n        up.changeDependentContractAddress();\r\n    }\r\n\r\n    /**\r\n     * @dev Anyone can close a claim if oraclize fails to close it.\r\n     * @param _claimId id of claim to be closed.\r\n     */ \r\n    function closeClaim(uint _claimId) external {\r\n\r\n        require(canCall(_claimId), \"Payout retry time not reached.\");\r\n        ClaimsReward cr = ClaimsReward(getLatestAddress(\"CR\"));\r\n        cr.changeClaimStatus(_claimId);\r\n    }\r\n\r\n    /**\r\n     * @dev  Handles the oraclize query callback.\r\n     * @param myid ID of oraclize query to be processed\r\n     */ \r\n    function delegateCallBack(bytes32 myid) external noReentrancy {\r\n        PoolData pd = PoolData(getLatestAddress(\"PD\"));\r\n        uint callTime = pd.getDateUpdOfAPI(myid);\r\n        uint dateAdd = pd.getDateAddOfAPI(myid);\r\n        require(callTime == dateAdd, \"Callback already received\");\r\n\r\n        bytes4 res = pd.getApiIdTypeOf(myid);\r\n        pd.updateDateUpdOfAPI(myid);\r\n\r\n        if (isPause()) {\r\n\r\n            bytes4 by;\r\n            (, , by) = getLastEmergencyPause();\r\n\r\n            require(res == \"EP\", \"Only callback of type EP is allowed during emergency pause\");\r\n            require(callTime.add(pauseTime) < now, \"Callback was called too soon\");\r\n            require(by == \"AB\", \"Emergency paused was not started by Advisory Board\");\r\n\r\n            addEmergencyPause(false, \"AUT\");\r\n            return;\r\n        }\r\n\r\n        uint id = pd.getIdOfApiId(myid);\r\n\r\n        if (res == \"COV\") {\r\n            Quotation qt = Quotation(getLatestAddress(\"QT\"));\r\n            qt.expireCover(id);\r\n            return;\r\n        }\r\n\r\n        if (res == \"CLA\") {\r\n            require(canCall(id), \"Payout retry time not reached\");\r\n            ClaimsReward cr = ClaimsReward(getLatestAddress(\"CR\"));\r\n            cr.changeClaimStatus(id);\r\n            return;\r\n        }\r\n\r\n        if (res == \"MCRF\") {\r\n            require(callTime.add(pd.mcrFailTime()) < now, \"MCR posting time not reached\");\r\n            MCR m1 = MCR(getLatestAddress(\"MC\"));\r\n            m1.addLastMCRData(uint64(id));\r\n            return;\r\n        }\r\n\r\n        if (res == \"ULT\") {\r\n            require(callTime.add(pd.liquidityTradeCallbackTime()) < now, \"Liquidity trade time not reached\");\r\n            Pool2 p2 = Pool2(getLatestAddress(\"P2\"));\r\n            p2.externalLiquidityTrade();\r\n            return;\r\n        }\r\n\r\n        if (res == \"MCR\" || res == \"IARB\") {\r\n            return;\r\n        }\r\n\r\n        revert(\"Invalid callback\");\r\n    }\r\n\r\n    function getOwnerParameters(bytes8 code) external view returns(bytes8 codeVal, address val) {\r\n        codeVal = code;\r\n        QuotationData qd;\r\n        PoolData pd;\r\n        if (code == \"MSWALLET\") {\r\n            TokenData td;\r\n            td = TokenData(getLatestAddress(\"TD\"));\r\n            val = td.walletAddress();\r\n\r\n        } else if (code == \"MCRNOTA\") {\r\n            \r\n            pd = PoolData(getLatestAddress(\"PD\"));\r\n            val = pd.notariseMCR();\r\n\r\n        } else if (code == \"DAIFEED\") {\r\n            pd = PoolData(getLatestAddress(\"PD\"));\r\n            val = pd.daiFeedAddress();\r\n\r\n        } else if (code == \"UNISWADD\") {\r\n            Pool2 p2;\r\n            p2 = Pool2(getLatestAddress(\"P2\"));\r\n            val = p2.uniswapFactoryAddress();\r\n\r\n        } else if (code == \"OWNER\") {\r\n\r\n            val = owner;\r\n\r\n        } else if (code == \"QUOAUTH\") {\r\n            \r\n            qd = QuotationData(getLatestAddress(\"QD\"));\r\n            val = qd.authQuoteEngine();\r\n\r\n        } else if (code == \"KYCAUTH\") {\r\n            qd = QuotationData(getLatestAddress(\"QD\"));\r\n            val = qd.kycAuthAddress();\r\n\r\n        }\r\n        \r\n    }\r\n\r\n    /// @dev Add Emergency pause\r\n    /// @param _pause to set Emergency Pause ON/OFF\r\n    /// @param _by to set who Start/Stop EP\r\n    function addEmergencyPause(bool _pause, bytes4 _by) public {\r\n        require(_by == \"AB\" || _by == \"AUT\",\"Invalid call.\");\r\n        require(msg.sender == getLatestAddress(\"P1\") || msg.sender == getLatestAddress(\"GV\"),\"Callable by P1 and GV only.\");\r\n        emergencyPaused.push(EmergencyPause(_pause, now, _by));\r\n        if (_pause == false) {\r\n            Claims c1 = Claims(allContractVersions[\"CL\"]);\r\n            c1.submitClaimAfterEPOff(); // Process claims submitted while EP was on\r\n            c1.startAllPendingClaimsVoting(); // Resume voting on all pending claims\r\n        }\r\n    }\r\n\r\n    ///@dev update time in seconds for which emergency pause is applied.\r\n    function updatePauseTime(uint _time) public {\r\n\r\n        require(isInternal(msg.sender),\"Not internal call.\");\r\n        pauseTime = _time;\r\n    }\r\n    \r\n    /// @dev upgrades All Address at a time\r\n    function upgradeAllAddress() \r\n    public \r\n    onlyAuthorizedToGovern\r\n    {\r\n        _changeAllAddress();\r\n    }\r\n    \r\n    function changeAllAddress(uint8 start,uint8 end) public \r\n    {\r\n        uint i;\r\n        for (i = start; i < end; i++) {\r\n            contractsActive[allContractVersions[allContractNames[i]]] = true;\r\n            Iupgradable up = Iupgradable(allContractVersions[allContractNames[i]]);\r\n            up.changeDependentContractAddress(); \r\n        }\r\n    }\r\n    \r\n    /// @dev upgrades contract at a time\r\n    function upgradeContract(\r\n        bytes2 _contractsName,\r\n        address payable _contractsAddress\r\n        ) \r\n    public \r\n    onlyAuthorizedToGovern\r\n    {\r\n        \r\n        address payable oldAddress = allContractVersions[_contractsName];\r\n        contractsActive[oldAddress] = false;\r\n        allContractVersions[_contractsName] = _contractsAddress;\r\n        contractsActive[_contractsAddress] = true;\r\n\r\n        Iupgradable up = Iupgradable(allContractVersions[_contractsName]);\r\n        up.changeMasterAddress(address(this));\r\n    }\r\n\r\n    /// @dev upgrades multiple contracts at a time\r\n    function upgradeMultipleContracts(\r\n        bytes2[] memory _contractsName,\r\n        address payable[] memory _contractsAddress\r\n        ) \r\n    public \r\n    onlyAuthorizedToGovern\r\n    {\r\n        require(_contractsName.length == _contractsAddress.length, \"Array length should be equal.\");\r\n        \r\n        for (uint i=0; i<_contractsName.length; i++) {\r\n            address payable newAddress = _contractsAddress[i];\r\n            require(newAddress != address(0),\"NULL address is not allowed.\");\r\n            require(isUpgradable[_contractsName[i]],\"Contract should be upgradable.\");\r\n            if (_contractsName[i] == \"QT\") {\r\n                Quotation qt = Quotation(allContractVersions[\"QT\"]);\r\n                qt.transferAssetsToNewContract(newAddress);\r\n\r\n            } else if (_contractsName[i] == \"CR\") {\r\n                TokenController tc = TokenController(getLatestAddress(\"TC\"));\r\n                tc.addToWhitelist(newAddress);\r\n                tc.removeFromWhitelist(allContractVersions[\"CR\"]);\r\n                ClaimsReward cr = ClaimsReward(allContractVersions[\"CR\"]);\r\n                cr.upgrade(newAddress);\r\n\r\n            } else if (_contractsName[i] == \"P1\") {\r\n                Pool1 p1 = Pool1(allContractVersions[\"P1\"]);\r\n                p1.upgradeCapitalPool(newAddress);\r\n\r\n\r\n            } else if (_contractsName[i] == \"P2\") {\r\n                Pool2 p2 = Pool2(allContractVersions[\"P2\"]);\r\n                p2.upgradeInvestmentPool(newAddress);\r\n\r\n            }\r\n\r\n            address payable oldAddress = allContractVersions[_contractsName[i]];\r\n            contractsActive[oldAddress] = false;\r\n            allContractVersions[_contractsName[i]] = newAddress;\r\n            contractsActive[newAddress] = true;\r\n\r\n            Iupgradable up = Iupgradable(allContractVersions[_contractsName[i]]);\r\n            up.changeMasterAddress(address(this));\r\n        }\r\n\r\n        _changeAllAddress();\r\n    }\r\n\r\n    /// @dev checks whether the address is an internal contract address.\r\n    function isInternal(address _contractAddress) public view returns(bool) {\r\n        return contractsActive[_contractAddress];\r\n    }\r\n\r\n    /// @dev checks whether the address is the Owner or not.\r\n    function isOwner(address _address) public view returns(bool) {\r\n        return owner == _address;\r\n    }\r\n\r\n    /// @dev Checks whether emergency pause id on/not.\r\n    function isPause() public view returns(bool) {\r\n        uint length = emergencyPaused.length;\r\n        return length > 0 && emergencyPaused[length - 1].pause;\r\n    }\r\n\r\n    /// @dev checks whether the address is a member of the mutual or not.\r\n    function isMember(address _add) public view returns(bool) {\r\n        MemberRoles mr = MemberRoles(getLatestAddress(\"MR\"));\r\n        return mr.checkRole(_add, uint(MemberRoles.Role.Member));\r\n    }\r\n\r\n    ///@dev Gets the number of emergency pause has been toggled.\r\n    function getEmergencyPausedLength() public view returns(uint len) {\r\n        len = emergencyPaused.length;\r\n    }\r\n\r\n    ///@dev Gets last emergency pause details.\r\n    function getLastEmergencyPause() public view returns(bool _pause, uint _time, bytes4 _by) {\r\n        _pause = false;\r\n        _time = 0;\r\n        _by = \"\";\r\n        uint len = getEmergencyPausedLength();\r\n        if (len > 0) {\r\n            len = len.sub(1);\r\n            _pause = emergencyPaused[len].pause;\r\n            _time = emergencyPaused[len].time;\r\n            _by = emergencyPaused[len].by;\r\n        }\r\n    }\r\n\r\n    /// @dev Gets latest version name and address\r\n    /// @return contractsName Latest version's contract names\r\n    /// @return contractsAddress Latest version's contract addresses\r\n    function getVersionData() \r\n        public \r\n        view \r\n        returns (\r\n            bytes2[] memory contractsName,\r\n            address[] memory contractsAddress\r\n        ) \r\n    {\r\n        contractsName = allContractNames;\r\n        contractsAddress = new address[](allContractNames.length);\r\n\r\n        for (uint i = 0; i < allContractNames.length; i++) {\r\n            contractsAddress[i] = allContractVersions[allContractNames[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev returns the address of token controller \r\n     * @return address is returned\r\n     */\r\n    function dAppLocker() public view returns(address _add) {\r\n\r\n        _add = getLatestAddress(\"TC\");\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev returns the address of sote token \r\n     * @return address is returned\r\n     */\r\n    function dAppToken() public view returns(address _add) {\r\n        _add = tokenAddress;\r\n    }\r\n\r\n    /// @dev Gets latest contract address\r\n    /// @param _contractName Contract name to fetch\r\n    function getLatestAddress(bytes2 _contractName) public view returns(address payable contractAddress) {\r\n        contractAddress = allContractVersions[_contractName];\r\n    }\r\n\r\n    /// @dev Creates a new version of contract addresses\r\n    /// @param _contractAddresses Array of contract addresses which will be generated\r\n    function addNewVersion(address payable[] memory _contractAddresses) public {\r\n\r\n        require(msg.sender == owner && !masterInitialized,\"Caller should be owner and should only be called once.\");\r\n        require(_contractAddresses.length == allContractNames.length, \"array length not same\");\r\n        masterInitialized = true;\r\n\r\n        MemberRoles mr = MemberRoles(_contractAddresses[14]);   \r\n        // shoud send proxy address for proxy contracts (if not 1st time deploying) \r\n        // bool isMasterUpgrade = mr.soteMasterAddress() != address(0);\r\n\r\n        for (uint i = 0; i < allContractNames.length; i++) {\r\n            require(_contractAddresses[i] != address(0),\"NULL address is not allowed.\");\r\n            allContractVersions[allContractNames[i]] = _contractAddresses[i];\r\n            contractsActive[_contractAddresses[i]] = true;\r\n\r\n        }\r\n\r\n        // Need to override owner as owner in MR to avoid inconsistency as owner in MR is some other address. \r\n        (, address[] memory mrOwner) = mr.members(uint(MemberRoles.Role.Owner));\r\n        owner = mrOwner[0];\r\n    }\r\n\r\n    /**\r\n     * @dev to check if the address is authorized to govern or not \r\n     * @param _add is the address in concern\r\n     * @return the boolean status status for the check\r\n     */\r\n    function checkIsAuthToGoverned(address _add) public view returns(bool) {\r\n        return isAuthorizedToGovern(_add);\r\n    }\r\n\r\n    /// @dev Allow AB Members to Start Emergency Pause\r\n    function startEmergencyPause() public  onlyAuthorizedToGovern {\r\n        addEmergencyPause(true, \"AB\"); //Start Emergency Pause\r\n        Pool1 p1 = Pool1(allContractVersions[\"P1\"]);\r\n        p1.closeEmergencyPause(pauseTime); //oraclize callback of 4 weeks\r\n        Claims c1 = Claims(allContractVersions[\"CL\"]);\r\n        c1.pauseAllPendingClaimsVoting(); //Pause Voting of all pending Claims\r\n    }\r\n    \r\n    /**\r\n     * @dev to update the owner parameters \r\n     * @param code is the associated code \r\n     * @param val is value to be set\r\n     */\r\n    function updateOwnerParameters(bytes8 code, address payable val) public onlyAuthorizedToGovern {\r\n        QuotationData qd;\r\n        PoolData pd;\r\n        if (code == \"MSWALLET\") {\r\n            TokenData td;\r\n            td = TokenData(getLatestAddress(\"TD\"));\r\n            td.changeWalletAddress(val);\r\n\r\n        } else if (code == \"MCRNOTA\") {\r\n            \r\n            pd = PoolData(getLatestAddress(\"PD\"));\r\n            pd.changeNotariseAddress(val);\r\n\r\n        } else if (code == \"DAIFEED\") {\r\n            pd = PoolData(getLatestAddress(\"PD\"));\r\n            pd.changeDAIfeedAddress(val);\r\n\r\n        } else if (code == \"UNISWADD\") {\r\n            Pool2 p2;\r\n            p2 = Pool2(getLatestAddress(\"P2\"));\r\n            p2.changeUniswapFactoryAddress(val);\r\n\r\n        } else if (code == \"OWNER\") {\r\n\r\n            MemberRoles mr = MemberRoles(getLatestAddress(\"MR\"));\r\n            mr.swapOwner(val);\r\n            owner = val;\r\n\r\n        } else if (code == \"QUOAUTH\") {\r\n            \r\n            qd = QuotationData(getLatestAddress(\"QD\"));\r\n            qd.changeAuthQuoteEngine(val);\r\n\r\n        } else if (code == \"KYCAUTH\") {\r\n            qd = QuotationData(getLatestAddress(\"QD\"));\r\n            qd.setKycAuthAddress(val);\r\n\r\n        } else {\r\n            revert(\"Invalid param code\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev to generater proxy \r\n     * @param _implementationAddress of the proxy\r\n     */\r\n    function _generateProxy(address _implementationAddress) internal returns(address) {\r\n        OwnedUpgradeabilityProxy proxy = new OwnedUpgradeabilityProxy(_implementationAddress);\r\n        return address(proxy);\r\n    }\r\n    \r\n\r\n    /// @dev Sets the older versions of contract addresses as inactive and the latest one as active.\r\n    function _changeAllAddress() internal {\r\n        uint i;\r\n        for (i = 0; i < allContractNames.length; i++) {\r\n            \r\n            contractsActive[allContractVersions[allContractNames[i]]] = true;\r\n            Iupgradable up = Iupgradable(allContractVersions[allContractNames[i]]);\r\n            up.changeDependentContractAddress(); \r\n        }\r\n    }\r\n\r\n    function canCall(uint _claimId) internal view returns(bool)\r\n    {\r\n        ClaimsData cd = ClaimsData(getLatestAddress(\"CD\"));\r\n        (, , , uint status, uint dateUpd, ) = cd.getClaim(_claimId);\r\n        if (status == 12) {\r\n            if (dateUpd.add(cd.payoutRetryTime()) > now) {\r\n                return false;\r\n            } \r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n// /* Copyright (C) 2017 GovBlocks.io\r\n//   This program is free software: you can redistribute it and/or modify\r\n//     it under the terms of the GNU General Public License as published by\r\n//     the Free Software Foundation, either version 3 of the License, or\r\n//     (at your option) any later version.\r\n//   This program is distributed in the hope that it will be useful,\r\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n//     GNU General Public License for more details.\r\n//   You should have received a copy of the GNU General Public License\r\n//     along with this program.  If not, see http://www.gnu.org/licenses/ */\r\ncontract Governance is IGovernance, Iupgradable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    enum ProposalStatus { \r\n        Draft,\r\n        AwaitingSolution,\r\n        VotingStarted,\r\n        Accepted,\r\n        Rejected,\r\n        Majority_Not_Reached_But_Accepted,\r\n        Denied\r\n    }\r\n\r\n    struct ProposalData {\r\n        uint propStatus;\r\n        uint finalVerdict;\r\n        uint category;\r\n        uint commonIncentive;\r\n        uint dateUpd;\r\n        address owner;\r\n    }\r\n\r\n    struct ProposalVote {\r\n        address voter;\r\n        uint proposalId;\r\n        uint dateAdd;\r\n    }\r\n\r\n    struct VoteTally {\r\n        mapping(uint=>uint) memberVoteValue;\r\n        mapping(uint=>uint) abVoteValue;\r\n        uint voters;\r\n    }\r\n\r\n    struct DelegateVote {\r\n        address follower;\r\n        address leader;\r\n        uint lastUpd;\r\n    }\r\n\r\n    ProposalVote[] internal allVotes;\r\n    DelegateVote[] public allDelegation;\r\n\r\n    mapping(uint => ProposalData) internal allProposalData;\r\n    mapping(uint => bytes[]) internal allProposalSolutions;\r\n    mapping(address => uint[]) internal allVotesByMember;\r\n    mapping(uint => mapping(address => bool)) public rewardClaimed;\r\n    mapping (address => mapping(uint => uint)) public memberProposalVote;\r\n    mapping (address => uint) public followerDelegation;\r\n    mapping (address => uint) internal followerCount;\r\n    mapping (address => uint[]) internal leaderDelegation;\r\n    mapping (uint => VoteTally) public proposalVoteTally;\r\n    mapping (address => bool) public isOpenForDelegation;\r\n    mapping (address => uint) public lastRewardClaimed;\r\n\r\n    bool public constructorCheck;\r\n    uint public tokenHoldingTime;\r\n    uint internal roleIdAllowedToCatgorize;\r\n    uint internal maxVoteWeigthPer;\r\n    uint internal specialResolutionMajPerc;\r\n    uint internal maxFollowers;\r\n    uint internal totalProposals;\r\n    uint internal maxDraftTime;\r\n\r\n    MemberRoles internal memberRole;\r\n    ProposalCategory internal proposalCategory;\r\n    TokenController internal tokenInstance;\r\n\r\n    mapping(uint => uint) public proposalActionStatus;\r\n    mapping(uint => uint) internal proposalExecutionTime;\r\n    mapping(uint => mapping(address => bool)) public proposalRejectedByAB;\r\n    mapping(uint => uint) internal actionRejectedCount;\r\n\r\n    bool internal actionParamsInitialised;\r\n    uint internal actionWaitingTime;\r\n    uint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\r\n\r\n    enum ActionStatus {\r\n        Pending,\r\n        Accepted,\r\n        Rejected,\r\n        Executed,\r\n        NoAction\r\n    }\r\n\r\n    /**\r\n    * @dev Called whenever an action execution is failed.\r\n    */\r\n    event ActionFailed (\r\n        uint256 proposalId\r\n    );\r\n\r\n    /**\r\n    * @dev Called whenever an AB member rejects the action execution.\r\n    */\r\n    event ActionRejected (\r\n        uint256 indexed proposalId,\r\n        address rejectedBy\r\n    );\r\n\r\n    /**\r\n    * @dev Checks if msg.sender is proposal owner\r\n    */\r\n    modifier onlyProposalOwner(uint _proposalId) {\r\n        require(msg.sender == allProposalData[_proposalId].owner, \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if proposal is opened for voting\r\n    */\r\n    modifier voteNotStarted(uint _proposalId) {\r\n        require(allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if msg.sender is allowed to create proposal under given category\r\n    */\r\n    modifier isAllowed(uint _categoryId) {\r\n        require(allowedToCreateProposal(_categoryId), \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if msg.sender is allowed categorize proposal under given category\r\n    */\r\n    modifier isAllowedToCategorize() {\r\n        require(memberRole.checkRole(msg.sender, roleIdAllowedToCatgorize), \"Not allowed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if msg.sender had any pending rewards to be claimed\r\n    */\r\n    modifier checkPendingRewards {\r\n        require(getPendingReward(msg.sender) == 0, \"Claim reward\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Event emitted whenever a proposal is categorized\r\n    */\r\n    event ProposalCategorized(\r\n        uint indexed proposalId,\r\n        address indexed categorizedBy,\r\n        uint categoryId\r\n    );\r\n    \r\n    /**\r\n     * @dev Removes delegation of an address.\r\n     * @param _add address to undelegate.\r\n     */\r\n    function removeDelegation(address _add) external onlyInternal {\r\n        _unDelegate(_add);\r\n    }\r\n\r\n    /**\r\n    * @dev Creates a new proposal\r\n    * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    */\r\n    function createProposal(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash, \r\n        uint _categoryId\r\n    ) \r\n        external isAllowed(_categoryId)\r\n    {\r\n        require(ms.isMember(msg.sender), \"Not Member\");\r\n\r\n        _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n    }\r\n\r\n    /**\r\n    * @dev Edits the details of an existing proposal\r\n    * @param _proposalId Proposal id that details needs to be updated\r\n    * @param _proposalDescHash Proposal description hash having long and short description of proposal.\r\n    */\r\n    function updateProposal(\r\n        uint _proposalId, \r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash\r\n    ) \r\n        external onlyProposalOwner(_proposalId)\r\n    {\r\n        require(\r\n            allProposalSolutions[_proposalId].length < 2,\r\n            \"Not allowed\"\r\n        );\r\n        allProposalData[_proposalId].propStatus = uint(ProposalStatus.Draft);\r\n        allProposalData[_proposalId].category = 0;\r\n        allProposalData[_proposalId].commonIncentive = 0;\r\n        emit Proposal(\r\n            allProposalData[_proposalId].owner,\r\n            _proposalId,\r\n            now,\r\n            _proposalTitle, \r\n            _proposalSD, \r\n            _proposalDescHash\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\r\n    */\r\n    function categorizeProposal(\r\n        uint _proposalId,\r\n        uint _categoryId,\r\n        uint _incentive\r\n    )\r\n        external\r\n        voteNotStarted(_proposalId) isAllowedToCategorize\r\n    {\r\n        _categorizeProposal(_proposalId, _categoryId, _incentive);\r\n    }\r\n\r\n    /**\r\n    * @dev Initiates add solution\r\n    * To implement the governance interface\r\n    */\r\n    function addSolution(uint, string calldata, bytes calldata) external {\r\n    }\r\n\r\n    /**\r\n    * @dev Opens proposal for voting\r\n    * To implement the governance interface\r\n    */\r\n    function openProposalForVoting(uint) external {\r\n    }\r\n\r\n    /**\r\n    * @dev Submit proposal with solution\r\n    * @param _proposalId Proposal id\r\n    * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    */\r\n    function submitProposalWithSolution(\r\n        uint _proposalId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external\r\n        onlyProposalOwner(_proposalId)\r\n    {\r\n\r\n        require(allProposalData[_proposalId].propStatus == uint(ProposalStatus.AwaitingSolution));\r\n        \r\n        _proposalSubmission(_proposalId, _solutionHash, _action);\r\n    }\r\n\r\n    /**\r\n    * @dev Creates a new proposal with solution\r\n    * @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\r\n    * @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\r\n    * @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\r\n    */\r\n    function createProposalwithSolution(\r\n        string calldata _proposalTitle, \r\n        string calldata _proposalSD, \r\n        string calldata _proposalDescHash,\r\n        uint _categoryId, \r\n        string calldata _solutionHash, \r\n        bytes calldata _action\r\n    ) \r\n        external isAllowed(_categoryId)\r\n    {\r\n\r\n\r\n        uint proposalId = totalProposals;\r\n\r\n        _createProposal(_proposalTitle, _proposalSD, _proposalDescHash, _categoryId);\r\n        \r\n        require(_categoryId > 0);\r\n\r\n        _proposalSubmission(\r\n            proposalId,\r\n            _solutionHash,\r\n            _action\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Submit a vote on the proposal.\r\n     * @param _proposalId to vote upon.\r\n     * @param _solutionChosen is the chosen vote.\r\n     */\r\n    function submitVote(uint _proposalId, uint _solutionChosen) external {\r\n        \r\n        require(allProposalData[_proposalId].propStatus == \r\n        uint(Governance.ProposalStatus.VotingStarted), \"Not allowed\");\r\n\r\n        require(_solutionChosen < allProposalSolutions[_proposalId].length);\r\n\r\n\r\n        _submitVote(_proposalId, _solutionChosen);\r\n    }\r\n\r\n    /**\r\n     * @dev Closes the proposal.\r\n     * @param _proposalId of proposal to be closed.\r\n     */\r\n    function closeProposal(uint _proposalId) external {\r\n        uint category = allProposalData[_proposalId].category;\r\n        \r\n        \r\n        uint _memberRole;\r\n        if (allProposalData[_proposalId].dateUpd.add(maxDraftTime) <= now && \r\n            allProposalData[_proposalId].propStatus < uint(ProposalStatus.VotingStarted)) {\r\n            _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        } else {\r\n            require(canCloseProposal(_proposalId) == 1);\r\n            (, _memberRole, , , , , ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n            if (_memberRole == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n                _closeAdvisoryBoardVote(_proposalId, category);\r\n            } else {\r\n                _closeMemberVote(_proposalId, category);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev Claims reward for member.\r\n     * @param _memberAddress to claim reward of.\r\n     * @param _maxRecords maximum number of records to claim reward for.\r\n     _proposals list of proposals of which reward will be claimed.\r\n     * @return amount of pending reward.\r\n     */\r\n    function claimReward(address _memberAddress, uint _maxRecords) \r\n        external returns(uint pendingDAppReward) \r\n    {\r\n        \r\n        uint voteId;\r\n        address leader;\r\n        uint lastUpd;\r\n\r\n        require(msg.sender == ms.getLatestAddress(\"CR\"));\r\n\r\n        uint delegationId = followerDelegation[_memberAddress];\r\n        DelegateVote memory delegationData = allDelegation[delegationId];\r\n        if (delegationId > 0 && delegationData.leader != address(0)) {\r\n            leader = delegationData.leader;\r\n            lastUpd = delegationData.lastUpd;\r\n        } else\r\n            leader = _memberAddress;\r\n\r\n        uint proposalId;\r\n        uint totalVotes = allVotesByMember[leader].length;\r\n        uint lastClaimed = totalVotes;\r\n        uint j;\r\n        uint i;\r\n        for (i = lastRewardClaimed[_memberAddress]; i < totalVotes && j < _maxRecords; i++) {\r\n            voteId = allVotesByMember[leader][i];\r\n            proposalId = allVotes[voteId].proposalId;\r\n            if (proposalVoteTally[proposalId].voters > 0 && (allVotes[voteId].dateAdd > (\r\n                lastUpd.add(tokenHoldingTime)) || leader == _memberAddress)) {\r\n                if (allProposalData[proposalId].propStatus > uint(ProposalStatus.VotingStarted)) {\r\n                    if (!rewardClaimed[voteId][_memberAddress]) {\r\n                        pendingDAppReward = pendingDAppReward.add(\r\n                                allProposalData[proposalId].commonIncentive.div(\r\n                                    proposalVoteTally[proposalId].voters\r\n                                )\r\n                            );\r\n                        rewardClaimed[voteId][_memberAddress] = true;\r\n                        j++;\r\n                    }\r\n                } else {\r\n                    if (lastClaimed == totalVotes) {\r\n                        lastClaimed = i;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (lastClaimed == totalVotes) {\r\n            lastRewardClaimed[_memberAddress] = i;\r\n        } else {\r\n            lastRewardClaimed[_memberAddress] = lastClaimed;\r\n        }\r\n\r\n        if (j > 0) {\r\n            emit RewardClaimed(\r\n                _memberAddress,\r\n                pendingDAppReward\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets delegation acceptance status of individual user\r\n     * @param _status delegation acceptance status\r\n     */\r\n    function setDelegationStatus(bool _status) external isMemberAndcheckPause checkPendingRewards {\r\n        isOpenForDelegation[msg.sender] = _status;\r\n    }\r\n\r\n    /**\r\n     * @dev Delegates vote to an address.\r\n     * @param _add is the address to delegate vote to.\r\n     */\r\n    function delegateVote(address _add) external isMemberAndcheckPause checkPendingRewards {\r\n\r\n        require(ms.masterInitialized());\r\n\r\n        require(allDelegation[followerDelegation[_add]].leader == address(0));\r\n\r\n        if (followerDelegation[msg.sender] > 0) {\r\n            require((allDelegation[followerDelegation[msg.sender]].lastUpd).add(tokenHoldingTime) < now);\r\n        }\r\n\r\n        require(!alreadyDelegated(msg.sender));\r\n        require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.Owner)));\r\n        require(!memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)));\r\n\r\n\r\n        require(followerCount[_add] < maxFollowers);\r\n        \r\n        if (allVotesByMember[msg.sender].length > 0) {\r\n            require((allVotes[allVotesByMember[msg.sender][allVotesByMember[msg.sender].length - 1]].dateAdd).add(tokenHoldingTime)\r\n            < now);\r\n        }\r\n\r\n        require(ms.isMember(_add));\r\n\r\n        require(isOpenForDelegation[_add]);\r\n\r\n        allDelegation.push(DelegateVote(msg.sender, _add, now));\r\n        followerDelegation[msg.sender] = allDelegation.length - 1;\r\n        leaderDelegation[_add].push(allDelegation.length - 1);\r\n        followerCount[_add]++;\r\n        lastRewardClaimed[msg.sender] = allVotesByMember[_add].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Undelegates the sender\r\n     */\r\n    function unDelegate() external isMemberAndcheckPause checkPendingRewards {\r\n        _unDelegate(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers action of accepted proposal after waiting time is finished\r\n     */\r\n    function triggerAction(uint _proposalId) external {\r\n        require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted) && proposalExecutionTime[_proposalId] <= now, \"Cannot trigger\");\r\n        _triggerAction(_proposalId, allProposalData[_proposalId].category);\r\n    }\r\n\r\n    /**\r\n     * @dev Provides option to Advisory board member to reject proposal action execution within actionWaitingTime, if found suspicious\r\n     */\r\n    function rejectAction(uint _proposalId) external {\r\n        require(memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && proposalExecutionTime[_proposalId] > now);\r\n\r\n        require(proposalActionStatus[_proposalId] == uint(ActionStatus.Accepted));\r\n\r\n        require(!proposalRejectedByAB[_proposalId][msg.sender]);\r\n\r\n        require(\r\n            keccak256(proposalCategory.categoryActionHashes(allProposalData[_proposalId].category))\r\n            != keccak256(abi.encodeWithSignature(\"swapABMember(address,address)\"))\r\n        );\r\n\r\n        proposalRejectedByAB[_proposalId][msg.sender] = true;\r\n        actionRejectedCount[_proposalId]++;\r\n        emit ActionRejected(_proposalId, msg.sender);\r\n        if (actionRejectedCount[_proposalId] == AB_MAJ_TO_REJECT_ACTION) {\r\n            proposalActionStatus[_proposalId] = uint(ActionStatus.Rejected);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets intial actionWaitingTime value\r\n     * To be called after governance implementation has been updated\r\n     */\r\n    function setInitialActionParameters() external onlyOwner {\r\n        require(!actionParamsInitialised);\r\n        actionParamsInitialised = true;\r\n        actionWaitingTime = 24 * 1 hours;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Uint Parameters of a code\r\n     * @param code whose details we want\r\n     * @return string value of the code\r\n     * @return associated amount (time or perc or value) to the code\r\n     */\r\n    function getUintParameters(bytes8 code) external view returns(bytes8 codeVal, uint val) {\r\n\r\n        codeVal = code;\r\n\r\n        if (code == \"GOVHOLD\") {\r\n\r\n            val = tokenHoldingTime / (1 days);\r\n\r\n        } else if (code == \"MAXFOL\") {\r\n\r\n            val = maxFollowers;\r\n\r\n        } else if (code == \"MAXDRFT\") {\r\n\r\n            val = maxDraftTime / (1 days);\r\n\r\n        } else if (code == \"EPTIME\") {\r\n\r\n            val = ms.pauseTime() / (1 days);\r\n\r\n        } else if (code == \"ACWT\") {\r\n\r\n            val = actionWaitingTime / (1 hours);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets all details of a propsal\r\n     * @param _proposalId whose details we want\r\n     * @return proposalId\r\n     * @return category\r\n     * @return status\r\n     * @return finalVerdict\r\n     * @return totalReward\r\n     */\r\n    function proposal(uint _proposalId)\r\n        external\r\n        view\r\n        returns(\r\n            uint proposalId,\r\n            uint category,\r\n            uint status,\r\n            uint finalVerdict,\r\n            uint totalRewar\r\n        )\r\n    {\r\n        return(\r\n            _proposalId,\r\n            allProposalData[_proposalId].category,\r\n            allProposalData[_proposalId].propStatus,\r\n            allProposalData[_proposalId].finalVerdict,\r\n            allProposalData[_proposalId].commonIncentive\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets some details of a propsal\r\n     * @param _proposalId whose details we want\r\n     * @return proposalId\r\n     * @return number of all proposal solutions\r\n     * @return amount of votes \r\n     */\r\n    function proposalDetails(uint _proposalId) external view returns(uint, uint, uint) {\r\n        return(\r\n            _proposalId,\r\n            allProposalSolutions[_proposalId].length,\r\n            proposalVoteTally[_proposalId].voters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Gets solution action on a proposal\r\n     * @param _proposalId whose details we want\r\n     * @param _solution whose details we want\r\n     * @return action of a solution on a proposal\r\n     */\r\n    function getSolutionAction(uint _proposalId, uint _solution) external view returns(uint, bytes memory) {\r\n        return (\r\n            _solution,\r\n            allProposalSolutions[_proposalId][_solution]\r\n        );\r\n    }\r\n   \r\n    /**\r\n     * @dev Gets length of propsal\r\n     * @return length of propsal\r\n     */\r\n    function getProposalLength() external view returns(uint) {\r\n        return totalProposals;\r\n    }\r\n\r\n    /**\r\n     * @dev Get followers of an address\r\n     * @return get followers of an address\r\n     */\r\n    function getFollowers(address _add) external view returns(uint[] memory) {\r\n        return leaderDelegation[_add];\r\n    }\r\n\r\n    /**\r\n     * @dev Gets pending rewards of a member\r\n     * @param _memberAddress in concern\r\n     * @return amount of pending reward\r\n     */\r\n    function getPendingReward(address _memberAddress)\r\n        public view returns(uint pendingDAppReward)\r\n    {\r\n        uint delegationId = followerDelegation[_memberAddress];\r\n        address leader;\r\n        uint lastUpd;\r\n        DelegateVote memory delegationData = allDelegation[delegationId];\r\n\r\n        if (delegationId > 0 && delegationData.leader != address(0)) {\r\n            leader = delegationData.leader;\r\n            lastUpd = delegationData.lastUpd;\r\n        } else\r\n            leader = _memberAddress;\r\n\r\n        uint proposalId;\r\n        for (uint i = lastRewardClaimed[_memberAddress]; i < allVotesByMember[leader].length; i++) {\r\n            if (allVotes[allVotesByMember[leader][i]].dateAdd > (\r\n                lastUpd.add(tokenHoldingTime)) || leader == _memberAddress) {\r\n                if (!rewardClaimed[allVotesByMember[leader][i]][_memberAddress]) {\r\n                    proposalId = allVotes[allVotesByMember[leader][i]].proposalId;\r\n                    if (proposalVoteTally[proposalId].voters > 0 && allProposalData[proposalId].propStatus\r\n                    > uint(ProposalStatus.VotingStarted)) {\r\n                        pendingDAppReward = pendingDAppReward.add(\r\n                            allProposalData[proposalId].commonIncentive.div(\r\n                                proposalVoteTally[proposalId].voters\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Updates Uint Parameters of a code\r\n     * @param code whose details we want to update\r\n     * @param val value to set\r\n     */\r\n    function updateUintParameters(bytes8 code, uint val) public {\r\n\r\n        require(ms.checkIsAuthToGoverned(msg.sender));\r\n        if (code == \"GOVHOLD\") {\r\n\r\n            tokenHoldingTime = val * 1 days;\r\n\r\n        } else if (code == \"MAXFOL\") {\r\n\r\n            maxFollowers = val;\r\n\r\n        } else if (code == \"MAXDRFT\") {\r\n\r\n            maxDraftTime = val * 1 days;\r\n\r\n        } else if (code == \"EPTIME\") {\r\n\r\n            ms.updatePauseTime(val * 1 days);\r\n\r\n        } else if (code == \"ACWT\") {\r\n\r\n            actionWaitingTime = val * 1 hours;\r\n\r\n        } else {\r\n\r\n            revert(\"Invalid code\");\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Updates all dependency addresses to latest ones from Master\r\n    */\r\n    function changeDependentContractAddress() public {\r\n        tokenInstance = TokenController(ms.dAppLocker());\r\n        memberRole = MemberRoles(ms.getLatestAddress(\"MR\"));\r\n        proposalCategory = ProposalCategory(ms.getLatestAddress(\"PC\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if msg.sender is allowed to create a proposal under given category\r\n    */\r\n    function allowedToCreateProposal(uint category) public view returns(bool check) {\r\n        if (category == 0)\r\n            return true;\r\n        uint[] memory mrAllowed;\r\n        (, , , , mrAllowed, , ) = proposalCategory.category(category);\r\n        for (uint i = 0; i < mrAllowed.length; i++) {\r\n            if (mrAllowed[i] == 0 || memberRole.checkRole(msg.sender, mrAllowed[i]))\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if an address is already delegated\r\n     * @param _add in concern\r\n     * @return bool value if the address is delegated or not\r\n     */\r\n    function alreadyDelegated(address _add) public view returns(bool delegated) {\r\n        for (uint i=0; i < leaderDelegation[_add].length; i++) {\r\n            if (allDelegation[leaderDelegation[_add][i]].leader == _add) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Pauses a proposal\r\n    * To implement govblocks interface\r\n    */\r\n    function pauseProposal(uint) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Resumes a proposal\r\n    * To implement govblocks interface\r\n    */\r\n    function resumeProposal(uint) public {\r\n    }\r\n\r\n    /**\r\n    * @dev Checks If the proposal voting time is up and it's ready to close \r\n    *      i.e. Closevalue is 1 if proposal is ready to be closed, 2 if already closed, 0 otherwise!\r\n    * @param _proposalId Proposal id to which closing value is being checked\r\n    */\r\n    function canCloseProposal(uint _proposalId) \r\n        public \r\n        view \r\n        returns(uint)\r\n    {\r\n        uint dateUpdate;\r\n        uint pStatus;\r\n        uint _closingTime;\r\n        uint _roleId;\r\n        uint majority;\r\n        pStatus = allProposalData[_proposalId].propStatus;\r\n        dateUpdate = allProposalData[_proposalId].dateUpd;\r\n        (, _roleId, majority, , , _closingTime, ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n        if (\r\n            pStatus == uint(ProposalStatus.VotingStarted)\r\n        ) {\r\n            uint numberOfMembers = memberRole.numberOfMembers(_roleId);\r\n            if (_roleId == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n                if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) >= majority  \r\n                || proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0]) == numberOfMembers\r\n                || dateUpdate.add(_closingTime) <= now) {\r\n\r\n                    return 1;\r\n                }\r\n            } else {\r\n                if (numberOfMembers == proposalVoteTally[_proposalId].voters \r\n                || dateUpdate.add(_closingTime) <= now)\r\n                    return  1;\r\n            }\r\n        } else if (pStatus > uint(ProposalStatus.VotingStarted)) {\r\n            return  2;\r\n        } else {\r\n            return  0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets Id of member role allowed to categorize the proposal\r\n     * @return roleId allowed to categorize the proposal\r\n     */\r\n    function allowedToCatgorize() public view returns(uint roleId) {\r\n        return roleIdAllowedToCatgorize;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets vote tally data\r\n     * @param _proposalId in concern\r\n     * @param _solution of a proposal id\r\n     * @return member vote value\r\n     * @return advisory board vote value\r\n     * @return amount of votes\r\n     */\r\n    function voteTallyData(uint _proposalId, uint _solution) public view returns(uint, uint, uint) {\r\n        return (proposalVoteTally[_proposalId].memberVoteValue[_solution],\r\n            proposalVoteTally[_proposalId].abVoteValue[_solution], proposalVoteTally[_proposalId].voters);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to create proposal\r\n     * @param _proposalTitle of proposal\r\n     * @param _proposalSD is short description of proposal\r\n     * @param _proposalDescHash IPFS hash value of propsal\r\n     * @param _categoryId of proposal\r\n     */\r\n    function _createProposal(\r\n        string memory _proposalTitle,\r\n        string memory _proposalSD,\r\n        string memory _proposalDescHash,\r\n        uint _categoryId\r\n    )\r\n        internal\r\n    {\r\n        require(proposalCategory.categoryABReq(_categoryId) == 0 || _categoryId == 0);\r\n        uint _proposalId = totalProposals;\r\n        allProposalData[_proposalId].owner = msg.sender;\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalSolutions[_proposalId].push(\"\");\r\n        totalProposals++;\r\n\r\n        emit Proposal(\r\n            msg.sender,\r\n            _proposalId,\r\n            now,\r\n            _proposalTitle,\r\n            _proposalSD,\r\n            _proposalDescHash\r\n        );\r\n\r\n        if (_categoryId > 0)\r\n            _categorizeProposal(_proposalId, _categoryId, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to categorize a proposal\r\n     * @param _proposalId of proposal\r\n     * @param _categoryId of proposal\r\n     * @param _incentive is commonIncentive\r\n     */\r\n    function _categorizeProposal(\r\n        uint _proposalId,\r\n        uint _categoryId,\r\n        uint _incentive\r\n    )\r\n        internal\r\n    {\r\n        require(\r\n            _categoryId > 0 && _categoryId < proposalCategory.totalCategories(),\r\n            \"Invalid category\"\r\n        );\r\n        allProposalData[_proposalId].category = _categoryId;\r\n        allProposalData[_proposalId].commonIncentive = _incentive;\r\n        allProposalData[_proposalId].propStatus = uint(ProposalStatus.AwaitingSolution);\r\n\r\n        emit ProposalCategorized(_proposalId, msg.sender, _categoryId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to add solution to a proposal\r\n     * @param _proposalId in concern\r\n     * @param _action on that solution\r\n     * @param _solutionHash string value\r\n     */\r\n    function _addSolution(uint _proposalId, bytes memory _action, string memory _solutionHash)\r\n        internal\r\n    {\r\n        allProposalSolutions[_proposalId].push(_action);\r\n        emit Solution(_proposalId, msg.sender, allProposalSolutions[_proposalId].length - 1, _solutionHash, now);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal call to add solution and open proposal for voting\r\n    */\r\n    function _proposalSubmission(\r\n        uint _proposalId,\r\n        string memory _solutionHash,\r\n        bytes memory _action\r\n    )\r\n        internal\r\n    {\r\n\r\n        uint _categoryId = allProposalData[_proposalId].category;\r\n        if (proposalCategory.categoryActionHashes(_categoryId).length == 0) {\r\n            require(keccak256(_action) == keccak256(\"\"));\r\n            proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);\r\n        }\r\n        \r\n        _addSolution(\r\n            _proposalId,\r\n            _action,\r\n            _solutionHash\r\n        );\r\n\r\n        _updateProposalStatus(_proposalId, uint(ProposalStatus.VotingStarted));\r\n        (, , , , , uint closingTime, ) = proposalCategory.category(_categoryId);\r\n        emit CloseProposalOnTime(_proposalId, closingTime.add(now));\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to submit vote\r\n     * @param _proposalId of proposal in concern\r\n     * @param _solution for that proposal\r\n     */\r\n    function _submitVote(uint _proposalId, uint _solution) internal {\r\n\r\n        uint delegationId = followerDelegation[msg.sender];\r\n        uint mrSequence;\r\n        uint majority;\r\n        uint closingTime;\r\n        (, mrSequence, majority, , , closingTime, ) = proposalCategory.category(allProposalData[_proposalId].category);\r\n\r\n        require(allProposalData[_proposalId].dateUpd.add(closingTime) > now, \"Closed\");\r\n\r\n        require(memberProposalVote[msg.sender][_proposalId] == 0, \"Not allowed\");\r\n        require((delegationId == 0) || (delegationId > 0 && allDelegation[delegationId].leader == address(0) && \r\n        _checkLastUpd(allDelegation[delegationId].lastUpd)));\r\n\r\n        require(memberRole.checkRole(msg.sender, mrSequence), \"Not Authorized\");\r\n        uint totalVotes = allVotes.length;\r\n\r\n        allVotesByMember[msg.sender].push(totalVotes);\r\n        memberProposalVote[msg.sender][_proposalId] = totalVotes;\r\n\r\n        allVotes.push(ProposalVote(msg.sender, _proposalId, now));\r\n\r\n        emit Vote(msg.sender, _proposalId, totalVotes, now, _solution);\r\n        if (mrSequence == uint(MemberRoles.Role.Owner)) {\r\n            if (_solution == 1)\r\n                _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), allProposalData[_proposalId].category, 1, MemberRoles.Role.Owner);\r\n            else\r\n                _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n        \r\n        } else {\r\n            uint numberOfMembers = memberRole.numberOfMembers(mrSequence);\r\n            _setVoteTally(_proposalId, _solution, mrSequence);\r\n\r\n            if (mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n                if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100).div(numberOfMembers) \r\n                >= majority \r\n                || (proposalVoteTally[_proposalId].abVoteValue[1].add(proposalVoteTally[_proposalId].abVoteValue[0])) == numberOfMembers) {\r\n                    emit VoteCast(_proposalId);\r\n                }\r\n            } else {\r\n                if (numberOfMembers == proposalVoteTally[_proposalId].voters)\r\n                    emit VoteCast(_proposalId);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to set vote tally of a proposal\r\n     * @param _proposalId of proposal in concern\r\n     * @param _solution of proposal in concern\r\n     * @param mrSequence number of members for a role\r\n     */\r\n    function _setVoteTally(uint _proposalId, uint _solution, uint mrSequence) internal\r\n    {\r\n        uint categoryABReq;\r\n        uint isSpecialResolution;\r\n        (, categoryABReq, isSpecialResolution) = proposalCategory.categoryExtendedData(allProposalData[_proposalId].category);\r\n        if (memberRole.checkRole(msg.sender, uint(MemberRoles.Role.AdvisoryBoard)) && (categoryABReq > 0) || \r\n            mrSequence == uint(MemberRoles.Role.AdvisoryBoard)) {\r\n            proposalVoteTally[_proposalId].abVoteValue[_solution]++;\r\n        }\r\n        tokenInstance.lockForMemberVote(msg.sender, tokenHoldingTime);\r\n        if (mrSequence != uint(MemberRoles.Role.AdvisoryBoard)) {\r\n            uint voteWeight;\r\n            uint voters = 1;\r\n            uint tokenBalance = tokenInstance.totalBalanceOf(msg.sender);\r\n            uint totalSupply = tokenInstance.totalSupply();\r\n            if (isSpecialResolution == 1) {\r\n                voteWeight = tokenBalance.add(10**18);\r\n            } else {\r\n                voteWeight = (_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10**18);\r\n            }\r\n            DelegateVote memory delegationData;\r\n            for (uint i = 0; i < leaderDelegation[msg.sender].length; i++) {\r\n                delegationData = allDelegation[leaderDelegation[msg.sender][i]];\r\n                if (delegationData.leader == msg.sender && \r\n                _checkLastUpd(delegationData.lastUpd)) {\r\n                    if (memberRole.checkRole(delegationData.follower, mrSequence)) {\r\n                        tokenBalance = tokenInstance.totalBalanceOf(delegationData.follower);\r\n                        tokenInstance.lockForMemberVote(delegationData.follower, tokenHoldingTime);\r\n                        voters++;\r\n                        if (isSpecialResolution == 1) {\r\n                            voteWeight = voteWeight.add(tokenBalance.add(10**18));\r\n                        } else {\r\n                            voteWeight = voteWeight.add((_minOf(tokenBalance, maxVoteWeigthPer.mul(totalSupply).div(100))).add(10**18));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            proposalVoteTally[_proposalId].memberVoteValue[_solution] = proposalVoteTally[_proposalId].memberVoteValue[_solution].add(voteWeight);\r\n            proposalVoteTally[_proposalId].voters = proposalVoteTally[_proposalId].voters + voters;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets minimum of two numbers\r\n     * @param a one of the two numbers\r\n     * @param b one of the two numbers\r\n     * @return minimum number out of the two\r\n     */\r\n    function _minOf(uint a, uint b) internal pure returns(uint res) {\r\n        res = a;\r\n        if (res > b)\r\n            res = b;\r\n    }\r\n    \r\n    /**\r\n     * @dev Check the time since last update has exceeded token holding time or not\r\n     * @param _lastUpd is last update time\r\n     * @return the bool which tells if the time since last update has exceeded token holding time or not\r\n     */\r\n    function _checkLastUpd(uint _lastUpd) internal view returns(bool) {\r\n        return (now - _lastUpd) > tokenHoldingTime;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if the vote count against any solution passes the threshold value or not.\r\n    */\r\n    function _checkForThreshold(uint _proposalId, uint _category) internal view returns(bool check) {\r\n        uint categoryQuorumPerc;\r\n        uint roleAuthorized;\r\n        (, roleAuthorized, , categoryQuorumPerc, , , ) = proposalCategory.category(_category);\r\n        check = ((proposalVoteTally[_proposalId].memberVoteValue[0]\r\n                            .add(proposalVoteTally[_proposalId].memberVoteValue[1]))\r\n                        .mul(100))\r\n                .div(\r\n                    tokenInstance.totalSupply().add(\r\n                        memberRole.numberOfMembers(roleAuthorized).mul(10 ** 18)\r\n                    )\r\n                ) >= categoryQuorumPerc;\r\n    }\r\n    \r\n    /**\r\n     * @dev Called when vote majority is reached\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal in concern\r\n     * @param category of proposal in concern\r\n     * @param max vote value of proposal in concern\r\n     */\r\n    function _callIfMajReached(uint _proposalId, uint _status, uint category, uint max, MemberRoles.Role role) internal {\r\n        \r\n        allProposalData[_proposalId].finalVerdict = max;\r\n        _updateProposalStatus(_proposalId, _status);\r\n        emit ProposalAccepted(_proposalId);\r\n        if (proposalActionStatus[_proposalId] != uint(ActionStatus.NoAction)) {\r\n            if (role == MemberRoles.Role.AdvisoryBoard) {\r\n                _triggerAction(_proposalId, category);\r\n            } else {\r\n                proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n                proposalExecutionTime[_proposalId] = actionWaitingTime.add(now);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to trigger action of accepted proposal\r\n     */\r\n    function _triggerAction(uint _proposalId, uint _categoryId) internal {\r\n        proposalActionStatus[_proposalId] = uint(ActionStatus.Executed);\r\n        bytes2 contractName;\r\n        address actionAddress;\r\n        bytes memory _functionHash;\r\n        (, actionAddress, contractName, , _functionHash) = proposalCategory.categoryActionDetails(_categoryId);\r\n        if (contractName == \"MS\") {\r\n            actionAddress = address(ms);\r\n        } else if (contractName != \"EX\") {\r\n            actionAddress = ms.getLatestAddress(contractName);\r\n        }\r\n        (bool actionStatus, ) = actionAddress.call(abi.encodePacked(_functionHash, allProposalSolutions[_proposalId][1]));\r\n        if (actionStatus) {\r\n            emit ActionSuccess(_proposalId);\r\n        } else {\r\n            proposalActionStatus[_proposalId] = uint(ActionStatus.Accepted);\r\n            emit ActionFailed(_proposalId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to update proposal status\r\n     * @param _proposalId of proposal in concern\r\n     * @param _status of proposal to set\r\n     */\r\n    function _updateProposalStatus(uint _proposalId, uint _status) internal {\r\n        if (_status == uint(ProposalStatus.Rejected) || _status == uint(ProposalStatus.Denied)) {\r\n            proposalActionStatus[_proposalId] = uint(ActionStatus.NoAction);   \r\n        }\r\n        allProposalData[_proposalId].dateUpd = now;\r\n        allProposalData[_proposalId].propStatus = _status;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to undelegate a follower\r\n     * @param _follower is address of follower to undelegate\r\n     */\r\n    function _unDelegate(address _follower) internal {\r\n        uint followerId = followerDelegation[_follower];\r\n        if (followerId > 0) {\r\n\r\n            followerCount[allDelegation[followerId].leader] = followerCount[allDelegation[followerId].leader].sub(1);\r\n            allDelegation[followerId].leader = address(0);\r\n            allDelegation[followerId].lastUpd = now;\r\n\r\n            lastRewardClaimed[_follower] = allVotesByMember[_follower].length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to close member voting\r\n     * @param _proposalId of proposal in concern\r\n     * @param category of proposal in concern\r\n     */\r\n    function _closeMemberVote(uint _proposalId, uint category) internal {\r\n        uint isSpecialResolution;\r\n        uint abMaj;\r\n        (, abMaj, isSpecialResolution) = proposalCategory.categoryExtendedData(category);\r\n        if (isSpecialResolution == 1) {\r\n            uint acceptedVotePerc = proposalVoteTally[_proposalId].memberVoteValue[1].mul(100)\r\n            .div(\r\n                tokenInstance.totalSupply().add(\r\n                        memberRole.numberOfMembers(uint(MemberRoles.Role.Member)).mul(10**18)\r\n                    ));\r\n            if (acceptedVotePerc >= specialResolutionMajPerc) {\r\n                _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n            } else {\r\n                _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n            }\r\n        } else {\r\n            if (_checkForThreshold(_proposalId, category)) {\r\n                uint majorityVote;\r\n                (, , majorityVote, , , , ) = proposalCategory.category(category);\r\n                if (\r\n                    ((proposalVoteTally[_proposalId].memberVoteValue[1].mul(100))\r\n                                        .div(proposalVoteTally[_proposalId].memberVoteValue[0]\r\n                                                .add(proposalVoteTally[_proposalId].memberVoteValue[1])\r\n                                        ))\r\n                    >= majorityVote\r\n                    ) {\r\n                        _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n                    } else {\r\n                        _updateProposalStatus(_proposalId, uint(ProposalStatus.Rejected));\r\n                    }\r\n            } else {\r\n                if (abMaj > 0 && proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n                .div(memberRole.numberOfMembers(uint(MemberRoles.Role.AdvisoryBoard))) >= abMaj) {\r\n                    _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, MemberRoles.Role.Member);\r\n                } else {\r\n                    _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (proposalVoteTally[_proposalId].voters > 0) {\r\n            tokenInstance.mint(ms.getLatestAddress(\"CR\"), allProposalData[_proposalId].commonIncentive);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal call to close advisory board voting\r\n     * @param _proposalId of proposal in concern\r\n     * @param category of proposal in concern\r\n     */\r\n    function _closeAdvisoryBoardVote(uint _proposalId, uint category) internal {\r\n        uint _majorityVote;\r\n        MemberRoles.Role _roleId = MemberRoles.Role.AdvisoryBoard;\r\n        (, , _majorityVote, , , , ) = proposalCategory.category(category);\r\n        if (proposalVoteTally[_proposalId].abVoteValue[1].mul(100)\r\n        .div(memberRole.numberOfMembers(uint(_roleId))) >= _majorityVote) {\r\n            _callIfMajReached(_proposalId, uint(ProposalStatus.Accepted), category, 1, _roleId);\r\n        } else {\r\n            _updateProposalStatus(_proposalId, uint(ProposalStatus.Denied));\r\n        }\r\n\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_founderAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"BlackListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"WhiteListed\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addToWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLockedForMV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"lockForMemberVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"operatorTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeFromWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SOTEToken", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002b14d048faedfafd42428b04d053905ce6173352000000000000000000000000000000000000000000084595161401484a000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a30806146fbedf9e86266afacbe1d5468f0edfcf7f45442628176f4ec378966b"}