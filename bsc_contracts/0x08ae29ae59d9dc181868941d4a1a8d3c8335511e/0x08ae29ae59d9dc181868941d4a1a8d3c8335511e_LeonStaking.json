{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LeonStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport \\\"./interfaces/IBEP20.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @title LEON Staking\\n */\\ncontract LeonStaking is Ownable {\\n    using SafeMath for uint256;\\n\\n    struct Stake {\\n        uint256 amount; //staked amount\\n        uint256 createdAt; // Timestamp of when stake was created\\n        uint256 rewardAmount; // Calculated reward amount, will be transfered to stake holder after plan expiry\\n        uint8 state; // state of the stake, 0 - FREE, 1 - ACTIVE, 2 - 'REMOVING'\\n        string plan;\\n    }\\n\\n    struct Plan {\\n        string name; //The name of the plan, should be a single word in lowercase\\n        uint256 durationInDays; // The duration in days of the plan\\n        uint256 rewardPercentage; //The total reward percentage of the plan\\n        uint256 minimumStake; //The minimum amount a stakeholder can stake\\n        uint256 createdAt; // Timestamp of when plan was created\\n        uint256 usageCount; // How many stakes are in active on this plan\\n        uint256 stakedAmount;\\n        uint8 state; // State of the plan, 0 - Not Created, 1 - Active, 2 - Disabled\\n    }\\n\\n    uint256 public constant MAX_NUM_OF_STAKES_PER_USER = 5;\\n\\n    address public leonToken; /* LEON Token Contract Address */\\n    address public rewardAccount; //LEON account from which reward amount will be sent to Stake holders\\n    uint256 public totalStakedAmount; // Total staked amount, from all share holders\\n    uint256 public totalPendingRewardAmount; // Reward Amount pending to be rewarded to all stakeholders\\n    uint256 public totalRewardAmountClaimed; // Reward amount transfered to all stake holders\\n    bool public stakingPaused;\\n\\n    //The stakes for each stakeholder.\\n    mapping(address => Stake[MAX_NUM_OF_STAKES_PER_USER]) internal stakes;\\n\\n    //The plans\\n    mapping(string => Plan) internal plans;\\n\\n    event PlanCreated(string name, uint256 duration, uint256 rewardPercentage);\\n    event PlanDeleted(string name);\\n    event ExcessRewardTransferred(address, uint256);\\n    event Staked(\\n        address sender,\\n        string plan,\\n        uint256 stakeAmount,\\n        uint256 duration,\\n        uint256 rewardAmount\\n    );\\n    event StakeRemoved(\\n        address sender,\\n        uint256 stakeIndex,\\n        uint256 stakeamount,\\n        uint256 rewardAmount\\n    );\\n\\n    constructor(address _leonToken, address rewardsFrom) public {\\n        leonToken = _leonToken;\\n        rewardAccount = rewardsFrom;\\n    }\\n\\n    /**\\n     * @notice A method for a stakeholder to create a stake.\\n     * @param _stakeAmount The size of the stake to be created.\\n     * @param _plan The type of stake to be created.\\n     */\\n    function enterStaking(uint256 _stakeAmount, string memory _plan)\\n        external\\n        returns (uint256 stakeIndex)\\n    {\\n        uint256 i;\\n        uint256 rewardAmount;\\n\\n        Plan storage plan = plans[_plan];\\n\\n        require(!stakingPaused, \\\"LeonStaking: Staking Paused\\\");\\n        /* plan must be valid and should not be disabled for further stakes */\\n        require(\\n            plan.state == 1,\\n            \\\"LeonStaking: Invalid or disabled staking plan\\\"\\n        );\\n        require(\\n            _stakeAmount >= plan.minimumStake,\\n            \\\"LeonStaking: Stake is below minimum allowed stake\\\"\\n        );\\n\\n        // Transfer tokens from stake holders LEON account to this contract account\\n        IBEP20(leonToken).transferFrom(\\n            _msgSender(),\\n            address(this),\\n            _stakeAmount\\n        );\\n\\n        if (plan.rewardPercentage > 0) {\\n            rewardAmount = (_stakeAmount.mul(plan.rewardPercentage).div(10000));\\n\\n            IBEP20(leonToken).transferFrom(\\n                rewardAccount,\\n                address(this),\\n                rewardAmount\\n            );\\n        }\\n        /* A stack holder can stake upto MAX_NUM_OF_STAKES_PER_USER of stakes at any point of time */\\n        for (i = 0; i < MAX_NUM_OF_STAKES_PER_USER; i++)\\n            if (stakes[_msgSender()][i].state == 0) break;\\n\\n        require(\\n            i < MAX_NUM_OF_STAKES_PER_USER,\\n            \\\"LEONStacking: Reached maximum stakes per user\\\"\\n        );\\n\\n        Stake storage stake = stakes[_msgSender()][i];\\n\\n        stake.amount = _stakeAmount;\\n        stake.plan = _plan;\\n        stake.rewardAmount = rewardAmount;\\n        stake.createdAt = block.timestamp;\\n        stake.state = 1; // Set to active statemul\\n        stakeIndex = i;\\n\\n        totalStakedAmount = totalStakedAmount.add(_stakeAmount);\\n        totalPendingRewardAmount = totalPendingRewardAmount.add(\\n            stake.rewardAmount\\n        );\\n\\n        plan.stakedAmount = plan.stakedAmount.add(_stakeAmount);\\n\\n        /* Increase the usage count of this plan */\\n        plan.usageCount++;\\n\\n        emit Staked(\\n            _msgSender(),\\n            _plan,\\n            _stakeAmount,\\n            plan.durationInDays,\\n            _stakeAmount.mul(plan.rewardPercentage).div(10000)\\n        );\\n    }\\n\\n    function getStakesIndexes(address stakeHolder)\\n        external\\n        view\\n        returns (uint256[] memory stakesIndexes, uint256 numStakes)\\n    {\\n        uint256 i;\\n        uint256 j;\\n\\n        for (i = 0; i < MAX_NUM_OF_STAKES_PER_USER; i++)\\n            if (stakes[stakeHolder][i].state == 1) numStakes++;\\n\\n        if (numStakes > 0) {\\n            stakesIndexes = new uint256[](numStakes);\\n\\n            for (i = 0; i < MAX_NUM_OF_STAKES_PER_USER; i++) {\\n                if (stakes[stakeHolder][i].state == 1) {\\n                    stakesIndexes[j] = i;\\n                    j++;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getAllStakes(address stakeHolder)\\n        external\\n        view\\n        returns (\\n            uint256[] memory stakesIndexes,\\n            uint256[] memory stakedAmounts,\\n            uint256[] memory createdAt,\\n            uint256 numStakes\\n        )\\n    {\\n        uint256 i;\\n        uint256 j;\\n\\n        for (i = 0; i < MAX_NUM_OF_STAKES_PER_USER; i++) {\\n            if (stakes[stakeHolder][i].state == 1) numStakes++;\\n        }\\n\\n        if (numStakes > 0) {\\n            stakesIndexes = new uint256[](numStakes);\\n            stakedAmounts = new uint256[](numStakes);\\n            createdAt = new uint256[](numStakes);\\n\\n            for (i = 0; i < MAX_NUM_OF_STAKES_PER_USER; i++) {\\n                if (stakes[stakeHolder][i].state == 1) {\\n                    stakesIndexes[j] = i;\\n                    stakedAmounts[j] = stakes[stakeHolder][i].amount;\\n                    createdAt[j] = stakes[stakeHolder][i].createdAt;\\n                    j++;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getStakeInfo(address stakeHolder, uint256 _stakeIndex)\\n        external\\n        view\\n        returns (\\n            uint256 stakeAmount,\\n            uint256 createdAt,\\n            uint256 rewardAmount,\\n            string memory plan\\n        )\\n    {\\n        if (\\n            _stakeIndex < MAX_NUM_OF_STAKES_PER_USER &&\\n            stakes[stakeHolder][_stakeIndex].state == 1\\n        ) {\\n            stakeAmount = stakes[stakeHolder][_stakeIndex].amount;\\n            createdAt = stakes[stakeHolder][_stakeIndex].createdAt;\\n            plan = stakes[stakeHolder][_stakeIndex].plan;\\n            rewardAmount = stakeAmount.mul(plans[plan].rewardPercentage).div(\\n                10000\\n            );\\n        }\\n    }\\n\\n    function getStakedAmountByPlan(string memory _plan)\\n        external\\n        view\\n        onlyOwner\\n        returns (uint256)\\n    {\\n        if (plans[_plan].state > 0) return plans[_plan].stakedAmount;\\n\\n        return 0;\\n    }\\n\\n    /* Withdraw/Remove a stake */\\n    function withdrawStaking(uint256 _stakeIndex) external {\\n        uint256 amount;\\n\\n        require(\\n            _stakeIndex < MAX_NUM_OF_STAKES_PER_USER,\\n            \\\"LeonStaking: Invalid stake index\\\"\\n        );\\n\\n        Stake storage stake = stakes[_msgSender()][_stakeIndex];\\n        require(stake.state == 1, \\\"LeonStaking: Stake is not active\\\");\\n        require(\\n            _isExpired(stake.createdAt, plans[stake.plan].durationInDays),\\n            \\\"LeonStaking: Stake Plan not expired yet\\\"\\n        );\\n\\n        // set the state to 'removing'\\n        stake.state = 2;\\n\\n        /* transfer stake amount + rewared amount to the stake holder */\\n        amount = amount.add(stake.amount);\\n        amount = amount.add(stake.rewardAmount);\\n\\n        IBEP20(leonToken).transfer(_msgSender(), amount);\\n\\n        /* Update globals */\\n        totalStakedAmount = totalStakedAmount.sub(stake.amount);\\n        totalPendingRewardAmount = totalPendingRewardAmount.sub(\\n            stake.rewardAmount\\n        );\\n        totalRewardAmountClaimed = totalRewardAmountClaimed.add(\\n            stake.rewardAmount\\n        );\\n\\n        plans[stake.plan].stakedAmount = plans[stake.plan].stakedAmount.sub(\\n            stake.amount\\n        );\\n\\n        /* reduce plan active count */\\n        plans[stake.plan].usageCount--;\\n\\n        emit StakeRemoved(\\n            _msgSender(),\\n            _stakeIndex,\\n            stake.amount,\\n            stake.amount.mul(plans[stake.plan].rewardPercentage).div(10000)\\n        );\\n        delete stakes[_msgSender()][_stakeIndex]; //Sets state to 0\\n    }\\n\\n    /*\\n     */\\n    function transferExcessReward(address _to) external onlyOwner {\\n        uint256 excessAmount = IBEP20(leonToken).balanceOf(address(this));\\n\\n        if (excessAmount > 0) {\\n            excessAmount = excessAmount.sub(\\n                totalStakedAmount.add(totalPendingRewardAmount)\\n            );\\n            IBEP20(leonToken).transfer(_to, excessAmount);\\n        }\\n        emit ExcessRewardTransferred(_to, excessAmount);\\n    }\\n\\n    /*\\n     * @notice A method to pause staking. New stakes are not allowed once paused\\n     *\\n     */\\n    function pauseStaking() external onlyOwner returns (bool) {\\n        stakingPaused = true;\\n        return true;\\n    }\\n\\n    /*\\n     * @notice A method to resume paused staking. New stakes are allowed once resumed\\n     *\\n     */\\n    function resumeStaking() external onlyOwner returns (bool) {\\n        stakingPaused = false;\\n        return true;\\n    }\\n\\n    /*\\n     * @notice A method to update 'rewaredAccount'\\n     *\\n     */\\n    function updateRewardAccount(address _rewardAccount)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        require(\\n            _rewardAccount != address(0),\\n            \\\"Invalid address for rewardAccount\\\"\\n        );\\n\\n        rewardAccount = _rewardAccount;\\n        return true;\\n    }\\n\\n    /**\\n     * @notice A method for a contract owner to create a staking plan.\\n     * @param _name The name of the plan to be created.\\n     * @param _minimum_stake The minimum a stakeholder can stake.\\n     * @param _duration The duration in weeks of the plan to be created.\\n     * @param _reward_percentage The total reward percentage of the plan.\\n     *        Percentage should be in the degree of '100' (i.e multiply the required percent by 100)\\n     *        To set 10 percent, _reward_percentage should be 1000, to set 0.1 percent, it shoud be 10.\\n     */\\n    function createPlan(\\n        string memory _name,\\n        uint256 _minimum_stake,\\n        uint256 _duration,\\n        uint256 _reward_percentage\\n    ) external onlyOwner {\\n        require(_duration > 0, \\\"LeonStaking: Duration in weeks can't be zero\\\");\\n        require(_minimum_stake > 0, \\\"LeonStaking: Minimum stake can't be zero\\\");\\n        require(plans[_name].state == 0, \\\"LeonStaking: Plan already exists\\\");\\n\\n        Plan storage plan = plans[_name];\\n\\n        plan.name = _name;\\n        plan.minimumStake = _minimum_stake;\\n        plan.durationInDays = _duration;\\n        plan.rewardPercentage = _reward_percentage;\\n        plan.createdAt = block.timestamp;\\n        plan.state = 1;\\n\\n        emit PlanCreated(plan.name, plan.durationInDays, plan.rewardPercentage);\\n    }\\n\\n    function deletePlan(string memory _name) external onlyOwner {\\n        require(plans[_name].state > 0, \\\"LeonStaking: Plan not found\\\");\\n        require(plans[_name].usageCount == 0, \\\"LeonStaking: Plan is in use\\\");\\n\\n        delete plans[_name];\\n\\n        emit PlanDeleted(_name);\\n    }\\n\\n    /*\\n     * @notice A method to disable a plan. No more new stakes will be added with this plan.\\n     * @param _name The plan name to disable\\n     */\\n    function disablePlan(string memory _name) external onlyOwner {\\n        require(plans[_name].state > 0, \\\"LeonStaking: Plan doesn't exist\\\");\\n        plans[_name].state = 2; //Disable\\n    }\\n\\n    /**\\n     * @notice A method to retrieve the plan with the name.\\n     * @param _name The plan to retrieve\\n     */\\n    function getPlanInfo(string memory _name)\\n        external\\n        view\\n        returns (\\n            uint256 minimumStake,\\n            uint256 duration,\\n            uint256 rewardPercentage,\\n            uint256 usageCount,\\n            uint8 state\\n        )\\n    {\\n        Plan storage plan = plans[_name];\\n\\n        if (plan.state > 0) {\\n            minimumStake = plan.minimumStake;\\n            duration = plan.durationInDays;\\n            rewardPercentage = plan.rewardPercentage;\\n            usageCount = plan.usageCount;\\n            state = plan.state;\\n        }\\n    }\\n\\n    function _isExpired(uint256 _time, uint256 _duration)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        if (block.timestamp >= (_time + _duration * 1 days)) return true;\\n        else return false;\\n    }\\n\\n    function getUserStakedAmount(address stakeHolder)\\n        external\\n        view\\n        returns (uint256 stakedAmount)\\n    {\\n        uint256 i;\\n\\n        for (i = 0; i < MAX_NUM_OF_STAKES_PER_USER; i++)\\n            if (stakes[stakeHolder][i].state == 1) {\\n                stakedAmount = stakedAmount.add(stakes[stakeHolder][i].amount);\\n            }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"/contracts/interfaces/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable is Context {\\n  address public owner;\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = _msgSender();\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_msgSender() == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n  // Empty internal constructor, to prevent people from mistakenly deploying\\n  // an instance of this contract, which should be used via inheritance.\\n  constructor () internal { }\\n\\n  function _msgSender() internal view returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leonToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsFrom\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ExcessRewardTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPercentage\",\"type\":\"uint256\"}],\"name\":\"PlanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"PlanDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"StakeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"plan\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_NUM_OF_STAKES_PER_USER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_minimum_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward_percentage\",\"type\":\"uint256\"}],\"name\":\"createPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"deletePlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"disablePlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_plan\",\"type\":\"string\"}],\"name\":\"enterStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"getAllStakes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stakesIndexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakedAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"createdAt\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"numStakes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getPlanInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"plan\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_plan\",\"type\":\"string\"}],\"name\":\"getStakedAmountByPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"getStakesIndexes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stakesIndexes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"numStakes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeHolder\",\"type\":\"address\"}],\"name\":\"getUserStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leonToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resumeStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardAmountClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferExcessReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardAccount\",\"type\":\"address\"}],\"name\":\"updateRewardAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LeonStaking", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000027e873bee690c8e161813de3566e9e18a64b0381000000000000000000000000e66dfd66ad576cead321f354770042610ac5f107", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}