{"SourceCode": "// SPDX-License-Identifier: MIT\npragma solidity =0.7.6;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = -denominator & denominator;\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(MAX_TICK), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \"R\");\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n\nlibrary OracleLibrary {\n    function getQuoteAtTick(int24 tick, uint128 baseAmount, address baseToken, address quoteToken)\n        internal\n        pure\n        returns (uint256 quoteAmount)\n    {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n}\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a + b;require(c >= a, \"SafeMath: addition overflow\");return c;}\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return sub(a, b, \"SafeMath: subtraction overflow\");}\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b <= a, errorMessage);uint256 c = a - b; return c;}\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {if (a == 0) {return 0;}uint256 c = a * b;require(c / a == b, \"SafeMath: multiplication overflow\");return c;}\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return div(a, b, \"SafeMath: division by zero\");}\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b > 0, errorMessage);uint256 c = a / b;return c;}\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return mod(a, b, \"SafeMath: modulo by zero\");}\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage);return a % b;}\n}\n\npragma abicoder v2;\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IPancakeV3PoolState {\n    function slot0() external view returns (\n        uint160 sqrtPriceX96,\n        int24 tick,\n        uint16 observationIndex,\n        uint16 observationCardinality,\n        uint16 observationCardinalityNext,\n        uint32 feeProtocol,\n        bool unlocked\n    );\n}\n\ncontract KoreaAmc {\n    using SafeMath for uint256;\n    IPancakeV3PoolState public pool;\n    IERC20 public usdt;\n    IERC20 public amc;\n    struct OBJInviter {\n        address a;\n        bool b;\n    }\n    mapping(address => uint256) _level; \n    mapping(address => uint256) _joinTime; \n    mapping(address => uint256) _upTime; \n    mapping(address => address[]) _inviters; \n    mapping(address => address) public _userTop; \n    mapping(address => bool) public _isjoin; \n    mapping(address => uint256) addupStcBalance; \n    mapping(address => uint256) addupDynBalance; \n    mapping(address => uint256) atmBalance; \n\n    mapping(address => uint256) totalRateBalance; \n    mapping(address => uint256) stcRateBalance; \n    mapping(address => uint256) dynRateBalance; \n\n   \n    uint256[9] _rate = [15,12,10,8,8,8,6,6,6];\n    uint256[4] _levelRate = [0,8,9,10];\n    uint256[4] _joinAmt = [0,500e18,1000e18,2000e18];\n    uint256[4] _joinAmtMax = [0,1500e18,3000e18,6000e18];\n    address _rewardAddr; \n    address _zero; \n    uint256 _oneday;\n\n    \n    struct OBJreg {\n        address user;\n        address father;\n        uint256 timer;\n    }\n    OBJreg[] public regList;\n\n    struct OBJorder{\n        address _user;\n        uint256 _total;\n        uint256 _usdt;\n        uint256 _amc;\n        uint256 _timer;\n    }\n    OBJorder[] public orders;\n\n    bool isReward;\n    modifier localReward {\n        isReward = true;\n        _;\n        isReward = false;\n    }\n    constructor(){\n        usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\n        amc = IERC20(0x299142a6370e1912156E53fBD4f25D7ba49DdcC5);\n        pool = IPancakeV3PoolState(0xC1fEb3e2E411f82BC5892328C17B36B45a1A64c1);\n        _zero = address(0x520731EC399dBd5AEAA799C733402734187054FA);\n        _rewardAddr = address(0x129BD3b9f5ce720E70025827c7d568529949b464);\n        _oneday = 86400;\n    }\n        \n    function getAmount(uint256 _u) view private returns(uint256){\n        (, int24 tick,,,,,) = pool.slot0();\n        return OracleLibrary.getQuoteAtTick(tick, uint128(_u), address(usdt), address(amc));\n    }\n\n    event bidLog(address user, address father, uint256 timer);\n    function register(address _father) public {\n        address _user = msg.sender;\n        require(_father != address(0),\"reg father invalid\");\n        require(!_isCt(_user) && (tx.origin == _user), \"reg address error\");\n        require(_userTop[_user] == address(0),\"reg bound error\");\n        require(_father != _user,\"father == me\");\n        require(_user != _zero,\"user == zero node\");\n        require(_isjoin[_father] || _zero == _father,\"father is out\");\n        _userTop[_user] = _father;\n        _inviters[_father].push(_user);\n        regList.push(OBJreg(_user, _father, block.timestamp));\n        emit bidLog(_user, _father, block.timestamp);\n    }\n\n    event joinLog(address indexed _u,uint256 _total, \n                uint256 _usdt, uint256 _amc,uint _time);\n    function join(uint256 _index) external {\n        require(_index > 0 && _index < 4, \"join index error\");\n        address _user = msg.sender;\n        uint256 _time = block.timestamp;\n        require(_userTop[_user] != address(0),\"join father invalid\");\n        require(!_isjoin[_user],\"address not out\");\n        \n        require(_level[_user] <= _index,\"join level error\");\n        delete addupStcBalance[_user];\n        delete addupDynBalance[_user];\n        _joinTime[_user] = _time;\n        _level[_user] = _index;\n        _upTime[_user] = _time;\n        _isjoin[_user] = true;\n       \n        uint256 toUsdt = _joinAmt[_index].mul(70).div(100);\n        uint256 toAmc = getAmount(uint128(_joinAmt[_index].mul(30).div(100)));\n        require(usdt.transferFrom(_user, address(this), toUsdt),\"transfer usdt error\");\n        require(amc.transferFrom(_user, address(this), toAmc),\"transfer amc error\");\n        orders.push(OBJorder(_user, _joinAmt[_index], toUsdt, toAmc, _time));\n        emit joinLog(_user, _joinAmt[_index], toUsdt, toAmc, _time);\n    }\n    function getUserInivters() view external returns(OBJInviter[] memory obj){\n        address _user = msg.sender;\n        uint256 len = _inviters[_user].length;\n        obj = new OBJInviter[](len);\n        if(len == 0)return obj;\n        for (uint256 index = 0; index < len; index++) {\n            obj[index] = OBJInviter(_inviters[_user][index],_isjoin[_inviters[_user][index]]);\n        }\n    }\n    \n    function getUserRate(address _user) view external returns(\n        uint256 sRate, uint256 remain, uint256 stcRate, uint256 dynRate,\n        uint256 totalRate, uint256 totalStc, uint256 totalDyn,\n        uint256 atmRate, uint256 joinTime, uint256 level\n    ){\n        sRate = _sRateDay(_user); \n        remain = _calc_remain(_user);\n        stcRate = addupStcBalance[_user]; \n        dynRate = addupDynBalance[_user]; \n\n        totalRate = totalRateBalance[_user]; \n        totalStc = stcRateBalance[_user]; \n        totalDyn = dynRateBalance[_user];\n\n        atmRate = atmBalance[_user]; \n        joinTime = _joinTime[_user]; \n        level = _level[_user]; \n    }\n\n    function _sRateDay(address _user) view private returns(uint256 x){\n        uint256 a = _calc_sRate(_user);\n        uint256 b = _calc_remain(_user);\n        x =  a > b ? b : a;\n    }\n\n    function _calc_remain(address _user) view private returns(uint256 x){\n        x =  _isjoin[_user] ? (_joinAmtMax[_level[_user]].sub(\n            addupStcBalance[_user] + addupDynBalance[_user]\n        )):0;\n    }\n    \n    function _calc_sRate(address _user) view private returns(uint256 x){\n        uint256 _lUser = _joinAmt[_level[_user]].mul(_levelRate[_level[_user]]).div(1000);\n        uint256 t = _calc_day(_user);\n        x = _isjoin[_user] ? (_lUser.mul(t)) : 0;\n    }\n\n    function _calc_day(address _user) view private returns(uint256 x){\n        uint256 _bt = block.timestamp - _upTime[_user];\n        x = _bt < _oneday ? 0 : ((_bt % _oneday) == 0 ? _bt/_oneday : (_bt - (_bt % _oneday))/_oneday);\n    }\n\n    function _calc_recom(address _user) view private returns(uint256 x){\n        uint256 len = _inviters[_user].length;\n        if(len == 0)return 0;\n        for (uint256 i = 0; i < len; i++) {\n            if(_isjoin[_inviters[_user][i]])x++;\n        }\n    }\n\n    event calcStcLog(address _user, uint256 _amt, uint256 _order_time, uint256 _uptime);\n    function calcUserRate() external {\n        address _user = msg.sender;\n        uint256 _tempRate = _calc_sRate(_user);\n        uint256 _updateTime = _upTime[_user].add(_calc_day(_user).mul(_oneday));\n        require(_isjoin[_user],\"you not join\");\n        require(_tempRate > 0, \"you not rate\");\n        uint256 _allRate = _tempRate.add(addupStcBalance[_user].add(addupDynBalance[_user]));\n        if(_allRate >= _joinAmtMax[_level[_user]]){\n            _tempRate = _calc_remain(_user);\n\n            stcRateBalance[_user] += _tempRate;\n            totalRateBalance[_user] +=_tempRate;\n            atmBalance[_user] += _tempRate;\n            if(!isReward)_dynReward(_user,_tempRate);\n\n            addupStcBalance[_user] = 0;\n            addupDynBalance[_user] = 0;\n            _upTime[_user] = _updateTime;\n            _isjoin[_user] = false;\n            emit calcStcLog(_user, _tempRate, _updateTime, block.timestamp);\n            return;\n        }\n        addupStcBalance[_user] += _tempRate;\n        stcRateBalance[_user] += _tempRate;\n        totalRateBalance[_user] +=_tempRate;\n        atmBalance[_user] += _tempRate;\n        _upTime[_user] = _updateTime;\n        if(!isReward)_dynReward(_user,_tempRate);\n        emit calcStcLog(_user, _tempRate, _updateTime, block.timestamp);\n    }\n    event calcDynLog(address _from, address _to, uint256 _amt, uint256 _uptime);\n    function _dynReward(address _user, uint256 _amount) private localReward{\n        address _nowUser = _userTop[_user];\n        if(_amount <= 0)return;\n        for (uint256 i = 0; i < _rate.length; i++) {\n            if(_nowUser == address(0))break;\n            if(!_isjoin[_nowUser] || _calc_recom(_nowUser) < i+1){\n                _nowUser = _userTop[_nowUser];\n                continue;\n            }\n            uint256 _amt = _amount.mul(_rate[i]).div(100);\n            uint256 _surRate = _calc_remain(_nowUser);\n            if(_amt >= _surRate){\n                uint256 _updateTime = _upTime[_nowUser].add(_calc_day(_nowUser).mul(_oneday));\n                dynRateBalance[_nowUser] += _surRate;\n                totalRateBalance[_nowUser] +=_surRate;\n                atmBalance[_nowUser] += _surRate;\n\n                addupStcBalance[_nowUser] = 0;\n                addupDynBalance[_nowUser] = 0;\n                _upTime[_nowUser] = _updateTime;\n                _isjoin[_nowUser] = false;\n                emit calcDynLog(_user, _nowUser, _surRate, block.timestamp);\n                _nowUser = _userTop[_nowUser];\n                continue;\n            }\n            addupDynBalance[_nowUser] += _amt;\n            dynRateBalance[_nowUser] += _amt;\n            totalRateBalance[_nowUser] += _amt;\n            atmBalance[_nowUser] += _amt;\n            emit calcDynLog(_user, _nowUser, _amt, block.timestamp);\n            _nowUser = _userTop[_nowUser];\n        }\n    }\n\n    function atmUserRate(uint256 _usda, bool _is) external {\n        address _user = msg.sender;\n        require(!_isCt(_user) && (tx.origin == _user), \"atm address error\");\n        uint256 _atmAmt = atmBalance[_user];\n        require(_atmAmt > 0 && _usda > 0,\"atm balance zero\");\n        require(_usda <= _atmAmt, \"atm out of range\");\n        if(_is){\n            atmBalance[_user] = _atmAmt.sub(_usda);\n            require(usdt.transfer(_user, _usda.mul(97).div(100)),\"atm usdt error0\");\n            require(usdt.transfer(_rewardAddr, _usda.mul(3).div(100)),\"atm usdt error1\");\n        }else{\n            atmBalance[_user] = _atmAmt.sub(_usda);\n            uint256 to_amc = getAmount(uint128(_usda));\n            require(amc.transfer(_user, to_amc.mul(97).div(100)),\"atm amc error0\");\n            require(amc.transfer(_rewardAddr, to_amc.mul(3).div(100)),\"atm amc error1\");\n        }\n    }\n\n    function _isCt(address account) public view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"father\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timer\",\"type\":\"uint256\"}],\"name\":\"bidLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_uptime\",\"type\":\"uint256\"}],\"name\":\"calcDynLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_order_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_uptime\",\"type\":\"uint256\"}],\"name\":\"calcStcLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_u\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_usdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"joinLog\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_isCt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isjoin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userTop\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_usda\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_is\",\"type\":\"bool\"}],\"name\":\"atmUserRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcUserRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserInivters\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"internalType\":\"struct KoreaAmc.OBJInviter[]\",\"name\":\"obj\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stcRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dynRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDyn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"atmRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timer\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IPancakeV3PoolState\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"regList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"father\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timer\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_father\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "KoreaAmc", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}