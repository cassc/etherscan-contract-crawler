{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.1;\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint256 amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface ISwapPair {\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(\r\n        address to\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal view returns (bytes memory) {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract CTSStake is Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    struct UserInfo {\r\n        bool isExist;\r\n        bool isValid;\r\n        uint256 balance;\r\n        uint256 level;\r\n        uint256 userForce;\r\n        uint256 teamForce;\r\n        uint256 mining;\r\n        uint256 inviteReward;\r\n        uint256 teams;\r\n        uint256 invites;\r\n        uint256 v2;\r\n        uint256 v3;\r\n        uint256 v4;\r\n        uint256 v5;\r\n    }\r\n    struct OrderInfo {\r\n        bool isValid;\r\n        uint256 total;\r\n        uint256 surplus;\r\n        uint256 startTime;\r\n        uint256 startBlock;\r\n        uint256 endBlock;\r\n        uint256 lastBlock;\r\n        uint256 perBlock;\r\n        uint256 fz;\r\n        uint256 cts;\r\n    }\r\n    mapping(address => mapping(uint256 => OrderInfo)) public userOrders;\r\n    mapping(address => uint256) public userOrderNum;\r\n    mapping(address => uint256) public userOrderValidNum;\r\n    mapping(address => UserInfo) public users;\r\n    mapping(uint256 => address) public userAdds;\r\n    mapping(address => address) public userRefers;\r\n    mapping(address => uint256) public userFZ;\r\n    mapping(address => mapping(uint256 => address)) public userInvites;\r\n    mapping(address => uint256) public userInviteTotals;\r\n    uint256 public userTotal;\r\n    uint256 public totalForce;\r\n    uint256 public achievementV1;\r\n    uint256 public achievementV2;\r\n    uint256 public validFZ = 1000e18;\r\n    address public marketA;\r\n    address public marketB;\r\n    ISwapRouter private _swapRouter;\r\n    IERC20 private _ETH;\r\n    IERC20 private _USDT;\r\n    IERC20 private _CTS;\r\n    IERC20 private _FZ;\r\n    event DepositHP(address account, uint256 hp, uint256 usdt, address refer);\r\n    event DepositFZ(address account, uint256 fz, uint256 usdt, address refer);\r\n    event Withdraw(address account, uint256 amount);\r\n\r\n    constructor() {\r\n        marketA = 0x251F50343f1AE7FBd9461fA59F1bFEeb12e55753;\r\n        marketB = 0xe5CC8e63ec619929FC3A58341375462b716c5d90;\r\n        _ETH = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n        _CTS = IERC20(0x8a19083CC8f3aE5DCbd55f7E405cbf6898234eD9);\r\n        _FZ = IERC20(0x351241F08Eff9F72B15afB276Ec0d34Ef63C8692);\r\n        _USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        _swapRouter = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        achievementV1 = 1_0000e18;\r\n        achievementV2 = 15_0000e18;\r\n    }\r\n\r\n    function withdrawToken(\r\n        IERC20 token,\r\n        address account,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        token.transfer(account, amount);\r\n    }\r\n\r\n    function setAchievement(\r\n        uint256 v1,\r\n        uint256 v2,\r\n        uint256 valid\r\n    ) public onlyOwner {\r\n        achievementV1 = v1;\r\n        achievementV2 = v2;\r\n        validFZ = valid;\r\n    }\r\n\r\n    function setToken(\r\n        address eth,\r\n        address usdt,\r\n        address cts,\r\n        address fz\r\n    ) public onlyOwner {\r\n        _ETH = IERC20(eth);\r\n        _USDT = IERC20(usdt);\r\n        _CTS = IERC20(cts);\r\n        _FZ = IERC20(fz);\r\n    }\r\n\r\n    function setMarket(address dataA, address dataB) public onlyOwner {\r\n        marketA = dataA;\r\n        marketB = dataB;\r\n    }\r\n\r\n    function getPriceCTS() public view returns (uint256) {\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(_CTS);\r\n        path[1] = address(_ETH);\r\n        path[2] = address(_USDT);\r\n        return _swapRouter.getAmountsOut(1e18, path)[2];\r\n    }\r\n\r\n    function getOrders(\r\n        address account\r\n    ) public view returns (OrderInfo[] memory ordes) {\r\n        ordes = new OrderInfo[](userOrderNum[account]);\r\n        for (uint256 i = userOrderNum[account]; i > 0; i--) {\r\n            ordes[userOrderNum[account] - i] = userOrders[account][i - 1];\r\n        }\r\n    }\r\n\r\n    function getInvites(\r\n        address account\r\n    ) public view returns (address[] memory invites) {\r\n        invites = new address[](userInviteTotals[account]);\r\n        for (uint256 i = 0; i < userInviteTotals[account]; i++) {\r\n            invites[i] = userInvites[account][i + 1];\r\n        }\r\n    }\r\n\r\n    function getInvitesInfo(\r\n        address account\r\n    ) public view returns (address[] memory invites, UserInfo[] memory infos) {\r\n        invites = new address[](userInviteTotals[account]);\r\n        infos = new UserInfo[](userInviteTotals[account]);\r\n        for (uint256 i = 0; i < userInviteTotals[account]; i++) {\r\n            invites[i] = userInvites[account][i + 1];\r\n            infos[i] = users[invites[i]];\r\n        }\r\n    }\r\n\r\n    function depositFZ(uint256 fz, uint256 usdt, address refer) public {\r\n        address account = msg.sender;\r\n        require(fz % (20e18) == 0, \"Multiple Error FZ\");\r\n        require(usdt % (3e18) == 0, \"Multiple Error CTS\");\r\n        require(usdt == (fz / (20e18)) * 3e18, \"CTS Match FZ\");\r\n        require(_FZ.balanceOf(account) >= fz, \"Insufficient FZ\");\r\n        uint256 priceCTS = getPriceCTS();\r\n        uint256 cts = (usdt * 1e18) / priceCTS;\r\n        require(_CTS.balanceOf(account) >= cts, \"Insufficient CTS\");\r\n        _FZ.transferFrom(account, address(1), fz);\r\n        _CTS.transferFrom(account, address(1), (cts * 96) / 100);\r\n        _CTS.transferFrom(account, marketA, (cts * 2) / 100);\r\n        _CTS.transferFrom(account, marketB, (cts * 2) / 100);\r\n        _handleUserAndRefer(account, refer);\r\n        {\r\n            userOrders[account][userOrderNum[account]] = OrderInfo({\r\n                isValid: true,\r\n                total: cts * 2,\r\n                surplus: cts * 2,\r\n                startTime: block.timestamp,\r\n                startBlock: block.number,\r\n                endBlock: block.number + 360 * 28800,\r\n                lastBlock: block.number,\r\n                perBlock: (cts * 2) / (360 * 28800),\r\n                fz: fz,\r\n                cts: cts\r\n            });\r\n            userOrderNum[account]++;\r\n            users[account].userForce += cts * 2;\r\n            userFZ[account] += fz;\r\n            if (\r\n                !users[account].isValid &&\r\n                userRefers[account] != address(0) &&\r\n                userFZ[account] >= validFZ\r\n            ) {\r\n                users[account].isValid = true;\r\n                users[userRefers[account]].invites += 1;\r\n            }\r\n        }\r\n        _handleTeam(account, fz, true);\r\n        totalForce += cts * 2;\r\n        emit DepositFZ(account, fz, usdt, refer);\r\n    }\r\n\r\n    function withdraw() public {\r\n        address account = msg.sender;\r\n        UserInfo storage user = users[account];\r\n        uint256 total;\r\n        for (\r\n            uint256 i = userOrderValidNum[account];\r\n            i < userOrderNum[account];\r\n            i++\r\n        ) {\r\n            OrderInfo storage order = userOrders[account][i];\r\n            if (block.number < order.endBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (block.number - order.lastBlock);\r\n                total += reward;\r\n                order.lastBlock = block.number;\r\n                if (order.surplus > reward) order.surplus -= reward;\r\n                else order.surplus = 0;\r\n            } else if (order.endBlock > order.lastBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - order.lastBlock);\r\n                total += reward;\r\n                order.lastBlock = order.endBlock;\r\n                order.isValid = false;\r\n                order.surplus = 0;\r\n                userOrderValidNum[account]++;\r\n            }\r\n        }\r\n        if (total > 0) {\r\n            user.balance += total;\r\n            user.mining += total;\r\n        }\r\n        if (user.balance > 0) {\r\n            _handleInviteReward(account, user.balance);\r\n            _CTS.transfer(account, user.balance);\r\n            emit Withdraw(account, user.balance);\r\n            if (user.userForce > user.balance) {\r\n                user.userForce -= user.balance;\r\n            } else {\r\n                user.userForce = 0;\r\n            }\r\n            if (totalForce > user.balance) {\r\n                totalForce -= user.balance;\r\n            } else {\r\n                totalForce = 0;\r\n            }\r\n            user.balance = 0;\r\n        }\r\n    }\r\n\r\n    function getPending(address account) public view returns (uint256 total) {\r\n        for (\r\n            uint256 i = userOrderValidNum[account];\r\n            i < userOrderNum[account];\r\n            i++\r\n        ) {\r\n            OrderInfo memory order = userOrders[account][i];\r\n            if (block.number < order.endBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (block.number - order.lastBlock);\r\n                total += reward;\r\n            } else if (order.endBlock > order.lastBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - order.lastBlock);\r\n                total += reward;\r\n            }\r\n        }\r\n        total += users[account].balance;\r\n    }\r\n\r\n    function _handleUserAndRefer(address account, address refer) private {\r\n        if (refer != address(0) && !users[refer].isExist) {\r\n            UserInfo storage parent = users[refer];\r\n            parent.isExist = true;\r\n            userTotal = userTotal.add(1);\r\n            userAdds[userTotal] = refer;\r\n        }\r\n        UserInfo storage user = users[account];\r\n        if (!user.isExist) {\r\n            user.isExist = true;\r\n            userTotal = userTotal.add(1);\r\n            userAdds[userTotal] = account;\r\n        }\r\n        if (refer != address(0) && userRefers[account] == address(0)) {\r\n            userRefers[account] = refer;\r\n            userInviteTotals[refer] = userInviteTotals[refer].add(1);\r\n            userInvites[refer][userInviteTotals[refer]] = account;\r\n        }\r\n    }\r\n\r\n    function _handleTeam(address account, uint256 amount, bool isAdd) private {\r\n        uint256 index;\r\n        uint256 v1;\r\n        uint256 v2;\r\n        uint256 v3;\r\n        uint256 v4;\r\n        uint256 v5;\r\n        address refer = userRefers[account];\r\n        address[] memory refers = new address[](11);\r\n        refers[index] = refer;\r\n        while (refer != address(0) && index < 10) {\r\n            UserInfo storage user = users[refer];\r\n            if (isAdd) {\r\n                user.teams += amount;\r\n                if (v5 > 0) {\r\n                    user.v5 += v5;\r\n                    if (user.level < 6 && user.v5 >= 2 && user.invites >= 12)\r\n                        user.level = 6;\r\n                }\r\n                if (v4 > 0) {\r\n                    user.v4 += v4;\r\n                    if (user.level < 5 && user.v4 >= 2 && user.invites >= 9) {\r\n                        user.level = 5;\r\n                        v5++;\r\n                    }\r\n                }\r\n                if (v3 > 0) {\r\n                    user.v3 += v3;\r\n                    if (user.level < 4 && user.v3 >= 2 && user.invites >= 7) {\r\n                        user.level = 4;\r\n                        v4++;\r\n                    }\r\n                }\r\n                if (v2 > 0) {\r\n                    user.v2 += v2;\r\n                    if (user.level < 3 && user.v2 >= 2 && user.invites >= 5) {\r\n                        user.level = 3;\r\n                        v3++;\r\n                    }\r\n                }\r\n                if (\r\n                    user.level < 2 &&\r\n                    user.teams >= achievementV2 &&\r\n                    user.invites >= 3\r\n                ) {\r\n                    user.level = 2;\r\n                    v2++;\r\n                }\r\n                if (\r\n                    user.level == 0 &&\r\n                    user.teams >= achievementV1 &&\r\n                    user.invites >= 1\r\n                ) {\r\n                    user.level = 1;\r\n                    v1++;\r\n                }\r\n                user.teamForce += amount;\r\n            } else {\r\n                if (user.teamForce > amount) {\r\n                    user.teamForce -= amount;\r\n                } else {\r\n                    user.teamForce = 0;\r\n                }\r\n            }\r\n            index++;\r\n            bool isExist;\r\n            for (uint256 i = 0; i < refers.length; i++) {\r\n                if (userRefers[refer] == refers[i]) {\r\n                    isExist = true;\r\n                    break;\r\n                }\r\n            }\r\n            refer = userRefers[refer];\r\n            if (isExist) {\r\n                break;\r\n            }\r\n            refers[index] = refer;\r\n        }\r\n    }\r\n\r\n    function _handleInviteReward(address account, uint256 amount) private {\r\n        address refer = userRefers[account];\r\n        uint256 index;\r\n        uint256 current;\r\n        uint256 level;\r\n        uint256 times;\r\n        uint8[6] memory rates = [5, 10, 15, 20, 25, 30];\r\n        while (refer != address(0) && index < 20) {\r\n            UserInfo memory parent = users[refer];\r\n            if (parent.level > level) {\r\n                _updateOrder(\r\n                    refer,\r\n                    (amount * (rates[parent.level - 1] - current)) / 100\r\n                );\r\n                current = rates[parent.level - 1];\r\n                level = parent.level;\r\n            } else if (level == 6 && parent.level == 6 && times < 1) {\r\n                _updateOrder(refer, (amount * 3) / 100);\r\n                times++;\r\n            }\r\n            if (times > 0) break;\r\n            refer = userRefers[refer];\r\n            index++;\r\n        }\r\n    }\r\n\r\n    function _updateOrder(address account, uint256 amount) private {\r\n        UserInfo storage user = users[account];\r\n        uint256 total = amount;\r\n        uint256 rewardTotal;\r\n        uint256 rewardMining;\r\n        for (\r\n            uint256 i = userOrderValidNum[account];\r\n            i < userOrderNum[account];\r\n            i++\r\n        ) {\r\n            OrderInfo storage order = userOrders[account][i];\r\n            if (block.number < order.endBlock) {\r\n                uint256 pending = order.perBlock *\r\n                    (block.number - order.lastBlock);\r\n                rewardMining += pending;\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - block.number);\r\n                bool isEnd;\r\n                if (reward > total) {\r\n                    reward = order.perBlock * (total / order.perBlock);\r\n                    total = 0;\r\n                } else {\r\n                    isEnd = true;\r\n                    total -= reward;\r\n                }\r\n                rewardTotal += (reward + pending);\r\n                order.endBlock = order.endBlock - reward / order.perBlock;\r\n                order.lastBlock = block.number;\r\n                if (order.surplus > (reward + pending) && !isEnd) {\r\n                    order.surplus -= (reward + pending);\r\n                } else {\r\n                    order.surplus = 0;\r\n                    order.isValid = false;\r\n                    userOrderValidNum[account]++;\r\n                }\r\n            } else if (order.endBlock > order.lastBlock) {\r\n                uint256 reward = order.perBlock *\r\n                    (order.endBlock - order.lastBlock);\r\n                rewardTotal += reward;\r\n                rewardMining += reward;\r\n                order.lastBlock = order.endBlock;\r\n                order.isValid = false;\r\n                order.surplus = 0;\r\n                userOrderValidNum[account]++;\r\n            }\r\n            if (total == 0) {\r\n                break;\r\n            }\r\n        }\r\n        if (rewardTotal > 0) {\r\n            user.balance += rewardTotal;\r\n            user.mining += rewardMining;\r\n            user.inviteReward += rewardTotal - rewardMining;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fz\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"DepositFZ\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"DepositHP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"achievementV1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"achievementV2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fz\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refer\",\"type\":\"address\"}],\"name\":\"depositFZ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInvites\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"invites\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInvitesInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"invites\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teams\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invites\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v5\",\"type\":\"uint256\"}],\"internalType\":\"struct CTSStake.UserInfo[]\",\"name\":\"infos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fz\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cts\",\"type\":\"uint256\"}],\"internalType\":\"struct CTSStake.OrderInfo[]\",\"name\":\"ordes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceCTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valid\",\"type\":\"uint256\"}],\"name\":\"setAchievement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dataA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dataB\",\"type\":\"address\"}],\"name\":\"setMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cts\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fz\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalForce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAdds\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFZ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInviteTotals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvites\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOrderNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOrderValidNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fz\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRefers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamForce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teams\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invites\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v5\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validFZ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CTSStake", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c1e0549a5b5b69b50d0b0c7fa561e0382e48c6dd8abe971e669521471ab6d977"}