{"SourceCode": "{\"IContracts.sol\":{\"content\":\"//iBEP20 Interface\\npragma solidity 0.7.4;\\ninterface iBEP20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address, uint256) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address, uint256) external returns (bool);\\n    function transferFrom(address, address, uint256) external returns (bool);\\n    function burnFrom(address, uint256) external;\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n}\\ninterface iBONDv2{\\n    function calcClaimBondedLP(address member, address asset) external returns (uint256);\\n    function claim(address asset) external returns (bool);\\n}\\ninterface iBONDv3{\\n    function calcClaimBondedLP(address member, address asset) external returns (uint256);\\n    function claimAndLock(address asset) external returns (bool);\\n}\\ninterface iBASE {\\n    function claim(address asset, uint256 amount) external payable;  \\n    function secondsPerEra() external view returns (uint256);\\n    function DAO() external view returns (iDAO);\\n    function burn(uint) external;\\n}\\ninterface iROUTER {\\n    function addLiquidity(uint inputBase, uint inputToken, address token) external payable returns (uint units);\\n}\\ninterface iWBNB {\\n    function withdraw(uint256) external;\\n}\\ninterface iUTILS {\\n    function calcPart(uint bp, uint total) external pure returns (uint part);\\n    function calcShare(uint part, uint total, uint amount) external pure returns (uint share);\\n    function calcLiquidityShare(uint units, address token, address pool, address member) external pure returns (uint share);\\n    function calcSwapOutput(uint x, uint X, uint Y) external pure returns (uint output);\\n    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint output);\\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external pure returns (uint units);\\n    function getPoolShare(address token, uint units) external view returns(uint baseAmount, uint tokenAmount);\\n    function getPoolShareAssym(address token, uint units, bool toBase) external view returns(uint baseAmount, uint tokenAmount, uint outputAmt);\\n    function calcValueInBase(address token, uint amount) external view returns (uint value);\\n    function calcValueInToken(address token, uint amount) external view returns (uint value);\\n    function calcValueInBaseWithPool(address pool, uint amount) external view returns (uint value);\\n    function calcTokenPPinBase(address pool, uint256 amount) external view returns (uint256 value);\\n    function getPool(address token)external view returns (address value);\\n}\\ninterface iDAO {\\n    function ROUTER() external view returns(address);\\n    function UTILS() external view returns(iUTILS);\\n    function DAO() external view returns (address);\\n    function depositForMember(address pool, uint256 amount, address member) external;\\n    function deposit(address pool, uint256 amount) external;\\n    function mapMember_weight(address member) external returns (uint256);\\n    function totalWeight() external returns (uint256);\\n}\\n\\n\\n\"},\"Router.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\npragma experimental ABIEncoderV2;\\nimport \\\"./IContracts.sol\\\"; \\ncontract Pool is iBEP20 {\\n    using SafeMath for uint256;\\n\\n    address public BASE;\\n    address public TOKEN;\\n\\n    uint256 public one = 10**18;\\n\\n    // ERC-20 Parameters\\n    string _name; string _symbol;\\n    uint256 public override decimals; uint256 public override totalSupply;\\n    // ERC-20 Mappings\\n    mapping(address =\\u003e uint) private _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint)) private _allowances;\\n\\n    uint public genesis;\\n    uint public baseAmount;\\n    uint public tokenAmount;\\n    uint public baseAmountPooled;\\n    uint public tokenAmountPooled;\\n    uint public fees;\\n    uint public volume;\\n    uint public txCount;\\n\\n    event AddLiquidity(address member, uint inputBase, uint inputToken, uint unitsIssued);\\n    event RemoveLiquidity(address member, uint outputBase, uint outputToken, uint unitsClaimed);\\n    event Swapped(address tokenFrom, address tokenTo, uint inputAmount, uint outputAmount, uint fee, address recipient);\\n\\n    function _DAO() internal view returns(iDAO) {\\n        return iBASE(BASE).DAO();\\n    }\\n\\n    constructor (address _base, address _token) public payable {\\n        BASE = _base;\\n        TOKEN = _token;\\n\\n        string memory poolName = \\\"SpartanPoolV1-\\\";\\n        string memory poolSymbol = \\\"SPT1-\\\";\\n        _name = string(abi.encodePacked(poolName, iBEP20(_token).name()));\\n        _symbol = string(abi.encodePacked(poolSymbol, iBEP20(_token).symbol()));\\n        \\n        decimals = 18;\\n        genesis = block.timestamp;\\n    }\\n\\n    //========================================iBEP20=========================================//\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n    // iBEP20 Transfer function\\n    function transfer(address to, uint256 value) public override returns (bool success) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n    // iBEP20 Approve function\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n    // iBEP20 TransferFrom function\\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\\n        require(value \\u003c= _allowances[from][msg.sender], \\u0027AllowanceErr\\u0027);\\n        _allowances[from][msg.sender] = _allowances[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    // Internal transfer function\\n    function _transfer(address _from, address _to, uint256 _value) private {\\n        require(_balances[_from] \\u003e= _value, \\u0027BalanceErr\\u0027);\\n        require(_balances[_to] + _value \\u003e= _balances[_to], \\u0027BalanceErr\\u0027);\\n        _balances[_from] -= _value;\\n        _balances[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    // Contract can mint\\n    function _mint(address account, uint256 amount) internal {\\n        totalSupply = totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n    // Burn supply\\n    function burn(uint256 amount) public virtual {\\n        _burn(msg.sender, amount);\\n    }\\n    function burnFrom(address from, uint256 value) public virtual override {\\n        require(value \\u003c= _allowances[from][msg.sender], \\u0027AllowanceErr\\u0027);\\n        _allowances[from][msg.sender] -= value;\\n        _burn(from, value);\\n    }\\n    function _burn(address account, uint256 amount) internal virtual {\\n        _balances[account] = _balances[account].sub(amount, \\\"BalanceErr\\\");\\n        totalSupply = totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n\\n    //==================================================================================//\\n    // Asset Movement Functions\\n\\n    // TransferTo function\\n    function transferTo(address recipient, uint256 amount) public returns (bool) {\\n                _transfer(tx.origin, recipient, amount);\\n        return true;\\n    }\\n\\n    // Sync internal balances to actual\\n    function sync() public {\\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\\n    }\\n\\n    // Add liquidity for self\\n    function addLiquidity() public returns(uint liquidityUnits){\\n        liquidityUnits = addLiquidityForMember(msg.sender);\\n        return liquidityUnits;\\n    }\\n\\n    // Add liquidity for a member\\n    function addLiquidityForMember(address member) public returns(uint liquidityUnits){\\n        uint256 _actualInputBase = _getAddedBaseAmount();\\n        uint256 _actualInputToken = _getAddedTokenAmount();\\n        liquidityUnits = _DAO().UTILS().calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply);\\n        _incrementPoolBalances(_actualInputBase, _actualInputToken);\\n        _mint(member, liquidityUnits);\\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\\n        return liquidityUnits;\\n    }\\n\\n    // Remove Liquidity\\n    function removeLiquidity() public returns (uint outputBase, uint outputToken) {\\n        return removeLiquidityForMember(msg.sender);\\n    } \\n\\n    // Remove Liquidity for a member\\n    function removeLiquidityForMember(address member) public returns (uint outputBase, uint outputToken) {\\n        uint units = balanceOf(member);\\n        outputBase = _DAO().UTILS().calcLiquidityShare(units, BASE, address(this), member);\\n        outputToken = _DAO().UTILS().calcLiquidityShare(units, TOKEN, address(this), member);\\n        _decrementPoolBalances(outputBase, outputToken);\\n        _burn(address(this), units);\\n        iBEP20(BASE).transfer(member, outputBase);\\n        iBEP20(TOKEN).transfer(member, outputToken);\\n        emit RemoveLiquidity(member, outputBase, outputToken, units);\\n        return (outputBase, outputToken);\\n    }\\n\\n    function swap(address token) public returns (uint outputAmount, uint fee){\\n        (outputAmount, fee) = swapTo(token, msg.sender);\\n        return (outputAmount, fee);\\n    }\\n\\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\\n        require((token == BASE || token == TOKEN), \\\"Must be BASE or TOKEN\\\");\\n        address _fromToken; uint _amount;\\n        if(token == BASE){\\n            _fromToken = TOKEN;\\n            _amount = _getAddedTokenAmount();\\n            (outputAmount, fee) = _swapTokenToBase(_amount);\\n        } else {\\n            _fromToken = BASE;\\n            _amount = _getAddedBaseAmount();\\n            (outputAmount, fee) = _swapBaseToToken(_amount);\\n        }\\n        emit Swapped(_fromToken, token, _amount, outputAmount, fee, member);\\n        iBEP20(token).transfer(member, outputAmount);\\n        return (outputAmount, fee);\\n    }\\n\\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \\n        if(_baseBalance \\u003e baseAmount){\\n            _actual = _baseBalance.sub(baseAmount);\\n        } else {\\n            _actual = 0;\\n        }\\n        return _actual;\\n    }\\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \\n        if(_tokenBalance \\u003e tokenAmount){\\n            _actual = _tokenBalance.sub(tokenAmount);\\n        } else {\\n            _actual = 0;\\n        }\\n        return _actual;\\n    }\\n\\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\\n        uint256 _X = baseAmount;\\n        uint256 _Y = tokenAmount;\\n        _y =  _DAO().UTILS().calcSwapOutput(_x, _X, _Y);\\n        _fee = _DAO().UTILS().calcSwapFee(_x, _X, _Y);\\n        _setPoolAmounts(_X.add(_x), _Y.sub(_y));\\n        _addPoolMetrics(_y+_fee, _fee, false);\\n        return (_y, _fee);\\n    }\\n\\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\\n        uint256 _X = tokenAmount;\\n        uint256 _Y = baseAmount;\\n        _y =  _DAO().UTILS().calcSwapOutput(_x, _X, _Y);\\n        _fee = _DAO().UTILS().calcSwapFee(_x, _X, _Y);\\n        _setPoolAmounts(_Y.sub(_y), _X.add(_x));\\n        _addPoolMetrics(_y+_fee, _fee, true);\\n        return (_y, _fee);\\n    }\\n\\n    //==================================================================================//\\n    // Data Model\\n\\n\\n    // Increment internal balances\\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\\n        baseAmount += _baseAmount;\\n        tokenAmount += _tokenAmount;\\n        baseAmountPooled += _baseAmount;\\n        tokenAmountPooled += _tokenAmount; \\n    }\\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\\n        baseAmount = _baseAmount;\\n        tokenAmount = _tokenAmount; \\n    }\\n\\n    // Decrement internal balances\\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\\n        uint _removedBase = _DAO().UTILS().calcShare(_baseAmount, baseAmount, baseAmountPooled);\\n        uint _removedToken = _DAO().UTILS().calcShare(_tokenAmount, tokenAmount, tokenAmountPooled);\\n        baseAmountPooled = baseAmountPooled.sub(_removedBase);\\n        tokenAmountPooled = tokenAmountPooled.sub(_removedToken); \\n        baseAmount = baseAmount.sub(_baseAmount);\\n        tokenAmount = tokenAmount.sub(_tokenAmount); \\n    }\\n\\n    function _addPoolMetrics(uint256 _volume, uint256 _fee, bool _toBase) internal {\\n        if(_toBase){\\n            volume += _volume;\\n            fees += _fee;\\n        } else {\\n            volume += _DAO().UTILS().calcValueInBaseWithPool(address(this), _volume);\\n            fees += _DAO().UTILS().calcValueInBaseWithPool(address(this), _fee);\\n        }\\n        txCount += 1;\\n    }\\n}\\n\\ncontract Router {\\n    using SafeMath for uint256;\\n    address public BASE;\\n    address public WBNB;\\n    address public DEPLOYER;\\n\\n    uint public totalPooled; \\n    uint public totalVolume;\\n    uint public totalFees;\\n   \\n    uint public maxTrades;\\n    uint public eraLength;\\n    uint public normalAverageFee;\\n    uint public arrayFeeSize;\\n    uint256 [] public feeArray;\\n\\n    address[] public arrayTokens;\\n    mapping(address=\\u003eaddress) private mapToken_Pool;\\n    mapping(address=\\u003ebool) public isPool;\\n    mapping(address=\\u003ebool) public isCuratedPool;\\n\\n    event NewPool(address token, address pool, uint genesis);\\n    event AddLiquidity(address member, uint inputBase, uint inputToken, uint unitsIssued);\\n    event RemoveLiquidity(address member, uint outputBase, uint outputToken, uint unitsClaimed);\\n    event Swapped(address tokenFrom, address tokenTo, uint inputAmount, uint transferAmount, uint outputAmount, uint fee, address recipient);\\n\\n    // Only DAO can execute\\n    modifier onlyDAO() {\\n        require(msg.sender == _DAO().DAO() || msg.sender == DEPLOYER, \\\"Must be DAO\\\");\\n        _;\\n    }\\n\\n\\n    constructor (address _base, address _wbnb) public payable {\\n        BASE = _base;\\n        WBNB = _wbnb;\\n        arrayFeeSize = 20;\\n        eraLength = 30;\\n        maxTrades = 100;\\n        DEPLOYER = msg.sender;\\n    }\\n\\n    function _DAO() internal view returns(iDAO) {\\n        return iBASE(BASE).DAO();\\n    }\\n\\n    receive() external payable {}\\n\\n    // In case of new router can migrate metrics\\n    function migrateRouterData(address payable oldRouter) public onlyDAO {\\n        totalPooled = 28736281000000000000000000;\\n        totalVolume = Router(oldRouter).totalVolume();\\n        totalFees = Router(oldRouter).totalFees();\\n    }\\n\\n    function migrateTokenData(address payable oldRouter) public onlyDAO {\\n        uint256 tokenCount = Router(oldRouter).tokenCount();\\n        for(uint256 i = 0; i\\u003ctokenCount; i++){\\n            address token = Router(oldRouter).getToken(i);\\n            address pool = Router(oldRouter).getPool(token);\\n            isPool[pool] = true;\\n            arrayTokens.push(token);\\n            mapToken_Pool[token] = pool;\\n        }\\n    }\\n\\n    function purgeDeployer() public onlyDAO {\\n        DEPLOYER = address(0);\\n    }\\n\\n    //==================================================================================//\\n    // Add/Remove Liquidity functions\\n\\n    // Add liquidity for self\\n    function addLiquidity(uint inputBase, uint inputToken, address token) public payable returns (uint units) {\\n        units = addLiquidityForMember(inputBase, inputToken, token, msg.sender);\\n        return units;\\n    }\\n\\n    // Add liquidity for member\\n    function addLiquidityForMember(uint inputBase, uint inputToken, address token, address member) public payable returns (uint units) {\\n        address pool = getPool(token);\\n        uint256 _actualInputBase = _handleTransferIn(BASE, inputBase, pool);\\n        _handleTransferIn(token, inputToken, pool);\\n        totalPooled += _actualInputBase;\\n        units = Pool(pool).addLiquidityForMember(member);\\n         emit AddLiquidity( member,  inputBase,  inputToken,  units);\\n        return units;\\n    }\\n\\n    // Remove % for self\\n    function removeLiquidity(uint basisPoints, address token) public returns (uint outputBase, uint outputToken) {\\n        require((basisPoints \\u003e 0 \\u0026\\u0026 basisPoints \\u003c= 10000), \\\"InputErr\\\");\\n        uint _units = _DAO().UTILS().calcPart(basisPoints, iBEP20(getPool(token)).balanceOf(msg.sender));\\n        return removeLiquidityExact(_units, token);\\n    }\\n\\n    // Remove an exact qty of units\\n    function removeLiquidityExact(uint units, address token) public returns (uint outputBase, uint outputToken) {\\n        address _pool = getPool(token);\\n        address _member = msg.sender;\\n        Pool(_pool).transferTo(_pool, units);\\n        (outputBase, outputToken) = Pool(_pool).removeLiquidity();\\n        _handleTransferOut(token, outputToken, _member);\\n        _handleTransferOut(BASE, outputBase, _member);\\n        totalPooled = totalPooled.sub(outputBase);\\n         emit RemoveLiquidity(_member,  outputBase,  outputToken, units);\\n        return (outputBase, outputToken);\\n    }\\n\\n    //==================================================================================//\\n    // Swapping Functions\\n\\n    function buy(uint256 amount, address token) public returns (uint256 outputAmount, uint256 fee){\\n        return buyTo(amount, token, msg.sender);\\n    }\\n    function buyTo(uint amount, address token, address member) public returns (uint outputAmount, uint fee) {\\n        require(token != BASE, \\\"TokenTypeErr\\\");\\n        address _token = token;\\n        if(token == address(0)){_token = WBNB;} // Handle BNB\\n        address _pool = getPool(token);\\n        uint _actualAmount = _handleTransferIn(BASE, amount, _pool);\\n        (outputAmount, fee) = Pool(_pool).swap(_token);\\n        _handleTransferOut(token, outputAmount, member);\\n        totalPooled += _actualAmount;\\n        totalVolume += _actualAmount;\\n        totalFees += _DAO().UTILS().calcValueInBase(token, fee);\\n        return (outputAmount, fee);\\n    }\\n\\n    function sell(uint amount, address token) public payable returns (uint outputAmount, uint fee){\\n        return sellTo(amount, token, msg.sender);\\n    }\\n    function sellTo(uint amount, address token, address member) public payable returns (uint outputAmount, uint fee) {\\n        require(token != BASE, \\\"TokenTypeErr\\\");\\n        address _pool = getPool(token);\\n        _handleTransferIn(token, amount, _pool);\\n        (outputAmount, fee) = Pool(_pool).swapTo(BASE, member);\\n        totalPooled = totalPooled.sub(outputAmount);\\n        totalVolume += outputAmount;\\n        totalFees += fee;\\n        return (outputAmount, fee);\\n    }\\n\\n    function swap(uint256 inputAmount, address fromToken, address toToken) public payable returns (uint256 outputAmount, uint256 fee) {\\n        return swapTo(inputAmount, fromToken, toToken, msg.sender);\\n    }\\n\\n    function swapTo(uint256 inputAmount, address fromToken, address toToken, address member) public payable returns (uint256 outputAmount, uint256 fee) {\\n        require(fromToken != toToken, \\\"TokenTypeErr\\\");\\n        uint256 _transferAmount = 0;\\n        \\n        if(fromToken == BASE){\\n            (outputAmount, fee) = buyTo(inputAmount, toToken, member);\\n            address _pool = getPool(toToken);\\n            if(isCuratedPool[_pool]){\\n            addTradeFee(fee);//add fee to feeArray\\n            addDividend(toToken, fee); //add dividend\\n            }\\n        } else if(toToken == BASE) {\\n            (outputAmount, fee) = sellTo(inputAmount, fromToken, member);\\n            address _pool = getPool(fromToken);\\n            if(isCuratedPool[_pool]){\\n            addTradeFee(fee);//add fee to feeArray\\n            addDividend(fromToken, fee);\\n            }\\n        } else {\\n            address _poolTo = getPool(toToken);\\n            (uint256 _yy, uint256 _feey) = sellTo(inputAmount, fromToken, _poolTo);\\n            address _toToken = toToken;\\n            address _pool = getPool(fromToken);\\n             if(isCuratedPool[_pool]){\\n            addTradeFee(_feey);//add fee to feeArray\\n            addDividend(fromToken, _feey);\\n             }\\n            if(toToken == address(0)){_toToken = WBNB;} // Handle BNB\\n            (uint _zz, uint _feez) = Pool(_poolTo).swap(_toToken);\\n            if(isCuratedPool[_poolTo]){\\n            addTradeFee(_feez);//add fee to feeArray\\n            addDividend(_toToken,  _feez);\\n            }\\n            _handleTransferOut(toToken, _zz, member);\\n            totalFees += _DAO().UTILS().calcValueInBase(toToken, _feez); \\n            _transferAmount = _yy; outputAmount = _zz; \\n            totalPooled = totalPooled.add(_yy);\\n            fee = _feez + _DAO().UTILS().calcValueInToken(toToken, _feey);\\n        }\\n        emit Swapped(fromToken, toToken, inputAmount, _transferAmount, outputAmount, fee, member);\\n        return (outputAmount, fee);\\n    }\\n\\n    //==================================================================================//\\n    // Token Transfer Functions\\n\\n    function _handleTransferIn(address _token, uint256 _amount, address _pool) internal returns(uint256 actual){\\n        if(_amount \\u003e 0) {\\n            if(_token == address(0)){\\n                // If BNB, then send to WBNB contract, then forward WBNB to pool\\n                require((_amount == msg.value), \\\"InputErr\\\");\\n                payable(WBNB).call{value:_amount}(\\\"\\\"); \\n                iBEP20(WBNB).transfer(_pool, _amount); \\n                actual = _amount;\\n            } else {\\n                uint startBal = iBEP20(_token).balanceOf(_pool); \\n                iBEP20(_token).transferFrom(msg.sender, _pool, _amount); \\n                actual = iBEP20(_token).balanceOf(_pool).sub(startBal);\\n            }\\n        }\\n    }\\n\\n    function _handleTransferOut(address _token, uint256 _amount, address _recipient) internal {\\n        if(_amount \\u003e 0) {\\n            if (_token == address(0)) {\\n                // If BNB, then withdraw to BNB, then forward BNB to recipient\\n                iWBNB(WBNB).withdraw(_amount);\\n                payable(_recipient).call{value:_amount}(\\\"\\\"); \\n            } else {\\n                iBEP20(_token).transfer(_recipient, _amount);\\n            }\\n        }\\n    }\\n\\n    function addDividend(address _token, uint256 _fees) internal returns (bool){\\n        if(!(normalAverageFee == 0)){\\n             uint reserve = iBEP20(BASE).balanceOf(address(this)); // get base balance\\n            if(!(reserve == 0)){\\n            address _pool = getPool(_token);\\n            uint dailyAllocation = reserve.div(eraLength).div(maxTrades); // get max dividend for reserve/30/100 \\n            uint numerator = _fees.mul(dailyAllocation);\\n            uint feeDividend = numerator.div(_fees.add(normalAverageFee));\\n            totalFees = totalFees.add(feeDividend);\\n            iBEP20(BASE).transfer(_pool,feeDividend);   \\n            Pool(_pool).sync();\\n            }\\n        return true;\\n        }\\n       \\n    }\\n    function addTradeFee(uint fee) internal returns (bool) {\\n        uint totalTradeFees = 0;\\n        uint arrayFeeLength = getTradeLength();\\n        if(!(arrayFeeLength == arrayFeeSize)){\\n            feeArray.push(fee);\\n        }else {\\n            addFee(fee);\\n            for(uint i = 0; i\\u003carrayFeeSize; i++){\\n            totalTradeFees = totalTradeFees.add(feeArray[i]);\\n        }\\n        }\\n        normalAverageFee = totalTradeFees.div(arrayFeeSize); \\n    }\\n\\n    function addFee(uint fee) internal returns(bool) {\\n        uint n = feeArray.length;//20\\n        for (uint i = n - 1; i \\u003e 0; i--) {\\n        feeArray[i] = feeArray[i - 1];\\n        }\\n         feeArray[0] = fee;\\n        return true;\\n    }\\n    function changeArrayFeeSize(uint _size) public onlyDAO returns(bool){\\n        arrayFeeSize = _size;\\n        return true;\\n    }\\n    function changeMaxTrades(uint _maxtrades) public onlyDAO returns(bool){\\n        maxTrades = _maxtrades;\\n        return true;\\n    }\\n     function changeEraLength(uint _eraLength) public onlyDAO returns(bool){\\n        eraLength = _eraLength;\\n        return true;\\n    }\\n    function forwardRouterFunds(address newRouterAddress ) public onlyDAO returns(bool){\\n        uint balanceBase = iBEP20(BASE).balanceOf(address(this)); // get base balance\\n        iBEP20(BASE).transfer(newRouterAddress, balanceBase);\\n        return true;\\n    }\\n    function addCuratedPool(address token) public onlyDAO returns (bool){\\n        require(token != BASE);\\n        address _pool = getPool(token);\\n        require(isPool[_pool] == true);\\n        isCuratedPool[_pool] = true;\\n        return true;\\n    }\\n\\n    //======================================HELPERS========================================//\\n    // Helper Functions\\n\\n    function getPool(address token) public view returns(address pool){\\n        if(token == address(0)){\\n            pool = mapToken_Pool[WBNB];   // Handle BNB\\n        } else {\\n            pool = mapToken_Pool[token];  // Handle normal token\\n        } \\n        return pool;\\n    }\\n\\n    function tokenCount() public view returns(uint256){\\n        return arrayTokens.length;\\n    }\\n\\n    function getToken(uint256 i) public view returns(address){\\n        return arrayTokens[i];\\n    }\\n    function getTradeLength() public view returns(uint256){\\n        return feeArray.length;\\n    }\\n     function destroyRouter() public onlyDAO {\\n         selfdestruct(msg.sender);\\n    }\\n\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsIssued\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"genesis\",\"type\":\"uint256\"}],\"name\":\"NewPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsClaimed\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPLOYER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addCuratedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addLiquidityForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arrayFeeSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrayTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"buyTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"changeArrayFeeSize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eraLength\",\"type\":\"uint256\"}],\"name\":\"changeEraLength\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxtrades\",\"type\":\"uint256\"}],\"name\":\"changeMaxTrades\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eraLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"}],\"name\":\"forwardRouterFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradeLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCuratedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTrades\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"oldRouter\",\"type\":\"address\"}],\"name\":\"migrateRouterData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"oldRouter\",\"type\":\"address\"}],\"name\":\"migrateTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"normalAverageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purgeDeployer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeLiquidityExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"sellTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"swapTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPooled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Router", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e4ae305ebe1abe663f261bc00534067c80ad677c000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://312780801e58a4fc7165292b08232ce22b702e07896296e7dc8598badc6601ab"}