{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Collateral.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./CStorage.sol\\\";\\nimport \\\"./CSetter.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/ITarotSolidlyPriceOracleV2.sol\\\";\\nimport \\\"./interfaces/ITarotCallee.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\n\\ncontract Collateral is ICollateral, PoolToken, CStorage, CSetter {\\n    using UQ112x112 for uint224;\\n\\n    constructor() public {}\\n\\n    /*** Collateralization Model ***/\\n\\n    // returns the prices of borrowable0's and borrowable1's underlyings with collateral's underlying as denom\\n    function getPrices() public returns (uint256 price0, uint256 price1) {\\n        uint224 twapPrice112x112;\\n        {\\n            (uint112 _twapReserve0, uint112 _twapReserve1, ) = ITarotSolidlyPriceOracleV2(tarotPriceOracle).getResult(underlying);\\n            twapPrice112x112 = UQ112x112.encode(_twapReserve1).uqdiv(_twapReserve0);\\n        }\\n        (uint112 reserve0, uint112 reserve1, ) =\\n            IUniswapV2Pair(underlying).getReserves();\\n        uint256 collateralTotalSupply =\\n            IUniswapV2Pair(underlying).totalSupply();\\n\\n        uint224 currentPrice112x112 =\\n            UQ112x112.encode(reserve1).uqdiv(reserve0);\\n        uint256 adjustmentSquared =\\n            uint256(twapPrice112x112).mul(2**32).div(currentPrice112x112);\\n        uint256 adjustment = Math.sqrt(adjustmentSquared.mul(2**32));\\n\\n        uint256 currentBorrowable0Price =\\n            uint256(collateralTotalSupply).mul(1e18).div(reserve0 * 2);\\n        uint256 currentBorrowable1Price =\\n            uint256(collateralTotalSupply).mul(1e18).div(reserve1 * 2);\\n\\n        price0 = currentBorrowable0Price.mul(adjustment).div(2**32);\\n        price1 = currentBorrowable1Price.mul(2**32).div(adjustment);\\n\\n        /*\\n         * Price calculation errors may happen in some edge pairs where\\n         * reserve0 / reserve1 is close to 2**112 or 1/2**112\\n         * We're going to prevent users from using pairs at risk from the UI\\n         */\\n        require(price0 > 100, \\\"Tarot: PRICE_CALCULATION_ERROR\\\");\\n        require(price1 > 100, \\\"Tarot: PRICE_CALCULATION_ERROR\\\");\\n    }\\n\\n    // returns liquidity in  collateral's underlying\\n    function _calculateLiquidity(\\n        uint256 amountCollateral,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) internal returns (uint256 liquidity, uint256 shortfall) {\\n        uint256 _safetyMarginSqrt = safetyMarginSqrt;\\n        (uint256 price0, uint256 price1) = getPrices();\\n\\n        uint256 a = amount0.mul(price0).div(1e18);\\n        uint256 b = amount1.mul(price1).div(1e18);\\n        if (a < b) (a, b) = (b, a);\\n        a = a.mul(_safetyMarginSqrt).div(1e18);\\n        b = b.mul(1e18).div(_safetyMarginSqrt);\\n        uint256 collateralNeeded = a.add(b).mul(liquidationPenalty()).div(1e18);\\n\\n        if (amountCollateral >= collateralNeeded) {\\n            return (amountCollateral - collateralNeeded, 0);\\n        } else {\\n            return (0, collateralNeeded - amountCollateral);\\n        }\\n    }\\n\\n    /*** ERC20 ***/\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(tokensUnlocked(from, value), \\\"Tarot: INSUFFICIENT_LIQUIDITY\\\");\\n        super._transfer(from, to, value);\\n    }\\n\\n    function tokensUnlocked(address from, uint256 value) public returns (bool) {\\n        uint256 _balance = balanceOf[from];\\n        if (value > _balance) return false;\\n        uint256 finalBalance = _balance - value;\\n        uint256 amountCollateral = finalBalance.mul(exchangeRate()).div(1e18);\\n        uint256 amount0 = IBorrowable(borrowable0).borrowBalance(from);\\n        uint256 amount1 = IBorrowable(borrowable1).borrowBalance(from);\\n        (, uint256 shortfall) =\\n            _calculateLiquidity(amountCollateral, amount0, amount1);\\n        return shortfall == 0;\\n    }\\n\\n    /*** Collateral ***/\\n\\n    function accountLiquidityAmounts(\\n        address borrower,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) public returns (uint256 liquidity, uint256 shortfall) {\\n        if (amount0 == uint256(-1))\\n            amount0 = IBorrowable(borrowable0).borrowBalance(borrower);\\n        if (amount1 == uint256(-1))\\n            amount1 = IBorrowable(borrowable1).borrowBalance(borrower);\\n        uint256 amountCollateral =\\n            balanceOf[borrower].mul(exchangeRate()).div(1e18);\\n        return _calculateLiquidity(amountCollateral, amount0, amount1);\\n    }\\n\\n    function accountLiquidity(address borrower)\\n        public\\n        returns (uint256 liquidity, uint256 shortfall)\\n    {\\n        return accountLiquidityAmounts(borrower, uint256(-1), uint256(-1));\\n    }\\n\\n    function canBorrow(\\n        address borrower,\\n        address borrowable,\\n        uint256 accountBorrows\\n    ) public returns (bool) {\\n        address _borrowable0 = borrowable0;\\n        address _borrowable1 = borrowable1;\\n        require(\\n            borrowable == _borrowable0 || borrowable == _borrowable1,\\n            \\\"Tarot: INVALID_BORROWABLE\\\"\\n        );\\n        uint256 amount0 =\\n            borrowable == _borrowable0 ? accountBorrows : uint256(-1);\\n        uint256 amount1 =\\n            borrowable == _borrowable1 ? accountBorrows : uint256(-1);\\n        (, uint256 shortfall) =\\n            accountLiquidityAmounts(borrower, amount0, amount1);\\n        return shortfall == 0;\\n    }\\n\\n    // this function must be called from borrowable0 or borrowable1\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256 seizeTokens) {\\n        require(\\n            msg.sender == borrowable0 || msg.sender == borrowable1,\\n            \\\"Tarot: UNAUTHORIZED\\\"\\n        );\\n\\n        (, uint256 shortfall) = accountLiquidity(borrower);\\n        require(shortfall > 0, \\\"Tarot: INSUFFICIENT_SHORTFALL\\\");\\n\\n        uint256 price;\\n        if (msg.sender == borrowable0) (price, ) = getPrices();\\n        else (, price) = getPrices();\\n\\n        uint256 collateralEquivalent = repayAmount.mul(price).div(exchangeRate());\\n\\n        seizeTokens = collateralEquivalent\\n            .mul(liquidationIncentive)\\n            .div(1e18);\\n\\n        balanceOf[borrower] = balanceOf[borrower].sub(\\n            seizeTokens,\\n            \\\"Tarot: LIQUIDATING_TOO_MUCH\\\"\\n        );\\n        balanceOf[liquidator] = balanceOf[liquidator].add(seizeTokens);\\n        emit Transfer(borrower, liquidator, seizeTokens);\\n\\n        if (liquidationFee > 0) {\\n            uint256 seizeFee = collateralEquivalent.mul(liquidationFee).div(1e18);\\n            address reservesManager = IFactory(factory).reservesManager();\\n            balanceOf[borrower] = balanceOf[borrower].sub(seizeFee, \\\"Tarot: LIQUIDATING_TOO_MUCH\\\");\\n            balanceOf[reservesManager] = balanceOf[reservesManager].add(seizeFee);\\n            emit Transfer(borrower, reservesManager, seizeFee);\\n        }\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function flashRedeem(\\n        address redeemer,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external nonReentrant update {\\n        require(redeemAmount <= totalBalance, \\\"Tarot: INSUFFICIENT_CASH\\\");\\n\\n        // optimistically transfer funds\\n        _safeTransfer(redeemer, redeemAmount);\\n        if (data.length > 0)\\n            ITarotCallee(redeemer).tarotRedeem(msg.sender, redeemAmount, data);\\n\\n        uint256 redeemTokens = balanceOf[address(this)];\\n        uint256 declaredRedeemTokens =\\n            redeemAmount.mul(1e18).div(exchangeRate()).add(1); // rounded up\\n        require(\\n            redeemTokens >= declaredRedeemTokens,\\n            \\\"Tarot: INSUFFICIENT_REDEEM_TOKENS\\\"\\n        );\\n\\n        _burn(address(this), redeemTokens);\\n        emit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PoolToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./TarotERC20.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract PoolToken is IPoolToken, TarotERC20 {\\n    uint256 internal constant initialExchangeRate = 1e18;\\n    address public underlying;\\n    address public factory;\\n    uint256 public totalBalance;\\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    /*** Initialize ***/\\n\\n    // called once by the factory\\n    function _setFactory() external {\\n        require(factory == address(0), \\\"Tarot: FACTORY_ALREADY_SET\\\");\\n        factory = msg.sender;\\n    }\\n\\n    /*** PoolToken ***/\\n\\n    function _update() internal {\\n        totalBalance = IERC20(underlying).balanceOf(address(this));\\n        emit Sync(totalBalance);\\n    }\\n\\n    function exchangeRate() public returns (uint256) {\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        uint256 _totalBalance = totalBalance; // gas savings\\n        if (_totalSupply == 0 || _totalBalance == 0) return initialExchangeRate;\\n        return _totalBalance.mul(1e18).div(_totalSupply);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function mint(address minter)\\n        external\\n        nonReentrant\\n        update\\n        returns (uint256 mintTokens)\\n    {\\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\\n        uint256 mintAmount = balance.sub(totalBalance);\\n        mintTokens = mintAmount.mul(1e18).div(exchangeRate());\\n\\n        if (totalSupply == 0) {\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            mintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY);\\n        }\\n        require(mintTokens > 0, \\\"Tarot: MINT_AMOUNT_ZERO\\\");\\n        _mint(minter, mintTokens);\\n        emit Mint(msg.sender, minter, mintAmount, mintTokens);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function redeem(address redeemer)\\n        external\\n        nonReentrant\\n        update\\n        returns (uint256 redeemAmount)\\n    {\\n        uint256 redeemTokens = balanceOf[address(this)];\\n        redeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\\n\\n        require(redeemAmount > 0, \\\"Tarot: REDEEM_AMOUNT_ZERO\\\");\\n        require(redeemAmount <= totalBalance, \\\"Tarot: INSUFFICIENT_CASH\\\");\\n        _burn(address(this), redeemTokens);\\n        _safeTransfer(redeemer, redeemAmount);\\n        emit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    // force real balance to match totalBalance\\n    function skim(address to) external nonReentrant {\\n        _safeTransfer(\\n            to,\\n            IERC20(underlying).balanceOf(address(this)).sub(totalBalance)\\n        );\\n    }\\n\\n    // force totalBalance to match real balance\\n    function sync() external nonReentrant update {}\\n\\n    /*** Utilities ***/\\n\\n    // same safe transfer function used by UniSwapV2 (with fixed underlying)\\n    bytes4 private constant SELECTOR =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    function _safeTransfer(address to, uint256 amount) internal {\\n        (bool success, bytes memory data) =\\n            underlying.call(abi.encodeWithSelector(SELECTOR, to, amount));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"Tarot: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    // prevents a contract from calling itself, directly or indirectly.\\n    bool internal _notEntered = true;\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"Tarot: REENTERED\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true;\\n    }\\n\\n    // update totalBalance with current balance\\n    modifier update() {\\n        _;\\n        _update();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CStorage.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n\\ncontract CStorage {\\n\\taddress public borrowable0;\\n\\taddress public borrowable1;\\n\\taddress public tarotPriceOracle;\\n\\tuint public safetyMarginSqrt = 1.41421356e18; //safetyMargin: 200%\\n\\tuint public liquidationIncentive = 1.02e18; //102%\\n\\tuint public liquidationFee = 0.01e18; //1%\\n\\n\\tfunction liquidationPenalty() public view returns (uint) {\\n\\t\\treturn liquidationIncentive + liquidationFee;\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/CSetter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./CStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/ITarotSolidlyPriceOracleV2.sol\\\";\\n\\ncontract CSetter is PoolToken, CStorage {\\n    uint256 public constant SAFETY_MARGIN_SQRT_MIN = 1.00e18; //safetyMargin: 100%\\n    uint256 public constant SAFETY_MARGIN_SQRT_MAX = 1.58113884e18; //safetyMargin: 250%\\n    uint256 public constant LIQUIDATION_INCENTIVE_MIN = 1.00e18; //100%\\n    uint256 public constant LIQUIDATION_INCENTIVE_MAX = 1.05e18; //105%\\n    uint256 public constant LIQUIDATION_FEE_MAX = 0.05e18; //5%\\n\\n    event NewSafetyMargin(uint256 newSafetyMarginSqrt);\\n    event NewLiquidationIncentive(uint256 newLiquidationIncentive);\\n    event NewLiquidationFee(uint256 newLiquidationFee);\\n\\n    // called once by the factory at the time of deployment\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _borrowable0,\\n        address _borrowable1\\n    ) external {\\n        require(msg.sender == factory, \\\"Tarot: UNAUTHORIZED\\\"); // sufficient check\\n        _setName(_name, _symbol);\\n        underlying = _underlying;\\n        borrowable0 = _borrowable0;\\n        borrowable1 = _borrowable1;\\n        tarotPriceOracle = IFactory(factory).tarotPriceOracle();\\n    }\\n\\n    function _setSafetyMarginSqrt(uint256 newSafetyMarginSqrt)\\n        external\\n        nonReentrant\\n    {\\n        _checkSetting(\\n            newSafetyMarginSqrt,\\n            SAFETY_MARGIN_SQRT_MIN,\\n            SAFETY_MARGIN_SQRT_MAX\\n        );\\n        safetyMarginSqrt = newSafetyMarginSqrt;\\n        emit NewSafetyMargin(newSafetyMarginSqrt);\\n    }\\n\\n    function _setLiquidationIncentive(uint256 newLiquidationIncentive)\\n        external\\n        nonReentrant\\n    {\\n        _checkSetting(\\n            newLiquidationIncentive,\\n            LIQUIDATION_INCENTIVE_MIN,\\n            LIQUIDATION_INCENTIVE_MAX\\n        );\\n        liquidationIncentive = newLiquidationIncentive;\\n        emit NewLiquidationIncentive(newLiquidationIncentive);\\n    }\\n\\n    function _setLiquidationFee(uint256 newLiquidationFee)\\n        external\\n        nonReentrant\\n    {\\n        _checkSetting(\\n            newLiquidationFee,\\n            0,\\n            LIQUIDATION_FEE_MAX\\n        );\\n        liquidationFee = newLiquidationFee;\\n        emit NewLiquidationFee(newLiquidationFee);\\n    }\\n\\n    function _checkSetting(\\n        uint256 parameter,\\n        uint256 min,\\n        uint256 max\\n    ) internal view {\\n        _checkAdmin();\\n        require(parameter >= min, \\\"Tarot: INVALID_SETTING\\\");\\n        require(parameter <= max, \\\"Tarot: INVALID_SETTING\\\");\\n    }\\n\\n    function _checkAdmin() internal view {\\n        require(msg.sender == IFactory(factory).admin(), \\\"Tarot: UNAUTHORIZED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBorrowable.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBorrowable {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** Borrowable ***/\\n\\n    event BorrowApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Borrow(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed receiver,\\n        uint256 borrowAmount,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n    event Liquidate(\\n        address indexed sender,\\n        address indexed borrower,\\n        address indexed liquidator,\\n        uint256 seizeTokens,\\n        uint256 repayAmount,\\n        uint256 accountBorrowsPrior,\\n        uint256 accountBorrows,\\n        uint256 totalBorrows\\n    );\\n\\n    function BORROW_FEE() external pure returns (uint256);\\n\\n    function collateral() external view returns (address);\\n\\n    function reserveFactor() external view returns (uint256);\\n\\n    function exchangeRateLast() external view returns (uint256);\\n\\n    function borrowIndex() external view returns (uint256);\\n\\n    function totalBorrows() external view returns (uint256);\\n\\n    function borrowAllowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function borrowBalance(address borrower) external view returns (uint256);\\n\\n    function borrowTracker() external view returns (address);\\n\\n    function BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function borrowApprove(address spender, uint256 value)\\n        external\\n        returns (bool);\\n\\n    function borrowPermit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function borrow(\\n        address borrower,\\n        address receiver,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function liquidate(address borrower, address liquidator)\\n        external\\n        returns (uint256 seizeTokens);\\n\\n    function trackBorrow(address borrower) external;\\n\\n    /*** Borrowable Interest Rate Model ***/\\n\\n    event AccrueInterest(\\n        uint256 interestAccumulated,\\n        uint256 borrowIndex,\\n        uint256 totalBorrows\\n    );\\n    event CalculateKink(uint256 kinkRate);\\n    event CalculateBorrowRate(uint256 borrowRate);\\n\\n    function KINK_BORROW_RATE_MAX() external pure returns (uint256);\\n\\n    function KINK_BORROW_RATE_MIN() external pure returns (uint256);\\n\\n    function KINK_MULTIPLIER() external pure returns (uint256);\\n\\n    function borrowRate() external view returns (uint256);\\n\\n    function kinkBorrowRate() external view returns (uint256);\\n\\n    function kinkUtilizationRate() external view returns (uint256);\\n\\n    function adjustSpeed() external view returns (uint256);\\n\\n    function rateUpdateTimestamp() external view returns (uint32);\\n\\n    function accrualTimestamp() external view returns (uint32);\\n\\n    function accrueInterest() external;\\n\\n    /*** Borrowable Setter ***/\\n\\n    event NewReserveFactor(uint256 newReserveFactor);\\n    event NewKinkUtilizationRate(uint256 newKinkUtilizationRate);\\n    event NewAdjustSpeed(uint256 newAdjustSpeed);\\n    event NewBorrowTracker(address newBorrowTracker);\\n\\n    function RESERVE_FACTOR_MAX() external pure returns (uint256);\\n\\n    function KINK_UR_MIN() external pure returns (uint256);\\n\\n    function KINK_UR_MAX() external pure returns (uint256);\\n\\n    function ADJUST_SPEED_MIN() external pure returns (uint256);\\n\\n    function ADJUST_SPEED_MAX() external pure returns (uint256);\\n\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _collateral\\n    ) external;\\n\\n    function _setReserveFactor(uint256 newReserveFactor) external;\\n\\n    function _setKinkUtilizationRate(uint256 newKinkUtilizationRate) external;\\n\\n    function _setAdjustSpeed(uint256 newAdjustSpeed) external;\\n\\n    function _setBorrowTracker(address newBorrowTracker) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollateral.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ICollateral {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** Collateral ***/\\n\\n    function borrowable0() external view returns (address);\\n\\n    function borrowable1() external view returns (address);\\n\\n    function tarotPriceOracle() external view returns (address);\\n\\n    function safetyMarginSqrt() external view returns (uint256);\\n\\n    function liquidationIncentive() external view returns (uint256);\\n \\n    function liquidationFee() external view returns (uint256);\\n\\n    function liquidationPenalty() external view returns (uint256);\\n\\n    function getPrices() external returns (uint256 price0, uint256 price1);\\n\\n    function tokensUnlocked(address from, uint256 value)\\n        external\\n        returns (bool);\\n\\n    function accountLiquidityAmounts(\\n        address account,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external returns (uint256 liquidity, uint256 shortfall);\\n\\n    function accountLiquidity(address account)\\n        external\\n        returns (uint256 liquidity, uint256 shortfall);\\n\\n    function canBorrow(\\n        address account,\\n        address borrowable,\\n        uint256 accountBorrows\\n    ) external returns (bool);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256 seizeTokens);\\n\\n    function flashRedeem(\\n        address redeemer,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    /*** Collateral Setter ***/\\n\\n    event NewSafetyMargin(uint256 newSafetyMarginSqrt);\\n    event NewLiquidationIncentive(uint256 newLiquidationIncentive);\\n    event NewLiquidationFee(uint256 newLiquidationFee);\\n\\n    function SAFETY_MARGIN_SQRT_MIN() external pure returns (uint256);\\n\\n    function SAFETY_MARGIN_SQRT_MAX() external pure returns (uint256);\\n\\n    function LIQUIDATION_INCENTIVE_MIN() external pure returns (uint256);\\n\\n    function LIQUIDATION_INCENTIVE_MAX() external pure returns (uint256);\\n\\n    function LIQUIDATION_FEE_MAX() external pure returns (uint256);\\n\\n    function _initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _underlying,\\n        address _borrowable0,\\n        address _borrowable1\\n    ) external;\\n\\n    function _setSafetyMarginSqrt(uint256 newSafetyMarginSqrt) external;\\n\\n    function _setLiquidationIncentive(uint256 newLiquidationIncentive) external;\\n\\n    function _setLiquidationFee(uint256 newLiquidationFee) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IFactory {\\n\\tevent LendingPoolInitialized(address indexed uniswapV2Pair, address indexed token0, address indexed token1,\\n\\t\\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\\n\\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\tevent NewAdmin(address oldAdmin, address newAdmin);\\n\\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\\n\\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\\n\\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\\n\\t\\n\\tfunction admin() external view returns (address);\\n\\tfunction pendingAdmin() external view returns (address);\\n\\tfunction reservesAdmin() external view returns (address);\\n\\tfunction reservesPendingAdmin() external view returns (address);\\n\\tfunction reservesManager() external view returns (address);\\n\\n\\tfunction getLendingPool(address uniswapV2Pair) external view returns (\\n\\t\\tbool initialized, \\n\\t\\tuint24 lendingPoolId, \\n\\t\\taddress collateral, \\n\\t\\taddress borrowable0, \\n\\t\\taddress borrowable1\\n\\t);\\n\\tfunction allLendingPools(uint) external view returns (address uniswapV2Pair);\\n\\tfunction allLendingPoolsLength() external view returns (uint);\\n\\t\\n\\tfunction bDeployer() external view returns (address);\\n\\tfunction cDeployer() external view returns (address);\\n\\tfunction tarotPriceOracle() external view returns (address);\\n\\n\\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral);\\n\\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0);\\n\\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1);\\n\\tfunction initializeLendingPool(address uniswapV2Pair) external;\\n\\n\\tfunction _setPendingAdmin(address newPendingAdmin) external;\\n\\tfunction _acceptAdmin() external;\\n\\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\\n\\tfunction _acceptReservesAdmin() external;\\n\\tfunction _setReservesManager(address newReservesManager) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITarotSolidlyPriceOracleV2.sol\": {\r\n      \"content\": \"pragma solidity >=0.5;\\n\\ninterface ITarotSolidlyPriceOracleV2 {\\n    function MIN_T() external pure returns (uint32);\\n\\n    function getResult(address pair) external returns (uint112 reserve0, uint112 reserve1, uint32 T);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITarotCallee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ITarotCallee {\\n    function tarotBorrow(\\n        address sender,\\n        address borrower,\\n        uint256 borrowAmount,\\n        bytes calldata data\\n    ) external;\\n\\n    function tarotRedeem(\\n        address sender,\\n        uint256 redeemAmount,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/UQ112x112.sol\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing various math operations\\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TarotERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\n// This contract is basically UniswapV2ERC20 with small modifications\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\\n\\ncontract TarotERC20 {\\n    using SafeMath for uint256;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    mapping(address => uint256) public nonces;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    constructor() public {}\\n\\n    function _setName(string memory _name, string memory _symbol) internal {\\n        name = _name;\\n        symbol = _symbol;\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(_name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        balanceOf[from] = balanceOf[from].sub(\\n            value,\\n            \\\"Tarot: TRANSFER_TOO_HIGH\\\"\\n        );\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\\n                value,\\n                \\\"Tarot: TRANSFER_NOT_ALLOWED\\\"\\n            );\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _checkSignature(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes32 typehash\\n    ) internal {\\n        require(deadline >= block.timestamp, \\\"Tarot: EXPIRED\\\");\\n        bytes32 digest =\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR,\\n                    keccak256(\\n                        abi.encode(\\n                            typehash,\\n                            owner,\\n                            spender,\\n                            value,\\n                            nonces[owner]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"Tarot: INVALID_SIGNATURE\\\"\\n        );\\n    }\\n\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        _checkSignature(\\n            owner,\\n            spender,\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s,\\n            PERMIT_TYPEHASH\\n        );\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IPoolToken {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationFee\",\"type\":\"uint256\"}],\"name\":\"NewLiquidationFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"NewLiquidationIncentive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSafetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"NewSafetyMargin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_FEE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_INCENTIVE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_INCENTIVE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_MARGIN_SQRT_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_MARGIN_SQRT_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowable0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowable1\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidationFee\",\"type\":\"uint256\"}],\"name\":\"_setLiquidationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"_setLiquidationIncentive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSafetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"_setSafetyMarginSqrt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"accountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfall\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"accountLiquidityAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfall\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowable0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowable1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"}],\"name\":\"canBorrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationIncentive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safetyMarginSqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tarotPriceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokensUnlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Collateral", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}