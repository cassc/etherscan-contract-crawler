{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BNBAbylon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a);\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Percent {\\r\\n    struct percent {\\r\\n        uint256 num;\\r\\n        uint256 den;\\r\\n    }\\r\\n\\r\\n    function mul(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        return (a * p.num) / p.den;\\r\\n    }\\r\\n\\r\\n    function div(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        return (a / p.num) * p.den;\\r\\n    }\\r\\n\\r\\n    function sub(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        uint256 b = mul(p, a);\\r\\n        if (b >= a) return 0;\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function add(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        return a + mul(p, a);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BNBAbylon is ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using Percent for Percent.percent;\\r\\n\\r\\n    struct Plan {\\r\\n        Percent.percent daily;\\r\\n        Percent.percent max_payout;\\r\\n        Percent.percent additional;\\r\\n        uint256 max_additional;\\r\\n        uint256 min_deposit;\\r\\n        uint256 max_deposit;\\r\\n        uint256 min_withdraw;\\r\\n    }\\r\\n\\r\\n    struct User {\\r\\n        address sponsor;\\r\\n        uint256 bonus;\\r\\n        uint256 deposited;\\r\\n        uint256 reinvested;\\r\\n        uint256 turnover_bonus;\\r\\n        uint256 turnover;\\r\\n        uint256 withdrawn;\\r\\n        uint256 withdraw_ref_date;\\r\\n        mapping(uint256 => uint256) referrals;\\r\\n    }\\r\\n\\r\\n    struct UserPlan {\\r\\n        uint256 pending;\\r\\n        uint256 pending_payout;\\r\\n        uint256 deposited;\\r\\n        uint256 withdrawn_payout;\\r\\n        uint256 withdraw_date;\\r\\n        uint256 last_date;\\r\\n    }\\r\\n\\r\\n    uint256 private ONE_DAY = 1 days;\\r\\n    uint256 private MIN_BONUS_WITHDRAWAL = 5e16;\\r\\n    uint256 private TURNOVER_BONUS_EVERY = 200e18;\\r\\n    uint256 private TURNOVER_BONUS_AMOUNT = 20e18;\\r\\n\\r\\n    address payable private owner =\\r\\n        payable(0x5c00114237e2FC579B80176dca49dBfd639a2cC8);\\r\\n    address payable private promote =\\r\\n        payable(0x979707294108A6Ec6A5A304E3709ce7A223AB0B9);\\r\\n\\r\\n    Percent.percent private ADMIN_FEE = Percent.percent(12, 100);\\r\\n    Percent.percent private WITHDRAW_REINVEST = Percent.percent(20, 100);\\r\\n\\r\\n    Percent.percent[] private PERCENT_REFERRAL;\\r\\n    Plan[] private PLANS;\\r\\n\\r\\n    mapping(address => User) public users;\\r\\n    mapping(address => mapping(uint256 => UserPlan)) public user_plans;\\r\\n\\r\\n    uint256 public total_deposited;\\r\\n    uint256 public total_rewards;\\r\\n    uint256 public total_reinvested;\\r\\n\\r\\n    event Sponsor(address indexed addr, address indexed sponsor);\\r\\n    event Deposit(address indexed addr, uint256 plan, uint256 amount);\\r\\n    event Reinvest(address indexed addr, uint256 plan, uint256 amount);\\r\\n    event Payout(address indexed addr, address indexed from, uint256 amount);\\r\\n    event Withdraw(address indexed addr, uint256 plan, uint256 amount);\\r\\n\\r\\n    constructor() {\\r\\n        PERCENT_REFERRAL.push(Percent.percent(6, 100));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(4, 100));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(2, 100));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(2, 100));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(1, 100));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(1, 100));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(5, 1000));\\r\\n        PERCENT_REFERRAL.push(Percent.percent(5, 1000));\\r\\n\\r\\n        PLANS.push(\\r\\n            Plan(\\r\\n                Percent.percent(2, 100),\\r\\n                Percent.percent(120, 100),\\r\\n                Percent.percent(1, 1000),\\r\\n                10,\\r\\n                5e16,\\r\\n                1e18,\\r\\n                1e16\\r\\n            )\\r\\n        );\\r\\n\\r\\n        PLANS.push(\\r\\n            Plan(\\r\\n                Percent.percent(1, 100),\\r\\n                Percent.percent(160, 100),\\r\\n                Percent.percent(1, 1000),\\r\\n                10,\\r\\n                1e18,\\r\\n                4e18,\\r\\n                5e16\\r\\n            )\\r\\n        );\\r\\n\\r\\n        PLANS.push(\\r\\n            Plan(\\r\\n                Percent.percent(1, 100),\\r\\n                Percent.percent(200, 100),\\r\\n                Percent.percent(1, 1000),\\r\\n                10,\\r\\n                4e18,\\r\\n                10e18,\\r\\n                5e17\\r\\n            )\\r\\n        );\\r\\n\\r\\n        PLANS.push(\\r\\n            Plan(\\r\\n                Percent.percent(15, 1000),\\r\\n                Percent.percent(300, 100),\\r\\n                Percent.percent(1, 1000),\\r\\n                10,\\r\\n                10e18,\\r\\n                0,\\r\\n                5e17\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        _deposit(0, msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    function _setSponsor(address _addr, address _sponsor) private {\\r\\n        if (\\r\\n            users[_addr].sponsor == address(0) &&\\r\\n            _sponsor != _addr &&\\r\\n            _addr != owner &&\\r\\n            (user_plans[_sponsor][0].last_date > 0 || _sponsor == owner)\\r\\n        ) {\\r\\n            users[_addr].sponsor = _sponsor;\\r\\n\\r\\n            emit Sponsor(_addr, _sponsor);\\r\\n\\r\\n            for (uint8 i = 0; i < PERCENT_REFERRAL.length; i++) {\\r\\n                if (_sponsor == address(0)) break;\\r\\n                users[_sponsor].referrals[i]++;\\r\\n                _sponsor = users[_sponsor].sponsor;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _deposit(uint256 _plan, address _addr, uint256 _amount) private {\\r\\n        require(_plan >= 0 && _plan < PLANS.length, \\\"Bad plan\\\");\\r\\n        require(_amount > 0, \\\"Zero amount\\\");\\r\\n        require(\\r\\n            user_plans[_addr][_plan].deposited + _amount >= PLANS[_plan].min_deposit,\\r\\n            \\\"Wrong min amount\\\"\\r\\n        );\\r\\n        if (PLANS[_plan].max_deposit > 0)\\r\\n            require(\\r\\n                user_plans[_addr][_plan].deposited + _amount <= PLANS[_plan].max_deposit,\\r\\n                \\\"Wrong max amount\\\"\\r\\n            );\\r\\n        if (_plan != 0)\\r\\n            require(\\r\\n                user_plans[_addr][_plan - 1].deposited > 0,\\r\\n                \\\"Previous plan not activated\\\"\\r\\n            );\\r\\n\\r\\n        uint256 pending = this.payoutOf(_plan, _addr);\\r\\n        if (pending > 0) user_plans[_addr][_plan].pending += pending;\\r\\n\\r\\n        user_plans[_addr][_plan].last_date = block.timestamp;\\r\\n        user_plans[_addr][_plan].deposited += _amount;\\r\\n        users[_addr].deposited += _amount;\\r\\n        total_deposited += _amount;\\r\\n\\r\\n        _refPayout(_addr, _amount);\\r\\n\\r\\n        (bool successPromoteFee, ) = promote.call{value: ADMIN_FEE.mul(_amount)}(\\r\\n            \\\"\\\"\\r\\n        );\\r\\n        require(successPromoteFee, \\\"Transfer failed.\\\");\\r\\n\\r\\n        emit Deposit(_addr, _plan, _amount);\\r\\n    }\\r\\n\\r\\n    function _reinvest(uint256 _plan, address _addr, uint256 _amount) private {\\r\\n        uint256 pending = this.payoutOf(_plan, _addr);\\r\\n        if (pending > 0) user_plans[_addr][_plan].pending += pending;\\r\\n\\r\\n        user_plans[_addr][_plan].last_date = block.timestamp;\\r\\n        user_plans[_addr][_plan].deposited += _amount;\\r\\n        users[_addr].reinvested += _amount;\\r\\n        total_reinvested += _amount;\\r\\n\\r\\n        emit Reinvest(_addr, _plan, _amount);\\r\\n    }\\r\\n\\r\\n    function _refPayout(address _addr, uint256 _amount) private {\\r\\n        address up = users[_addr].sponsor;\\r\\n\\r\\n        for (uint256 i = 0; i <= PERCENT_REFERRAL.length; i++) {\\r\\n            if (up == address(0)) break;\\r\\n            uint256 bonus = PERCENT_REFERRAL[i].mul(_amount);\\r\\n\\r\\n            if (i == 0) {\\r\\n                users[up].turnover_bonus += _amount;\\r\\n\\r\\n                if (users[up].turnover_bonus >= TURNOVER_BONUS_EVERY) {\\r\\n                    bonus += TURNOVER_BONUS_AMOUNT;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            users[up].turnover += _amount;\\r\\n            users[up].bonus += bonus;\\r\\n            total_rewards += bonus;\\r\\n            emit Payout(up, _addr, bonus);\\r\\n            up = users[up].sponsor;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 _plan, address _sponsor) external payable nonReentrant {\\r\\n        _setSponsor(msg.sender, _sponsor);\\r\\n        _deposit(_plan, msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 _plan) external nonReentrant {\\r\\n        require(_plan <= PLANS.length, \\\"Invalid plan\\\");\\r\\n\\r\\n        uint256 payout = 0;\\r\\n        uint256 payoutFull = 0;\\r\\n        if (_plan == PLANS.length) {\\r\\n            payoutFull = users[msg.sender].bonus;\\r\\n            require(payoutFull > 0, \\\"Zero payout\\\");\\r\\n            require(\\r\\n                payoutFull >= MIN_BONUS_WITHDRAWAL,\\r\\n                \\\"Minimum withdrawal amount is 0.05 BNB\\\"\\r\\n            );\\r\\n\\r\\n            uint256 diff = (block.timestamp -\\r\\n                users[msg.sender].withdraw_ref_date) / ONE_DAY;\\r\\n            require(diff > 0, \\\"One withdrawal per day is allowed\\\");\\r\\n\\r\\n            users[msg.sender].bonus = 0;\\r\\n            users[msg.sender].withdraw_ref_date = block.timestamp;\\r\\n\\r\\n            payout = payoutFull;\\r\\n        } else {\\r\\n            payoutFull = this.payoutOf(_plan, msg.sender);\\r\\n            require(payoutFull > 0, \\\"Zero payout\\\");\\r\\n\\r\\n            Plan storage plan = PLANS[_plan];\\r\\n            require(payoutFull >= plan.min_withdraw, \\\"Wrong minimum withdrawal amount\\\");\\r\\n\\r\\n            uint256 diff = (block.timestamp -\\r\\n                user_plans[msg.sender][_plan].withdraw_date) / ONE_DAY;\\r\\n            require(diff > 0, \\\"One withdrawal per day is allowed\\\");\\r\\n\\r\\n            uint256 reinvest = WITHDRAW_REINVEST.mul(payoutFull);\\r\\n            payout = payoutFull - reinvest;\\r\\n\\r\\n            user_plans[msg.sender][_plan].pending = 0;\\r\\n            user_plans[msg.sender][_plan].pending_payout = 0;\\r\\n            user_plans[msg.sender][_plan].last_date = block.timestamp;\\r\\n            user_plans[msg.sender][_plan].withdraw_date = block.timestamp;\\r\\n            user_plans[msg.sender][_plan].withdrawn_payout += payout;\\r\\n\\r\\n            _reinvest(_plan, msg.sender, reinvest);\\r\\n        }\\r\\n\\r\\n        users[msg.sender].withdrawn += payoutFull;\\r\\n\\r\\n        (bool successWithdraw, ) = msg.sender.call{value:payout}(\\\"\\\");\\r\\n        require(successWithdraw, \\\"Transfer failed.\\\");\\r\\n\\r\\n        emit Withdraw(msg.sender, _plan, payoutFull);\\r\\n    }\\r\\n\\r\\n    function maxPayoutOf(\\r\\n        uint256 _plan,\\r\\n        uint256 _amount\\r\\n    ) internal view returns (uint256) {\\r\\n        return PLANS[_plan].max_payout.mul(_amount);\\r\\n    }\\r\\n\\r\\n    function payoutOf(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) external view returns (uint256 payout) {\\r\\n        uint256 max_payout = maxPayoutOf(\\r\\n            _plan,\\r\\n            user_plans[_addr][_plan].deposited\\r\\n        );\\r\\n        if (user_plans[_addr][_plan].withdrawn_payout >= max_payout) return 0;\\r\\n        payout =\\r\\n            (dailyBonus(_plan, _addr) + holdBonus(_plan, _addr)) +\\r\\n            user_plans[_addr][_plan].pending +\\r\\n            user_plans[_addr][_plan].pending_payout;\\r\\n        if (user_plans[_addr][_plan].withdrawn_payout + payout >= max_payout)\\r\\n            return max_payout - user_plans[_addr][_plan].withdrawn_payout;\\r\\n        return payout;\\r\\n    }\\r\\n\\r\\n    function dailyBonus(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) internal view returns (uint256 percent) {\\r\\n        if (user_plans[_addr][_plan].last_date == 0) return 0;\\r\\n        return\\r\\n            (PLANS[_plan].daily.mul(user_plans[_addr][_plan].deposited) *\\r\\n                (block.timestamp - user_plans[_addr][_plan].last_date)) /\\r\\n            ONE_DAY;\\r\\n    }\\r\\n\\r\\n    function getHoldBonus(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) public view returns (uint256 percent) {\\r\\n        if (user_plans[_addr][_plan].last_date == 0) return 0;\\r\\n        uint256 ldays = block\\r\\n            .timestamp\\r\\n            .sub(user_plans[_addr][_plan].last_date)\\r\\n            .div(ONE_DAY);\\r\\n        return\\r\\n            ldays > PLANS[_plan].max_additional\\r\\n                ? PLANS[_plan].max_additional\\r\\n                : ldays;\\r\\n    }\\r\\n\\r\\n    function holdBonus(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) internal view returns (uint256 percent) {\\r\\n        if (user_plans[_addr][_plan].last_date == 0) return 0;\\r\\n        uint256 ldays = block\\r\\n            .timestamp\\r\\n            .sub(user_plans[_addr][_plan].last_date)\\r\\n            .div(ONE_DAY);\\r\\n        if (ldays == 0) return 0;\\r\\n\\r\\n        uint256 bonus = 0;\\r\\n        uint256 holdBonusMultiplier = getHoldBonus(_plan, _addr);\\r\\n\\r\\n        for (uint256 i = 1; i <= holdBonusMultiplier; i++) {\\r\\n            if (i == 10) bonus += (user_plans[_addr][_plan].deposited * (PLANS[_plan].additional.num * i)) / PLANS[_plan].additional.den * (ldays - 9);\\r\\n            else bonus += (user_plans[_addr][_plan].deposited * (PLANS[_plan].additional.num * i)) / PLANS[_plan].additional.den;\\r\\n        }\\r\\n\\r\\n        return bonus;\\r\\n    }\\r\\n\\r\\n    function referralsCount(\\r\\n        address _addr,\\r\\n        uint256 _level\\r\\n    ) external view returns (uint256 referrals) {\\r\\n        return users[_addr].referrals[_level];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"Sponsor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getHoldBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"payoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"referralsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_reinvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_plans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending_payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn_payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw_date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw_ref_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BNBAbylon", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}