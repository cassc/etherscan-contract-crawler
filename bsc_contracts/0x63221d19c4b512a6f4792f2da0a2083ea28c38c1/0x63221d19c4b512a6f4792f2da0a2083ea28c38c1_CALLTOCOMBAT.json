{"SourceCode": "/*\r\n\r\n\u2588\u2580\u2580 \u2588\u2580\u2580\u2588 \u2588\u2500\u2500 \u2588\u2500\u2500 \u2580\u2580\u2588\u2580\u2580 \u2588\u2580\u2580\u2588 \u2588\u2580\u2580 \u2588\u2580\u2580\u2588 \u2588\u2580\u2584\u2580\u2588 \u2588\u2580\u2580\u2584 \u2588\u2580\u2580\u2588 \u2580\u2580\u2588\u2580\u2580 \r\n\u2588\u2500\u2500 \u2588\u2584\u2584\u2588 \u2588\u2500\u2500 \u2588\u2500\u2500 \u2500\u2500\u2588\u2500\u2500 \u2588\u2500\u2500\u2588 \u2588\u2500\u2500 \u2588\u2500\u2500\u2588 \u2588\u2500\u2580\u2500\u2588 \u2588\u2580\u2580\u2584 \u2588\u2584\u2584\u2588 \u2500\u2500\u2588\u2500\u2500 \r\n\u2580\u2580\u2580 \u2580\u2500\u2500\u2580 \u2580\u2580\u2580 \u2580\u2580\u2580 \u2500\u2500\u2580\u2500\u2500 \u2580\u2580\u2580\u2580 \u2580\u2580\u2580 \u2580\u2580\u2580\u2580 \u2580\u2500\u2500\u2500\u2580 \u2580\u2580\u2580\u2500 \u2580\u2500\u2500\u2580 \u2500\u2500\u2580\u2500\u2500 \r\n\r\n\u2591\u2588\u2580\u2580\u2588 \u2588\u2500\u2500 \u2588\u2580\u2580\u2588 \u2588\u2500\u2500\u2588 \u3000 \u2580\u2580\u2588\u2580\u2580 \u2588\u2580\u2580\u2588 \u3000 \u2588\u2580\u2580 \u2588\u2580\u2580\u2588 \u2588\u2580\u2580\u2588 \u2588\u2580\u2580\u2584 \r\n\u2591\u2588\u2584\u2584\u2588 \u2588\u2500\u2500 \u2588\u2584\u2584\u2588 \u2588\u2584\u2584\u2588 \u3000 \u2500\u2500\u2588\u2500\u2500 \u2588\u2500\u2500\u2588 \u3000 \u2588\u2580\u2580 \u2588\u2584\u2584\u2588 \u2588\u2584\u2584\u2580 \u2588\u2500\u2500\u2588 \r\n\u2591\u2588\u2500\u2500\u2500 \u2580\u2580\u2580 \u2580\u2500\u2500\u2580 \u2584\u2584\u2584\u2588 \u3000 \u2500\u2500\u2580\u2500\u2500 \u2580\u2580\u2580\u2580 \u3000 \u2580\u2580\u2580 \u2580\u2500\u2500\u2580 \u2580\u2500\u2580\u2580 \u2580\u2500\u2500\u2580\r\n\r\n##CALLTOCOMBAT\r\n\r\n+++++++++++++++Tokenomics\r\n>> 5% BUY TAX\r\n>> 15% SELL TAX\r\n>> TOTAL SUPPLY 100,000,000 $CTC\r\n>> DEV CANNOT SET MAX FEE 100%\r\n>> AUTOMATIC IDO UNLOCK\r\n>> NO MINT\r\n>> REWARDING HOLDERS BUSD WITH NO REBASE!!!!!\r\n\r\n+++++++++++++++Tax Breakdown\r\n>> 15% BUY OR SELL TAX SENT TO INSURANCE RESERVE\r\n>> 5% BUY OR SELL TAX AUTOMATICALLY BURNED\r\n>> 85% BUY OR SELL TAX SENT TO REWARD ALL HOLDERS\r\n\r\n+++++++++++++++Socials\r\nGithub >> https://github.com/calltocombat\r\nTelegram Chat >> https://t.me/calltocombat\r\nTelegram News >> https://t.me/calltocombatnews\r\nTwitter >> https://twitter.com/combatcall\r\nYoutube >> https://www.youtube.com/channel/UCbyecUgKyKvLKJU1OIczbyg\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    \r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be authorized\r\n     */\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    /**\r\n     * Authorize address. Owner only\r\n     */\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    /**\r\n     * Remove address' authorization. Owner only\r\n     */\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\t\r\n\tfunction swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface readIDOContract {\r\n  function getIDOAmount(address _address) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract CALLTOCOMBAT is IBEP20, Auth {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant MASK = type(uint128).max;\r\n    address BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\taddress ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    string constant _name = \"CALLTOCOMBAT\";\r\n    string constant _symbol = \"CTC\";\r\n    uint8 constant _decimals = 9;\r\n\r\n    uint256 _totalSupply = 100_000_000 * (10 ** _decimals);\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    mapping (address => bool) isFeeExempt;\r\n\r\n  \r\n    uint256 public totalbuyFee = 5; //general buy tax\r\n\tuint256 public totalsellFee = 15; //general sell tax\r\n\t\r\n\tuint256 public insuranceFee = 15;\r\n\tuint256 public burnFee = 5; \r\n\tuint256 public rewardsFee = 80;\r\n\tuint256 tFeeTotal;\r\n\t\r\n\tuint256 maxtotalbuyFee = 10; //NOTE:<--prevent dev from exceeding this level set buy fee!\r\n\tuint256 maxtotalsellFee = 20; //NOTE:<--prevent dev from exceeding this level set sell fee!\r\n\tuint256 feeDenominator = 100; //100%\r\n\tuint256 public unlocktimestamp;\r\n\t\r\n\tuint256 public swapThreshold; \r\n\r\n\r\n    address public rewardscontractReceiver; \r\n    address public insuranceFundReceiver;\r\n\taddress public idoContract; //NOTE:<--bookkeeping for IDO. will be ejected automatically after the unlock time. (end of IDO)\r\n\t\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    uint256 public launchedAt;\r\n    uint256 public launchedAtTimestamp;\r\n\r\n\r\n    bool inSwap;\r\n    bool public swapEnabled = true;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor (\r\n        address _dexRouter\r\n    ) Auth(msg.sender) {\r\n        router = IDEXRouter(_dexRouter);\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        WBNB = router.WETH();\r\n        isFeeExempt[msg.sender] = true;\r\n\r\n        rewardscontractReceiver = msg.sender;\r\n        insuranceFundReceiver = msg.sender;\r\n        unlocktimestamp = block.timestamp;\r\n\t\tswapThreshold = _totalSupply.div(10000); //0.01% required token to swap back\r\n        approve(_dexRouter, _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { } //to receive BNB from pcs\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _tokentransfer(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != _totalSupply){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _tokentransfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _tokentransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n\t\tif (idoContract != address(0)) {\r\n                uint256 totalPurchasedAmount = readIDOContract(idoContract).getIDOAmount(sender);\r\n                require(balanceOf(sender).sub(amount) >= totalPurchasedAmount, \"$CTC tokens purchased during IDO cannot be transferred yet.\");\r\n            }\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n\r\n        if(shouldSwapBack()){ swapBack(); } //this initiates the buy back from contract balance\r\n\t\t\r\n\t\tif(shouldUnlock()){ forceUnlock(); } //this initiates the Automatic Unlock of Locked IDO Tokens\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n\r\n        uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, recipient, amount) : amount;\r\n\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n\t\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n\t\temit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        return !isFeeExempt[sender];\r\n    }\r\n\r\n\r\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\r\n        //check and collect fees!!--dump fees into contract to be utilized!\r\n\t\tif (sender == pair) {\r\n        uint256 feeAmountperc = totalbuyFee; \r\n\t\tuint256 feeAmount = feeAmountperc.mul(amount).div(feeDenominator); \r\n\t\ttFeeTotal += feeAmount;\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n\t\t}\r\n\t\telse if (receiver == pair) {\r\n\t\tuint256 feeAmountperc = totalsellFee; \r\n\t\tuint256 feeAmount = feeAmountperc.mul(amount).div(feeDenominator);\r\n        tFeeTotal += feeAmount;\t\t\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n\t\t} else {\r\n\t\t//dont take fees on regular (wallet to wallet) token transfers\r\n        return amount;\r\n\t\t}\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold;\r\n    }\r\n\t\r\n\r\n    function swapBack() internal swapping {\r\n\t\t/*\r\n\t\t   *We will split the token balance into three parts for each fee. \r\n\t\t   *and deal with each part individually - it just uses a bit more gas :(\r\n\t\t*/\r\n\t\tuint256 initialTokenBalance = balanceOf(address(this)); //capture initial contract token balance\r\n\t\tuint256 amountToBurn = initialTokenBalance.mul(burnFee).div(feeDenominator);\r\n        uint256 amountToSwapBUSD =initialTokenBalance.mul(rewardsFee).div(feeDenominator);\r\n\t\tuint256 amountToSwapBNB =initialTokenBalance.mul(insuranceFee).div(feeDenominator);\r\n\t\t/*\r\n\t\t   *We will assume that all tokens in contract balance are fees and swap everything.. \r\n\t\t   *anyone that manually sends tokens to contact simply donated more fees to the community :)\r\n\t\t*/\r\n\t\t//lets Burn\r\n\t\t_balances[address(this)] = _balances[address(this)].sub(amountToBurn);\r\n\t\t_balances[DEAD] = _balances[DEAD].add(amountToBurn);\r\n        emit Transfer(address(this), DEAD, amountToBurn);\r\n\t\t\r\n\t\t//lets GETBNB and send to insurance\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n        uint256 balanceBefore = address(this).balance; //capture initial bnb balance\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwapBNB,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 amountBNB = address(this).balance.sub(balanceBefore); //exact bnb that was added\r\n        payable(insuranceFundReceiver).transfer(amountBNB);\r\n\r\n        //lets GETBUSD with BNB and send to rewards\r\n        uint256 balanceAfterFirstSwap = address(this).balance; //capture again bnb balance\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwapBUSD,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 amountBNBtoBUSD = address(this).balance.sub(balanceAfterFirstSwap); //exact bnb that was added to balance\r\n        \r\n\t\t//lets get BUSD to rewardscontractReceiver\r\n\t\tbuyTokenBusd(amountBNBtoBUSD, rewardscontractReceiver);\r\n      }\r\n\t  \r\n\tfunction shouldUnlock() internal view returns (bool) {\r\n\t\treturn block.timestamp >= unlocktimestamp \r\n\t\t&& idoContract != address(0);\r\n\t}\r\n\t\r\n\tfunction forceUnlock() internal {\r\n\t\t/*\r\n\t\t   *After the IDO is ended, If unlock time is reached, the contract automatically Ejects the IDO contract to unlock IDO tokens\r\n\t\t*/\r\n\t\tidoContract = address(0);\r\n\t}\r\n\t\r\n\tfunction SetIDOContract(address _idoContract) external authorized {\r\n\t\t/*\r\n\t\t   *Once the IDO contract and Future Unlock Time is set by DEV, it cannot be replaced by DEV until unlock time is reached.\r\n\t\t   *Once the future unlock time is set by DEV, it can not be changed until the SET time is elapsed.\r\n\t\t*/\r\n\t\trequire(block.timestamp >= unlocktimestamp, \"cannot SET or Replace IDO contract during a current IDO Sale.\");\r\n\t\tidoContract = _idoContract;\r\n\t}\r\n\t\r\n\tfunction SetUnlockTimestamp(uint256 _timestamp) external authorized {\r\n\t\trequire(block.timestamp >= unlocktimestamp, \"initial SET timestamp must be exceeded before the dev will be able to set a new timestamp\");\r\n\t\tunlocktimestamp = _timestamp;\r\n\t}\r\n\r\n\t\r\n\tfunction buyTokenBusd(uint256 amount, address to) internal swapping { \r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = BUSD;\r\n\r\n        router.swapExactETHForTokens{value: amount}(\r\n            0,\r\n            path,\r\n            to,\r\n            block.timestamp\r\n        );\r\n    }\r\n\t\r\n\tfunction RolloverRewards() external {\r\n\t\tbuyTokenBusd(address(this).balance, rewardscontractReceiver);\r\n\t}\r\n\t\r\n\t\r\n\tfunction withdrawStuckToken(address recipient, address token) external authorized {\r\n        //allows stuck tokens ERC20 to be ejected from this contract.\r\n\t\trequire(token != address(this), \"Cannot Withdraw Own Token\");\r\n        IBEP20(token).transfer(recipient, IBEP20(token).balanceOf(address(this)));\r\n    }\r\n\r\n\r\n    function launched() internal view returns (bool) {\r\n        return launchedAt != 0;\r\n    }\r\n\r\n\r\n    function launch() public authorized {\r\n        require(launchedAt == 0, \"CALLTOCOMBAT WAS LAUNCHED ALREADY\");\r\n        launchedAt = block.number;\r\n        launchedAtTimestamp = block.timestamp;\r\n    }\r\n\r\n\r\n    function ExcludeFees(address holder) external authorized {\r\n        require(!isFeeExempt[holder], \"holder is already excluded from Fees\");\r\n        isFeeExempt[holder] = true;\r\n    }\r\n\r\n\tfunction includeFees(address holder) external authorized {\r\n        require(isFeeExempt[holder], \"holder is not excluded from Fees\");\r\n        isFeeExempt[holder] = false;\r\n    }\r\n\t\r\n\r\n    function setBuyAndSellFees(uint256 _buyFee, uint256 _sellFee) external authorized {\r\n        require(_buyFee <= maxtotalbuyFee && _sellFee <= maxtotalsellFee, \"Sorry Dev, You cant set above Max Fees\");\r\n\t\ttotalbuyFee = _buyFee;\r\n        totalsellFee = _sellFee;\r\n    }\r\n\t\r\n\t\r\n\tfunction setIndividualFeePercentages(uint256 _insuranceFee, uint256 _burnFee, uint256 _rewardsFee) external authorized {\r\n        require(_insuranceFee + _burnFee + _rewardsFee == feeDenominator, \"please Re-Arragne inividual Fees\");\r\n\t\tinsuranceFee = _insuranceFee;\r\n        burnFee = _burnFee;\r\n\t\trewardsFee = _rewardsFee;\r\n    }\r\n\r\n    function setFeeReceivers(address _rewardscontractReceiver, address _insuranceFundReceiver) external authorized {\r\n        rewardscontractReceiver = _rewardscontractReceiver;\r\n        insuranceFundReceiver = _insuranceFundReceiver;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external authorized {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _amount;\r\n    }\r\n\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\t\r\n\tfunction totalFees() public view returns (uint256) {\r\n        return tFeeTotal;\r\n    }\r\n\r\n    function getLiquidityBacking(uint256 accuracy) public view returns (uint256) {\r\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"ExcludeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RolloverRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_idoContract\",\"type\":\"address\"}],\"name\":\"SetIDOContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"SetUnlockTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"includeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceFundReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAtTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardscontractReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setBuyAndSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardscontractReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_insuranceFundReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_insuranceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsFee\",\"type\":\"uint256\"}],\"name\":\"setIndividualFeePercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalbuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalsellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlocktimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CALLTOCOMBAT", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d12f3c01434ee5c91fa3151161554df42b6373725b6040f2a158a13e03f763d5"}