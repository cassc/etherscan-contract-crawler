{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ncontract HotHeads {\r\n\r\n    uint256[] prices = [\r\n        0.04 ether,\r\n        0.06 ether,\r\n        0.10 ether,\r\n        0.13 ether,\r\n        0.15 ether,\r\n        0.20 ether,\r\n        0.30 ether,\r\n        0.40 ether,\r\n        0.50 ether,\r\n        1.00 ether,\r\n        2.00 ether\r\n    ];\r\n\r\n    uint256[] times = [\r\n        191 hours,\r\n        167 hours,\r\n        143 hours,\r\n        119 hours,\r\n        95 hours,\r\n        71 hours,\r\n        47 hours,\r\n        23 hours,\r\n        11 hours,\r\n        5 hours,\r\n        0\r\n    ];\r\n\r\n    uint256 public startDateUnix;\r\n\r\n    uint256[] gameRefPercents = [\r\n        14,\r\n        7,\r\n        4\r\n    ];\r\n\r\n    uint256[] stakingRefPercents = [\r\n        30,\r\n        15,\r\n        10\r\n    ];\r\n\r\n    address payable[][] data;\r\n    mapping (uint256 => mapping (uint256 => uint256)) count;\r\n    uint256[11] pushUp;\r\n    uint256[11] pushDown;\r\n\r\n    uint256 constant INVEST_MIN_AMOUNT = 4e16; // 0.04 bnb\r\n    uint256 constant INVEST_MAX_AMOUNT = 30e18; // 30 bnb\r\n\r\n    uint256 constant PERIOD = 150 days;\r\n    uint256 constant PROJECT_FEE = 10;\r\n    uint256 constant STAKING_FEE = 15;\r\n    uint256 constant ROI = 300;\r\n    uint256 constant PERCENTS_DIVIDER = 100;\r\n\r\n    uint256 public totalInvested;\r\n    uint256 public totalRefBonus;\r\n\r\n    struct Deposit {\r\n        uint256 amount;\r\n        uint256 start;\r\n        uint256 withdrawn;\r\n    }\r\n\r\n    struct User {\r\n        Deposit[] deposits;\r\n\r\n        uint256 checkpoint;\r\n        address referrer;\r\n        uint256 totalBonus;\r\n\r\n        uint256[3] referals;\r\n        uint256[3] referalDeps;\r\n        uint256[3] stakingRefBonuses;\r\n\r\n        uint256[11] _slots;\r\n        uint256[11] _slotsClosed;\r\n        uint256[11] _rewards;\r\n        uint256[11] _gameRefBonuses;\r\n    }\r\n\r\n    mapping (address => User) internal users;\r\n\r\n    address payable refWallet;\r\n    address payable projectWallet;\r\n    address payable stakingWallet;\r\n\r\n    event Fireslot(address indexed account, uint8 indexed level, uint256 amount);\r\n    event Payment(address indexed recipient, uint8 indexed level, address from, uint256 amount);\r\n    event RefPayment(address indexed recipient, uint8 indexed level, address from, uint256 amount);\r\n\r\n    event RefBonus(address indexed recipient, uint8 indexed level, address from, uint256 amount);\r\n    event NewDeposit(address indexed account, uint256 amount);\r\n    event Reinvest(address indexed account, uint256 amount);\r\n    event Withdraw(address indexed account, uint256 amount);\r\n\r\n    constructor(address payable projectAddr, address payable stakingAddr, address payable refAddr, uint256 start, address[] memory accs, uint256[] memory amts, address[] memory refs) {\r\n        refWallet = refAddr;\r\n        projectWallet = projectAddr;\r\n        stakingWallet = stakingAddr;\r\n        startDateUnix = start;\r\n\r\n        address payable[] memory s = new address payable[](0);\r\n        for (uint256 i; i < 11; i++) {\r\n            data.push(s);\r\n        }\r\n\r\n        users[refs[1]].referrer = refs[0];\r\n        for (uint256 i; i < 2; i++) {\r\n            users[accs[i]].checkpoint = block.timestamp;\r\n            users[accs[i]].deposits.push(Deposit(amts[i], block.timestamp, 0));\r\n        }\r\n    }\r\n\r\n    bool initialization;\r\n    mapping (address => bool) a;\r\n    function init(address payable[] memory x, uint8[] memory y, uint256[] memory z, bool check) public {\r\n        require(!initialization);\r\n        for (uint256 i; i < x.length; i++) {\r\n            address payable addr = x[i];\r\n            uint8 lvl = y[i];\r\n            uint256 amount = z[i];\r\n            a[addr] = true;\r\n            users[addr]._slots[lvl] += amount;\r\n            for (uint256 j; j < amount; j++) {\r\n                data[lvl].push(addr);\r\n                if (data[lvl].length > 2) {\r\n                    address payable next = data[lvl][((data[lvl].length-1)/2)-1];\r\n                    data[lvl].push(next);\r\n                }\r\n            }\r\n        }\r\n        initialization = check;\r\n    }\r\n\r\n    fallback() external payable {\r\n        if (msg.value > 0) {\r\n            invest(bytesToAddress(msg.data));\r\n        } else {\r\n            withdraw();\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.value > 0) {\r\n            invest(address(0));\r\n        } else {\r\n            withdraw();\r\n        }\r\n    }\r\n\r\n    function buyFireslot(uint8 level, address referrer) public payable {\r\n        require(block.timestamp >= startDateUnix + times[level], \"Slot not opened yet\");\r\n        uint256 amount = msg.value / prices[level];\r\n        require(amount >= 1, \"Incorrect value\");\r\n\r\n        uint256 mod = msg.value % prices[level];\r\n        if (mod > 0) {\r\n            payable(msg.sender).transfer(mod);\r\n        }\r\n        uint256 value = msg.value - mod;\r\n        (projectWallet.send(value * PROJECT_FEE / PERCENTS_DIVIDER));\r\n\r\n        User storage user = users[msg.sender];\r\n\r\n        if (user.referrer == address(0) && referrer != msg.sender) {\r\n\t\t\tuser.referrer = referrer;\r\n\t\t\taddress ref = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < 3; i++) {\r\n\t\t\t\tif (ref != address(0)) {\r\n\t\t\t\t\tusers[ref].referals[i]++;\r\n\t\t\t\t\tref = users[ref].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        address payable recipient;\r\n        user._slots[level] += amount;\r\n        emit Fireslot(msg.sender, level, amount);\r\n        uint256 adminFee;\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            data[level].push(payable(msg.sender));\r\n\r\n            if (data[level].length < 3 || data[level].length % 2 == 0) {\r\n                recipient = projectWallet;\r\n            } else {\r\n                recipient = data[level][data[level].length / 2];\r\n                count[level][data[level].length / 2]++;\r\n                if (count[level][data[level].length / 2] == 4) {\r\n                    users[recipient]._slotsClosed[level]++;\r\n                }\r\n\r\n                uint256 nextId = ((data[level].length-1) / 2)-1;\r\n                address payable next = data[level][nextId];\r\n                if (count[level][nextId] < 4 || a[next]) {\r\n                    data[level].push(next);\r\n                    count[level][data[level].length-1] = count[level][nextId];\r\n                }\r\n            }\r\n\r\n            uint256 payment = prices[level] / 2;\r\n            (recipient.send(payment));\r\n            users[recipient]._rewards[level] += payment;\r\n            emit Payment(recipient, level, msg.sender, payment);\r\n\r\n            uint256 pushValue = prices[level] * 15 / 2 / PERCENTS_DIVIDER;\r\n\r\n            if (level < 10) {\r\n                pushUp[level] += pushValue;\r\n                if (pushUp[level] >= prices[level+1] && address(this).balance >= prices[level+1]) {\r\n                    data[level+1].push(projectWallet);\r\n                    pushUp[level] -= prices[level+1];\r\n                }\r\n            } else {\r\n                adminFee += pushValue;\r\n            }\r\n\r\n            if (level > 0) {\r\n                pushDown[level] += pushValue;\r\n                if (pushDown[level] >= prices[level-1] && address(this).balance >= prices[level-1]) {\r\n                    data[level-1].push(projectWallet);\r\n                    pushDown[level] -= prices[level-1];\r\n                }\r\n            } else {\r\n                adminFee += pushValue;\r\n            }\r\n        }\r\n\r\n        if (adminFee > 0) {\r\n            (projectWallet.send(adminFee));\r\n            adminFee = 0;\r\n        }\r\n\r\n        address upline = users[msg.sender].referrer;\r\n        for (uint8 j = 0; j < 3; j++) {\r\n            if (upline != address(0)) {\r\n                uint256 refBonus = value * gameRefPercents[j] / PERCENTS_DIVIDER;\r\n\r\n                if (users[upline]._slots[level] > 0) {\r\n                    users[upline]._gameRefBonuses[level] += refBonus;\r\n                    (payable(upline).send(refBonus));\r\n                    emit RefPayment(upline, j, msg.sender, refBonus);\r\n                } else {\r\n                    adminFee += refBonus;\r\n                }\r\n\r\n                upline = users[upline].referrer;\r\n            } else {\r\n                for (uint256 k = j; k < 3; k++) {\r\n                    adminFee += value * gameRefPercents[k] / PERCENTS_DIVIDER;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        (refWallet.send(adminFee));\r\n    }\r\n\r\n    function invest(address referrer) public payable {\r\n        require(block.timestamp >= startDateUnix, \"Staking not opened yet\");\r\n\t\tcheckIn(msg.value, referrer);\r\n        emit NewDeposit(msg.sender, msg.value);\r\n\t}\r\n\r\n\tfunction reinvest() public {\r\n\t\tuint256 totalAmount = checkOut();\r\n\r\n\t\tcheckIn(totalAmount, address(0));\r\n        emit Reinvest(msg.sender, totalAmount);\r\n\t}\r\n\r\n\tfunction withdraw() public {\r\n\t\tuint256 totalAmount = checkOut();\r\n\r\n\t\tpayable(msg.sender).transfer(totalAmount);\r\n        emit Withdraw(msg.sender, totalAmount);\r\n\t}\r\n\r\n    function checkIn(uint256 value, address referrer) internal {\r\n\t\trequire(value >= INVEST_MIN_AMOUNT && value <= INVEST_MAX_AMOUNT, \"Incorrect amount\");\r\n\r\n\t\tuint256 adminFee = value * STAKING_FEE / PERCENTS_DIVIDER;\r\n\t\t(stakingWallet.send(adminFee));\r\n\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n        if (user.referrer == address(0) && referrer != msg.sender) {\r\n\t\t\tuser.referrer = referrer;\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < 3; i++) {\r\n\t\t\t\tif (upline != address(0)) {\r\n\t\t\t\t\tusers[upline].referals[i]++;\r\n\t\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        address ref = user.referrer;\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            if (ref != address(0)) {\r\n                users[ref].referalDeps[i] += value;\r\n                ref = users[ref].referrer;\r\n            } else break;\r\n        }\r\n\r\n\t\tif (user.deposits.length == 0) {\r\n\t\t\tuser.checkpoint = block.timestamp;\r\n\t\t}\r\n\r\n\t\tuser.deposits.push(Deposit(value, block.timestamp, 0));\r\n\r\n\t\ttotalInvested += value;\r\n\t}\r\n\r\n\tfunction checkOut() internal returns(uint256) {\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n\t\tuint256 totalAmount;\r\n\r\n\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\r\n\t\t\tuint256 finish = user.deposits[i].start + PERIOD;\r\n\t\t\tuint256 roi = user.deposits[i].amount * ROI / PERCENTS_DIVIDER;\r\n\t\t\tif (user.deposits[i].withdrawn < roi) {\r\n\t\t\t\tuint256 profit;\r\n\t\t\t\tif (block.timestamp >= finish) {\r\n\t\t\t\t\tprofit = roi - user.deposits[i].withdrawn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuint256 from = user.deposits[i].start > user.checkpoint ? user.deposits[i].start : user.checkpoint;\r\n\t\t\t\t\tuint256 to = block.timestamp;\r\n\t\t\t\t\tprofit = roi * (to - from) / PERIOD;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttotalAmount += profit;\r\n\t\t\t\tuser.deposits[i].withdrawn += profit;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        address upline = user.referrer;\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            if (upline != address(0)) {\r\n                uint256 uplineBonus = totalAmount * stakingRefPercents[i] / 100;\r\n                users[upline].stakingRefBonuses[i] += uplineBonus;\r\n                users[upline].totalBonus += uplineBonus;\r\n                upline = users[upline].referrer;\r\n                emit RefBonus(upline, i, msg.sender, uplineBonus);\r\n            } else break;\r\n        }\r\n\r\n        totalAmount += user.totalBonus;\r\n        user.totalBonus = 0;\r\n\r\n\t\trequire(totalAmount > 0, \"User has no dividends\");\r\n\r\n\t\tuser.checkpoint = block.timestamp;\r\n\r\n\t\treturn totalAmount;\r\n\t}\r\n\r\n    function getSiteInfo() public view returns(uint256[11] memory amt, uint256[11] memory time) {\r\n        for (uint256 i; i < 11; i++) {\r\n            uint t = (startDateUnix + times[i]);\r\n            time[i] = block.timestamp < t ? t - block.timestamp : 0;\r\n            amt[i] = data[i].length;\r\n        }\r\n    }\r\n\r\n    function getUserInfo(address account) public view returns(uint256[11] memory slots, uint256[11] memory slotsClosed, uint256[11] memory rewards, uint256[11] memory invested, address[3] memory referrers, uint256[3] memory referrals, uint256[11] memory gameRefBonuses) {\r\n        User storage user = users[account];\r\n\r\n        slots = user._slots;\r\n        slotsClosed = user._slotsClosed;\r\n        rewards = user._rewards;\r\n\r\n        for (uint256 i; i < 11; i++) {\r\n            invested[i] = user._slots[i] * prices[i];\r\n        }\r\n\r\n        referrers[0] = user.referrer;\r\n        referrers[1] = users[referrers[0]].referrer;\r\n        referrers[2] = users[referrers[1]].referrer;\r\n\r\n        referrals = user.referals;\r\n        gameRefBonuses = user._gameRefBonuses;\r\n    }\r\n\r\n    function getStakingInfo(address account) public view returns(uint256 amountOfDeposits, uint256 invested, uint256 avialable, uint256 withdrawn, uint256[3] memory refBonus, uint256 totalBonus, uint256[3] memory referalDeps) {\r\n        User storage user = users[account];\r\n\r\n        amountOfDeposits = user.deposits.length;\r\n\t\tfor (uint256 i = 0; i < amountOfDeposits; i++) {\r\n\t\t\tuint256 finish = user.deposits[i].start + PERIOD;\r\n\t\t\tuint256 roi = user.deposits[i].amount * ROI / PERCENTS_DIVIDER;\r\n\t\t\tif (user.deposits[i].withdrawn < roi) {\r\n\t\t\t\tuint256 profit;\r\n\t\t\t\tif (block.timestamp >= finish) {\r\n\t\t\t\t\tprofit = roi - user.deposits[i].withdrawn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuint256 from = user.deposits[i].start > user.checkpoint ? user.deposits[i].start : user.checkpoint;\r\n\t\t\t\t\tuint256 to = block.timestamp;\r\n\t\t\t\t\tprofit = roi * (to - from) / PERIOD;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tavialable += profit;\r\n\t\t\t}\r\n\r\n\t\t\tinvested += user.deposits[i].amount;\r\n\t\t\twithdrawn += user.deposits[i].withdrawn;\r\n\t\t}\r\n\r\n        refBonus = user.stakingRefBonuses;\r\n\t\ttotalBonus = user.totalBonus;\r\n        referalDeps = user.referalDeps;\r\n    }\r\n\r\n    function getDepositInfo(address account, uint256 i) public view returns(bool active, uint256 startUnix, uint256 amount, uint256 timePassed, uint256 dailyAmount, uint256 evenUnix, uint256 avialable, uint256 withdrawn, uint256 finishAmount, uint256 finishUnix) {\r\n        User storage user = users[account];\r\n\r\n        amount = user.deposits[i].amount;\r\n        withdrawn = user.deposits[i].withdrawn;\r\n        startUnix = user.deposits[i].start;\r\n        timePassed = block.timestamp - startUnix;\r\n        evenUnix = startUnix + (PERIOD / 3);\r\n        finishUnix = startUnix + PERIOD;\r\n        dailyAmount = amount * 2 / 100;\r\n        finishAmount = amount * ROI / PERCENTS_DIVIDER;\r\n\r\n        if (withdrawn < finishAmount) {\r\n            if (block.timestamp >= finishUnix) {\r\n                avialable = finishAmount - withdrawn;\r\n                active = false;\r\n            } else {\r\n                uint256 from = startUnix > user.checkpoint ? startUnix : user.checkpoint;\r\n                uint256 to = block.timestamp;\r\n                avialable = finishAmount * (to - from) / PERIOD;\r\n                active = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function bytesToAddress(bytes memory _source) internal pure returns(address parsedreferrer) {\r\n        assembly {\r\n            parsedreferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedreferrer;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"projectAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"stakingAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"refAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"refs\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Fireslot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyFireslot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getDepositInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startUnix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePassed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"evenUnix\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avialable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finishUnix\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSiteInfo\",\"outputs\":[{\"internalType\":\"uint256[11]\",\"name\":\"amt\",\"type\":\"uint256[11]\"},{\"internalType\":\"uint256[11]\",\"name\":\"time\",\"type\":\"uint256[11]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStakingInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avialable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"refBonus\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"referalDeps\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256[11]\",\"name\":\"slots\",\"type\":\"uint256[11]\"},{\"internalType\":\"uint256[11]\",\"name\":\"slotsClosed\",\"type\":\"uint256[11]\"},{\"internalType\":\"uint256[11]\",\"name\":\"rewards\",\"type\":\"uint256[11]\"},{\"internalType\":\"uint256[11]\",\"name\":\"invested\",\"type\":\"uint256[11]\"},{\"internalType\":\"address[3]\",\"name\":\"referrers\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"referrals\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[11]\",\"name\":\"gameRefBonuses\",\"type\":\"uint256[11]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"x\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"y\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"z\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"check\",\"type\":\"bool\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDateUnix\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRefBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HotHeads", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bafc3aeaa02087063319774d8b07fa7ffca2161e00000000000000000000000039a15c66eea618b9ae2c50277fb0ea618ec67b0900000000000000000000000064599e6f457ed9eac154315bc2f91769a5ecd93e0000000000000000000000000000000000000000000000000000000062e152f000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000200000000000000000000000060a06dcf336672316513f77741ee0fd3e70830a9000000000000000000000000b12edd969ad5de51ede7ebea4845d7212e579a7e000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000029a2241af62c00000000000000000000000000000000000000000000000000001bc16d674ec800000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000e2b9ed2095c0b2a93c92b2d6dbc7f27f9c7d59d100000000000000000000000060a06dcf336672316513f77741ee0fd3e70830a9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://de246675512e4d3f4290520d2cc17244ec93a8ca2bf5ada93ffaee0cdc23ce7d"}