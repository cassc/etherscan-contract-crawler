{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BetGame.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.19;\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ncontract BetGame {\\r\\n  // Variable declaration\\r\\n  address public betHub;\\r\\n  IERC20 public usdtToken;\\r\\n  bool public optionAWon;\\r\\n  uint256 public totalBetOnOptionA;\\r\\n  uint256 public totalBetOnOptionB;\\r\\n  uint256 public gameStartTime;\\r\\n  bool public isWinnerDetermined;\\r\\n  uint256 public betsOnA;\\r\\n  uint256 public betsOnB;\\r\\n  bool public optionABlocked;\\r\\n  bool public optionBBlocked;\\r\\n  uint256 public threshold;\\r\\n  uint256 public ownerFee;\\r\\n\\r\\n  struct Bet {\\r\\n    uint256 amount;\\r\\n    bool isOptionA;\\r\\n  }\\r\\n\\r\\n  mapping(address => Bet[]) public bets;\\r\\n  mapping(address => bool) public hasWithdrawn;\\r\\n\\r\\n  constructor(address _betHub, address _usdtToken, uint256 _threshold, uint256 _fee) {\\r\\n    betHub = _betHub;\\r\\n    usdtToken = IERC20(_usdtToken);\\r\\n    gameStartTime = block.timestamp; // Set the start time when the contract is deployed\\r\\n    threshold = _threshold;\\r\\n    ownerFee = _fee;\\r\\n  }\\r\\n\\r\\n  function placeBet(uint256 amount, bool isOptionA) public {\\r\\n    require(!isWinnerDetermined, \\\"Betting is closed\\\");\\r\\n    require(amount >= 500000000000000000, \\\"Minimum bet is 0.5 USDT\\\"); // Adjusted for 18 decimals\\r\\n    require(isOptionA ? !optionABlocked : !optionBBlocked, \\\"This betting option is currently blocked\\\");\\r\\n    // Calculate the fee and the bet amount\\r\\n    uint256 fee = amount * ownerFee / 100; //  fee\\r\\n    uint256 betAmount = amount - fee; //  bet amount\\r\\n\\r\\n    // Transfer the fee to BetHub contract\\r\\n    require(usdtToken.transferFrom(msg.sender, betHub, fee), \\\"Fee transfer failed\\\");\\r\\n\\r\\n    // Transfer the bet amount to this contract\\r\\n    require(usdtToken.transferFrom(msg.sender, address(this), betAmount), \\\"Bet transfer failed\\\");\\r\\n\\r\\n    bets[msg.sender].push(Bet({ amount: betAmount, isOptionA: isOptionA }));\\r\\n    // Update total bets for each option with the 90% bet amount only\\r\\n    if (isOptionA) {\\r\\n      betsOnA += 1;\\r\\n      totalBetOnOptionA += betAmount;\\r\\n    } else {\\r\\n      betsOnB += 1;\\r\\n      totalBetOnOptionB += betAmount;\\r\\n    }\\r\\n    // After the bet is placed, check if either option needs to be blocked or unblocked\\r\\n    checkAndToggleOptionBlocking();\\r\\n  }\\r\\n\\r\\n  function checkAndToggleOptionBlocking() internal {\\r\\n    uint256 totalBets = totalBetOnOptionA + totalBetOnOptionB;\\r\\n\\r\\n    // Calculate the maximum allowed difference based on the percentage threshold\\r\\n    uint256 maxDifference = (totalBets * threshold) / 100;\\r\\n\\r\\n    uint256 difference;\\r\\n    if (totalBetOnOptionA > totalBetOnOptionB) {\\r\\n      difference = totalBetOnOptionA - totalBetOnOptionB;\\r\\n    } else {\\r\\n      difference = totalBetOnOptionB - totalBetOnOptionA;\\r\\n    }\\r\\n\\r\\n    if (difference > maxDifference) {\\r\\n      // If the difference is greater than the threshold, block the option with the higher total\\r\\n      optionABlocked = totalBetOnOptionA > totalBetOnOptionB;\\r\\n      optionBBlocked = totalBetOnOptionB > totalBetOnOptionA;\\r\\n    } else {\\r\\n      // If the difference is within the threshold, ensure both options are unblocked\\r\\n      optionABlocked = false;\\r\\n      optionBBlocked = false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Function for winners to withdraw winnings\\r\\n  function withdrawWinnings() public {\\r\\n    require(isWinnerDetermined, \\\"Game not ended\\\");\\r\\n    require(!hasWithdrawn[msg.sender], \\\"Winnings already withdrawn\\\");\\r\\n\\r\\n    bool userWon = false;\\r\\n    uint256 totalWinningAmount = 0;\\r\\n    for (uint i = 0; i < bets[msg.sender].length; i++) {\\r\\n      if (bets[msg.sender][i].isOptionA == optionAWon) {\\r\\n        userWon = true;\\r\\n        uint256 winnerBet = bets[msg.sender][i].amount;\\r\\n\\r\\n        // Calculate the winner's share for each bet from the losing pot\\r\\n        uint256 winnerShareFromLosingPot = calculateIndividualBetWinnings(winnerBet, bets[msg.sender][i].isOptionA);\\r\\n\\r\\n        // Add the original bet amount to the winner's earnings\\r\\n        totalWinningAmount += winnerBet + winnerShareFromLosingPot;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    require(userWon, \\\"Not a winner\\\");\\r\\n\\r\\n    usdtToken.transfer(msg.sender, totalWinningAmount);\\r\\n    hasWithdrawn[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  function calculateIndividualBetWinnings(uint256 winnerBet, bool isOptionA) internal view returns (uint256) {\\r\\n    uint256 winnerTotalBet = isOptionA ? totalBetOnOptionA : totalBetOnOptionB;\\r\\n    uint256 loserTotalBet = isOptionA ? totalBetOnOptionB : totalBetOnOptionA;\\r\\n\\r\\n    uint256 winnerShare = (winnerBet * loserTotalBet) / winnerTotalBet;\\r\\n    return winnerShare;\\r\\n  }\\r\\n\\r\\n  function calculateTotalWinnings(address user) external view returns (uint256) {\\r\\n    if (!isWinnerDetermined || hasWithdrawn[user]) return 0;\\r\\n\\r\\n    uint256 totalWinningAmount = 0;\\r\\n    for (uint i = 0; i < bets[user].length; i++) {\\r\\n      if (bets[user][i].isOptionA == optionAWon) {\\r\\n        uint256 winnerBet = bets[user][i].amount;\\r\\n        uint256 winnerShareFromLosingPot = calculateIndividualBetWinnings(winnerBet, bets[user][i].isOptionA);\\r\\n        totalWinningAmount += winnerBet + winnerShareFromLosingPot;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return totalWinningAmount;\\r\\n  }\\r\\n\\r\\n  // Function to check if a user has winnings\\r\\n  function hasWinnings(address user) public view returns (bool) {\\r\\n    if (!isWinnerDetermined || hasWithdrawn[user]) return false;\\r\\n\\r\\n    for (uint i = 0; i < bets[user].length; i++) {\\r\\n      if (bets[user][i].isOptionA == optionAWon) {\\r\\n        return true; // User has at least one winning bet\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return false; // No winning bets found\\r\\n  }\\r\\n\\r\\n  function determineWinner(string memory seed) public {\\r\\n    require(msg.sender == betHub, \\\"Only BetHub can determine the winner\\\");\\r\\n    require(!isWinnerDetermined, \\\"Winner already determined\\\");\\r\\n\\r\\n    bytes32 randomHash = keccak256(abi.encodePacked(seed, block.difficulty, block.timestamp));\\r\\n    optionAWon = uint256(randomHash) % 2 == 0;\\r\\n    isWinnerDetermined = true;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_betHub\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"betHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOptionA\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betsOnA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betsOnB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateTotalWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seed\",\"type\":\"string\"}],\"name\":\"determineWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"hasWinnings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasWithdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWinnerDetermined\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionABlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionAWon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optionBBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOptionA\",\"type\":\"bool\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBetOnOptionA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBetOnOptionB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BetGame", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000004ff9dc1768c4c8ecf865f4372cbae2b8eef14b1d00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000005", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}