{"SourceCode": "{\"CalcUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary CalcUtils {\\n    function calcAmount(uint256 amount, uint256 rate) internal pure returns (uint256 tokenA) {\\n        return (amount * rate) / 1e21;\\n    }\\n\\n    function calcRate(uint256 tokenAValue, uint256 tokenBValue) internal pure returns (uint256 rate) {\\n        return (tokenAValue * 1e21) / tokenBValue;\\n    }\\n}\\n\"},\"DealProviderState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title DealProviderState contract\\n/// @notice Contains storage variables, structures\\ncontract DealProviderState {\\n    mapping(uint256 =\\u003e uint256) public poolIdToAmount;\\n}\\n\"},\"DelayVaultProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./DelayVaultState.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @title DelayVaultProvider\\n * @dev Smart contract for locking ERC20 tokens with a delay and pairing with NFTs.\\n */\\ncontract DelayVaultProvider is DelayVaultState {\\n    /**\\n     * @dev Constructor to initialize the DelayVaultProvider contract.\\n     * @param _token Address of the ERC-20 token used within the DelayVault system.\\n     * @param _migrator Address of the migrator contract handling user migrations between DelayVaults.\\n     * @param _providersData Provider-specific data for different tier levels.\\n     */\\n    constructor(address _token, IMigrator _migrator, ProviderData[] memory _providersData) {\\n        require(address(_token) != address(0x0), \\\"invalid address for token\\\");\\n        require(address(_migrator) != address(0x0), \\\"invalid address for migrator\\\");\\n        require(_providersData.length \\u003c= 255, \\\"too many providers\\\");\\n        name = \\\"DelayVaultProvider\\\";\\n        token = _token;\\n        migrator = _migrator;\\n        lockDealNFT = _migrator.lockDealNFT();\\n        _finalize(_providersData);\\n    }\\n\\n    /**\\n     * @dev Registers a new pool for the DelayVaultProvider.\\n     * @param poolId Identifier for the DelayVaultProvider NFT pool.\\n     * @param params Array of parameters including the amount of tokens stored in the pool.\\n     */\\n    function registerPool(\\n        uint256 poolId,\\n        uint256[] calldata params\\n    ) external override firewallProtected onlyProvider validProviderId(poolId) {\\n        require(params.length == currentParamsTargetLength(), \\\"invalid params length\\\");\\n        _registerPool(poolId, params);\\n    }\\n\\n    /**\\n     * @dev Internal function to register a new pool.\\n     * @param poolId Identifier for the DelayVaultProvider NFT pool.\\n     * @param params Array of parameters including the amount of tokens stored in the pool.\\n     */\\n    function _registerPool(uint256 poolId, uint256[] calldata params) internal firewallProtectedSig(0xdf3aac25) {\\n        uint256 amount = params[0];\\n        address owner = lockDealNFT.ownerOf(poolId);\\n        _addHoldersSum(owner, amount, owner == msg.sender || msg.sender == address(migrator));\\n        poolIdToAmount[poolId] = amount;\\n    }\\n\\n    /**\\n     * @dev Retrieves parameters associated with a DelayVaultProvider pool.\\n     * @param poolId Pool identifier.\\n     * @return params Array of parameters. The first element is the amount.\\n     */\\n    function getParams(uint256 poolId) external view override returns (uint256[] memory params) {\\n        params = new uint256[](1);\\n        params[0] = poolIdToAmount[poolId];\\n    }\\n\\n    /**\\n     * @dev Retrieves the withdrawable amount for a specified pool.\\n     * @param poolId Pool identifier.\\n     * @return withdrawalAmount The withdrawal amount.\\n     */\\n    function getWithdrawableAmount(uint256 poolId) external view override returns (uint256 withdrawalAmount) {\\n        withdrawalAmount = poolIdToAmount[poolId];\\n    }\\n\\n    /**\\n     * @dev Allows a user to upgrade their account type, subject to certain conditions.\\n     * @param newType The new account type.\\n     */\\n    function upgradeType(uint8 newType) external firewallProtected {\\n        uint8 oldType = userToType[msg.sender];\\n        uint256 amount = getTotalAmount(msg.sender);\\n        require(amount \\u003e 0, \\\"amount must be bigger than 0\\\");\\n        require(newType \\u003e oldType, \\\"new type must be bigger than the old one\\\");\\n        require(newType \\u003c typesCount, \\\"new type must be smaller than the types count\\\");\\n        userToType[msg.sender] = newType;\\n    }\\n\\n    /**\\n     * @dev Creates a new delay vault, transferring tokens and minting a new NFT.\\n     * @param owner Owner of the new vault.\\n     * @param params Array with one parameter. params[0] - the amount of tokens stored in the pool.\\n     * @return poolId The created pool ID.\\n     */\\n    function createNewDelayVault(address owner, uint256[] calldata params) external firewallProtected returns (uint256 poolId) {\\n        require(params.length == currentParamsTargetLength(), \\\"invalid params length\\\");\\n        uint256 amount = params[0];\\n        IERC20(token).transferFrom(msg.sender, address(lockDealNFT), amount);\\n        poolId = lockDealNFT.mintAndTransfer(owner, token, amount, this);\\n        _registerPool(poolId, params);\\n    }\\n\\n    /**\\n     * @dev Creates a new delay vault with a cryptographic signature.\\n     * @param owner Owner of the new vault.\\n     * @param params Array with one parameter. params[0] - the amount of tokens stored in the pool\\n     * @param signature Cryptographic signature.\\n     * @return poolId The created pool ID.\\n     */\\n    function createNewDelayVaultWithSignature(\\n        address owner,\\n        uint256[] calldata params,\\n        bytes calldata signature\\n    ) external firewallProtected returns (uint256 poolId) {\\n        require(params.length == currentParamsTargetLength(), \\\"invalid params length\\\");\\n        poolId = lockDealNFT.safeMintAndTransfer(owner, token, msg.sender, params[0], this, signature);\\n        _registerPool(poolId, params);\\n    }\\n}\\n\"},\"DelayVaultState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./DealProviderState.sol\\\";\\nimport \\\"./CalcUtils.sol\\\";\\nimport \\\"./LastPoolOwnerState.sol\\\";\\nimport \\\"./HoldersSum.sol\\\";\\n\\n/**\\n * @title DelayVaultState\\n * @dev Abstract contract containing common state and functions for DelayVaultProvider.\\n */\\nabstract contract DelayVaultState is DealProviderState, LastPoolOwnerState, HoldersSum {\\n    using CalcUtils for uint256;\\n\\n    /**\\n     * @dev Executes before a transfer, updating state based on the transfer details.\\n     * @param from Sender address.\\n     * @param to Receiver address.\\n     * @param poolId Pool identifier.\\n     */\\n    function beforeTransfer(address from, address to, uint256 poolId) external override firewallProtected onlyNFT {\\n        if (to == address(lockDealNFT))\\n            // this means it will be withdraw or split\\n            lastPoolOwner[poolId] = from; //this is the only way to know the owner of the pool\\n        else if (from != address(0) \\u0026\\u0026 !lockDealNFT.approvedContracts(from)) {\\n            _handleTransfer(from, to, poolId);\\n        }\\n        // Back-end can effortlessly extract address details from the default transfer event.\\n    }\\n\\n    /**\\n     * @dev Internal function to handle transfers and update state.\\n     * @param from Sender address.\\n     * @param to Receiver address.\\n     * @param poolId Pool identifier.\\n     * @return amount The transferred amount.\\n     */\\n    function _handleTransfer(address from, address to, uint256 poolId)\\n        internal\\n        firewallProtectedSig(0x87ac3d6b)\\n        returns (uint256 amount)\\n    {\\n        amount = poolIdToAmount[poolId];\\n        _subHoldersSum(from, amount);\\n        _addHoldersSum(to, amount, false);\\n    }\\n\\n    /**\\n     * @dev Retrieves parameters for withdrawing a specified amount from a pool.\\n     * @param amount Amount to be withdrawn.\\n     * @param theType The account type.\\n     * @return params Array of withdrawal parameters.\\n     */\\n    function getWithdrawPoolParams(uint256 amount, uint8 theType) public view returns (uint256[] memory params) {\\n        uint256[] memory settings = typeToProviderData[theType].params;\\n        params = _getWithdrawPoolParams(amount, settings);\\n    }\\n\\n    /**\\n     * @dev Internal function to retrieve withdrawal parameters.\\n     * @param amount Amount to be withdrawn.\\n     * @param settings Provider settings for withdrawal.\\n     * @return params Array of withdrawal parameters.\\n     */\\n    function _getWithdrawPoolParams(\\n        uint256 amount,\\n        uint256[] memory settings\\n    ) internal view returns (uint256[] memory params) {\\n        uint256 length = settings.length + 1;\\n        params = new uint256[](length);\\n        params[0] = amount;\\n        for (uint256 i = 0; i \\u003c settings.length; i++) {\\n            params[i + 1] = block.timestamp + settings[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev Function to be called to handle the withdrawal of assets from a DelayVaultProvider pool.\\n     * @param tokenId Identifier of the NFT representing ownership of the pool.\\n     * @return withdrawnAmount The amount of assets withdrawn.\\n     * @return isFinal A boolean indicating whether the withdrawal is final.\\n     */\\n    function withdraw(uint256 tokenId) external override firewallProtected onlyNFT returns (uint256 withdrawnAmount, bool isFinal) {\\n        address owner = lastPoolOwner[tokenId];\\n        uint8 theType = userToType[owner];\\n        uint256 amount = poolIdToAmount[tokenId];\\n        _createLockNFT(owner, amount, theType, tokenId);\\n        isFinal = true;\\n        withdrawnAmount = poolIdToAmount[tokenId] = 0;\\n        _subHoldersSum(owner, amount);\\n        _resetTypeIfEmpty(owner);\\n        // After the withdrawal, the default LockDealNFT `TokenWithdrawn` event will be triggered.\\n    }\\n\\n    /**\\n     * @dev Internal function to create a new LockNFT and associated pool.\\n     * @param owner Owner of the new pool.\\n     * @param amount Amount of tokens in the pool.\\n     * @param theType Account type of the owner.\\n     * @param tokenId Identifier for the new pool.\\n     */\\n    function _createLockNFT(address owner, uint256 amount, uint8 theType, uint tokenId)\\n        internal\\n        firewallProtectedSig(0x41d49551)\\n    {\\n        ProviderData memory providerData = typeToProviderData[theType];\\n        uint256 newPoolId = lockDealNFT.mintForProvider(owner, providerData.provider);\\n        lockDealNFT.cloneVaultId(newPoolId, tokenId);\\n        uint256[] memory params = getWithdrawPoolParams(amount, theType);\\n        providerData.provider.registerPool(newPoolId, params);\\n    }\\n\\n    /**\\n     * @dev Splits a pool, transferring a specified ratio to a new pool.\\n     * @param oldPoolId Identifier for the existing pool.\\n     * @param newPoolId Identifier for the new pool.\\n     * @param ratio Ratio of the amount to be transferred to the new pool.\\n     */\\n    function split(uint256 oldPoolId, uint256 newPoolId, uint256 ratio) external override firewallProtected onlyNFT {\\n        address oldOwner = lastPoolOwner[oldPoolId];\\n        address newOwner = lockDealNFT.ownerOf(newPoolId);\\n        uint256 amount = poolIdToAmount[oldPoolId].calcAmount(ratio);\\n        poolIdToAmount[oldPoolId] -= amount;\\n        poolIdToAmount[newPoolId] = amount;\\n        if (newOwner != oldOwner) {\\n            _handleTransfer(oldOwner, newOwner, newPoolId);\\n        }\\n        // After the split, the default LockDealNFT `PoolSplit` event will be triggered.\\n    }\\n\\n    /**\\n     * @dev Resets the account type if the user\\u0027s total amount becomes zero.\\n     * @param user User address.\\n     */\\n    function _resetTypeIfEmpty(address user) internal firewallProtectedSig(0x646db9f5) {\\n        if (getTotalAmount(user) == 0) {\\n            userToType[user] = 0; //reset the type\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves provider data for a specific account type.\\n     * @param theType Account type.\\n     * @return providerData Provider data for the specified account type.\\n     */\\n    function getTypeToProviderData(uint8 theType) public view virtual returns (ProviderData memory providerData) {\\n        providerData = typeToProviderData[theType];\\n    }\\n\\n    /**\\n     * @dev Checks if the contract supports the specified interface.\\n     * @param interfaceId Interface identifier.\\n     * @return true if the contract supports the interface, false otherwise.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IDelayVaultProvider).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"},\"ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) \\u0026\\u0026\\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) \\u0026\\u0026 supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they\\u0027re supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they\\u0027re supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i \\u003c interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i \\u003c interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success \\u0026\\u0026 returnSize \\u003e= 0x20 \\u0026\\u0026 returnValue \\u003e 0;\\n    }\\n}\\n\"},\"FirewallConsumer.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2023\\npragma solidity 0.8.19;\\n\\nimport \\\"./FirewallConsumerBase.sol\\\";\\n\\n/**\\n * @title Firewall Consumer\\n * @author David Benchimol @ Ironblocks \\n * @dev This contract is a parent contract that can be used to add firewall protection to any contract.\\n *\\n * The contract must initializes with the firewall contract disabled, and the deployer\\n * as the firewall admin.\\n *\\n */\\ncontract FirewallConsumer is FirewallConsumerBase(address(0), msg.sender) {\\n}\\n\"},\"FirewallConsumerBase.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2023\\npragma solidity 0.8.19;\\n\\nimport \\\"./IFirewall.sol\\\";\\nimport \\\"./IFirewallConsumer.sol\\\";\\n\\n/**\\n * @title Firewall Consumer Base Contract\\n * @author David Benchimol @ Ironblocks \\n * @dev This contract is a parent contract that can be used to add firewall protection to any contract.\\n *\\n * The contract must define a firewall contract which will manage the policies that are applied to the contract.\\n * It also must define a firewall admin which will be able to add and remove policies.\\n *\\n */\\ncontract FirewallConsumerBase is IFirewallConsumer {\\n\\n    address private firewall;\\n    address public firewallAdmin;\\n\\n    /**\\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall, applying each of\\n     * the subscribed policies.\\n     */\\n    modifier firewallProtected() {\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint value;\\n        // We do this because msg.value can only be accessed in payable functions.\\n        assembly {\\n            value := callvalue()\\n        }\\n        IFirewall(firewall).preExecution(msg.sender, msg.data, value);\\n        _; \\n        IFirewall(firewall).postExecution(msg.sender, msg.data, value);\\n    }\\n\\n    /**\\n     * @dev modifier that will run the preExecution and postExecution hooks of the firewall, applying each of\\n     * the subscribed policies. Allows passing custom data to the firewall, not necessarily msg.data.\\n     * Useful for checking internal function calls\\n     */\\n    modifier firewallProtectedCustom(bytes memory data) {\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint value;\\n        // We do this because msg.value can only be accessed in payable functions.\\n        assembly {\\n            value := callvalue()\\n        }\\n        IFirewall(firewall).preExecution(msg.sender, data, value);\\n        _; \\n        IFirewall(firewall).postExecution(msg.sender, data, value);\\n    }\\n\\n    /**\\n     * @dev identical to the rest of the modifiers in terms of logic, but makes it more\\n     * aesthetic when all you want to pass are signatures/unique identifiers.\\n     */\\n    modifier firewallProtectedSig(bytes4 selector) {\\n        if (firewall == address(0)) {\\n            _;\\n            return;\\n        }\\n        uint value;\\n        // We do this because msg.value can only be accessed in payable functions.\\n        assembly {\\n            value := callvalue()\\n        }\\n        IFirewall(firewall).preExecution(msg.sender, abi.encodePacked(selector), value);\\n        _; \\n        IFirewall(firewall).postExecution(msg.sender, abi.encodePacked(selector), value);\\n    }\\n\\n    /**\\n     * @dev modifier similar to onlyOwner, but for the firewall admin.\\n     */\\n    modifier onlyFirewallAdmin() {\\n        require(msg.sender == firewallAdmin, \\\"FirewallConsumer: not firewall admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes a contract protected by a firewall, with a firewall address and a firewall admin.\\n     */\\n    constructor(\\n        address _firewall,\\n        address _firewallAdmin\\n    ) {\\n        firewall = _firewall;\\n        firewallAdmin = _firewallAdmin;\\n    }\\n\\n    /**\\n     * @dev Admin only function allowing the consumers admin to remove a policy from the consumers subscribed policies.\\n     */\\n    function setFirewall(address _firewall) external onlyFirewallAdmin {\\n        firewall = _firewall;\\n    }\\n\\n    /**\\n     * @dev Admin only function allowing the consumers admin to remove a policy from the consumers subscribed policies.\\n     */\\n    function setFirewallAdmin(address _firewallAdmin) external onlyFirewallAdmin {\\n        require(_firewallAdmin != address(0), \\\"FirewallConsumer: zero address\\\");\\n        firewallAdmin = _firewallAdmin;\\n    }\\n\\n}\\n\"},\"HoldersSum.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ProviderModifiers.sol\\\";\\nimport \\\"./IDelayVaultProvider.sol\\\";\\nimport \\\"./IMigrator.sol\\\";\\nimport \\\"./FirewallConsumer.sol\\\";\\n\\n/**\\n * @title HoldersSum\\n * @dev Contract handling user balances, account types, and provider data for DelayVaultProvider.\\n */\\nabstract contract HoldersSum is ProviderModifiers, IDelayVaultProvider, FirewallConsumer {\\n    //this is only the delta\\n    //the amount is the amount of the pool\\n    // params[0] = startTimeDelta (empty for DealProvider)\\n    // params[1] = endTimeDelta (only for TimedLockDealProvider)\\n    mapping(address =\\u003e uint256) public userToAmount; // Total amount held by each user\\n    mapping(address =\\u003e uint8) public userToType; //Each user got type, can go up. when withdraw to 0, its reset\\n    mapping(uint8 =\\u003e ProviderData) public typeToProviderData; // Provider data for each tier type; indexed by type\\n    uint8 public typesCount; // Maximum tier type + 1\\n    address public token; // ERC-20 token address\\n    IMigrator public migrator; // Migrator contract for user data migration\\n\\n    event VaultValueChanged(address indexed token, address indexed owner, uint256 amount);\\n\\n    /**\\n     * @dev Retrieves the total amount held by a user, including both DelayVault and V1 DelayVault balances.\\n     * @param user User address.\\n     * @return Total amount held by the user.\\n     */\\n    function getTotalAmount(address user) public view returns (uint256) {\\n        return userToAmount[user] + migrator.getUserV1Amount(user);\\n    }\\n\\n    /**\\n     * @dev Determines the tier type based on the amount of tokens held.\\n     * @dev Better to use binary search if the number of types is more than ~6-7\\n     * @param amount Amount of ERC20 tokens.\\n     * @return theType The deterfmined tier type.\\n     */\\n    function theTypeOf(uint256 amount) public view returns (uint8 theType) {\\n        for (uint8 i = 0; i \\u003c typesCount; ++i) {\\n            if (amount \\u003c= typeToProviderData[i].limit) {\\n                theType = i;\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance (number of NFTs) owned by a user for the current provider.\\n     * @param user User address.\\n     * @return balance (number of NFTs) owned by the user for the current provider.\\n     */\\n    function balanceOf(address user) public view returns (uint256 balance) {\\n        uint256 fullBalanceOf = lockDealNFT.balanceOf(user);\\n        for (uint256 i = 0; i \\u003c fullBalanceOf; ++i) {\\n            if (this == lockDealNFT.poolIdToProvider(lockDealNFT.tokenOfOwnerByIndex(user, i))) {\\n                ++balance;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Retrieves the DelayVault NFT pool ID owned by a user at a specific index.\\n     * @param user User address.\\n     * @param index Index of the user NFT token.\\n     * @return poolId Pool ID of the DelayVault NFT owned by the user at the specified index.\\n     */\\n    function tokenOfOwnerByIndex(address user, uint256 index) public view returns (uint256 poolId) {\\n        uint256 length = balanceOf(user);\\n        require(index \\u003c length, \\\"invalid index poolId\\\");\\n        uint256 fullBalanceOf = lockDealNFT.balanceOf(user);\\n        uint256 j = 0;\\n        for (uint256 i = 0; i \\u003c fullBalanceOf; ++i) {\\n            poolId = lockDealNFT.tokenOfOwnerByIndex(user, i);\\n            if (this == lockDealNFT.poolIdToProvider(poolId) \\u0026\\u0026 j++ == index) {\\n                return poolId;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to add the specified amount to a user\\u0027s total balance and update the tier type.\\n     * @param user User address.\\n     * @param amount Amount to be added.\\n     * @param allowTypeUpgrade Boolean indicating whether tier type upgrades are allowed.\\n     */\\n    function _addHoldersSum(address user, uint256 amount, bool allowTypeUpgrade)\\n        internal\\n        firewallProtectedSig(0x858b046b)\\n    {\\n        uint256 newAmount = userToAmount[user] + amount;\\n        _setHoldersSum(user, newAmount, allowTypeUpgrade);\\n    }\\n\\n    /**\\n     * @dev Internal function to subtract the specified amount from a user\\u0027s total balance.\\n     * @param user User address.\\n     * @param amount Amount to be subtracted.\\n     */\\n    function _subHoldersSum(address user, uint256 amount) internal firewallProtectedSig(0x8d611b76) {\\n        uint256 oldAmount = userToAmount[user];\\n        require(oldAmount \\u003e= amount, \\\"amount exceeded\\\");\\n        uint256 newAmount = oldAmount - amount;\\n        _setHoldersSum(user, newAmount, false);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the total balance for a user and update the tier type.\\n     * @param user User address.\\n     * @param newAmount New total balance for the user.\\n     * @param allowTypeUpgrade Boolean indicating whether tier type upgrades are allowed.\\n     */\\n    function _setHoldersSum(address user, uint256 newAmount, bool allowTypeUpgrade)\\n        internal\\n        firewallProtectedSig(0xf7355e12)\\n    {\\n        uint8 newType = theTypeOf(migrator.getUserV1Amount(user) + newAmount);\\n        if (allowTypeUpgrade) {\\n            _upgradeUserTypeIfGreater(user, newType);\\n        } else {\\n            _upgradeUserTypeIfMatchesV1(user, newType, newAmount);\\n            // Ensure the type doesn\\u0027t change if upgrades are not allowed\\n            require(newType \\u003c= userToType[user], \\\"type must be the same or lower\\\");\\n        }\\n        userToAmount[user] = newAmount;\\n        emit VaultValueChanged(token, user, newAmount);\\n    }\\n\\n    /**\\n     * @dev Internal function to upgrade a user\\u0027s tier type if the new type is greater.\\n     * @param user User address.\\n     * @param newType New tier type.\\n     */\\n    function _upgradeUserTypeIfGreater(address user, uint8 newType) internal firewallProtectedSig(0xbbd9280a) {\\n        if (newType \\u003e userToType[user]) {\\n            userToType[user] = newType;\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to reset a user\\u0027s tier type if the new amount is zero.\\n     * @param user User address.\\n     * @param newType New tier type.\\n     * @param newAmount New total balance for the user.\\n     */\\n    function _upgradeUserTypeIfMatchesV1(address user, uint8 newType, uint256 newAmount)\\n        internal\\n        firewallProtectedSig(0xb37af86d)\\n    {\\n        if (newAmount == 0) {\\n            userToType[user] = newType;\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to finalize the initialization of tier types and provider data.\\n     * @param _providersData Array of provider data for different tier types.\\n     */\\n    function _finalize(ProviderData[] memory _providersData) internal firewallProtectedSig(0xb6daee4e) {\\n        typesCount = uint8(_providersData.length);\\n        uint256 limit = 0;\\n        for (uint8 i = 0; i \\u003c typesCount; ++i) {\\n            limit = _setTypeToProviderData(i, limit, _providersData[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to set provider data for a specific tier type.\\n     * @param theType Tier type.\\n     * @param lastLimit Last limit used for setting provider data.\\n     * @param item Provider data for the specified tier type.\\n     * @return limit Updated limit for the next provider data.\\n     */\\n    function _setTypeToProviderData(\\n        uint8 theType,\\n        uint256 lastLimit,\\n        ProviderData memory item\\n    )\\n        internal\\n        firewallProtectedSig(0x8fac0700)\\n        returns (uint256 limit)\\n    {\\n        require(address(item.provider) != address(0x0), \\\"invalid address\\\");\\n        require(item.provider.currentParamsTargetLength() == item.params.length + 1, \\\"invalid params length\\\");\\n        limit = item.limit;\\n        require(limit \\u003e= lastLimit, \\\"limit must be bigger or equal than the previous on\\\");\\n        typeToProviderData[theType] = item;\\n        if (theType == typesCount - 1) {\\n            typeToProviderData[theType].limit = type(uint256).max; //the last one is the max, token supply is out of the scope\\n        }\\n    }\\n}\\n\"},\"IBeforeTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBeforeTransfer {\\n    function beforeTransfer(address from, address to, uint256 poolId) external;\\n}\"},\"IDelayVaultProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IProvider.sol\\\";\\nimport \\\"./ILockDealNFT.sol\\\";\\n\\n/**\\n * @title IDelayVaultProvider\\n * @dev Interface for the DelayVaultProvider contract, extending the IProvider interface.\\n */\\ninterface IDelayVaultProvider is IProvider {\\n    /**\\n     * @dev Structure representing provider-specific data.\\n     * @param provider The Simple provider contract address.\\n     * @param params An array of parameters: 0 params for DealProvider, 1 for LockProvider, 2 for TimedDealProvider.\\n     * @param limit The limit associated with the tier level.\\n     */\\n    struct ProviderData {\\n        IProvider provider;\\n        uint256[] params;\\n        uint256 limit;\\n    }\\n\\n    /**\\n     * @dev Creates a new delay vault associated with the specified owner and parameters.\\n     * @param owner The address of the vault owner.\\n     * @param params An array of parameters for the new delay vault.\\n     * @return poolId The unique identifier of the newly created delay vault.\\n     */\\n    function createNewDelayVault(address owner, uint256[] memory params) external returns (uint256 poolId);\\n\\n    /**\\n     * @dev Retrieves the address of the ERC-20 token associated with the DelayVaultProvider.\\n     * @return The address of the ERC-20 token.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @dev Determines the tier type based on the specified amount of assets.\\n     * @param amount The amount of assets.\\n     * @return theType The determined tier type.\\n     */\\n    function theTypeOf(uint256 amount) external view returns (uint8 theType);\\n\\n    /**\\n     * @dev Retrieves the total amount of assets owned by a specific user.\\n     * @param user The address of the user.\\n     * @return totalAmount The total amount of assets owned by the user.\\n     */\\n    function getTotalAmount(address user) external view returns (uint256);\\n\\n    /**\\n     * @dev Retrieves provider-specific data based on the specified tier type.\\n     * @param theType The tier type.\\n     * @return providerData The provider data associated with the tier type.\\n     */\\n    function getTypeToProviderData(uint8 theType) external view returns (ProviderData memory providerData);\\n\\n    /**\\n     * @dev Retrieves the parameters for withdrawing a specified amount from a pool associated with a certain tier type.\\n     * @param amount The amount to withdraw.\\n     * @param theType The tier type.\\n     * @return params The parameters for withdrawing the specified amount.\\n     */\\n    function getWithdrawPoolParams(uint256 amount, uint8 theType) external view returns (uint256[] memory params);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"},\"IERC2981.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"},\"IFirewall.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2023\\npragma solidity 0.8.19;\\n\\ninterface IFirewall {\\n    function preExecution(address sender, bytes memory data, uint value) external;\\n    function postExecution(address sender, bytes memory data, uint value) external;\\n}\\n\"},\"IFirewallConsumer.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n// See LICENSE file for full license text.\\n// Copyright (c) Ironblocks 2023\\npragma solidity 0.8.19;\\n\\ninterface IFirewallConsumer {\\n    function firewallAdmin() external returns (address);\\n}\\n\"},\"ILockDealNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IProvider.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IVaultManager.sol\\\";\\n\\ninterface ILockDealNFT is IERC721Enumerable {\\n    function approvedContracts(address contractAddress) external view returns (bool);\\n\\n    function mintAndTransfer(\\n        address owner,\\n        address token,\\n        uint256 amount,\\n        IProvider provider\\n    ) external returns (uint256 poolId);\\n\\n    function safeMintAndTransfer(\\n        address owner,\\n        address token,\\n        address from,\\n        uint256 amount,\\n        IProvider provider,\\n        bytes calldata data\\n    ) external returns (uint256 poolId);\\n\\n    function cloneVaultId(uint256 destinationPoolId, uint256 sourcePoolId) external;\\n\\n    function mintForProvider(address owner, IProvider provider) external returns (uint256 poolId);\\n\\n    function getData(uint256 poolId) external view returns (BasePoolInfo memory poolInfo);\\n\\n    function getFullData(uint256 poolId) external view returns (BasePoolInfo[] memory poolInfo);\\n\\n    function tokenOf(uint256 poolId) external view returns (address token);\\n\\n    function vaultManager() external view returns (IVaultManager);\\n\\n    function poolIdToProvider(uint256 poolId) external view returns (IProvider provider);\\n\\n    function getWithdrawableAmount(uint256 poolId) external view returns (uint256 withdrawalAmount);\\n\\n    struct BasePoolInfo {\\n        IProvider provider;\\n        string name;\\n        uint256 poolId;\\n        uint256 vaultId;\\n        address owner;\\n        address token;\\n        uint256[] params;\\n    }\\n}\\n\"},\"IMigrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILockDealNFT.sol\\\";\\n\\n/**\\n * @title IMigrator\\n * @dev Interface for the migrator contract used in the migration process between different versions of the DelayVault system.\\n */\\ninterface IMigrator {\\n    /**\\n     * @dev Retrieves the amount of assets associated with a user in version 1 of the DelayVault system.\\n     * @param user The address of the user.\\n     * @return amount The amount of assets owned by the user in version 1.\\n     */\\n    function getUserV1Amount(address user) external view returns (uint256 amount);\\n\\n    /**\\n     * @dev Retrieves the address of the LockDealNFT contract.\\n     * @return lockDealNFT The address of the LockDealNFT contract.\\n     */\\n    function lockDealNFT() external view returns (ILockDealNFT);\\n}\"},\"IProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n///@dev Interface for the provider contract\\n///@notice This interface is used by the NFT contract to call the provider contract\\ninterface IProvider {\\n    event UpdateParams(uint256 indexed poolId, uint256[] params);\\n\\n    function withdraw(uint256 tokenId) external returns (uint256 withdrawnAmount, bool isFinal);\\n\\n    function split(uint256 oldPoolId, uint256 newPoolId, uint256 ratio) external;\\n\\n    function registerPool(uint256 poolId, uint256[] calldata params) external;\\n\\n    function getParams(uint256 poolId) external view returns (uint256[] memory params);\\n\\n    function getWithdrawableAmount(uint256 poolId) external view returns (uint256 withdrawalAmount);\\n\\n    function currentParamsTargetLength() external view returns (uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function getSubProvidersPoolIds(uint256 poolID) external view returns (uint256[] memory poolIds);\\n}\\n\"},\"IVaultManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC2981.sol\\\";\\n\\ninterface IVaultManager is IERC2981 {\\n    function depositByToken(address _tokenAddress, uint _amount) external returns (uint vaultId);\\n    function safeDeposit(\\n        address _tokenAddress,\\n        uint _amount,\\n        address _from,\\n        bytes memory _signature\\n    ) external returns (uint vaultId);\\n    function withdrawByVaultId(uint _vaultId, address to, uint _amount) external;\\n    function vaultIdToTokenAddress(uint _vaultId) external view returns (address token);\\n    function vaultIdToTradeStartTime(uint256 _vaultId) external view returns (uint256 startTime);\\n}\\n\"},\"LastPoolOwnerState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeforeTransfer.sol\\\";\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title LastPoolOwnerState\\n * @dev Contract to keep track of the last owner of a DelayVaultProvider pool before a transfer.\\n */\\nabstract contract LastPoolOwnerState is IBeforeTransfer, IERC165 {\\n    // Mapping to store the last owner of each DelayVaultProvider pool before a transfer\\n    mapping(uint256 =\\u003e address) internal lastPoolOwner;\\n\\n    /**\\n     * @dev Function to be called before a transfer.\\n     * @param from Address from which the transfer is initiated.\\n     * @param to Address to which the transfer is directed.\\n     * @param poolId Identifier of the DelayVaultProvider pool.\\n     */\\n    function beforeTransfer(address from, address to, uint256 poolId) external virtual override;\\n\\n    /**\\n     * @dev Checks whether a contract supports the specified interface.\\n     * @param interfaceId Interface identifier.\\n     * @return A boolean indicating whether the contract supports the specified interface.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IBeforeTransfer).interfaceId;\\n    }\\n}\\n\"},\"ProviderModifiers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ProviderState.sol\\\";\\nimport \\\"./ERC165Checker.sol\\\";\\n\\nabstract contract ProviderModifiers is ProviderState {\\n    modifier onlyProvider() {\\n        _onlyProvider();\\n        _;\\n    }\\n\\n    modifier validParamsLength(uint256 paramsLength, uint256 minLength) {\\n        _validParamsLength(paramsLength, minLength);\\n        _;\\n    }\\n\\n    modifier onlyNFT() {\\n        _onlyNFT();\\n        _;\\n    }\\n\\n    modifier validProviderAssociation(uint256 poolId, IProvider provider) {\\n        _validProvider(poolId, provider);\\n        _;\\n    }\\n\\n    modifier validProviderId(uint256 poolId) {\\n        _validProvider(poolId, this);\\n        _;\\n    }\\n\\n    modifier validAddressesLength(uint256 addressLength, uint256 minLength) {\\n        _validAddressLength(addressLength, minLength);\\n        _;\\n    }\\n\\n    function _validAddressLength(uint256 addressLength, uint256 minLength) internal pure {\\n        require(addressLength \\u003e= minLength, \\\"invalid addresses length\\\");\\n    }\\n\\n    function _validProvider(uint256 poolId, IProvider provider) internal view {\\n        require(lockDealNFT.poolIdToProvider(poolId) == provider, \\\"Invalid provider poolId\\\");\\n    }\\n\\n    function _onlyNFT() internal view {\\n        require(msg.sender == address(lockDealNFT), \\\"only NFT contract can call this function\\\");\\n    }\\n\\n    function _validParamsLength(uint256 paramsLength, uint256 minLength) private pure {\\n        require(paramsLength \\u003e= minLength, \\\"invalid params length\\\");\\n    }\\n\\n    function _onlyProvider() private view {\\n        require(lockDealNFT.approvedContracts(msg.sender), \\\"invalid provider address\\\");\\n    }\\n\\n    function _validProviderInterface(IProvider provider, bytes4 interfaceId) internal view {\\n        require(ERC165Checker.supportsInterface(address(provider), interfaceId), \\\"invalid provider type\\\");\\n    }\\n}\\n\"},\"ProviderState.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILockDealNFT.sol\\\";\\n\\nabstract contract ProviderState is IProvider {\\n    ///@dev Each provider sets its own name\\n    string public name;\\n    ILockDealNFT public lockDealNFT;\\n\\n    ///@dev each provider decides how many parameters it needs by overriding this function\\n    function currentParamsTargetLength() public view virtual returns (uint256) {\\n        return 1;\\n    }\\n\\n    function getSubProvidersPoolIds(uint256) public view virtual override returns (uint256[] memory poolIds) {\\n        return poolIds;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IMigrator\",\"name\":\"_migrator\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"internalType\":\"struct IDelayVaultProvider.ProviderData[]\",\"name\":\"_providersData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"}],\"name\":\"UpdateParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VaultValueChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"beforeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"}],\"name\":\"createNewDelayVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"createNewDelayVaultWithSignature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentParamsTargetLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firewallAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getParams\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getSubProvidersPoolIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"poolIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"theType\",\"type\":\"uint8\"}],\"name\":\"getTypeToProviderData\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"internalType\":\"struct IDelayVaultProvider.ProviderData\",\"name\":\"providerData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"theType\",\"type\":\"uint8\"}],\"name\":\"getWithdrawPoolParams\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDealNFT\",\"outputs\":[{\"internalType\":\"contract ILockDealNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"contract IMigrator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolIdToAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"}],\"name\":\"registerPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_firewall\",\"type\":\"address\"}],\"name\":\"setFirewall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_firewallAdmin\",\"type\":\"address\"}],\"name\":\"setFirewallAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oldPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPoolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"split\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"theTypeOf\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"theType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"typeToProviderData\",\"outputs\":[{\"internalType\":\"contract IProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typesCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newType\",\"type\":\"uint8\"}],\"name\":\"upgradeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userToType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DelayVaultProvider", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000baea9aba1454df334943951d51116ae342eab25500000000000000000000000010f1da58d6d25b5909d5897ea3ba3e76fce774a5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000eb21d2745e52f39c57c129b44d62cfca37aa0a0a00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000bdae612980e3cc0000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000d2f00000000000000000000000000eb21d2745e52f39c57c129b44d62cfca37aa0a0a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000043c25e0dcc1bd1c0000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000001a5e00000000000000000000000000eb21d2745e52f39c57c129b44d62cfca37aa0a0a000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000043c33c193756480000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000278d00", "EVMVersion": "byzantium", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8229c31b60341a7a49b067d52f288f213203a36ed1b6992e352877caa6447485"}