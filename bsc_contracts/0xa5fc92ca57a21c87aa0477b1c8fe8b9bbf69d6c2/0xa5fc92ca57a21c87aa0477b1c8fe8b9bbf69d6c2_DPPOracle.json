{"SourceCode": "// File: contracts/lib/InitializableOwnable.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Ownable\r\n * @author DODO Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n\r\ninterface IFeeRateImpl {\r\n    function getFeeRate(address pool, address trader) external view returns (uint256);\r\n}\r\n\r\ninterface IFeeRateModel {\r\n    function getFeeRate(address trader) external view returns (uint256);\r\n}\r\n\r\ncontract FeeRateModel is InitializableOwnable {\r\n    address public feeRateImpl;\r\n\r\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\r\n        feeRateImpl = _feeRateImpl;\r\n    }\r\n    \r\n    function getFeeRate(address trader) external view returns (uint256) {\r\n        if(feeRateImpl == address(0))\r\n            return 0;\r\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n\r\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\r\n        if (e == 0) {\r\n            return 10 ** 18;\r\n        } else if (e == 1) {\r\n            return target;\r\n        } else {\r\n            uint p = powFloor(target, e.div(2));\r\n            p = p.mul(p) / (10**18);\r\n            if (e % 2 == 1) {\r\n                p = p.mul(target) / (10**18);\r\n            }\r\n            return p;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @author DODO Breeder\r\n *\r\n * @notice Protect functions from Reentrancy Attack\r\n */\r\ncontract ReentrancyGuard {\r\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\r\n    // zero-state of _ENTERED_ is false\r\n    bool private _ENTERED_;\r\n\r\n    modifier preventReentrant() {\r\n        require(!_ENTERED_, \"REENTRANT\");\r\n        _ENTERED_ = true;\r\n        _;\r\n        _ENTERED_ = false;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title DODOMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\r\n */\r\nlibrary DODOMath {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n        Integrate dodo curve from V1 to V2\r\n        require V0>=V1>=V2>0\r\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\r\n        let V1-V2=delta\r\n        res = i*delta*(1-k+k(V0^2/V1/V2))\r\n\r\n        i is the price of V-res trading pair\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _GeneralIntegrate(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 V2,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        require(V0 > 0, \"TARGET_IS_ZERO\");\r\n        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\r\n        if (k == 0) {\r\n            return fairAmount.div(DecimalMath.ONE);\r\n        }\r\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\r\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\r\n        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\r\n    }\r\n\r\n    /*\r\n        Follow the integration function above\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\r\n\r\n        i is the price of delta-V trading pair\r\n        give out target of V\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _SolveQuadraticFunctionForTarget(\r\n        uint256 V1,\r\n        uint256 delta,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        if (k == 0) {\r\n            return V1.add(DecimalMath.mulFloor(i, delta));\r\n        }\r\n        // V0 = V1*(1+(sqrt-1)/2k)\r\n        // sqrt = \u221a(1+4kidelta/V1)\r\n        // premium = 1+(sqrt-1)/2k\r\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\r\n\r\n        if (V1 == 0) {\r\n            return 0;\r\n        }\r\n        uint256 sqrt;\r\n        uint256 ki = (4 * k).mul(i);\r\n        if (ki == 0) {\r\n            sqrt = DecimalMath.ONE;\r\n        } else if ((ki * delta) / ki == delta) {\r\n            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\r\n        } else {\r\n            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\r\n        }\r\n        uint256 premium =\r\n            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\r\n        // V0 is greater than or equal to V1 according to the solution\r\n        return DecimalMath.mulFloor(V1, premium);\r\n    }\r\n\r\n    /*\r\n        Follow the integration expression above, we have:\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Given Q1 and deltaB, solve Q2\r\n        This is a quadratic function and the standard version is\r\n        aQ2^2 + bQ2 + c = 0, where\r\n        a=1-k\r\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\r\n        c=-kQ0^2 \r\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\r\n        note: another root is negative, abondan\r\n\r\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\r\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\r\n        return |Q1-Q2|\r\n\r\n        as we only support sell amount as delta, the deltaB is always negative\r\n        the input ideltaB is actually -ideltaB in the equation\r\n\r\n        i is the price of delta-V trading pair\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _SolveQuadraticFunctionForTrade(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 delta,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        require(V0 > 0, \"TARGET_IS_ZERO\");\r\n        if (delta == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (k == 0) {\r\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\r\n        }\r\n\r\n        if (k == DecimalMath.ONE) {\r\n            // if k==1\r\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\r\n            // temp = ideltaBQ1/Q0/Q0\r\n            // Q2 = Q1/(1+temp)\r\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\r\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\r\n            uint256 temp;\r\n            uint256 idelta = i.mul(delta);\r\n            if (idelta == 0) {\r\n                temp = 0;\r\n            } else if ((idelta * V1) / idelta == V1) {\r\n                temp = (idelta * V1).div(V0.mul(V0));\r\n            } else {\r\n                temp = delta.mul(V1).div(V0).mul(i).div(V0);\r\n            }\r\n            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\r\n        }\r\n\r\n        // calculate -b value and sig\r\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\r\n        // part1 = (1-k)Q1 >=0\r\n        // part2 = kQ0^2/Q1-i*deltaB >=0\r\n        // bAbs = abs(part1-part2)\r\n        // if part1>part2 => b is negative => bSig is false\r\n        // if part2>part1 => b is positive => bSig is true\r\n        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\r\n        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\r\n\r\n        bool bSig;\r\n        if (bAbs >= part2) {\r\n            bAbs = bAbs - part2;\r\n            bSig = false;\r\n        } else {\r\n            bAbs = part2 - bAbs;\r\n            bSig = true;\r\n        }\r\n        bAbs = bAbs.div(DecimalMath.ONE);\r\n\r\n        // calculate sqrt\r\n        uint256 squareRoot =\r\n            DecimalMath.mulFloor(\r\n                DecimalMath.ONE.sub(k).mul(4),\r\n                DecimalMath.mulFloor(k, V0).mul(V0)\r\n            ); // 4(1-k)kQ0^2\r\n        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\r\n\r\n        // final res\r\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\r\n        uint256 numerator;\r\n        if (bSig) {\r\n            numerator = squareRoot.sub(bAbs);\r\n        } else {\r\n            numerator = bAbs.add(squareRoot);\r\n        }\r\n\r\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\r\n        if (V2 > V1) {\r\n            return 0;\r\n        } else {\r\n            return V1 - V2;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Pricing\r\n * @author DODO Breeder\r\n *\r\n * @notice DODO Pricing model\r\n */\r\n\r\nlibrary PMMPricing {\r\n    using SafeMath for uint256;\r\n\r\n    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\r\n\r\n    struct PMMState {\r\n        uint256 i;\r\n        uint256 K;\r\n        uint256 B;\r\n        uint256 Q;\r\n        uint256 B0;\r\n        uint256 Q0;\r\n        RState R;\r\n    }\r\n\r\n    // ============ buy & sell ============\r\n\r\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveQuoteAmount, RState newR)\r\n    {\r\n        if (state.R == RState.ONE) {\r\n            // case 1: R=1\r\n            // R falls below one\r\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\r\n            newR = RState.BELOW_ONE;\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            uint256 backToOnePayBase = state.B0.sub(state.B);\r\n            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\r\n            // case 2: R>1\r\n            // complex case, R status depends on trading amount\r\n            if (payBaseAmount < backToOnePayBase) {\r\n                // case 2.1: R status do not change\r\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\r\n                newR = RState.ABOVE_ONE;\r\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\r\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\r\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\r\n                    receiveQuoteAmount = backToOneReceiveQuote;\r\n                }\r\n            } else if (payBaseAmount == backToOnePayBase) {\r\n                // case 2.2: R status changes to ONE\r\n                receiveQuoteAmount = backToOneReceiveQuote;\r\n                newR = RState.ONE;\r\n            } else {\r\n                // case 2.3: R status changes to BELOW_ONE\r\n                receiveQuoteAmount = backToOneReceiveQuote.add(\r\n                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\r\n                );\r\n                newR = RState.BELOW_ONE;\r\n            }\r\n        } else {\r\n            // state.R == RState.BELOW_ONE\r\n            // case 3: R<1\r\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\r\n            newR = RState.BELOW_ONE;\r\n        }\r\n    }\r\n\r\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveBaseAmount, RState newR)\r\n    {\r\n        if (state.R == RState.ONE) {\r\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\r\n            newR = RState.ABOVE_ONE;\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\r\n            newR = RState.ABOVE_ONE;\r\n        } else {\r\n            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\r\n            uint256 backToOneReceiveBase = state.B.sub(state.B0);\r\n            if (payQuoteAmount < backToOnePayQuote) {\r\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\r\n                newR = RState.BELOW_ONE;\r\n                if (receiveBaseAmount > backToOneReceiveBase) {\r\n                    receiveBaseAmount = backToOneReceiveBase;\r\n                }\r\n            } else if (payQuoteAmount == backToOnePayQuote) {\r\n                receiveBaseAmount = backToOneReceiveBase;\r\n                newR = RState.ONE;\r\n            } else {\r\n                receiveBaseAmount = backToOneReceiveBase.add(\r\n                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\r\n                );\r\n                newR = RState.ABOVE_ONE;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ R = 1 cases ============\r\n\r\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        // in theory Q2 <= targetQuoteTokenAmount\r\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.Q0,\r\n                state.Q0,\r\n                payBaseAmount,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.B0,\r\n                state.B0,\r\n                payQuoteAmount,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ R < 1 cases ============\r\n\r\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._GeneralIntegrate(\r\n                state.Q0,\r\n                state.Q.add(payQuoteAmount),\r\n                state.Q,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.Q0,\r\n                state.Q,\r\n                payBaseAmount,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ R > 1 cases ============\r\n\r\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._GeneralIntegrate(\r\n                state.B0,\r\n                state.B.add(payBaseAmount),\r\n                state.B,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            DODOMath._SolveQuadraticFunctionForTrade(\r\n                state.B0,\r\n                state.B,\r\n                payQuoteAmount,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ Helper functions ============\r\n\r\n    function adjustedTarget(PMMState memory state) internal pure {\r\n        if (state.R == RState.BELOW_ONE) {\r\n            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\r\n                state.Q,\r\n                state.B.sub(state.B0),\r\n                state.i,\r\n                state.K\r\n            );\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\r\n                state.B,\r\n                state.Q.sub(state.Q0),\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n        }\r\n    }\r\n\r\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\r\n        if (state.R == RState.BELOW_ONE) {\r\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\r\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\r\n            return DecimalMath.divFloor(state.i, R);\r\n        } else {\r\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\r\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\r\n            return DecimalMath.mulFloor(state.i, R);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ninterface IOracle {\r\n    function getPrice(address base) external view returns (uint256 latestPrice,bool isValid,bool isStale,uint256 timestamp);    \r\n\r\n    function prices(address base) external view returns (uint256);\r\n    \r\n    function isFeasible(address base) external view returns (bool); \r\n}\r\n\r\n\r\n\r\ncontract DPPStorage is InitializableOwnable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    bool public _IS_OPEN_TWAP_ = false;\r\n    bool public _IS_ORACLE_ENABLED = true;\r\n\r\n    // ============ Core Address ============\r\n\r\n    address public _MAINTAINER_;\r\n\r\n    IERC20 public _BASE_TOKEN_;\r\n    IERC20 public _QUOTE_TOKEN_;\r\n\r\n    uint112 public _BASE_RESERVE_;\r\n    uint112 public _QUOTE_RESERVE_;\r\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\r\n\r\n    uint112 public _BASE_TARGET_;\r\n    uint112 public _QUOTE_TARGET_;\r\n    uint32 public _RState_;\r\n\r\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\r\n\r\n    // ============ Variables for Pricing ============\r\n\r\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\r\n    \r\n    uint64 public _LP_FEE_RATE_;\r\n    uint64 public _K_;\r\n    uint128 public _I_;\r\n    address public _O_;\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\r\n        if (_IS_ORACLE_ENABLED) {\r\n            state.i = IOracle(_O_).prices(address(_BASE_TOKEN_));\r\n        } else {\r\n            state.i = _I_;\r\n        }\r\n        state.K = _K_;\r\n        state.B = _BASE_RESERVE_;\r\n        state.Q = _QUOTE_RESERVE_;\r\n        state.B0 = _BASE_TARGET_;\r\n        state.Q0 = _QUOTE_TARGET_;\r\n        state.R = PMMPricing.RState(_RState_);\r\n        PMMPricing.adjustedTarget(state);\r\n    }\r\n\r\n    function getPMMStateForCall() \r\n        external \r\n        view \r\n        returns (\r\n            uint256 i,\r\n            uint256 K,\r\n            uint256 B,\r\n            uint256 Q,\r\n            uint256 B0,\r\n            uint256 Q0,\r\n            uint256 R\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        i = state.i;\r\n        K = state.K;\r\n        B = state.B;\r\n        Q = state.Q;\r\n        B0 = state.B0;\r\n        Q0 = state.Q0;\r\n        R = uint256(state.R);\r\n    }\r\n\r\n    function getMidPrice() public view returns (uint256 midPrice) {\r\n        return PMMPricing.getMidPrice(getPMMState());\r\n    }\r\n}\r\n\r\n\r\ninterface IDODOCallee {\r\n    function DVMSellShareCall(\r\n        address sender,\r\n        uint256 burnShareAmount,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DVMFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DPPFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DSPFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function CPCancelCall(\r\n        address sender,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n\tfunction CPClaimBidCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function NFTRedeemCall(\r\n        address payable assetTo,\r\n        uint256 quoteAmount,\r\n        bytes calldata\r\n    ) external;\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract DPPVault is DPPStorage {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ Events ============\r\n\r\n    event LpFeeRateChange(uint256 newLpFeeRate);\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\r\n        baseReserve = _BASE_RESERVE_;\r\n        quoteReserve = _QUOTE_RESERVE_;\r\n    }\r\n\r\n    function getUserFeeRate(address user)\r\n        external\r\n        view\r\n        returns (uint256 lpFeeRate, uint256 mtFeeRate)\r\n    {\r\n        lpFeeRate = _LP_FEE_RATE_;\r\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\r\n    }\r\n\r\n    // ============ Get Input ============\r\n\r\n    function getBaseInput() public view returns (uint256 input) {\r\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\r\n    }\r\n\r\n    function getQuoteInput() public view returns (uint256 input) {\r\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\r\n    }\r\n\r\n    // ============ TWAP UPDATE ===========\r\n    \r\n    function _twapUpdate() internal {\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\r\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\r\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\r\n        }\r\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\r\n    }\r\n\r\n    // ============ Set Status ============\r\n\r\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\r\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\r\n        _BASE_RESERVE_ = uint112(baseReserve);\r\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function _sync() internal {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        \r\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\r\n\r\n        if (baseBalance != _BASE_RESERVE_) {\r\n            _BASE_RESERVE_ = uint112(baseBalance);\r\n        }\r\n        if (quoteBalance != _QUOTE_RESERVE_) {\r\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\r\n        }\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function _resetTargetAndReserve() internal {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n\r\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\r\n        \r\n        _BASE_RESERVE_ = uint112(baseBalance);\r\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\r\n        _BASE_TARGET_ = uint112(baseBalance);\r\n        _QUOTE_TARGET_ = uint112(quoteBalance);\r\n        _RState_ = uint32(PMMPricing.RState.ONE);\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function ratioSync() external preventReentrant onlyOwner {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n\r\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\r\n\r\n        if (baseBalance != _BASE_RESERVE_) {\r\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).mul(baseBalance).div(uint256(_BASE_RESERVE_)));\r\n            _BASE_RESERVE_ = uint112(baseBalance);\r\n        }\r\n        if (quoteBalance != _QUOTE_RESERVE_) {\r\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).mul(quoteBalance).div(uint256(_QUOTE_RESERVE_)));\r\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\r\n        }\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function reset(\r\n        address assetTo,\r\n        uint256 newLpFeeRate,\r\n        uint256 newI,\r\n        uint256 newK,\r\n        uint256 baseOutAmount,\r\n        uint256 quoteOutAmount,\r\n        uint256 minBaseReserve,\r\n        uint256 minQuoteReserve\r\n    ) public preventReentrant onlyOwner returns (bool) {\r\n        require(\r\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\r\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\r\n        );\r\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\r\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\r\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\r\n\r\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\r\n        _K_ = uint64(newK);\r\n        _I_ = uint128(newI);\r\n\r\n        _transferBaseOut(assetTo, baseOutAmount);\r\n        _transferQuoteOut(assetTo, quoteOutAmount);\r\n        _resetTargetAndReserve();\r\n        emit LpFeeRateChange(newLpFeeRate);\r\n        return true;\r\n    }\r\n\r\n    // ============ Asset Out ============\r\n\r\n    function _transferBaseOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _BASE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    function _transferQuoteOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    function retrieve(\r\n        address to,\r\n        address token,\r\n        uint256 amount\r\n    ) external preventReentrant onlyOwner {\r\n        require(token != address(_BASE_TOKEN_) && token != address(_QUOTE_TOKEN_), \"USE_RESET\");\r\n        IERC20(token).safeTransfer(to, amount);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract DPPTrader is DPPVault {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Events ============\r\n\r\n    event DODOSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromAmount,\r\n        uint256 toAmount,\r\n        address trader,\r\n        address receiver\r\n    );\r\n\r\n    event DODOFlashLoan(\r\n        address borrower,\r\n        address assetTo,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount\r\n    );\r\n\r\n    event RChange(PMMPricing.RState newRState);\r\n\r\n\r\n    // ============ Trade Functions ============\r\n\r\n    function sellBase(address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 receiveQuoteAmount)\r\n    {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n        uint256 mtFee;\r\n        uint256 newBaseTarget;\r\n        PMMPricing.RState newRState;\r\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\r\n\r\n        _transferQuoteOut(to, receiveQuoteAmount);\r\n        _transferQuoteOut(_MAINTAINER_, mtFee);\r\n        \r\n        // update TARGET\r\n        if (_RState_ != uint32(newRState)) {\r\n            require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\r\n            _BASE_TARGET_ = uint112(newBaseTarget);\r\n            _RState_ = uint32(newRState);\r\n            emit RChange(newRState);\r\n        }\r\n\r\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\r\n\r\n        emit DODOSwap(\r\n            address(_BASE_TOKEN_),\r\n            address(_QUOTE_TOKEN_),\r\n            baseInput,\r\n            receiveQuoteAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function sellQuote(address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 receiveBaseAmount)\r\n    {\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n        uint256 mtFee;\r\n        uint256 newQuoteTarget;\r\n        PMMPricing.RState newRState;\r\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\r\n            tx.origin,\r\n            quoteInput\r\n        );\r\n\r\n        _transferBaseOut(to, receiveBaseAmount);\r\n        _transferBaseOut(_MAINTAINER_, mtFee);\r\n\r\n        // update TARGET\r\n        if (_RState_ != uint32(newRState)) {\r\n            require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\r\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\r\n            _RState_ = uint32(newRState);\r\n            emit RChange(newRState);\r\n        }\r\n\r\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\r\n\r\n        emit DODOSwap(\r\n            address(_QUOTE_TOKEN_),\r\n            address(_BASE_TOKEN_),\r\n            quoteInput,\r\n            receiveBaseAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function flashLoan(\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        address _assetTo,\r\n        bytes calldata data\r\n    ) external preventReentrant {\r\n        address assetTo = _assetTo;\r\n        _transferBaseOut(assetTo, baseAmount);\r\n        _transferQuoteOut(assetTo, quoteAmount);\r\n\r\n        if (data.length > 0)\r\n            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\r\n\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n\r\n        // no input -> pure loss\r\n        require(\r\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\r\n            \"FLASH_LOAN_FAILED\"\r\n        );\r\n\r\n        // sell quote case\r\n        // quote input + base output\r\n        if (baseBalance < _BASE_RESERVE_) {\r\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n            (\r\n                uint256 receiveBaseAmount,\r\n                uint256 mtFee,\r\n                PMMPricing.RState newRState,\r\n                uint256 newQuoteTarget\r\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\r\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\r\n\r\n            _transferBaseOut(_MAINTAINER_, mtFee);\r\n            if (_RState_ != uint32(newRState)) {\r\n                require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\r\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\r\n                _RState_ = uint32(newRState);\r\n                emit RChange(newRState);\r\n            }\r\n            emit DODOSwap(\r\n                address(_QUOTE_TOKEN_),\r\n                address(_BASE_TOKEN_),\r\n                quoteInput,\r\n                receiveBaseAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        // sell base case\r\n        // base input + quote output\r\n        if (quoteBalance < _QUOTE_RESERVE_) {\r\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n            (\r\n                uint256 receiveQuoteAmount,\r\n                uint256 mtFee,\r\n                PMMPricing.RState newRState,\r\n                uint256 newBaseTarget\r\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\r\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\r\n\r\n            _transferQuoteOut(_MAINTAINER_, mtFee);\r\n            if (_RState_ != uint32(newRState)) {\r\n                require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\r\n                _BASE_TARGET_ = uint112(newBaseTarget);\r\n                _RState_ = uint32(newRState);\r\n                emit RChange(newRState);\r\n            }\r\n            emit DODOSwap(\r\n                address(_BASE_TOKEN_),\r\n                address(_QUOTE_TOKEN_),\r\n                baseInput,\r\n                receiveQuoteAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        _sync();\r\n        \r\n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\r\n    }\r\n\r\n    // ============ Query Functions ============\r\n\r\n    function querySellBase(address trader, uint256 payBaseAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 receiveQuoteAmount,\r\n            uint256 mtFee,\r\n            PMMPricing.RState newRState,\r\n            uint256 newBaseTarget\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\r\n        receiveQuoteAmount = receiveQuoteAmount\r\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n        newBaseTarget = state.B0;\r\n    }\r\n\r\n    function querySellQuote(address trader, uint256 payQuoteAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 receiveBaseAmount,\r\n            uint256 mtFee,\r\n            PMMPricing.RState newRState,\r\n            uint256 newQuoteTarget\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\r\n        receiveBaseAmount = receiveBaseAmount\r\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n        newQuoteTarget = state.Q0;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title DODO PrivatePool\r\n * @author DODO Breeder\r\n *\r\n * @notice DODOPrivatePool with oracle price\r\n */\r\ncontract DPPOracle is DPPTrader {\r\n\r\n    event EnableOracle();\r\n    event DisableOracle(uint256 newI);\r\n    event ChangeOracle(address indexed oracle);\r\n\r\n    function init(\r\n        address owner,\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 k,\r\n        uint256 i,\r\n        address o,\r\n        bool isOpenTWAP,\r\n        bool isOracleEnabled\r\n    ) external {\r\n        initOwner(owner);\r\n\r\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\r\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\r\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\r\n\r\n        _MAINTAINER_ = maintainer;\r\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\r\n        \r\n        require(lpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\r\n        require(k <= 1e18, \"K_OUT_OF_RANGE\");\r\n        require(i > 0 && i <= 1e36, \"I_OUT_OF_RANGE\");\r\n        require(o !=  address(0), \"INVALID_ORACLE\");\r\n\r\n        _LP_FEE_RATE_ = uint64(lpFeeRate);\r\n        _K_ = uint64(k);\r\n        _I_ = uint128(i);\r\n        _O_ = o;\r\n\r\n        _IS_OPEN_TWAP_ = isOpenTWAP;\r\n        _IS_ORACLE_ENABLED = isOracleEnabled;\r\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\r\n        \r\n        _resetTargetAndReserve();\r\n    }\r\n\r\n    function changeOracle(address newOracle) public preventReentrant onlyOwner {\r\n        require(newOracle !=  address(0), \"INVALID_ORACLE\");\r\n        _O_ = newOracle;\r\n        emit ChangeOracle(newOracle);\r\n    }\r\n\r\n    function enableOracle() public preventReentrant onlyOwner {\r\n        _IS_ORACLE_ENABLED = true;\r\n        emit EnableOracle();\r\n    }\r\n\r\n    function disableOracle(uint256 newI) public preventReentrant onlyOwner {\r\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\r\n        _I_ = uint128(newI);\r\n        _IS_ORACLE_ENABLED = false;\r\n        emit DisableOracle(newI);\r\n    }\r\n\r\n    function tuneParameters(\r\n        uint256 newLpFeeRate,\r\n        uint256 newI,\r\n        uint256 newK,\r\n        uint256 minBaseReserve,\r\n        uint256 minQuoteReserve\r\n    ) public preventReentrant onlyOwner returns (bool) {\r\n        require(\r\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\r\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\r\n        );\r\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\r\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\r\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\r\n\r\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\r\n        _K_ = uint64(newK);\r\n        _I_ = uint128(newI);\r\n\r\n        emit LpFeeRateChange(newLpFeeRate);\r\n        return true;\r\n    }\r\n\r\n    function tunePrice(\r\n        uint256 newI,\r\n        uint256 minBaseReserve,\r\n        uint256 minQuoteReserve\r\n    ) public preventReentrant onlyOwner returns (bool) {\r\n        require(\r\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\r\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\r\n        );\r\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\r\n        _I_ = uint128(newI);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ============ Version Control ============\r\n\r\n    function version() external pure returns (string memory) {\r\n        return \"DPP Oracle 1.1.0\";\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"ChangeOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"assetTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"name\":\"DODOFlashLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"DODOSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newI\",\"type\":\"uint256\"}],\"name\":\"DisableOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnableOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLpFeeRate\",\"type\":\"uint256\"}],\"name\":\"LpFeeRateChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PMMPricing.RState\",\"name\":\"newRState\",\"type\":\"uint8\"}],\"name\":\"RChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_BASE_PRICE_CUMULATIVE_LAST_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BASE_RESERVE_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BASE_TARGET_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BASE_TOKEN_\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BLOCK_TIMESTAMP_LAST_\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_IS_OPEN_TWAP_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_IS_ORACLE_ENABLED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_I_\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_K_\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_LP_FEE_RATE_\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAINTAINER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MT_FEE_RATE_MODEL_\",\"outputs\":[{\"internalType\":\"contract IFeeRateModel\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_O_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_QUOTE_RESERVE_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_QUOTE_TARGET_\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_QUOTE_TOKEN_\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_RState_\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"changeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newI\",\"type\":\"uint256\"}],\"name\":\"disableOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_assetTo\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMidPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"midPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPMMState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q0\",\"type\":\"uint256\"},{\"internalType\":\"enum PMMPricing.RState\",\"name\":\"R\",\"type\":\"uint8\"}],\"internalType\":\"struct PMMPricing.PMMState\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPMMStateForCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"K\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"B0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Q0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"R\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQuoteInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFeeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteReserve\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mtFeeRateModel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isOpenTWAP\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isOracleEnabled\",\"type\":\"bool\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payBaseAmount\",\"type\":\"uint256\"}],\"name\":\"querySellBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveQuoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"},{\"internalType\":\"enum PMMPricing.RState\",\"name\":\"newRState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newBaseTarget\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payQuoteAmount\",\"type\":\"uint256\"}],\"name\":\"querySellQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveBaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mtFee\",\"type\":\"uint256\"},{\"internalType\":\"enum PMMPricing.RState\",\"name\":\"newRState\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newQuoteTarget\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ratioSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"assetTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newLpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteReserve\",\"type\":\"uint256\"}],\"name\":\"reset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retrieve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sellBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveQuoteAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sellQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receiveBaseAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLpFeeRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteReserve\",\"type\":\"uint256\"}],\"name\":\"tuneParameters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteReserve\",\"type\":\"uint256\"}],\"name\":\"tunePrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "DPPOracle", "CompilerVersion": "v0.6.9+commit.3e3065ac", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8b136300ae10d91c02258be401c5dc272133c5824b072b883f318f31025a46d0"}