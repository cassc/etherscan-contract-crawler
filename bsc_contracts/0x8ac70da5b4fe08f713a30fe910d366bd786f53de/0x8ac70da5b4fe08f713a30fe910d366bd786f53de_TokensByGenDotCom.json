{"SourceCode": "// SPDX-License-Identifier: Unlicensed \r\n// Unlicensed is NOT Open Source!\r\n// Can not be used/forked without permission\r\n\r\n/*\r\n\r\nCreated by https://tokensbygen.com/\r\nToken Generator Tool by GenTokens\r\n\r\nCONTRACT FEATURES\r\n    \r\n    - Reflection Rewards to Holders\r\n    - BNB Marketing Wallet\r\n    - Auto Liquidity\r\n    - Adjust Buy and Sell Fees independently\r\n    - Anti-Whale - Max Wallet Limit\r\n    - Anti-Dump - Max Transaction Limit\r\n    - Auto Fee Processing Triggers\r\n    - No Fee on Wallet-to-Wallet Transfers\r\n    - Ability to Add Unlimited Liquidity Pairings\r\n    - Buyer Protection - Hard-Coded Fee Limit 20%\r\n    - Buyer Protection - Can Not Set Limit to 0 Tokens\r\n\r\n*/\r\n\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                 assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ncontract TokensByGenDotCom is Context, IERC20 { \r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    address public _owner;\r\n    address public Wallet_Liquidity;\r\n    address payable public Wallet_Marketing;\r\n\r\n    // Only used if the 1% transaction fee option is chosen \r\n    address payable public feeCollector = payable(0xde491C65E507d281B6a3688d11e8fC222eee0975);\r\n\r\n    string public _name;\r\n    string public _symbol;\r\n    uint256 public _decimals;\r\n    uint256 public _tTotal;\r\n\r\n    // Social links for this token\r\n    string public Token_Website;\r\n    string public Token_Telegram;\r\n\r\n    // Init limit uints\r\n    uint256 public max_Hold;\r\n    uint256 public max_Tran;\r\n    uint256 public swap_Max;\r\n    uint256 public swap_Min;\r\n\r\n    // Init Fees\r\n    uint256 public _fee_Buy_Liquidity;\r\n    uint256 public _fee_Buy_Marketing;\r\n    uint256 public _fee_Buy_Reflection;\r\n    uint256 public _fee_Buy_Contract;\r\n\r\n    uint256 public _fee_Sell_Liquidity;\r\n    uint256 public _fee_Sell_Marketing;\r\n    uint256 public _fee_Sell_Reflection;\r\n    uint256 public _fee_Sell_Contract;\r\n\r\n    uint256 public _SwapFeeTotal_Buy;\r\n    uint256 public _SwapFeeTotal_Sell;\r\n\r\n    // Track contract fee\r\n    uint256 private ContractFee;\r\n\r\n    // Initi Supply Tracking for RFI\r\n    uint256 private _rTotal;\r\n    uint256 private _tFeeTotal;\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n\r\n    // Set factory\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n    constructor (string memory _TokenSymbol, string memory _TokenName, address _OwnerWallet, address payable _MarketingWallet, uint256 _TotalSupply, uint256 _Decimals, string memory _Website, string memory _Telegram, uint256 _ContractFee) {\r\n\r\n   \r\n    // Set owner\r\n    _owner              = _OwnerWallet;\r\n\r\n    // Set basic token details\r\n    _name               = _TokenName;\r\n    _symbol             = _TokenSymbol;\r\n    _decimals           = _Decimals;\r\n    _tTotal             = _TotalSupply * 10**_decimals;\r\n    _rTotal             = (MAX - (MAX % _tTotal));\r\n    \r\n\r\n    // Wallet limits\r\n    max_Hold            = _tTotal; // Set limits after deploying\r\n    max_Tran            = _tTotal; // Set limits after deploying\r\n\r\n    // Contract sell limits when processing fees\r\n    swap_Min            = 1000;             // 1000 tokens\r\n    swap_Max            = _tTotal / 200;    // 0.5% of total supply\r\n\r\n    // Set Socials \r\n    Token_Website       = _Website;\r\n    Token_Telegram      = _Telegram;\r\n\r\n    // Set marketing and liquidity collection wallets to owner (can be updated later)\r\n    Wallet_Marketing    = _MarketingWallet;\r\n    Wallet_Liquidity    = _OwnerWallet;\r\n\r\n    // Set contract fee\r\n    ContractFee         = _ContractFee;\r\n\r\n    // Set other fees to defaults\r\n    _fee_Buy_Liquidity      = 0; // Set fees after deploying\r\n    _fee_Buy_Marketing      = 0; // Set fees after deploying\r\n    _fee_Buy_Reflection     = 0; // Set fees after deploying\r\n    _fee_Buy_Contract       = 0; // Set fees after deploying\r\n\r\n    _fee_Sell_Liquidity     = 0; // Set fees after deploying\r\n    _fee_Sell_Marketing     = 0; // Set fees after deploying\r\n    _fee_Sell_Reflection    = 0; // Set fees after deploying\r\n    _fee_Sell_Contract      = 0; // Set fees after deploying\r\n\r\n    // Calculate total fee\r\n    _SwapFeeTotal_Buy       = _fee_Buy_Liquidity + _fee_Buy_Marketing + _fee_Buy_Contract;\r\n    _SwapFeeTotal_Sell      = _fee_Sell_Liquidity + _fee_Sell_Marketing + _fee_Sell_Contract;\r\n\r\n    // Transfer token supply to owner wallet\r\n    _rOwned[_owner] = _rTotal;\r\n\r\n    // Set PancakeSwap Factory Address\r\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n\r\n    // Create initial liquidity pair with BNB on PancakeSwap factory\r\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n    uniswapV2Router = _uniswapV2Router;\r\n\r\n    // Wallet that are excluded from holding limits\r\n    _isLimitExempt[_owner] = true;\r\n    _isLimitExempt[address(this)] = true;\r\n    _isLimitExempt[Wallet_Burn] = true;\r\n    _isLimitExempt[uniswapV2Pair] = true;\r\n\r\n    // Wallets that are excluded from fees\r\n    _isExcludedFromFee[_owner] = true;\r\n    _isExcludedFromFee[address(this)] = true;\r\n    _isExcludedFromFee[Wallet_Burn] = true;\r\n\r\n    // Set the initial liquidity pair\r\n    _isPair[uniswapV2Pair] = true;    \r\n\r\n\r\n    // Exclude from Rewards\r\n    _isExcluded[Wallet_Burn] = true;\r\n    _isExcluded[uniswapV2Pair] = true;\r\n    _isExcluded[address(this)] = true;\r\n\r\n    // Push excluded wallets to array\r\n    _excluded.push(Wallet_Burn);\r\n    _excluded.push(uniswapV2Pair);\r\n    _excluded.push(address(this));\r\n\r\n    // Wallets granted access before trade is open\r\n    _preLaunchAccess[_owner] = true;\r\n\r\n    // Emit Supply Transfer to Owner\r\n    emit Transfer(address(0), _owner, _tTotal);\r\n\r\n    // Emit ownership transfer\r\n    emit OwnershipTransferred(address(0), _owner);\r\n\r\n\r\n    }\r\n\r\n    \r\n    // Events\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event updated_mapping_preLaunchAccess(address Wallet_Address, bool preLaunchAccess);\r\n    event updated_mapping_isLimitExempt(address Wallet_Address, bool LimitExempt);\r\n    event updated_mapping_isPair(address Wallet_Address, bool LiquidityPair);\r\n    event updated_mapping_isExcludedFromFee(address Wallet_Address, bool ExcludedFromFee);\r\n    event updated_ExcludeFromReward(address indexed WalletAddress);\r\n    event updated_IncludeInReward(address indexed WalletAddress);\r\n    event updated_Wallet_Marketing(address indexed oldWallet, address indexed newWallet);\r\n    event updated_Wallet_Liquidity(address indexed oldWallet, address indexed newWallet);\r\n    event updated_wallet_Limits(uint256 max_Tran, uint256 max_Hold);\r\n    event updated_Buy_fees(uint256 Marketing, uint256 Liquidity, uint256 Reflection, uint256 Contract_Development_Fee);\r\n    event updated_Sell_fees(uint256 Marketing, uint256 Liquidity, uint256 Reflection, uint256 Contract_Development_Fee);\r\n    event updated_noFeeOnTransfer(bool true_or_false);\r\n    event updated_swapTriggerCount(uint256 swapTrigger_Transaction_Count);\r\n    event updated_swapTrigger_Token_Limits(uint256 swap_Trigger_Min_Tokens, uint256 swap_Trigger_Max_Tokens);\r\n    event updated_SwapAndLiquify_Enabled(bool Swap_and_Liquify_Enabled);\r\n    event updated_trade_Open(bool TradeOpen);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\r\n    event set_Contract_Fee(uint256 Contract_Development_Buy_Fee, uint256 Contract_Development_Sell_Fee);\r\n\r\n\r\n    // Restrict function to contract owner only \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    // Address mappings\r\n    mapping (address => uint256) private _tOwned;                               // Tokens Owned\r\n    mapping (address => uint256) private _rOwned;                               // Reflected balance\r\n    mapping (address => mapping (address => uint256)) private _allowances;      // Allowance to spend another wallets tokens\r\n    mapping (address => bool) public _isExcludedFromFee;                        // Wallets that do not pay fees\r\n    mapping (address => bool) public _isExcluded;                               // Excluded from RFI rewards\r\n    mapping (address => bool) public _preLaunchAccess;                          // Wallets that have access before trade is open\r\n    mapping (address => bool) public _isLimitExempt;                            // Wallets that are excluded from HOLD and TRANSFER limits\r\n    mapping (address => bool) public _isPair;                                   // Address is liquidity pair\r\n    address[] private _excluded;                                                // Array of wallets excluded from rewards\r\n\r\n    \r\n\r\n    // Burn (dead) address\r\n    address public constant Wallet_Burn = 0x000000000000000000000000000000000000dEaD; \r\n\r\n\r\n    // Swap triggers\r\n    uint256 public swapTrigger = 11;    // After 10 transactions with a fee swap will be triggered \r\n    uint256 public swapCounter = 1;     // Start at 1 not zero to save gas\r\n\r\n    // Wallet to wallet transfers without fees\r\n    bool public noFeeToTransfer = true;\r\n    \r\n\r\n    // SwapAndLiquify - Automatically processing fees and adding liquidity                                   \r\n    bool public inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = false; // Must be set to true post deploy!\r\n\r\n\r\n    // Launch settings\r\n    bool public TradeOpen = false;\r\n\r\n\r\n    // Renounce ownership of the contract \r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n\r\n\r\n    // Transfer the contract to to a new owner - Overide used to update wallet mapping status\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\r\n        // Remove old owner status \r\n        _isLimitExempt[owner()] = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _preLaunchAccess[owner()] = false;\r\n\r\n\r\n        // Emit ownership transfer\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        // Transfer owner\r\n        _owner = newOwner;\r\n\r\n        // Add new Owner status\r\n        _isLimitExempt[owner()] = true;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _preLaunchAccess[owner()] = true;\r\n\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    ERC20/BEP20 Compliance and Standard Functions\r\n\r\n    */\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"Decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"Owner is zero address!\");\r\n        require(spender != address(0), \"Spender is zero address!\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n   \r\n    function tokenFromReflection(uint256 _rAmount) internal view returns(uint256) {\r\n        require(_rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return _rAmount / currentRate;\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;      \r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n            rSupply = rSupply - _rOwned[_excluded[i]];\r\n            tSupply = tSupply - _tOwned[_excluded[i]];\r\n        }\r\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"Allowance exceeded\"));\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    Wallet Mappings\r\n\r\n    */\r\n\r\n\r\n    // Grants access when trade is closed - Default false (true for contract owner)\r\n    function Mapping_preLaunchAccess(address Wallet_Address, bool true_or_false) external onlyOwner {    \r\n        _preLaunchAccess[Wallet_Address] = true_or_false;\r\n        emit updated_mapping_preLaunchAccess(Wallet_Address, true_or_false);\r\n    }\r\n\r\n    // Excludes wallet from transaction and holding limits - Default false\r\n    function Mapping_LimitExempt(address Wallet_Address, bool true_or_false) external onlyOwner {  \r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n        emit updated_mapping_isLimitExempt(Wallet_Address, true_or_false);\r\n    }\r\n \r\n    // Identifies wallet as a liquidity pair - Default false\r\n    function Mapping_isPair(address Wallet_Address, bool true_or_false) external onlyOwner {\r\n        _isPair[Wallet_Address] = true_or_false;\r\n        emit updated_mapping_isPair(Wallet_Address, true_or_false);\r\n    }\r\n\r\n    // Excludes wallet from fees - Default false\r\n    function Mapping_excludeFromFee(address Wallet_Address, bool true_or_false) external onlyOwner {\r\n        _isExcludedFromFee[Wallet_Address] = true_or_false;\r\n        emit updated_mapping_isExcludedFromFee(Wallet_Address, true_or_false);\r\n\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n    The following functions are used to exclude or include a wallet in the reflection rewards.\r\n    By default, all wallets are included. \r\n\r\n    Wallets that are excluded:\r\n\r\n            The Burn address\r\n            The Liquidity Pair\r\n            The Contract Address\r\n\r\n    DoS 'OUT OF GAS' Error Warning\r\n\r\n    A reflections contract needs to loop through all excluded wallets to correctly process several functions. \r\n    This loop can break the contract if it runs out of gas before completion. \r\n    to prevent this, keep the number of wallet that are excluded from rewards to an absolute minimum. \r\n    In addition to the default excluded wallets, you will need to exclude the address of any locked tokens.\r\n\r\n    */\r\n\r\n\r\n    // Exclude wallet from RFI - LOOP RISK OF OUT OF GAS! LIMIT TO ESSENTIAL WALLETS! (Contract, Pair and Burn ONLY!)\r\n    function reflections_exclude_Wallet(address account) external onlyOwner {\r\n        require(!_isExcluded[account], \"Account already excluded\");\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n        emit updated_ExcludeFromReward(account);\r\n    }\r\n\r\n    // Include wallet in RFI\r\n    function reflections_include_Wallet(address account) external onlyOwner {\r\n        require(_isExcluded[account], \"Account already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n        emit updated_IncludeInReward(account);\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    Update Wallets\r\n\r\n    */\r\n\r\n\r\n    // Update marketing wallet\r\n    function Wallet_Update_Marketing(address payable wallet) external onlyOwner {\r\n\r\n        require(wallet != address(0), \"Can not be zero address\");\r\n        emit updated_Wallet_Marketing(Wallet_Marketing,wallet);\r\n        Wallet_Marketing = wallet;\r\n    }\r\n\r\n    // Update liquidity collection wallet\r\n    function Wallet_Update_Liquidity(address wallet) external onlyOwner {\r\n\r\n        // To send the auto liquidity tokens directly to burn update to 0x000000000000000000000000000000000000dEaD\r\n        emit updated_Wallet_Liquidity(Wallet_Liquidity,wallet);\r\n        Wallet_Liquidity = wallet;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    Wallet Limits\r\n\r\n    */\r\n\r\n    // Wallet Holding and Transaction Limits (Enter token amount, excluding decimals)\r\n    function Set_Limits_For_Wallets(\r\n\r\n        uint256 Max_Tokens_Per_Transaction,\r\n        uint256 Max_Total_Tokens_Per_Wallet \r\n\r\n        ) external onlyOwner {\r\n\r\n        // Buyer protection - Limits can not be set to zero \r\n        require(Max_Tokens_Per_Transaction > 0, \"Must be greater than 0\");\r\n        require(Max_Total_Tokens_Per_Wallet > 0, \"Must be greater than 0\");\r\n        \r\n        max_Tran = Max_Tokens_Per_Transaction * 10**_decimals;\r\n        max_Hold = Max_Total_Tokens_Per_Wallet * 10**_decimals;\r\n\r\n        emit updated_wallet_Limits(max_Tran, max_Hold);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    FEES  \r\n\r\n    If contract development fee was set to 1% of transactions, this is included in the max fee limit of 20\r\n\r\n    */\r\n\r\n\r\n    // Set Buy Fees\r\n    function Set_Fees_on_Buy(uint256 Marketing_on_BUY, uint256 Liquidity_on_BUY, uint256 Reflection_on_BUY) external onlyOwner {\r\n\r\n        _fee_Buy_Contract = ContractFee;\r\n\r\n        // Buyer protection - max fee can not be set over 20% (including possible 1% contract fee if chosen)\r\n        require(Marketing_on_BUY + Liquidity_on_BUY + Reflection_on_BUY + _fee_Buy_Contract <= 20, \"Fees too high\"); \r\n\r\n        // Update fees\r\n        _fee_Buy_Marketing  = Marketing_on_BUY;\r\n        _fee_Buy_Liquidity  = Liquidity_on_BUY;\r\n        _fee_Buy_Reflection = Reflection_on_BUY;\r\n\r\n        // Fees that will need to be processed during swap and liquify\r\n        _SwapFeeTotal_Buy   = _fee_Buy_Marketing + _fee_Buy_Liquidity + _fee_Buy_Contract;\r\n\r\n        emit updated_Buy_fees(_fee_Buy_Marketing, _fee_Buy_Liquidity, _fee_Buy_Reflection, _fee_Buy_Contract);\r\n    }\r\n\r\n    // Set Sell Fees\r\n    function Set_Fees_on_Sell(uint256 Marketing_on_SELL, uint256 Liquidity_on_SELL, uint256 Reflection_on_SELL) external onlyOwner {\r\n\r\n        _fee_Sell_Contract = ContractFee;\r\n\r\n        // Buyer protection - max fee can not be set over 20% (including possible 1% contract fee if chosen)\r\n        require(Marketing_on_SELL + Liquidity_on_SELL + Reflection_on_SELL + _fee_Sell_Contract <= 20, \"Fees too high\"); \r\n\r\n        // Update fees\r\n        _fee_Sell_Marketing  = Marketing_on_SELL;\r\n        _fee_Sell_Liquidity  = Liquidity_on_SELL;\r\n        _fee_Sell_Reflection = Reflection_on_SELL;\r\n\r\n        // Fees that will need to be processed during swap and liquify\r\n        _SwapFeeTotal_Sell   = _fee_Sell_Marketing + _fee_Sell_Liquidity + _fee_Sell_Contract;\r\n\r\n        emit updated_Sell_fees(_fee_Sell_Marketing, _fee_Sell_Liquidity, _fee_Sell_Reflection, _fee_Sell_Contract);\r\n    }\r\n\r\n    // When sending tokens to another wallet (not buying or selling) if noFeeToTransfer is true there will be no fee (default = true)\r\n    function Set_Transfers_Without_Fees(bool true_or_false) external onlyOwner {\r\n        noFeeToTransfer = true_or_false;\r\n        emit updated_noFeeOnTransfer(true_or_false);\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    Swap and Liquify Settings (Processing Transaction Fees)\r\n\r\n    */\r\n\r\n\r\n\r\n    // Set the number of transactions before swap is triggered (default 10)\r\n    function SwapTrigger_Transaction_Count(uint256 number_Of_Transactions) external onlyOwner {\r\n\r\n        // Add 1 to total as counter is reset to 1, not 0, to save gas\r\n        swapTrigger = number_Of_Transactions + 1;\r\n        emit updated_swapTriggerCount(swapTrigger);\r\n    }\r\n\r\n    // Set the min and max limits for fee processing trigger\r\n    function SwapTrigger_Token_Limits(uint256 _swap_Min, uint256 _swap_Max) external onlyOwner {\r\n        swap_Min = _swap_Min;\r\n        swap_Max = _swap_Max;\r\n        emit updated_swapTrigger_Token_Limits(swap_Min, swap_Max);\r\n    }\r\n\r\n    // Default is True = Contract will process fees into Marketing and Liquidity automatically\r\n    function Swap_Enabled(bool true_or_false) external onlyOwner {\r\n        swapAndLiquifyEnabled = true_or_false;\r\n        emit updated_SwapAndLiquify_Enabled(true_or_false);\r\n    }\r\n\r\n    // Manually process fees - emit is triggered within swapAndLiquify function so not needed here\r\n    function Swap_Now (uint256 percent_Of_Tokens_To_Process) external onlyOwner {\r\n        require(!inSwapAndLiquify, \"Already in swap\"); \r\n        if (percent_Of_Tokens_To_Process > 100){percent_Of_Tokens_To_Process == 100;}\r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract * percent_Of_Tokens_To_Process / 100;\r\n        swapAndLiquify(sendTokens);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Open trade - one way switch to protect buyers - trade can not be paused once opened\r\n    function OpenTrade() external onlyOwner {\r\n        TradeOpen = true;\r\n        swapAndLiquifyEnabled = true;\r\n        emit updated_trade_Open(TradeOpen);\r\n        emit updated_SwapAndLiquify_Enabled(swapAndLiquifyEnabled);\r\n\r\n        // Set the contract fee if required\r\n        _fee_Buy_Contract   = ContractFee;\r\n        _fee_Sell_Contract  = ContractFee;\r\n        _SwapFeeTotal_Buy   = _fee_Buy_Liquidity + _fee_Buy_Marketing + _fee_Buy_Contract;\r\n        _SwapFeeTotal_Sell  = _fee_Sell_Liquidity + _fee_Sell_Marketing + _fee_Sell_Contract;\r\n\r\n        emit set_Contract_Fee(_fee_Buy_Contract, _fee_Sell_Contract);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Main transfer checks and settings \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n\r\n\r\n        // Allows owner to add liquidity safely, eliminating the risk of someone maliciously setting the price \r\n        if (!TradeOpen){\r\n        require(_preLaunchAccess[from] || _preLaunchAccess[to], \"Trade is not open\");\r\n        }\r\n\r\n\r\n        // Wallet Limit\r\n        if (!_isLimitExempt[to] && from != owner())\r\n            {\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= max_Hold, \"Over wallet max\");\r\n            }\r\n\r\n\r\n        /*\r\n        \r\n        PooCoin Trade button Warning\r\n\r\n        PooCoin will do a simulation sell of approximately 0.01 BNB. If they can not buy and sell this amount they will disable your trade button.\r\n        If you only add a small amount of BNB to your initial liquidity (1 BNB or less) and your max transaction is limited to 1% of total supply then \r\n        this test will fail and you will not get a trade button on PooCoin. Be aware of this when doing tests on main net with low liquidity! \r\n\r\n        */\r\n\r\n\r\n        // Transaction limit - To send over the transaction limit then the sender AND the recipient must be limit exempt (or increase transaction limit)\r\n        if (!_isLimitExempt[to] || !_isLimitExempt[from])\r\n            {\r\n            require(amount <= max_Tran, \"Over transaction limit\");\r\n            }\r\n\r\n\r\n        // Compliance and safety checks\r\n        require(from != address(0) && to != address(0), \"Can not be 0 address\");\r\n        require(amount > 0, \"Transfer must be greater than 0\");\r\n\r\n\r\n\r\n        // Check number of transaction to trigger fee processing - can only trigger on sells\r\n        if( _isPair[to] &&\r\n            !inSwapAndLiquify &&\r\n            swapAndLiquifyEnabled\r\n            )\r\n            {\r\n\r\n            // Check that enough transaction have passed since last swap\r\n            if(swapCounter >= swapTrigger){\r\n\r\n            // Check number of tokens on contract\r\n            uint256 contractTokens = balanceOf(address(this));\r\n\r\n            // Only trigger fee processing if over min swap limit\r\n            if (contractTokens >= swap_Min){\r\n\r\n                // Limit number of tokens that can be swapped \r\n                if (contractTokens <= swap_Max){\r\n                    swapAndLiquify (contractTokens);\r\n                    } else {\r\n                    swapAndLiquify (swap_Max);\r\n                    }\r\n            }\r\n            }  \r\n            }\r\n\r\n\r\n        // Only charge a fee on buys and sells, no fee for wallet transfers\r\n        bool takeFee = true;\r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (noFeeToTransfer && !_isPair[to] && !_isPair[from])){\r\n            takeFee = false;\r\n        } \r\n\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Process fees\r\n    function swapAndLiquify(uint256 Tokens) private {\r\n\r\n        /*\r\n        \r\n        Fees are processed as an average over all buys and sells         \r\n\r\n        */\r\n\r\n        // Lock swapAndLiquify function\r\n        inSwapAndLiquify        = true;  \r\n\r\n        uint256 _FeesTotal      = (_SwapFeeTotal_Buy + _SwapFeeTotal_Sell);\r\n        uint256 LP_Tokens       = Tokens * (_fee_Buy_Liquidity + _fee_Sell_Liquidity) / _FeesTotal / 2;\r\n        uint256 Swap_Tokens     = Tokens - LP_Tokens;\r\n\r\n        // Swap tokens for BNB\r\n        uint256 contract_BNB    = address(this).balance;\r\n        swapTokensForBNB(Swap_Tokens);\r\n        uint256 returned_BNB    = address(this).balance - contract_BNB;\r\n\r\n        // Double fees instead of halving LP fee to prevent rounding errors is LP fee is 1%\r\n        uint256 fee_Split = _FeesTotal * 2 - (_fee_Buy_Liquidity + _fee_Sell_Liquidity);\r\n\r\n        // Calculate the BNB values for each fee (excluding marketing)\r\n        uint256 BNB_Liquidity   = returned_BNB * (_fee_Buy_Liquidity     + _fee_Sell_Liquidity)       / fee_Split;\r\n        uint256 BNB_Contract    = returned_BNB * (_fee_Buy_Contract      + _fee_Sell_Contract)    * 2 / fee_Split;\r\n\r\n        // Add liquidity \r\n        if (LP_Tokens != 0){\r\n            addLiquidity(LP_Tokens, BNB_Liquidity);\r\n            emit SwapAndLiquify(LP_Tokens, BNB_Liquidity, LP_Tokens);\r\n        }\r\n\r\n        // Take developer fee\r\n        if(BNB_Contract > 0){\r\n        feeCollector.transfer(BNB_Contract); \r\n        }\r\n        \r\n        // Send remaining BNB to marketing wallet\r\n        contract_BNB = address(this).balance;\r\n        if(contract_BNB > 0){\r\n        Wallet_Marketing.transfer(contract_BNB); \r\n        }\r\n\r\n        // Reset transaction counter (reset to 1 not 0 to save gas)\r\n        swapCounter = 1;\r\n\r\n        // Unlock swapAndLiquify function\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n\r\n\r\n    // Swap tokens for BNB\r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n\r\n    // Add liquidity and send Cake LP tokens to liquidity collection wallet\r\n    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.addLiquidityETH{value: BNBAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, \r\n            0,\r\n            Wallet_Liquidity, \r\n            block.timestamp\r\n        );\r\n    } \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    TAKE FEES\r\n\r\n    */\r\n\r\n\r\n    // Take non-token fees and add to contract\r\n    function _takeSwap(uint256 _tSwapFeeTotal, uint256 _rSwapFeeTotal) private {\r\n\r\n        _rOwned[address(this)] = _rOwned[address(this)] + _rSwapFeeTotal;\r\n        if(_isExcluded[address(this)])\r\n        _tOwned[address(this)] = _tOwned[address(this)] + _tSwapFeeTotal;\r\n\r\n    }\r\n\r\n    // Adjust RFI for reflection balance\r\n    function _takeReflect(uint256 _tReflect, uint256 _rReflect) private {\r\n\r\n        _rTotal = _rTotal - _rReflect;\r\n        _tFeeTotal = _tFeeTotal + _tReflect;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    TRANSFER TOKENS AND CALCULATE FEES\r\n\r\n    */\r\n\r\n    // Init uints for fee calculations\r\n\r\n    uint256 private tAmount;\r\n    uint256 private rAmount;\r\n    uint256 private tReflect;\r\n    uint256 private rReflect;\r\n    uint256 private tSwapFeeTotal;\r\n    uint256 private rSwapFeeTotal;\r\n    uint256 private tTransferAmount;\r\n    uint256 private rTransferAmount;\r\n\r\n    \r\n\r\n    // Transfer Tokens and Calculate Fees\r\n    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\r\n\r\n        // Calculate the transfer fees\r\n        tAmount = amount;\r\n\r\n        if (!takeFee){\r\n\r\n        tReflect        = 0;    // Reflection Fee\r\n        tSwapFeeTotal   = 0;    // Marketing, Liquidity and Contract Fee\r\n\r\n        } else {\r\n\r\n        // Increase the transaction counter - only increase if required to save gas on buys when already in trigger zone\r\n        if (swapCounter < swapTrigger){\r\n            swapCounter++;\r\n            }\r\n\r\n        if(_isPair[sender]){\r\n\r\n            // Buy fees\r\n            tReflect        = tAmount * _fee_Buy_Reflection / 100;\r\n            tSwapFeeTotal   = tAmount * _SwapFeeTotal_Buy / 100;\r\n\r\n        } else {\r\n\r\n            // Sell fees\r\n            tReflect        = tAmount * _fee_Sell_Reflection / 100;\r\n            tSwapFeeTotal   = tAmount * _SwapFeeTotal_Sell / 100;\r\n\r\n        }\r\n        }\r\n\r\n        // Calculate reflected fees for RFI\r\n        uint256 RFI     = _getRate(); \r\n\r\n        rAmount         = tAmount * RFI;\r\n        rReflect        = tReflect * RFI;\r\n        rSwapFeeTotal   = tSwapFeeTotal * RFI;\r\n        tTransferAmount = tAmount - (tReflect + tSwapFeeTotal);\r\n        rTransferAmount = rAmount - (rReflect + rSwapFeeTotal);\r\n        \r\n        // Swap tokens based on RFI status of sender and recipient\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n\r\n        _tOwned[sender] = _tOwned[sender] - tAmount;\r\n        _rOwned[sender] = _rOwned[sender] - rAmount;\r\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n\r\n        _rOwned[sender] = _rOwned[sender] - rAmount;\r\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\r\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n\r\n        _rOwned[sender]     = _rOwned[sender] - rAmount;\r\n        _rOwned[recipient]  = _rOwned[recipient] + rTransferAmount;\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n\r\n        _tOwned[sender] = _tOwned[sender] - tAmount;\r\n        _rOwned[sender] = _rOwned[sender] - rAmount;\r\n        _tOwned[recipient] = _tOwned[recipient] + tTransferAmount;\r\n        _rOwned[recipient] = _rOwned[recipient] + rTransferAmount;\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else {\r\n\r\n        _rOwned[sender]     = _rOwned[sender] - rAmount;\r\n        _rOwned[recipient]  = _rOwned[recipient] + rTransferAmount;\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        }\r\n\r\n\r\n        // Take reflections\r\n        if(tReflect != 0){_takeReflect(tReflect, rReflect);}\r\n\r\n\r\n        // Take fees that require processing during swap and liquify\r\n        if(tSwapFeeTotal != 0){_takeSwap(tSwapFeeTotal, rSwapFeeTotal);}\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Remove random tokens from the contract - the emit happens during _transfer, therefore it is not required within this function\r\n    function Remove_Random_Tokens(address random_Token_Address, uint256 percent_of_Tokens) external onlyOwner returns(bool _sent){\r\n\r\n            // Can not purge the native token!\r\n            require (random_Token_Address != address(this), \"Can not remove native token, must be processed via SwapAndLiquify\");\r\n\r\n            // Get balance of random tokens and send to caller wallet\r\n            uint256 totalRandom = IERC20(random_Token_Address).balanceOf(address(this));\r\n            uint256 removeRandom = totalRandom * percent_of_Tokens / 100;\r\n            _sent = IERC20(random_Token_Address).transfer(msg.sender, removeRandom);\r\n\r\n    }\r\n\r\n\r\n\r\n    // This function is required so that the contract can receive BNB during fee processing\r\n    receive() external payable {}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n\r\nDISCLAIMER\r\n\r\nAnybody can use our tool to create a token. We can not guarantee that tokens made using our tool are genuine.\r\nPlease do your own research into the team and the project before investing.\r\n\r\nWe are not responsible for the actions of those using our tool.\r\n\r\n*/", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_TokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_TokenName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_OwnerWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_MarketingWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_TotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Decimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_Website\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_Telegram\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_ContractFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Buy_Fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Sell_Fee\",\"type\":\"uint256\"}],\"name\":\"set_Contract_Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Reflection\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Fee\",\"type\":\"uint256\"}],\"name\":\"updated_Buy_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"WalletAddress\",\"type\":\"address\"}],\"name\":\"updated_ExcludeFromReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"WalletAddress\",\"type\":\"address\"}],\"name\":\"updated_IncludeInReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Reflection\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Fee\",\"type\":\"uint256\"}],\"name\":\"updated_Sell_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Swap_and_Liquify_Enabled\",\"type\":\"bool\"}],\"name\":\"updated_SwapAndLiquify_Enabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updated_Wallet_Liquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updated_Wallet_Marketing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ExcludedFromFee\",\"type\":\"bool\"}],\"name\":\"updated_mapping_isExcludedFromFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"LimitExempt\",\"type\":\"bool\"}],\"name\":\"updated_mapping_isLimitExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"LiquidityPair\",\"type\":\"bool\"}],\"name\":\"updated_mapping_isPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"preLaunchAccess\",\"type\":\"bool\"}],\"name\":\"updated_mapping_preLaunchAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"updated_noFeeOnTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapTrigger_Transaction_Count\",\"type\":\"uint256\"}],\"name\":\"updated_swapTriggerCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swap_Trigger_Min_Tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swap_Trigger_Max_Tokens\",\"type\":\"uint256\"}],\"name\":\"updated_swapTrigger_Token_Limits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"TradeOpen\",\"type\":\"bool\"}],\"name\":\"updated_trade_Open\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_Tran\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_Hold\",\"type\":\"uint256\"}],\"name\":\"updated_wallet_Limits\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Mapping_LimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Mapping_excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Mapping_isPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Mapping_preLaunchAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OpenTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent_of_Tokens\",\"type\":\"uint256\"}],\"name\":\"Remove_Random_Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Marketing_on_BUY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity_on_BUY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_on_BUY\",\"type\":\"uint256\"}],\"name\":\"Set_Fees_on_Buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Marketing_on_SELL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity_on_SELL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_on_SELL\",\"type\":\"uint256\"}],\"name\":\"Set_Fees_on_Sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Max_Tokens_Per_Transaction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Max_Total_Tokens_Per_Wallet\",\"type\":\"uint256\"}],\"name\":\"Set_Limits_For_Wallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Set_Transfers_Without_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swap_Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swap_Max\",\"type\":\"uint256\"}],\"name\":\"SwapTrigger_Token_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number_Of_Transactions\",\"type\":\"uint256\"}],\"name\":\"SwapTrigger_Transaction_Count\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Swap_Enabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent_Of_Tokens_To_Process\",\"type\":\"uint256\"}],\"name\":\"Swap_Now\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token_Telegram\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token_Website\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TradeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Burn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Liquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Marketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Wallet_Update_Liquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"Wallet_Update_Marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_SwapFeeTotal_Buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_SwapFeeTotal_Sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Buy_Contract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Buy_Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Buy_Marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Buy_Reflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Sell_Contract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Sell_Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Sell_Marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_Sell_Reflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_preLaunchAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_Hold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_Tran\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noFeeToTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"reflections_exclude_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"reflections_include_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTrigger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_Max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_Min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TokensByGenDotCom", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000d05895edf847e1712721cc9e0427aa26289a6bc5000000000000000000000000d05895edf847e1712721cc9e0427aa26289a6bc500000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000444454d4f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000444454d4f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001868747470733a2f2f746f6b656e73627967656e2e636f6d2f0000000000000000000000000000000000000000000000000000000000000000000000000000001868747470733a2f2f742e6d652f746f6b656e73427947454e0000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c043c33c4bd39d45e207de4c91231eea6c0eeb9bc06435f3c5c73272acce424a"}