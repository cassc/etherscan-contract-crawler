{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CUNetwork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\ncontract ERC20 is Context, IERC20 {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overloaded;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\\n/**\\n * @title StakingContract\\n * @dev This contract represents a staking system with different plans.\\n */\\ncontract CUnetwork is ERC20 {\\n    IERC20 public USDT;\\n\\n    // Constants defining referral limits and tier values\\n     address public admin1_address;\\n    address public admin2_address;\\n    address public admin3_address; // New admin3 address\\n    uint public UsdtPool;\\n    uint public ReferralPool;\\n    uint256[] public BuyPercent = [500, 300, 200, 100, 100, 100, 50, 50, 50, 50];\\n    uint256[] public Salepercent = [50, 50, 50, 50, 50, 50, 50, 50, 50, 50];\\n    uint8 public BuyandSellDivisor = 100;\\n    uint8 public amountForReffererForBuying = 15;\\n    uint8 public amountForReffererForSeller = 5;\\n    uint public TokenPrice = 10000000000000 wei;\\n    uint256 public maxPurchaseAmount = 1000 * 10**18; // $1,000 in USDT's smallest unit\\n    uint256 public minPurchaseAmount = 10 * 10**18;   // $10 in USDT's smallest unit\\n    uint8 public constant MAX_LEVELS = 10;\\n    uint public constant ACTIVATION_AMOUNT = 10 * 10**18; // 10 USDT in smallest unit\\n    address public Owner;\\n\\n\\n    // Structs\\n    struct BuyDetail {\\n        address parent;\\n        uint amount;\\n        uint currentRate;\\n        uint256 dateTime;\\n        address[] Refferrers;\\n        uint[] amounts;\\n    }\\n\\n    struct SellDetail {\\n        uint amount;\\n        uint currentRate;\\n        uint256 dateTime;\\n        address[] Refferrers;\\n        uint[] amounts;\\n    }\\n\\n    struct WithdrawalDetail {\\n        uint amount;\\n        uint currentRate;\\n        uint256 dateTime;\\n        address[] Refferrers;\\n        uint[] amounts;\\n    }\\n\\n    struct User_children {\\n        address[] child;\\n    }\\n    struct UserCount{\\n        uint buyCount;\\n        uint withdrawCount;\\n        uint SellCount;\\n    }\\n\\n    // Mappings\\n    mapping(address => uint8) public userLevels;\\n    mapping(address => bool) public accountActivated;\\n    mapping(address => User_children) internal referrerToDirectChildren;\\n    mapping(address => User_children) internal referrerToIndirectChildren;\\n    mapping(address => address) public parent;\\n    mapping(address => uint) public RewardAmount;\\n    mapping(address => uint) public totalInvested;\\n    mapping(address => uint) public totalWithdrawn;\\n    mapping(address => uint) public totalAmountSold;\\n    mapping(address => BuyDetail[]) public userBuys;\\n    mapping(address => SellDetail[]) public userSells;\\n    mapping(address => WithdrawalDetail[]) public userWithdrawals;\\n    mapping(address => UserCount) public UserCounts;\\n\\n\\n    modifier onlyOwner(){\\n        require(msg.sender == Owner,\\\"The sender needs to be the owner\\\");\\n        _;\\n    }\\n\\n\\n    // Events\\n    event TokenSold(address indexed user, uint256 tokenAmount, uint256 usdtAmount);\\n\\n    // Constructor\\n    constructor(address _usdt) ERC20(\\\"CUN\\\", \\\"CUN\\\")  {\\n        USDT = IERC20(_usdt);\\n        Owner = msg.sender;\\n        userLevels[msg.sender] = MAX_LEVELS;\\n        accountActivated[msg.sender] = true;\\n    }\\n\\n\\n\\n  function BuyTokens(uint amountInUSDT, address _referrer) external {\\n    // Validate input parameters\\n    require(amountInUSDT > 0, \\\"The amount cannot be less than 0\\\");\\n    require(_referrer != address(0), \\\"The address cannot be equal to the zero address\\\");\\n    require(USDT.balanceOf(msg.sender) >= amountInUSDT, \\\"Insufficient USDT balance\\\");\\n    require(USDT.allowance(msg.sender, address(this)) >= amountInUSDT, \\\"Insufficient allowance\\\");\\n    if (_referrer != Owner) {\\n        require(totalInvested[_referrer] > 0, \\\"The referrer should have some investment\\\");\\n    }\\n\\n    // Check purchase limits\\n    require(amountInUSDT <= maxPurchaseAmount, \\\"Purchase exceeds maximum limit\\\");\\n    require(amountInUSDT % minPurchaseAmount == 0, \\\"Amount must be a multiple of $10\\\");\\n    // Check and set referrer\\n    if (parent[msg.sender] != address(0)) {\\n        require(parent[msg.sender] == _referrer, \\\"Incorrect referrer\\\");\\n    } else {\\n        parent[msg.sender] = _referrer;\\n    }\\n    // Transfer USDT from user to contract\\n    require(USDT.transferFrom(msg.sender, address(this), amountInUSDT), \\\"Transfer failed\\\");\\n\\n\\n\\n    userBuys[msg.sender].push(BuyDetail({\\n        parent: _referrer,\\n        amount: amountInUSDT,\\n        currentRate: TokenPrice,\\n        dateTime: block.timestamp,\\n        Refferrers: new address[](0), // Initialize with empty array\\n        amounts: new uint[](0)       // Initialize with empty array\\n    }));\\n     BuyDetail storage buy = userBuys[msg.sender][userBuys[msg.sender].length-1];\\n    if(UserCounts[msg.sender].buyCount == 0 )\\n    {\\n        setDirectAndIndirectUsers(msg.sender,_referrer);\\n    }\\n    \\n    // Unlock user levels\\n    if (msg.sender != Owner && msg.sender != admin1_address && msg.sender != admin2_address && msg.sender != admin3_address) {\\n        uint amount=amountInUSDT;\\n        if (!accountActivated[msg.sender]) {\\n                // Account activation\\n                if (amount >= ACTIVATION_AMOUNT) {\\n                    accountActivated[msg.sender] = true;\\n                    amount -= ACTIVATION_AMOUNT;\\n                } \\n            }\\n\\n        uint8 levelsToUnlock = uint8(amount / (10 * (10**18)));\\n        userLevels[msg.sender] = (userLevels[msg.sender] + levelsToUnlock > MAX_LEVELS) ? MAX_LEVELS : (userLevels[msg.sender] + levelsToUnlock);\\n\\n        // Update referrer's levels\\n        if (_referrer != address(0) && _referrer != msg.sender &&msg.sender != Owner && msg.sender != admin1_address && msg.sender != admin2_address ) {\\n            uint8 additionalLevelsForReferrer = levelsToUnlock;\\n            if (userLevels[_referrer] + additionalLevelsForReferrer > MAX_LEVELS) {\\n                additionalLevelsForReferrer = MAX_LEVELS - userLevels[_referrer];\\n            }\\n            userLevels[_referrer] += additionalLevelsForReferrer;\\n        }\\n    }\\n\\n    // Calculate and update pool amounts\\n    uint LpPoolAmount = (amountInUSDT * 85) / 100;\\n    UsdtPool += LpPoolAmount;\\n    // Distribute rewards and admin fees\\n    distributeRewardsAndFees(amountInUSDT,buy  );\\n   \\n\\n    // Mint tokens\\n    mintTokens(amountInUSDT);\\n\\n    // Update invested amount\\n    totalInvested[msg.sender] += amountInUSDT;\\n    updateTokenPrice();\\n    UserCounts[msg.sender].buyCount++;\\n\\n}\\nfunction distributeRewardsAndFees(uint amountInUSDT,BuyDetail storage _buy) internal {\\n    address new_referrel = msg.sender;\\n    \\n\\n    for (uint256 i = 0; i < 10; i++) {\\n        if (new_referrel == Owner) {\\n            uint RemainingamountDistributed = (BuyPercent[i] * amountInUSDT) / 10000;\\n           ReferralPool+= RemainingamountDistributed;\\n        } else {\\n            address parent_addr = parent[new_referrel];\\n            uint amountDistributed = (BuyPercent[i] * amountInUSDT) / 10000;\\n            if(userLevels[parent_addr] >= i+1)\\n            { \\n                RewardAmount[parent_addr] += amountDistributed;\\n                _buy.Refferrers.push(parent_addr);\\n                _buy.amounts.push(amountDistributed);\\n            }\\n            ReferralPool +=amountDistributed;\\n            new_referrel = parent_addr;\\n        }\\n    }\\n}\\nfunction mintTokens(uint amountInUSDT) internal {\\n   uint tokenPerUSDT = 1e18 / TokenPrice;\\n    uint256 amountForTokenUserConversion = (amountInUSDT * 50) / 100;\\n    uint256 tokensToMintForUser = amountForTokenUserConversion * tokenPerUSDT;\\n    uint amountForTokenAdmin1Conversion = (amountInUSDT * 4) / 100;\\nuint amountForTokenAdmin2Conversion = (amountInUSDT * 4) / 100;\\nuint amountForTokenAdmin3Conversion = (amountInUSDT * 2) / 100;\\n    uint256 tokensToMintForAdmin1 = amountForTokenAdmin1Conversion * tokenPerUSDT;\\n    uint256 tokensToMintForAdmin2 = amountForTokenAdmin2Conversion * tokenPerUSDT;\\n    uint256 tokensToMintForAdmin3 = amountForTokenAdmin3Conversion * tokenPerUSDT;\\n\\n    _mint(msg.sender, tokensToMintForUser);\\n   _mint(admin1_address, tokensToMintForAdmin1); // 4%\\n     _mint(admin2_address, tokensToMintForAdmin2); // 4%\\n     _mint(admin3_address, tokensToMintForAdmin3); // 2%\\n\\n   \\n}\\n\\n\\nfunction withdraw(uint256 rewardAmount) external {\\n    require(rewardAmount > 0, \\\"The reward amount should be greater than 0\\\");\\n    require(RewardAmount[msg.sender] >= rewardAmount, \\\"Insufficient reward amount\\\");\\n    require(ReferralPool >= rewardAmount,\\\"Not enough tokens in refferel pool\\\");\\n    if (msg.sender != admin1_address && msg.sender != admin2_address && msg.sender != admin3_address) {\\n        uint256 withdrawLimit = 5 * totalInvested[msg.sender] - totalWithdrawn[msg.sender];\\n        require(rewardAmount <= withdrawLimit, \\\"Withdrawal exceeds limit\\\");\\n    }\\n     userWithdrawals[msg.sender].push(WithdrawalDetail({\\n        amount: rewardAmount,\\n        currentRate: TokenPrice,\\n        dateTime: block.timestamp,\\n        Refferrers: new address[](0), // Initialize with empty array\\n        amounts: new uint[](0)       // Initialize with empty array\\n    }));\\n\\n     WithdrawalDetail storage withdrawal = userWithdrawals[msg.sender][userWithdrawals[msg.sender].length-1];\\n    // userWithdrawals[msg.sender].push(withdrawal);\\n     uint256 amountForLP = (rewardAmount * 10) / 100;\\n    uint256 amountForAdmin1 = (rewardAmount * 2) / 100;\\n    uint256 amountForAdmin2 = (rewardAmount * 2) / 100;\\n    uint256 amountForAdmin3 = (rewardAmount * 1) / 100;\\n    uint256 amountForReferer = (rewardAmount * 5) / 100;\\n     UsdtPool += amountForLP;\\n      \\n    USDT.transfer(admin1_address, amountForAdmin1);\\n    USDT.transfer(admin2_address, amountForAdmin2);\\n     USDT.transfer(admin3_address, amountForAdmin3);\\n    distributeToReferrer(rewardAmount,withdrawal);\\n    //calculate the user share \\n    uint256 amountForUser = rewardAmount - (amountForLP + (amountForAdmin1+amountForAdmin2+amountForAdmin3) + amountForReferer);\\n    ReferralPool -= amountForUser;\\n    transferToUser(amountForUser);\\n\\n     RewardAmount[msg.sender] -= rewardAmount;\\n    totalWithdrawn[msg.sender] += rewardAmount;\\n    updateTokenPrice();\\n    UserCounts[msg.sender].withdrawCount++;\\n}\\n\\n\\nfunction transferToUser(uint256 amountForUser) internal {\\n    USDT.transfer(msg.sender, amountForUser);\\n}\\n\\nfunction distributeToReferrer(uint256 rewardAmount,WithdrawalDetail storage _withdraw) internal {\\n    address new_referrel = msg.sender;\\n    \\n\\n    for (uint256 i = 0; i < 10; i++) {\\n        if (new_referrel == Owner) {\\n            uint RemainingdistributionAmount= (Salepercent[i] * rewardAmount) / 10000;\\n             ReferralPool +=RemainingdistributionAmount;\\n\\n        } else {\\n            address parent_addr = parent[new_referrel];\\n            uint distributionAmount = (Salepercent[i] * rewardAmount) / 10000;\\n            if(userLevels[parent_addr] >= i+1)\\n            {\\n                RewardAmount[parent_addr] += distributionAmount;\\n                _withdraw.Refferrers.push(parent_addr);\\n                _withdraw.amounts.push(distributionAmount);\\n            }\\n             ReferralPool +=distributionAmount;\\n            new_referrel = parent_addr; \\n        }\\n    }\\n}\\n\\n\\n\\n\\n\\n\\nfunction sellTokens(uint256 tokenAmount) external {\\n    require(tokenAmount > 0, \\\"Amount must be greater than 0\\\");\\n    require(balanceOf(msg.sender) >= tokenAmount, \\\"Insufficient token balance\\\");\\n\\n    uint usdtAmount = (tokenAmount * TokenPrice) / (1e18);\\n    require(usdtAmount <= maxPurchaseAmount, \\\"Purchase exceeds maximum limit\\\");\\n    if (msg.sender != admin1_address && msg.sender != admin2_address && msg.sender != Owner && msg.sender != admin3_address) {\\n        uint256 sellingLimit = 2 * totalInvested[msg.sender];\\n        require(usdtAmount <= sellingLimit, \\\"Selling amount exceeds limit\\\");\\n    }\\n\\nuserSells[msg.sender].push(SellDetail({\\n        amount: usdtAmount,\\n        currentRate: TokenPrice,\\n        dateTime: block.timestamp,\\n        Refferrers: new address[](0), // Initialize with empty array\\n        amounts: new uint[](0)       // Initialize with empty array\\n    }));\\n\\n    // WithdrawalDetail storage withdrawal = userWithdrawals[msg.sender][userWithdrawals[msg.sender].length-1];\\n    // Record sell details\\n     SellDetail storage seller = userSells[msg.sender][userSells[msg.sender].length-1];\\n\\n    // Perform the sell operation\\n    performSell(usdtAmount, tokenAmount);\\n\\n    // Distribute rewards and update total amount sold\\n    distributeSellRewards(usdtAmount,seller);\\n     uint256 amountForLP = (usdtAmount * 10) / 100;\\n    uint256 amountForAdmin1 = (usdtAmount * 2) / 100;\\n    uint256 amountForAdmin2 = (usdtAmount * 2) / 100;\\n    uint256 amountForAdmin3 = (usdtAmount * 1) / 100;\\n    uint256 amountForReferer = (usdtAmount * 5) / 100;\\n    UsdtPool += amountForLP;\\n    //Distribute 50% to the Admin\\n   \\n    USDT.transfer(admin1_address, amountForAdmin1);\\n    USDT.transfer(admin2_address, amountForAdmin2);\\n    USDT.transfer(admin3_address, amountForAdmin3);\\n    // Transfer USDT from contract to user\\n     uint256 amountForCharges = amountForLP + (amountForAdmin1+amountForAdmin2+amountForAdmin3) + amountForReferer;\\n    uint256 amountAfterCharge = usdtAmount - amountForCharges;\\n    USDT.transfer(msg.sender, amountAfterCharge);\\n    totalAmountSold[msg.sender] += usdtAmount;\\n    \\n    // Update token price\\n    updateTokenPrice();\\n    UserCounts[msg.sender].SellCount++;\\n}\\n\\n\\n\\nfunction performSell(uint usdtAmount, uint256 tokenAmount) internal {\\n    UsdtPool -= usdtAmount;\\n    _burn(msg.sender, tokenAmount);\\n}\\n\\n\\n\\nfunction distributeSellRewards(uint usdtAmount,SellDetail storage sell) internal {\\n address new_referrel = msg.sender;\\n\\n    for (uint256 i = 0; i < 10; i++) {\\n        if (new_referrel == Owner) {\\n            uint RemainingdistributeAmount= (Salepercent[i] * usdtAmount) / 10000;\\n             ReferralPool +=RemainingdistributeAmount;\\n        } else {\\n            address parent_addr = parent[new_referrel];\\n            uint distributeAmount = (Salepercent[i] * usdtAmount) / 10000;\\n            if(userLevels[parent_addr] >= i+1)\\n            {\\n                RewardAmount[parent_addr] += distributeAmount;\\n                sell.Refferrers.push(parent_addr);\\n                sell.amounts.push(distributeAmount);\\n            }\\n            ReferralPool +=distributeAmount;\\n            new_referrel = parent_addr; \\n        }\\n    }\\n}\\n\\n\\nfunction updateTokenPrice() internal {\\n    TokenPrice = (UsdtPool * (1e18)) / totalSupply();\\n}\\n\\nfunction setAdminaddresses(address _admin1,address _admin2,address _admin3)external onlyOwner()\\n{\\n     require(_admin1 != address(0), \\\"Admin1 address cannot be zero\\\");\\n        require(_admin2 != address(0), \\\"Admin2 address cannot be zero\\\");\\n        require(_admin3 != address(0), \\\"Admin3 address cannot be zero\\\");\\n\\n        admin1_address = _admin1;\\n        admin2_address = _admin2;\\n        admin3_address = _admin3;\\n\\n        // Unlock all levels for the new admins\\n        userLevels[_admin1] = MAX_LEVELS;\\n        userLevels[_admin2] = MAX_LEVELS;\\n        userLevels[_admin3] = MAX_LEVELS; // For admin3\\n        accountActivated[_admin1] = true;\\n        accountActivated[_admin2] = true;\\n        accountActivated[_admin3] = true; // For admin3\\n\\n}\\n\\nfunction setDirectAndIndirectUsers(address _user, address _referee) internal {\\n        address DirectReferee = _referee;\\n      \\n        referrerToDirectChildren[DirectReferee].child.push(_user);\\n        setIndirectUsersRecursive(_user, _referee);\\n    }\\n    function setIndirectUsersRecursive(address _user, address _referee) internal {\\n    if (_referee != Owner) {\\n        address presentReferee = parent[_referee];\\n        referrerToIndirectChildren[presentReferee].child.push(_user);\\n        setIndirectUsersRecursive(_user, presentReferee);\\n    }\\n}\\n\\nfunction getAvailableRewards(address user) external view returns (uint256) {\\n    return RewardAmount[user];\\n}\\n\\n\\nfunction getRewardsWithdrawn(address user) external view returns (uint256) {\\n    return totalWithdrawn[user];\\n}\\nfunction getRewardLimit(address user) external view returns (uint256) {\\n    // Assuming the reward limit is 5 times the total invested amount\\n    return 5 * totalInvested[user] - totalWithdrawn[user];\\n}\\nfunction getSellingLimit(address user) external view returns (uint256) {\\n\\n    return 2 * totalInvested[user] - totalAmountSold[user];\\n}\\nfunction getUsdtBalanceInPool() external view returns (uint256) {\\n    return USDT.balanceOf(address(this));\\n}\\nfunction getTokensBalanceInPool() external view returns (uint256) {\\n    return balanceOf(address(this));\\n}\\n\\n function showAllDirectChild(\\n        address user\\n    ) external view returns (address[] memory) {\\n        address[] memory children = referrerToDirectChildren[user].child;\\n\\n        return children;\\n    }\\n\\n   function showAllInDirectChild(\\n        address user\\n    ) external view returns (address[] memory) {\\n        address[] memory children = referrerToIndirectChildren[user].child;\\n\\n        return children;\\n    }\\n    \\n      function getUserLevels(address user) external view returns (uint8) {\\n        return userLevels[user];\\n    }\\n    function transferOwnership(address newOwner) public  onlyOwner {\\n        require(newOwner != address(0), \\\"New owner cannot be the zero address\\\");\\n         Owner= newOwner;\\n\\n        // Set max levels and activate account for the new owner\\n        userLevels[newOwner] = MAX_LEVELS;\\n        accountActivated[newOwner] = true;\\n        \\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"TokenSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACTIVATION_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BuyPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountInUSDT\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"BuyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyandSellDivisor\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LEVELS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReferralPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Salepercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UsdtPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SellCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin1_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin2_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin3_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountForReffererForBuying\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountForReffererForSeller\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewardLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRewardsWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getSellingLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensBalanceInPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsdtBalanceInPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLevels\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPurchaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPurchaseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"parent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin3\",\"type\":\"address\"}],\"name\":\"setAdminaddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"showAllDirectChild\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"showAllInDirectChild\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalAmountSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userBuys\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLevels\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userSells\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CUnetwork", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}