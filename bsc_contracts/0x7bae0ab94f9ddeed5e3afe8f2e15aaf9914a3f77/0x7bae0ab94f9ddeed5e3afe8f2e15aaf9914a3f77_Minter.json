{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/libs/IBEP20.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract IBEP20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() external view virtual returns (uint8);\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view virtual returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the token name.\r\n   */\r\n  function name() external view virtual returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(\r\n    address recipient,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address spender\r\n  ) external view virtual returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(\r\n    address spender,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external virtual returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/libs/I4M.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract I4M {\r\n  function isUser(address uid) external virtual returns (bool);\r\n\r\n  function isActiveUser(address uid) external virtual returns (bool);\r\n}\r\n\r\n// File: contracts/libs/SafeMath.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/libs/Context.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this;\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: contracts/libs/Ownable.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  using SafeMath for uint256;\r\n\r\n  address internal _owner;\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _owner = _msgSender();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/libs/ICakePool.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract ICakePool {\r\n  function balanceOf(address account) external view virtual returns (uint256);\r\n\r\n  function mint(uint256 mintAmount) external virtual returns (uint256);\r\n\r\n  function redeem(uint256 redeemTokens) external virtual returns (uint256);\r\n\r\n  function redeemUnderlying(\r\n    uint256 redeemAmount\r\n  ) external virtual returns (uint256);\r\n}\r\n\r\n// File: contracts/libs/SmartVault.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\ncontract SmartVault {\r\n  mapping(address => bool) private _owner;\r\n\r\n  constructor(address creator) {\r\n    _owner[msg.sender] = true;\r\n    _owner[creator] = true;\r\n  }\r\n\r\n  function transfer(address token, address to, uint256 amount) public {\r\n    require(_owner[msg.sender], \"permission denied\");\r\n    amount = amount == 0 ? IBEP20(token).balanceOf(address(this)) : amount;\r\n    IBEP20(token).transfer(to, amount);\r\n  }\r\n}\r\n\r\n// File: contracts/Minter.sol\r\n\r\npragma solidity ^0.8.10;\r\n\r\nabstract contract IROCK is IBEP20 {\r\n  function burn(uint256 amount) external virtual;\r\n}\r\n\r\ncontract Minter is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  struct SwapPrice {\r\n    uint256 price; // \u4ef7\u683c\r\n    uint256 time; // \u65f6\u95f4\r\n  }\r\n\r\n  struct Ladder {\r\n    uint256 min; // \u6700\u5c0f\u5929\u6570\r\n    uint256 max; // \u6700\u5927\u5929\u6570\r\n    uint256 num; // \u4ea7\u51fa\u603b\u91cf\r\n  }\r\n\r\n  struct User {\r\n    address uid; // \u7528\u6237\u5730\u5740\r\n    uint256 level; // \u6316\u77ff\u7b49\u7ea7\r\n    uint256 mintTotal; // \u6316\u77ff\u603b\u91cf\r\n    uint256 mintTime; // \u6316\u77ff\u65f6\u95f4\r\n    uint256 buyNum; // \u8d2d\u4e70\u6570\u91cf\r\n    uint256 sellNum; // \u51fa\u552e\u6570\u91cf\r\n  }\r\n\r\n  struct Order {\r\n    uint256 key;\r\n    address uid;\r\n    uint256 amount;\r\n    uint256 price;\r\n    uint256 time;\r\n    bool isBuy;\r\n  }\r\n\r\n  SwapPrice[] internal _swapPrice;\r\n\r\n  ICakePool internal _vUSDT;\r\n  IBEP20 internal _USDT;\r\n  IBEP20 internal _USDM;\r\n  IROCK internal _ROCK;\r\n  I4M internal _MMMM;\r\n\r\n  Ladder[] internal _ladders;\r\n\r\n  SmartVault internal _smartMint;\r\n  SmartVault internal _smartSwap;\r\n\r\n  mapping(address => User) internal _minters;\r\n  mapping(uint256 => uint256) internal _levelNum;\r\n  mapping(uint256 => uint256) internal _mintNum;\r\n  mapping(uint256 => uint256) internal _indexMintNum;\r\n  mapping(uint256 => mapping(uint256 => uint256)) internal _indexLevelNum;\r\n  mapping(address => Order[]) internal _orders;\r\n  mapping(uint256 => uint256) internal _levelRate;\r\n\r\n  uint256 internal RBASE = 10000;\r\n  uint256 internal _rock_price = 1e18;\r\n  uint256 internal _swap_fee = 2000;\r\n  uint256 internal _year = 0;\r\n  uint256 internal _mintTotal = 0;\r\n  uint256 internal _buyTotal = 0;\r\n  uint256 internal _sellTotal = 0;\r\n  uint256 internal _freedNum;\r\n  uint256 internal _cycle = 1 days;\r\n\r\n  uint256 internal _startTime;\r\n  uint256 internal _time;\r\n\r\n  constructor(address usdt, address rock, address swap, uint256 time) {\r\n    _USDT = IBEP20(usdt);\r\n    _ROCK = IROCK(rock);\r\n    _vUSDT = ICakePool(swap);\r\n    _time = time;\r\n\r\n    _ladders.push(Ladder(0, 365 * _cycle, 1995e18));\r\n    _ladders.push(Ladder(365 * _cycle, 730 * _cycle, 2992.5e18));\r\n    _ladders.push(Ladder(730 * _cycle, 1095 * _cycle, 3990e18));\r\n    _ladders.push(Ladder(1095 * _cycle, 1460 * _cycle, 4987.5e18));\r\n    _ladders.push(Ladder(1460 * _cycle, 1825 * _cycle, 5985e18));\r\n\r\n    _levelRate[1] = 3000;\r\n    _levelRate[2] = 3000;\r\n    _levelRate[3] = 4000;\r\n\r\n    _smartMint = new SmartVault(msg.sender);\r\n    _smartSwap = new SmartVault(msg.sender);\r\n\r\n    setRockPrice(1e18);\r\n  }\r\n\r\n  function updateTime() public {\r\n    uint256 time = _time;\r\n    if (time.add(_cycle) > block.timestamp) return;\r\n    do {\r\n      time = time.add(_cycle);\r\n    } while (time.add(_cycle) < block.timestamp);\r\n    _time = time;\r\n\r\n    _indexLevelNum[_time][1] = _levelNum[1];\r\n    _indexLevelNum[_time][2] = _levelNum[2];\r\n    _indexLevelNum[_time][3] = _levelNum[3];\r\n    _indexMintNum[_time] = _getPerDay();\r\n\r\n    if (_startTime == 0 || block.timestamp < _startTime) return;\r\n    if (_ROCK.balanceOf(address(this)) >= 10.5e18) {\r\n      _ROCK.transfer(address(_smartSwap), 10.5e18);\r\n      _freedNum += 10.5e18;\r\n    }\r\n  }\r\n\r\n  function transfer(\r\n    address token,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public onlyOwner {\r\n    IBEP20(token).transfer(recipient, amount);\r\n  }\r\n\r\n  function sell(uint256 amount) external {\r\n    updateTime();\r\n    address uid = msg.sender;\r\n    require(amount > 0, \"invalid amount\");\r\n\r\n    _ROCK.transferFrom(uid, address(this), amount);\r\n    _ROCK.burn(amount);\r\n\r\n    uint256 usdtValue = amount.mul(_rock_price).div(1e18);\r\n    uint256 fee = usdtValue.mul(_swap_fee).div(RBASE);\r\n    uint256 usdtAmount = usdtValue.sub(fee);\r\n\r\n    if (_minters[uid].uid == address(0)) {\r\n      _minters[uid] = User(uid, 0, 0, 0, 0, 0);\r\n      _levelNum[0]++;\r\n    }\r\n\r\n    _sellTotal += amount;\r\n    _minters[uid].sellNum += amount;\r\n\r\n    _withdraw(uid, usdtAmount);\r\n\r\n    _orders[uid].push(\r\n      Order(\r\n        _orders[uid].length,\r\n        uid,\r\n        amount,\r\n        _rock_price,\r\n        block.timestamp,\r\n        false\r\n      )\r\n    );\r\n  }\r\n\r\n  function buy(uint256 amount) external {\r\n    updateTime();\r\n    address uid = msg.sender;\r\n    require(amount > 0, \"invalid amount\");\r\n    require(_MMMM.isActiveUser(uid), \"invalid user\");\r\n\r\n    uint256 usdtValue = amount.mul(_rock_price).div(1e18);\r\n    _USDT.transferFrom(uid, address(this), usdtValue);\r\n\r\n    _smartSwap.transfer(address(_ROCK), uid, amount);\r\n\r\n    if (_minters[uid].uid == address(0)) {\r\n      _minters[uid] = User(uid, 0, 0, 0, 0, 0);\r\n      _levelNum[0]++;\r\n    }\r\n\r\n    _buyTotal += amount;\r\n    _minters[uid].buyNum += amount;\r\n\r\n    if (block.chainid != 1337) {\r\n      _deposit();\r\n    }\r\n    _orders[uid].push(\r\n      Order(\r\n        _orders[uid].length,\r\n        uid,\r\n        amount,\r\n        _rock_price,\r\n        block.timestamp,\r\n        true\r\n      )\r\n    );\r\n  }\r\n\r\n  function _deposit() private {\r\n    uint256 amount = _USDT.balanceOf(address(this));\r\n    _USDT.approve(address(_vUSDT), amount);\r\n    _vUSDT.mint(amount);\r\n  }\r\n\r\n  function _withdraw(address uid, uint256 amount) private {\r\n    if (block.chainid != 1337) {\r\n      uint256 amount_1 = _USDT.balanceOf(address(this));\r\n      _vUSDT.redeemUnderlying(amount);\r\n      uint256 amount_2 = _USDT.balanceOf(address(this));\r\n      amount = amount_2.sub(amount_1);\r\n    }\r\n    require(_USDT.transfer(uid, amount), \"transfer fail\");\r\n  }\r\n\r\n  function withdrawAll(address to) external onlyOwner {\r\n    _vUSDT.redeem(_vUSDT.balanceOf(address(this)));\r\n    _USDT.transfer(to, _USDT.balanceOf(address(this)));\r\n  }\r\n\r\n  function setRockPrice(uint256 price) public onlyOwner {\r\n    require(price > 0, \"invalid price\");\r\n    _rock_price = price;\r\n    _swapPrice.push(SwapPrice(price, block.timestamp));\r\n  }\r\n\r\n  function setSwapFee(uint256 fee) external onlyOwner {\r\n    require(fee >= 0 && fee <= 10000, \"invalid fee\");\r\n    _swap_fee = fee;\r\n  }\r\n\r\n  function setMinter(address uid, uint256 level) external {\r\n    require(msg.sender == address(_MMMM), \"invalid sender\");\r\n    require(level >= 1 && level <= 3, \"invalid level\");\r\n\r\n    _mint(uid, mintNum(uid));\r\n\r\n    if (_minters[uid].uid == address(0)) {\r\n      _minters[uid] = User(uid, level, 0, _time, 0, 0);\r\n      _levelNum[level]++;\r\n    } else {\r\n      if (_minters[uid].level >= level) return;\r\n      _levelNum[_minters[uid].level]--;\r\n      _minters[uid].level = level;\r\n      _levelNum[level]++;\r\n    }\r\n  }\r\n\r\n  function mint() public {\r\n    updateTime();\r\n    uint256 num = mintNum(msg.sender);\r\n    if (num > 0) {\r\n      _mint(msg.sender, num);\r\n    } else {\r\n      _minters[msg.sender].mintTime = _time;\r\n    }\r\n  }\r\n\r\n  function _mint(address uid, uint256 num) private {\r\n    if (num > 0) {\r\n      _smartMint.transfer(address(_ROCK), uid, num);\r\n      _minters[uid].mintTotal += num;\r\n\r\n      uint256 ladder = _getLadder();\r\n      if (ladder != _year) {\r\n        _year = ladder;\r\n      }\r\n      _mintNum[_year] += num;\r\n      _mintTotal += num;\r\n    }\r\n    _minters[uid].mintTime = _time;\r\n  }\r\n\r\n  function mintNum(address uid) public view returns (uint256) {\r\n    if (_startTime == 0) return 0;\r\n    if (_startTime > block.timestamp) return 0;\r\n    if (_minters[uid].uid == address(0)) return 0;\r\n    if (_minters[uid].mintTime >= _time) return 0;\r\n    if (_minters[uid].level == 0) return 0;\r\n    uint256 num;\r\n    uint256 levelNum;\r\n    uint256 ind = 1;\r\n    uint256 time = _minters[uid].mintTime.add(_cycle);\r\n    time = time > _startTime ? time : _startTime;\r\n    do {\r\n      levelNum = _indexLevelNum[time][_minters[uid].level];\r\n      if (levelNum > 0) {\r\n        num += _indexMintNum[time]\r\n          .mul(_levelRate[_minters[uid].level])\r\n          .div(RBASE)\r\n          .div(levelNum);\r\n      }\r\n      if (ind == 3) break;\r\n      ind++;\r\n      time += _cycle;\r\n    } while (time <= _time);\r\n    return num;\r\n  }\r\n\r\n  function _getPerDay() private view returns (uint256) {\r\n    uint256 i = _getLadder();\r\n    return _ladders[i].num.div(365);\r\n  }\r\n\r\n  function _getLadder() private view returns (uint256) {\r\n    for (uint256 i = 0; i < _ladders.length; i++) {\r\n      if (\r\n        _ladders[i].min.add(_startTime) < block.timestamp &&\r\n        _ladders[i].max.add(_startTime) >= block.timestamp\r\n      ) {\r\n        return i;\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  function getSmart()\r\n    external\r\n    view\r\n    returns (address mintAddr, address swapAddr)\r\n  {\r\n    mintAddr = address(_smartMint);\r\n    swapAddr = address(_smartSwap);\r\n  }\r\n\r\n  function getParams()\r\n    public\r\n    view\r\n    returns (\r\n      uint256 price,\r\n      uint256 fee,\r\n      uint256 startTime,\r\n      uint256 time,\r\n      uint256 year,\r\n      uint256 buyTotal,\r\n      uint256 sellTotal,\r\n      uint256 mintLadder,\r\n      uint256 mintCurrent,\r\n      uint256 mintTotal,\r\n      uint256 freedNum\r\n    )\r\n  {\r\n    price = _rock_price;\r\n    fee = _swap_fee;\r\n    startTime = _startTime;\r\n    time = _time;\r\n    year = _year;\r\n    buyTotal = _buyTotal;\r\n    sellTotal = _sellTotal;\r\n    mintLadder = _ladders[_getLadder()].num;\r\n    mintCurrent = _mintNum[_year];\r\n    mintTotal = _mintTotal;\r\n    freedNum = _freedNum;\r\n  }\r\n\r\n  function setStartTime(uint256 startTime) external onlyOwner {\r\n    require(startTime > 0, \"invalid startTime\");\r\n    _startTime = startTime;\r\n  }\r\n\r\n  function set4M(address mmmm) external onlyOwner {\r\n    require(address(mmmm) != address(0), \"invalid address\");\r\n    _MMMM = I4M(mmmm);\r\n  }\r\n\r\n  function getMinter(address uid) external view returns (User memory) {\r\n    return _minters[uid];\r\n  }\r\n\r\n  function getLevelNum()\r\n    external\r\n    view\r\n    returns (uint256 l_1, uint256 l_2, uint256 l_3, uint256 m_1)\r\n  {\r\n    return (\r\n      _indexLevelNum[_time][1],\r\n      _indexLevelNum[_time][2],\r\n      _indexLevelNum[_time][3],\r\n      _indexMintNum[_time]\r\n    );\r\n  }\r\n\r\n  function getPairBalance() external view returns (uint256 usdt, uint256 rock) {\r\n    usdt = _USDT.balanceOf(address(this));\r\n    if (block.chainid != 1337) {\r\n      usdt += _vUSDT.balanceOf(address(this));\r\n    }\r\n    rock = _ROCK.balanceOf(address(_smartSwap));\r\n  }\r\n\r\n  function orderList(\r\n    address uid,\r\n    uint256 page,\r\n    uint256 size\r\n  ) external view returns (Order[] memory order, uint256 total) {\r\n    total = _orders[uid].length;\r\n    if (total == 0) return (order, total);\r\n    page = page < 1 ? 1 : page;\r\n    size = size > total ? total : size;\r\n\r\n    uint256 end = total.sub(1).sub(page.sub(1).mul(size));\r\n    uint256 start = end.sub(size.sub(1));\r\n\r\n    order = new Order[](size);\r\n    uint256 key;\r\n    for (uint256 i = start; i <= end; i++) {\r\n      order[key] = _orders[uid][end - key];\r\n      key++;\r\n    }\r\n  }\r\n\r\n  function rockPrice()\r\n    external\r\n    view\r\n    returns (SwapPrice[] memory price, uint256 total)\r\n  {\r\n    uint256 page = 1;\r\n    uint256 size = 10;\r\n\r\n    total = _swapPrice.length;\r\n    if (total == 0) return (price, total);\r\n    page = page < 1 ? 1 : page;\r\n    size = size > total ? total : size;\r\n\r\n    uint256 end = total.sub(1).sub(page.sub(1).mul(size));\r\n    uint256 start = end.sub(size.sub(1));\r\n\r\n    price = new SwapPrice[](size);\r\n    uint256 key;\r\n    for (uint256 i = start; i <= end; i++) {\r\n      price[key] = _swapPrice[end - key];\r\n      key++;\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLevelNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"l_1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l_2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l_3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"m_1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"getMinter\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNum\",\"type\":\"uint256\"}],\"internalType\":\"struct Minter.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPairBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintLadder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freedNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSmart\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mintAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapAddr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"}],\"name\":\"mintNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"orderList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"}],\"internalType\":\"struct Minter.Order[]\",\"name\":\"order\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rockPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct Minter.SwapPrice[]\",\"name\":\"price\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mmmm\",\"type\":\"address\"}],\"name\":\"set4M\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uid\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setRockPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Minter", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000009c1a2913be2a44c6c67842dcbdc94b8829d983df000000000000000000000000fd5840cd36d94d7229439859c0112a4185bc02550000000000000000000000000000000000000000000000000000000065a01080", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5568f6ca9d4ac16a595f1ebbdbab1a334bf8f4631da440d2d4509ceaff77a6df"}