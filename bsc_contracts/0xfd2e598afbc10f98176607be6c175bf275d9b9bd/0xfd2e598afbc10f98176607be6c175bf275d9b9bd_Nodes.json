{"SourceCode": "{\"EnumerableSet.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n/*\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0 means a value is not in the set.\\n        mapping(bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n        if (valueIndex != 0) {\\n            // we swap the element to delete with the last one in the array, and then remove the last element.\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n                set._values[toDeleteIndex] = lastValue;\\n                set._indexes[lastValue] = valueIndex;\\n            }\\n            set._values.pop();\\n            delete set._indexes[value];\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    // Return the entire set in an array\\n    // WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n    // to mostly be used by view accessors that are queried without any gas fees. \\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n}\"},\"Nodes.sol\":{\"content\":\"pragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./EnumerableSet.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n   \\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    constructor () {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Nodes is Ownable {\\r\\n    IERC20 public constant c_erc20 = IERC20(0x2c44b726ADF1963cA47Af88B284C06f30380fC78);\\r\\n    using EnumerableSet for EnumerableSet.AddressSet;\\r\\n    EnumerableSet.AddressSet private nodes;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public withdrawns;\\r\\n    uint256 public dividendTime = 1685703600; // 2023-06-02 19:00:00\\r\\n    uint256 public duration = 7 days;\\r\\n    uint256 public feeRate = 3;\\r\\n    address public feeAddress = 0xc33ba9A342cB9E705f2B342ef62Ef8b544eE1aEF;\\r\\n\\r\\n    struct RecordDividend {\\r\\n        uint64 timestamp;\\r\\n        uint64 num;\\r\\n        uint128 amount;\\r\\n    }\\r\\n    RecordDividend[] public records;\\r\\n\\r\\n    function setTime(uint256 d, uint256 i) external onlyOwner {\\r\\n        dividendTime = d;\\r\\n        duration = i;\\r\\n    }\\r\\n   \\r\\n    function addNode(address[] calldata addrs) external onlyOwner {\\r\\n        uint256 len = addrs.length;\\r\\n        for (uint256 i; i \\u003c len; ++i) {\\r\\n            nodes.add(addrs[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeNode(address[] calldata addrs) external onlyOwner {\\r\\n        uint256 len = addrs.length;\\r\\n        for (uint256 i; i \\u003c len; ++i) {\\r\\n            nodes.remove(addrs[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setFeeRate(uint256 fr, address fa) external onlyOwner {\\r\\n        feeRate = fr;\\r\\n        feeAddress = fa;\\r\\n    }\\r\\n\\r\\n    function getERC201(IERC20 c_erc2, uint256 amount) external onlyOwner {\\r\\n        c_erc2.transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function getDividend() external {\\r\\n        require(block.timestamp \\u003e dividendTime + duration, \\u0027no time\\u0027);\\r\\n        uint256 interval = (block.timestamp - dividendTime)/duration;\\r\\n        dividendTime += interval*duration;\\r\\n\\r\\n        uint256 feeAmount = c_erc20.balanceOf(address(this)) * feeRate / 100;\\r\\n        c_erc20.transfer(feeAddress, feeAmount);\\r\\n        uint256 len = nodes.length();\\r\\n        uint256 o = c_erc20.balanceOf(address(this))/len;\\r\\n        for (uint256 i; i \\u003c len; ++i) {\\r\\n            address addr = nodes.at(i);\\r\\n            c_erc20.transfer(addr, o);\\r\\n            withdrawns[addr] += o;\\r\\n        }\\r\\n        records.push(RecordDividend(uint64(block.timestamp), uint64(len), uint128(o*len)));\\r\\n    }\\r\\n\\r\\n    function nodeInfo(address addr) external view returns(uint256, uint256, bool, uint256, uint256, uint256) {\\r\\n        return (nodes.length(), c_erc20.balanceOf(address(this)), nodes.contains(addr), withdrawns[addr], dividendTime, duration);\\r\\n    }\\r\\n\\r\\n    function nodesInfo() external view returns(address[] memory addrs, uint256[] memory withdrawnAmounts) {\\r\\n        uint256 len = nodes.length();\\r\\n        addrs = new address[](len);\\r\\n        withdrawnAmounts = new uint256[](len);\\r\\n        for (uint256 i; i \\u003c len; ++i) {\\r\\n            address addr = nodes.at(i);\\r\\n            addrs[i] = addr;\\r\\n            withdrawnAmounts[i] = withdrawns[addr];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function recordInfo() external view returns(RecordDividend[] memory o) {\\r\\n        o = records;\\r\\n    }\\r\\n\\r\\n    function getRecordsByPage(uint256 pageNum, uint256 pageSize) external view returns (RecordDividend[] memory o, uint256 total) {\\r\\n        total = records.length;\\r\\n        uint256 from = pageNum*pageSize;\\r\\n        if (total \\u003c= from) {\\r\\n            return (new RecordDividend[](0), total);\\r\\n        }\\r\\n\\r\\n        uint256 minNum = Math.min(total - from, pageSize);\\r\\n        from = total - from - 1;\\r\\n        o = new RecordDividend[](minNum);\\r\\n        \\r\\n        for (uint256 i; i \\u003c minNum; ++i) {\\r\\n            o[i] = records[from];\\r\\n            if(from \\u003e 0) {\\r\\n                from--;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"c_erc20\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"c_erc2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getERC201\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pageNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getRecordsByPage\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"num\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct Nodes.RecordDividend[]\",\"name\":\"o\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"nodeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodesInfo\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawnAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recordInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"num\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct Nodes.RecordDividend[]\",\"name\":\"o\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"num\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fr\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fa\",\"type\":\"address\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Nodes", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6c060c2278b0b55bc1d4eff9912dc5e68435d3dd7e9363b3431fdcfe41b14f9e"}