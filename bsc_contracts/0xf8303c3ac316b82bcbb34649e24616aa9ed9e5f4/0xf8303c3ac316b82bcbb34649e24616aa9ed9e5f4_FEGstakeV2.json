{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.7.6;\r\n\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// SafeMath library\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    \r\n    function ceil(uint a, uint m) internal pure returns (uint r) {\r\n        return (a + m - 1) / m * m;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"ERC20: sending to the zero address\");\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// ----------------------------------------------------------------------------\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) external returns (bool success);\r\n    function approve(address spender, uint256 tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) external returns (bool success);\r\n    function burnTokens(uint256 _amount) external;\r\n    \r\n    function calculateFeesBeforeSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external view returns (uint256, uint256);\r\n    \r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\ninterface regreward {\r\n    function distributeV2() external;\r\n}\r\n\r\ninterface FEGex2 {\r\n    function BUY(\r\n        address to,\r\n        uint minAmountOut\r\n    ) \r\n        external payable\r\n        returns (uint tokenAmountOut, uint spotPriceAfter);\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"Roles: account already has role\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"Roles: account does not have role\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        require(account != address(0), \"Roles: account is the zero address\");\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract WhitelistAdminRole is Owned  {\r\n    using Roles for Roles.Role;\r\n\r\n    event WhitelistAdminAdded(address indexed account);\r\n    event WhitelistAdminRemoved(address indexed account);\r\n\r\n    Roles.Role private _whitelistAdmins;\r\n\r\n   constructor () {\r\n        _addWhitelistAdmin(msg.sender);\r\n    }\r\n    \r\n    modifier onlyWhitelistAdmin() {\r\n        require(isWhitelistAdmin(msg.sender), \"WhitelistAdminRole: caller does not have the WhitelistAdmin role\");\r\n        _;\r\n    }\r\n\r\n    function isWhitelistAdmin(address account) public view returns (bool) {\r\n        return _whitelistAdmins.has(account);\r\n    }\r\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\r\n        _addWhitelistAdmin(account);\r\n    }\r\n\r\n    function renounceWhitelistAdmin() public {\r\n        _removeWhitelistAdmin(msg.sender);\r\n    }\r\n\r\n    function _addWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.add(account);\r\n        emit WhitelistAdminAdded(account);\r\n    } \r\n\r\n    function _removeWhitelistAdmin(address account) internal {\r\n        _whitelistAdmins.remove(account);\r\n        emit WhitelistAdminRemoved(account);\r\n    }\r\n}\r\n\r\ncontract FNum is ReentrancyGuard{\r\n\r\n    uint public constant BASE              = 10**18;\r\n    \r\n    function badd(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c = a + b;\r\n        require(c >= a, \"ERR_ADD_OVERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsub(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        (uint c, bool flag) = bsubSign(a, b);\r\n        require(!flag, \"ERR_SUB_UNDERFLOW\");\r\n        return c;\r\n    }\r\n\r\n    function bsubSign(uint a, uint b)\r\n        internal pure\r\n        returns (uint, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function bmul(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\r\n        uint c1 = c0 + (BASE / 2);\r\n        require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\r\n        uint c2 = c1 / BASE;\r\n        return c2;\r\n    }\r\n\r\n    function bdiv(uint a, uint b)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        require(b != 0, \"ERR_DIV_ZERO\");\r\n        uint c0 = a * BASE;\r\n        require(a == 0 || c0 / a == BASE, \"ERR_DIV_INTERNAL\"); // bmul overflow\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n    \r\nfunction btoi(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return a / BASE;\r\n    }\r\n\r\n    function bfloor(uint a)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        return btoi(a) * BASE;\r\n    }\r\n    \r\nfunction bpowi(uint a, uint n)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        uint z = n % 2 != 0 ? a : BASE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = bmul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = bmul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    function bpow(uint base, uint exp)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n\r\n        uint whole  = bfloor(exp);\r\n        uint remain = bsub(exp, whole);\r\n\r\n        uint wholePow = bpowi(base, btoi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n        uint BPOW_PRECISION = BASE / 10**10;\r\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\r\n        return bmul(wholePow, partialResult);\r\n    }\r\n\r\n    function bpowApprox(uint base, uint exp, uint precision)\r\n        internal pure\r\n        returns (uint)\r\n    {\r\n        // term 0:\r\n        uint a     = exp;\r\n        (uint x, bool xneg)  = bsubSign(base, BASE);\r\n        uint term = BASE;\r\n        uint sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        for (uint i = 1; term >= precision; i++) {\r\n            uint bigK = i * BASE;\r\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BASE));\r\n            term = bmul(term, bmul(c, x));\r\n            term = bdiv(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum = bsub(sum, term);\r\n            } else {\r\n                sum = badd(sum, term);\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract FTokenBase is FNum {\r\n\r\n    mapping(address => uint)                   internal _balance;\r\n    mapping(address => mapping(address=>uint)) internal _allowance;\r\n    uint public _totalSupply;\r\n\r\n    event Approval(address indexed src, address indexed dst, uint amt);\r\n    event Transfer(address indexed src, address indexed dst, uint amt);\r\n\r\n    function _mint(uint amt) internal {\r\n        _balance[address(this)] = badd(_balance[address(this)], amt);\r\n        _totalSupply = badd(_totalSupply, amt);\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint amt) internal {\r\n        require(_balance[address(this)] >= amt);\r\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\r\n        _totalSupply = bsub(_totalSupply, amt);\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n    \r\n    function _move(address src, address dst, uint amt) internal {\r\n        require(_balance[src] >= amt);\r\n        _balance[src] = bsub(_balance[src], amt);\r\n        _balance[dst] = badd(_balance[dst], amt);\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n}\r\n\r\ncontract FToken is FTokenBase {\r\n\r\n    string  private _name     = \"FEG Stake Shares\";\r\n    string  private _symbol   = \"FSS\";\r\n    uint8   private _decimals = 18;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function allowance(address src, address dst) external view returns (uint) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view returns (uint) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\r\n        uint oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint amt) external returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\r\n        require(msg.sender == src || amt <= _allowance[src][msg.sender]);\r\n     \r\n        _move(src, dst, amt);\r\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\r\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract FEGstakeV2 is Owned, ReentrancyGuard, WhitelistAdminRole, FNum, FTokenBase, FToken{\r\n    using SafeMath for uint256;\r\n    \r\n    address public FEG   = 0xacFC95585D80Ab62f67A14C566C1b7a49Fe91167;\r\n    address public fBNB  = 0x87b1AccE6a1958E522233A737313C086551a5c76;\r\n    address public USDT  = 0xEf11aB854b475Bd0c5Db37f6bFFAB443219d656d;\r\n    address public TRY   = 0xc12eCeE46ed65D970EE5C899FCC7AE133AfF9b03;\r\n    address public FETP  = 0xbc26Fac021Ee15dEE618c5B67c17a2Fc6eFA430D;\r\n    address public BTC   = 0xD3ba3FB9014AB0b67ea9af05d9b690BFa2305DC2;\r\n    address public poolShares = address(this);\r\n    address public regrewardContract; //Signs The Checks\r\n    \r\n    bool public live = false;\r\n    bool public perform = false; //if true then distribution of rewards from the pool to stakers via the withdraw function is enabled\r\n    bool public perform2 = true; //if true then distribution of TX rewards from unclaimed 1 and 2 wrap's will distribute to stakers\r\n    bool public perform3 = true; //if true then distribution of TX rewards from unclaimed 3rd wrap's will distribute to stakers\r\n    uint256 public scailment = 20; // FEG has TX fee, deduct this fee to not break maths\r\n    \r\n    uint256 public totalDividends = 0;\r\n    uint256 public must = 2e16;\r\n    uint256 public scaleatize = 99;\r\n    uint256 private scaledRemainder = 0;\r\n    uint256 private scaling = uint256(10) ** 12;\r\n    uint public round = 1;\r\n    uint256 public totalDividends1 = 0;\r\n    uint256 private scaledRemainder1 = 0;\r\n    uint256 private scaling1 = uint256(10) ** 12;\r\n    uint public round1 = 1;\r\n    uint256 public totalDividends2 = 0;\r\n    uint256 private scaledRemainder2 = 0;\r\n    uint256 private scaling2 = uint256(10) ** 12;\r\n    uint public round2 = 1;\r\n    \r\n    mapping(address => uint) public farmTime; // When you staked\r\n    \r\n    struct USER{\r\n        uint256 lastDividends;\r\n        uint256 fromTotalDividend;\r\n        uint round;\r\n        uint256 remainder;\r\n        uint256 lastDividends1;\r\n        uint256 fromTotalDividend1;\r\n        uint round1;\r\n        uint256 remainder1;\r\n        uint256 lastDividends2;\r\n        uint256 fromTotalDividend2;\r\n        uint round2;\r\n        uint256 remainder2;\r\n        bool initialized;\r\n        bool activated;\r\n    } \r\n    \r\n    address[] internal stakeholders;\r\n    uint public scalerize = 98;\r\n    uint256 public scaletor = 1e17;\r\n    uint256 public scaletor1 = 20e18;\r\n    uint256 public scaletor2 = 1e15;\r\n    uint256 public totalWrap; //  total unclaimed bnb rewards\r\n    uint256 public totalWrap1; //  total unclaimed usdt rewards\r\n    uint256 public totalWrap2; //  total unclaimed btc rewards\r\n    uint256 public totalWrapRef  = bsub(IERC20(fBNB).balanceOf(address(this)), totalWrap); //total bnb reflections unclaimed\r\n    uint256 public totalWrapRef1 = bsub(IERC20(USDT).balanceOf(address(this)), totalWrap1); //total usdt reflections unclaimed\r\n    uint256 public totalWrapRef2 = bsub(IERC20(BTC).balanceOf(address(this)), totalWrap2); //total BTC reflections unclaimed\r\n    mapping(address => USER) stakers;\r\n    mapping (uint => uint256) public payouts;                   // keeps record of each payout\r\n    mapping (uint => uint256) public payouts1;                   // keeps record of each payout\r\n    mapping (uint => uint256) public payouts2;                   // keeps record of each payout\r\n    mapping (uint => uint256) public payoutsTS;                   // keeps record of each payout\r\n    mapping (uint => uint256) public payouts1TS;                   // keeps record of each payout\r\n    mapping (uint => uint256) public payouts2TS;                   // keeps record of each payout\r\n    FEGex2 fegexpair;\r\n    event STAKED(address staker, uint256 tokens);\r\n    event ACTIVATED(address staker, uint256 cost);\r\n    event START(address staker, uint256 tokens);\r\n    event EARNED(address staker, uint256 tokens);\r\n    event UNSTAKED(address staker, uint256 tokens);\r\n    event PAYOUT(uint256 round, uint256 tokens, address sender);\r\n    event PAYOUT1(uint256 round, uint256 tokens, address sender);\r\n    event PAYOUT2(uint256 round, uint256 tokens, address sender);\r\n    event CLAIMEDREWARD(address staker, uint256 reward);\r\n    event CLAIMEDREWARD1(address staker, uint256 reward);\r\n    event CLAIMEDREWARD2(address staker, uint256 reward);\r\n    \r\n    constructor(){\r\n    fegexpair = FEGex2(FETP);\r\n    }\r\n    \r\n    receive() external payable {\r\n    }\r\n\r\n    function changeFEGExPair(FEGex2 _fegexpair, address addy) external onlyOwner{ // Incase FEGex updates in future\r\n        require(address(_fegexpair) != address(0), \"setting 0 to contract\");\r\n        fegexpair = _fegexpair;\r\n        FETP = addy;\r\n    }\r\n    \r\n    function changeTRY(address _try) external onlyOwner{ // Incase TRY updates in future\r\n        TRY = _try;\r\n    }\r\n    \r\n    function changeScalerize(uint _sca) public onlyOwner{\r\n        require(_sca != 0, \"You cannot turn off\");\r\n        scalerize = _sca;\r\n    }\r\n    \r\n    function changeScalatize(uint _scm) public onlyOwner {\r\n        require(_scm != 0, \"You cannot turn off\");\r\n        scaleatize = _scm;\r\n    }\r\n    \r\n    function isStakeholder(address _address)\r\n       public\r\n       view\r\n       returns(bool)\r\n   {\r\n       \r\n       if(stakers[_address].initialized) return true;\r\n       else return false;\r\n   }\r\n   \r\n   function addStakeholder(address _stakeholder)\r\n       internal\r\n   {\r\n       (bool _isStakeholder) = isStakeholder(_stakeholder);\r\n       if(!_isStakeholder) {\r\n           farmTime[msg.sender] =  block.timestamp;\r\n           stakers[_stakeholder].initialized = true;\r\n       }\r\n   }\r\n   \r\n   // ------------------------------------------------------------------------\r\n    // Token holders can stake their tokens using this function\r\n    // @param tokens number of tokens to stake\r\n    // ------------------------------------------------------------------------\r\n\r\n    function calcPoolInGivenSingleOut(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint poolAmountIn)\r\n    {\r\n\r\n\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n        uint zar = bmul(bsub(BASE, normalizedWeight), swapFee);\r\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BASE, zar));\r\n\r\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\r\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\r\n\r\n\r\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\r\n\r\n\r\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BASE, 0));\r\n        return (poolAmountIn);\r\n    }\r\n    \r\n    function calcSingleOutGivenPoolIn(\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint poolAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut)\r\n    {\r\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\r\n\r\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BASE, 0));\r\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\r\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\r\n\r\n\r\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BASE, normalizedWeight));\r\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\r\n        uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\r\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BASE, zaz));\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    function calcPoolOutGivenSingleIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint poolSupply,\r\n        uint totalWeight,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint poolAmountOut)\r\n    {\r\n\r\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\r\n        uint zaz = bmul(bsub(BASE, normalizedWeight), swapFee);\r\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BASE, zaz));\r\n\r\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\r\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\r\n\r\n \r\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\r\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\r\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\r\n        return (poolAmountOut);\r\n    }\r\n     \r\n    function calcOutGivenIn(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountIn,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountOut, uint tokenInFee)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\r\n        uint adjustedIn = bsub(BASE, swapFee);\r\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\r\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\r\n        uint foo = bpow(y, weightRatio);\r\n        uint bar = bsub(BASE, foo);\r\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\r\n        tokenInFee = bsub(tokenAmountIn, adjustedIn);\r\n        return (tokenAmountOut, tokenInFee);\r\n    }\r\n\r\n    function calcInGivenOut(\r\n        uint tokenBalanceIn,\r\n        uint tokenWeightIn,\r\n        uint tokenBalanceOut,\r\n        uint tokenWeightOut,\r\n        uint tokenAmountOut,\r\n        uint swapFee\r\n    )\r\n        public pure\r\n        returns (uint tokenAmountIn)\r\n    {\r\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\r\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\r\n        uint y = bdiv(tokenBalanceOut, diff);\r\n        uint foo = bpow(y, weightRatio);\r\n        foo = bsub(foo, BASE);\r\n        foo = bmul(tokenBalanceIn, foo);\r\n        tokenAmountIn = bsub(BASE, swapFee);\r\n        tokenAmountIn = bdiv(foo, tokenAmountIn);\r\n        return (tokenAmountIn);\r\n    }\r\n\r\n    function activateUserStaking() public payable{ // Activation of FEGstake costs 0.02 bnb which is automatically refunded to your wallet in the form of TRY.\r\n        require(msg.value == must, \"You must deposit the right amount to activate\");\r\n      \r\n        fegexpair.BUY{value: msg.value }(msg.sender, 100);\r\n        stakers[msg.sender].activated = true;\r\n        \r\n        emit ACTIVATED(msg.sender, msg.value);\r\n    }\r\n\r\n    function isActivated(address staker) public view returns(bool){\r\n        if(stakers[staker].activated) return true;\r\n       else return false;\r\n    }\r\n    \r\n    function Start(uint256 tokens) public onlyOwner returns(uint poolAmountOut){\r\n        require(live == false, \"Can only use once\");\r\n        require(IERC20(FEG).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from user for locking\");\r\n        uint256 transferTxFee = (onePercent(tokens).mul(scailment)).div(10);\r\n        uint256 tokensToStake = (tokens.sub(transferTxFee));\r\n        addStakeholder(msg.sender);\r\n\r\n        _mint(tokensToStake);\r\n        live = true;\r\n        IERC20(poolShares).transfer(msg.sender, tokensToStake);\r\n        IERC20(address(fBNB)).approve(address(FETP), 1000000000000000000000e18);        \r\n    \r\n        emit START(msg.sender, tokensToStake);    \r\n        \r\n        return poolAmountOut;\r\n    }\r\n    \r\n    function STAKE(uint256 tokens) public returns(uint poolAmountOut){ \r\n        require(IERC20(FEG).balanceOf(msg.sender) >= tokens, \"You do not have enough FEG\");\r\n        require(stakers[msg.sender].activated == true);\r\n        require(live == true);\r\n        uint256 transferTxFee = (onePercent(tokens).mul(scailment)).div(10);\r\n        uint256 tokensToStake = (tokens.sub(transferTxFee));\r\n        uint256 totalFEG = IERC20(FEG).balanceOf(address(this));\r\n        addStakeholder(msg.sender);\r\n        \r\n        // add pending rewards to remainder to be claimed by user later, if there is any existing stake\r\n            uint256 owing = pendingReward(msg.sender);\r\n            stakers[msg.sender].remainder += owing;\r\n            stakers[msg.sender].lastDividends = owing;\r\n            stakers[msg.sender].fromTotalDividend = totalDividends;\r\n            stakers[msg.sender].round =  round;\r\n            \r\n            uint256 owing1 = pendingReward1(msg.sender);\r\n            stakers[msg.sender].remainder1 += owing1;\r\n            stakers[msg.sender].lastDividends1 = owing1;\r\n            stakers[msg.sender].fromTotalDividend1 = totalDividends1;\r\n            stakers[msg.sender].round1 =  round1;\r\n            \r\n            uint256 owing2 = pendingReward2(msg.sender);\r\n            stakers[msg.sender].remainder2 += owing2;\r\n            stakers[msg.sender].lastDividends2 = owing2;\r\n            stakers[msg.sender].fromTotalDividend2 = totalDividends2;\r\n            stakers[msg.sender].round2 =  round2;\r\n            \r\n        poolAmountOut = calcPoolOutGivenSingleIn(\r\n                            totalFEG,\r\n                            bmul(BASE, 25),\r\n                            _totalSupply,\r\n                            bmul(BASE, 25),\r\n                            tokensToStake,\r\n                            0\r\n                        );\r\n                        \r\n        require(IERC20(FEG).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from user for locking\");                \r\n        _mint(poolAmountOut);\r\n        IERC20(poolShares).transfer(msg.sender, poolAmountOut);\r\n            \r\n        emit STAKED(msg.sender, tokens); \r\n            \r\n        return poolAmountOut;\r\n        \r\n    }\r\n\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Owners can send the funds to be distributed to stakers using this function\r\n    // @param tokens number of tokens to distribute\r\n    // ------------------------------------------------------------------------\r\n\r\n    function ADDFUNDS1(uint256 tokens) public onlyWhitelistAdmin{\r\n        require(IERC20(fBNB).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from funder account\");\r\n        \r\n        uint256 tokens_ = bmul(tokens, bdiv(99, 100));\r\n        totalWrap = badd(totalWrap, tokens_);\r\n        _addPayout(tokens_);\r\n    }\r\n    \r\n    function ADDFUNDS2(uint256 tokens) public onlyWhitelistAdmin{\r\n        require(IERC20(USDT).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from funder account\");\r\n        \r\n        uint256 tokens_ = bmul(tokens, bdiv(99, 100));\r\n        totalWrap1 = badd(totalWrap1, tokens_);\r\n        _addPayout1(tokens_);\r\n    }\r\n    \r\n    function ADDFUNDS3(uint256 tokens) public onlyWhitelistAdmin{\r\n        require(IERC20(BTC).transferFrom(msg.sender, address(this), tokens), \"Tokens cannot be transferred from funder account\");\r\n        uint256 tokens_ = bmul(tokens, bdiv(99, 100));\r\n        totalWrap2 = badd(totalWrap2, tokens_);\r\n        _addPayout2(tokens_);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Private function to register payouts\r\n    // ------------------------------------------------------------------------\r\n    function _addPayout(uint256 tokens_) private {\r\n         // divide the funds among the currently staked tokens\r\n        // scale the deposit and add the previous remainder\r\n        uint256 totalShares = _totalSupply;\r\n        uint256 available = (tokens_.mul(scaling)).add(scaledRemainder); \r\n        uint256 dividendPerToken = available.div(totalShares);\r\n        scaledRemainder = available.mod(totalShares);\r\n        totalDividends = totalDividends.add(dividendPerToken);\r\n        payouts[round] = payouts[round - 1].add(dividendPerToken);\r\n        emit PAYOUT(round, tokens_, msg.sender);\r\n        round++;\r\n        \r\n    }\r\n    \r\n    function _addPayout1(uint256 tokens_1) private{\r\n        // divide the funds among the currently staked tokens\r\n        // scale the deposit and add the previous remainder\r\n        uint256 totalShares = _totalSupply;\r\n        uint256 available = (tokens_1.mul(scaling)).add(scaledRemainder1); \r\n        uint256 dividendPerToken = available.div(totalShares);\r\n        scaledRemainder1 = available.mod(totalShares);\r\n        totalDividends1 = totalDividends1.add(dividendPerToken);\r\n        payouts1[round1] = payouts1[round1 - 1].add(dividendPerToken);\r\n        emit PAYOUT1(round1, tokens_1, msg.sender);\r\n        round1++;\r\n    }\r\n    \r\n    function _addPayout2(uint256 tokens_2) private{\r\n        // divide the funds among the currently staked tokens\r\n        // scale the deposit and add the previous remainder\r\n        uint256 totalShares = _totalSupply;\r\n        uint256 available = (tokens_2.mul(scaling)).add(scaledRemainder2); \r\n        uint256 dividendPerToken = available.div(totalShares);\r\n        scaledRemainder2 = available.mod(totalShares);\r\n        totalDividends2 = totalDividends2.add(dividendPerToken);\r\n        payouts2[round2] = payouts2[round2 - 1].add(dividendPerToken);\r\n        emit PAYOUT2(round2, tokens_2, msg.sender);\r\n        round2++;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Stakers can claim their pending rewards using this function\r\n    // ------------------------------------------------------------------------\r\n    function CLAIMREWARD() public nonReentrant{\r\n        \r\n            uint256 owing = pendingReward(msg.sender);\r\n        if(owing > 0){\r\n            owing = owing.add(stakers[msg.sender].remainder);\r\n            stakers[msg.sender].remainder = 0;\r\n        \r\n            require(IERC20(fBNB).transfer(msg.sender,owing), \"ERROR: error in sending reward from contract\");\r\n        \r\n            emit CLAIMEDREWARD(msg.sender, owing);\r\n            totalWrap = bsub(totalWrap, owing);\r\n            stakers[msg.sender].lastDividends = owing; // unscaled\r\n            stakers[msg.sender].round = round; // update the round\r\n            stakers[msg.sender].fromTotalDividend = totalDividends; // scaled\r\n        }\r\n    }\r\n    \r\n    function CLAIMREWARD1() public nonReentrant {\r\n        \r\n            uint256 owing1 = pendingReward1(msg.sender);\r\n        if(owing1 > 0){\r\n            owing1 = owing1.add(stakers[msg.sender].remainder1);\r\n            stakers[msg.sender].remainder1 = 0;\r\n        \r\n            require(IERC20(USDT).transfer(msg.sender,owing1), \"ERROR: error in sending reward from contract\");\r\n        \r\n            emit CLAIMEDREWARD1(msg.sender, owing1);\r\n            totalWrap1 = bsub(totalWrap1, owing1);\r\n            stakers[msg.sender].lastDividends1 = owing1; // unscaled\r\n            stakers[msg.sender].round1 = round1; // update the round\r\n            stakers[msg.sender].fromTotalDividend1 = totalDividends1; // scaled\r\n        }\r\n    }\r\n    \r\n    function CLAIMREWARD2() public nonReentrant {\r\n      \r\n            uint256 owing2 = pendingReward2(msg.sender);\r\n        if(owing2 > 0){\r\n            owing2 = owing2.add(stakers[msg.sender].remainder2);\r\n            stakers[msg.sender].remainder2 = 0;\r\n        \r\n            require(IERC20(BTC).transfer(msg.sender, owing2), \"ERROR: error in sending reward from contract\");\r\n        \r\n            emit CLAIMEDREWARD2(msg.sender, owing2);\r\n            totalWrap2 = bsub(totalWrap2, owing2);\r\n            stakers[msg.sender].lastDividends2 = owing2; // unscaled\r\n            stakers[msg.sender].round2 = round2; // update the round\r\n            stakers[msg.sender].fromTotalDividend2 = totalDividends2; // scaled\r\n        }\r\n    }\r\n    \r\n    function CLAIMALLREWARD() public { \r\n        distribute12();\r\n        CLAIMREWARD();\r\n        CLAIMREWARD1();\r\n        \r\n        if(perform3==true){\r\n        distribute23();    \r\n        CLAIMREWARD2();   \r\n        }\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Get the pending rewards of the staker\r\n    // @param _staker the address of the staker\r\n    // ------------------------------------------------------------------------    \r\n\r\n    function pendingReward(address staker) private returns (uint256) {\r\n        require(staker != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 yourBase = IERC20(poolShares).balanceOf(msg.sender);\r\n        uint stakersRound = stakers[staker].round;\r\n        uint256 amount =  ((totalDividends.sub(payouts[stakersRound - 1])).mul(yourBase)).div(scaling);\r\n        stakers[staker].remainder += ((totalDividends.sub(payouts[stakersRound - 1])).mul(yourBase)) % scaling;\r\n        return (bmul(amount, bdiv(scalerize, 100)));\r\n    }\r\n    \r\n    function pendingReward1(address staker) private returns (uint256) {\r\n        require(staker != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 yourBase = IERC20(poolShares).balanceOf(msg.sender);\r\n        uint stakersRound = stakers[staker].round1;\r\n        uint256 amount1 =  ((totalDividends1.sub(payouts1[stakersRound - 1])).mul(yourBase)).div(scaling);\r\n        stakers[staker].remainder1 += ((totalDividends1.sub(payouts1[stakersRound - 1])).mul(yourBase)) % scaling;\r\n        return (bmul(amount1, bdiv(scalerize, 100)));\r\n    }\r\n    \r\n    function pendingReward2(address staker) private returns (uint256) {\r\n        require(staker != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 yourBase = IERC20(poolShares).balanceOf(msg.sender);\r\n        uint stakersRound = stakers[staker].round2;\r\n        uint256 amount2 =  ((totalDividends2.sub(payouts2[stakersRound - 1])).mul(yourBase)).div(scaling);\r\n        stakers[staker].remainder2 += ((totalDividends2.sub(payouts2[stakersRound - 1])).mul(yourBase)) % scaling;\r\n        return (bmul(amount2, bdiv(scalerize, 100)));\r\n    }\r\n    \r\n    function getPending1(address staker) public view returns(uint256 _pendingReward) {\r\n        require(staker != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 yourBase = IERC20(poolShares).balanceOf(staker);\r\n        uint stakersRound = stakers[staker].round; \r\n        uint256 amount =  ((totalDividends.sub(payouts[stakersRound - 1])).mul(yourBase)).div(scaling);\r\n        amount += ((totalDividends.sub(payouts[stakersRound - 1])).mul(yourBase)) % scaling;\r\n        return (bmul(amount.add(stakers[staker].remainder), bdiv(scalerize, 100)));\r\n    }\r\n    \r\n    function getPending2(address staker) public view returns(uint256 _pendingReward) {\r\n        require(staker != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 yourBase = IERC20(poolShares).balanceOf(staker);\r\n        uint stakersRound = stakers[staker].round1;\r\n        uint256 amount1 = ((totalDividends1.sub(payouts1[stakersRound - 1])).mul(yourBase)).div(scaling);\r\n        amount1 += ((totalDividends1.sub(payouts1[stakersRound - 1])).mul(yourBase)) % scaling;\r\n        return (bmul(amount1.add(stakers[staker].remainder1), bdiv(scalerize, 100)));\r\n    }\r\n    \r\n    function getPending3(address staker) public view returns(uint256 _pendingReward) {\r\n        require(staker != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 yourBase = IERC20(poolShares).balanceOf(staker);\r\n        uint stakersRound = stakers[staker].round2;\r\n        uint256 amount2 =  ((totalDividends2.sub(payouts2[stakersRound - 1])).mul(yourBase)).div(scaling);\r\n        amount2 += ((totalDividends2.sub(payouts2[stakersRound - 1])).mul(yourBase)) % scaling;\r\n        return (bmul(amount2.add(stakers[staker].remainder2), bdiv(scalerize, 100)));\r\n    \r\n    }\r\n        // ------------------------------------------------------------------------\r\n    // Get the FEG balance of the token holder\r\n    // @param user the address of the token holder\r\n    // ------------------------------------------------------------------------\r\n    function userStakedFEG(address user) external view returns(uint256 StakedFEG){\r\n        require(user != address(0), \"ERC20: sending to the zero address\");\r\n        uint256 totalFEG = IERC20(FEG).balanceOf(address(this));\r\n        uint256 yourStakedFEG = calcSingleOutGivenPoolIn(\r\n                            totalFEG, \r\n                            bmul(BASE, 25),\r\n                            _totalSupply,\r\n                            bmul(BASE, 25),\r\n                            IERC20(poolShares).balanceOf(address(user)),\r\n                            0\r\n                        );\r\n        \r\n        return yourStakedFEG;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Stakers can un stake the staked tokens using this function\r\n    // @param tokens the number of tokens to withdraw\r\n    // ------------------------------------------------------------------------\r\n    function WITHDRAW(address to, uint256 _tokens) external returns (uint tokenAmountOut) {\r\n        uint256 totalFEG = IERC20(FEG).balanceOf(address(this));\r\n        require(stakers[msg.sender].activated == true);\r\n        \r\n        if(perform==true) {\r\n        regreward(regrewardContract).distributeV2();\r\n        }\r\n        \r\n        CLAIMALLREWARD();\r\n\r\n        uint256 tokens = calcPoolInGivenSingleOut(\r\n                            totalFEG,\r\n                            bmul(BASE, 25),\r\n                            _totalSupply,\r\n                            bmul(BASE, 25),\r\n                            _tokens,\r\n                            0\r\n                        );\r\n                        \r\n        tokenAmountOut = calcSingleOutGivenPoolIn(\r\n                            totalFEG, \r\n                            bmul(BASE, 25),\r\n                            _totalSupply,\r\n                            bmul(BASE, 25),\r\n                            tokens,\r\n                            0\r\n                        ); \r\n        require(tokens <= IERC20(poolShares).balanceOf(msg.sender), \"You don't have enough FEG\");\r\n        _pullPoolShare(tokens);\r\n        _burn(tokens);\r\n        require(IERC20(FEG).transfer(to, tokenAmountOut), \"Error in un-staking tokens\");\r\n        \r\n        emit UNSTAKED(msg.sender, tokens);\r\n        \r\n        return tokenAmountOut;\r\n    }\r\n    \r\n    function _pullPoolShare(uint amount)\r\n        internal\r\n    {\r\n        bool xfer = IERC20(poolShares).transferFrom(msg.sender, address(this), amount);\r\n        require(xfer, \"ERR_ERC20_FALSE\");\r\n    }    \r\n\r\n    // ------------------------------------------------------------------------\r\n    // Private function to calculate 1% percentage\r\n    // ------------------------------------------------------------------------\r\n    function onePercent(uint256 _tokens) private pure returns (uint256){\r\n        uint256 roundValue = _tokens.ceil(100);\r\n        uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2));\r\n        return onePercentofTokens;\r\n    }\r\n    \r\n    function emergencySaveLostTokens(address to, address _token, uint256 _amt) public onlyOwner {\r\n        require(_token != FEG, \"Cannot remove users FEG\");\r\n        require(_token != fBNB, \"Cannot remove users wBNB\");\r\n        require(_token != USDT, \"Cannot remove users fUSDT\");\r\n        require(_token != BTC, \"Cannot remove users fBTC\");\r\n        require(IERC20(_token).transfer(to, _amt), \"Error in retrieving tokens\");\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n    \r\n    function changeregrewardContract(address _regrewardContract) external onlyOwner{\r\n        require(address(_regrewardContract) != address(0), \"setting 0 to contract\");\r\n        regrewardContract = _regrewardContract;\r\n    }\r\n   \r\n    function changePerform(bool _bool) external onlyOwner{\r\n        perform = _bool;\r\n    }\r\n\r\n    function changePerform2(bool _bool) external onlyOwner{\r\n        perform2 = _bool;\r\n    }\r\n    \r\n    function changePerform3(bool _bool) external onlyOwner{\r\n        perform3 = _bool;\r\n    }\r\n    \r\n    function changeMust(uint256 _must) external onlyOwner{\r\n        require(must !=0, \"Cannot set to 0\");\r\n        require(must <= 2e16, \"Cannot set over 0.02 BNB\");\r\n        must = _must;\r\n    }\r\n    \r\n    function updateBase(address _BTC, address _BNB, address _USDT) external onlyOwner{ // Incase wraps ever update\r\n        BTC = _BTC;\r\n        fBNB = _BNB;\r\n        USDT = _USDT;\r\n    }\r\n    \r\n    function distribute12() public {\r\n        if (IERC20(fBNB).balanceOf(address(this)) > badd(totalWrap, scaletor))  {\r\n        distributeWrap1();\r\n        }\r\n        \r\n        if(IERC20(USDT).balanceOf(address(this)) > badd(totalWrap1, scaletor1)){\r\n        distributeWrap2();\r\n        }\r\n    }\r\n    \r\n    function distribute23() public {    \r\n        if(perform3==true){\r\n            if(IERC20(BTC).balanceOf(address(this)) > badd(totalWrap2, scaletor2)){\r\n        distributeWrap3();}\r\n        }\r\n    }\r\n    \r\n    function changeScaletor(uint256 _sca, uint256 _sca1, uint256 _sca2) public onlyOwner {\r\n        require(_sca !=0 && _sca1 !=0 && _sca2 !=0, \"You cannot turn off\");\r\n        require(_sca >= 5e17 && _sca1 >= 20e18 && _sca2 >= 1e15, \"Must be over minimum\");\r\n        scaletor = _sca;\r\n        scaletor1 = _sca1;\r\n        scaletor2 = _sca2;\r\n    }\r\n    \r\n    function distributeWrap1() internal {\r\n        uint256 wrapped = bsub(IERC20(fBNB).balanceOf(address(this)), totalWrap);\r\n        totalWrap = badd(totalWrap, wrapped);\r\n        _addPayout(wrapped);\r\n    }\r\n\r\n    function distributeWrap2() internal {\r\n        uint256 wrapped = bsub(IERC20(USDT).balanceOf(address(this)), totalWrap1);\r\n        totalWrap1 = badd(totalWrap1, wrapped);\r\n        _addPayout1(wrapped);\r\n    }\r\n    \r\n    function distributeWrap3() internal {\r\n        uint256 wrapped = bsub(IERC20(BTC).balanceOf(address(this)), totalWrap2);\r\n        totalWrap2 = badd(totalWrap2, wrapped);\r\n        _addPayout2(wrapped);\r\n    }\r\n    }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"ACTIVATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CLAIMEDREWARD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CLAIMEDREWARD1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CLAIMEDREWARD2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"EARNED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PAYOUT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PAYOUT1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PAYOUT2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"STAKED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"START\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"UNSTAKED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ADDFUNDS1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ADDFUNDS2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ADDFUNDS3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIMALLREWARD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIMREWARD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIMREWARD1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIMREWARD2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FETP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"STAKE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"WITHDRAW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateUserStaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FEGex2\",\"name\":\"_fegexpair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"changeFEGExPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_must\",\"type\":\"uint256\"}],\"name\":\"changeMust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changePerform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changePerform2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"changePerform3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_scm\",\"type\":\"uint256\"}],\"name\":\"changeScalatize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sca\",\"type\":\"uint256\"}],\"name\":\"changeScalerize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sca\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sca1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sca2\",\"type\":\"uint256\"}],\"name\":\"changeScaletor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_try\",\"type\":\"address\"}],\"name\":\"changeTRY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_regrewardContract\",\"type\":\"address\"}],\"name\":\"changeregrewardContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute12\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute23\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"emergencySaveLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"farmTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getPending1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getPending2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getPending3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isStakeholder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"must\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts1TS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts2TS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payoutsTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perform\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perform2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"perform3\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolShares\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regrewardContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"round2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scailment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaleatize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scalerize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaletor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaletor1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaletor2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWrap1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWrap2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWrapRef\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWrapRef1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWrapRef2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BTC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BNB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_USDT\",\"type\":\"address\"}],\"name\":\"updateBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userStakedFEG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"StakedFEG\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FEGstakeV2", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a222b7cf9ff6aa183408f120b1a5c035ff1b61a05fa0e4fdbd8b43be146acc5d"}