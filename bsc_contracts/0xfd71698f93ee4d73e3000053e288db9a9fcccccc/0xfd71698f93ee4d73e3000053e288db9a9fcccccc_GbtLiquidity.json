{"SourceCode": "/***\r\n *      ______  _____         ______  _______ __   _  \r\n *     |  ____ |     | |      |     \\ |______ | \\  |  \r\n *     |_____| |_____| |_____ |_____/ |______ |  \\_|  \r\n *                                                    \r\n *     ______  _______ _______ ______   _____   _____ \r\n *     |_____] |_____| |  |  | |_____] |     | |     |\r\n *     |_____] |     | |  |  | |_____] |_____| |_____|\r\n *                                                    \r\n *     _______  _____  _     _ _______ __   _         \r\n *        |    |     | |____/  |______ | \\  |         \r\n *        |    |_____| |    \\_ |______ |  \\_|         \r\n *                                                    \r\n *     Website: https://gbt.gold\r\n *     Twitter(X): https://twitter.com/gbt_gold\r\n *     Telegram: https://t.me/gbt_gold\r\n *     Email: gbt@gbt.im\r\n */\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.8.19;\r\n\r\ninterface Broker {\r\n    function userInvestTotal(address) external view returns (uint256);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance < requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor () {}\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function changeOwner(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ncontract GbtLiquidity is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public _usdt;\r\n    address public _token;\r\n    address public _broker;\r\n    address public _broker1;\r\n    uint private _decimals;\r\n    // Reward multiplier\r\n    uint public _rewardTimes;\r\n    //Minimum added liquidity amount\r\n    uint public _minAdd;\r\n    // Minimum LP for entry\r\n    uint public _minLp;\r\n    // LP amount to trigger stop of new entries\r\n    uint public _helpLp;\r\n    // Number of online orders\r\n    uint public _currentOrderNum;\r\n\r\n    // Virtual U Pool quantity\r\n    uint public virtualUPool;\r\n    // Virtual LP Pool quantity\r\n    uint public virtualLPPool;\r\n    // Total dividends already distributed for online orders\r\n    uint public totalDividends;\r\n    // Default precision of virtual lp pool\r\n    uint public _calculateVirtualDecimals;\r\n\r\n    // Router for Uniswap V2\r\n    IUniswapV2Router02 public _uniswapV2Router;\r\n    // User's liquidity pool information\r\n    mapping(uint => LiquidityInfo) public _userLiquidityInfos;\r\n    uint public _lastLiquidityId;\r\n    mapping(address => uint[]) public _userLiquidityIds;\r\n    mapping(address => uint) public _userInAmountTotal;\r\n    mapping(uint => ClaimInfo[]) public _userClaimInfos;\r\n\r\n    struct ClaimInfo {\r\n        uint time;\r\n        uint amount;\r\n    }\r\n\r\n    struct LiquidityInfo {\r\n        uint id;\r\n        uint time;\r\n        uint amount;\r\n        uint liquify;\r\n        // Status: 0 - waiting for rewards, 1 - rewards ended, 2 - withdrawn\r\n        uint status;\r\n        // Pending rewards to be claimed\r\n        uint interest;\r\n        // Claimed rewards\r\n        uint claim;\r\n        // Number of times rewards have been claimed\r\n        uint claimTimes;\r\n        // Withdrawal time\r\n        uint remove_time;\r\n        // Virtual LP\r\n        uint virtualLP;\r\n        // User's address\r\n        address account;\r\n    }\r\n\r\n    event AddLiquidity(\r\n        address account,\r\n        uint amount\r\n    );\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n    );\r\n    bool private locked;\r\n    modifier nonReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() {\r\n        _lastLiquidityId = 1;\r\n        _rewardTimes = 2;\r\n        _usdt = 0x55d398326f99059fF775485246999027B3197955;\r\n        _token = 0xb0d22255889850F41D3ffA5BA4152f8865AAAAAA;\r\n        _broker = 0xF089427b2e862f419A6063336D3060096FBBBBBB;\r\n        _broker1 = 0x2460064f68DFED945136341F4e3109D2f0BBBBBB;\r\n        _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        _decimals = uint(IERC20(_usdt).decimals());\r\n        _minAdd = 100 * 10 ** _decimals;\r\n        // Minimum LP amount for stopping all new entries across the network\r\n        _helpLp = 1 * 10 ** _decimals;\r\n        _calculateVirtualDecimals = 40;\r\n    }\r\n\r\n    function setAddress(address param, uint status) external onlyOwner {\r\n        if (status == 0) {\r\n            _token = param;\r\n        } else if (status == 1) {\r\n            _broker = param;\r\n        } else if (status == 2) {\r\n            _broker1 = param;\r\n        }\r\n    }\r\n\r\n    function setUint(uint param, uint status) external onlyOwner {\r\n        if (status == 0) {\r\n            _rewardTimes = param;\r\n        } else if (status == 1) {\r\n            _minAdd = param;\r\n        } else if (status == 2) {\r\n            _helpLp = param;\r\n        } else if (status == 3) {\r\n            _calculateVirtualDecimals = param;\r\n        }\r\n    }\r\n    // Check if current entry is allowed\r\n    function canAddLiquidity() public view returns (bool){\r\n        return _minLp == 0 || _minLp > _helpLp;\r\n    }\r\n\r\n    // Add liquidity\r\n    function addLiquidity(uint amount) external nonReentrant(){\r\n        require(amount >= _minAdd, \"Liquidity:The admission amount is too low\");\r\n        uint realAmount = amount.div(1 * 10 ** _decimals);\r\n        require(realAmount.mul(1 * 10 ** _decimals) == amount, \"Liquidity:Add only integers\");\r\n        address account = _msgSender();\r\n        uint invest = Broker(_broker).userInvestTotal(account) + Broker(_broker1).userInvestTotal(account);\r\n        uint liquiditied = _userInAmountTotal[account];\r\n\r\n        // Check if the limit is sufficient\r\n        require(liquiditied.add(amount) <= invest, \"Liquidity:over invest amount\");\r\n        // Check if current entry is allowed\r\n        require(canAddLiquidity(), \"Liquidity:over invest amount\");\r\n        IERC20(_usdt).safeTransferFrom(account, address(this), amount);\r\n        // Exchange and add to liquidity pool\r\n        uint addLiquidityNum = _swapAndLiquify(amount);\r\n        // Liquidity record\r\n        LiquidityInfo storage info = _userLiquidityInfos[_lastLiquidityId];\r\n        info.id = _lastLiquidityId;\r\n        info.time = block.timestamp;\r\n        info.amount = amount;\r\n        info.liquify = addLiquidityNum;\r\n        info.status = 0;\r\n        info.interest = 0;\r\n        info.claim = 0;\r\n        info.claimTimes = 0;\r\n        info.remove_time = 0;\r\n        info.account = account;\r\n\r\n        // User information\r\n        _userInAmountTotal[account] += amount;\r\n        _userLiquidityIds[account].push(_lastLiquidityId);\r\n        // Increment the liquidity ID\r\n        _lastLiquidityId++;\r\n        uint balance = IERC20(_token).balanceOf(address(this));\r\n        if (balance > 0) {\r\n            IERC20(_token).safeTransfer(_token, balance);\r\n        }\r\n        // Calculate virtual LP quantity based on the ratio of virtual LP pool to virtual U pool\r\n        uint virtualLP = calculateVirtualLP(realAmount);\r\n        if (_minLp == 0 || virtualLP < _minLp) {\r\n            // Record the minimum LP\r\n            _minLp = virtualLP;\r\n        }\r\n        // Update virtual U pool quantity\r\n        virtualUPool += realAmount;\r\n        // Update virtual LP pool quantity\r\n        virtualLPPool += virtualLP;\r\n        // Record virtual LP quantity\r\n        info.virtualLP = virtualLP;\r\n        _currentOrderNum++;\r\n        emit AddLiquidity(account, amount);\r\n    }\r\n\r\n    // Remove liquidity\r\n    function removeLiquidity(uint liquidityId) external nonReentrant(){\r\n        address account = _msgSender();\r\n        require(_inArray(liquidityId, _userLiquidityIds[account]), \"no permission\");\r\n\r\n        LiquidityInfo storage info = _userLiquidityInfos[liquidityId];\r\n        require(info.status != 2, \"the order is over\");\r\n        // Claim rewards\r\n        _claim(account, info);\r\n        // Calculate LP value\r\n        uint uAmount = _lpValue(info.liquify, true);\r\n        if (uAmount > 0) {\r\n            // If the value increased, distribute the original U-value LP; If it decreased, distribute the original LP\r\n            if (uAmount.mul(2) > info.amount) {\r\n                // If the value increased\r\n                uint lp = _lpValue(info.amount, false);\r\n                if (lp > 0) {\r\n                    _removeLiquidity(lp, account);\r\n                }\r\n            } else {\r\n                _removeLiquidity(info.liquify, account);\r\n            }\r\n        }\r\n        if (info.status == 0) {\r\n            // Remove virtual information\r\n            _removeVirtuals(info);\r\n        }\r\n        // Set to completed status\r\n        info.status = 2;\r\n        info.remove_time = block.timestamp;\r\n        if (_currentOrderNum == 0) {\r\n            // Reset the minimum LP\r\n            _minLp = 0;\r\n        }\r\n    }\r\n\r\n    // Remove virtual information\r\n    function _removeVirtuals(LiquidityInfo storage info) internal {\r\n        uint amount = info.amount.div(1 * 10 ** _decimals);\r\n        if (virtualUPool >= amount) {\r\n            virtualUPool -= amount;\r\n        } else {\r\n            virtualUPool = 0;\r\n        }\r\n        // Update virtual LP pool quantity\r\n        if (virtualLPPool >= info.virtualLP) {\r\n            virtualLPPool -= info.virtualLP;\r\n        } else {\r\n            virtualLPPool = 0;\r\n        }\r\n        // Deduct totalDividends for the whole network\r\n        totalDividends -= info.claim;\r\n        _currentOrderNum = _currentOrderNum >= 1 ? _currentOrderNum - 1 : 0;\r\n    }\r\n\r\n    // Get a collection of order IDs that are eligible for removal\r\n    function getRemoveIds(uint start, uint end) external view returns (uint[] memory){\r\n        require(start <= end && _lastLiquidityId > 1, \"Order does not exist\");\r\n        uint len = 0;\r\n        if (start == 0 && end == 0) {\r\n            len = _lastLiquidityId - 1;\r\n            start = 1;\r\n            end = len;\r\n        } else {\r\n            len = end - start > 0 ? (end - start) : 1;\r\n        }\r\n        uint success;\r\n        uint[] memory ids = new uint[](len);\r\n        for (uint i = start; i <= end; i++) {\r\n            LiquidityInfo memory info = _userLiquidityInfos[i];\r\n            if (info.status == 0 && info.amount > 0) {\r\n                // Only check orders that meet the conditions for elimination\r\n                if (getInterest(i).add(info.claim) >= info.amount.mul(_rewardTimes)) {\r\n                    ids[success++] = i;\r\n                }\r\n            }\r\n        }\r\n        return ids;\r\n    }\r\n\r\n    // Help all orders on the network to be removed\r\n    function helpRemove(uint[] calldata ids) external nonReentrant() {\r\n        require(_lastLiquidityId > 1, 'No order execution');\r\n        uint successed;\r\n        for (uint i; i < ids.length; i++) {\r\n            LiquidityInfo storage info = _userLiquidityInfos[ids[i]];\r\n            require(info.amount > 0 && info.status == 0, \"The order does not meet the conditions\");\r\n            // Only check orders that meet the conditions for elimination\r\n            if (getInterest(ids[i]).add(info.claim) >= info.amount.mul(_rewardTimes)) {\r\n                _claim(info.account, info);\r\n                successed++;\r\n            }\r\n        }\r\n        if (successed == 0) {\r\n            revert('Orders that have not been eliminated');\r\n        }\r\n    }\r\n\r\n    // Get the actual virtual U pool quantity\r\n    function _realVirtualUPool() public view returns (uint){\r\n        uint balance = IERC20(_usdt).balanceOf(address(this));\r\n        if (balance > 0) {\r\n            balance = balance.div(1 * 10 ** _decimals);\r\n        }\r\n        uint _totalDividends = totalDividends;\r\n        if (_totalDividends > 0) {\r\n            _totalDividends = _totalDividends.div(1 * 10 ** _decimals);\r\n        }\r\n        return virtualUPool.add(balance).add(_totalDividends);\r\n    }\r\n\r\n    // Transfer tokens\r\n    function _transfer(address token, address account, uint amount) internal {\r\n        if (IERC20(token).balanceOf(address(this)) < amount) {\r\n            amount = IERC20(token).balanceOf(address(this));\r\n        }\r\n        if (amount > 0) {\r\n            IERC20(token).safeTransfer(account, amount);\r\n        }\r\n    }\r\n\r\n    // Remove specific liquidity\r\n    function _removeLiquidity(uint lp, address account) internal {\r\n        uint amount = IERC20(_lpToken()).balanceOf(address(this));\r\n        if (lp > amount) {\r\n            lp = amount;\r\n        }\r\n        if (lp > 0) {\r\n            IERC20(_lpToken()).safeIncreaseAllowance(address(_uniswapV2Router), lp);\r\n            _uniswapV2Router.removeLiquidity(_usdt, _token, lp, 0, 0, account, block.timestamp);\r\n        }\r\n    }\r\n\r\n    // Calculate the virtual LP quantity of the order\r\n    function calculateVirtualLP(uint enterAmount) private view returns (uint) {\r\n        if (virtualLPPool == 0) {\r\n            // If there is no LP in the virtual LP pool, the virtual LP quantity is equal to the USDT amount of the order (with 18 decimals by default)\r\n            return enterAmount * 10 ** _calculateVirtualDecimals;\r\n        } else {\r\n            // If there is LP in the virtual LP pool, calculate the virtual LP quantity based on the formula\r\n            return enterAmount.mul(virtualLPPool).div(_realVirtualUPool());\r\n        }\r\n    }\r\n    // Calculate the withdrawable amount for an order\r\n    function calculateDividends(uint liquidityId) private view returns (uint) {\r\n        LiquidityInfo memory info = _userLiquidityInfos[liquidityId];\r\n        if (info.status == 1 || info.status == 2 || info.account == address(0)) {\r\n            return 0;\r\n        }\r\n        // Calculate the withdrawable amount: order amount * 2 - claimed - (current market value - entry amount)\r\n        uint realVirtualUPool = _realVirtualUPool();\r\n        uint uAmount = info.virtualLP.mul(realVirtualUPool).mul(1 * 10 ** _decimals).div(virtualLPPool);\r\n        uint withdrawableAmount = uAmount < info.amount ? 0 : uAmount.sub(info.amount);\r\n        if (withdrawableAmount > 0 && withdrawableAmount > info.amount.mul(_rewardTimes)) {\r\n            withdrawableAmount = info.amount.mul(_rewardTimes);\r\n        }\r\n        if (withdrawableAmount >= info.claim) {\r\n            withdrawableAmount = withdrawableAmount.sub(info.claim);\r\n        } else {\r\n            withdrawableAmount = 0;\r\n        }\r\n\r\n        return withdrawableAmount;\r\n    }\r\n\r\n    // Get the U value of LP\r\n    function _lpValue(uint amount, bool status) internal view returns (uint){\r\n        address pair = _lpToken();\r\n        (uint reserve1,uint reserve2,) = IUniswapV2Pair(pair).getReserves();\r\n        if (IUniswapV2Pair(pair).token0() == _token) {\r\n            reserve1 = reserve2;\r\n        }\r\n        if (status == true) {\r\n            // Calculate how much U for a certain LP value\r\n            return amount.mul(reserve1).div(IUniswapV2Pair(pair).totalSupply());\r\n        } else {\r\n            // Calculate how much LP for a certain U value; divide by 2 because the trading pair is 2 times U\r\n            return amount.mul(IUniswapV2Pair(pair).totalSupply()).div(reserve1).div(2);\r\n        }\r\n    }\r\n\r\n    function _lpToken() internal view returns (address){\r\n        return IUniswapV2Factory(_uniswapV2Router.factory()).getPair(_token, _usdt);\r\n    }\r\n\r\n    // Claim rewards\r\n    function claim(uint liquidityId) external nonReentrant(){\r\n        address account = _msgSender();\r\n        require(_inArray(liquidityId, _userLiquidityIds[account]), \"no permission\");\r\n\r\n        LiquidityInfo storage info = _userLiquidityInfos[liquidityId];\r\n        require(info.status != 2, \"the order is over\");\r\n        // Claim rewards\r\n        _claim(account, info);\r\n    }\r\n\r\n    function _claim(address account, LiquidityInfo storage info) internal {\r\n        uint amount = calculateDividends(info.id);\r\n        if (amount > 0) {\r\n            _transfer(_usdt, account, amount);\r\n            info.claim += amount;\r\n            // Total dividends\r\n            totalDividends += amount;\r\n            info.claimTimes++;\r\n            if (info.status == 0 && info.claim >= info.amount.mul(_rewardTimes)) {\r\n                // End the order\r\n                info.status = 1;\r\n                // Remove virtual information\r\n                _removeVirtuals(info);\r\n            }\r\n            _userClaimInfos[info.id].push(ClaimInfo(block.timestamp, amount));\r\n            if (_currentOrderNum == 0) {\r\n                // Reset the minimum LP\r\n                _minLp = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _inArray(uint id, uint[] memory ids) internal pure returns (bool){\r\n        for (uint i; i < ids.length; i++) {\r\n            if (ids[i] == id) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    event SendReward(uint reward);\r\n\r\n    // Get the real withdrawable interest for the current order\r\n    function getInterest(uint infoId) public view returns (uint amount){\r\n        return calculateDividends(infoId);\r\n    }\r\n\r\n    // Exchange and add to the liquidity pool\r\n    function _swapAndLiquify(uint256 tokens) private returns (uint){\r\n        // Split the contract balance into halves\r\n        uint256 half = tokens.div(2);\r\n        uint256 otherHalf = tokens.sub(half);\r\n\r\n        // Swap tokens for USDT\r\n        _swapTokensForTokensTo(half, address(this));\r\n        // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\r\n\r\n        uint256 newBalance = IERC20(_token).balanceOf(address(this));\r\n        // Add liquidity to Uniswap\r\n        emit SwapAndLiquify(half, newBalance, otherHalf);\r\n        return _addLiquidityTokens(otherHalf, newBalance);\r\n    }\r\n\r\n    function _swapTokensForTokensTo(uint256 tokenAmount, address to) private {\r\n        // Generate the Uniswap pair path of token -> USDT\r\n        address[] memory path = new address[](2);\r\n        path[0] = _usdt;\r\n        path[1] = _token;\r\n\r\n        IERC20(_usdt).safeIncreaseAllowance(address(_uniswapV2Router), tokenAmount);\r\n\r\n        // Make the swap\r\n        _uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // Accept any amount of ETH\r\n            path,\r\n            to,\r\n            block.timestamp\r\n        );\r\n\r\n    }\r\n\r\n    function _addLiquidityTokens(uint256 uAmount, uint256 tokenAmount) private returns (uint liquidityNum){\r\n        // Approve token transfer to cover all possible scenarios\r\n        IERC20(_token).safeIncreaseAllowance(address(_uniswapV2Router), tokenAmount);\r\n        IERC20(_usdt).safeIncreaseAllowance(address(_uniswapV2Router), uAmount);\r\n        // Add the liquidity\r\n        (,, liquidityNum) = _uniswapV2Router.addLiquidity(\r\n            _usdt,\r\n            _token,\r\n            uAmount,\r\n            tokenAmount,\r\n            0, // Slippage is unavoidable\r\n            0, // Slippage is unavoidable\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // Get the total principal amount\r\n    function userInAmountSum(address account) external view returns (uint sum){\r\n        for (uint i; i < _userLiquidityIds[account].length; i++) {\r\n            LiquidityInfo memory info = _userLiquidityInfos[_userLiquidityIds[account][i]];\r\n            if (info.status == 0) {\r\n                sum += info.amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get the user's liquidity IDs collection\r\n    function getUserLiquidityIds(address account) public view returns (uint[] memory ids){\r\n        uint[] memory temp = new uint[](_userLiquidityIds[account].length);\r\n        for (uint i; i < _userLiquidityIds[account].length; i++) {\r\n            temp[i] = _userLiquidityIds[account][i];\r\n        }\r\n        ids = temp;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"SendReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_broker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_broker1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_calculateVirtualDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_currentOrderNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_helpLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastLiquidityId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minAdd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_realVirtualUPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userClaimInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userInAmountTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userLiquidityIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userLiquidityInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquify\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remove_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"virtualLP\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"infoId\",\"type\":\"uint256\"}],\"name\":\"getInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getRemoveIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserLiquidityIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"helpRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityId\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"param\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"param\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setUint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userInAmountSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualLPPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualUPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GbtLiquidity", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0fd0a174e7fd09ee669422a82221c1850553311c8b4cffc482966beea2125019"}