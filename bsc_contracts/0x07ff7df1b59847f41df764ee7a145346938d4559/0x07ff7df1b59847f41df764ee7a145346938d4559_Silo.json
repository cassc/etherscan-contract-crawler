{"SourceCode": "/*\r\n    SPDX-License-Identifier: MIT\r\n    farm.br34p.finance \r\n*/\r\n\r\npragma solidity ^0.6.12;\r\n\r\ninterface Token {\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\n\r\n// import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\";\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\";\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ncontract Silo is Ownable, Pausable {\r\n\r\n    using SafeMath for uint;\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /// @dev Only people with tokens\r\n    modifier onlyBagholders {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev Only people with profits\r\n    modifier onlyStronghands {\r\n        require(myDividends() > 0);\r\n        _;\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n\r\n\r\n    event onLeaderBoard(\r\n        address indexed customerAddress,\r\n        uint256 invested,\r\n        uint256 tokens,\r\n        uint256 soldTokens,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenPurchase(\r\n        address indexed customerAddress,\r\n        uint256 incomingeth,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed customerAddress,\r\n        uint256 tokensBurned,\r\n        uint256 ethEarned,\r\n        uint timestamp\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed customerAddress,\r\n        uint256 ethReinvested,\r\n        uint256 tokensMinted,\r\n        uint timestamp\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 ethWithdrawn,\r\n        uint timestamp\r\n    );\r\n\r\n\r\n    event onTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 tokens,\r\n        uint timestamp\r\n    );\r\n\r\n    event onBalance(\r\n        uint256 balance,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onDonation(\r\n        address indexed from,\r\n        uint256 amount,\r\n        uint timestamp\r\n    );\r\n\r\n    // Onchain Stats!!!\r\n    struct Stats {\r\n        uint invested;\r\n        uint reinvested;\r\n        uint withdrawn;\r\n        uint rewarded;\r\n        uint contributed;\r\n        uint transferredTokens;\r\n        uint receivedTokens;\r\n        uint xInvested;\r\n        uint xReinvested;\r\n        uint xRewarded;\r\n        uint xContributed;\r\n        uint xWithdrawn;\r\n        uint xTransferredTokens;\r\n        uint xReceivedTokens;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n\r\n    /// @dev 15% dividends for token purchase\r\n    uint8 constant internal entryFee_ = 10;\r\n\r\n\r\n    /// @dev 5% dividends for token selling\r\n    uint8 constant internal exitFee_ = 10;\r\n\r\n    uint8 constant internal dripFee = 80;  //80% of fees go to drip, the rest to the Swap buyback\r\n\r\n    uint8 constant payoutRate_ = 2;\r\n\r\n    uint256 constant internal magnitude = 2 ** 64;\r\n\r\n    /*=================================\r\n     =            DATASETS            =\r\n     ================================*/\r\n\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) private tokenBalanceLedger_;\r\n    mapping(address => int256) private payoutsTo_;\r\n    mapping(address => Stats) private stats;\r\n    //on chain referral tracking\r\n    uint256 private tokenSupply_;\r\n    uint256 private profitPerShare_;\r\n    uint256 public totalDeposits;\r\n    uint256 internal lastBalance_;\r\n\r\n    uint public players;\r\n    uint public totalTxs;\r\n    uint public dividendBalance_;\r\n    uint public lastPayout;\r\n    uint public totalClaims;\r\n\r\n    uint256 public balanceInterval = 6 hours;\r\n    uint256 public distributionInterval = 2 seconds;\r\n\r\n    address public tokenAddress;\r\n\r\n    Token private token;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS           =\r\n    =======================================*/\r\n\r\n    constructor(address _tokenAddress) public {\r\n\r\n        tokenAddress = _tokenAddress;\r\n        token = Token(_tokenAddress);\r\n\r\n        lastPayout = now;\r\n\r\n    }\r\n\r\n\r\n    /// @dev This is how you pump pure \"drip\" dividends into the system\r\n    function donatePool(uint amount) public returns (uint256) {\r\n        require(token.transferFrom(msg.sender, address(this),amount));\r\n\r\n        dividendBalance_ += amount;\r\n\r\n        emit onDonation(msg.sender, amount,now);\r\n    }\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buy(uint buy_amount) public whenNotPaused returns (uint256)  {\r\n        return buyFor(msg.sender, buy_amount);\r\n    }\r\n\r\n\r\n    /// @dev Converts all incoming eth to tokens for the caller, and passes down the referral addy (if any)\r\n    function buyFor(address _customerAddress, uint buy_amount) public whenNotPaused returns (uint256)  {\r\n        require(token.transferFrom(_customerAddress, address(this), buy_amount));\r\n        totalDeposits += buy_amount;\r\n        uint amount = purchaseTokens(_customerAddress, buy_amount);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n\r\n        return amount;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Fallback function to return any BNB accidentally sent to the contract\r\n     */\r\n    receive() external payable {\r\n        require(false);\r\n    }\r\n\r\n    /// @dev Converts all of caller's dividends to tokens.\r\n    function reinvest() onlyStronghands public {\r\n        // fetch dividends\r\n        uint256 _dividends = myDividends();\r\n        // retrieve ref. bonus later in the code\r\n\r\n        // pay out the dividends virtually\r\n        address _customerAddress = msg.sender;\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n        // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n        uint256 _tokens = purchaseTokens(msg.sender, _dividends);\r\n\r\n        // fire event\r\n        emit onReinvestment(_customerAddress, _dividends, _tokens, now);\r\n\r\n        //Stats\r\n        stats[_customerAddress].reinvested = SafeMath.add(stats[_customerAddress].reinvested, _dividends);\r\n        stats[_customerAddress].xReinvested += 1;\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /// @dev Withdraws all of the callers earnings.\r\n    function withdraw() onlyStronghands public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myDividends();\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n\r\n        // lambo delivery service\r\n        token.transfer(_customerAddress,_dividends);\r\n\r\n        //stats\r\n        stats[_customerAddress].withdrawn = SafeMath.add(stats[_customerAddress].withdrawn, _dividends);\r\n        stats[_customerAddress].xWithdrawn += 1;\r\n        totalTxs += 1;\r\n        totalClaims += _dividends;\r\n\r\n        // fire event\r\n        emit onWithdraw(_customerAddress, _dividends, now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n\r\n    /// @dev Liquifies tokens to eth.\r\n    function sell(uint256 _amountOfTokens) onlyBagholders public {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_amountOfTokens, exitFee_) / 100;\r\n        uint256 _taxedeth = SafeMath.sub(_amountOfTokens, _undividedDividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _amountOfTokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens + (_taxedeth * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenSell(_customerAddress, _amountOfTokens, _taxedeth, now);\r\n\r\n        //distribute\r\n        distribute();\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from the caller to a new holder.\r\n    *  Zero fees\r\n    */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders external returns (bool) {\r\n        // setup\r\n        address _customerAddress = msg.sender;\r\n\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        // withdraw all outstanding dividends first\r\n        if (myDividends() > 0) {\r\n            withdraw();\r\n        }\r\n\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _amountOfTokens);\r\n\r\n\r\n\r\n        /* Members\r\n            A player can be initialized by buying or receiving and we want to add the user ASAP\r\n         */\r\n        if (stats[_toAddress].invested == 0 && stats[_toAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        //Stats\r\n        stats[_customerAddress].xTransferredTokens += 1;\r\n        stats[_customerAddress].transferredTokens += _amountOfTokens;\r\n        stats[_toAddress].receivedTokens += _amountOfTokens;\r\n        stats[_toAddress].xReceivedTokens += 1;\r\n        totalTxs += 1;\r\n\r\n        // fire event\r\n        emit onTransfer(_customerAddress, _toAddress, _amountOfTokens,now);\r\n\r\n        emit onLeaderBoard(_customerAddress,\r\n            stats[_customerAddress].invested,\r\n            tokenBalanceLedger_[_customerAddress],\r\n            stats[_customerAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        emit onLeaderBoard(_toAddress,\r\n            stats[_toAddress].invested,\r\n            tokenBalanceLedger_[_toAddress],\r\n            stats[_toAddress].withdrawn,\r\n            now\r\n        );\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n\r\n    /*=====================================\r\n    =      HELPERS AND CALCULATORS        =\r\n    =====================================*/\r\n\r\n    /**\r\n     * @dev Method to view the current eth stored in the contract\r\n     */\r\n    function totalTokenBalance() public view returns (uint256) {\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Retrieve the total token supply.\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /// @dev Retrieve the tokens owned by the caller.\r\n    function myTokens() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the dividends owned by the caller.\r\n     */\r\n    function myDividends() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return dividendsOf(_customerAddress);\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function balanceOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /// @dev Retrieve the token balance of any single address.\r\n    function tokenBalance(address _customerAddress) public view returns (uint256) {\r\n        return _customerAddress.balance;\r\n    }\r\n\r\n    /// @dev Retrieve the dividend balance of any single address.\r\n    function dividendsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n\r\n\r\n    /// @dev Return the sell price of 1 individual token.\r\n    function sellPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Return the buy price of 1 individual token.\r\n    function buyPrice() public pure returns (uint256) {\r\n        uint256 _eth = 1e18;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.add(_eth, _dividends);\r\n\r\n        return _taxedeth;\r\n\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n    function calculateTokensReceived(uint256 _ethToSpend) public pure returns (uint256) {\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_ethToSpend, entryFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_ethToSpend, _dividends);\r\n        uint256 _amountOfTokens = _taxedeth;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /// @dev Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n    function calculateethReceived(uint256 _tokensToSell) public view returns (uint256) {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _eth = _tokensToSell;\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_eth, exitFee_), 100);\r\n        uint256 _taxedeth = SafeMath.sub(_eth, _dividends);\r\n        return _taxedeth;\r\n    }\r\n\r\n\r\n    /// @dev Stats of any single address\r\n    function statsOf(address _customerAddress) public view returns (uint256[14] memory){\r\n        Stats memory s = stats[_customerAddress];\r\n        uint256[14] memory statArray = [s.invested, s.withdrawn, s.rewarded, s.contributed, s.transferredTokens, s.receivedTokens, s.xInvested, s.xRewarded, s.xContributed, s.xWithdrawn, s.xTransferredTokens, s.xReceivedTokens, s.reinvested, s.xReinvested];\r\n        return statArray;\r\n    }\r\n\r\n\r\n    function dailyEstimate(address _customerAddress) public view returns (uint256){\r\n        uint256 share = dividendBalance_.mul(payoutRate_).div(100);\r\n\r\n        return (tokenSupply_ > 0) ? share.mul(tokenBalanceLedger_[_customerAddress]).div(tokenSupply_) : 0;\r\n    }\r\n\r\n\r\n    function allocateFees(uint fee) private {\r\n\r\n\r\n        // 1/5 paid out instantly\r\n        uint256 instant = fee.div(5);\r\n\r\n        if (tokenSupply_ > 0) {\r\n            // Apply instant divs\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (instant * magnitude) / tokenSupply_);\r\n        }\r\n\r\n        // Add 4/5 to dividend drip pools\r\n        dividendBalance_ += fee.safeSub(instant);\r\n    }\r\n\r\n    function distribute() private {\r\n\r\n        if (now.safeSub(lastBalance_) > balanceInterval) {\r\n            emit onBalance(totalTokenBalance(), now);\r\n            lastBalance_ = now;\r\n        }\r\n\r\n\r\n        if (SafeMath.safeSub(now, lastPayout) > distributionInterval && tokenSupply_ > 0) {\r\n\r\n            //A portion of the dividend is paid out according to the rate\r\n            uint256 share = dividendBalance_.mul(payoutRate_).div(100).div(24 hours);\r\n            //divide the profit by seconds in the day\r\n            uint256 profit = share * now.safeSub(lastPayout);\r\n            //share times the amount of time elapsed\r\n            dividendBalance_ = dividendBalance_.safeSub(profit);\r\n\r\n            //Apply divs\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (profit * magnitude) / tokenSupply_);\r\n\r\n            lastPayout = now;\r\n        }\r\n\r\n    }\r\n    \r\n    function pause() onlyOwner public {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() onlyOwner public {\r\n        _unpause();\r\n    }\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    /// @dev Internal function to actually purchase the tokens.\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingeth) internal returns (uint256) {\r\n\r\n        /* Members */\r\n        if (stats[_customerAddress].invested == 0 && stats[_customerAddress].receivedTokens == 0) {\r\n            players += 1;\r\n        }\r\n\r\n        totalTxs += 1;\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.mul(_incomingeth, entryFee_) / 100;\r\n        uint256 _amountOfTokens = SafeMath.sub(_incomingeth, _undividedDividends);\r\n\r\n        // fire event\r\n        emit onTokenPurchase(_customerAddress, _incomingeth, _amountOfTokens, now);\r\n\r\n        // yes we know that the safemath function automatically rules out the \"greater then\" equation.\r\n        require(_amountOfTokens > 0 && SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_);\r\n\r\n\r\n        // we can't give people infinite eth\r\n        if (tokenSupply_ > 0) {\r\n            // add tokens to the pool\r\n            tokenSupply_ += _amountOfTokens;\r\n\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        //drip and buybacks\r\n        allocateFees(_undividedDividends);\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really i know you think you do but you don't\r\n        int256 _updatedPayouts = (int256) (profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_customerAddress] += _updatedPayouts;\r\n\r\n\r\n        //Stats\r\n        stats[_customerAddress].invested += _incomingeth;\r\n        stats[_customerAddress].xInvested += 1;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /* @dev Subtracts two numbers, else returns zero */\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        if (b > a) {\r\n            return 0;\r\n        } else {\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onDonation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"soldTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onLeaderBoard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingeth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethEarned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balanceInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buy_amount\",\"type\":\"uint256\"}],\"name\":\"buyFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateethReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dailyEstimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendBalance_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donatePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"players\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"statsOf\",\"outputs\":[{\"internalType\":\"uint256[14]\",\"name\":\"\",\"type\":\"uint256[14]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Silo", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a86d305a36cdb815af991834b46ad3d7fbb38523", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://34817fe817f97cc0170a32c2eecbb36b71dd7c598d74d25e1ac74844da03fe28"}