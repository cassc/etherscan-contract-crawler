{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function burnFrom(address account, uint256 amount) external;\r\n    function burn(uint256 amount) external;\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary DateTime {\r\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint256 constant SECONDS_PER_MINUTE = 60;\r\n    int256 constant OFFSET19700101 = 2440588;\r\n\r\n    uint256 constant DOW_MON = 1;\r\n    uint256 constant DOW_TUE = 2;\r\n    uint256 constant DOW_WED = 3;\r\n    uint256 constant DOW_THU = 4;\r\n    uint256 constant DOW_FRI = 5;\r\n    uint256 constant DOW_SAT = 6;\r\n    uint256 constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day\r\n    ) internal pure returns (uint256 _days) {\r\n        require(year >= 1970);\r\n        int256 _year = int256(year);\r\n        int256 _month = int256(month);\r\n        int256 _day = int256(day);\r\n\r\n        int256 __days =\r\n            _day -\r\n                32075 +\r\n                (1461 * (_year + 4800 + (_month - 14) / 12)) /\r\n                4 +\r\n                (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\r\n                12 -\r\n                (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\r\n                4 -\r\n                OFFSET19700101;\r\n\r\n        _days = uint256(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint256 _days)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 year,\r\n            uint256 month,\r\n            uint256 day\r\n        )\r\n    {\r\n        int256 __days = int256(_days);\r\n\r\n        int256 L = __days + 68569 + OFFSET19700101;\r\n        int256 N = (4 * L) / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int256 _year = (4000 * (L + 1)) / 1461001;\r\n        L = L - (1461 * _year) / 4 + 31;\r\n        int256 _month = (80 * L) / 2447;\r\n        int256 _day = L - (2447 * _month) / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint256(_year);\r\n        month = uint256(_month);\r\n        day = uint256(_day);\r\n    }\r\n\r\n    function isLeapYear(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (bool leapYear)\r\n    {\r\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n\r\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n\r\n    function getDaysInMonth(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256 daysInMonth)\r\n    {\r\n        (uint256 year, uint256 month, ) =\r\n            _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n\r\n    function _getDaysInMonth(uint256 year, uint256 month)\r\n        internal\r\n        pure\r\n        returns (uint256 daysInMonth)\r\n    {\r\n        if (\r\n            month == 1 ||\r\n            month == 3 ||\r\n            month == 5 ||\r\n            month == 7 ||\r\n            month == 8 ||\r\n            month == 10 ||\r\n            month == 12\r\n        ) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256 dayOfWeek)\r\n    {\r\n        uint256 _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = ((_days + 3) % 7) + 1;\r\n    }\r\n\r\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\r\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\r\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\r\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function timestampFromDate(\r\n        uint256 year,\r\n        uint256 month,\r\n        uint256 day\r\n    ) internal pure returns (uint256 timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the Friday of the same week\r\n     * @param timestamp is the given date and time\r\n     * @return the Friday of the same week in unix time\r\n     */\r\n    function getThisWeekFriday(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return timestamp + 5 days - getDayOfWeek(timestamp) * 1 days;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the next friday after the given date and time\r\n     * @param timestamp is the given date and time\r\n     * @return the next friday after the given date and time\r\n     */\r\n    function getNextFriday(uint256 timestamp) internal pure returns (uint256) {\r\n        uint256 friday = getThisWeekFriday(timestamp);\r\n        return friday >= timestamp ? friday : friday + 1 weeks;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the last day of the month\r\n     * @param timestamp is the given date and time\r\n     * @return the last day of the same month in unix time\r\n     */\r\n    function getLastDayOfMonth(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            timestampFromDate(getYear(timestamp), getMonth(timestamp) + 1, 1) -\r\n            1 days;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the last Friday of the month\r\n     * @param timestamp is the given date and time\r\n     * @return the last Friday of the same month in unix time\r\n     */\r\n    function getMonthLastFriday(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 lastDay = getLastDayOfMonth(timestamp);\r\n        uint256 friday = getThisWeekFriday(lastDay);\r\n\r\n        return friday > lastDay ? friday - 1 weeks : friday;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the last Friday of the quarter\r\n     * @param timestamp is the given date and time\r\n     * @return the last Friday of the quarter in unix time\r\n     */\r\n    function getQuarterLastFriday(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 month = getMonth(timestamp);\r\n        uint256 quarterMonth =\r\n            (month <= 3) ? 3 : (month <= 6) ? 6 : (month <= 9) ? 9 : 12;\r\n\r\n        uint256 quarterDate =\r\n            timestampFromDate(getYear(timestamp), quarterMonth, 1);\r\n\r\n        return getMonthLastFriday(quarterDate);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the last Friday of the half-year\r\n     * @param timestamp is the given date and time\r\n     * @return the last friday of the half-year\r\n     */\r\n    function getBiannualLastFriday(uint256 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 month = getMonth(timestamp);\r\n        uint256 biannualMonth = (month <= 6) ? 6 : 12;\r\n\r\n        uint256 biannualDate =\r\n            timestampFromDate(getYear(timestamp), biannualMonth, 1);\r\n\r\n        return getMonthLastFriday(biannualDate);\r\n    }\r\n}\r\n\r\n// File: arma-stake.sol\r\n\r\npragma solidity ^0.8.18;\r\n\r\ninterface pancake {\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\n\r\n//time, transfer, liverate\r\n\r\ncontract aarmastaking is Ownable, Pausable, ReentrancyGuard {\r\n    struct Package {\r\n        uint256 number;\r\n        uint256 months;\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 bonus;\r\n        uint256 percentage;\r\n        uint256 roi;\r\n        uint256 day;\r\n        uint256 week;\r\n    }\r\n   \r\n    struct RefferalRewardTxn {\r\n        address from;\r\n        address to;\r\n        uint256 amount;\r\n        uint256 reward;\r\n        uint256 percentage;\r\n        uint256 level;\r\n        uint256 time;\r\n    }\r\n    struct BonusRewardTxn {\r\n        address user;\r\n        uint256 level;\r\n        uint256 reward;\r\n        uint256 member;\r\n        uint256 teamBusiness;\r\n        uint256 time;\r\n    }\r\n    struct Stakes {\r\n        address user;\r\n        uint256 uAmount; //  1000\r\n        uint256 stakedArma; // 11640\r\n        uint256 cAmount; // $405 roi + bonus\r\n        uint256 rate;\r\n        uint256 starttime;\r\n        uint256 endtime;\r\n        uint256 package;\r\n        uint256 balance;\r\n        uint256 _type;\r\n    }\r\n    struct Users {\r\n        address refferal;\r\n        address user;\r\n        uint256 lastClaimedBonusLevel;\r\n        uint256[9] userLevel;\r\n        uint256[9] levelBusiness;\r\n        uint256[9] bonusReward; // 0 1\r\n        uint256[9] claimedBonusReward;\r\n    }\r\n    struct Totals {\r\n        uint256 totalStake;\r\n        uint256 totalStakeArma;\r\n        uint256 totalRefReward;\r\n        uint256 totalDailyReward;\r\n        uint256 totalBonusReward;\r\n        uint256 totalPending;\r\n        uint256 totalWithdrawlArma; // 0\r\n        uint256 totalWithdrawlArmaBusd; // 0\r\n        uint256 totalWithdrawlBusd; // 1\r\n        uint256 totalWithdrawlBusdArma; // 1\r\n    }\r\n    struct Withdrawl {\r\n        address user;\r\n        uint256 _type; //\r\n        uint256 amount;\r\n        uint256 totalToken;\r\n        uint256 rate;\r\n        uint256 time;\r\n        uint256 fee;\r\n    }\r\n    BonusRewardTxn[] public bonusRewardTxn; // useraddress\r\n    Withdrawl[] public withdrawl; // useraddress\r\n    mapping(address => BonusRewardTxn) public bonusRewardTxnMap;\r\n    uint256[3] public levelReward = [5e18, 25e17, 125e16];\r\n    // mapping(address => Incomes) public incomes;\r\n    // mapping(address => Rewards) public rewards;\r\n    uint256 constant oneday = 86400;\r\n    uint256 public constant MONTH = oneday * 30;\r\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint256 public minArmaWithrawl = 10e18;\r\n\r\n    Package[] public packages;\r\n    mapping(address => Stakes) public stakes;\r\n    mapping(address => Users) public users;\r\n    mapping(address => Totals) public totals;\r\n    Stakes[] public stakesList;\r\n    // uint256 public armaPrice() = 125e15;\r\n    uint256 public stakeLenght;\r\n    address[] public stakers;\r\n    RefferalRewardTxn[] public refferalRewardTxn; // user to\r\n    uint256[2] public bonusRewardMembers = [3, 9];\r\n    address public defaultAddress = 0x066109250F3151f7D9d60a7Cc51EFa886697c765;\r\n    address AUSD = 0x7e48A0eb32CDcE54794aFe505Bf0AF9A7b83Ef1E;\r\n    address ARMA = 0xf1F0FA0287C47804636fFeF14e2C241f2587903e;\r\n    address BUSD = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    IERC20 public ausd = IERC20(AUSD);\r\n    IERC20 public arma = IERC20(ARMA);\r\n    IERC20 public busd = IERC20(BUSD);\r\n    uint256 public withdrawlFee = 2e18;\r\n    uint256[9] public bonusRewawrdBusiness = [\r\n        1500e18,\r\n        5000e18,\r\n        15000e18,\r\n        50000e18,\r\n        175000e18,\r\n        500000e18,\r\n        1500000e18,\r\n        5000000e18,\r\n        15000000e18\r\n    ];\r\n    uint256[9] public bonusRewawrdBusinessBack = [\r\n        1500e18,\r\n        6500e18,\r\n        21500e18,\r\n        71500e18,\r\n        246500e18,\r\n        746500e18,\r\n        2246500e18,\r\n        7246500e18,\r\n        22246500e18\r\n    ];\r\n    uint256[9] public bonusReward = [\r\n        75e18,\r\n        200e18,\r\n        550e18,\r\n        750e18,\r\n        6125e18,\r\n        15000e18,\r\n        40000e18,\r\n        100000e18,\r\n        300000e18\r\n    ];\r\n\r\n    mapping(address => bool) public blocked;\r\n    bool public withdrawlPaused;\r\n    bool public bonusPaused;\r\n    mapping(address => bool) public pauseUserWithdrawl;\r\n    mapping(address => bool) public pauseUserBonus;\r\n    mapping(address => bool) public pauseUserStaking;\r\n    uint256[3] public ausdPackage = [500e18, 15e18, 5e18];\r\n    uint256 public totalSupplyLimit = 21150000e18;\r\n    uint256 public allstakingarma;\r\n    uint256 public allstakingausd;\r\n    uint256 public allburning;\r\n    uint256 public allwithdrawalarma;\r\n    uint256 public allwithdrawalbusd;\r\n\r\n    function changetoken(address _arma, address _ausd, address _busd) public onlyOwner{\r\n        ARMA = _arma;\r\n        AUSD = _ausd;\r\n        BUSD = _busd;\r\n    }\r\n\r\n    function armaPrice() public view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = ARMA;\r\n        path[1] = BUSD;\r\n        uint256[] memory price = pancake(routerAddress).getAmountsOut(\r\n            1e18,\r\n            path\r\n        );\r\n        return price[1];\r\n    }\r\n\r\n    constructor() {\r\n        packages.push(\r\n            Package({\r\n                number: 1,\r\n                months: 27,\r\n                min: 100e18,\r\n                max: 2599e18,\r\n                bonus: 5e18,\r\n                percentage: 15e17,\r\n                roi: 4050e16,\r\n                day: 810,\r\n                week: 108\r\n            })\r\n        );\r\n        packages.push(\r\n            Package({\r\n                number: 2,\r\n                months: 36,\r\n                min: 2600e18,\r\n                max: 5099e18,\r\n                bonus: 10e18,\r\n                percentage: 175e16,\r\n                roi: 63e18,\r\n                day: 1080,\r\n                week: 144\r\n            })\r\n        );\r\n        packages.push(\r\n            Package({\r\n                number: 3,\r\n                months: 45,\r\n                min: 5100e18,\r\n                max: 10999e18,\r\n                bonus: 15e18,\r\n                percentage: 2e18,\r\n                roi: 90e18,\r\n                day: 1350,\r\n                week: 180\r\n            })\r\n        );\r\n        packages.push(\r\n            Package({\r\n                number: 4,\r\n                months: 54,\r\n                min: 11000e18,\r\n                max: 25999e18,\r\n                bonus: 20e18,\r\n                percentage: 225e16,\r\n                roi: 1215e17,\r\n                day: 1620,\r\n                week: 216\r\n            })\r\n        );\r\n        packages.push(\r\n            Package({\r\n                number: 5,\r\n                months: 63,\r\n                min: 26000e18,\r\n                max: 50999e18,\r\n                bonus: 25e18,\r\n                percentage: 25e17,\r\n                roi: 1575e17,\r\n                day: 1890,\r\n                week: 250\r\n            })\r\n        );\r\n        packages.push(\r\n            Package({\r\n                number: 6,\r\n                months: 72,\r\n                min: 51000e18,\r\n                max: arma.totalSupply(),\r\n                // max: 10000000e18,\r\n                bonus: 30e18,\r\n                percentage: 3e18,\r\n                roi: 216e18,\r\n                day: 2160,\r\n                week: 288\r\n            })\r\n        );\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function blockUser(address user) public onlyOwner {\r\n        blocked[user] = true;\r\n    }\r\n\r\n    function unBlockUser(address user) public onlyOwner {\r\n         blocked[user] = false;\r\n    }\r\n\r\n    function changeWithdrawlStatus() public onlyOwner {\r\n        withdrawlPaused = withdrawlPaused ? false : true;\r\n    }\r\n\r\n    function changeBonusStatus() public onlyOwner {\r\n        bonusPaused = bonusPaused ? false : true;\r\n    }\r\n\r\n    function changePauseUserWithdrawl(address user) public onlyOwner {\r\n        pauseUserWithdrawl[user] = pauseUserWithdrawl[user] ? false : true;\r\n    }\r\n\r\n    function changePauseUserBonus(address user) public onlyOwner {\r\n        pauseUserBonus[user] = pauseUserBonus[user] ? false : true;\r\n    }\r\n\r\n    function changePauseUserStaking(address user) public onlyOwner {\r\n        pauseUserStaking[user] = pauseUserStaking[user] ? false : true;\r\n    }\r\n\r\n    modifier isBlocked() {\r\n        require(blocked[msg.sender] == false, \"miner is blocked !\");\r\n        _;\r\n    }\r\n\r\n    modifier WithdrawlStatus() {\r\n        require(withdrawlPaused == false, \"withdrawl is paused !\");\r\n        _;\r\n    }\r\n    \r\n    modifier BonusStatus() {\r\n        require(bonusPaused == false, \"bonus is paused !\");\r\n        _;\r\n    }\r\n    \r\n    modifier PauseUserWithdrawlStatus() {\r\n        require(\r\n            pauseUserWithdrawl[msg.sender] == false,\r\n            \"this user's withdrawl is paused !\"\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier PauseUserBonusStatus() {\r\n        require(\r\n            pauseUserBonus[msg.sender] == false,\r\n            \"this user's bonus is paused !\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier PauseUserStakingStatus() {\r\n        require(\r\n            pauseUserStaking[msg.sender] == false,\r\n            \"this user's staking is paused !\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function changeWithdrawFee(uint256 value) public onlyOwner {\r\n        withdrawlFee = value;\r\n    }\r\n\r\n    function gettime(uint256 time) public pure returns (uint256) {\r\n        uint256 hour = ((time / 60 / 60) % 24);\r\n        uint256 minute = (time / 60) % 60;\r\n        uint256 sec = time % 60;\r\n        uint256 minutensec = (minute * 60) + sec;\r\n        uint256 diffhour = (hour) * SECONDS_PER_HOUR;\r\n        uint256 difftime = diffhour + minutensec;\r\n        uint256 finaltime = (time - difftime);\r\n        return finaltime;\r\n    }\r\n\r\n    function findPackageNumber(uint256 _amt) public view returns (uint256) {\r\n        require(_amt > 0, \"Amount is not ZERO.\");\r\n        uint256 pkg = 0;\r\n        for (uint256 i = 0; i < packages.length; i++) {\r\n            if (_amt >= packages[i].min && _amt <= packages[i].max) {\r\n                pkg = i;\r\n            }\r\n        }\r\n        return pkg;\r\n    }\r\n\r\n    //0 arma 1 ausd\r\n    event Stake(address user, uint256 busd, uint256 _type, uint256 _arma);\r\n\r\n    function stake(\r\n        uint256 _busd,\r\n        address _refferal,\r\n        uint256 _type,\r\n        address user,\r\n        uint starttime,\r\n        uint256 rate\r\n    ) public whenNotPaused isBlocked PauseUserStakingStatus{\r\n        // address user = msg.sender;\r\n        uint256 armaRate = 0;\r\n        uint256 timestamp = 0;\r\n        if (msg.sender == owner()){\r\n            armaRate = rate;\r\n            timestamp = starttime;\r\n        } else {\r\n            armaRate = armaPrice();\r\n            timestamp = block.timestamp;\r\n        }\r\n        require(\r\n            stakes[user].endtime < timestamp,\r\n            \"user already staked !\"\r\n        );\r\n        uint256 _arma = ((_busd * 1e18) / armaRate);\r\n        if (_type == 0) {\r\n            require(_arma >= 100e18, \"minimum amount is 100 !\");\r\n            require(user != _refferal, \"refferal and user address same !\");\r\n\r\n            require(\r\n                checkUserStatus(_refferal) == 1,\r\n                \"refferal user is not active !\"\r\n            );\r\n            if (stakes[user].user == address(0)) {\r\n                stakers.push(user);\r\n            }\r\n            uint256 package = findPackageNumber(_busd);\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                uint256 _roi,\r\n                uint256 _bonus,\r\n                uint256 totalIncome\r\n            ) = findPackage(_busd,armaRate);\r\n            if (msg.sender == owner()){\r\n                totalIncome = (((_roi + _bonus + _busd)*1e18)/armaRate);\r\n            }\r\n            stakes[user].user = user;\r\n            users[user].user = user;\r\n            stakes[user].uAmount = _busd;\r\n            users[user].refferal = _refferal;\r\n            stakes[user].starttime = timestamp;\r\n            stakes[user].endtime =\r\n                timestamp +\r\n                (packages[package].months * MONTH);\r\n            stakes[user].package = packages[package].number;\r\n            stakes[user].stakedArma = totalIncome;\r\n            stakes[user].cAmount = (_roi + _bonus);\r\n            stakes[user].rate = armaRate;\r\n            totals[user].totalStake += (_busd + (_roi + _bonus));\r\n            totals[user].totalStakeArma += totalIncome;\r\n            stakes[user]._type = 0;\r\n            stakesList.push(\r\n                Stakes({\r\n                    user: user,\r\n                    uAmount: _busd,\r\n                    stakedArma: totalIncome,\r\n                    cAmount: (_roi + _bonus),\r\n                    rate: armaRate,\r\n                    starttime: timestamp,\r\n                    endtime: timestamp +\r\n                        (packages[package].months * MONTH),\r\n                    package: package,\r\n                    balance: 0,\r\n                    _type: 0\r\n                })\r\n            );\r\n            allstakingarma += totalIncome;\r\n            if (msg.sender != owner()){\r\n                arma.transferFrom(user, address(this), _arma);\r\n            }\r\n            stakeLenght++;\r\n            distLevelReward(user, _busd);\r\n        }\r\n        if (_type == 1) {\r\n            uint256 ausdBalance = 0;\r\n            if (msg.sender == owner()) {\r\n                ausdBalance = _busd;\r\n            } else {\r\n                ausdBalance = ausd.balanceOf(user);\r\n            }\r\n            require(\r\n                ausdBalance > ausdPackage[0],\r\n                \"minimum is 500 AUSD !\"\r\n            );\r\n\r\n            (, uint256 _roi, uint256 _bonus) = calcAusdStaking(ausdBalance);\r\n            stakes[user].user = user;\r\n            users[user].user = user;\r\n            stakes[user].uAmount = ausdBalance;\r\n            users[user].refferal = _refferal;\r\n            stakes[user].starttime = timestamp;\r\n            stakes[user].endtime = timestamp + (30 * MONTH);\r\n            stakes[user].package = 0;\r\n            stakes[user].stakedArma = 0;\r\n            stakes[user].cAmount = (_roi + _bonus);\r\n            totals[user].totalStake += (ausdBalance + (_roi + _bonus));\r\n            totals[user].totalStakeArma = 0;\r\n            stakes[user]._type = 1;\r\n            stakesList.push(\r\n                Stakes({\r\n                    user: user,\r\n                    uAmount: ausdBalance,\r\n                    stakedArma: 0,\r\n                    cAmount: (_roi + _bonus),\r\n                    rate: armaRate,\r\n                    starttime: timestamp,\r\n                    endtime: timestamp + (30 * MONTH),\r\n                    package: 0,\r\n                    balance: 0,\r\n                    _type: 1\r\n                })\r\n            );\r\n            allstakingausd +=ausdBalance;\r\n            if (msg.sender != owner()){\r\n                ausd.transferFrom(user, address(this), ausdBalance);\r\n            }\r\n        }\r\n        emit Stake(user, _busd, _type, _arma);\r\n    }\r\n    \r\n    function calcAusdStaking(uint256 value)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 amount,\r\n            uint256 roi,\r\n            uint256 bonus\r\n        )\r\n    {\r\n        amount = value;\r\n        roi = (value * ausdPackage[1]) / 100e18;\r\n        bonus = (value * ausdPackage[2]) / 100e18;\r\n    }\r\n\r\n    function checkUserStatus(address user) public view returns (uint256) {\r\n        if (user == defaultAddress) {\r\n            return (1);\r\n        } else {\r\n            if (\r\n                (stakes[user].endtime > block.timestamp &&\r\n                    stakes[user].endtime != 0)\r\n            ) {\r\n                return (1);\r\n            } else {\r\n                return (0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkausduserstatus(address _user) public view returns (uint256) {\r\n        require(stakes[_user]._type == 1, \"Staking is not AUSD\");\r\n        uint256 maxreward = totals[_user].totalStake;\r\n        return maxreward;\r\n    }\r\n\r\n    function getUserLevel(address user)\r\n        public\r\n        view\r\n        returns (uint256[9] memory)\r\n    {\r\n        return users[user].userLevel;\r\n    }\r\n\r\n    function getLevelBusiness(address user)\r\n        public\r\n        view\r\n        returns (uint256[9] memory)\r\n    {\r\n        return users[user].levelBusiness;\r\n    }\r\n\r\n    function getBonusReward(address user)\r\n        public\r\n        view\r\n        returns (uint256[9] memory)\r\n    {\r\n        return users[user].bonusReward;\r\n    }\r\n\r\n    function getClaimedBonusReward(address user)\r\n        public\r\n        view\r\n        returns (uint256[9] memory)\r\n    {\r\n        return users[user].claimedBonusReward;\r\n    }\r\n\r\n    event LevelReward(address user, uint256 value, uint256 time);\r\n    function distLevelReward(address user, uint256 value)\r\n        internal\r\n        returns (address[] memory)\r\n    {\r\n        address[] memory uplines = new address[](9);\r\n        address refferal = users[user].refferal;\r\n        uint256 length;\r\n        if (stakers.length >= levelReward.length) {\r\n            length = levelReward.length;\r\n        } else {\r\n            length = stakers.length;\r\n        }\r\n        uint256 loopLength;\r\n        if (stakers.length >= bonusReward.length) {\r\n            loopLength = bonusReward.length;\r\n        } else {\r\n            loopLength = stakers.length;\r\n        }\r\n        for (uint256 i = 0; i < loopLength; i++) {\r\n            uplines[i] = refferal;\r\n            if (refferal != address(0)) {\r\n                if(checkUserStatus(user) == 1)\r\n                {\r\n                    // break;\r\n                    if (i < length) {\r\n                        refferalRewardTxn.push(\r\n                            RefferalRewardTxn({\r\n                                from: user,\r\n                                to: refferal,\r\n                                amount: value,\r\n                                reward: (value * levelReward[i]) / 100e18,\r\n                                percentage: levelReward[i],\r\n                                level: i + 1,\r\n                                time: block.timestamp\r\n                            })\r\n                        );\r\n                    totals[refferal].totalRefReward +=\r\n                        (value * levelReward[i]) /\r\n                        100e18;\r\n                    }\r\n                    users[refferal].userLevel[i] += 1;\r\n                    users[refferal].levelBusiness[i] += value;\r\n                }\r\n                distBonusReward(refferal);\r\n                refferal = users[refferal].refferal;\r\n            }\r\n        }\r\n        emit LevelReward(user, value, block.timestamp);\r\n        return uplines;\r\n    }\r\n\r\n    function updateUserLevel(\r\n        uint256 leve,\r\n        uint256 value,\r\n        address user\r\n    ) public onlyOwner {\r\n        users[user].userLevel[leve] = value;\r\n    }\r\n\r\n    function updateBonusReward(\r\n        uint256 leve,\r\n        uint256 value,\r\n        address user\r\n    ) public onlyOwner {\r\n        users[user].bonusReward[leve] = value;\r\n    }\r\n\r\n    function updateBusiness(\r\n        address user,\r\n        uint256 value,\r\n        uint256 i\r\n    ) public onlyOwner {\r\n        users[user].levelBusiness[i] = value;\r\n    }\r\n\r\n    function updateMap(address user, uint256 level) public onlyOwner {\r\n        bonusRewardTxnMap[user].user = user;\r\n        bonusRewardTxnMap[user].level = level;\r\n    }\r\n\r\n    function distBonusReward(address _refferal) internal {\r\n        uint256 i = bonusRewardTxnMap[_refferal].level;\r\n        if (i == 0) {\r\n            if (\r\n                bonusRewawrdBusinessBack[i] <=\r\n                users[_refferal].levelBusiness[i] &&\r\n                users[_refferal].bonusReward[i] == 0\r\n            ) {\r\n                if (i < bonusRewardMembers.length) {\r\n                    if (\r\n                        users[_refferal].userLevel[i] >= bonusRewardMembers[i]\r\n                    ) {\r\n                        sendBonusReward(_refferal, i);\r\n                    }\r\n                } else {\r\n                    sendBonusReward(_refferal, i);\r\n                }\r\n            }\r\n        }\r\n       \r\n        else  {\r\n            if (i < bonusRewardMembers.length) {\r\n                if (\r\n                    users[_refferal].levelBusiness[i] >=\r\n                    bonusRewawrdBusinessBack[i] &&\r\n                    (users[_refferal].userLevel[i] >= bonusRewardMembers[i])\r\n                ) {\r\n                    sendBonusReward(_refferal, i);\r\n                }\r\n            } else {\r\n                if (\r\n                    users[_refferal].levelBusiness[i] >=\r\n                    bonusRewawrdBusinessBack[i]\r\n                ) {\r\n                    sendBonusReward(_refferal, i);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    event BonusReward(address user, uint256 reward, uint256 time);\r\n\r\n    function sendBonusReward(address _refferal, uint256 i) internal {\r\n        bonusRewardTxn.push(\r\n            BonusRewardTxn({\r\n                user: _refferal,\r\n                level: i + 1,\r\n                reward: bonusReward[i],\r\n                member: users[_refferal].userLevel[i],\r\n                teamBusiness: users[_refferal].levelBusiness[i],\r\n                time: block.timestamp\r\n            })\r\n        );\r\n        bonusRewardTxnMap[_refferal].user = _refferal;\r\n        bonusRewardTxnMap[_refferal].level = i + 1;\r\n        bonusRewardTxnMap[_refferal].reward = bonusReward[i];\r\n        bonusRewardTxnMap[_refferal].member = users[_refferal].userLevel[i];\r\n        bonusRewardTxnMap[_refferal].teamBusiness = users[_refferal]\r\n            .levelBusiness[i];\r\n        bonusRewardTxnMap[_refferal].time = block.timestamp;\r\n        users[_refferal].bonusReward[i] = 1;\r\n        totals[_refferal].totalPending += bonusReward[i];\r\n        if(i > 1 && users[_refferal].bonusReward[i] == 0){\r\n            users[_refferal].bonusReward[i-1] = 2;\r\n        }\r\n        emit BonusReward(_refferal, bonusReward[i], block.timestamp);\r\n    }\r\n\r\n    function monthlyReward(address _address)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 totalDays = (currentTime - stakes[_address].starttime) /\r\n            60 /\r\n            60 /\r\n            24;\r\n        uint256 months = totalDays / 30;\r\n        (uint256 dailyIncome, , , , , ) = findPackage(stakes[_address].uAmount,stakes[_address].rate);\r\n        uint256 monthly = months * dailyIncome * 30;\r\n        uint256 currentReward = (totalDays * dailyIncome);\r\n        return (monthly, currentReward);\r\n    }\r\n\r\n    function monthlyAUSDReward(address _address)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        // uint256 currentTime = time; //for testing\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 totalDays = (currentTime - stakes[_address].starttime) /\r\n            60 /\r\n            60 /\r\n            24;\r\n        uint256 months = 30;\r\n        (uint256 amount, uint256 roi, uint256 bonus) = calcAusdStaking(\r\n            stakes[_address].uAmount\r\n        );\r\n        uint256 dailyIncome = (amount + roi + bonus) / (900);\r\n        uint256 monthly = months * dailyIncome * 30;\r\n        uint256 currentReward = (totalDays * dailyIncome);\r\n        return (monthly, currentReward);\r\n    }\r\n\r\n    function findPackage(uint256 _busd,uint256 rate)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 dailyIncome = 0;\r\n        uint256 monthIncome = 0;\r\n        uint256 package = findPackageNumber(_busd);\r\n        uint256 _roi = (_busd * packages[package].roi) / 100e18;\r\n        uint256 _bonus = (_busd * packages[package].bonus) / 100e18;\r\n        uint256 totalIncome = _busd + _roi + _bonus;\r\n        uint256 armaa = ((totalIncome * 1e18) / rate);\r\n        dailyIncome = armaa / packages[package].day;\r\n        monthIncome = armaa / packages[package].months;\r\n        return (\r\n            dailyIncome,\r\n            monthIncome,\r\n            armaa / packages[package].week,\r\n            _roi,\r\n            _bonus,\r\n            armaa\r\n        );\r\n    }\r\n    event ClaimWithdrawl(\r\n        address user,\r\n        uint256 _tokenType,\r\n        uint256 value,\r\n        uint256 time\r\n    );\r\n\r\n    function claimWithdrawlOwner(uint256 _tokenType, uint256 value,address user, uint256 rate)\r\n        public\r\n       onlyOwner\r\n    {\r\n        uint time = block.timestamp;\r\n        // 1 == arma , 2 = busd\r\n        // at Withdrawal user must active\r\n        // Withdrawal\r\n        require(_tokenType == 0 || _tokenType == 1, \"token type should be 0 or 1\");\r\n        // (uint256 remaining,,) = getTotalDailyRemainingWithrawls(user);\r\n        uint256 fee = 0;\r\n        uint256 totalArma = 0;\r\n        if (_tokenType == 0) {\r\n            fee = (value * withdrawlFee) / 100e18;\r\n            // if (arma.totalSupply() > totalSupplyLimit) {\r\n            //     arma.burn(fee);\r\n            //     allburning += fee;\r\n            // }\r\n            if (stakes[user]._type == 0) {\r\n                require(\r\n                    remainingWithdrawl(user, _tokenType) >= value,\r\n                    \"invalid value type 0\"\r\n                );\r\n                // require(remaining >= ((value * armaPrice()()) / 1e18),\"your daily limit exceeds!\");\r\n                totalArma = value;\r\n                totals[user].totalWithdrawlArma += value;\r\n                totals[user].totalWithdrawlArmaBusd += ((value * rate) /\r\n                    1e18);\r\n                // arma.transfer(user, (value - fee));\r\n                allwithdrawalbusd += ((value * rate) /\r\n                    1e18);\r\n                allwithdrawalarma += value;\r\n            }\r\n            if (stakes[user]._type == 1) {\r\n                uint256 busdValue = (value * rate) / 1e18;\r\n                (, uint256 currentReward) = monthlyAUSDReward(user);\r\n                require(value >= minArmaWithrawl,\"minimum arma is morethan 10!\");\r\n                require(\r\n                    value <= (currentReward - totals[user].totalDailyReward),\r\n                    \"you enetred value more than your current reward !\"\r\n                );\r\n                totalArma = value;\r\n                uint256 maxBalance = checkausduserstatus(user);\r\n                require(busdValue <= maxBalance, \" enter valid amount\");\r\n                require(\r\n                    stakes[user].balance <= maxBalance,\r\n                    \"might be you reached your max limit !\"\r\n                );\r\n                \r\n                stakes[user].balance += busdValue;\r\n                // arma.transfer(user, (value - fee));\r\n                allwithdrawalarma += value;\r\n                totals[user].totalDailyReward += value;\r\n            }\r\n            \r\n        }\r\n        if (_tokenType == 1) {\r\n            totalArma = ((value * 1e18) / rate);\r\n            fee = (totalArma * withdrawlFee) / 100e18;\r\n            // require(remaining >= value,\"your daily limit exceeds!\");\r\n            // if (arma.totalSupply() > totalSupplyLimit) {\r\n            //     arma.burn(fee);\r\n            //     allburning += fee;\r\n            // }\r\n            require(\r\n                value <= remainingWithdrawl(user, _tokenType),\r\n                \"invalid value type 1\"\r\n            );\r\n            totals[user].totalWithdrawlBusd += value;\r\n            totals[user].totalWithdrawlBusdArma += ((value * 1e18) / rate);\r\n            // arma.transfer(user, (totalArma - fee));\r\n            allwithdrawalarma += totalArma;\r\n        }\r\n        withdrawl.push(\r\n            Withdrawl({\r\n                user: user,\r\n                _type: _tokenType,\r\n                amount: value,\r\n                totalToken:totalArma,\r\n                rate: rate,\r\n                time: time,\r\n                fee: fee\r\n            })\r\n        );\r\n    }\r\n\r\n    function claimWithdrawl(uint256 _tokenType, uint256 value)\r\n        public\r\n        WithdrawlStatus\r\n        PauseUserWithdrawlStatus\r\n        isBlocked\r\n    {\r\n        // uint time = block.timestamp;\r\n        // 1 == arma , 2 = busd\r\n        // at Withdrawal user must active\r\n        // Withdrawal\r\n        require(_tokenType == 0 || _tokenType == 1, \"token type should be 0 or 1\");\r\n        address user = msg.sender;\r\n        (uint256 remaining,,) = getTotalDailyRemainingWithrawls(user);\r\n        uint256 fee = 0;\r\n        uint256 totalArma = 0;\r\n        if (_tokenType == 0) {\r\n            fee = (value * withdrawlFee) / 100e18;\r\n            if (arma.totalSupply() > totalSupplyLimit) {\r\n                arma.burn(fee);\r\n                allburning += fee;\r\n            }\r\n            if (stakes[user]._type == 0) {\r\n                require(\r\n                    remainingWithdrawl(user, _tokenType) >= value,\r\n                    \"invalid value type 0\"\r\n                );\r\n                require(remaining >= ((value * armaPrice()) / 1e18),\"your daily limit exceeds!\");\r\n                totalArma = value;\r\n                totals[user].totalWithdrawlArma += value;\r\n                totals[user].totalWithdrawlArmaBusd += ((value * armaPrice()) /\r\n                    1e18);\r\n                arma.transfer(user, (value - fee));\r\n                allwithdrawalbusd += ((value * armaPrice()) /\r\n                    1e18);\r\n                allwithdrawalarma += value;\r\n            }\r\n            if (stakes[user]._type == 1) {\r\n                uint256 busdValue = (value * armaPrice()) / 1e18;\r\n                (, uint256 currentReward) = monthlyAUSDReward(user);\r\n                require(value >= minArmaWithrawl,\"minimum arma is morethan 10!\");\r\n                require(\r\n                    value <= (currentReward - totals[user].totalDailyReward),\r\n                    \"you enetred value more than your current reward !\"\r\n                );\r\n                totalArma = value;\r\n                uint256 maxBalance = checkausduserstatus(user);\r\n                require(busdValue <= maxBalance, \" enter valid amount\");\r\n                require(\r\n                    stakes[user].balance <= maxBalance,\r\n                    \"might be you reached your max limit !\"\r\n                );\r\n                \r\n                stakes[user].balance += busdValue;\r\n                arma.transfer(user, (value - fee));\r\n                allwithdrawalarma += value;\r\n                totals[user].totalDailyReward += value;\r\n            }\r\n            \r\n        }\r\n        if (_tokenType == 1) {\r\n            totalArma = ((value * 1e18) / armaPrice());\r\n            fee = (totalArma * withdrawlFee) / 100e18;\r\n            require(\r\n                value <= remainingWithdrawl(user, _tokenType),\r\n                \"invalid value type 1\"\r\n            );\r\n            require(remaining >= value,\"your daily limit exceeds!\");\r\n            if (arma.totalSupply() > totalSupplyLimit) {\r\n                arma.burn(fee);\r\n                allburning += fee;\r\n            }\r\n            totals[user].totalWithdrawlBusd += value;\r\n            totals[user].totalWithdrawlBusdArma += ((value * 1e18) / armaPrice());\r\n            arma.transfer(user, (totalArma - fee));\r\n            allwithdrawalarma += totalArma;\r\n        }\r\n        withdrawl.push(\r\n            Withdrawl({\r\n                user: user,\r\n                _type: _tokenType,\r\n                amount: value,\r\n                totalToken:totalArma,\r\n                rate: armaPrice(),\r\n                time: block.timestamp,\r\n                fee: fee\r\n            })\r\n        );\r\n        emit ClaimWithdrawl(user, _tokenType, value, block.timestamp);\r\n    }\r\n\r\n    function remainingWithdrawl(address user, uint256 _type)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (_type == 0) {\r\n            (,uint256 daily ) = monthlyReward(user);\r\n            return (daily - totals[user].totalWithdrawlArma);\r\n        } else {\r\n            uint256 reward = (totals[user].totalRefReward +\r\n                totals[user].totalBonusReward) -\r\n                totals[user].totalWithdrawlBusd;\r\n            return reward;\r\n        }\r\n    }\r\n\r\n    event ClaimBonusReward(address user, uint256 value, uint256 time);\r\n\r\n        function claimBonusReward(uint256 level)\r\n        public\r\n        BonusStatus\r\n        PauseUserBonusStatus\r\n        isBlocked\r\n    {\r\n        address user = msg.sender;\r\n        uint256 total = 0;\r\n        require(\r\n            users[user].bonusReward[level] == 1,\r\n            \"this level reward not active yet !\"\r\n        );\r\n        distBonusReward(user);\r\n        if (level == 0) {\r\n            total += bonusReward[level];\r\n            users[user].claimedBonusReward[level] = 1;\r\n        } else if (users[user].claimedBonusReward[0] == 1){\r\n            for (uint256 i = level; i > 0; i--) {\r\n                if (users[user].bonusReward[level] == 1) {\r\n                    uint256 bonusRewardRequire = 0;\r\n                    uint256 bonusRewardUser = 0;\r\n                    for (uint256 j = 0; j <= level; j++) {\r\n                        bonusRewardRequire += bonusRewawrdBusiness[j];\r\n                        bonusRewardUser += users[user].levelBusiness[j];\r\n                    }\r\n                    require(\r\n                        bonusRewardUser >= bonusRewardRequire,\r\n                        \"bonus reward is not less than total of all level reward !\"\r\n                    );\r\n                    total += bonusReward[level];\r\n                    users[user].claimedBonusReward[level] = 1;\r\n                }\r\n                if (level != i) {\r\n                    users[user].bonusReward[i] = 2;\r\n                    users[user].claimedBonusReward[i] = 2;\r\n                }\r\n            }\r\n        } else {\r\n            revert(\"level is not open!\");\r\n        }\r\n\r\n        totals[user].totalBonusReward += total;\r\n        emit ClaimBonusReward(user, total, block.timestamp);\r\n    }\r\n\r\n    function getBonusRewardTxn(address _address)\r\n        public\r\n        view\r\n        returns (BonusRewardTxn[] memory)\r\n    {\r\n        BonusRewardTxn[] memory txn = new BonusRewardTxn[](\r\n            bonusRewardTxn.length\r\n        );\r\n        for (uint256 i = 0; i < bonusRewardTxn.length; i++) {\r\n            BonusRewardTxn storage user = bonusRewardTxn[i];\r\n            if (user.user == _address) {\r\n                txn[i] = user;\r\n            }\r\n        }\r\n        return txn;\r\n    }\r\n\r\n    function getWithdrawlTxn(address _address)\r\n        public\r\n        view\r\n        returns (Withdrawl[] memory)\r\n    {\r\n        Withdrawl[] memory txn = new Withdrawl[](withdrawl.length);\r\n        for (uint256 i = 0; i < withdrawl.length; i++) {\r\n            Withdrawl storage user = withdrawl[i];\r\n            if (user.user == _address) {\r\n                txn[i] = user;\r\n            }\r\n        }\r\n        return txn;\r\n    }\r\n\r\n    function getRefferalRewardTxn(address _address)\r\n        public\r\n        view\r\n        returns (RefferalRewardTxn[] memory)\r\n    {\r\n        RefferalRewardTxn[] memory txn = new RefferalRewardTxn[](\r\n            refferalRewardTxn.length\r\n        );\r\n        for (uint256 i = 0; i < refferalRewardTxn.length; i++) {\r\n            RefferalRewardTxn storage user = refferalRewardTxn[i];\r\n            if (user.to == _address) {\r\n                txn[i] = user;\r\n            }\r\n        }\r\n        return txn;\r\n    }\r\n\r\n    function getStakings(address _address)\r\n        public\r\n        view\r\n        returns (Stakes[] memory)\r\n    {\r\n        Stakes[] memory txn = new Stakes[](stakesList.length);\r\n        for (uint256 i = 0; i < stakesList.length; i++) {\r\n            Stakes storage user = stakesList[i];\r\n            if (user.user == _address) {\r\n                txn[i] = user;\r\n            }\r\n        }\r\n        return txn;\r\n    }\r\n\r\n    function withdrawlToken(address _address, uint256 value) public onlyOwner {\r\n        IERC20 token = IERC20(_address);\r\n        token.transfer(msg.sender, value);\r\n    }\r\n\r\n    function withdrawlCoin(uint256 value) public onlyOwner {\r\n        (bool sent, ) = (msg.sender).call{value: value}(\"\");\r\n        require(sent, \"Failed to send BNB\");\r\n    }\r\n\r\n    function getTotalDailyRemainingWithrawls(address user) public view returns(uint256 remaining,uint staking,uint total) {\r\n       \r\n        (uint256 year,uint256 month ,uint256 day ) = DateTime._daysToDate(block.timestamp / DateTime.SECONDS_PER_DAY);\r\n        uint startTime = (DateTime.timestampFromDate(year,month,day));\r\n        uint endTime = startTime + 1 days;\r\n        // Withdrawl[] memory txn = new Withdrawl[](withdrawl.length);\r\n        uint256 value = 0;\r\n        for (uint256 i = 0; i < withdrawl.length; i++) {\r\n            Withdrawl storage withs = withdrawl[i];\r\n            if (withs.user == user && startTime < withs.time && endTime > withs.time) {\r\n                value += ((withs.totalToken * withs.rate) / 1e18);\r\n            }\r\n        }\r\n        total = value;\r\n        staking = stakes[user].uAmount;\r\n        remaining = stakes[user].uAmount - value > 0 ? stakes[user].uAmount - value : 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"BonusReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ClaimBonusReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ClaimWithdrawl\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LevelReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_arma\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MONTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allburning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allstakingarma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allstakingausd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allwithdrawalarma\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allwithdrawalbusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arma\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"armaPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ausd\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ausdPackage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"blockUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusRewardMembers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusRewardTxn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"member\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusRewardTxnMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"member\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusRewawrdBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusRewawrdBusinessBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"busd\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calcAusdStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeBonusStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"changePauseUserBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"changePauseUserStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"changePauseUserWithdrawl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"changeWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeWithdrawlStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arma\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ausd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_busd\",\"type\":\"address\"}],\"name\":\"changetoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"checkUserStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkausduserstatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"claimBonusReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"claimWithdrawl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"claimWithdrawlOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_busd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"findPackage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"findPackageNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBonusReward\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBonusRewardTxn\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"member\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct aarmastaking.BonusRewardTxn[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getClaimedBonusReward\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLevelBusiness\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefferalRewardTxn\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct aarmastaking.RefferalRewardTxn[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakings\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedArma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"internalType\":\"struct aarmastaking.Stakes[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getTotalDailyRemainingWithrawls\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLevel\",\"outputs\":[{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getWithdrawlTxn\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct aarmastaking.Withdrawl[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"gettime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minArmaWithrawl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"monthlyAUSDReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"monthlyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"packages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"months\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pauseUserBonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pauseUserStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pauseUserWithdrawl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refferalRewardTxn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"remainingWithdrawl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_busd\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_refferal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeLenght\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedArma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakesList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedArma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeArma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRefReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDailyReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonusReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawlArma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawlArmaBusd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawlBusd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawlBusdArma\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"unBlockUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateBonusReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"updateBusiness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"updateMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateUserLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"refferal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimedBonusLevel\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawlCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawlFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawlPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawlToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "aarmastaking", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2a1fa6e9916011ba065401a8bfa1d50c439d43057b6ce126efeb23920d506a41"}