{"SourceCode": "{\"deseo-imports.sol\":{\"content\":\"/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n */ \\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {this; return msg.data;}\\r\\n}\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        unchecked { require(b \\u003c= a, errorMessage); return a - b; }\\r\\n    }\\r\\n}\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size \\u003e 0;}\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {return functionCall(target, data, \\\"Address: low-level call failed\\\");}\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {return functionCallWithValue(target, data, 0, errorMessage);}\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");}\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) { return returndata; } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {revert(errorMessage);}\\r\\n        }\\r\\n    }\\r\\n}\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    uint256 private _lockTime;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n    function getUnlockTime() public view returns (uint256) {\\r\\n        return _lockTime;\\r\\n    }\\r\\n    function lock(uint256 time) public virtual onlyOwner {\\r\\n        _previousOwner = _owner;\\r\\n        _owner = address(0);\\r\\n        _lockTime = block.timestamp + time;\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n    }\\r\\n    function unlock() public virtual {\\r\\n        require(_previousOwner == msg.sender, \\\"Only the previous owner can unlock onwership\\\");\\r\\n        require(block.timestamp \\u003e _lockTime , \\\"The contract is still locked\\\");\\r\\n        emit OwnershipTransferred(_owner, _previousOwner);\\r\\n        _owner = _previousOwner;\\r\\n    }\\r\\n}\\r\\nabstract contract Manageable is Context {\\r\\n    address private _manager;\\r\\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\\r\\n    constructor(){\\r\\n        address msgSender = _msgSender();\\r\\n        _manager = msgSender;\\r\\n        emit ManagementTransferred(address(0), msgSender);\\r\\n    }\\r\\n    function manager() public view returns(address){ return _manager; }\\r\\n    modifier onlyManager(){\\r\\n        require(_manager == _msgSender(), \\\"Manageable: caller is not the manager\\\");\\r\\n        _;\\r\\n    }\\r\\n    function transferManagement(address newManager) external virtual onlyManager {\\r\\n        emit ManagementTransferred(_manager, newManager);\\r\\n        _manager = newManager;\\r\\n    }\\r\\n}\\r\\ninterface IPancakeV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\ninterface IPancakeV2Router {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"nftdeseo.sol\":{\"content\":\"/**\\r\\n * SPDX-License-Identifier: MIT\\r\\n */\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * Tokenomics:\\r\\n * \\r\\n * Liquidity        4%\\r\\n * Redistribution   1%\\r\\n * Burn             1%\\r\\n * Gifts            1%\\r\\n * Marketing        2%\\r\\n * Lottery        0.1%\\r\\n * \\r\\n * El proyecto DESEO cuenta con el apoyo de varias aplicaciones que generan liquidez gracias a la publicidad.\\r\\n * El proyecto DESEO tendr\u00e1 un juego NFT para el a\u00f1o 2023 - En construcci\u00f3n -\\r\\n * El proyecto DESEO realizar\u00e1 donaciones y regalos en fechas se\u00f1aladas a ni\u00f1os sin recursos.\\r\\n * M\u00e1s informaci\u00f3n en nuestra p\u00e1gina web.\\r\\n * El proyecto DESEO sacar\u00e1 a la venta tantos grupos de NFTs como le sea posible crear \\r\\n * con el fin de obtener mayor liquidez para el proyecto.\\r\\n * Los NFTs se vender\u00e1n a trav\u00e9s de OPENSEA\\r\\n * https://opensea.io/collection/monsterbobus\\r\\n * Nuestras Redes Sociales son:\\r\\n * web: https:deseocoin.com\\r\\n * Telegram: https://t.me/deseocoin\\r\\n * Twitter: https://twitter.com/CoinDeseo\\r\\n * Discord: https://discord.gg/t9v7v3kx25\\r\\n * \\r\\n */\\r\\n\\r\\nimport \\\"./deseo-imports.sol\\\";\\r\\n\\r\\n/**\\r\\n * Gracias por confiar en el proyecto DESEO\\r\\n */\\r\\nabstract contract Tokenomics {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    // --------------------- Token Settings ------------------- //\\r\\n\\r\\n    string internal constant NAME = \\\"DESEO NFT\\\";\\r\\n    string internal constant SYMBOL = \\\"DESEO\\\";\\r\\n    \\r\\n    uint16 internal constant FEES_DIVISOR = 10**3;\\r\\n    uint8 internal constant DECIMALS = 18;\\r\\n    uint256 internal constant ZEROES = 10**DECIMALS;\\r\\n    \\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n    uint256 internal constant TOTAL_SUPPLY = 1000000000000000 * ZEROES;\\r\\n    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\\r\\n\\r\\n    /**\\r\\n     * @dev Set the maximum transaction amount allowed in a transfer.\\r\\n     * \\r\\n     * The default value is 1% of the total supply. \\r\\n     * \\r\\n     * NOTE: set the value to `TOTAL_SUPPLY` to have an unlimited max, i.e.\\r\\n     * `maxTransactionAmount = TOTAL_SUPPLY;`\\r\\n     */\\r\\n    uint256 internal constant maxTransactionAmount = TOTAL_SUPPLY / 10; // 10% of the total supply\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the maximum allowed balance in a wallet.\\r\\n     * \\r\\n     * The default value is 2% of the total supply. \\r\\n     * \\r\\n     * NOTE: set the value to 0 to have an unlimited max.\\r\\n     *\\r\\n     * IMPORTANT: This value MUST be greater than `numberOfTokensToSwapToLiquidity` set below,\\r\\n     * otherwise the liquidity swap will never be executed\\r\\n     */\\r\\n    uint256 internal constant maxWalletBalance = TOTAL_SUPPLY / 10; // 2% of the total supply\\r\\n    \\r\\n    /**\\r\\n     * @dev Set the number of tokens to swap and add to liquidity. \\r\\n     * \\r\\n     * Whenever the contract\\u0027s balance reaches this number of tokens, swap \\u0026 liquify will be \\r\\n     * executed in the very next transfer (via the `_beforeTokenTransfer`)\\r\\n     * \\r\\n     * If the `FeeType.Liquidity` is enabled in `FeesSettings`, the given % of each transaction will be first\\r\\n     * sent to the contract address. Once the contract\\u0027s balance reaches `numberOfTokensToSwapToLiquidity` the\\r\\n     * `swapAndLiquify` of `Liquifier` will be executed. Half of the tokens will be swapped for ETH \\r\\n     * (or BNB on BSC) and together with the other half converted into a Token-ETH/Token-BNB LP Token.\\r\\n     * \\r\\n     * See: `Liquifier`\\r\\n     */\\r\\n    uint256 internal constant numberOfTokensToSwapToLiquidity = TOTAL_SUPPLY / 1000; // 0.1% of the total supply\\r\\n\\r\\n    // --------------------- Fees Settings ------------------- //\\r\\n\\r\\n    /**\\r\\n     * @dev To add/edit/remove fees scroll down to the `addFees` function below\\r\\n     */\\r\\n\\r\\n    address internal charityAddress = 0x22007FFA0191826FB7Be80FC6D639F74142F4713;\\r\\n    address internal marketingAddress = 0xE39AFC54fc2E9604B50571e1f196dAd3D513e7A3;\\r\\n\\r\\n    /**\\r\\n     * Gracias por confiar en DESEO\\r\\n     */\\r\\n    address internal burnAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    /**\\r\\n     * El 0.1% se destina a Loteria\\r\\n     * Cada 30 d\u00edas se vender\u00e1 el acumulado y se har\u00e1 un sorteo entre todos los Holders\\r\\n     *\\r\\n     */\\r\\n    address internal tipToTheDev = 0xb95ffa9A1508743Fa0D0EEf6cd1fCA97c9Bb38F8;\\r\\n\\r\\n    enum FeeType { Antiwhale, Burn, Liquidity, Rfi, External, ExternalToETH }\\r\\n    struct Fee {\\r\\n        FeeType name;\\r\\n        uint256 value;\\r\\n        address recipient;\\r\\n        uint256 total;\\r\\n    }\\r\\n\\r\\n    Fee[] internal fees;\\r\\n    uint256 internal sumOfFees;\\r\\n\\r\\n    constructor() {\\r\\n        _addFees();\\r\\n    }\\r\\n\\r\\n    function _addFee(FeeType name, uint256 value, address recipient) private {\\r\\n        fees.push( Fee(name, value, recipient, 0 ) );\\r\\n        sumOfFees += value;\\r\\n    }\\r\\n\\r\\n    function _addFees() private {\\r\\n\\r\\n        /**\\r\\n         * Destinaremos el 1% directo a regalos y donaciones infantiles.\\r\\n         * Adem\u00e1s de otras aportaciones privadas y donaciones voluntarias.\\r\\n         * El dinero de marketing que no se utilice se destinar\u00e1 a regalos.\\r\\n         */ \\r\\n        _addFee(FeeType.Rfi, 10, address(this) ); \\r\\n\\r\\n        _addFee(FeeType.Burn, 10, burnAddress );\\r\\n        _addFee(FeeType.Liquidity, 40, address(this) );\\r\\n        _addFee(FeeType.External, 10, charityAddress );\\r\\n        _addFee(FeeType.External, 20, marketingAddress );\\r\\n\\r\\n        // 0.1% directo a regalos!\\r\\n        _addFee(FeeType.ExternalToETH, 1, tipToTheDev );\\r\\n    }\\r\\n\\r\\n    function _getFeesCount() internal view returns (uint256){ return fees.length; }\\r\\n\\r\\n    function _getFeeStruct(uint256 index) private view returns(Fee storage){\\r\\n        require( index \\u003e= 0 \\u0026\\u0026 index \\u003c fees.length, \\\"FeesSettings._getFeeStruct: Fee index out of bounds\\\");\\r\\n        return fees[index];\\r\\n    }\\r\\n    function _getFee(uint256 index) internal view returns (FeeType, uint256, address, uint256){\\r\\n        Fee memory fee = _getFeeStruct(index);\\r\\n        return ( fee.name, fee.value, fee.recipient, fee.total );\\r\\n    }\\r\\n    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\\r\\n        Fee storage fee = _getFeeStruct(index);\\r\\n        fee.total = fee.total.add(amount);\\r\\n    }\\r\\n\\r\\n    // function getCollectedFeeTotal(uint256 index) external view returns (uint256){\\r\\n    function getCollectedFeeTotal(uint256 index) internal view returns (uint256){\\r\\n        Fee memory fee = _getFeeStruct(index);\\r\\n        return fee.total;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Presaleable is Manageable {\\r\\n    bool internal isInPresale;\\r\\n    function setPreseableEnabled(bool value) external onlyManager {\\r\\n        isInPresale = value;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract BaseRfiToken is IERC20, IERC20Metadata, Ownable, Presaleable, Tokenomics {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _reflectedBalances;\\r\\n    mapping (address =\\u003e uint256) internal _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\r\\n    \\r\\n    mapping (address =\\u003e bool) internal _isExcludedFromFee;\\r\\n    mapping (address =\\u003e bool) internal _isExcludedFromRewards;\\r\\n    address[] private _excluded;\\r\\n    \\r\\n    constructor(){\\r\\n        \\r\\n        _reflectedBalances[owner()] = _reflectedSupply;\\r\\n        \\r\\n        // exclude owner and this contract from fee\\r\\n        _isExcludedFromFee[owner()] = true;\\r\\n        _isExcludedFromFee[address(this)] = true;\\r\\n        \\r\\n        // exclude the owner and this contract from rewards\\r\\n        _exclude(owner());\\r\\n        _exclude(address(this));\\r\\n\\r\\n        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\\r\\n        \\r\\n    }\\r\\n    \\r\\n    /** Functions required by IERC20Metadat **/\\r\\n        function name() external pure override returns (string memory) { return NAME; }\\r\\n        function symbol() external pure override returns (string memory) { return SYMBOL; }\\r\\n        function decimals() external pure override returns (uint8) { return DECIMALS; }\\r\\n        \\r\\n    /** Functions required by IERC20Metadat - END **/\\r\\n    /** Functions required by IERC20 **/\\r\\n        function totalSupply() external pure override returns (uint256) {\\r\\n            return TOTAL_SUPPLY;\\r\\n        }\\r\\n        \\r\\n        function balanceOf(address account) public view override returns (uint256){\\r\\n            if (_isExcludedFromRewards[account]) return _balances[account];\\r\\n            return tokenFromReflection(_reflectedBalances[account]);\\r\\n        }\\r\\n        \\r\\n        function transfer(address recipient, uint256 amount) external override returns (bool){\\r\\n            _transfer(_msgSender(), recipient, amount);\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        function allowance(address owner, address spender) external view override returns (uint256){\\r\\n            return _allowances[owner][spender];\\r\\n        }\\r\\n    \\r\\n        function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n            _approve(_msgSender(), spender, amount);\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool){\\r\\n            _transfer(sender, recipient, amount);\\r\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n            return true;\\r\\n        }\\r\\n    /** Functions required by IERC20 - END **/\\r\\n\\r\\n    /**\\r\\n     * @dev this is really a \\\"soft\\\" burn (total supply is not reduced). RFI holders\\r\\n     * get two benefits from burning tokens:\\r\\n     *\\r\\n     * 1) Tokens in the burn address increase the % of tokens held by holders not\\r\\n     *    excluded from rewards (assuming the burn address is excluded)\\r\\n     * 2) Tokens in the burn address cannot be sold (which in turn draing the \\r\\n     *    liquidity pool)\\r\\n     *\\r\\n     *\\r\\n     * In RFI holders already get % of each transaction so the value of their tokens \\r\\n     * increases (in a way). Therefore there is really no need to do a \\\"hard\\\" burn \\r\\n     * (reduce the total supply). What matters (in RFI) is to make sure that a large\\r\\n     * amount of tokens cannot be sold = draining the liquidity pool = lowering the\\r\\n     * value of tokens holders own. For this purpose, transfering tokens to a (vanity)\\r\\n     * burn address is the most appropriate way to \\\"burn\\\". \\r\\n     *\\r\\n     * There is an extra check placed into the `transfer` function to make sure the\\r\\n     * burn address cannot withdraw the tokens is has (although the chance of someone\\r\\n     * having/finding the private key is virtually zero).\\r\\n     */\\r\\n    function burn(uint256 amount) external {\\r\\n\\r\\n        address sender = _msgSender();\\r\\n        require(sender != address(0), \\\"BaseRfiToken: burn from the zero address\\\");\\r\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: burn from the burn address\\\");\\r\\n\\r\\n        uint256 balance = balanceOf(sender);\\r\\n        require(balance \\u003e= amount, \\\"BaseRfiToken: burn amount exceeds balance\\\");\\r\\n\\r\\n        uint256 reflectedAmount = amount.mul(_getCurrentRate());\\r\\n\\r\\n        // remove the amount from the sender\\u0027s balance first\\r\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(reflectedAmount);\\r\\n        if (_isExcludedFromRewards[sender])\\r\\n            _balances[sender] = _balances[sender].sub(amount);\\r\\n\\r\\n        _burnTokens( sender, amount, reflectedAmount );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev \\\"Soft\\\" burns the specified amount of tokens by sending them \\r\\n     * to the burn address\\r\\n     */\\r\\n    function _burnTokens(address sender, uint256 tBurn, uint256 rBurn) internal {\\r\\n\\r\\n        /**\\r\\n         * @dev Do not reduce _totalSupply and/or _reflectedSupply. (soft) burning by sending\\r\\n         * tokens to the burn address (which should be excluded from rewards) is sufficient\\r\\n         * in RFI\\r\\n         */ \\r\\n        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(rBurn);\\r\\n        if (_isExcludedFromRewards[burnAddress])\\r\\n            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\\r\\n\\r\\n        /**\\r\\n         * @dev Emit the event so that the burn address balance is updated (on bscscan)\\r\\n         */\\r\\n        emit Transfer(sender, burnAddress, tBurn);\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function isExcludedFromReward(address account) external view returns (bool) {\\r\\n        return _isExcludedFromRewards[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and returns the reflected amount for the given amount with or without \\r\\n     * the transfer fees (deductTransferFee true/false)\\r\\n     */\\r\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns(uint256) {\\r\\n        require(tAmount \\u003c= TOTAL_SUPPLY, \\\"Amount must be less than supply\\\");\\r\\n        if (!deductTransferFee) {\\r\\n            (uint256 rAmount,,,,) = _getValues(tAmount,0);\\r\\n            return rAmount;\\r\\n        } else {\\r\\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount,_getSumOfFees(_msgSender(), tAmount));\\r\\n            return rTransferAmount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\\r\\n     */\\r\\n    function tokenFromReflection(uint256 rAmount) internal view returns(uint256) {\\r\\n        require(rAmount \\u003c= _reflectedSupply, \\\"Amount must be less than total reflections\\\");\\r\\n        uint256 currentRate = _getCurrentRate();\\r\\n        return rAmount.div(currentRate);\\r\\n    }\\r\\n    \\r\\n    function excludeFromReward(address account) external onlyOwner() {\\r\\n        require(!_isExcludedFromRewards[account], \\\"Account is not included\\\");\\r\\n        _exclude(account);\\r\\n    }\\r\\n    \\r\\n    function _exclude(address account) internal {\\r\\n        if(_reflectedBalances[account] \\u003e 0) {\\r\\n            _balances[account] = tokenFromReflection(_reflectedBalances[account]);\\r\\n        }\\r\\n        _isExcludedFromRewards[account] = true;\\r\\n        _excluded.push(account);\\r\\n    }\\r\\n\\r\\n    function includeInReward(address account) external onlyOwner() {\\r\\n        require(_isExcludedFromRewards[account], \\\"Account is not excluded\\\");\\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_excluded[i] == account) {\\r\\n                _excluded[i] = _excluded[_excluded.length - 1];\\r\\n                _balances[account] = 0;\\r\\n                _isExcludedFromRewards[account] = false;\\r\\n                _excluded.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function setExcludedFromFee(address account, bool value) external onlyOwner { _isExcludedFromFee[account] = value; }\\r\\n    function isExcludedFromFee(address account) public view returns(bool) { return _isExcludedFromFee[account]; }\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 amount) internal {\\r\\n        require(owner != address(0), \\\"BaseRfiToken: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"BaseRfiToken: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     */\\r\\n    function _isUnlimitedSender(address account) internal view returns(bool){\\r\\n        // the owner should be the only whitelisted sender\\r\\n        return (account == owner());\\r\\n    }\\r\\n    /**\\r\\n     */\\r\\n    function _isUnlimitedRecipient(address account) internal view returns(bool){\\r\\n        // the owner should be a white-listed recipient\\r\\n        // and anyone should be able to burn as many tokens as \\r\\n        // he/she wants\\r\\n        return (account == owner() || account == burnAddress);\\r\\n    }\\r\\n\\r\\n    function _transfer(address sender, address recipient, uint256 amount) private {\\r\\n        require(sender != address(0), \\\"BaseRfiToken: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"BaseRfiToken: transfer to the zero address\\\");\\r\\n        require(sender != address(burnAddress), \\\"BaseRfiToken: transfer from the burn address\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        \\r\\n        // indicates whether or not feee should be deducted from the transfer\\r\\n        bool takeFee = true;\\r\\n\\r\\n        if ( isInPresale ){ takeFee = false; }\\r\\n        else {\\r\\n            /**\\r\\n            * Check the amount is within the max allowed limit as long as a\\r\\n            * unlimited sender/recepient is not involved in the transaction\\r\\n            */\\r\\n            if ( amount \\u003e maxTransactionAmount \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) ){\\r\\n                revert(\\\"Transfer amount exceeds the maxTxAmount.\\\");\\r\\n            }\\r\\n            /**\\r\\n            * The pair needs to excluded from the max wallet balance check; \\r\\n            * selling tokens is sending them back to the pair (without this\\r\\n            * check, selling tokens would not work if the pair\\u0027s balance \\r\\n            * was over the allowed max)\\r\\n            *\\r\\n            * Note: This does NOT take into account the fees which will be deducted \\r\\n            *       from the amount. As such it could be a bit confusing \\r\\n            */\\r\\n            if ( maxWalletBalance \\u003e 0 \\u0026\\u0026 !_isUnlimitedSender(sender) \\u0026\\u0026 !_isUnlimitedRecipient(recipient) \\u0026\\u0026 !_isV2Pair(recipient) ){\\r\\n                uint256 recipientBalance = balanceOf(recipient);\\r\\n                require(recipientBalance + amount \\u003c= maxWalletBalance, \\\"New balance would exceed the maxWalletBalance\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]){ takeFee = false; }\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount, takeFee);\\r\\n        _transferTokens(sender, recipient, amount, takeFee);\\r\\n        \\r\\n    }\\r\\n\\r\\n    function _transferTokens(address sender, address recipient, uint256 amount, bool takeFee) private {\\r\\n    \\r\\n        /**\\r\\n         * We don\\u0027t need to know anything about the individual fees here \\r\\n         * (like Safemoon does with `_getValues`). All that is required \\r\\n         * for the transfer is the sum of all fees to calculate the % of the total \\r\\n         * transaction amount which should be transferred to the recipient. \\r\\n         *\\r\\n         * The `_takeFees` call will/should take care of the individual fees\\r\\n         */\\r\\n        uint256 sumOfFees = _getSumOfFees(sender, amount);\\r\\n        if ( !takeFee ){ sumOfFees = 0; }\\r\\n        \\r\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 tAmount, uint256 tTransferAmount, uint256 currentRate ) = _getValues(amount, sumOfFees);\\r\\n        \\r\\n        /** \\r\\n         * Sender\\u0027s and Recipient\\u0027s reflected balances must be always updated regardless of\\r\\n         * whether they are excluded from rewards or not.\\r\\n         */ \\r\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\\r\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rTransferAmount);\\r\\n\\r\\n        /**\\r\\n         * Update the true/nominal balances for excluded accounts\\r\\n         */        \\r\\n        if (_isExcludedFromRewards[sender]){ _balances[sender] = _balances[sender].sub(tAmount); }\\r\\n        if (_isExcludedFromRewards[recipient] ){ _balances[recipient] = _balances[recipient].add(tTransferAmount); }\\r\\n        \\r\\n        _takeFees( amount, currentRate, sumOfFees );\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n    \\r\\n    function _takeFees(uint256 amount, uint256 currentRate, uint256 sumOfFees ) private {\\r\\n        if ( sumOfFees \\u003e 0 \\u0026\\u0026 !isInPresale ){\\r\\n            _takeTransactionFees(amount, currentRate);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getValues(uint256 tAmount, uint256 feesSum) internal view returns (uint256, uint256, uint256, uint256, uint256) {\\r\\n        \\r\\n        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\\r\\n        uint256 tTransferAmount = tAmount.sub(tTotalFees);\\r\\n        uint256 currentRate = _getCurrentRate();\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n        uint256 rTotalFees = tTotalFees.mul(currentRate);\\r\\n        uint256 rTransferAmount = rAmount.sub(rTotalFees);\\r\\n        \\r\\n        return (rAmount, rTransferAmount, tAmount, tTransferAmount, currentRate);\\r\\n    }\\r\\n    \\r\\n    function _getCurrentRate() internal view returns(uint256) {\\r\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\r\\n        return rSupply.div(tSupply);\\r\\n    }\\r\\n    \\r\\n    function _getCurrentSupply() internal view returns(uint256, uint256) {\\r\\n        uint256 rSupply = _reflectedSupply;\\r\\n        uint256 tSupply = TOTAL_SUPPLY;  \\r\\n\\r\\n        /**\\r\\n         * The code below removes balances of addresses excluded from rewards from\\r\\n         * rSupply and tSupply, which effectively increases the % of transaction fees\\r\\n         * delivered to non-excluded holders\\r\\n         */    \\r\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\r\\n            if (_reflectedBalances[_excluded[i]] \\u003e rSupply || _balances[_excluded[i]] \\u003e tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\\r\\n            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\\r\\n            tSupply = tSupply.sub(_balances[_excluded[i]]);\\r\\n        }\\r\\n        if (tSupply == 0 || rSupply \\u003c _reflectedSupply.div(TOTAL_SUPPLY)) return (_reflectedSupply, TOTAL_SUPPLY);\\r\\n        return (rSupply, tSupply);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens.\\r\\n     */\\r\\n    function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal virtual;\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the total sum of fees to be processed in each transaction. \\r\\n     * \\r\\n     * To separate concerns this contract (class) will take care of ONLY handling RFI, i.e. \\r\\n     * changing the rates and updating the holder\\u0027s balance (via `_redistribute`). \\r\\n     * It is the responsibility of the dev/user to handle all other fees and taxes \\r\\n     * in the appropriate contracts (classes).\\r\\n     */ \\r\\n    function _getSumOfFees(address sender, uint256 amount) internal view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev A delegate which should return true if the given address is the V2 Pair and false otherwise\\r\\n     */\\r\\n    function _isV2Pair(address account) internal view virtual returns(bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Redistributes the specified amount among the current holders via the reflect.finance\\r\\n     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\\r\\n     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`. \\r\\n     * This is the bit of clever math which allows rfi to redistribute the fee without \\r\\n     * having to iterate through all holders. \\r\\n     * \\r\\n     * Visit our discord at https://discord.gg/t9v7v3kx25\\r\\n     */\\r\\n    function _redistribute(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) internal {\\r\\n        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rFee = tFee.mul(currentRate);\\r\\n\\r\\n        _reflectedSupply = _reflectedSupply.sub(rFee);\\r\\n        _addFeeCollectedAmount(index, tFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before the `Transfer` event is emitted if fees are enabled for the transfer\\r\\n     */\\r\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal virtual;\\r\\n}\\r\\n\\r\\nabstract contract Liquifier is Ownable, Manageable {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 private withdrawableBalance;\\r\\n\\r\\n    enum Env {Testnet, MainnetV1, MainnetV2}\\r\\n    Env private _env;\\r\\n\\r\\n    // PancakeSwap V1\\r\\n    address private _mainnetRouterV1Address = 0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\\r\\n    // PancakeSwap V2\\r\\n    address private _mainnetRouterV2Address = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    // Testnet\\r\\n    // address private _testnetRouterAddress = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\r\\n\\r\\n    IPancakeV2Router internal _router;\\r\\n    address internal _pair;\\r\\n    \\r\\n    bool private inSwapAndLiquify;\\r\\n    bool private swapAndLiquifyEnabled = true;\\r\\n\\r\\n    uint256 private maxTransactionAmount;\\r\\n    uint256 private numberOfTokensToSwapToLiquidity;\\r\\n\\r\\n    modifier lockTheSwap {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    event RouterSet(address indexed router);\\r\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiquidity);\\r\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\r\\n    event LiquidityAdded(uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity);\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function initializeLiquiditySwapper(Env env, uint256 maxTx, uint256 liquifyAmount) internal {\\r\\n        _env = env;\\r\\n        if (_env == Env.MainnetV1){ _setRouterAddress(_mainnetRouterV1Address); }\\r\\n        else if (_env == Env.MainnetV2){ _setRouterAddress(_mainnetRouterV2Address); }\\r\\n    \\r\\n\\r\\n        maxTransactionAmount = maxTx;\\r\\n        numberOfTokensToSwapToLiquidity = liquifyAmount;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * NOTE: passing the `contractTokenBalance` here is preferred to creating `balanceOfDelegate`\\r\\n     */\\r\\n    function liquify(uint256 contractTokenBalance, address sender) internal {\\r\\n\\r\\n        if (contractTokenBalance \\u003e= maxTransactionAmount) contractTokenBalance = maxTransactionAmount;\\r\\n        \\r\\n        bool isOverRequiredTokenBalance = ( contractTokenBalance \\u003e= numberOfTokensToSwapToLiquidity );\\r\\n        \\r\\n        /**\\r\\n         * - first check if the contract has collected enough tokens to swap and liquify\\r\\n         * - then check swap and liquify is enabled\\r\\n         * - then make sure not to get caught in a circular liquidity event\\r\\n         * - finally, don\\u0027t swap \\u0026 liquify if the sender is the uniswap pair\\r\\n         */\\r\\n        if ( isOverRequiredTokenBalance \\u0026\\u0026 swapAndLiquifyEnabled \\u0026\\u0026 !inSwapAndLiquify \\u0026\\u0026 (sender != _pair) ){\\r\\n            // TODO check if the `(sender != _pair)` is necessary because that basically\\r\\n            // stops swap and liquify for all \\\"buy\\\" transactions\\r\\n            _swapAndLiquify(contractTokenBalance);            \\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev sets the router address and created the router, factory pair to enable\\r\\n     * swapping and liquifying (contract) tokens\\r\\n     */\\r\\n    function _setRouterAddress(address router) private {\\r\\n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(router);\\r\\n        _pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(address(this), _newPancakeRouter.WETH());\\r\\n        _router = _newPancakeRouter;\\r\\n        emit RouterSet(router);\\r\\n    }\\r\\n    \\r\\n    function _swapAndLiquify(uint256 amount) private lockTheSwap {\\r\\n        \\r\\n        // split the contract balance into halves\\r\\n        uint256 half = amount.div(2);\\r\\n        uint256 otherHalf = amount.sub(half);\\r\\n        \\r\\n        // capture the contract\\u0027s current ETH balance.\\r\\n        // this is so that we can capture exactly the amount of ETH that the\\r\\n        // swap creates, and not make the liquidity event include any ETH that\\r\\n        // has been manually sent to the contract\\r\\n        uint256 initialBalance = address(this).balance;\\r\\n        \\r\\n        // swap tokens for ETH\\r\\n        _swapTokensForEth(half); // \\u003c- this breaks the ETH -\\u003e HATE swap when swap+liquify is triggered\\r\\n\\r\\n        // how much ETH did we just swap into?\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n\\r\\n        // add liquidity to uniswap\\r\\n        _addLiquidity(otherHalf, newBalance);\\r\\n        \\r\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\r\\n    }\\r\\n    \\r\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\r\\n        \\r\\n        // generate the uniswap pair path of token -\\u003e weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _router.WETH();\\r\\n\\r\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\r\\n\\r\\n        // make the swap\\r\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            // The minimum amount of output tokens that must be received for the transaction not to revert.\\r\\n            // 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\r\\n\\r\\n        // add tahe liquidity\\r\\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) = _router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            // Bounds the extent to which the WETH/token price can go up before the transaction reverts. \\r\\n            // Must be \\u003c= amountTokenDesired; 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            // Bounds the extent to which the token/WETH price can go up before the transaction reverts.\\r\\n            // 0 = accept any amount (slippage is inevitable)\\r\\n            0,\\r\\n            // !\\r\\n            owner(),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        // !\\r\\n        /**\\r\\n         * !\\r\\n         */\\r\\n        withdrawableBalance = address(this).balance;\\r\\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\\r\\n    }\\r\\n    \\r\\n\\r\\n    /**\\r\\n    * @dev Sets the uniswapV2 pair (router \\u0026 factory) for swapping and liquifying tokens\\r\\n    */\\r\\n    function setRouterAddress(address router) external onlyManager() {\\r\\n        _setRouterAddress(router);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sends the swap and liquify flag to the provided value. If set to `false` tokens collected in the contract will\\r\\n     * NOT be converted into liquidity.\\r\\n     */\\r\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyManager {\\r\\n        swapAndLiquifyEnabled = enabled;\\r\\n        emit SwapAndLiquifyEnabledUpdated(swapAndLiquifyEnabled);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * !\\r\\n     */\\r\\n    function withdrawLockedEth(address payable recipient) external onlyManager(){\\r\\n        require(recipient != address(0), \\\"Cannot withdraw the ETH balance to the zero address\\\");\\r\\n        require(withdrawableBalance \\u003e 0, \\\"The ETH balance must be greater than 0\\\");\\r\\n\\r\\n        // prevent re-entrancy attacks\\r\\n        uint256 amount = withdrawableBalance;\\r\\n        withdrawableBalance = 0;\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Use this delegate instead of having (unnecessarily) extend `BaseRfiToken` to gained access \\r\\n     * to the `_approve` function.\\r\\n     */\\r\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal virtual;\\r\\n\\r\\n}\\r\\n\\r\\n//////////////////////////////////////////////////////////////////////////\\r\\nabstract contract Antiwhale is Tokenomics {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total sum of fees (in percents / per-mille - this depends on the FEES_DIVISOR value)\\r\\n     *\\r\\n     * NOTE: Currently this is just a placeholder. The parameters passed to this function are the\\r\\n     *      sender\\u0027s token balance and the transfer amount. An *antiwhale* mechanics can use these \\r\\n     *      values to adjust the fees total for each tx\\r\\n     */\\r\\n    // function _getAntiwhaleFees(uint256 sendersBalance, uint256 amount) internal view returns (uint256){\\r\\n    function _getAntiwhaleFees(uint256, uint256) internal view returns (uint256){\\r\\n        return sumOfFees;\\r\\n    }\\r\\n}\\r\\n//////////////////////////////////////////////////////////////////////////\\r\\n\\r\\nabstract contract SafeToken is BaseRfiToken, Liquifier, Antiwhale {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // constructor(string memory _name, string memory _symbol, uint8 _decimals){\\r\\n    constructor(Env _env){\\r\\n\\r\\n        initializeLiquiditySwapper(_env, maxTransactionAmount, numberOfTokensToSwapToLiquidity);\\r\\n\\r\\n        // exclude the pair address from rewards - we don\\u0027t want to redistribute\\r\\n        // tx fees to these two; redistribution is only for holders, dah!\\r\\n        _exclude(_pair);\\r\\n        _exclude(burnAddress);\\r\\n    }\\r\\n    \\r\\n    function _isV2Pair(address account) internal view override returns(bool){\\r\\n        return (account == _pair);\\r\\n    }\\r\\n\\r\\n    function _getSumOfFees(address sender, uint256 amount) internal view override returns (uint256){ \\r\\n        return _getAntiwhaleFees(balanceOf(sender), amount); \\r\\n    }\\r\\n    \\r\\n    // function _beforeTokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) internal override {\\r\\n    function _beforeTokenTransfer(address sender, address , uint256 , bool ) internal override {\\r\\n        if ( !isInPresale ){\\r\\n            uint256 contractTokenBalance = balanceOf(address(this));\\r\\n            liquify( contractTokenBalance, sender );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate) internal override {\\r\\n        \\r\\n        if( isInPresale ){ return; }\\r\\n\\r\\n        uint256 feesCount = _getFeesCount();\\r\\n        for (uint256 index = 0; index \\u003c feesCount; index++ ){\\r\\n            (FeeType name, uint256 value, address recipient,) = _getFee(index);\\r\\n            // no need to check value \\u003c 0 as the value is uint (i.e. from 0 to 2^256-1)\\r\\n            if ( value == 0 ) continue;\\r\\n\\r\\n            if ( name == FeeType.Rfi ){\\r\\n                _redistribute( amount, currentRate, value, index );\\r\\n            }\\r\\n            else if ( name == FeeType.Burn ){\\r\\n                _burn( amount, currentRate, value, index );\\r\\n            }\\r\\n            else if ( name == FeeType.Antiwhale){\\r\\n                // TODO\\r\\n            }\\r\\n            else if ( name == FeeType.ExternalToETH){\\r\\n                _takeFeeToETH( amount, currentRate, value, recipient, index );\\r\\n            }\\r\\n            else {\\r\\n                _takeFee( amount, currentRate, value, recipient, index );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 amount, uint256 currentRate, uint256 fee, uint256 index) private {\\r\\n        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rBurn = tBurn.mul(currentRate);\\r\\n\\r\\n        _burnTokens(address(this), tBurn, rBurn);\\r\\n        _addFeeCollectedAmount(index, tBurn);\\r\\n    }\\r\\n\\r\\n    function _takeFee(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\r\\n\\r\\n        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\\r\\n        uint256 rAmount = tAmount.mul(currentRate);\\r\\n\\r\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(rAmount);\\r\\n        if(_isExcludedFromRewards[recipient])\\r\\n            _balances[recipient] = _balances[recipient].add(tAmount);\\r\\n\\r\\n        _addFeeCollectedAmount(index, tAmount);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev When implemented this will convert the fee amount of tokens into ETH/BNB\\r\\n     * and send to the recipient\\u0027s wallet. Note that this reduces liquidity so it \\r\\n     * might be a good idea to add a % into the liquidity fee for % you take our through\\r\\n     * this method (just a suggestions)\\r\\n     */\\r\\n    function _takeFeeToETH(uint256 amount, uint256 currentRate, uint256 fee, address recipient, uint256 index) private {\\r\\n        _takeFee(amount, currentRate, fee, recipient, index);        \\r\\n    }\\r\\n\\r\\n    function _approveDelegate(address owner, address spender, uint256 amount) internal override {\\r\\n        _approve(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract nftdeseo is SafeToken{\\r\\n\\r\\n    constructor() SafeToken(Env.MainnetV2){\\r\\n        // pre-approve the initial liquidity supply (to safe a bit of time)\\r\\n        _approve(owner(),address(_router), ~uint256(0));\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"RouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPreseableEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawLockedEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "nftdeseo", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7324c537d39f9f10575eee057b8531ae862cd4c0b133f6d89e2e55150360fca7"}