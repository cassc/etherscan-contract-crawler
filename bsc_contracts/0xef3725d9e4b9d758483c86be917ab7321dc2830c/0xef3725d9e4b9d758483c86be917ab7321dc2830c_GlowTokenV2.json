{"SourceCode": "{\"GlowV3.sol\":{\"content\":\"/**\\r\\nTG: https://t.me/GLOW_Token_Official\\r\\nWebsite: https://glowtoken.online/\\r\\nAuthor: @DaisyOfficialTG\\r\\n */\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n \\r\\nimport \\\"./Libraries.sol\\\";\\r\\n \\r\\ncontract GlowTokenV2 is Ownable, IBEP20{\\r\\n    using Address for address;\\r\\n \\r\\n    // Basic Contract Info\\r\\n    uint256 private constant _totalSupply = 1_000_000_000_000_000*10**9; // 1 Quad\\r\\n    uint8 private constant _tokenDecimals=9;\\r\\n    string private constant _tokenName=\\\"Glow Token V2\\\";\\r\\n    string private constant _tokenSymbol=\\\"Glow V2\\\";\\r\\n    //Liquidity Variables\\r\\n    uint256 public liquidityUnlockSeconds;\\r\\n    uint256 private _fixedLPLockTime=60 days;\\r\\n    // Boolean variables\\r\\n    bool private _tradingEnabled;\\r\\n    bool private _inSwap;\\r\\n    bool public swapEnabled;\\r\\n    bool public lotteryEnabled;\\r\\n    bool public rewardsEnabled;\\r\\n    bool private _addingLP;\\r\\n    bool private _removingLP;\\r\\n    // Team Addresses\\r\\n    address public coFounder_1=0x8e68D30Ae71E32bA1e13cDce606838f70ca83C3C;\\r\\n    address public coFounder_2=0xf545d69BC89711CA855e6c24fd7fC935ce5B604B;\\r\\n    address public coFounder_3=0x09B658C800Bb644a51A3d6eA88D5714eb4ACe4E7;\\r\\n    address public VPCustomerRelations=0x999C8324f34b40437d2625ad4f79D801F15138Cf;\\r\\n    address public VPOperations=0xC5D74A9bA8ba15e62c1d5C814ce3b8aC0dA686f7;\\r\\n    address public headDevelopment=0x0209564AcaF3c354BB681E27b018fdcFD8E109d3;\\r\\n    address public developer_1=0xB4e06da1aB74E1742b73Da6a1B9D0eFBb761119b;\\r\\n    address public developer_2=0x66FF2BF3937b4a196479Df61235f3Ed4118C2bD7;\\r\\n    address public leadDeveloper=0x4f509E30853F77b03a45f6e41F8273e82B55C174;\\r\\n    // Public Addresses\\r\\n    address public defaultRewardToken=0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // BUSD\\r\\n    address public _pancakeRouterAddress=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    address public burnWallet = 0x000000000000000000000000000000000000dEaD;\\r\\n    address public airDropper;\\r\\n    // Router addresses\\r\\n    IPancakeRouter02 private _pancakeRouter;\\r\\n    address public pancakePairAddress;\\r\\n    // Events\\r\\n    event OwnerUpdateDefaultRewardToken(address defaultRewardToken);\\r\\n    event OwnerUpdatePancakePair(address pair,address router);\\r\\n    event OwnerUpdateAMM(address AMM,bool enabled);\\r\\n    event OwnerLockTeamWallet(address account,bool locked);\\r\\n    event OwnerExcludeFromFees(address account,bool enabled);\\r\\n    event OwnerBlacklistWallet(address account,bool enabled);\\r\\n    event OwnerFixStuckBNB(uint256 amountWei);\\r\\n    event OwnerExtendLPLock(uint256 timeSeconds);\\r\\n    event OwnerBoostContract(uint256 amountWei);\\r\\n    event OwnerSetIncludedToLottery(address account);\\r\\n    event OwnerSetExcludedFromLottery(address account);\\r\\n    event OwnerSetIncludedToRewards(address account);\\r\\n    event OwnerSetExcludedFromRewards(address account);\\r\\n    event OwnerSetRewardSetting(uint256 minPeriod,uint256 minDistribution);\\r\\n    event OwnerSetLotterySetting(uint256 minPeriod,uint256 percentage,uint256 minBalance);\\r\\n    event OwnerSwitchRewardsEnabled(bool enabled);\\r\\n    event OwnerSwitchLotteryEnabled(bool enabled);\\r\\n    event OwnerSwitchSwapEnabled(bool enabled);\\r\\n    event OwnerTriggerSwap(uint256 swapThreshold,bool ignoreLimits);\\r\\n    event OwnerTriggerLottery(uint256 percentage);\\r\\n    event OwnerUpdateSwapThreshold(uint256 swapThreshold);\\r\\n    event OwnerUpdateSecondaryTaxes(uint256 liquidity,uint256 lottery,uint256 charity,uint256 rewards,uint256 marketing);\\r\\n    event OwnerUpdateTaxes(uint256 buyTax,uint256 sellTax);\\r\\n    event OwnerEnableTrading(uint256 timestamp);\\r\\n    event OwnerRemoveLPPercent(uint256 LPPercent);\\r\\n    event OwnerReleaseLP(uint256 LPPercent);\\r\\n    event OwnerCreateLP(uint256 amountTokens,uint256 amountBNB);\\r\\n    event OwnerSetAirDropper(address airDropper);\\r\\n    event LiquidityAdded(uint256 amountTokens,uint256 amountBNB);\\r\\n    event SetCustomRewardToken(address account,address rewardToken);\\r\\n    // Mappings\\r\\n    address[] holders; // Store lottery users\\r\\n    address[] shareholders; // Store reward users\\r\\n    mapping(address =\\u003e uint256) holderIndexes; \\r\\n    mapping(address =\\u003e uint256) shareholderIndexes;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n    mapping(address=\\u003ebool) private _excludeFromFees;\\r\\n    mapping(address=\\u003ebool) private _excludeFromRewards;\\r\\n    mapping(address=\\u003ebool) private _excludeFromLottery;\\r\\n    mapping(address=\\u003ebool) private _automatedMarketMakers;\\r\\n    mapping(address=\\u003eHolder) private _holders;\\r\\n    mapping(address=\\u003ebool) private _blacklisted;\\r\\n    // Lock \\u0026 unlock team wallets only\\r\\n    mapping(address=\\u003ebool) private _teamWalletLock;\\r\\n    uint256 private _nonce;\\r\\n    uint256 currentIndex;\\r\\n    // Structs\\r\\n    Tax private _tax;\\r\\n    Limit private _limit;\\r\\n    Tracker private _tracker;\\r\\n    Lottery private _lottery;\\r\\n    Rewards private _rewards;\\r\\n    struct Tracker {\\r\\n        uint256 profitPerToken;\\r\\n        uint256 totalTokensHeld;\\r\\n        uint256 totalMarketingBNB;\\r\\n        uint256 totalLotteryBNB;\\r\\n        uint256 totalCharityBNB;\\r\\n        uint256 totalLiquidityBNB;\\r\\n        uint256 totalRewardBNB;\\r\\n        uint256 totalRewardBNBPayout;\\r\\n    }\\r\\n    struct Limit {\\r\\n        // Tax limits\\r\\n        uint8 maxBuyTax;\\r\\n        uint8 maxSellTax;\\r\\n        // Swap variables\\r\\n        uint8 maxSwapThreshold;\\r\\n        uint8 swapThreshold;\\r\\n        // Transaction limits\\r\\n        uint256 maxWalletSize;\\r\\n        uint256 maxSellSize;\\r\\n    }\\r\\n    struct Tax {\\r\\n        // Primary Taxes\\r\\n        uint8 buyTax;\\r\\n        uint8 sellTax;\\r\\n        // Secondary Taxes\\r\\n        uint8 liquidityTax;\\r\\n        uint8 lotteryTax;\\r\\n        uint8 charityTax;\\r\\n        uint8 rewardsTax;\\r\\n        uint8 marketingTax;\\r\\n    }\\r\\n    struct Holder {\\r\\n        bool hasCustomRewardToken;\\r\\n        address customRewardToken;\\r\\n        uint256 alreadyPaid;\\r\\n        uint256 toBePaid;\\r\\n        uint256 tokenLock;\\r\\n        uint256 lotteryAmount;\\r\\n        uint256 rewardsAmount;\\r\\n        uint256 lastClaim;\\r\\n    }\\r\\n    struct Lottery{\\r\\n        uint256 percentage;\\r\\n        uint256 lastLottery;\\r\\n        uint256 minPeriod;\\r\\n        uint256 minBalance;\\r\\n    }\\r\\n    struct Rewards{\\r\\n        uint256 minPeriod;\\r\\n        uint256 minDistribution;\\r\\n        uint256 gas;\\r\\n    }\\r\\n    modifier LockTheSwap {\\r\\n        _inSwap=true;\\r\\n        _;\\r\\n        _inSwap=false;\\r\\n    }\\r\\n    constructor() {\\r\\n        // Mint _totalSupply to address\\r\\n        _updateBalance(address(this),_totalSupply);\\r\\n        emit Transfer(address(0),address(this),_totalSupply);\\r\\n        // Exclude from fees \\u0026 rewards\\r\\n        _excludeFromFees[address(this)]=_excludeFromFees[msg.sender]=true;\\r\\n        _excludeFromRewards[address(this)]=_excludeFromRewards[pancakePairAddress]=_excludeFromRewards[burnWallet]=true;\\r\\n        _excludeFromLottery[address(this)]=_excludeFromLottery[pancakePairAddress]=_excludeFromLottery[burnWallet]=true;\\r\\n        // Initialize Pancake Pair\\r\\n        _pancakeRouter=IPancakeRouter02(_pancakeRouterAddress);\\r\\n        pancakePairAddress=IPancakeFactory(_pancakeRouter.factory()).createPair(address(this),_pancakeRouter.WETH());\\r\\n        _approve(address(this),address(_pancakeRouter),type(uint256).max);\\r\\n        _automatedMarketMakers[pancakePairAddress]=true;\\r\\n        // Set initial taxes\\r\\n        _tax.buyTax=_limit.maxBuyTax=15;\\r\\n        _tax.sellTax=_limit.maxSellTax=15;\\r\\n        _tax.liquidityTax=_tax.lotteryTax=_tax.charityTax=_tax.rewardsTax=_tax.marketingTax=20;\\r\\n        _limit.swapThreshold=_limit.maxSwapThreshold=50;\\r\\n        // Set initial lottery \\u0026 reward settings\\r\\n        _lottery.percentage=100;\\r\\n        _lottery.minPeriod=_rewards.minPeriod=1 hours;\\r\\n        lotteryEnabled=rewardsEnabled=swapEnabled=true;\\r\\n        _rewards.gas=500000;\\r\\n        // Set transaction limits\\r\\n        _limit.maxWalletSize=_limit.maxSellSize=_totalSupply/100; // 1 %\\r\\n    }\\r\\n///////// Transfer Functions \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\n    function _transfer(address sender,address recipient,uint256 amount) private {\\r\\n        require(sender!=address(0)\\u0026\\u0026recipient!=address(0),\\\"Cannot be address(0).\\\");\\r\\n        bool isBuy=_automatedMarketMakers[sender];\\r\\n        bool isSell=_automatedMarketMakers[recipient];\\r\\n        bool isExcluded=_excludeFromFees[sender]||_excludeFromFees[recipient]||_addingLP||_removingLP;\\r\\n        if(isExcluded)_transferExcluded(sender,recipient,amount);\\r\\n        else {\\r\\n            require(_tradingEnabled);\\r\\n            if(isBuy)_buyTokens(sender,recipient,amount);\\r\\n            else if(isSell) {\\r\\n                // Swap \\u0026 Liquify\\r\\n                if(!_inSwap\\u0026\\u0026swapEnabled)_swapAndLiquify(_limit.swapThreshold,false);\\r\\n                // Lottery\\r\\n                if(_shouldSendLottery())_sendLotteryReward(_lottery.percentage);\\r\\n                // Rewards\\r\\n                if(_shouldProcessRewards())_processRewards(_rewards.gas);\\r\\n                _sellTokens(sender,recipient,amount);\\r\\n            } else {\\r\\n                // P2P Transfer\\r\\n                require(!_blacklisted[sender]\\u0026\\u0026!_blacklisted[recipient]);\\r\\n                require(!_teamWalletLock[sender]\\u0026\\u0026!_teamWalletLock[recipient]);\\r\\n                require(_balances[recipient]+amount\\u003c=_limit.maxWalletSize);\\r\\n                _transferExcluded(sender,recipient,amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function _buyTokens(address sender,address recipient,uint256 amount) private {\\r\\n        require(!_blacklisted[recipient]);\\r\\n        // Team wallet must be unlocked to buy.\\r\\n        require(!_teamWalletLock[recipient]);\\r\\n        require(_balances[recipient]+amount\\u003c=_limit.maxWalletSize);\\r\\n        uint256 tokenTax=amount*_tax.buyTax/100;\\r\\n        _transferIncluded(sender,recipient,amount,tokenTax);\\r\\n    }\\r\\n    function _sellTokens(address sender,address recipient,uint256 amount) private {\\r\\n        require(!_blacklisted[sender]);\\r\\n        // Team wallet must be unlocked to sell.\\r\\n        require(!_teamWalletLock[sender]);\\r\\n        require(amount\\u003c=_limit.maxSellSize);\\r\\n        uint256 tokenTax=amount*_tax.sellTax/100;\\r\\n        _transferIncluded(sender,recipient,amount,tokenTax);\\r\\n    }\\r\\n    function _updateBalance(address account,uint256 newBalance) private {\\r\\n        _balances[account]=newBalance;\\r\\n        if(!_excludeFromRewards[account])_setShareholder(account,_balances[account]);\\r\\n        if(!_excludeFromLottery[account])_setHolder(account,_balances[account]);\\r\\n        else return;\\r\\n    }\\r\\n    function _transferExcluded(address sender,address recipient,uint256 amount) private {\\r\\n        _updateBalance(sender,_balances[sender]-amount);\\r\\n        _updateBalance(recipient,_balances[recipient]+amount);\\r\\n        emit Transfer(sender,recipient,amount);\\r\\n    }\\r\\n    function _transferIncluded(address sender,address recipient,uint256 amount,uint256 tokenTax) private {\\r\\n        uint256 newAmount=amount-tokenTax;\\r\\n        _updateBalance(sender,_balances[sender]-amount);\\r\\n        _updateBalance(address(this),_balances[address(this)]+tokenTax);\\r\\n        _updateBalance(recipient,_balances[recipient]+newAmount);\\r\\n        emit Transfer(sender,recipient,newAmount);\\r\\n    }\\r\\n    function _swapAndLiquify(uint8 swapThreshold,bool ignoreLimits) private LockTheSwap{\\r\\n        uint256 contractTokens=_balances[address(this)];\\r\\n        uint256 toSwap=swapThreshold*_balances[pancakePairAddress]/1000;\\r\\n        if(contractTokens\\u003ctoSwap)\\r\\n            if(ignoreLimits)\\r\\n                toSwap=contractTokens;\\r\\n            else return;\\r\\n        uint256 totalLPTokens=toSwap*_tax.liquidityTax/100;\\r\\n        uint256 tokensLeft=toSwap-totalLPTokens;\\r\\n        uint256 LPTokens=totalLPTokens/2;\\r\\n        uint256 LPBNBTokens=totalLPTokens-LPTokens;\\r\\n        toSwap=tokensLeft+LPBNBTokens;\\r\\n        uint256 oldBNB=address(this).balance;\\r\\n        _swapTokensForBNB(toSwap);\\r\\n        uint256 newBNB=address(this).balance-oldBNB;\\r\\n        uint256 LPBNB=(newBNB*LPBNBTokens)/toSwap;\\r\\n        _addLiquidity(LPTokens,LPBNB);\\r\\n        uint256 remainingBNB=address(this).balance-oldBNB;\\r\\n        _distributeBNB(remainingBNB);\\r\\n    }\\r\\n    function _distributeBNB(uint256 amountWei) private {\\r\\n        uint256 charityBNB=amountWei*_tax.charityTax/100;\\r\\n        uint256 lotteryBNB=amountWei*_tax.lotteryTax/100;\\r\\n        uint256 rewardBNB=amountWei*_tax.marketingTax/100;\\r\\n        uint256 marketingBNB=amountWei-(charityBNB+lotteryBNB+rewardBNB);\\r\\n        if(_tracker.totalTokensHeld==0)_tracker.totalMarketingBNB+=(charityBNB+lotteryBNB+rewardBNB+marketingBNB);\\r\\n        else {\\r\\n            _tracker.totalCharityBNB+=charityBNB;\\r\\n            _tracker.totalLotteryBNB+=lotteryBNB;\\r\\n            _tracker.totalRewardBNB+=rewardBNB;\\r\\n            _tracker.totalMarketingBNB+=marketingBNB;\\r\\n            _tracker.profitPerToken+=(_tracker.totalRewardBNB*(2**64))/_tracker.totalTokensHeld;\\r\\n        }\\r\\n    }\\r\\n    function _swapBNBtoRWRD(address account, uint256 amountWei) private {\\r\\n        bool swapSuccess;bool buyNoFeesSuccess;\\r\\n        IBEP20 RWRD = IBEP20(defaultRewardToken);\\r\\n        // check if holder has a custom reward set\\r\\n        if(_holders[account].hasCustomRewardToken){\\r\\n            RWRD = IBEP20(_holders[account].customRewardToken);\\r\\n        }\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(_pancakeRouter.WETH());\\r\\n        path[1] = address(RWRD);\\r\\n        if(RWRD == IBEP20(address(this))){ // If reward is this token, buy with no fees\\r\\n            bool prevExclusion = _excludeFromFees[account]; // ensure we don\\u0027t remove exclusions if the current wallet is already excluded\\r\\n            _excludeFromFees[msg.sender] = true;\\r\\n            //try to swap for tokens, if it fails (bad contract, or whatever other reason, send BNB)\\r\\n            try _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountWei}(\\r\\n                0,\\r\\n                path,\\r\\n                account,\\r\\n                block.timestamp\\r\\n            ){buyNoFeesSuccess = true;}\\r\\n            catch {buyNoFeesSuccess = false;}\\r\\n            _excludeFromFees[msg.sender] = prevExclusion; // set value to match original value\\r\\n            // if the swap failed, send them their BNB instead\\r\\n            if(!buyNoFeesSuccess){(bool success,) = account.call{value: amountWei, gas: 3000}(\\\"\\\");\\r\\n                if(!success) {_holders[account].alreadyPaid = _holders[account].alreadyPaid-(amountWei);}\\r\\n                }\\r\\n        }else { //\\r\\n            //try to swap for tokens, if it fails (bad contract, or whatever other reason, send BNB)\\r\\n            try _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountWei}(\\r\\n                0,\\r\\n                path,\\r\\n                account,\\r\\n                block.timestamp\\r\\n                ){swapSuccess = true;}\\r\\n            catch {swapSuccess = false;}\\r\\n            // if the swap failed, send them their BNB instead\\r\\n            if(!swapSuccess){(bool success,) = account.call{value: amountWei, gas: 3000}(\\\"\\\");\\r\\n                if(!success) {_holders[account].alreadyPaid = _holders[account].alreadyPaid-(amountWei);}\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n///////// Lottery Functions \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\n    function _shouldSendLottery() private view returns (bool) {\\r\\n        return msg.sender!=pancakePairAddress\\r\\n        \\u0026\\u0026 !_inSwap\\r\\n        \\u0026\\u0026 lotteryEnabled\\r\\n        \\u0026\\u0026 _lottery.lastLottery+_lottery.minPeriod\\u003c=block.timestamp\\r\\n        \\u0026\\u0026 _tracker.totalLotteryBNB\\u003e0;\\r\\n    }\\r\\n    function _excludeAccountFromLottery(address account) private {\\r\\n        require(!_excludeFromLottery[account],\\\"Already excluded\\\");\\r\\n        _excludeFromLottery[account]=true;\\r\\n        _setHolder(account,0);\\r\\n    } \\r\\n    function _includeAccountToLottery(address account) private {\\r\\n        require(_excludeFromLottery[account],\\\"Address is not excluded\\\");\\r\\n        _excludeFromLottery[account]=false;\\r\\n        _setHolder(account,_balances[account]);\\r\\n    }\\r\\n    function _random() public view returns (uint) {\\r\\n        uint r=uint(uint256(keccak256(abi.encodePacked(block.difficulty,block.timestamp,_nonce)))%holders.length);\\r\\n        return r;\\r\\n    }\\r\\n    function _sendLotteryReward(uint256 percentage) private returns (bool) {\\r\\n        uint rand = _random();\\r\\n        while(_balances[holders[rand]]\\u003c _lottery.minBalance){\\r\\n            rand = _random();\\r\\n        }\\r\\n        address payable winningAddress = payable(holders[rand]);\\r\\n        uint256 amountWei = _tracker.totalLotteryBNB*percentage/100;\\r\\n        _swapBNBtoRWRD(winningAddress, amountWei);\\r\\n        _tracker.totalLotteryBNB-=amountWei;\\r\\n        _lottery.lastLottery = block.timestamp;\\r\\n        return true;\\r\\n    }\\r\\n    function _setHolder(address account, uint256 amount) private { \\r\\n        if(amount \\u003e 0 \\u0026\\u0026 _holders[account].lotteryAmount == 0){\\r\\n            _addHolder(account);\\r\\n        }\\r\\n        if(amount == 0 \\u0026\\u0026 _holders[account].lotteryAmount \\u003e 0){\\r\\n            _removeHolder(account);\\r\\n        }\\r\\n        _holders[account].lotteryAmount = amount;\\r\\n    }\\r\\n    function _addHolder(address holder) private {\\r\\n        holderIndexes[holder] = holders.length;\\r\\n        holders.push(holder);\\r\\n    }\\r\\n    function _removeHolder(address holder) private {\\r\\n        holders[holderIndexes[holder]] = holders[holders.length-1];\\r\\n        holderIndexes[holders[holders.length-1]] = holderIndexes[holder];\\r\\n        holders.pop();\\r\\n    }\\r\\n///////// Rewards Functions \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\n    function setCustomRewardToken(address rewardToken) public {\\r\\n        require(rewardToken!=pancakePairAddress);\\r\\n        require(rewardToken.isContract(), \\\"Address is a wallet, not a contract.\\\");\\r\\n        _holders[msg.sender].customRewardToken=rewardToken;\\r\\n        _holders[msg.sender].hasCustomRewardToken=true;\\r\\n        emit SetCustomRewardToken(msg.sender,rewardToken);\\r\\n    }\\r\\n    function includeMeToRewards() public {\\r\\n        _includeAccountToRewards(msg.sender);\\r\\n    } \\r\\n    function _excludeAccountFromRewards(address account) private {\\r\\n        require(!_excludeFromRewards[account], \\\"Already excluded\\\");\\r\\n        _excludeFromRewards[account]=true;\\r\\n        _setShareholder(account,0);\\r\\n    } \\r\\n    function _includeAccountToRewards(address account) private {\\r\\n        require(_excludeFromRewards[account], \\\"Address is not excluded\\\");\\r\\n        _excludeFromRewards[account]=false;\\r\\n        _setShareholder(account,_balances[account]);\\r\\n    } \\r\\n    function _setShareholder(address account, uint256 amount) private { \\r\\n        if(amount \\u003e 0 \\u0026\\u0026 _holders[account].rewardsAmount == 0){\\r\\n            _addShareholder(account);\\r\\n        }\\r\\n        if(amount == 0 \\u0026\\u0026 _holders[account].toBePaid \\u003e 0){\\r\\n            _removeShareholder(account);\\r\\n        }\\r\\n        _tracker.totalTokensHeld = _tracker.totalTokensHeld-(_holders[account].rewardsAmount)+(amount);\\r\\n        _holders[account].rewardsAmount = amount;\\r\\n    }\\r\\n    function _shouldProcessRewards() private view returns (bool) {\\r\\n        return msg.sender != pancakePairAddress\\r\\n        \\u0026\\u0026 !_inSwap\\r\\n        \\u0026\\u0026 rewardsEnabled\\r\\n        \\u0026\\u0026 _tracker.totalRewardBNB \\u003e 0;\\r\\n    }\\r\\n    function _processRewards(uint256 gas) private {\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n        if(shareholderCount == 0) { return; }\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n        uint256 iterations = 0;\\r\\n        while(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c shareholderCount) {\\r\\n            if(currentIndex \\u003e= shareholderCount) {\\r\\n                currentIndex = 0;\\r\\n            }\\r\\n            if(_shouldDistribute(shareholders[currentIndex])) {\\r\\n                _distributeRewards(shareholders[currentIndex]);\\r\\n            }\\r\\n            gasUsed = gasUsed+(gasLeft-(gasleft()));\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n        }\\r\\n    }\\r\\n    function _shouldDistribute(address account) private view returns (bool) {\\r\\n        return _holders[account].lastClaim + _rewards.minPeriod \\u003c block.timestamp\\r\\n        \\u0026\\u0026 _getUnpaidReward(account) \\u003e _rewards.minDistribution;\\r\\n    } \\r\\n    function _distributeRewards(address account) private {\\r\\n        if(_holders[account].rewardsAmount == 0){ return; }\\r\\n        uint256 amountWei = _getUnpaidReward(account);\\r\\n        if(amountWei \\u003e 0){\\r\\n            _tracker.totalRewardBNBPayout+=amountWei;\\r\\n            _holders[account].lastClaim = block.timestamp;\\r\\n            _holders[account].alreadyPaid+=amountWei;\\r\\n            _holders[account].toBePaid=_calculateRewards(account,_holders[account].rewardsAmount);\\r\\n            _tracker.totalRewardBNB-=amountWei;\\r\\n            _swapBNBtoRWRD(account, amountWei);\\r\\n        }\\r\\n    }\\r\\n    function _getUnpaidReward(address account) private view returns (uint256) {\\r\\n        if(_holders[account].rewardsAmount == 0){ return 0; }\\r\\n        uint256 toBePaid = _calculateRewards(account,_holders[account].rewardsAmount);\\r\\n        uint256 alreadyPaid = _holders[account].alreadyPaid;\\r\\n        if(toBePaid \\u003c= alreadyPaid){ return 0; }\\r\\n        return toBePaid-(alreadyPaid);\\r\\n    }\\r\\n    function _calculateRewards(address account,uint256 amount) private view returns (uint256) {\\r\\n        return _excludeFromRewards[account]?0:amount*_tracker.profitPerToken/(2**64);\\r\\n    }\\r\\n    function _addShareholder(address shareholder) private {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n    function _removeShareholder(address shareholder) private {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n///////// Owner Functions \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\n    function ownerCreateLP() public payable onlyOwner {\\r\\n        require(msg.value\\u003e0\\u0026\\u0026IBEP20(pancakePairAddress).totalSupply()==0);\\r\\n        uint256 amountWei=msg.value;\\r\\n        uint256 ownerTokens=20000000000000*10**_tokenDecimals;\\r\\n        uint256 LPTokens=67937687699075*10**_tokenDecimals;\\r\\n        _transferExcluded(address(this),owner(),ownerTokens);\\r\\n        require(_balances[msg.sender]\\u003c=ownerTokens);\\r\\n        _addLiquidity(LPTokens,amountWei);\\r\\n        require(IBEP20(pancakePairAddress).totalSupply()\\u003e0);\\r\\n        emit OwnerCreateLP(LPTokens,amountWei);\\r\\n    }\\r\\n    function ownerUpdatePancakePair(address pair,address router) public onlyOwner {\\r\\n        pancakePairAddress=pair;\\r\\n        _pancakeRouterAddress=router;\\r\\n        emit OwnerUpdatePancakePair(pair,router);\\r\\n    }\\r\\n    function ownerUpdateAMM(address AMM,bool enabled) public onlyOwner {\\r\\n        _automatedMarketMakers[AMM]=enabled;\\r\\n        _excludeAccountFromRewards(AMM);\\r\\n        emit OwnerUpdateAMM(AMM,enabled);\\r\\n    }\\r\\n    function ownerLockTeamWallet(address account,bool locked) public onlyOwner {\\r\\n        require(account==coFounder_1||account==coFounder_2||account==coFounder_3||account==VPCustomerRelations\\r\\n        ||account==VPOperations||account==headDevelopment||account==developer_1||account==developer_2||account==leadDeveloper);\\r\\n        _teamWalletLock[account]=locked;\\r\\n        emit OwnerLockTeamWallet(account,locked);\\r\\n    }\\r\\n    function ownerBurnInitialToken() public onlyOwner {\\r\\n        require(!_tradingEnabled);\\r\\n        uint256 tokenToBurn=550000000000000*10**_tokenDecimals; \\r\\n        _transferExcluded(address(this), burnWallet, tokenToBurn);\\r\\n        emit Transfer(address(this),burnWallet,tokenToBurn);\\r\\n    }\\r\\n    function ownerSetAirDropper(address _airDropper) public onlyOwner {\\r\\n        airDropper=_airDropper;\\r\\n        _excludeFromFees[airDropper]=true;\\r\\n        emit OwnerSetAirDropper(airDropper);\\r\\n    }\\r\\n    function ownerBoostContract() public payable onlyOwner {\\r\\n        uint256 amountWei=msg.value;\\r\\n        require(amountWei\\u003e0);\\r\\n        _distributeBNB(amountWei);\\r\\n        emit OwnerBoostContract(amountWei);\\r\\n    }\\r\\n    function ownerLockAllTeamTokens() public onlyOwner {\\r\\n        _teamWalletLock[coFounder_1]=true;\\r\\n        _teamWalletLock[coFounder_2]=true;\\r\\n        _teamWalletLock[coFounder_3]=true;\\r\\n        _teamWalletLock[VPCustomerRelations]=true;\\r\\n        _teamWalletLock[VPOperations]=true;\\r\\n        _teamWalletLock[headDevelopment]=true;\\r\\n        _teamWalletLock[developer_1]=true;\\r\\n        _teamWalletLock[developer_2]=true;\\r\\n        _teamWalletLock[leadDeveloper]=true;\\r\\n    }\\r\\n    function ownerReleaseLP() public onlyOwner {\\r\\n        require(block.timestamp\\u003e=liquidityUnlockSeconds+30 days);\\r\\n        uint256 oldBNB=address(this).balance;\\r\\n        _removeLiquidityPercent(100);\\r\\n        uint256 newBNB=address(this).balance-oldBNB;\\r\\n        require(newBNB\\u003eoldBNB);\\r\\n        _tracker.totalMarketingBNB+=(newBNB-oldBNB);\\r\\n        emit OwnerReleaseLP(100);\\r\\n    }\\r\\n    function ownerRemoveLPPercent(uint8 LPPercent) public onlyOwner {\\r\\n        require(block.timestamp\\u003e=liquidityUnlockSeconds);\\r\\n        require(LPPercent\\u003c=20);\\r\\n        uint256 oldBNB=address(this).balance;\\r\\n        _removeLiquidityPercent(LPPercent);\\r\\n        uint256 newBNB=address(this).balance-oldBNB;\\r\\n        require(newBNB\\u003eoldBNB);\\r\\n        _tracker.totalMarketingBNB+=(newBNB-oldBNB);\\r\\n        liquidityUnlockSeconds=block.timestamp+_fixedLPLockTime;\\r\\n        emit OwnerRemoveLPPercent(LPPercent);\\r\\n    }\\r\\n    function ownerUpdateDefaultRewardToken(address _defaultRewardToken) public onlyOwner {\\r\\n        defaultRewardToken=_defaultRewardToken;\\r\\n        emit OwnerUpdateDefaultRewardToken(defaultRewardToken);\\r\\n    }\\r\\n    function ownerExtendLPLock(uint256 timeSeconds) public onlyOwner {\\r\\n        require(timeSeconds\\u003c=_fixedLPLockTime);\\r\\n        liquidityUnlockSeconds+=timeSeconds;\\r\\n        emit OwnerExtendLPLock(timeSeconds);\\r\\n    }\\r\\n    function ownerBlacklistWallet(address account,bool enabled) public onlyOwner {\\r\\n        _blacklisted[account]=enabled;\\r\\n        emit OwnerBlacklistWallet(account,enabled);\\r\\n    }\\r\\n    function ownerEnableTrading() public onlyOwner {\\r\\n        require(!_tradingEnabled);\\r\\n        _tradingEnabled=true;\\r\\n        liquidityUnlockSeconds=block.timestamp+_fixedLPLockTime;\\r\\n        emit OwnerEnableTrading(block.timestamp);\\r\\n    }\\r\\n    function ownerUpdatePrimaryTaxes(uint8 buyTax,uint8 sellTax) public onlyOwner {\\r\\n        require(buyTax\\u003c=_limit.maxBuyTax\\u0026\\u0026sellTax\\u003c=_limit.maxSellTax);\\r\\n        _tax.buyTax=buyTax;\\r\\n        _tax.sellTax=sellTax;\\r\\n        emit OwnerUpdateTaxes(buyTax,sellTax);\\r\\n    }\\r\\n    function ownerUpdateSecondaryTaxes(uint8 liquidity,uint8 lottery,uint8 charity,uint8 rewards,uint8 marketing) public onlyOwner {\\r\\n        require(liquidity+lottery+charity+rewards+marketing==100);\\r\\n        _tax.liquidityTax=liquidity;\\r\\n        _tax.lotteryTax=lottery;\\r\\n        _tax.charityTax=charity;\\r\\n        _tax.rewardsTax=rewards;\\r\\n        _tax.marketingTax=marketing;\\r\\n        emit OwnerUpdateSecondaryTaxes(liquidity,lottery,charity,rewards,marketing);\\r\\n    }\\r\\n    function ownerUpdateSwapThreshold(uint8 swapThreshold) public onlyOwner {\\r\\n        require(swapThreshold\\u003c=_limit.maxSwapThreshold\\u0026\\u0026swapThreshold\\u003e=1);\\r\\n        _limit.swapThreshold=swapThreshold;\\r\\n        emit OwnerUpdateSwapThreshold(swapThreshold);\\r\\n    }\\r\\n    function ownerTriggerSwap(uint8 swapThreshold,bool ignoreLimits) public onlyOwner {\\r\\n        require(swapThreshold\\u003c=_limit.maxSwapThreshold\\u0026\\u0026swapThreshold\\u003e=1);\\r\\n        _swapAndLiquify(swapThreshold,ignoreLimits);\\r\\n        emit OwnerTriggerSwap(swapThreshold,ignoreLimits);\\r\\n    }\\r\\n    function ownerTriggerLottery(uint256 percentage) public onlyOwner {\\r\\n        require(percentage\\u003e=25,\\\"Cannot set percentage below 25%\\\");\\r\\n        require(percentage\\u003c=100,\\\"Cannot set percentage over 100%\\\");\\r\\n        _sendLotteryReward(_lottery.percentage);\\r\\n        emit OwnerTriggerLottery(percentage);\\r\\n    }\\r\\n    function ownerSwitchSwapEnabled(bool enabled) public onlyOwner {\\r\\n        swapEnabled=enabled;\\r\\n        emit OwnerSwitchSwapEnabled(enabled);\\r\\n    }\\r\\n    function ownerSwitchLotteryEnabled(bool enabled) public onlyOwner {\\r\\n        lotteryEnabled=enabled;\\r\\n        emit OwnerSwitchLotteryEnabled(enabled);\\r\\n    }\\r\\n    function ownerSwitchRewardsEnabled(bool enabled) public onlyOwner {\\r\\n        rewardsEnabled=enabled;\\r\\n        emit OwnerSwitchRewardsEnabled(enabled);\\r\\n    }\\r\\n    function ownerSetLotterySettings(uint256 minPeriod,uint256 percentage,uint256 minBalance) public onlyOwner{\\r\\n        require(percentage\\u003e=25, \\\"Cannot set percentage below 25%\\\");\\r\\n        require(percentage\\u003c=100, \\\"Cannot set percentage over 100%\\\");\\r\\n        _lottery.minPeriod=minPeriod;\\r\\n        _lottery.percentage=percentage;\\r\\n        _lottery.minBalance=minBalance*10**_tokenDecimals;\\r\\n        emit OwnerSetLotterySetting(minPeriod,percentage,minBalance);\\r\\n    }\\r\\n    function ownerSetRewardSettings(uint256 minPeriod,uint256 minDistribution) public onlyOwner{\\r\\n        _rewards.minPeriod=minPeriod;\\r\\n        _rewards.minDistribution=minDistribution;\\r\\n        emit OwnerSetRewardSetting(minPeriod,minDistribution);\\r\\n    }\\r\\n    function ownerSetExcludeFromRewards(address account) public onlyOwner{\\r\\n        _excludeAccountFromRewards(account);\\r\\n        emit OwnerSetExcludedFromRewards(account);\\r\\n    }\\r\\n    function ownerSetIncludedToRewards(address account) public onlyOwner{\\r\\n        _includeAccountToRewards(account);\\r\\n        emit OwnerSetIncludedToRewards(account);\\r\\n    }\\r\\n    function ownerSetExcludeFromLottery(address account) public onlyOwner{\\r\\n        _excludeAccountFromLottery(account);\\r\\n        emit OwnerSetExcludedFromLottery(account);\\r\\n    }\\r\\n    function ownerSetIncludedToLottery(address account) public onlyOwner{\\r\\n        _includeAccountToLottery(account);\\r\\n        emit OwnerSetIncludedToLottery(account);\\r\\n    }\\r\\n    function ownerExcludeFromFees(address account,bool enabled) public onlyOwner {\\r\\n        _excludeFromFees[account]=enabled;\\r\\n        emit OwnerExcludeFromFees(account,enabled);\\r\\n    }\\r\\n    function withdrawAirDropTokens() public {\\r\\n        require(msg.sender==airDropper, \\\"Only airdropper can withdraw tokens\\\");\\r\\n        require(!_tradingEnabled, \\\"Cannot withdraw tokens after trading is enabled\\\");\\r\\n        uint256 airdropAmount=292062312300925*10** _tokenDecimals;\\r\\n        _transferExcluded(address(this),airDropper,airdropAmount);\\r\\n        emit Transfer(address(this),airDropper,airdropAmount);\\r\\n    }\\r\\n    function withdrawAirDropTokenPresale() public {\\r\\n        require(msg.sender==airDropper, \\\"Only airdropper can withdraw tokens\\\");\\r\\n        require(!_tradingEnabled, \\\"Cannot withdraw tokens after trading is enabled\\\");\\r\\n        uint256 airdropAmount=70000000000000*10** _tokenDecimals;\\r\\n        _transferExcluded(address(this),airDropper,airdropAmount);\\r\\n        emit Transfer(address(this),airDropper,airdropAmount);\\r\\n    }\\r\\n    function ownerWithdrawMarketingBNB(uint256 amountWei) public onlyOwner {\\r\\n        require(amountWei\\u003c=_tracker.totalMarketingBNB);\\r\\n        (bool sent,)=msg.sender.call{value: (amountWei)}(\\\"\\\");\\r\\n        require(sent);\\r\\n        _tracker.totalMarketingBNB-=amountWei;\\r\\n    }\\r\\n    function ownerWithdrawCharityBNB(uint256 amountWei) public onlyOwner{\\r\\n        require(amountWei\\u003c=_tracker.totalCharityBNB);\\r\\n        (bool sent,)=msg.sender.call{value: (amountWei)}(\\\"\\\");\\r\\n        require(sent);\\r\\n        _tracker.totalCharityBNB-=amountWei;\\r\\n    }\\r\\n    function ownerWithdrawStrandedToken(address strandedToken) public onlyOwner {\\r\\n        // Cannot withdraw this token, or LP-token from contract\\r\\n        require(strandedToken!=pancakePairAddress\\u0026\\u0026strandedToken!=address(this));\\r\\n        IBEP20 token=IBEP20(strandedToken);\\r\\n        token.transfer(owner(), token.balanceOf(address(this)));\\r\\n    }\\r\\n    function ownerFixStuckBNB() public onlyOwner {\\r\\n        uint256 stuckBNB=address(this).balance-(_tracker.totalMarketingBNB+_tracker.totalCharityBNB);\\r\\n        _tracker.totalMarketingBNB+=(stuckBNB\\u003e0?stuckBNB:0);\\r\\n        emit OwnerFixStuckBNB(stuckBNB);\\r\\n    }\\r\\n    function ownerWithdrawBNB() public onlyOwner {\\r\\n        (bool success,) = msg.sender.call{value: (address(this).balance)}(\\\"\\\");\\r\\n        require(success);\\r\\n    }\\r\\n///////// Liquidity Functions \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\n    function _addLiquidity(uint256 amountTokens,uint256 amountBNB) private {\\r\\n        _tracker.totalLiquidityBNB+=amountBNB;\\r\\n        _addingLP=true;\\r\\n        _pancakeRouter.addLiquidityETH{value: amountBNB}(\\r\\n            address(this),\\r\\n            amountTokens,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        _addingLP=false;\\r\\n        emit LiquidityAdded(amountTokens,amountBNB);\\r\\n    }\\r\\n    function _removeLiquidityPercent(uint8 percent) private {\\r\\n        IPancakeERC20 lpToken=IPancakeERC20(pancakePairAddress);\\r\\n        uint256 amount=lpToken.balanceOf(address(this)) * percent / 100;\\r\\n        lpToken.approve(address(_pancakeRouter),amount);\\r\\n        _removingLP=true;\\r\\n        _pancakeRouter.removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n            address(this),\\r\\n            amount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n        _removingLP=false;\\r\\n    }\\r\\n    function _swapTokensForBNB(uint256 amount) private {\\r\\n        address[] memory path=new address[](2);\\r\\n        path[0]=address(this);\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n///////// IBEP20 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\\n    function _approve(address owner, address spender, uint256 amount) private {\\r\\n        require((owner != address(0) \\u0026\\u0026 spender != address(0)), \\\"Owner/Spender address cannot be 0.\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        uint256 allowance_ = _allowances[sender][msg.sender];\\r\\n        _transfer(sender, recipient, amount);\\r\\n        require(allowance_ \\u003e= amount);\\r\\n        _approve(sender, msg.sender, allowance_ - amount);\\r\\n            emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function allTaxes() external view returns (uint8 buyTax,uint8 sellTax,uint8 liquidityTax,uint8 lotteryTax,uint8 charityTax,uint8 rewardsTax,uint8 marketingTax) {\\r\\n        buyTax=_tax.buyTax;\\r\\n        sellTax=_tax.sellTax;\\r\\n        liquidityTax=_tax.liquidityTax;\\r\\n        lotteryTax=_tax.lotteryTax;\\r\\n        charityTax=_tax.charityTax;\\r\\n        rewardsTax=_tax.rewardsTax;\\r\\n        marketingTax=_tax.marketingTax;\\r\\n    }\\r\\n    function BNBTracker() external view returns (uint256 marketingBNB,uint256 lotteryBNB,uint256 charityBNB,uint256 rewardBNB,uint256 liquidityBNB) {\\r\\n        marketingBNB=_tracker.totalMarketingBNB;\\r\\n        lotteryBNB=_tracker.totalLotteryBNB;\\r\\n        charityBNB=_tracker.totalCharityBNB;\\r\\n        rewardBNB=_tracker.totalRewardBNB;\\r\\n        liquidityBNB=_tracker.totalLiquidityBNB;\\r\\n    }\\r\\n    function allowance(address owner_, address spender) external view override returns (uint256) {\\r\\n        return _allowances[owner_][spender];\\r\\n    }\\r\\n    function balanceOf(address account) external view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _tokenName;\\r\\n    }\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _tokenSymbol;\\r\\n    }\\r\\n    function totalSupply() external pure override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _tokenDecimals;\\r\\n    }\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n    receive() external payable {\\r\\n        // Only owner \\u0026 router can send BNB to address\\r\\n        require(msg.sender==owner()||msg.sender==_pancakeRouterAddress);\\r\\n    }\\r\\n}\"},\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function name() external view returns (string memory);\\r\\n  function getOwner() external view returns (address);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IPancakeERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = msg.sender;\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // This method relies on extcodesize, which returns 0 for contracts in\\r\\n        // construction, since the code is only stored at the end of the\\r\\n        // constructor execution.\\r\\n\\r\\n        uint256 size;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a static call.\\r\\n     *\\r\\n     * _Available since v3.3._\\r\\n     */\\r\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n     * but performing a delegate call.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return _verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter01 {\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\nlibrary EnumerableSet {\\r\\n    // To implement this library for multiple types with as little code\\r\\n    // repetition as possible, we write it in terms of a generic Set type with\\r\\n    // bytes32 values.\\r\\n    // The Set implementation uses private functions, and user-facing\\r\\n    // implementations (such as AddressSet) are just wrappers around the\\r\\n    // underlying Set.\\r\\n    // This means that we can only create new EnumerableSets for types that fit\\r\\n    // in bytes32.\\r\\n\\r\\n    struct Set {\\r\\n        // Storage of set values\\r\\n        bytes32[] _values;\\r\\n\\r\\n        // Position of the value in the `values` array, plus 1 because index 0\\r\\n        // means a value is not in the set.\\r\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\r\\n        if (!_contains(set, value)) {\\r\\n            set._values.push(value);\\r\\n            // The value is stored at length-1, but we add 1 to all indexes\\r\\n            // and use 0 as a sentinel value\\r\\n            set._indexes[value] = set._values.length;\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\r\\n        // We read and store the value\\u0027s index to prevent multiple reads from the same storage slot\\r\\n        uint256 valueIndex = set._indexes[value];\\r\\n\\r\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\r\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\r\\n            // the array, and then remove the last element (sometimes called as \\u0027swap and pop\\u0027).\\r\\n            // This modifies the order of the array, as noted in {at}.\\r\\n\\r\\n            uint256 toDeleteIndex = valueIndex - 1;\\r\\n            uint256 lastIndex = set._values.length - 1;\\r\\n\\r\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\r\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \\u0027if\\u0027 statement.\\r\\n\\r\\n            bytes32 lastvalue = set._values[lastIndex];\\r\\n\\r\\n            // Move the last value to the index where the value to delete is\\r\\n            set._values[toDeleteIndex] = lastvalue;\\r\\n            // Update the index for the moved value\\r\\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue\\u0027s index to valueIndex\\r\\n\\r\\n            // Delete the slot where the moved value was stored\\r\\n            set._values.pop();\\r\\n\\r\\n            // Delete the index for the deleted slot\\r\\n            delete set._indexes[value];\\r\\n\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\r\\n        return set._indexes[value] != 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function _length(Set storage set) private view returns (uint256) {\\r\\n        return set._values.length;\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\r\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\r\\n        return set._values[index];\\r\\n    }\\r\\n\\r\\n    // Bytes32Set\\r\\n\\r\\n    struct Bytes32Set {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _add(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\r\\n        return _remove(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\r\\n        return _at(set._inner, index);\\r\\n    }\\r\\n\\r\\n    // AddressSet\\r\\n\\r\\n    struct AddressSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values in the set. O(1).\\r\\n     */\\r\\n    function length(AddressSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\r\\n        return address(uint160(uint256(_at(set._inner, index))));\\r\\n    }\\r\\n\\r\\n    // UintSet\\r\\n\\r\\n    struct UintSet {\\r\\n        Set _inner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a value to a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was added to the set, that is if it was not\\r\\n     * already present.\\r\\n     */\\r\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _add(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Removes a value from a set. O(1).\\r\\n     *\\r\\n     * Returns true if the value was removed from the set, that is if it was\\r\\n     * present.\\r\\n     */\\r\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\r\\n        return _remove(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the value is in the set. O(1).\\r\\n     */\\r\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\r\\n        return _contains(set._inner, bytes32(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of values on the set. O(1).\\r\\n     */\\r\\n    function length(UintSet storage set) internal view returns (uint256) {\\r\\n        return _length(set._inner);\\r\\n    }\\r\\n\\r\\n   /**\\r\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\r\\n    *\\r\\n    * Note that there are no guarantees on the ordering of values inside the\\r\\n    * array, and it may change when more values are added or removed.\\r\\n    *\\r\\n    * Requirements:\\r\\n    *\\r\\n    * - `index` must be strictly less than {length}.\\r\\n    */\\r\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\r\\n        return uint256(_at(set._inner, index));\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerBlacklistWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"OwnerBoostContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"}],\"name\":\"OwnerCreateLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeSeconds\",\"type\":\"uint256\"}],\"name\":\"OwnerExtendLPLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"OwnerFixStuckBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"OwnerLockTeamWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LPPercent\",\"type\":\"uint256\"}],\"name\":\"OwnerReleaseLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"LPPercent\",\"type\":\"uint256\"}],\"name\":\"OwnerRemoveLPPercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"airDropper\",\"type\":\"address\"}],\"name\":\"OwnerSetAirDropper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerSetExcludedFromLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerSetExcludedFromRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerSetIncludedToLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnerSetIncludedToRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minBalance\",\"type\":\"uint256\"}],\"name\":\"OwnerSetLotterySetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minDistribution\",\"type\":\"uint256\"}],\"name\":\"OwnerSetRewardSetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSwitchLotteryEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSwitchRewardsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerSwitchSwapEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"OwnerTriggerLottery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"OwnerTriggerSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OwnerUpdateAMM\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"defaultRewardToken\",\"type\":\"address\"}],\"name\":\"OwnerUpdateDefaultRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"OwnerUpdatePancakePair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lottery\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"charity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"}],\"name\":\"OwnerUpdateSecondaryTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapThreshold\",\"type\":\"uint256\"}],\"name\":\"OwnerUpdateSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"}],\"name\":\"OwnerUpdateTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"SetCustomRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BNBTracker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketingBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lotteryBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"charityBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardBNB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBNB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VPCustomerRelations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VPOperations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airDropper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allTaxes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lotteryTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"charityTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewardsTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingTax\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounder_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounder_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coFounder_3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer_1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer_2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headDevelopment\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"includeMeToRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leadDeveloper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityUnlockSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerBlacklistWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerBoostContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerBurnInitialToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCreateLP\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerExcludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeSeconds\",\"type\":\"uint256\"}],\"name\":\"ownerExtendLPLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerFixStuckBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerLockAllTeamTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"ownerLockTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerReleaseLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"LPPercent\",\"type\":\"uint8\"}],\"name\":\"ownerRemoveLPPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airDropper\",\"type\":\"address\"}],\"name\":\"ownerSetAirDropper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ownerSetExcludeFromLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ownerSetExcludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ownerSetIncludedToLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ownerSetIncludedToRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBalance\",\"type\":\"uint256\"}],\"name\":\"ownerSetLotterySettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDistribution\",\"type\":\"uint256\"}],\"name\":\"ownerSetRewardSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSwitchLotteryEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSwitchRewardsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerSwitchSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"ownerTriggerLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"swapThreshold\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"ignoreLimits\",\"type\":\"bool\"}],\"name\":\"ownerTriggerSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ownerUpdateAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultRewardToken\",\"type\":\"address\"}],\"name\":\"ownerUpdateDefaultRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"ownerUpdatePancakePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"}],\"name\":\"ownerUpdatePrimaryTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"liquidity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lottery\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"charity\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rewards\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketing\",\"type\":\"uint8\"}],\"name\":\"ownerUpdateSecondaryTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"swapThreshold\",\"type\":\"uint8\"}],\"name\":\"ownerUpdateSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawCharityBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountWei\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawMarketingBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strandedToken\",\"type\":\"address\"}],\"name\":\"ownerWithdrawStrandedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakePairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"setCustomRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAirDropTokenPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAirDropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GlowTokenV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e7a1621e6a5349d0732954de8a527268455cc7a04bb37e8322ca9a9410423231"}