{"SourceCode": "// Sources flattened with hardhat v2.9.9 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.7.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.7.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.7.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/Pausable.sol@v4.7.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.7.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`.\r\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\r\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\r\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\r\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1;\r\n        uint256 x = a;\r\n        if (x >> 128 > 0) {\r\n            x >>= 128;\r\n            result <<= 64;\r\n        }\r\n        if (x >> 64 > 0) {\r\n            x >>= 64;\r\n            result <<= 32;\r\n        }\r\n        if (x >> 32 > 0) {\r\n            x >>= 32;\r\n            result <<= 16;\r\n        }\r\n        if (x >> 16 > 0) {\r\n            x >>= 16;\r\n            result <<= 8;\r\n        }\r\n        if (x >> 8 > 0) {\r\n            x >>= 8;\r\n            result <<= 4;\r\n        }\r\n        if (x >> 4 > 0) {\r\n            x >>= 4;\r\n            result <<= 2;\r\n        }\r\n        if (x >> 2 > 0) {\r\n            result <<= 1;\r\n        }\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = sqrt(a);\r\n        if (rounding == Rounding.Up && result * result < a) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/StakingAnyToken/StakingAnyToken.sol\r\n\r\npragma solidity 0.8.9;\r\n/**\r\n * @dev Staking Contract \r\n *  - Stake any token and get Interest in other any token  \r\n *  - Set Penalty function \r\n *  - Number of days option for staking \r\n *  - different token have different interest rate.\r\n */\r\ncontract StakingAnyToken is Ownable, Pausable {\r\n\r\n    uint32 public currentVersion;\r\n\r\n    // minimum stake time in seconds, if the user withdraws before this time a penalty will be charged\r\n    uint256 public minimumStakeTime;\r\n\r\n    // the penalty, a number between 0 and 100\r\n    uint8 public penalty;\r\n\r\n    // lock to prevent withdraw staking\r\n    bool public withdrawLocked;\r\n\r\n    // the Stake\r\n    struct Stake {\r\n        // version of this stake\r\n        uint32 version;\r\n        // the staking token\r\n        address stakeToken;\r\n        // the reward token\r\n        address rewardToken;\r\n        // opening timestamp\r\n        uint64 startTimestamp;\r\n        // amount staked\r\n        uint256 amount;\r\n        // interest accrued, this will be available only after closing stake\r\n        uint256 interest;\r\n        // penalty charged, if any\r\n        uint256 penalty;\r\n        // last time the interest was withdrawn\r\n        uint64 lastWithdrawalTimestamp;\r\n        // closing timestamp, if 0 then stake is still open\r\n        uint64 finishedTimestamp;\r\n        // the version on closing\r\n        uint32 finishedVersion;\r\n    }\r\n    \r\n    struct StakeView {\r\n        // stake index\r\n        uint32 index;\r\n        // version of this stake\r\n        uint32 version;\r\n        // the staking token\r\n        address stakeToken;\r\n        // the reward token\r\n        address rewardToken;\r\n        // opening timestamp\r\n        uint64 startTimestamp;\r\n        // amount staked\r\n        uint256 amount;\r\n        // interest accrued, this will be available only after closing stake\r\n        uint256 interest;\r\n        // penalty charged, if any\r\n        uint256 penalty;\r\n        // last time the interest was withdrawn\r\n        uint64 lastWithdrawalTimestamp;\r\n        // closing timestamp, if 0 then stake is still open\r\n        uint64 finishedTimestamp;\r\n        // the version on closing\r\n        uint32 finishedVersion;\r\n        // interest realtime\r\n        uint256 interestRealTime;\r\n        // decimals of apy\r\n        int8 apyDecimals;\r\n        // Annual Percentage Yield. Interest(RewardToken) = stakedAmount(StakeToken) * (APY * 10^apyDecimals / stakedTime)\r\n        uint32 apy;\r\n    }\r\n\r\n    struct TokenAPY {\r\n        // the lower bound of the token apy\r\n        uint256 lowerBoundAmount;\r\n        // Annual Percentage Yield. Interest(RewardToken) = stakedAmount(StakeToken) * (APY * 10^apyDecimals / stakedTime)\r\n        uint32 apy;\r\n    }\r\n\r\n    struct StakeTokenInfo {\r\n        bool hasAdded;\r\n        bool enabled;\r\n        // minimum amount of tokens to create a stake\r\n        uint256 minimum;\r\n        int8 apyDecimals;\r\n        TokenAPY[] tokenAPYs;\r\n        // penalties are collected and stored by the contract\r\n        uint256 collectedPenalty;\r\n        // current left stake amount\r\n        uint256 stakingAmount;\r\n    }\r\n\r\n    struct StakeRewardTokenPair {\r\n        address stakeToken;\r\n        address rewardToken;\r\n    }\r\n\r\n    // stakes that the owner have    \r\n    mapping(address => Stake[]) public stakesOfOwner;\r\n    mapping(address => uint32) public validStakesCountOfOwner;\r\n    \r\n    // all accounts that have or have had stakes, this for the owner to be able to query stakes\r\n    address[] public ownersAccounts;\r\n\r\n    // count of owner who have stakes now\r\n    uint64 public stakingOwnerCount;\r\n    uint64 public totalValidStakesCount;\r\n\r\n    // all supported Stake Token Infos [stakeToken][rewardToken]\r\n    mapping(address => mapping(address => StakeTokenInfo)) public supportedTokenInfos;\r\n    // all supported Stake Token Reward Token pair addresses\r\n    StakeRewardTokenPair[] public supportedStakeRewardTokenPairs;\r\n    \r\n    event ObsoleteVersion(uint32 version);\r\n    event StakeCreated(address indexed user, uint32 indexed index, address indexed stakeToken, address rewardToken, uint256 amount);\r\n    event Withdraw(address indexed user, uint32 indexed index, uint64 interestSeconds, uint256 interest);\r\n    event WithdrawInterest(address indexed user, uint32 indexed index, uint64 interestSeconds, uint256 interest);\r\n    event EmergencyWithdraw(address indexed user, uint32 indexed index, uint64 interestSeconds, uint256 interest, uint256 penalty);\r\n    event WithdrawWithoutReward(address indexed user, uint32 indexed index);\r\n    event WithdrawObsoleteStaking(address indexed user, uint32 indexed index);\r\n\r\n\r\n    event StakeTokenInfoAdded(address indexed stakeToken, address indexed rewardToken, uint256 minimum, int8 apyDecimals, TokenAPY[] tokenAPYs);\r\n    event StakeTokenInfoChanged(address indexed stakeToken, address indexed rewardToken, bool enable, uint256 minimum, int8 apyDecimals, TokenAPY[] tokenAPYs);\r\n\r\n    struct StakeRewardTokenAmountPair {\r\n        address stakeToken;\r\n        address rewardToken;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct Summary {\r\n        uint64 stakingOwnerCount;\r\n        StakeRewardTokenAmountPair[] leftStakingAmounts;\r\n    }\r\n\r\n    struct AddressStakesData {\r\n        address user;\r\n        Stake[] stakes;\r\n    }\r\n\r\n    struct StakeResult {\r\n        AddressStakesData[] userStakes;\r\n        bool hasEnded;\r\n    }\r\n\r\n    // @param _minimumStakeTimeSeconds: minimum stake time in seconds\r\n    // @param _penalty: the penalty percentage 0 to 100\r\n    constructor(uint256 _minimumStakeTimeSeconds, uint8 _penalty) {\r\n        require(_penalty<=100, \"Penalty must be less than 100\");\r\n        minimumStakeTime = _minimumStakeTimeSeconds;\r\n        penalty = _penalty;\r\n        currentVersion = 1;\r\n    }\r\n    \r\n    function stakesOfOwnerLength(address _account) public view returns (uint256) {\r\n        return stakesOfOwner[_account].length;\r\n    }\r\n    \r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function lockWithdraw() public onlyOwner {\r\n        require(!withdrawLocked, \"Withdraw is already locked\");\r\n        withdrawLocked = true;\r\n    }\r\n\r\n    function unlockWithdraw() public onlyOwner {\r\n        require(withdrawLocked, \"Withdraw is not locked\");\r\n        withdrawLocked = false;\r\n    }\r\n\r\n    modifier whenWithdrawNotLocked {\r\n        require(!withdrawLocked, \"Withdraw is locked\");\r\n        _;\r\n    }\r\n\r\n    function modifyMinimumStakeTime(uint256 _newVal) external onlyOwner {\r\n        minimumStakeTime = _newVal;\r\n    }\r\n    function modifyPenalty(uint8 _newVal) external onlyOwner {\r\n        penalty = _newVal;\r\n    }\r\n\r\n    // give back all staking, user can withdraw all staking by calling withdrawObsoleteStake\r\n    function obsoleteVersion() external onlyOwner {\r\n        currentVersion += 1;\r\n        emit ObsoleteVersion(currentVersion - 1);\r\n    }\r\n\r\n\r\n    // query all stake accounts holders\r\n    function queryOwnersAccounts() external view returns (address[] memory) {\r\n        return ownersAccounts;\r\n    }\r\n\r\n    // query all stake accounts holders paginated\r\n    function queryOwnersAccountsPaginated(uint64 _startInx, uint32 _length) external view returns (address[] memory) {\r\n        uint256 realLength = Math.max(0, Math.min(_length, ownersAccounts.length - _startInx));\r\n        address[] memory result = new address[](realLength);\r\n        for (uint256 i = 0; i < realLength; i++) {\r\n            result[i] = ownersAccounts[_startInx + i];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // query all stake accounts holders length\r\n    function ownersAccountsLength() external view returns (uint256) {\r\n        return ownersAccounts.length;\r\n    }\r\n\r\n    // query all supported staking token pair length\r\n    function supportedStakeRewardTokenPairsLength() public view returns (uint256) {\r\n        return supportedStakeRewardTokenPairs.length;\r\n    }\r\n\r\n    // query all supported staking token pairs\r\n    function querySupportedStakeRewardTokenPairs() public view returns (StakeRewardTokenPair[] memory) {\r\n        return supportedStakeRewardTokenPairs;\r\n    }\r\n\r\n    // query supported staking token apy info length\r\n    function stakeTokenApyLength(address _stakeToken, address _rewardToken) public view returns (uint256) {\r\n        return supportedTokenInfos[_stakeToken][_rewardToken].tokenAPYs.length;\r\n    }\r\n\r\n    // query supported staking token apy info by index\r\n    function stakeTokenAPY(address _stakeToken, address _rewardToken, uint256 _index) public view returns (TokenAPY memory) {\r\n        require(_index < supportedTokenInfos[_stakeToken][_rewardToken].tokenAPYs.length, \"Index is out of bounds\");\r\n        return supportedTokenInfos[_stakeToken][_rewardToken].tokenAPYs[_index];\r\n    }\r\n\r\n    function querySupportedStakeTokenInfo(address _stakeToken, address _rewardToken) external view returns (StakeTokenInfo memory) {\r\n        StakeTokenInfo storage info = supportedTokenInfos[_stakeToken][_rewardToken];\r\n        require(info.hasAdded, \"Token pair is not supported\");\r\n        return info;\r\n    }\r\n\r\n    function querySupportedTokenInfosPaginated(uint32 _startInx, uint32 _length) external view returns (StakeTokenInfo[] memory) {\r\n        uint256 realLength = Math.max(0, Math.min(_length, supportedStakeRewardTokenPairs.length - _startInx));\r\n        StakeTokenInfo[] memory result = new StakeTokenInfo[](realLength);\r\n        for (uint256 i = 0; i < realLength; i++) {\r\n            StakeRewardTokenPair storage pair = supportedStakeRewardTokenPairs[_startInx + i];\r\n            StakeTokenInfo storage info = supportedTokenInfos[pair.stakeToken][pair.rewardToken];\r\n            result[i] = info;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // query staking summary, get staking owner count, and all staking amount of each token pair\r\n    function querySummary() public view returns (Summary memory) {\r\n        Summary memory summary = Summary(stakingOwnerCount, new StakeRewardTokenAmountPair[](supportedStakeRewardTokenPairs.length));\r\n        for (uint256 i = 0; i < supportedStakeRewardTokenPairs.length; i++) {\r\n            StakeRewardTokenPair storage pair = supportedStakeRewardTokenPairs[i];\r\n            uint256 amount = supportedTokenInfos[pair.stakeToken][pair.rewardToken].stakingAmount;\r\n            summary.leftStakingAmounts[i] = StakeRewardTokenAmountPair(pair.stakeToken, pair.rewardToken, amount);\r\n        }\r\n        return summary;\r\n    }\r\n    \r\n    function queryUserStakeSummary(address _user, address _stakeToken) public view returns (uint256 historyTotal, uint256 validWithObsoleted, uint256 validTotal) {\r\n        Stake[] storage userStakes = stakesOfOwner[_user];\r\n        for (uint256 i = 0; i < userStakes.length; i++) {\r\n            Stake storage stake = userStakes[i];\r\n            if (stake.stakeToken != _stakeToken) {\r\n                continue;\r\n            }\r\n            historyTotal += stake.amount;\r\n            if (stake.finishedTimestamp == 0) {\r\n                validWithObsoleted += stake.amount;\r\n                if (stake.version == currentVersion) {\r\n                    validTotal += stake.amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function queryUserStake(address _user, bool _skipFinished) public view returns (StakeView[] memory) {\r\n        Stake[] storage userStakes = stakesOfOwner[_user];\r\n        StakeView[] memory ret = new StakeView[](_skipFinished ? validStakesCountOfOwner[_user] : userStakes.length);\r\n        uint32 retStakeInx = 0;\r\n        for (uint32 i = 0; retStakeInx < ret.length ; i++) {\r\n            Stake storage stake = userStakes[i];\r\n            uint256 interestRealTime = 0;\r\n            uint32 apy;\r\n            int8 apyDecimals; \r\n            if (stake.finishedTimestamp != 0) {\r\n                if (_skipFinished) {\r\n                    continue;\r\n                }\r\n\r\n                (,,, apy, apyDecimals) = calculateInterestByStake(stake, block.timestamp - stake.startTimestamp < minimumStakeTime);\r\n            } else {\r\n                (interestRealTime,,, apy, apyDecimals) = calculateInterestByStake(stake, block.timestamp - stake.startTimestamp < minimumStakeTime);\r\n            }\r\n\r\n            ret[retStakeInx] = StakeView({\r\n                index: i,\r\n                version: stake.version,\r\n                stakeToken: stake.stakeToken,\r\n                rewardToken: stake.rewardToken,\r\n                startTimestamp: stake.startTimestamp,\r\n                amount: stake.amount,\r\n                interest: stake.interest,\r\n                penalty: stake.penalty,\r\n                lastWithdrawalTimestamp: stake.lastWithdrawalTimestamp,\r\n                finishedTimestamp: stake.finishedTimestamp,\r\n                finishedVersion: stake.finishedVersion,\r\n                interestRealTime: interestRealTime,\r\n                apy: apy,\r\n                apyDecimals: apyDecimals\r\n            });\r\n            retStakeInx += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function queryAllStakePaginated(bool _skipFinished, uint64 _startInx, uint32 _length) public view returns (StakeResult memory) {\r\n        uint256 realLength = Math.max(0, Math.min(_length, ownersAccounts.length - _startInx));\r\n        StakeResult memory result = StakeResult(new AddressStakesData[](realLength), _startInx + realLength >= ownersAccounts.length);\r\n        for (uint256 i = 0; i < realLength; i++) {\r\n            address userAddress = ownersAccounts[_startInx + i];\r\n            Stake[] storage userStakes = stakesOfOwner[userAddress];\r\n            AddressStakesData memory retUserStake = AddressStakesData(userAddress, new Stake[](_skipFinished ? validStakesCountOfOwner[userAddress] : userStakes.length));\r\n            {\r\n                uint32 retStakeInx = 0;\r\n                for (uint256 j = 0; retStakeInx < retUserStake.stakes.length ; j++) {\r\n                    Stake storage stake = userStakes[j];\r\n                    if (_skipFinished && stake.finishedTimestamp != 0) {\r\n                        continue;\r\n                    }\r\n                    retUserStake.stakes[retStakeInx] = stake;\r\n                    retStakeInx += 1;\r\n                }\r\n            }\r\n            result.userStakes[i] = retUserStake;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // add a new stake token\r\n    function addSupportedStakeToken(address _stakeToken, address _rewardToken, uint256 _minimum, int8 _apyDecimals, TokenAPY[] memory _tokenAPYs) external onlyOwner {\r\n        \r\n        StakeTokenInfo storage info = supportedTokenInfos[_stakeToken][_rewardToken];\r\n\r\n        require(!info.hasAdded, \"Token pair already supported\");\r\n        require(_tokenAPYs.length > 0, \"TokenAPYs can not be empty\");\r\n        require(_stakeToken != address(0), \"Stake token can not be zero address\");\r\n        require(_rewardToken != address(0), \"Reward token can not be zero address\");\r\n\r\n        supportedStakeRewardTokenPairs.push(StakeRewardTokenPair(_stakeToken, _rewardToken));\r\n        info.hasAdded = true;\r\n        info.enabled = true;\r\n        info.minimum = _minimum;\r\n        info.apyDecimals = _apyDecimals;\r\n\r\n        for(uint256 i = 0; i < _tokenAPYs.length; i++) {\r\n            if (i > 0) {\r\n                require(\r\n                    _tokenAPYs[i].lowerBoundAmount > _tokenAPYs[i - 1].lowerBoundAmount,\r\n                    \"APY low bound must asc\");\r\n            }\r\n            info.tokenAPYs.push(TokenAPY(_tokenAPYs[i].lowerBoundAmount, _tokenAPYs[i].apy));\r\n        }\r\n        emit StakeTokenInfoAdded(_stakeToken, _rewardToken, _minimum, _apyDecimals, _tokenAPYs);\r\n    }\r\n\r\n    // update the supported stake token info\r\n    function updateSupportedStakeToken(address _stakeToken, address _rewardToken, bool _enabled, uint256 _minimum, int8 _apyDecimals, TokenAPY[] memory _tokenAPYs) external onlyOwner {\r\n        StakeTokenInfo storage info = supportedTokenInfos[_stakeToken][_rewardToken];\r\n        require(info.hasAdded, \"Token pair not supported\");\r\n        if (_enabled) {\r\n            require(_tokenAPYs.length > 0, \"TokenAPYs can not be empty\");\r\n        }\r\n        info.enabled = _enabled;\r\n        info.minimum = _minimum;\r\n        info.apyDecimals = _apyDecimals;\r\n        delete info.tokenAPYs;\r\n        for(uint256 i = 0; i < _tokenAPYs.length; i++) {\r\n            if (i > 0) {\r\n                require(\r\n                    _tokenAPYs[i].lowerBoundAmount > _tokenAPYs[i - 1].lowerBoundAmount,\r\n                    \"APY low bound must asc\");\r\n            }\r\n            info.tokenAPYs.push(TokenAPY(_tokenAPYs[i].lowerBoundAmount, _tokenAPYs[i].apy));\r\n        }\r\n        emit StakeTokenInfoChanged(_stakeToken, _rewardToken, _enabled, _minimum, _apyDecimals, _tokenAPYs);\r\n    }\r\n\r\n\r\n    function isObsoleteStake(address _user, uint32 _index) public view returns (bool) {\r\n        require(_index < stakesOfOwner[_user].length, \"Index is out of bounds\");\r\n        return stakesOfOwner[_user][_index].version != currentVersion;\r\n    }\r\n    \r\n    // anyone can create a stake\r\n    function createStake(address _stakeToken, address _rewardToken, uint256 _amount) external whenNotPaused {\r\n        StakeTokenInfo storage stakeTokenInfo = supportedTokenInfos[_stakeToken][_rewardToken];\r\n        require(stakeTokenInfo.enabled, \"Stake token is not enabled\");\r\n        require(_amount >= stakeTokenInfo.minimum, \"The amount is too low\");\r\n\r\n        IERC20 stakeToken = IERC20(_stakeToken);\r\n\r\n        // store the tokens of the user in the contract\r\n        // requires approve\r\n        uint256 realAmount = stakeToken.balanceOf(address(this)); // we need to calculate real amount because of reflection\r\n\t\tstakeToken.transferFrom(msg.sender, address(this), _amount);\r\n        realAmount = stakeToken.balanceOf(address(this)) - realAmount; // realAmount is the final balance received\r\n\r\n        // store the account of the staker in ownersAccounts if it doesnt exists\r\n\t\tif(stakesOfOwner[msg.sender].length == 0){\r\n            ownersAccounts.push(msg.sender);\r\n\t\t}\r\n\r\n        // create the stake\r\n        stakesOfOwner[msg.sender].push(Stake({\r\n            version: currentVersion,\r\n            stakeToken: _stakeToken,\r\n            rewardToken: _rewardToken,\r\n            startTimestamp: uint64(block.timestamp),\r\n            amount: realAmount,\r\n            interest: 0,\r\n            penalty: 0,\r\n            lastWithdrawalTimestamp: 0,\r\n            finishedTimestamp: 0,\r\n            finishedVersion: 0\r\n        }));\r\n        if (validStakesCountOfOwner[msg.sender] == 0) {\r\n            stakingOwnerCount++;\r\n        }\r\n        validStakesCountOfOwner[msg.sender]++;\r\n        totalValidStakesCount++;\r\n        stakeTokenInfo.stakingAmount += realAmount;\r\n        emit StakeCreated(msg.sender, uint32(stakesOfOwner[msg.sender].length - 1), _stakeToken, _rewardToken, realAmount);\r\n    }\r\n\r\n    function processStakeOnFinish(StakeTokenInfo storage stakeTokenInfo, Stake storage stake) private  {\r\n        stakeTokenInfo.stakingAmount -= stake.amount;\r\n        validStakesCountOfOwner[msg.sender]--;\r\n        totalValidStakesCount--;\r\n        if (validStakesCountOfOwner[msg.sender] == 0) {\r\n            stakingOwnerCount--;\r\n        }\r\n\r\n        // record the transaction\r\n        stake.finishedTimestamp = uint64(block.timestamp);\r\n        stake.finishedVersion = currentVersion;\r\n    }\r\n\r\n    // withdraw obsoleted stakes\r\n    // _arrayIndex: is the id of the stake to be finalized\r\n    function withdrawObsoleteStake(uint32 _arrayIndex) external {\r\n\r\n        // Stake should exists and opened\r\n        require(_arrayIndex < stakesOfOwner[msg.sender].length, \"Stake does not exist\");\r\n        Stake storage stake = stakesOfOwner[msg.sender][_arrayIndex];\r\n        require(stake.finishedTimestamp == 0, \"This stake is closed\");\r\n        require(stake.version != currentVersion, \"This stake is not obsolete\");\r\n\r\n        StakeTokenInfo storage stakeTokenInfo = supportedTokenInfos[stake.stakeToken][stake.rewardToken];\r\n        \r\n        processStakeOnFinish(stakeTokenInfo, stake);\r\n\r\n        IERC20 stakeToken = IERC20(stake.stakeToken);\r\n        // transfer the amount from the contract itself\r\n        stakeToken.transfer(msg.sender, stake.amount);\r\n        emit WithdrawObsoleteStaking(msg.sender, _arrayIndex);\r\n    }\r\n\r\n    \r\n    // finalize the stake\r\n    // _arrayIndex: is the id of the stake to be finalized\r\n    function withdrawStakeWithoutReward(uint32 _arrayIndex) external whenWithdrawNotLocked {\r\n        // Stake should exists and opened\r\n        require(_arrayIndex < stakesOfOwner[msg.sender].length, \"Stake does not exist\");\r\n        Stake storage stake = stakesOfOwner[msg.sender][_arrayIndex];\r\n        require(stake.finishedTimestamp == 0, \"This stake is closed\");\r\n        require(stake.version == currentVersion, \"This stake is obsolete\");\r\n        require(block.timestamp - stake.startTimestamp >= minimumStakeTime, \"The stake is too short\");\r\n        \r\n        StakeTokenInfo storage stakeTokenInfo = supportedTokenInfos[stake.stakeToken][stake.rewardToken];\r\n        \r\n        \r\n        processStakeOnFinish(stakeTokenInfo, stake);\r\n\r\n        // transfer the amount from the contract itself\r\n        IERC20(stake.stakeToken).transfer(msg.sender, stake.amount);\r\n\r\n        emit WithdrawWithoutReward(msg.sender, _arrayIndex);\r\n    }\r\n\r\n    function calculateInterest(address _ownerAccount, uint32 _inx) private view returns (uint256 retInterest) {\r\n\r\n        Stake storage stake = stakesOfOwner[_ownerAccount][_inx];\r\n        (retInterest,,,,) = calculateInterestByStake(stake, block.timestamp - stake.startTimestamp < minimumStakeTime);\r\n    }\r\n\r\n    \r\n    function calculateInterestByStake(Stake storage _stake, bool _processPenalty) private view returns (uint256 retInterest, uint256 retPenalty, uint64 retInterestSeconds, uint32 apy, int8 apyDecimals) {\r\n        apy = 0;\r\n        StakeTokenInfo storage stakeTokenInfo = supportedTokenInfos[_stake.stakeToken][_stake.rewardToken];\r\n        for (uint i=stakeTokenInfo.tokenAPYs.length - 1; i>=0; i--) {\r\n            if (_stake.amount >= stakeTokenInfo.tokenAPYs[i].lowerBoundAmount) {\r\n                apy = stakeTokenInfo.tokenAPYs[i].apy;\r\n                break;\r\n            }\r\n        }\r\n\r\n        apyDecimals = stakeTokenInfo.apyDecimals;\r\n\r\n        // APY per year = amount * APY * 10^apyDecimal / seconds of the year\r\n        uint256 interestPerYear = _stake.amount * apy;\r\n        if (apyDecimals > 0) {\r\n            interestPerYear = interestPerYear * (10 ** uint8(apyDecimals));\r\n        } else if (apyDecimals < 0) {\r\n            interestPerYear = interestPerYear / (10 ** uint8(-apyDecimals));\r\n        }\r\n\r\n        // number of seconds since opening date\r\n        retInterestSeconds = uint64(block.timestamp -  Math.max(_stake.startTimestamp, _stake.lastWithdrawalTimestamp));\r\n\r\n        // calculate interest by a rule of three\r\n        //  seconds of the year: 31536000 = 365*24*60*60\r\n        //  interestPerYear   -   31536000\r\n        //  interest            -   num_seconds\r\n        //  interest = num_seconds * interestPerYear / 31536000\r\n        retInterest = retInterestSeconds * interestPerYear / 31536000;\r\n\r\n        // calculate penalty = interest * penalty / 100\r\n        if (_processPenalty) {\r\n            retPenalty = retInterest * penalty / 100;\r\n            retInterest -= retPenalty;\r\n        }\r\n    }\r\n\r\n    // finalize the stake\r\n    // _arrayIndex: is the id of the stake to be finalized\r\n    function withdrawStake(uint32 _arrayIndex) external whenWithdrawNotLocked {\r\n        // Stake should exists and opened\r\n        require(_arrayIndex < stakesOfOwner[msg.sender].length, \"Stake does not exist\");\r\n        Stake storage stake = stakesOfOwner[msg.sender][_arrayIndex];\r\n        require(stake.finishedTimestamp == 0, \"This stake is closed\");\r\n        require(stake.version == currentVersion, \"This stake is obsolete\");\r\n        require(block.timestamp - stake.startTimestamp >= minimumStakeTime, \"The stake is too short\");\r\n        \r\n        StakeTokenInfo storage stakeTokenInfo = supportedTokenInfos[stake.stakeToken][stake.rewardToken];\r\n        \r\n        processStakeOnFinish(stakeTokenInfo, stake);\r\n        \r\n        // get the interest\r\n        (uint256 interest,, uint64 interestSeconds,,) = calculateInterestByStake(stake, false);\r\n        // record the transaction\r\n        stake.interest += interest;\r\n\r\n        if (interest > 0) {\r\n            // transfer the interest amount from the contract owner\r\n            IERC20(stake.rewardToken).transferFrom(owner(), msg.sender, interest);\r\n        }\r\n\r\n        IERC20(stake.stakeToken).transfer(msg.sender, stake.amount);\r\n\r\n        // transfer the amount from the contract itself\r\n        emit Withdraw(msg.sender, _arrayIndex, interestSeconds, interest);\r\n    }\r\n    \r\n    function withdrawStakeInterest(uint32 _arrayIndex) external whenWithdrawNotLocked {\r\n        // Stake should exists and opened\r\n        require(_arrayIndex < stakesOfOwner[msg.sender].length, \"Stake does not exist\");\r\n        Stake storage stake = stakesOfOwner[msg.sender][_arrayIndex];\r\n        require(stake.finishedTimestamp == 0, \"This stake is closed\");\r\n        require(stake.version == currentVersion, \"This stake is obsolete\");\r\n        require(block.timestamp - stake.startTimestamp >= minimumStakeTime, \"The stake is too short\");\r\n        \r\n        \r\n        // get the interest\r\n        (uint256 interest,, uint64 interestSeconds,,) = calculateInterestByStake(stake, false);\r\n        \r\n        require(interest > 0, \"No interest to withdraw\");\r\n\r\n        // record the transaction\r\n        stake.lastWithdrawalTimestamp = uint64(block.timestamp);\r\n        stake.interest += interest;\r\n\r\n        // transfer the interest amount from the contract owner\r\n        IERC20(stake.rewardToken).transferFrom(owner(), msg.sender, interest);\r\n\r\n        emit WithdrawInterest(msg.sender, _arrayIndex, interestSeconds, interest);\r\n    }\r\n\r\n    // finalize the stake before the minimum stake time\r\n    // _arrayIndex: is the id of the stake to be finalized\r\n    function emergencyWithdrawStake(uint32 _arrayIndex) external whenWithdrawNotLocked {\r\n\r\n        // Stake should exists and opened\r\n        require(_arrayIndex < stakesOfOwner[msg.sender].length, \"Stake does not exist\");\r\n        Stake storage stake = stakesOfOwner[msg.sender][_arrayIndex];\r\n        require(stake.finishedTimestamp == 0, \"This stake is closed\");\r\n        require(stake.version == currentVersion, \"This stake is obsolete\");\r\n        require(block.timestamp - stake.startTimestamp < minimumStakeTime, \"This stake can be withdrawn normally\");\r\n        StakeTokenInfo storage stakeTokenInfo = supportedTokenInfos[stake.stakeToken][stake.rewardToken];\r\n        \r\n        processStakeOnFinish(stakeTokenInfo, stake);\r\n    \r\n        // get the interest\r\n        (uint256 interest, uint256 thePenalty, uint64 interestSeconds,,) = calculateInterestByStake(stake, true);\r\n\r\n        // record the transaction\r\n        stake.interest += interest;\r\n        stake.penalty += thePenalty;\r\n\r\n        // penalty funds are hold by the contract, but keep the account of how much is it here\r\n        stakeTokenInfo.collectedPenalty += thePenalty;\r\n\r\n        if (interest > 0) {\r\n            // transfer the interest amount from the contract owner\r\n            IERC20(stake.rewardToken).transferFrom(owner(), msg.sender, interest);\r\n        }\r\n\r\n        // transfer remaining\r\n        IERC20(stake.stakeToken).transfer(msg.sender, stake.amount);\r\n        emit EmergencyWithdraw(msg.sender, _arrayIndex, interestSeconds, interest, thePenalty);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumStakeTimeSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_penalty\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"interestSeconds\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"}],\"name\":\"ObsoleteVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"apyDecimals\",\"type\":\"int8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct StakingAnyToken.TokenAPY[]\",\"name\":\"tokenAPYs\",\"type\":\"tuple[]\"}],\"name\":\"StakeTokenInfoAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"apyDecimals\",\"type\":\"int8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct StakingAnyToken.TokenAPY[]\",\"name\":\"tokenAPYs\",\"type\":\"tuple[]\"}],\"name\":\"StakeTokenInfoChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"interestSeconds\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"interestSeconds\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"}],\"name\":\"WithdrawInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"WithdrawObsoleteStaking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"WithdrawWithoutReward\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimum\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"_apyDecimals\",\"type\":\"int8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.TokenAPY[]\",\"name\":\"_tokenAPYs\",\"type\":\"tuple[]\"}],\"name\":\"addSupportedStakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentVersion\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_arrayIndex\",\"type\":\"uint32\"}],\"name\":\"emergencyWithdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"isObsoleteStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newVal\",\"type\":\"uint256\"}],\"name\":\"modifyMinimumStakeTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newVal\",\"type\":\"uint8\"}],\"name\":\"modifyPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"obsoleteVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownersAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownersAccountsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penalty\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_skipFinished\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"_startInx\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_length\",\"type\":\"uint32\"}],\"name\":\"queryAllStakePaginated\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"lastWithdrawalTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finishedTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"finishedVersion\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.Stake[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct StakingAnyToken.AddressStakesData[]\",\"name\":\"userStakes\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"}],\"internalType\":\"struct StakingAnyToken.StakeResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryOwnersAccounts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_startInx\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_length\",\"type\":\"uint32\"}],\"name\":\"queryOwnersAccountsPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"querySummary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"stakingOwnerCount\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingAnyToken.StakeRewardTokenAmountPair[]\",\"name\":\"leftStakingAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct StakingAnyToken.Summary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"querySupportedStakeRewardTokenPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"internalType\":\"struct StakingAnyToken.StakeRewardTokenPair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"querySupportedStakeTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasAdded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"apyDecimals\",\"type\":\"int8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.TokenAPY[]\",\"name\":\"tokenAPYs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"collectedPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingAnyToken.StakeTokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_startInx\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_length\",\"type\":\"uint32\"}],\"name\":\"querySupportedTokenInfosPaginated\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasAdded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"apyDecimals\",\"type\":\"int8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.TokenAPY[]\",\"name\":\"tokenAPYs\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"collectedPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingAnyToken.StakeTokenInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_skipFinished\",\"type\":\"bool\"}],\"name\":\"queryUserStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"lastWithdrawalTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finishedTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"finishedVersion\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"interestRealTime\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"apyDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.StakeView[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"}],\"name\":\"queryUserStakeSummary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"historyTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validWithObsoleted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTotal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"stakeTokenAPY\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.TokenAPY\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"stakeTokenApyLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakesOfOwner\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"lastWithdrawalTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"finishedTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"finishedVersion\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"stakesOfOwnerLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingOwnerCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supportedStakeRewardTokenPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supportedStakeRewardTokenPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokenInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasAdded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"apyDecimals\",\"type\":\"int8\"},{\"internalType\":\"uint256\",\"name\":\"collectedPenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalValidStakesCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minimum\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"_apyDecimals\",\"type\":\"int8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lowerBoundAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"apy\",\"type\":\"uint32\"}],\"internalType\":\"struct StakingAnyToken.TokenAPY[]\",\"name\":\"_tokenAPYs\",\"type\":\"tuple[]\"}],\"name\":\"updateSupportedStakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validStakesCountOfOwner\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_arrayIndex\",\"type\":\"uint32\"}],\"name\":\"withdrawObsoleteStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_arrayIndex\",\"type\":\"uint32\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_arrayIndex\",\"type\":\"uint32\"}],\"name\":\"withdrawStakeInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_arrayIndex\",\"type\":\"uint32\"}],\"name\":\"withdrawStakeWithoutReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingAnyToken", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000003f480000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://39c31c6169a5966b5d77a38155b1ab8634da09835810022f041838bfc9373347"}