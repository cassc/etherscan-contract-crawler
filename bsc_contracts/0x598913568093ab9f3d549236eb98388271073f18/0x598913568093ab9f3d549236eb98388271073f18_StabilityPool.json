{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StabilityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"./Interfaces/IStabilityPool.sol\\\";\\nimport \\\"./Interfaces/IBorrowerOperations.sol\\\";\\nimport \\\"./Interfaces/ITroveManager.sol\\\";\\nimport \\\"./Interfaces/IUSDSToken.sol\\\";\\nimport \\\"./Interfaces/ISortedTroves.sol\\\";\\nimport \\\"./Interfaces/ICommunityIssuance.sol\\\";\\nimport \\\"./Dependencies/LiquityBase.sol\\\";\\nimport \\\"./Dependencies/SafeMath.sol\\\";\\nimport \\\"./Dependencies/LiquitySafeMath128.sol\\\";\\nimport \\\"./Dependencies/Ownable.sol\\\";\\nimport \\\"./Dependencies/CheckContract.sol\\\";\\nimport \\\"./Dependencies/console.sol\\\";\\n\\n/*\\n * The Stability Pool holds USDS tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its USDS debt gets offset with\\n * USDS in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of USDS tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a USDS loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an BNB gain, as the BNB collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total USDS in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n *\\n * --- IMPLEMENTATION ---\\n *\\n * We use a highly scalable method of tracking deposits and BNB gains that has O(1) complexity.\\n *\\n * When a liquidation occurs, rather than updating each depositor's deposit and BNB gain, we simply update two state variables:\\n * a product P, and a sum S.\\n *\\n * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits\\n * and accumulated BNB gains over time, as liquidations occur, using just these two variables P and S. When depositors join the\\n * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.\\n *\\n * The formula for a depositor's accumulated BNB gain is derived here:\\n * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf\\n *\\n * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,\\n * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated BNB gain.\\n *\\n * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding BNB gain\\n * can be calculated using the initial deposit, the depositor\u2019s snapshots of P and S, and the latest values of P and S.\\n *\\n * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated BNB gain is paid out, their new deposit is recorded\\n * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.\\n * Essentially, they make a fresh deposit that overwrites the old one.\\n *\\n *\\n * --- SCALE FACTOR ---\\n *\\n * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.\\n * Unfortunately, Solidity floor division always reaches 0, sooner or later.\\n *\\n * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P\\n * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.\\n *\\n * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),\\n * we first multiply P by 1e9, and increment a currentScale factor by 1.\\n *\\n * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the\\n * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the\\n * order of 1e-9.\\n *\\n * --- EPOCHS ---\\n *\\n * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0\\n * forever, and break all future reward calculations.\\n *\\n * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.\\n *\\n * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---\\n *\\n * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.\\n *\\n * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,\\n * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.\\n *\\n * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.\\n * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit\\n * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion USDS has depleted to < 1 USDS).\\n *\\n *\\n *  --- TRACKING DEPOSITOR'S BNB GAIN OVER SCALE CHANGES AND EPOCHS ---\\n *\\n * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.\\n *\\n * This allows us to calculate a deposit's accumulated BNB gain, during the epoch in which the deposit was non-zero and earned BNB.\\n *\\n * We calculate the depositor's accumulated BNB gain for the scale at which they made the deposit, using the BNB gain formula:\\n * e_1 = d_t * (S - S_t) / P_t\\n *\\n * and also for scale after, taking care to divide the latter by a factor of 1e9:\\n * e_2 = d_t * S / (P_t * 1e9)\\n *\\n * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.\\n * The deposit therefore was present for reward events from the beginning of that second scale.\\n *\\n *        S_i-S_t + S_{i+1}\\n *      .<--------.------------>\\n *      .         .\\n *      . S_i     .   S_{i+1}\\n *   <--.-------->.<----------->\\n *   S_t.         .\\n *   <->.         .\\n *      t         .\\n *  |---+---------|-------------|-----...\\n *         i            i+1\\n *\\n * The sum of (e_1 + e_2) captures the depositor's total accumulated BNB gain, handling the case where their\\n * deposit spanned one scale change. We only care about gains across one scale change, since the compounded\\n * deposit is defined as being 0 once it has spanned more than one scale change.\\n *\\n *\\n * --- UPDATING P WHEN A LIQUIDATION OCCURS ---\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / BNB gain derivations:\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n *\\n * --- SABLE ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * An SABLE issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued SABLE in proportion to the deposit as a share of total deposits. The SABLE earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * Please see the system Readme for an overview:\\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\\n *\\n * We use the same mathematical product-sum approach to track SABLE gains for depositors, where 'G' is the sum corresponding to SABLE gains.\\n * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.\\n *\\n */\\ncontract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {\\n    using LiquitySafeMath128 for uint128;\\n\\n    string public constant NAME = \\\"StabilityPool\\\";\\n\\n    IBorrowerOperations public borrowerOperations;\\n\\n    ITroveManager public troveManager;\\n\\n    IUSDSToken public usdsToken;\\n\\n    // Needed to check if there are pending liquidations\\n    ISortedTroves public sortedTroves;\\n\\n    ICommunityIssuance public communityIssuance;\\n\\n    uint256 internal BNB; // deposited ether tracker\\n\\n    // Tracker for USDS held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n    uint256 internal totalUSDSDeposits;\\n\\n    // --- Data structures ---\\n\\n    struct FrontEnd {\\n        uint kickbackRate;\\n        bool registered;\\n    }\\n\\n    struct Deposit {\\n        uint initialValue;\\n        address frontEndTag;\\n    }\\n\\n    struct Snapshots {\\n        uint S;\\n        uint P;\\n        uint G;\\n        uint128 scale;\\n        uint128 epoch;\\n    }\\n\\n    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct\\n    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct\\n\\n    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct\\n    mapping(address => uint) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end\\n    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct\\n\\n    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,\\n     * after a series of liquidations have occurred, each of which cancel some USDS debt with the deposit.\\n     *\\n     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t\\n     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.\\n     */\\n    uint public P = DECIMAL_PRECISION;\\n\\n    uint public constant SCALE_FACTOR = 1e9;\\n\\n    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1\\n    uint128 public currentScale;\\n\\n    // With each offset that fully empties the Pool, the epoch is incremented by 1\\n    uint128 public currentEpoch;\\n\\n    /* BNB Gain sum 'S': During its lifetime, each deposit d_t earns an BNB gain of ( d_t * [S - S_t] )/P_t, where S_t\\n     * is the depositor's snapshot of S taken at the time t when the deposit was made.\\n     *\\n     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):\\n     *\\n     * - The inner mapping records the sum S at different scales\\n     * - The outer mapping records the (scale => sum) mappings, for different epochs.\\n     */\\n    mapping(uint128 => mapping(uint128 => uint)) public epochToScaleToSum;\\n\\n    /*\\n     * Similarly, the sum 'G' is used to calculate SABLE gains. During it's lifetime, each deposit d_t earns a SABLE gain of\\n     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.\\n     *\\n     *  SABLE reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.\\n     *  In each case, the SABLE reward is issued (i.e. G is updated), before other state changes are made.\\n     */\\n    mapping(uint128 => mapping(uint128 => uint)) public epochToScaleToG;\\n\\n    // Error tracker for the error correction in the SABLE issuance calculation\\n    uint public lastSABLEError;\\n    // Error trackers for the error correction in the offset calculation\\n    uint public lastBNBError_Offset;\\n    uint public lastUSDSLossError_Offset;\\n\\n    // --- Events ---\\n\\n    event StabilityPoolBNBBalanceUpdated(uint _newBalance);\\n    event StabilityPoolUSDSBalanceUpdated(uint _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event USDSTokenAddressChanged(address _newUSDSTokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n    event SystemStateAddressChanged(address _newSystemStateAddress);\\n\\n    event P_Updated(uint _P);\\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\\n    event EpochUpdated(uint128 _currentEpoch);\\n    event ScaleUpdated(uint128 _currentScale);\\n\\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\\n\\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\\n    event FrontEndStakeChanged(\\n        address indexed _frontEnd,\\n        uint _newFrontEndStake,\\n        address _depositor\\n    );\\n\\n    event BNBGainWithdrawn(address indexed _depositor, uint _BNB, uint _USDSLoss);\\n    event SABLEPaidToDepositor(address indexed _depositor, uint _SABLE);\\n    event SABLEPaidToFrontEnd(address indexed _frontEnd, uint _SABLE);\\n    event EtherSent(address _to, uint _amount);\\n\\n    // --- Contract setters ---\\n\\n    function setParams(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _usdsTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress,\\n        address _systemStateAddress\\n    ) external override onlyOwner {\\n        checkContract(_borrowerOperationsAddress);\\n        checkContract(_troveManagerAddress);\\n        checkContract(_activePoolAddress);\\n        checkContract(_usdsTokenAddress);\\n        checkContract(_sortedTrovesAddress);\\n        checkContract(_priceFeedAddress);\\n        checkContract(_communityIssuanceAddress);\\n        checkContract(_systemStateAddress);\\n\\n        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);\\n        troveManager = ITroveManager(_troveManagerAddress);\\n        activePool = IActivePool(_activePoolAddress);\\n        usdsToken = IUSDSToken(_usdsTokenAddress);\\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\\n        priceFeed = IPriceFeed(_priceFeedAddress);\\n        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);\\n        systemState = ISystemState(_systemStateAddress);\\n\\n        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);\\n        emit TroveManagerAddressChanged(_troveManagerAddress);\\n        emit ActivePoolAddressChanged(_activePoolAddress);\\n        emit USDSTokenAddressChanged(_usdsTokenAddress);\\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\\n        emit PriceFeedAddressChanged(_priceFeedAddress);\\n        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);\\n        emit SystemStateAddressChanged(_systemStateAddress);\\n\\n        _renounceOwnership();\\n    }\\n\\n    // --- Getters for public variables. Required by IPool interface ---\\n\\n    function getBNB() external view override returns (uint) {\\n        return BNB;\\n    }\\n\\n    function getTotalUSDSDeposits() external view override returns (uint) {\\n        return totalUSDSDeposits;\\n    }\\n\\n    // --- External Depositor Functions ---\\n\\n    /*  provideToSP():\\n     *\\n     * - Triggers a SABLE issuance, based on time passed since the last issuance. The SABLE issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (SABLE, BNB) to depositor\\n     * - Sends the tagged front end's accumulated SABLE gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint _amount, address _frontEndTag) external override {\\n        _requireFrontEndIsRegisteredOrZero(_frontEndTag);\\n        _requireFrontEndNotRegistered(msg.sender);\\n        _requireNonZeroAmount(_amount);\\n\\n        uint initialDeposit = deposits[msg.sender].initialValue;\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerSABLEIssuance(communityIssuanceCached);\\n\\n        if (initialDeposit == 0) {\\n            _setFrontEndTag(msg.sender, _frontEndTag);\\n        }\\n        uint depositorBNBGain = getDepositorBNBGain(msg.sender);\\n        uint compoundedUSDSDeposit = getCompoundedUSDSDeposit(msg.sender);\\n        uint USDSLoss = initialDeposit.sub(compoundedUSDSDeposit); // Needed only for event log\\n\\n        // First pay out any SABLE gains\\n        address frontEnd = deposits[msg.sender].frontEndTag;\\n        _payOutSABLEGains(communityIssuanceCached, msg.sender, frontEnd);\\n\\n        // Update front end stake\\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\\n        uint newFrontEndStake = compoundedFrontEndStake.add(_amount);\\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\\n\\n        _sendUSDStoStabilityPool(msg.sender, _amount);\\n\\n        uint newDeposit = compoundedUSDSDeposit.add(_amount);\\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\\n        emit UserDepositChanged(msg.sender, newDeposit);\\n\\n        emit BNBGainWithdrawn(msg.sender, depositorBNBGain, USDSLoss); // USDS Loss required for event log\\n\\n        _sendBNBGainToDepositor(depositorBNBGain);\\n    }\\n\\n    /*  withdrawFromSP():\\n     *\\n     * - Triggers a SABLE issuance, based on time passed since the last issuance. The SABLE issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (SABLE, BNB) to depositor\\n     * - Sends the tagged front end's accumulated SABLE gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint _amount, bytes[] calldata priceFeedUpdateData) external override {\\n        if (_amount != 0) {\\n            _requireNoUnderCollateralizedTroves(priceFeedUpdateData);\\n        }\\n        uint initialDeposit = deposits[msg.sender].initialValue;\\n        _requireUserHasDeposit(initialDeposit);\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerSABLEIssuance(communityIssuanceCached);\\n\\n        uint depositorBNBGain = getDepositorBNBGain(msg.sender);\\n\\n        uint compoundedUSDSDeposit = getCompoundedUSDSDeposit(msg.sender);\\n        uint USDStoWithdraw = LiquityMath._min(_amount, compoundedUSDSDeposit);\\n        uint USDSLoss = initialDeposit.sub(compoundedUSDSDeposit); // Needed only for event log\\n\\n        // First pay out any SABLE gains\\n        address frontEnd = deposits[msg.sender].frontEndTag;\\n        _payOutSABLEGains(communityIssuanceCached, msg.sender, frontEnd);\\n\\n        // Update front end stake\\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\\n        uint newFrontEndStake = compoundedFrontEndStake.sub(USDStoWithdraw);\\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\\n\\n        _sendUSDSToDepositor(msg.sender, USDStoWithdraw);\\n\\n        // Update deposit\\n        uint newDeposit = compoundedUSDSDeposit.sub(USDStoWithdraw);\\n        _updateDepositAndSnapshots(msg.sender, newDeposit);\\n        emit UserDepositChanged(msg.sender, newDeposit);\\n\\n        emit BNBGainWithdrawn(msg.sender, depositorBNBGain, USDSLoss); // USDS Loss required for event log\\n\\n        _sendBNBGainToDepositor(depositorBNBGain);\\n    }\\n\\n    function ownerTriggerIssuance() external override {\\n        _requireCallerIsCommunityIssuance();\\n        _triggerSABLEIssuance(communityIssuance);\\n    }\\n\\n    /* withdrawBNBGainToTrove:\\n     * - Triggers a SABLE issuance, based on time passed since the last issuance. The SABLE issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's SABLE gain to  depositor\\n     * - Sends all tagged front end's SABLE gain to the tagged front end\\n     * - Transfers the depositor's entire BNB gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake */\\n    function withdrawBNBGainToTrove(\\n        address _upperHint,\\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdateData\\n    ) external override {\\n        uint initialDeposit = deposits[msg.sender].initialValue;\\n        _requireUserHasDeposit(initialDeposit);\\n        _requireUserHasTrove(msg.sender);\\n        _requireUserHasBNBGain(msg.sender);\\n\\n        ICommunityIssuance communityIssuanceCached = communityIssuance;\\n\\n        _triggerSABLEIssuance(communityIssuanceCached);\\n\\n        uint depositorBNBGain = getDepositorBNBGain(msg.sender);\\n\\n        uint compoundedUSDSDeposit = getCompoundedUSDSDeposit(msg.sender);\\n        uint USDSLoss = initialDeposit.sub(compoundedUSDSDeposit); // Needed only for event log\\n\\n        // First pay out any SABLE gains\\n        address frontEnd = deposits[msg.sender].frontEndTag;\\n        _payOutSABLEGains(communityIssuanceCached, msg.sender, frontEnd);\\n\\n        // Update front end stake\\n        uint compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);\\n        uint newFrontEndStake = compoundedFrontEndStake;\\n        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);\\n        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);\\n\\n        _updateDepositAndSnapshots(msg.sender, compoundedUSDSDeposit);\\n\\n        /* Emit events before transferring BNB gain to Trove.\\n         This lets the event log make more sense (i.e. so it appears that first the BNB gain is withdrawn\\n        and then it is deposited into the Trove, not the other way around). */\\n        emit BNBGainWithdrawn(msg.sender, depositorBNBGain, USDSLoss);\\n        emit UserDepositChanged(msg.sender, compoundedUSDSDeposit);\\n\\n        BNB = BNB.sub(depositorBNBGain);\\n        emit StabilityPoolBNBBalanceUpdated(BNB);\\n        emit EtherSent(msg.sender, depositorBNBGain);\\n\\n        borrowerOperations.moveBNBGainToTrove{value: depositorBNBGain}(\\n            msg.sender,\\n            _upperHint,\\n            _lowerHint,\\n            priceFeedUpdateData\\n        );\\n    }\\n\\n    // --- SABLE issuance functions ---\\n\\n    function _triggerSABLEIssuance(ICommunityIssuance _communityIssuance) internal {\\n        uint SABLEIssuance = _communityIssuance.issueSABLE();\\n        _updateG(SABLEIssuance);\\n    }\\n\\n    function _updateG(uint _SABLEIssuance) internal {\\n        uint totalUSDS = totalUSDSDeposits; // cached to save an SLOAD\\n        /*\\n         * When total deposits is 0, G is not updated. In this case, the SABLE issued can not be obtained by later\\n         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.\\n         *\\n         */\\n        if (totalUSDS == 0 || _SABLEIssuance == 0) {\\n            return;\\n        }\\n\\n        uint SABLEPerUnitStaked;\\n        SABLEPerUnitStaked = _computeSABLEPerUnitStaked(_SABLEIssuance, totalUSDS);\\n\\n        uint marginalSABLEGain = SABLEPerUnitStaked.mul(P);\\n        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]\\n            .add(marginalSABLEGain);\\n\\n        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);\\n    }\\n\\n    function _computeSABLEPerUnitStaked(\\n        uint _SABLEIssuance,\\n        uint _totalUSDSDeposits\\n    ) internal returns (uint) {\\n        /*\\n         * Calculate the SABLE-per-unit staked.  Division uses a \\\"feedback\\\" error correction, to keep the\\n         * cumulative error low in the running total G:\\n         *\\n         * 1) Form a numerator which compensates for the floor division error that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratio.\\n         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store this error for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint SABLENumerator = _SABLEIssuance.mul(DECIMAL_PRECISION).add(lastSABLEError);\\n\\n        uint SABLEPerUnitStaked = SABLENumerator.div(_totalUSDSDeposits);\\n        lastSABLEError = SABLENumerator.sub(SABLEPerUnitStaked.mul(_totalUSDSDeposits));\\n\\n        return SABLEPerUnitStaked;\\n    }\\n\\n    // --- Liquidation functions ---\\n\\n    /*\\n     * Cancels out the specified debt against the USDS contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's BNB collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint _debtToOffset, uint _collToAdd) external override {\\n        _requireCallerIsTroveManager();\\n        uint totalUSDS = totalUSDSDeposits; // cached to save an SLOAD\\n        if (totalUSDS == 0 || _debtToOffset == 0) {\\n            return;\\n        }\\n\\n        _triggerSABLEIssuance(communityIssuance);\\n\\n        (uint BNBGainPerUnitStaked, uint USDSLossPerUnitStaked) = _computeRewardsPerUnitStaked(\\n            _collToAdd,\\n            _debtToOffset,\\n            totalUSDS\\n        );\\n\\n        _updateRewardSumAndProduct(BNBGainPerUnitStaked, USDSLossPerUnitStaked); // updates S and P\\n\\n        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);\\n    }\\n\\n    // --- Offset helper functions ---\\n\\n    function _computeRewardsPerUnitStaked(\\n        uint _collToAdd,\\n        uint _debtToOffset,\\n        uint _totalUSDSDeposits\\n    ) internal returns (uint BNBGainPerUnitStaked, uint USDSLossPerUnitStaked) {\\n        /*\\n         * Compute the USDS and BNB rewards. Uses a \\\"feedback\\\" error correction, to keep\\n         * the cumulative error in the P and S state variables low:\\n         *\\n         * 1) Form numerators which compensate for the floor division errors that occurred the last time this\\n         * function was called.\\n         * 2) Calculate \\\"per-unit-staked\\\" ratios.\\n         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.\\n         * 4) Store these errors for use in the next correction when this function is called.\\n         * 5) Note: static analysis tools complain about this \\\"division before multiplication\\\", however, it is intended.\\n         */\\n        uint BNBNumerator = _collToAdd.mul(DECIMAL_PRECISION).add(lastBNBError_Offset);\\n\\n        assert(_debtToOffset <= _totalUSDSDeposits);\\n        if (_debtToOffset == _totalUSDSDeposits) {\\n            USDSLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit\\n            lastUSDSLossError_Offset = 0;\\n        } else {\\n            uint USDSLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(\\n                lastUSDSLossError_Offset\\n            );\\n            /*\\n             * Add 1 to make error in quotient positive. We want \\\"slightly too much\\\" USDS loss,\\n             * which ensures the error in any given compoundedUSDSDeposit favors the Stability Pool.\\n             */\\n            USDSLossPerUnitStaked = (USDSLossNumerator.div(_totalUSDSDeposits)).add(1);\\n            lastUSDSLossError_Offset = (USDSLossPerUnitStaked.mul(_totalUSDSDeposits)).sub(\\n                USDSLossNumerator\\n            );\\n        }\\n\\n        BNBGainPerUnitStaked = BNBNumerator.div(_totalUSDSDeposits);\\n        lastBNBError_Offset = BNBNumerator.sub(BNBGainPerUnitStaked.mul(_totalUSDSDeposits));\\n\\n        return (BNBGainPerUnitStaked, USDSLossPerUnitStaked);\\n    }\\n\\n    // Update the Stability Pool reward sum S and product P\\n    function _updateRewardSumAndProduct(\\n        uint _BNBGainPerUnitStaked,\\n        uint _USDSLossPerUnitStaked\\n    ) internal {\\n        uint currentP = P;\\n        uint newP;\\n\\n        assert(_USDSLossPerUnitStaked <= DECIMAL_PRECISION);\\n        /*\\n         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool USDS in the liquidation.\\n         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - USDSLossPerUnitStaked)\\n         */\\n        uint newProductFactor = uint(DECIMAL_PRECISION).sub(_USDSLossPerUnitStaked);\\n\\n        uint128 currentScaleCached = currentScale;\\n        uint128 currentEpochCached = currentEpoch;\\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\\n\\n        /*\\n         * Calculate the new S first, before we update P.\\n         * The BNB gain for any given depositor from a liquidation depends on the value of their deposit\\n         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.\\n         *\\n         * Since S corresponds to BNB gain, and P to deposit loss, we update S first.\\n         */\\n        uint marginalBNBGain = _BNBGainPerUnitStaked.mul(currentP);\\n        uint newS = currentS.add(marginalBNBGain);\\n        epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;\\n        emit S_Updated(newS, currentEpochCached, currentScaleCached);\\n\\n        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P\\n        if (newProductFactor == 0) {\\n            currentEpoch = currentEpochCached.add(1);\\n            emit EpochUpdated(currentEpoch);\\n            currentScale = 0;\\n            emit ScaleUpdated(currentScale);\\n            newP = DECIMAL_PRECISION;\\n\\n            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale\\n        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {\\n            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);\\n            currentScale = currentScaleCached.add(1);\\n            emit ScaleUpdated(currentScale);\\n        } else {\\n            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);\\n        }\\n\\n        require(newP > 0);\\n        P = newP;\\n\\n        emit P_Updated(newP);\\n    }\\n\\n    function _moveOffsetCollAndDebt(uint _collToAdd, uint _debtToOffset) internal {\\n        IActivePool activePoolCached = activePool;\\n\\n        // Cancel the liquidated USDS debt with the USDS in the stability pool\\n        activePoolCached.decreaseUSDSDebt(_debtToOffset);\\n        _decreaseUSDS(_debtToOffset);\\n\\n        // Burn the debt that was successfully offset\\n        usdsToken.burn(address(this), _debtToOffset);\\n\\n        activePoolCached.sendBNB(address(this), _collToAdd);\\n    }\\n\\n    function _decreaseUSDS(uint _amount) internal {\\n        uint newTotalUSDSDeposits = totalUSDSDeposits.sub(_amount);\\n        totalUSDSDeposits = newTotalUSDSDeposits;\\n        emit StabilityPoolUSDSBalanceUpdated(newTotalUSDSDeposits);\\n    }\\n\\n    // --- Reward calculator functions for depositor and front end ---\\n\\n    /* Calculates the BNB gain earned by the deposit since its last snapshots were taken.\\n     * Given by the formula:  E = d0 * (S - S(0))/P(0)\\n     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.\\n     * d0 is the last recorded deposit value.\\n     */\\n    function getDepositorBNBGain(address _depositor) public view override returns (uint) {\\n        uint initialDeposit = deposits[_depositor].initialValue;\\n\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint BNBGain = _getBNBGainFromSnapshots(initialDeposit, snapshots);\\n        return BNBGain;\\n    }\\n\\n    function _getBNBGainFromSnapshots(\\n        uint initialDeposit,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint) {\\n        /*\\n         * Grab the sum 'S' from the epoch at which the stake was made. The BNB gain may span up to one scale change.\\n         * If it does, the second portion of the BNB gain is scaled by 1e9.\\n         * If the gain spans no scale change, the second portion will be 0.\\n         */\\n        uint128 epochSnapshot = snapshots.epoch;\\n        uint128 scaleSnapshot = snapshots.scale;\\n        uint S_Snapshot = snapshots.S;\\n        uint P_Snapshot = snapshots.P;\\n\\n        uint firstPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot].sub(S_Snapshot);\\n        uint secondPortion = epochToScaleToSum[epochSnapshot][scaleSnapshot.add(1)].div(\\n            SCALE_FACTOR\\n        );\\n\\n        uint BNBGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\\n            DECIMAL_PRECISION\\n        );\\n\\n        return BNBGain;\\n    }\\n\\n    /*\\n     * Calculate the SABLE gain earned by a deposit since its last snapshots were taken.\\n     * Given by the formula:  SABLE = d0 * (G - G(0))/P(0)\\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\\n     * d0 is the last recorded deposit value.\\n     */\\n    function getDepositorSABLEGain(address _depositor) public view override returns (uint) {\\n        uint initialDeposit = deposits[_depositor].initialValue;\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        address frontEndTag = deposits[_depositor].frontEndTag;\\n\\n        /*\\n         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\\n         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\\n         * which they made their deposit.\\n         */\\n        uint kickbackRate = frontEndTag == address(0)\\n            ? DECIMAL_PRECISION\\n            : frontEnds[frontEndTag].kickbackRate;\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint SABLEGain = kickbackRate.mul(_getSABLEGainFromSnapshots(initialDeposit, snapshots)).div(\\n            DECIMAL_PRECISION\\n        );\\n\\n        return SABLEGain;\\n    }\\n\\n    /*\\n     * Return the SABLE gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)\\n     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.\\n     *\\n     * D0 is the last recorded value of the front end's total tagged deposits.\\n     */\\n    function getFrontEndSABLEGain(address _frontEnd) public view override returns (uint) {\\n        uint frontEndStake = frontEndStakes[_frontEnd];\\n        if (frontEndStake == 0) {\\n            return 0;\\n        }\\n\\n        uint kickbackRate = frontEnds[_frontEnd].kickbackRate;\\n        uint frontEndShare = uint(DECIMAL_PRECISION).sub(kickbackRate);\\n\\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\\n\\n        uint SABLEGain = frontEndShare.mul(_getSABLEGainFromSnapshots(frontEndStake, snapshots)).div(\\n            DECIMAL_PRECISION\\n        );\\n        return SABLEGain;\\n    }\\n\\n    function _getSABLEGainFromSnapshots(\\n        uint initialStake,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint) {\\n        /*\\n         * Grab the sum 'G' from the epoch at which the stake was made. The SABLE gain may span up to one scale change.\\n         * If it does, the second portion of the SABLE gain is scaled by 1e9.\\n         * If the gain spans no scale change, the second portion will be 0.\\n         */\\n        uint128 epochSnapshot = snapshots.epoch;\\n        uint128 scaleSnapshot = snapshots.scale;\\n        uint G_Snapshot = snapshots.G;\\n        uint P_Snapshot = snapshots.P;\\n\\n        uint firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);\\n        uint secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(SCALE_FACTOR);\\n\\n        uint SABLEGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(\\n            DECIMAL_PRECISION\\n        );\\n\\n        return SABLEGain;\\n    }\\n\\n    // --- Compounded deposit and compounded front end stake ---\\n\\n    /*\\n     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)\\n     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.\\n     */\\n    function getCompoundedUSDSDeposit(address _depositor) public view override returns (uint) {\\n        uint initialDeposit = deposits[_depositor].initialValue;\\n        if (initialDeposit == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = depositSnapshots[_depositor];\\n\\n        uint compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);\\n        return compoundedDeposit;\\n    }\\n\\n    /*\\n     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)\\n     * where P(0) is the depositor's snapshot of the product P, taken at the last time\\n     * when one of the front end's tagged deposits updated their deposit.\\n     *\\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\\n     */\\n    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint) {\\n        uint frontEndStake = frontEndStakes[_frontEnd];\\n        if (frontEndStake == 0) {\\n            return 0;\\n        }\\n\\n        Snapshots memory snapshots = frontEndSnapshots[_frontEnd];\\n\\n        uint compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);\\n        return compoundedFrontEndStake;\\n    }\\n\\n    // Internal function, used to calculcate compounded deposits and compounded front end stakes.\\n    function _getCompoundedStakeFromSnapshots(\\n        uint initialStake,\\n        Snapshots memory snapshots\\n    ) internal view returns (uint) {\\n        uint snapshot_P = snapshots.P;\\n        uint128 scaleSnapshot = snapshots.scale;\\n        uint128 epochSnapshot = snapshots.epoch;\\n\\n        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0\\n        if (epochSnapshot < currentEpoch) {\\n            return 0;\\n        }\\n\\n        uint compoundedStake;\\n        uint128 scaleDiff = currentScale.sub(scaleSnapshot);\\n\\n        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,\\n         * account for it. If more than one scale change was made, then the stake has decreased by a factor of\\n         * at least 1e-9 -- so return 0.\\n         */\\n        if (scaleDiff == 0) {\\n            compoundedStake = initialStake.mul(P).div(snapshot_P);\\n        } else if (scaleDiff == 1) {\\n            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);\\n        } else {\\n            // if scaleDiff >= 2\\n            compoundedStake = 0;\\n        }\\n\\n        /*\\n         * If compounded deposit is less than a billionth of the initial deposit, return 0.\\n         *\\n         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error\\n         * corrections should ensure the error in P \\\"favors the Pool\\\", i.e. any given compounded deposit should slightly less\\n         * than it's theoretical value.\\n         *\\n         * Thus it's unclear whether this line is still really needed.\\n         */\\n        if (compoundedStake < initialStake.div(1e9)) {\\n            return 0;\\n        }\\n\\n        return compoundedStake;\\n    }\\n\\n    // --- Sender functions for USDS deposit, BNB gains and SABLE gains ---\\n\\n    // Transfer the USDS tokens from the user to the Stability Pool's address, and update its recorded USDS\\n    function _sendUSDStoStabilityPool(address _address, uint _amount) internal {\\n        usdsToken.sendToPool(_address, address(this), _amount);\\n        uint newTotalUSDSDeposits = totalUSDSDeposits.add(_amount);\\n        totalUSDSDeposits = newTotalUSDSDeposits;\\n        emit StabilityPoolUSDSBalanceUpdated(newTotalUSDSDeposits);\\n    }\\n\\n    function _sendBNBGainToDepositor(uint _amount) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n        uint newBNB = BNB.sub(_amount);\\n        BNB = newBNB;\\n        emit StabilityPoolBNBBalanceUpdated(newBNB);\\n        emit EtherSent(msg.sender, _amount);\\n\\n        (bool success, ) = msg.sender.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"StabilityPool: sending BNB failed\\\");\\n    }\\n\\n    // Send USDS to user and decrease USDS in Pool\\n    function _sendUSDSToDepositor(address _depositor, uint USDSWithdrawal) internal {\\n        if (USDSWithdrawal == 0) {\\n            return;\\n        }\\n\\n        usdsToken.returnFromPool(address(this), _depositor, USDSWithdrawal);\\n        _decreaseUSDS(USDSWithdrawal);\\n    }\\n\\n    // --- External Front End functions ---\\n\\n    // Front end makes a one-time selection of kickback rate upon registering\\n    function registerFrontEnd(uint _kickbackRate) external override {\\n        _requireFrontEndNotRegistered(msg.sender);\\n        _requireUserHasNoDeposit(msg.sender);\\n        _requireValidKickbackRate(_kickbackRate);\\n\\n        frontEnds[msg.sender].kickbackRate = _kickbackRate;\\n        frontEnds[msg.sender].registered = true;\\n\\n        emit FrontEndRegistered(msg.sender, _kickbackRate);\\n    }\\n\\n    // --- Stability Pool Deposit Functionality ---\\n\\n    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {\\n        deposits[_depositor].frontEndTag = _frontEndTag;\\n        emit FrontEndTagSet(_depositor, _frontEndTag);\\n    }\\n\\n    function _updateDepositAndSnapshots(address _depositor, uint _newValue) internal {\\n        deposits[_depositor].initialValue = _newValue;\\n\\n        if (_newValue == 0) {\\n            delete deposits[_depositor].frontEndTag;\\n            delete depositSnapshots[_depositor];\\n            emit DepositSnapshotUpdated(_depositor, 0, 0, 0);\\n            return;\\n        }\\n        uint128 currentScaleCached = currentScale;\\n        uint128 currentEpochCached = currentEpoch;\\n        uint currentP = P;\\n\\n        // Get S and G for the current epoch and current scale\\n        uint currentS = epochToScaleToSum[currentEpochCached][currentScaleCached];\\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\\n\\n        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor\\n        depositSnapshots[_depositor].P = currentP;\\n        depositSnapshots[_depositor].S = currentS;\\n        depositSnapshots[_depositor].G = currentG;\\n        depositSnapshots[_depositor].scale = currentScaleCached;\\n        depositSnapshots[_depositor].epoch = currentEpochCached;\\n\\n        emit DepositSnapshotUpdated(_depositor, currentP, currentS, currentG);\\n    }\\n\\n    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint _newValue) internal {\\n        frontEndStakes[_frontEnd] = _newValue;\\n\\n        if (_newValue == 0) {\\n            delete frontEndSnapshots[_frontEnd];\\n            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);\\n            return;\\n        }\\n\\n        uint128 currentScaleCached = currentScale;\\n        uint128 currentEpochCached = currentEpoch;\\n        uint currentP = P;\\n\\n        // Get G for the current epoch and current scale\\n        uint currentG = epochToScaleToG[currentEpochCached][currentScaleCached];\\n\\n        // Record new snapshots of the latest running product P and sum G for the front end\\n        frontEndSnapshots[_frontEnd].P = currentP;\\n        frontEndSnapshots[_frontEnd].G = currentG;\\n        frontEndSnapshots[_frontEnd].scale = currentScaleCached;\\n        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;\\n\\n        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);\\n    }\\n\\n    function _payOutSABLEGains(\\n        ICommunityIssuance _communityIssuance,\\n        address _depositor,\\n        address _frontEnd\\n    ) internal {\\n        // Pay out front end's SABLE gain\\n        if (_frontEnd != address(0)) {\\n            uint frontEndSABLEGain = getFrontEndSABLEGain(_frontEnd);\\n            _communityIssuance.sendSABLE(_frontEnd, frontEndSABLEGain);\\n            emit SABLEPaidToFrontEnd(_frontEnd, frontEndSABLEGain);\\n        }\\n\\n        // Pay out depositor's SABLE gain\\n        uint depositorSABLEGain = getDepositorSABLEGain(_depositor);\\n        _communityIssuance.sendSABLE(_depositor, depositorSABLEGain);\\n        emit SABLEPaidToDepositor(_depositor, depositorSABLEGain);\\n    }\\n\\n    // --- 'require' functions ---\\n\\n    function _requireCallerIsActivePool() internal view {\\n        require(msg.sender == address(activePool), \\\"StabilityPool: Caller is not ActivePool\\\");\\n    }\\n\\n    function _requireCallerIsTroveManager() internal view {\\n        require(msg.sender == address(troveManager), \\\"StabilityPool: Caller is not TroveManager\\\");\\n    }\\n\\n    function _requireCallerIsCommunityIssuance() internal view {\\n        require(\\n            msg.sender == address(communityIssuance),\\n            \\\"StabilityPool: Callier is not CommunityIssuance\\\"\\n        );\\n    }\\n\\n    function _requireNoUnderCollateralizedTroves(bytes[] calldata priceFeedUpdateData) internal {\\n        IPriceFeed.FetchPriceResult memory fetchPriceResult = priceFeed.fetchPrice(\\n            priceFeedUpdateData\\n        );\\n        address lowestTrove = sortedTroves.getLast();\\n        uint ICR = troveManager.getCurrentICR(lowestTrove, fetchPriceResult.price);\\n        uint MCR = systemState.getMCR();\\n        require(ICR >= MCR, \\\"StabilityPool: Cannot withdraw while there are troves with ICR < MCR\\\");\\n    }\\n\\n    function _requireUserHasDeposit(uint _initialDeposit) internal pure {\\n        require(_initialDeposit > 0, \\\"StabilityPool: User must have a non-zero deposit\\\");\\n    }\\n\\n    function _requireUserHasNoDeposit(address _address) internal view {\\n        uint initialDeposit = deposits[_address].initialValue;\\n        require(initialDeposit == 0, \\\"StabilityPool: User must have no deposit\\\");\\n    }\\n\\n    function _requireNonZeroAmount(uint _amount) internal pure {\\n        require(_amount > 0, \\\"StabilityPool: Amount must be non-zero\\\");\\n    }\\n\\n    function _requireUserHasTrove(address _depositor) internal view {\\n        require(\\n            troveManager.getTroveStatus(_depositor) == 1,\\n            \\\"StabilityPool: caller must have an active trove to withdraw BNBGain to\\\"\\n        );\\n    }\\n\\n    function _requireUserHasBNBGain(address _depositor) internal view {\\n        uint BNBGain = getDepositorBNBGain(_depositor);\\n        require(BNBGain > 0, \\\"StabilityPool: caller must have non-zero BNB Gain\\\");\\n    }\\n\\n    function _requireFrontEndNotRegistered(address _address) internal view {\\n        require(\\n            !frontEnds[_address].registered,\\n            \\\"StabilityPool: must not already be a registered front end\\\"\\n        );\\n    }\\n\\n    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {\\n        require(\\n            frontEnds[_address].registered || _address == address(0),\\n            \\\"StabilityPool: Tag must be a registered front end, or the zero address\\\"\\n        );\\n    }\\n\\n    function _requireValidKickbackRate(uint _kickbackRate) internal pure {\\n        require(\\n            _kickbackRate <= DECIMAL_PRECISION,\\n            \\\"StabilityPool: Kickback rate must be in range [0,1]\\\"\\n        );\\n    }\\n\\n    // --- Fallback function ---\\n\\n    receive() external payable {\\n        _requireCallerIsActivePool();\\n        BNB = BNB.add(msg.value);\\n        StabilityPoolBNBBalanceUpdated(BNB);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IBorrowerOperations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IActivePool.sol\\\";\\nimport \\\"./ITroveManager.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface IBorrowerOperations {\\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _activePoolAddress);\\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\\n    event GasPoolAddressChanged(address _gasPoolAddress);\\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\\n    event USDSTokenAddressChanged(address _usdsTokenAddress);\\n    event SableStakingAddressChanged(address _sableStakingAddress);\\n    event OracleRateCalcAddressChanged(address _oracleRateCalcAddress);\\n\\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint stake,\\n        uint8 operation\\n    );\\n    event USDSBorrowingFeePaid(address indexed _borrower, uint _USDSFee);\\n\\n    // --- Functions ---\\n\\n    struct DependencyAddressParam {\\n        address troveManagerAddress;\\n        address activePoolAddress;\\n        address defaultPoolAddress;\\n        address stabilityPoolAddress;\\n        address gasPoolAddress;\\n        address collSurplusPoolAddress;\\n        address priceFeedAddress;\\n        address sortedTrovesAddress;\\n        address usdsTokenAddress;\\n        address sableStakingAddress;\\n        address systemStateAddress;\\n        address oracleRateCalcAddress;\\n    }\\n\\n    struct TriggerBorrowingFeeParam {\\n        ITroveManager troveManager;\\n        IUSDSToken usdsToken;\\n        uint USDSAmount;\\n        uint maxFeePercentage;\\n        uint oracleRate;\\n    }\\n\\n    struct WithdrawUSDSParam {\\n        IActivePool activePool;\\n        IUSDSToken usdsToken;\\n        address account;\\n        uint USDSAmount;\\n        uint netDebtIncrease;\\n    }\\n\\n    struct TroveIsActiveParam {\\n        ITroveManager troveManager;\\n        address borrower;\\n    }\\n\\n    function setAddresses(DependencyAddressParam memory param) external;\\n\\n    function openTrove(\\n        uint _maxFee,\\n        uint _USDSAmount,\\n        address _upperHint,\\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdatedata\\n    ) external payable;\\n\\n    function addColl(\\n        address _upperHint, \\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdatedata\\n    ) external payable;\\n\\n    function moveBNBGainToTrove(\\n        address _user,\\n        address _upperHint,\\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdatedata\\n    ) external payable;\\n\\n    function withdrawColl(\\n        uint _amount, \\n        address _upperHint, \\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdatedata\\n    ) external;\\n\\n    function withdrawUSDS(\\n        uint _maxFee,\\n        uint _amount,\\n        address _upperHint,\\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdatedata\\n    ) external;\\n\\n    function repayUSDS(\\n        uint _amount, \\n        address _upperHint, \\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdatedata\\n    ) external;\\n\\n    function closeTrove(bytes[] calldata priceFeedUpdatedata) external;\\n\\n    struct AdjustTroveParam {\\n        uint collWithdrawal;\\n        uint USDSChange;\\n        bool isDebtIncrease;\\n        address upperHint;\\n        address lowerHint;\\n        uint maxFeePercentage;\\n    }\\n\\n    struct NewICRFromTroveChangeParam {\\n        uint coll;\\n        uint debt;\\n        uint collChange;\\n        bool isCollIncrease;\\n        uint debtChange;\\n        bool isDebtIncrease;\\n        uint price;\\n    }\\n\\n    struct UpdateTroveFromAdjustmentParam {\\n        ITroveManager troveManager;\\n        address borrower;\\n        uint collChange;\\n        bool isCollIncrease;\\n        uint debtChange;\\n        bool isDebtIncrease;\\n    }\\n\\n    struct NewNomialICRFromTroveChangeParam {\\n        uint coll;\\n        uint debt;\\n        uint collChange;\\n        bool isCollIncrease;\\n        uint debtChange;\\n        bool isDebtIncrease;\\n    }\\n\\n    function adjustTrove(\\n        AdjustTroveParam memory adjustParam,\\n        bytes[] calldata priceFeedUpdateData\\n    ) external payable;\\n\\n    function claimCollateral() external;\\n\\n    function getCompositeDebt(uint _debt) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IStabilityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n/*\\n * The Stability Pool holds USDS tokens deposited by Stability Pool depositors.\\n *\\n * When a trove is liquidated, then depending on system conditions, some of its USDS debt gets offset with\\n * USDS in the Stability Pool:  that is, the offset debt evaporates, and an equal amount of USDS tokens in the Stability Pool is burned.\\n *\\n * Thus, a liquidation causes each depositor to receive a USDS loss, in proportion to their deposit as a share of total deposits.\\n * They also receive an BNB gain, as the BNB collateral of the liquidated trove is distributed among Stability depositors,\\n * in the same proportion.\\n *\\n * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%\\n * of the total USDS in the Stability Pool, depletes 40% of each deposit.\\n *\\n * A deposit that has experienced a series of liquidations is termed a \\\"compounded deposit\\\": each liquidation depletes the deposit,\\n * multiplying it by some factor in range ]0,1[\\n *\\n * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / BNB gain derivations:\\n * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf\\n *\\n * --- SABLE ISSUANCE TO STABILITY POOL DEPOSITORS ---\\n *\\n * An SABLE issuance event occurs at every deposit operation, and every liquidation.\\n *\\n * Each deposit is tagged with the address of the front end through which it was made.\\n *\\n * All deposits earn a share of the issued SABLE in proportion to the deposit as a share of total deposits. The SABLE earned\\n * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.\\n *\\n * Please see the system Readme for an overview:\\n * https://github.com/liquity/dev/blob/main/README.md#lqty-issuance-to-stability-providers\\n */\\ninterface IStabilityPool {\\n\\n    // --- Events ---\\n    \\n    event StabilityPoolBNBBalanceUpdated(uint _newBalance);\\n    event StabilityPoolUSDSBalanceUpdated(uint _newBalance);\\n\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event USDSTokenAddressChanged(address _newUSDSTokenAddress);\\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\\n\\n    event P_Updated(uint _P);\\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\\n    event EpochUpdated(uint128 _currentEpoch);\\n    event ScaleUpdated(uint128 _currentScale);\\n\\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\\n\\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\\n\\n    event BNBGainWithdrawn(address indexed _depositor, uint _BNB, uint _USDSLoss);\\n    event SABLEPaidToDepositor(address indexed _depositor, uint _SABLE);\\n    event SABLEPaidToFrontEnd(address indexed _frontEnd, uint _SABLE);\\n    event EtherSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n\\n    /*\\n     * Called only once on init, to set addresses of other Sable contracts\\n     * Callable only by owner, renounces ownership at the end\\n     */\\n    function setParams(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress,\\n        address _usdsTokenAddress,\\n        address _sortedTrovesAddress,\\n        address _priceFeedAddress,\\n        address _communityIssuanceAddress,\\n        address _systemStateAddress\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Frontend is registered or zero address\\n     * - Sender is not a registered frontend\\n     * - _amount is not zero\\n     * ---\\n     * - Triggers a SABLE issuance, based on time passed since the last issuance. The SABLE issuance is shared between *all* depositors and front ends\\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\\n     * - Sends depositor's accumulated gains (SABLE, BNB) to depositor\\n     * - Sends the tagged front end's accumulated SABLE gains to the tagged front end\\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\\n     */\\n    function provideToSP(uint _amount, address _frontEndTag) external;\\n\\n    /*\\n     * Initial checks:\\n     * - _amount is zero or there are no under collateralized troves left in the system\\n     * - User has a non zero deposit\\n     * ---\\n     * - Triggers a SABLE issuance, based on time passed since the last issuance. The SABLE issuance is shared between *all* depositors and front ends\\n     * - Removes the deposit's front end tag if it is a full withdrawal\\n     * - Sends all depositor's accumulated gains (SABLE, BNB) to depositor\\n     * - Sends the tagged front end's accumulated SABLE gains to the tagged front end\\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\\n     *\\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\\n     */\\n    function withdrawFromSP(uint _amount, bytes[] calldata priceFeedUpdateData) external;\\n\\n    /*\\n     * Initial checks:\\n     * - User has a non zero deposit\\n     * - User has an open trove\\n     * - User has some BNB gain\\n     * ---\\n     * - Triggers a SABLE issuance, based on time passed since the last issuance. The SABLE issuance is shared between *all* depositors and front ends\\n     * - Sends all depositor's SABLE gain to  depositor\\n     * - Sends all tagged front end's SABLE gain to the tagged front end\\n     * - Transfers the depositor's entire BNB gain from the Stability Pool to the caller's trove\\n     * - Leaves their compounded deposit in the Stability Pool\\n     * - Updates snapshots for deposit and tagged front end stake\\n     */\\n    function withdrawBNBGainToTrove(\\n        address _upperHint, \\n        address _lowerHint,\\n        bytes[] calldata priceFeedUpdateData\\n    ) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Frontend (sender) not already registered\\n     * - User (sender) has no deposit\\n     * - _kickbackRate is in the range [0, 100%]\\n     * ---\\n     * Front end makes a one-time selection of kickback rate upon registering\\n     */\\n    function registerFrontEnd(uint _kickbackRate) external;\\n\\n    /*\\n     * Initial checks:\\n     * - Caller is TroveManager\\n     * ---\\n     * Cancels out the specified debt against the USDS contained in the Stability Pool (as far as possible)\\n     * and transfers the Trove's BNB collateral from ActivePool to StabilityPool.\\n     * Only called by liquidation functions in the TroveManager.\\n     */\\n    function offset(uint _debt, uint _coll) external;\\n\\n    /*\\n     * Returns the total amount of BNB held by the pool, accounted in an internal variable instead of `balance`,\\n     * to exclude edge cases like BNB received from a self-destruct.\\n     */\\n    function getBNB() external view returns (uint);\\n\\n    /*\\n     * Returns USDS held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\\n     */\\n    function getTotalUSDSDeposits() external view returns (uint);\\n\\n    /*\\n     * Calculates the BNB gain earned by the deposit since its last snapshots were taken.\\n     */\\n    function getDepositorBNBGain(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Calculate the SABLE gain earned by a deposit since its last snapshots were taken.\\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\\n     * which they made their deposit.\\n     */\\n    function getDepositorSABLEGain(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Return the SABLE gain earned by the front end.\\n     */\\n    function getFrontEndSABLEGain(address _frontEnd) external view returns (uint);\\n\\n    /*\\n     * Return the user's compounded deposit.\\n     */\\n    function getCompoundedUSDSDeposit(address _depositor) external view returns (uint);\\n\\n    /*\\n     * Return the front end's compounded stake.\\n     *\\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\\n     */\\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\\n\\n    function ownerTriggerIssuance() external;\\n\\n    /*\\n     * Fallback function\\n     * Only callable by Active Pool, it just accounts for BNB received\\n     * receive() external payable;\\n     */\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITroveManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ILiquityBase.sol\\\";\\nimport \\\"./IStabilityPool.sol\\\";\\nimport \\\"./IUSDSToken.sol\\\";\\nimport \\\"./ISABLEToken.sol\\\";\\nimport \\\"./ISableStakingV2.sol\\\";\\nimport \\\"./IOracleRateCalculation.sol\\\";\\nimport \\\"./ICollSurplusPool.sol\\\";\\nimport \\\"./ISortedTroves.sol\\\";\\nimport \\\"./ITroveHelper.sol\\\";\\nimport \\\"../Dependencies/LiquityBase.sol\\\";\\nimport \\\"../Dependencies/Ownable.sol\\\";\\nimport \\\"../Dependencies/CheckContract.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface ITroveManager is ILiquityBase {\\n    // --- Events ---\\n    event AddressesChanged(DependencyAddressParam param);\\n\\n    event Liquidation(\\n        uint _liquidatedDebt,\\n        uint _liquidatedColl,\\n        uint _collGasCompensation,\\n        uint _USDSGasCompensation\\n    );\\n    event Redemption(uint _attemptedUSDSAmount, uint _actualUSDSAmount, uint _BNBSent, uint _BNBFee);\\n    event TroveUpdated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        uint _stake,\\n        TroveManagerOperation _operation\\n    );\\n    event TroveLiquidated(\\n        address indexed _borrower,\\n        uint _debt,\\n        uint _coll,\\n        TroveManagerOperation _operation\\n    );\\n    event BaseRateUpdated(uint _baseRate);\\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\\n    event TotalStakesUpdated(uint _newTotalStakes);\\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\\n    event LTermsUpdated(uint _L_BNB, uint _L_USDSDebt);\\n    event TroveSnapshotsUpdated(uint _L_BNB, uint _L_USDSDebt);\\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\\n\\n    enum TroveManagerOperation {\\n        applyPendingRewards,\\n        liquidateInNormalMode,\\n        liquidateInRecoveryMode,\\n        redeemCollateral\\n    }\\n\\n    enum Status {\\n        nonExistent,\\n        active,\\n        closedByOwner,\\n        closedByLiquidation,\\n        closedByRedemption\\n    }\\n\\n    // Store the necessary data for a trove\\n    struct Trove {\\n        uint debt;\\n        uint coll;\\n        uint stake;\\n        Status status;\\n        uint128 arrayIndex;\\n    }\\n\\n    // Object containing the BNB and USDS snapshots for a given active trove\\n    struct RewardSnapshot {\\n        uint BNB;\\n        uint USDSDebt;\\n    }\\n\\n    /*\\n     * --- Variable container structs for liquidations ---\\n     *\\n     * These structs are used to hold, return and assign variables inside the liquidation functions,\\n     * in order to avoid the error: \\\"CompilerError: Stack too deep\\\".\\n     **/\\n\\n    struct LocalVariables_OuterLiquidationFunction {\\n        uint price;\\n        uint USDSInStabPool;\\n        bool recoveryModeAtStart;\\n        uint liquidatedDebt;\\n        uint liquidatedColl;\\n    }\\n\\n    struct LocalVariables_InnerSingleLiquidateFunction {\\n        uint collToLiquidate;\\n        uint pendingDebtReward;\\n        uint pendingCollReward;\\n    }\\n\\n    struct LocalVariables_LiquidationSequence {\\n        uint remainingUSDSInStabPool;\\n        uint i;\\n        uint ICR;\\n        address user;\\n        address firstUser;\\n        bool backToNormalMode;\\n        uint entireSystemDebt;\\n        uint entireSystemColl;\\n        uint MCR;\\n    }\\n\\n    struct LiquidationValues {\\n        uint entireTroveDebt;\\n        uint entireTroveColl;\\n        uint collGasCompensation;\\n        uint USDSGasCompensation;\\n        uint debtToOffset;\\n        uint collToSendToSP;\\n        uint debtToRedistribute;\\n        uint collToRedistribute;\\n        uint collSurplus;\\n    }\\n\\n    struct LiquidationTotals {\\n        uint totalCollInSequence;\\n        uint totalDebtInSequence;\\n        uint totalCollGasCompensation;\\n        uint totalUSDSGasCompensation;\\n        uint totalDebtToOffset;\\n        uint totalCollToSendToSP;\\n        uint totalDebtToRedistribute;\\n        uint totalCollToRedistribute;\\n        uint totalCollSurplus;\\n    }\\n\\n    struct ContractsCache {\\n        IActivePool activePool;\\n        IDefaultPool defaultPool;\\n        IUSDSToken usdsToken;\\n        ISableStakingV2 sableStaking;\\n        ISortedTroves sortedTroves;\\n        ICollSurplusPool collSurplusPool;\\n        address gasPoolAddress;\\n    }\\n    // --- Variable container structs for redemptions ---\\n\\n    struct RedemptionTotals {\\n        uint remainingUSDS;\\n        uint totalUSDSToRedeem;\\n        uint totalBNBDrawn;\\n        uint BNBFee;\\n        uint BNBToSendToRedeemer;\\n        uint decayedBaseRate;\\n        uint price;\\n        uint totalUSDSSupplyAtStart;\\n    }\\n\\n    struct SingleRedemptionValues {\\n        uint USDSLot;\\n        uint BNBLot;\\n        bool cancelledPartial;\\n    }\\n\\n    // Struct to avoid stack too deep\\n    struct LocalVariables_RedeemCollateralFromTrove {\\n        uint usdsGasCompensation;\\n        uint minNetDebt;\\n        uint newDebt;\\n        uint newColl;\\n    }\\n\\n    struct RedeemCollateralFromTroveParam {\\n        ContractsCache contractsCache;\\n        address borrower;\\n        uint maxUSDSamount;\\n        uint price;\\n        address upperPartialRedemptionHint;\\n        address lowerPartialRedemptionHint;\\n        uint partialRedemptionHintNICR;\\n    }\\n    \\n    struct DependencyAddressParam {\\n        address borrowerOperationsAddress;\\n        address activePoolAddress;\\n        address defaultPoolAddress;\\n        address stabilityPoolAddress;\\n        address gasPoolAddress;\\n        address collSurplusPoolAddress;\\n        address priceFeedAddress;\\n        address usdsTokenAddress;\\n        address sortedTrovesAddress;\\n        address sableTokenAddress;\\n        address sableStakingAddress;\\n        address systemStateAddress;\\n        address oracleRateCalcAddress;\\n        address troveHelperAddress;\\n    }\\n\\n    // --- Functions ---\\n\\n    function setAddresses(DependencyAddressParam memory param) external;\\n\\n    function stabilityPool() external view returns (IStabilityPool);\\n\\n    function usdsToken() external view returns (IUSDSToken);\\n\\n    function sableToken() external view returns (ISABLEToken);\\n\\n    function sableStaking() external view returns (ISableStakingV2);\\n\\n    function oracleRateCalc() external view returns (IOracleRateCalculation);\\n\\n    function getTroveOwnersCount() external view returns (uint);\\n\\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\\n\\n    function getNominalICR(address _borrower) external view returns (uint);\\n\\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\\n\\n    function liquidate(\\n        address _borrower,\\n        bytes[] calldata priceFeedUpdateData\\n    ) external;\\n\\n    function liquidateTroves(\\n        uint _n,\\n        bytes[] calldata priceFeedUpdateData\\n    ) external;\\n\\n    function batchLiquidateTroves(\\n        address[] calldata _troveArray,\\n        bytes[] calldata priceFeedUpdateData    \\n    ) external;\\n\\n    function redeemCollateral(\\n        uint _USDSAmount,\\n        address _firstRedemptionHint,\\n        address _upperPartialRedemptionHint,\\n        address _lowerPartialRedemptionHint,\\n        uint _partialRedemptionHintNICR,\\n        uint _maxIterations,\\n        uint _maxFee,\\n        bytes[] calldata priceFeedUpdateData\\n    ) external;\\n\\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\\n\\n    function updateTroveRewardSnapshots(address _borrower) external;\\n\\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\\n\\n    function applyPendingRewards(address _borrower) external;\\n\\n    function getPendingBNBReward(address _borrower) external view returns (uint);\\n\\n    function getPendingUSDSDebtReward(address _borrower) external view returns (uint);\\n\\n    function hasPendingRewards(address _borrower) external view returns (bool);\\n\\n    function getEntireDebtAndColl(\\n        address _borrower\\n    )\\n        external\\n        view\\n        returns (uint debt, uint coll, uint pendingUSDSDebtReward, uint pendingBNBReward);\\n\\n    function closeTrove(address _borrower) external;\\n\\n    function removeStake(address _borrower) external;\\n\\n    function getRedemptionRate(uint _oracleRate) external view returns (uint);\\n\\n    function getRedemptionRateWithDecay(uint _oracleRate) external view returns (uint);\\n\\n    function getRedemptionFeeWithDecay(uint _BNBDrawn, uint _oracleRate) external view returns (uint);\\n\\n    function getBorrowingRate(uint _oracleRate) external view returns (uint);\\n\\n    function getBorrowingRateWithDecay(uint _oracleRate) external view returns (uint);\\n\\n    function getBorrowingFee(uint USDSDebt, uint _oracleRate) external view returns (uint);\\n\\n    function getBorrowingFeeWithDecay(uint _USDSDebt, uint _oracleRate) external view returns (uint);\\n\\n    function decayBaseRateFromBorrowing() external;\\n\\n    function getTroveStatus(address _borrower) external view returns (uint);\\n\\n    function getTroveStake(address _borrower) external view returns (uint);\\n\\n    function getTroveDebt(address _borrower) external view returns (uint);\\n\\n    function getTroveColl(address _borrower) external view returns (uint);\\n\\n    function setTroveStatus(address _borrower, uint num) external;\\n\\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\\n\\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint);\\n\\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint);\\n\\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint);\\n\\n    function getTCR(uint _price) external view returns (uint);\\n\\n    function checkRecoveryMode(uint _price) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IUSDSToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"../Dependencies/IERC20.sol\\\";\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\n\\ninterface IUSDSToken is IERC20, IERC2612 { \\n    \\n    // --- Events ---\\n\\n    event TroveManagerAddressChanged(address _troveManagerAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n\\n    event USDSTokenBalanceUpdated(address _user, uint _amount);\\n\\n    // --- Functions ---\\n\\n    function mint(address _account, uint256 _amount) external;\\n\\n    function burn(address _account, uint256 _amount) external;\\n\\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\\n\\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISortedTroves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\n// Common interface for the SortedTroves Doubly Linked List.\\ninterface ISortedTroves {\\n\\n    // --- Events ---\\n    \\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\\n    event NodeAdded(address _id, uint _NICR);\\n    event NodeRemoved(address _id);\\n\\n    struct SortedTrovesInsertParam {\\n        address id;\\n        uint256 newNICR;\\n        address prevId;\\n        address nextId;\\n    }\\n\\n    // --- Functions ---\\n    \\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\\n\\n    function insert(SortedTrovesInsertParam memory param) external;\\n\\n    function remove(address _id) external;\\n\\n    function reInsert(SortedTrovesInsertParam memory param) external;\\n\\n    function contains(address _id) external view returns (bool);\\n\\n    function isFull() external view returns (bool);\\n\\n    function isEmpty() external view returns (bool);\\n\\n    function getSize() external view returns (uint256);\\n\\n    function getMaxSize() external view returns (uint256);\\n\\n    function getFirst() external view returns (address);\\n\\n    function getLast() external view returns (address);\\n\\n    function getNext(address _id) external view returns (address);\\n\\n    function getPrev(address _id) external view returns (address);\\n\\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\\n\\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ICommunityIssuance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\ninterface ICommunityIssuance { \\n    \\n    // --- Events ---\\n    \\n    event SABLETokenAddressSet(address _sableTokenAddress);\\n    event StabilityPoolAddressSet(address _stabilityPoolAddress);\\n    event RewardPerSecUpdated(uint256 _newRewardPerSec);\\n\\n    // --- Functions ---\\n\\n    function setParams\\n    (\\n        address _sableTokenAddress, \\n        address _stabilityPoolAddress,\\n        uint256 _latestRewardPerSec\\n    ) external;\\n\\n    function issueSABLE() external returns (uint);\\n\\n    function sendSABLE(address _account, uint _SABLEamount) external;\\n\\n    function balanceSABLE() external returns (uint);\\n\\n    function updateRewardPerSec(uint _newRewardPerSec) external;\\n\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/LiquityBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./BaseMath.sol\\\";\\nimport \\\"./LiquityMath.sol\\\";\\nimport \\\"../Interfaces/IActivePool.sol\\\";\\nimport \\\"../Interfaces/IDefaultPool.sol\\\";\\nimport \\\"../Interfaces/IPriceFeed.sol\\\";\\nimport \\\"../Interfaces/ILiquityBase.sol\\\";\\nimport \\\"../Interfaces/ISystemState.sol\\\";\\n\\n/*\\n * Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\\n * common functions.\\n */\\ncontract LiquityBase is BaseMath, ILiquityBase {\\n    using SafeMath for uint;\\n\\n    uint public constant _100pct = 1000000000000000000; // 1e18 == 100%\\n\\n    uint public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\\n\\n    address public timeLock;\\n\\n    IActivePool public activePool;\\n\\n    IDefaultPool public defaultPool;\\n\\n    IPriceFeed public override priceFeed;\\n\\n    ISystemState public systemState;\\n\\n    // --- Gas compensation functions ---\\n\\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\\n    function _getCompositeDebt(uint _debt) internal view returns (uint) {\\n        uint USDS_GAS_COMPENSATION = systemState.getUSDSGasCompensation();\\n        return _debt.add(USDS_GAS_COMPENSATION);\\n    }\\n\\n    function _getNetDebt(uint _debt) internal view returns (uint) {\\n        uint USDS_GAS_COMPENSATION = systemState.getUSDSGasCompensation();\\n        return _debt.sub(USDS_GAS_COMPENSATION);\\n    }\\n\\n    // Return the amount of BNB to be drawn from a trove's collateral and sent as gas compensation.\\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\\n        return _entireColl / PERCENT_DIVISOR;\\n    }\\n\\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\\n        uint activeColl = activePool.getBNB();\\n        uint liquidatedColl = defaultPool.getBNB();\\n\\n        return activeColl.add(liquidatedColl);\\n    }\\n\\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\\n        uint activeDebt = activePool.getUSDSDebt();\\n        uint closedDebt = defaultPool.getUSDSDebt();\\n\\n        return activeDebt.add(closedDebt);\\n    }\\n\\n    function _getTCR(uint _price) internal view returns (uint TCR) {\\n        uint entireSystemColl = getEntireSystemColl();\\n        uint entireSystemDebt = getEntireSystemDebt();\\n\\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\\n\\n        return TCR;\\n    }\\n\\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\\n        uint TCR = _getTCR(_price);\\n        uint CCR = systemState.getCCR();\\n        return TCR < CCR;\\n    }\\n\\n    function _requireUserAcceptsFee(uint _fee, uint _value, uint _maxFeePercentage) internal pure {\\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_value);\\n        require(feePercentage <= _maxFeePercentage, \\\"Fee exceeded provided maximum\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * Based on OpenZeppelin's SafeMath:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\n *\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/LiquitySafeMath128.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n// uint128 addition and subtraction, with overflow protection.\\n\\nlibrary LiquitySafeMath128 {\\n    function add(uint128 a, uint128 b) internal pure returns (uint128) {\\n        uint128 c = a + b;\\n        require(c >= a, \\\"LiquitySafeMath128: addition overflow\\\");\\n\\n        return c;\\n    }\\n   \\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\\n        require(b <= a, \\\"LiquitySafeMath128: subtraction overflow\\\");\\n        uint128 c = a - b;\\n\\n        return c;\\n    }\\n}\"\r\n    },\r\n    \"contracts/Dependencies/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * Based on OpenZeppelin's Ownable contract:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n *\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     *\\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\\n     * Make sure you check it before calling it.\\n     */\\n    function _renounceOwnership() internal {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/CheckContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n\\ncontract CheckContract {\\n    /**\\n     * Check that the account is an already deployed non-destroyed contract.\\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\\n     */\\n    function checkContract(address _account) internal view {\\n        require(_account != address(0), \\\"0addr\\\");\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(_account) }\\n        require(size > 0, \\\"0code\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n// Buidler's helper contract for console logging\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction log() internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t\\tignored;\\n\\t}\\tfunction logInt(int p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logByte(byte p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(byte)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t(bool ignored, ) = CONSOLE_ADDRESS.staticcall(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t\\tignored;\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IActivePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./IPool.sol\\\";\\n\\n\\ninterface IActivePool is IPool {\\n    // --- Events ---\\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolUSDSDebtUpdated(uint _USDSDebt);\\n    event ActivePoolBNBBalanceUpdated(uint _BNB);\\n\\n    // --- Functions ---\\n    function sendBNB(address _account, uint _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n// Common interface for the Pools.\\ninterface IPool {\\n    \\n    // --- Events ---\\n    \\n    event BNBBalanceUpdated(uint _newBalance);\\n    event USDSBalanceUpdated(uint _newBalance);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\\n    event EtherSent(address _to, uint _amount);\\n\\n    // --- Functions ---\\n    \\n    function getBNB() external view returns (uint);\\n\\n    function getUSDSDebt() external view returns (uint);\\n\\n    function increaseUSDSDebt(uint _amount) external;\\n\\n    function decreaseUSDSDebt(uint _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILiquityBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./IPriceFeed.sol\\\";\\n\\n\\ninterface ILiquityBase {\\n    function priceFeed() external view returns (IPriceFeed);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISABLEToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"../Dependencies/IERC20.sol\\\";\\nimport \\\"../Dependencies/IERC2612.sol\\\";\\n\\ninterface ISABLEToken is IERC20, IERC2612 { \\n   \\n    // --- Events ---\\n    \\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\\n    event SABLEStakingAddressSet(address _sableStakingAddress);\\n\\n    // --- Functions ---\\n    \\n    function getDeploymentStartTime() external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISableStakingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\ninterface ISableStakingV2 {\\n\\n    // --- Events --\\n    \\n    event SABLETokenAddressSet(address _sableTokenAddress);\\n    event USDSTokenAddressSet(address _usdsTokenAddress);\\n    event TroveManagerAddressSet(address _troveManager);\\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\\n    event SableRewarderAddressSet(address _sableRewarderAddress);\\n    event ActivePoolAddressSet(address _activePoolAddress);\\n\\n    event StakeChanged(address indexed staker, uint newStake);\\n    event StakingGainsWithdrawn(address indexed staker, uint USDSGain, uint BNBGain, uint SABLEGain);\\n    event F_BNBUpdated(uint _F_BNB);\\n    event F_USDSUpdated(uint _F_USDS);\\n    event F_SABLEUpdated(uint _F_SABLE);\\n    event TotalSableLPStakedUpdated(uint _totalSableLPStaked);\\n    event EtherSent(address _account, uint _amount);\\n    event StakerSnapshotsUpdated(address _staker, uint _F_BNB, uint _F_USDS, uint _F_SABLE);\\n\\n    event SableLPTokenAddressSet(address _sableLPTokenAddress);\\n\\n    // --- Functions ---\\n\\n    function setAddresses\\n    (\\n        address _sableTokenAddress,\\n        address _usdsTokenAddress,\\n        address _troveManagerAddress, \\n        address _borrowerOperationsAddress,\\n        address _sableRewarderAddress,\\n        address _activePoolAddress\\n    )  external;\\n\\n    function setSableLPAddress(address _sableLPTokenAddress) external;\\n\\n    function stake(uint _SABLEamount) external;\\n\\n    function unstake(uint _SABLEamount) external;\\n\\n    function increaseF_BNB(uint _BNBFee) external; \\n\\n    function increaseF_USDS(uint _USDSFee) external;\\n\\n    function increaseF_SABLE(uint _SABLEGain) external;\\n\\n    function getPendingBNBGain(address _user) external view returns (uint);\\n\\n    function getPendingUSDSGain(address _user) external view returns (uint);\\n\\n    function getPendingSABLEGain(address _user) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IOracleRateCalculation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\ninterface IOracleRateCalculation {\\n    // --- Functions ---\\n\\n    function getOracleRate(\\n        bytes32 oracleKey, \\n        uint deviationPyth, \\n        uint publishTimePyth\\n    ) external view returns (uint);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ICollSurplusPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n\\ninterface ICollSurplusPool {\\n\\n    // --- Events ---\\n    \\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\\n\\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\\n    event EtherSent(address _to, uint _amount);\\n\\n    // --- Contract setters ---\\n\\n    function setAddresses(\\n        address _borrowerOperationsAddress,\\n        address _troveManagerAddress,\\n        address _activePoolAddress\\n    ) external;\\n\\n    function getBNB() external view returns (uint);\\n\\n    function getCollateral(address _account) external view returns (uint);\\n\\n    function accountSurplus(address _account, uint _amount) external;\\n\\n    function claimColl(address _account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ITroveHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ILiquityBase.sol\\\";\\nimport \\\"./IStabilityPool.sol\\\";\\nimport \\\"./IUSDSToken.sol\\\";\\nimport \\\"./ISABLEToken.sol\\\";\\nimport \\\"./ISableStakingV2.sol\\\";\\nimport \\\"./IOracleRateCalculation.sol\\\";\\nimport \\\"./ICollSurplusPool.sol\\\";\\nimport \\\"./ISortedTroves.sol\\\";\\nimport \\\"./ITroveManager.sol\\\";\\nimport \\\"../Dependencies/LiquityBase.sol\\\";\\nimport \\\"../Dependencies/Ownable.sol\\\";\\nimport \\\"../Dependencies/CheckContract.sol\\\";\\n\\n// Common interface for the Trove Manager.\\ninterface ITroveHelper {\\n    function setAddresses(\\n        address _troveManagerAddress,\\n        address _systemStateAddress,\\n        address _sortedTrovesAddress,\\n        address _sableTokenAddress,\\n        address _activePoolAddress,\\n        address _defaultPoolAddress\\n    ) external;\\n\\n    function getCappedOffsetVals(\\n        uint _entireTroveDebt,\\n        uint _entireTroveColl,\\n        uint _price\\n    ) external view returns (ITroveManager.LiquidationValues memory singleLiquidation);\\n\\n    function isValidFirstRedemptionHint(\\n        ISortedTroves _sortedTroves,\\n        address _firstRedemptionHint,\\n        uint _price\\n    ) external view returns (bool);\\n\\n    function requireValidMaxFeePercentage(uint _maxFeePercentage) external view;\\n\\n    function requireAfterBootstrapPeriod() external view;\\n\\n    function requireUSDSBalanceCoversRedemption(\\n        IUSDSToken _usdsToken,\\n        address _redeemer,\\n        uint _amount\\n    ) external view;\\n\\n    function requireMoreThanOneTroveInSystem(uint TroveOwnersArrayLength) external view;\\n\\n    function requireAmountGreaterThanZero(uint _amount) external view;\\n\\n    function requireTCRoverMCR(uint _price) external view;\\n\\n    function checkPotentialRecoveryMode(\\n        uint _entireSystemColl,\\n        uint _entireSystemDebt,\\n        uint _price\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IPyth.sol\\\";\\n\\ninterface IPriceFeed {\\n\\n    // --- Events ---\\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\\n\\n    struct FetchPriceResult {\\n        uint price;\\n        bytes32 oracleKey;\\n        uint deviationPyth;\\n        uint publishTimePyth;\\n    }\\n   \\n    // --- Function ---\\n    // return price, oracleKey, deviationPyth, publishTimePyth\\n    // if get price from Chainlink, deviationPyth = publishTimePyth = 0\\n    function fetchPrice(bytes[] calldata priceFeedUpdateData) external returns (FetchPriceResult memory);\\n\\n    function pyth() external view returns (IPyth);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPyth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./PythStructs.sol\\\";\\nimport \\\"./IPythEvents.sol\\\";\\n\\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\\n/// @author Pyth Data Association\\ninterface IPyth is IPythEvents {\\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\\n\\n    /// @notice Returns the price and confidence interval.\\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPrice(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\\n    /// @dev Reverts if the EMA price is not available.\\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPrice(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price of a price feed without any sanity checks.\\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\\n    /// However, if the price is not recent this function returns the latest available price.\\n    ///\\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\\n    /// the returned price is recent or useful for any particular application.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\\n    /// of the current time.\\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Update price feeds with given update messages.\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    /// Prices will be updated if they are more recent than the current stored prices.\\n    /// The call will succeed even if the update is not the most recent.\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\\n\\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\\n    ///\\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\\n    function updatePriceFeedsIfNecessary(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64[] calldata publishTimes\\n    ) external payable;\\n\\n    /// @notice Returns the required fee to update an array of price updates.\\n    /// @param updateData Array of price update data.\\n    /// @return feeAmount The required fee in Wei.\\n    function getUpdateFee(\\n        bytes[] calldata updateData\\n    ) external view returns (uint feeAmount);\\n\\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\\n    /// within `minPublishTime` and `maxPublishTime`.\\n    ///\\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdates(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/PythStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.6.11;\\n\\ncontract PythStructs {\\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\\n    //\\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\\n    // Both the price and confidence are stored in a fixed-point numeric representation,\\n    // `x * (10^expo)`, where `expo` is the exponent.\\n    //\\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\\n    // to how this price safely.\\n    struct Price {\\n        // Price\\n        int64 price;\\n        // Confidence interval around the price\\n        uint64 conf;\\n        // Price exponent\\n        int32 expo;\\n        // Unix timestamp describing when the price was published\\n        uint publishTime;\\n    }\\n\\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\\n    struct PriceFeed {\\n        // The price ID.\\n        bytes32 id;\\n        // Latest available price\\n        Price price;\\n        // Latest available exponentially-weighted moving average price\\n        Price emaPrice;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IPythEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n/// @title IPythEvents contains the events that Pyth contract emits.\\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\\ninterface IPythEvents {\\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\\n    /// @param id The Pyth Price Feed ID.\\n    /// @param publishTime Publish time of the given price update.\\n    /// @param price Price of the given price update.\\n    /// @param conf Confidence interval of the given price update.\\n    event PriceFeedUpdate(\\n        bytes32 indexed id,\\n        uint64 publishTime,\\n        int64 price,\\n        uint64 conf\\n    );\\n\\n    /// @dev Emitted when a batch price update is processed successfully.\\n    /// @param chainId ID of the source chain that the batch price update comes from.\\n    /// @param sequenceNumber Sequence number of the batch price update.\\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\\n}\"\r\n    },\r\n    \"contracts/Dependencies/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    \\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/Dependencies/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n * \\n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 amount, \\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    \\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     *\\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \\n     * a value in the near future. The deadline argument can be set to uint(-1) to \\n     * create Permits that effectively never expire.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n    \\n    function version() external view returns (string memory);\\n    function permitTypeHash() external view returns (bytes32);\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/BaseMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n\\ncontract BaseMath {\\n    uint constant public DECIMAL_PRECISION = 1e18;\\n}\\n\"\r\n    },\r\n    \"contracts/Dependencies/LiquityMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./console.sol\\\";\\n\\nlibrary LiquityMath {\\n    using SafeMath for uint;\\n\\n    uint internal constant DECIMAL_PRECISION = 1e18;\\n\\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\\n     *\\n     * - Making it \u201ctoo high\u201d could lead to overflows.\\n     * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division. \\n     *\\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 BNB,\\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\\n     *\\n     */\\n    uint internal constant NICR_PRECISION = 1e20;\\n\\n    function _min(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a < _b) ? _a : _b;\\n    }\\n\\n    function _max(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a : _b;\\n    }\\n\\n    /* \\n    * Multiply two decimal numbers and use normal rounding rules:\\n    * -round product up if 19'th mantissa digit >= 5\\n    * -round product down if 19'th mantissa digit < 5\\n    *\\n    * Used only inside the exponentiation, _decPow().\\n    */\\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\\n        uint prod_xy = x.mul(y);\\n\\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\\n    }\\n\\n    /* \\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\\n    * \\n    * Uses the efficient \\\"exponentiation by squaring\\\" algorithm. O(log(n)) complexity. \\n    * \\n    * Called by two functions that represent time in units of minutes:\\n    * 1) TroveManager._calcDecayedBaseRate\\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \\n    * \\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\\n    * \\\"minutes in 1000 years\\\": 60 * 24 * 365 * 1000\\n    * \\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\\n    * negligibly different from just passing the cap, since: \\n    *\\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\\n    */\\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\\n       \\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\\n    \\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\\n\\n        uint y = DECIMAL_PRECISION;\\n        uint x = _base;\\n        uint n = _minutes;\\n\\n        // Exponentiation-by-squaring\\n        while (n > 1) {\\n            if (n % 2 == 0) {\\n                x = decMul(x, x);\\n                n = n.div(2);\\n            } else { // if (n % 2 != 0)\\n                y = decMul(x, y);\\n                x = decMul(x, x);\\n                n = (n.sub(1)).div(2);\\n            }\\n        }\\n\\n        return decMul(x, y);\\n  }\\n\\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\\n    }\\n\\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            return _coll.mul(NICR_PRECISION).div(_debt);\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else { // if (_debt == 0)\\n            return 2**256 - 1;\\n        }\\n    }\\n\\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\\n        if (_debt > 0) {\\n            uint newCollRatio = _coll.mul(_price).div(_debt);\\n\\n            return newCollRatio;\\n        }\\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \\\"infinite\\\" CR.\\n        else { // if (_debt == 0)\\n            return 2**256 - 1; \\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IDefaultPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"./IPool.sol\\\";\\n\\n\\ninterface IDefaultPool is IPool {\\n    // --- Events ---\\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\\n    event DefaultPoolUSDSDebtUpdated(uint _USDSDebt);\\n    event DefaultPoolBNBBalanceUpdated(uint _BNB);\\n\\n    // --- Functions ---\\n    function sendBNBToActivePool(uint _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ISystemState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.11;\\n\\ninterface ISystemState {\\n    function setUSDSGasCompensation(uint _value) external;\\n\\n    function setBorrowingFeeFloor(uint _value) external;\\n\\n    function setRedemptionFeeFloor(uint _value) external;\\n\\n    function setMinNetDebt(uint _value) external;\\n\\n    function setMCR(uint _value) external;\\n\\n    function setCCR(uint _value) external;\\n\\n    function getUSDSGasCompensation() external view returns (uint);\\n\\n    function getBorrowingFeeFloor() external view returns (uint);\\n\\n    function getRedemptionFeeFloor() external view returns (uint);\\n\\n    function getMinNetDebt() external view returns (uint);\\n\\n    function getMCR() external view returns (uint);\\n\\n    function getCCR() external view returns (uint);\\n\\n    event USDSGasCompensationChanged(uint _o, uint _n);\\n    event BorrowingFeeFloorChanged(uint _o, uint _n);\\n    event RedemptionFeeFloorChanged(uint _o, uint _n);\\n    event MinNetDebtChanged(uint _o, uint _n);\\n    event MCR_Changed(uint _o, uint _n);\\n    event CCR_Changed(uint _o, uint _n);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newActivePoolAddress\",\"type\":\"address\"}],\"name\":\"ActivePoolAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_BNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_USDSLoss\",\"type\":\"uint256\"}],\"name\":\"BNBGainWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newBorrowerOperationsAddress\",\"type\":\"address\"}],\"name\":\"BorrowerOperationsAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newCommunityIssuanceAddress\",\"type\":\"address\"}],\"name\":\"CommunityIssuanceAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newDefaultPoolAddress\",\"type\":\"address\"}],\"name\":\"DefaultPoolAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_P\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_S\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_G\",\"type\":\"uint256\"}],\"name\":\"DepositSnapshotUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_currentEpoch\",\"type\":\"uint128\"}],\"name\":\"EpochUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EtherSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_kickbackRate\",\"type\":\"uint256\"}],\"name\":\"FrontEndRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_P\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_G\",\"type\":\"uint256\"}],\"name\":\"FrontEndSnapshotUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newFrontEndStake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"FrontEndStakeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"}],\"name\":\"FrontEndTagSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_G\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_epoch\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_scale\",\"type\":\"uint128\"}],\"name\":\"G_Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_P\",\"type\":\"uint256\"}],\"name\":\"P_Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newPriceFeedAddress\",\"type\":\"address\"}],\"name\":\"PriceFeedAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_SABLE\",\"type\":\"uint256\"}],\"name\":\"SABLEPaidToDepositor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_SABLE\",\"type\":\"uint256\"}],\"name\":\"SABLEPaidToFrontEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_S\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_epoch\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_scale\",\"type\":\"uint128\"}],\"name\":\"S_Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_currentScale\",\"type\":\"uint128\"}],\"name\":\"ScaleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newSortedTrovesAddress\",\"type\":\"address\"}],\"name\":\"SortedTrovesAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"StabilityPoolBNBBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newBalance\",\"type\":\"uint256\"}],\"name\":\"StabilityPoolUSDSBalanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newSystemStateAddress\",\"type\":\"address\"}],\"name\":\"SystemStateAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newTroveManagerAddress\",\"type\":\"address\"}],\"name\":\"TroveManagerAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newUSDSTokenAddress\",\"type\":\"address\"}],\"name\":\"USDSTokenAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newDeposit\",\"type\":\"uint256\"}],\"name\":\"UserDepositChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"P\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SCALE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_100pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activePool\",\"outputs\":[{\"internalType\":\"contract IActivePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowerOperations\",\"outputs\":[{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityIssuance\",\"outputs\":[{\"internalType\":\"contract ICommunityIssuance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentScale\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPool\",\"outputs\":[{\"internalType\":\"contract IDefaultPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositSnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"S\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"P\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"scale\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"frontEndTag\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"epochToScaleToG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"epochToScaleToSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frontEndSnapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"S\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"P\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"scale\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frontEndStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frontEnds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"kickbackRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"}],\"name\":\"getCompoundedFrontEndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getCompoundedUSDSDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getDepositorBNBGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getDepositorSABLEGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntireSystemColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemColl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntireSystemDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_frontEnd\",\"type\":\"address\"}],\"name\":\"getFrontEndSABLEGain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalUSDSDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBNBError_Offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSABLEError\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUSDSLossError_Offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_debtToOffset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collToAdd\",\"type\":\"uint256\"}],\"name\":\"offset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerTriggerIssuance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_frontEndTag\",\"type\":\"address\"}],\"name\":\"provideToSP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_kickbackRate\",\"type\":\"uint256\"}],\"name\":\"registerFrontEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrowerOperationsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_troveManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_activePoolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdsTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sortedTrovesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceFeedAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_communityIssuanceAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_systemStateAddress\",\"type\":\"address\"}],\"name\":\"setParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemState\",\"outputs\":[{\"internalType\":\"contract ISystemState\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdsToken\",\"outputs\":[{\"internalType\":\"contract IUSDSToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lowerHint\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"priceFeedUpdateData\",\"type\":\"bytes[]\"}],\"name\":\"withdrawBNBGainToTrove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"priceFeedUpdateData\",\"type\":\"bytes[]\"}],\"name\":\"withdrawFromSP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StabilityPool", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}