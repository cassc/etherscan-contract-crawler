{"SourceCode": "pragma solidity ^0.5.17;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath \r\n{\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n   // event Approval(address indexed owner, address indexed spender, uint value);\r\n   // event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ncontract PuzzleWeb3 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name = \"Puzzle Web3\";\r\n    string public symbol = \"PUE\";\r\n    uint256 constant public decimals = 18;\r\n    uint256 constant internal dividendFee = 10;\r\n    uint256 constant internal tokenPriceInitial = 1e18;\r\n    uint256 constant internal tokenPriceIncremental = 0.00001e18;\r\n    uint256 internal tokenSupply = 0;\r\n    uint256 internal profitPerShare =0;\r\n\r\n    mapping(address => uint256) internal tokenBalances;\r\n    mapping(address => int256) internal payOuts;\r\n\r\n    //usdt contract\r\n    IERC20 public usdtToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n\r\n\r\n    event TokenPurchase(address userAddress, uint256 usdtAmount, uint256 receivedTokens, address toAddress);\r\n    event TokenSell(address userAddress, uint256 tokenAmount, uint256 receivedUsdt, address toAddress);       \r\n    event WithdrawDividends(address userAddress, uint256 dividend);\r\n    event Transfer(address fromAddress, address toAddress, uint256 tokenAmount);\r\n\r\n\r\n    function tokenBalanceOf(address userAddress) public view returns(uint256)\r\n    {\r\n        return tokenBalances[userAddress];\r\n    }\r\n\r\n    function totalSupply() public view returns(uint256)\r\n    {\r\n        return tokenSupply;\r\n    }\r\n\r\n    //usdt\r\n    function dividendsOf(address userAddress) public view returns(uint256)\r\n    {\r\n        return (uint256)((int256)(profitPerShare.mul(tokenBalances[userAddress])) - payOuts[userAddress]) / 1e18;\r\n    }\r\n\r\n\r\n    function withdrawDividends() public\r\n    {\r\n        require(dividendsOf(msg.sender) > 0, \"Insufficient dividends\");\r\n\r\n        address var_customerAddress = msg.sender;\r\n        uint256 var_dividends = dividendsOf(var_customerAddress); \r\n\r\n        payOuts[var_customerAddress] += (int256)(var_dividends * 1e18);\r\n\r\n        //send usdt\r\n        usdtToken.transfer(msg.sender, var_dividends);\r\n\r\n        emit WithdrawDividends(var_customerAddress, var_dividends);\r\n    }\r\n\r\n    function getSellPrice() public view returns(uint256)\r\n    {\r\n        if(tokenSupply == 0)\r\n        {\r\n            return tokenPriceInitial - tokenPriceIncremental;\r\n        } \r\n        else \r\n        {\r\n            uint256 var_usdt = tokensToUsdt(1e18);\r\n            uint256 var_dividends = SafeMath.div(var_usdt, dividendFee);\r\n            uint256 var_taxedUsdt = SafeMath.sub(var_usdt, var_dividends);\r\n            return var_taxedUsdt;\r\n        }\r\n    }\r\n    \r\n    \r\n    function getBuyPrice() public view returns(uint256)\r\n    {\r\n        if(tokenSupply == 0)\r\n        {\r\n            return tokenPriceInitial + tokenPriceIncremental;\r\n        } \r\n        else\r\n        {\r\n            uint256 var_usdt = tokensToUsdt(1e18);\r\n            uint256 var_dividends = SafeMath.div(var_usdt, dividendFee);\r\n            uint256 var_taxedUsdt = SafeMath.sub(var_usdt, var_dividends);\r\n            return var_taxedUsdt;\r\n        }\r\n    }\r\n\r\n\r\n    function transfer(address toAddress, uint256 tokenAmount) public returns(bool)\r\n    {\r\n        require(tokenAmount < tokenBalances[msg.sender], \"Insufficient tokenAmount\");\r\n        require(toAddress != address(0), \"bad toAddress\");\r\n        \r\n        address var_customerAddress = msg.sender;\r\n        uint256 var_Fee = tokenAmount.div(dividendFee);\r\n        uint256 var_taxedTokens = tokenAmount.sub(var_Fee);\r\n        uint256 var_dividends = tokensToUsdt(var_Fee);\r\n  \r\n        tokenSupply = tokenSupply.sub(var_Fee);\r\n    \r\n        tokenBalances[var_customerAddress] = tokenBalances[var_customerAddress].sub(tokenAmount);\r\n       \r\n        tokenBalances[toAddress] = tokenBalances[toAddress].add(var_taxedTokens);\r\n        \r\n        payOuts[var_customerAddress] -= (int256)(profitPerShare * tokenAmount);\r\n        payOuts[toAddress] += (int256)(profitPerShare * var_taxedTokens);\r\n        \r\n        profitPerShare = profitPerShare.add(var_dividends.mul(1e18).div(tokenSupply));\r\n        \r\n        emit Transfer(var_customerAddress, toAddress, tokenAmount);\r\n        return true;\r\n    }\r\n\r\n    function buy(uint256 usdtAmount, address toAddress) public returns(uint256)\r\n    {\r\n        require(usdtAmount > 0 && toAddress != address(0), \"bad input\");\r\n        require(usdtToken.balanceOf(msg.sender) >= usdtAmount, \"Insufficient USDT balance\");\r\n\r\n        uint256 tokenAmount = purchaseTokens(usdtAmount, toAddress);\r\n        return tokenAmount;\r\n    }\r\n\r\n    function sell(uint256 tokenAmount) public returns(uint256)\r\n    {\r\n        return sell2(tokenAmount, msg.sender);\r\n    }\r\n\r\n    function sell2(uint256 tokenAmount, address toAddress) public returns(uint256)\r\n    {\r\n        require(tokenAmount > 0 && tokenAmount < tokenBalances[msg.sender], \"Insufficient token balance\");\r\n        require(toAddress != address(0), \"bad toAddress\");\r\n\r\n        address var_customerAddress = msg.sender;\r\n        uint256 var_usdtAmount = tokensToUsdt(tokenAmount);\r\n        uint256 var_dividends = SafeMath.div(var_usdtAmount, dividendFee);\r\n        uint256 var_taxedUsdt = SafeMath.sub(var_usdtAmount, var_dividends);\r\n\r\n        require(var_taxedUsdt > 0 && usdtToken.balanceOf(address(this)) > var_taxedUsdt, \"Insufficient USDT balance\");\r\n\r\n        tokenSupply = tokenSupply.sub(tokenAmount);\r\n        tokenBalances[var_customerAddress] = tokenBalances[var_customerAddress].sub(tokenAmount);\r\n        \r\n        payOuts[var_customerAddress] -= (int256)(profitPerShare * tokenAmount);\r\n   \r\n        if (tokenSupply > 0)\r\n        {\r\n            profitPerShare = profitPerShare.add(var_dividends.mul(1e18).div(tokenSupply));\r\n        }\r\n\r\n        //send usdt\r\n        usdtToken.transfer(toAddress, var_taxedUsdt);\r\n        \r\n        emit TokenSell(var_customerAddress, tokenAmount, var_taxedUsdt, toAddress);\r\n        return var_taxedUsdt;\r\n    }\r\n\r\n    function purchaseTokens(uint256 usdtAmount, address toAddress) internal returns(uint256)\r\n    {\r\n        address var_customerAddress = msg.sender;\r\n        uint256 var_free = usdtAmount.div(dividendFee);\r\n        uint256 var_taxedUsdt = usdtAmount.sub(var_free);\r\n        uint256 var_tokenAmount = usdtToTokens(var_taxedUsdt);\r\n        uint256 var_customerDividend; \r\n\r\n        require(var_tokenAmount > 0, \"bad var_tokenAmount\");\r\n\r\n        if(tokenSupply > 0)\r\n        {\r\n            tokenSupply = tokenSupply.add(var_tokenAmount);\r\n            profitPerShare = profitPerShare.add((var_free * 1e18) / tokenSupply);\r\n            \r\n            var_customerDividend = var_tokenAmount * ((var_free * 1e18) / tokenSupply);\r\n        } \r\n        else\r\n        {\r\n            tokenSupply = var_tokenAmount;\r\n            var_customerDividend = var_free * 1e18;\r\n        }\r\n\r\n        payOuts[toAddress] += (int256)(profitPerShare * var_tokenAmount - var_customerDividend);\r\n        \r\n        tokenBalances[toAddress] = tokenBalances[toAddress].add(var_tokenAmount);\r\n\r\n        usdtToken.transferFrom(var_customerAddress, address(this), usdtAmount);\r\n\r\n        emit TokenPurchase(var_customerAddress, usdtAmount, var_tokenAmount, toAddress);\r\n        return var_tokenAmount;\r\n    }\r\n\r\n\r\n\r\n    function usdtToTokens(uint256 usdtAmount) internal view returns(uint256)\r\n    {\r\n        uint256 var_tokenPriceInitial = tokenPriceInitial * 1e18;\r\n\r\n        uint256 var_tokensReceived =((SafeMath.sub((sqrt((var_tokenPriceInitial ** 2) +\r\n                          (2* (tokenPriceIncremental * 1e18) * (usdtAmount * 1e18))\r\n                          + (((tokenPriceIncremental) ** 2) * (tokenSupply ** 2))\r\n                          + (2*(tokenPriceIncremental) * var_tokenPriceInitial * tokenSupply))),\r\n                          var_tokenPriceInitial)) / tokenPriceIncremental) - tokenSupply;\r\n  \r\n        return var_tokensReceived;\r\n    }\r\n\r\n    function tokensToUsdt(uint256 tokenAmount) internal view returns(uint256)\r\n    {\r\n        uint256 var_tokens = (tokenAmount + 1e18);\r\n        uint256 var_tokenSupply = (tokenSupply + 1e18);\r\n\r\n        uint256 var_usdtReceived =\r\n        (\r\n            SafeMath.sub((((tokenPriceInitial +(tokenPriceIncremental * (var_tokenSupply / 1e18))\r\n                        ) - tokenPriceIncremental)*(var_tokens - 1e18)), \r\n                        (tokenPriceIncremental * ((var_tokens**2 - var_tokens) / 1e18)) / 2) / 1e18);\r\n\r\n        return var_usdtReceived;\r\n    }\r\n\r\n    function sqrt(uint x) internal pure returns (uint y)\r\n    {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedUsdt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"TokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dividend\",\"type\":\"uint256\"}],\"name\":\"WithdrawDividends\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"sell2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"tokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PuzzleWeb3", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://1c155bfd470cb47ebbb6669e614d327f2ccbc48604e7d74fd202ffb568674504"}