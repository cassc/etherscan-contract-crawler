{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-10-18\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n *Submitted for verification at BscScan.com on 2023-10-18\r\n*/\r\npragma solidity ^0.8.16;\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2023-10-18\r\n*/\r\n/**\r\n* @notice Contract is a inheritable smart contract that will add a \r\n* New modifier called onlyOwner available in the smart contract inherting it\r\n* \r\n* onlyOwner makes a function only callable from the Token owner\r\n*\r\n*/\r\ncontract Ownable {\r\n    // _owner is the owner of the Token\r\n    address private _owner;\r\n\r\n    /**\r\n    * Event OwnershipTransferred is used to log that a ownership change of the token has occured\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * Modifier\r\n    * We create our own function modifier called onlyOwner, it will Require the current owner to be \r\n    * the same as msg.sender\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only owner can call this function\");\r\n        // This _; is not a TYPO, It is important for the compiler;\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    /**\r\n    * @notice owner() returns the currently assigned owner of the Token\r\n    * \r\n     */\r\n    function owner() public view returns(address) {\r\n        return _owner;\r\n\r\n    }\r\n    /**\r\n    * @notice renounceOwnership will set the owner to zero address\r\n    * This will make the contract owner less, It will make ALL functions with\r\n    * onlyOwner no longer callable.\r\n    * There is no way of restoring the owner\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @notice transferOwnership will assign the {newOwner} as owner\r\n    *\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n    /**\r\n    * @notice _transferOwnership will assign the {newOwner} as owner\r\n    *\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n* @notice Stakeable is a contract who is ment to be inherited by other contract that wants Staking capabilities\r\n*/\r\ncontract Stakeable {\r\n\r\n\r\n    /**\r\n    * @notice Constructor since this contract is not ment to be used without inheritance\r\n    * push once to stakeholders for it to work proplerly\r\n     */\r\n    constructor() {\r\n        // This push is needed so we avoid index 0 causing bug of index-1\r\n        stakeholders.push();\r\n    }\r\n    /**\r\n     * @notice\r\n     * A stake struct is used to represent the way we store stakes, \r\n     * A Stake will contain the users address, the amount staked and a timestamp, \r\n     * Since which is when the stake was made\r\n     */\r\n    struct Stake{\r\n        address user;\r\n        uint256 amount;\r\n        uint256 from;\r\n        uint256 rate;\r\n        uint256 since;\r\n        // This claimable field is new and used to tell how big of a reward is currently available\r\n        uint256 claimable;\r\n    }\r\n    /**\r\n    * @notice Stakeholder is a staker that has active stakes\r\n     */\r\n    struct Stakeholder{\r\n        address user;\r\n        Stake[] address_stakes;\r\n        \r\n    }\r\n     /**\r\n     * @notice\r\n     * StakingSummary is a struct that is used to contain all stakes performed by a certain account\r\n     */ \r\n     struct StakingSummary{\r\n         uint256 total_amount;\r\n         Stake[] stakes;\r\n     }\r\n\r\n    /**\r\n    * @notice \r\n    *   This is a array where we store all Stakes that are performed on the Contract\r\n    *   The stakes for each address are stored at a certain index, the index can be found using the stakes mapping\r\n    */\r\n    Stakeholder[] internal stakeholders;\r\n    /**\r\n    * @notice \r\n    * stakes is used to keep track of the INDEX for the stakers in the stakes array\r\n     */\r\n    mapping(address => uint256) internal stakes;\r\n    /**\r\n    * @notice Staked event is triggered whenever a user stakes tokens, address is indexed to make it filterable\r\n     */\r\n     event Staked(address indexed user, uint256 amount,uint256 from,uint256 rate, uint256 index, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice\r\n      rewardPerDay is 1000 because it is used to represent 0.001, since we only use integer numbers\r\n      This will give users 0.1% reward for each staked token / H\r\n     */\r\n    uint256 internal rewardPerDay = 6000;\r\n\r\n\r\n    /**\r\n    * @notice _addStakeholder takes care of adding a stakeholder to the stakeholders array\r\n     */\r\n    function _addStakeholder(address staker) internal returns (uint256){\r\n        // Push a empty item to the Array to make space for our new stakeholder\r\n        stakeholders.push();\r\n        // Calculate the index of the last item in the array by Len-1\r\n        uint256 userIndex = stakeholders.length - 1;\r\n        // Assign the address to the new index\r\n        stakeholders[userIndex].user = staker;\r\n        // Add index to the stakeHolders\r\n        stakes[staker] = userIndex;\r\n        return userIndex; \r\n    }\r\n\r\n    /**\r\n    * @notice\r\n    * _Stake is used to make a stake for an sender. It will remove the amount staked from the stakers account and place those tokens inside a stake container\r\n    * StakeID \r\n    */\r\n    function _stake(uint256 _amount,uint256 _from,uint256 _rate) internal{\r\n        // Simple check so that user does not stake 0 \r\n        require(_amount > 0, \"Cannot stake nothing\");\r\n        \r\n\r\n        // Mappings in solidity creates all values, but empty, so we can just check the address\r\n        uint256 index = stakes[msg.sender];\r\n        // block.timestamp = timestamp of the current block in seconds since the epoch\r\n        uint256 timestamp = block.timestamp;\r\n        // See if the staker already has a staked index or if its the first time\r\n        if(index == 0){\r\n            // This stakeholder stakes for the first time\r\n            // We need to add him to the stakeHolders and also map it into the Index of the stakes\r\n            // The index returned will be the index of the stakeholder in the stakeholders array\r\n            index = _addStakeholder(msg.sender);\r\n        }\r\n\r\n        // Use the index to push a new Stake\r\n        // push a newly created Stake with the current block timestamp.\r\n        stakeholders[index].address_stakes.push(Stake(msg.sender, _amount,_from,_rate,timestamp,0));\r\n        // Emit an event that the stake has occured\r\n        emit Staked(msg.sender, _amount, _from,_rate,index,timestamp);\r\n    }\r\n\r\n    /**\r\n      * @notice\r\n      * calculateStakeReward is used to calculate how much a user should be rewarded for their stakes\r\n      * and the duration the stake has been active\r\n     */\r\n      function calculateStakeReward(Stake memory _current_stake) internal view returns(uint256){\r\nuint256 reward =0;\r\nif(_current_stake.from==0){\r\n            uint256 elapsed = ((block.timestamp - _current_stake.since) / 1 hours) ;\r\n            reward = ((_current_stake.rate/12/30/24) * 100 * _current_stake.amount) / 1e4;\r\n            reward *= elapsed;\r\n            return reward;\r\n       \r\n}\r\nif(_current_stake.from==1){\r\n\r\n uint256 elapsed = ((block.timestamp - _current_stake.since) / 1 days) ;\r\n            reward = ((_current_stake.rate/12/30) * 100 * _current_stake.amount) / 1e4;\r\n            reward *= elapsed;\r\n            return reward;\r\n     \r\n}\r\nif(_current_stake.from==2){\r\n uint256 elapsed = ((block.timestamp - _current_stake.since) / 30 days) ;\r\n         reward = ((_current_stake.rate/12) * 100 * _current_stake.amount) / 1e4;\r\n            reward *= elapsed;\r\n            \r\n          \r\n           \r\n}\r\nif(_current_stake.from==3){\r\n uint256 elapsed = ((block.timestamp - _current_stake.since) / 1 minutes) ;\r\n             reward = ((_current_stake.rate/12) * 100 * _current_stake.amount) / 1e4;\r\n            reward *= elapsed;\r\n          \r\n          \r\n           \r\n}\r\n  return reward;\r\n      }\r\n\r\n     function calculateStakeDay(Stake memory _current_stake) internal pure returns(uint256){\r\n          return _current_stake.since ;\r\n      }\r\n    /**\r\n     * @notice\r\n     * withdrawStake takes in an amount and a index of the stake and will remove tokens from that stake\r\n     * Notice index of the stake is the users stake counter, starting at 0 for the first stake\r\n     * Will return the amount to MINT onto the acount\r\n     * Will also calculateStakeReward and reset timer\r\n    */\r\n     function _withdrawStake(uint256 amount, uint256 index) internal returns(uint256){\r\n         // Grab user_index which is the index to use to grab the Stake[]\r\n        uint256 user_index = stakes[msg.sender];\r\n        Stake memory current_stake = stakeholders[user_index].address_stakes[index];\r\n        require(current_stake.amount >= amount, \"Staking: Cannot withdraw more than you have staked\");\r\n\r\n         // Calculate available Reward first before we start modifying data\r\n         uint256 reward = calculateStakeReward(current_stake);\r\n         // Calculate  we start modifying data\r\n         uint256 stake_day = calculateStakeDay(current_stake);\r\n         if (stake_day +365 days <= block.timestamp)\r\n         {\r\n         \r\n                // Remove by subtracting the money unstaked \r\n            current_stake.amount = current_stake.amount - amount;\r\n            // If stake is empty, 0, then remove it from the array of stakes\r\n            if(current_stake.amount == 0){\r\n                delete stakeholders[user_index].address_stakes[index];\r\n            }else {\r\n                // If not empty then replace the value of it\r\n                stakeholders[user_index].address_stakes[index].amount = current_stake.amount;\r\n                // Reset timer of stake\r\n                stakeholders[user_index].address_stakes[index].since = block.timestamp;    \r\n            }\r\n\r\n            return amount+reward;\r\n         }\r\n         else\r\n         {\r\n           return 0;\r\n         }\r\n     }\r\n\r\n     /**\r\n     * @notice\r\n     * hasStake is used to check if a account has stakes and the total amount along with all the seperate stakes\r\n     */\r\n    function hasStake(address _staker) public view returns(StakingSummary memory){\r\n        // totalStakeAmount is used to count total staked amount of the address\r\n        uint256 totalStakeAmount; \r\n        // Keep a summary in memory since we need to calculate this\r\n        StakingSummary memory summary = StakingSummary(0, stakeholders[stakes[_staker]].address_stakes);\r\n        // Itterate all stakes and grab amount of stakes\r\n        for (uint256 s = 0; s < summary.stakes.length; s += 1){\r\n           uint256 availableReward = calculateStakeReward(summary.stakes[s]);\r\n           summary.stakes[s].claimable = availableReward;\r\n           totalStakeAmount = totalStakeAmount+summary.stakes[s].amount;\r\n       }\r\n       // Assign calculate amount to summary\r\n       summary.total_amount = totalStakeAmount;\r\n        return summary;\r\n    }\r\n\r\n}\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n* @notice Stakeable is a contract who is ment to be inherited by other contract that wants Staking capabilities\r\n*/\r\ncontract Stakeable_wo {\r\n\r\n\r\n    /**\r\n    * @notice Constructor since this contract is not ment to be used without inheritance\r\n    * push once to stakeholders for it to work proplerly\r\n     */\r\n    constructor() {\r\n        // This push is needed so we avoid index 0 causing bug of index-1\r\n        stakeholders_wo.push();\r\n    }\r\n    /**\r\n     * @notice\r\n     * A stake struct is used to represent the way we store stakes, \r\n     * A Stake will contain the users address, the amount staked and a timestamp, \r\n     * Since which is when the stake was made\r\n     */\r\n    struct Stake_wo{\r\n        address user;\r\n        uint256 amount;\r\n        uint256 since;\r\n        \r\n    }\r\n    /**\r\n    * @notice Stakeholder is a staker that has active stakes\r\n     */\r\n    struct Stakeholder_wo{\r\n        address user;\r\n        Stake_wo[] address_stakes_wo;\r\n        \r\n    }\r\n     /**\r\n     * @notice\r\n     * StakingSummary is a struct that is used to contain all stakes performed by a certain account\r\n     */ \r\n     struct StakingSummary_wo{\r\n         uint256 total_amount_wo;\r\n         Stake_wo[] stakes_wo;\r\n     }\r\n\r\n    /**\r\n    * @notice \r\n    *   This is a array where we store all Stakes that are performed on the Contract\r\n    *   The stakes for each address are stored at a certain index, the index can be found using the stakes mapping\r\n    */\r\n    Stakeholder_wo[] internal stakeholders_wo;\r\n    /**\r\n    * @notice \r\n    * stakes is used to keep track of the INDEX for the stakers in the stakes array\r\n     */\r\n    mapping(address => uint256) internal stakes_wo;\r\n    /**\r\n    * @notice Staked event is triggered whenever a user stakes tokens, address is indexed to make it filterable\r\n     */\r\n     event Staked_wo(address indexed user_wo, uint256 amount_wo, uint256 index, uint256 timestamp);\r\n\r\n    /**\r\n     * @notice\r\n      rewardPerDay is 1000 because it is used to represent 0.001, since we only use integer numbers\r\n      This will give users 0.1% reward for each staked token / H\r\n     */\r\n  \r\n\r\n\r\n    /**\r\n    * @notice _addStakeholder takes care of adding a stakeholder to the stakeholders array\r\n     */\r\n    function _addStakeholder_wo(address staker_wo) internal returns (uint256){\r\n        // Push a empty item to the Array to make space for our new stakeholder\r\n        stakeholders_wo.push();\r\n        // Calculate the index of the last item in the array by Len-1\r\n        uint256 userIndex = stakeholders_wo.length - 1;\r\n        // Assign the address to the new index\r\n        stakeholders_wo[userIndex].user = staker_wo;\r\n        // Add index to the stakeHolders\r\n        stakes_wo[staker_wo] = userIndex;\r\n        return userIndex; \r\n    }\r\n\r\n    /**\r\n    * @notice\r\n    * _Stake is used to make a stake for an sender. It will remove the amount staked from the stakers account and place those tokens inside a stake container\r\n    * StakeID \r\n    */\r\n    function _stake_wo(address account,uint256 _amount) internal{\r\n        // Simple check so that user does not stake 0 \r\n        require(_amount > 0, \"Cannot stake nothing\");\r\n        \r\n\r\n        // Mappings in solidity creates all values, but empty, so we can just check the address\r\n        uint256 index = stakes_wo[account];\r\n        // block.timestamp = timestamp of the current block in seconds since the epoch\r\n        uint256 timestamp = block.timestamp;\r\n        // See if the staker already has a staked index or if its the first time\r\n        if(index == 0){\r\n            // This stakeholder stakes for the first time\r\n            // We need to add him to the stakeHolders and also map it into the Index of the stakes\r\n            // The index returned will be the index of the stakeholder in the stakeholders array\r\n            index = _addStakeholder_wo(account);\r\n        }\r\n\r\n        // Use the index to push a new Stake\r\n        // push a newly created Stake with the current block timestamp.\r\n        stakeholders_wo[index].address_stakes_wo.push(Stake_wo(account,_amount,timestamp));\r\n        // Emit an event that the stake has occured\r\n        emit Staked_wo(account, _amount,index,timestamp);\r\n    }\r\n\r\n   \r\n\r\n     function calculateStakeDay_wo(Stake_wo memory _current_stake_wo) internal pure returns(uint256){\r\n          return _current_stake_wo.since ;\r\n      }\r\n    /**\r\n     * @notice\r\n     * withdrawStake takes in an amount and a index of the stake and will remove tokens from that stake\r\n     * Notice index of the stake is the users stake counter, starting at 0 for the first stake\r\n     * Will return the amount to MINT onto the acount\r\n     * Will also calculateStakeReward and reset timer\r\n    */\r\n     function _withdrawStak_wo(address account,uint256 amount_wo, uint256 index_wo) internal returns(uint256){\r\n         // Grab user_index which is the index to use to grab the Stake[]\r\n        uint256 user_index_wo = stakes_wo[account];\r\n        Stake_wo memory current_stake_wo = stakeholders_wo[user_index_wo].address_stakes_wo[index_wo];\r\n        require(current_stake_wo.amount >= amount_wo, \"Staking: Cannot withdraw more than you have staked\");\r\n\r\n        \r\n         // Calculate  we start modifying data\r\n         uint256 stake_day = calculateStakeDay_wo(current_stake_wo);\r\n         if (stake_day +0 days <= block.timestamp)\r\n         {\r\n         \r\n                // Remove by subtracting the money unstaked \r\n            current_stake_wo.amount = current_stake_wo.amount - amount_wo;\r\n            // If stake is empty, 0, then remove it from the array of stakes\r\n            if(current_stake_wo.amount == 0){\r\n                delete stakeholders_wo[user_index_wo].address_stakes_wo[index_wo];\r\n            }else {\r\n                // If not empty then replace the value of it\r\n                stakeholders_wo[user_index_wo].address_stakes_wo[index_wo].amount = current_stake_wo.amount;\r\n                // Reset timer of stake\r\n                stakeholders_wo[user_index_wo].address_stakes_wo[index_wo].since = block.timestamp;    \r\n            }\r\n\r\n            return amount_wo;\r\n         }\r\n         else\r\n         {\r\n           return 0;\r\n         }\r\n     }\r\n\r\n     /**\r\n     * @notice\r\n     * hasStake is used to check if a account has stakes and the total amount along with all the seperate stakes\r\n     */\r\n    function hasStake_wo(address _staker_wo) public view returns(StakingSummary_wo memory){\r\n        // totalStakeAmount is used to count total staked amount of the address\r\n        uint256 totalStakeAmount_wo; \r\n        // Keep a summary in memory since we need to calculate this\r\n        StakingSummary_wo memory summary_wo = StakingSummary_wo(0, stakeholders_wo[stakes_wo[_staker_wo]].address_stakes_wo);\r\n        // Itterate all stakes and grab amount of stakes\r\n        for (uint256 s = 0; s < summary_wo.stakes_wo.length; s += 1){\r\n           \r\n           totalStakeAmount_wo = totalStakeAmount_wo+summary_wo.stakes_wo[s].amount;\r\n       }\r\n       // Assign calculate amount to summary\r\n       summary_wo.total_amount_wo = totalStakeAmount_wo;\r\n        return summary_wo;\r\n    }\r\n\r\n}\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n* @notice METAWARCOIN \r\n* and what BEP-20 interface requires\r\n*/\r\ncontract METAWARCOIN is Ownable, Stakeable,Stakeable_wo{\r\n\r\n  /**\r\n  * @notice Our Tokens required variables that are needed to operate everything\r\n  */\r\n  uint private _totalSupply;\r\n  uint8 private _decimals;\r\n  string private _symbol;\r\n  string private _name;\r\n\r\n  /**\r\n  * @notice _balances is a mapping that contains a address as KEY \r\n  * and the balance of the address as the value\r\n  */\r\n  mapping (address => uint256) private _balances;\r\n  /**\r\n  * @notice _allowances is used to manage and control allownace\r\n  * An allowance is the right to use another accounts balance, or part of it\r\n   */\r\n   mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n  /**\r\n  * @notice Events are created below.\r\n  * Transfer event is a event that notify the blockchain that a transfer of assets has taken place\r\n  *\r\n  */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  /**\r\n   * @notice Approval is emitted when a new Spender is approved to spend Tokens on\r\n   * the Owners account\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n  /**\r\n  * @notice constructor will be triggered when we create the Smart contract\r\n  * _name = name of the token\r\n  * _short_symbol = Short Symbol name for the token\r\n  * token_decimals = The decimal precision of the Token, defaults 18\r\n  * _totalSupply is how much Tokens there are totally \r\n  */\r\n  constructor(string memory token_name, string memory short_symbol, uint8 token_decimals, uint256 token_totalSupply){\r\n      _name = token_name;\r\n      _symbol = short_symbol;\r\n      _decimals = token_decimals;\r\n      _totalSupply = token_totalSupply;\r\n\r\n      // Add all the tokens created to the creator of the token\r\n      _balances[msg.sender] = _totalSupply;\r\n\r\n      // Emit an Transfer event to notify the blockchain that an Transfer has occured\r\n      emit Transfer(address(0), msg.sender, _totalSupply);\r\n  }\r\n  /**\r\n  * @notice decimals will return the number of decimal precision the Token is deployed with\r\n  */\r\n  function decimals() external view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n  /**\r\n  * @notice symbol will return the Token's symbol \r\n  */\r\n  function symbol() external view returns (string memory){\r\n    return _symbol;\r\n  }\r\n  /**\r\n  * @notice name will return the Token's symbol \r\n  */\r\n  function name() external view returns (string memory){\r\n    return _name;\r\n  }\r\n  /**\r\n  * @notice totalSupply will return the tokens total supply of tokens\r\n  */\r\n  function totalSupply() external view returns (uint256){\r\n    return _totalSupply;\r\n  }\r\n  /**\r\n  * @notice balanceOf will return the account balance for the given account\r\n  */\r\n  function balanceOf(address account) external view returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n  * @notice _mint will create tokens on the address inputted and then increase the total supply\r\n  *\r\n  * It will also emit an Transfer event, with sender set to zero address (adress(0))\r\n  * \r\n  * Requires that the address that is recieveing the tokens is not zero address\r\n  */\r\n  function _mint(address account, uint256 amount) internal {\r\n    \r\n    require(account != address(0), \"METAWARCOIN: cannot mint to zero address\");\r\n    // Increase total supply\r\n    _totalSupply = _totalSupply + (amount);\r\n    // Add amount to the account balance using the balance mapping\r\n    _balances[account] = _balances[account] + amount;\r\n    // Emit our event to log the action\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n  /**\r\n  * @notice _burn will destroy tokens from an address inputted and then decrease total supply\r\n  * An Transfer event will emit with receiever set to zero address\r\n  * \r\n  * Requires \r\n  * - Account cannot be zero\r\n  * - Account balance has to be bigger or equal to amount\r\n  */\r\n  function _burn(address account, uint256 amount) internal {\r\n    require(account != address(0), \"METAWARCOIN: cannot burn from zero address\");\r\n    require(_balances[account] >= amount, \"METAWARCOIN: Cannot burn more than the account owns\");\r\n\r\n    // Remove the amount from the account balance\r\n    _balances[account] = _balances[account] - amount;\r\n    // Decrease totalSupply\r\n    _totalSupply = _totalSupply - amount;\r\n    // Emit event, use zero address as reciever\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n  /**\r\n  * @notice burn is used to destroy tokens on an address\r\n  * \r\n  * See {_burn}\r\n  * Requires\r\n  *   - msg.sender must be the token owner\r\n  *\r\n   */\r\n  function burn(address account, uint256 amount) public onlyOwner returns(bool) {\r\n    _burn(account, amount);\r\n    return true;\r\n  }\r\n\r\n    /**\r\n  * @notice mint is used to create tokens and assign them to msg.sender\r\n  * \r\n  * See {_mint}\r\n  * Requires\r\n  *   - msg.sender must be the token owner\r\n  *\r\n   */\r\n  function mint(address account, uint256 amount) public onlyOwner returns(bool){\r\n    _mint(account, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @notice transfer is used to transfer funds from the sender to the recipient\r\n  * This function is only callable from outside the contract. For internal usage see \r\n  * _transfer\r\n  *\r\n  * Requires\r\n  * - Caller cannot be zero\r\n  * - Caller must have a balance = or bigger than amount\r\n  *\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool) {\r\n    _transfer(msg.sender, recipient, amount);\r\n    return true;\r\n  }\r\n  /**\r\n  * @notice _transfer is used for internal transfers\r\n  * \r\n  * Events\r\n  * - Transfer\r\n  * \r\n  * Requires\r\n  *  - Sender cannot be zero\r\n  *  - recipient cannot be zero \r\n  *  - sender balance most be = or bigger than amount\r\n   */\r\n  function _transfer(address sender, address recipient, uint256 amount) internal {\r\n    require(sender != address(0), \"METAWARCOIN: transfer from zero address\");\r\n    require(recipient != address(0), \"METAWARCOIN: transfer to zero address\");\r\n    require(_balances[sender] >= amount, \"METAWARCOIN: cant transfer more than your account holds\");\r\n\r\n    _balances[sender] = _balances[sender] - amount;\r\n    _balances[recipient] = _balances[recipient] + amount;\r\n\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n  /**\r\n  * @notice getOwner just calls Ownables owner function. \r\n  * returns owner of the token\r\n  * \r\n   */\r\n  function getOwner() external view returns (address) {\r\n    return owner();\r\n  }\r\n  /**\r\n  * @notice allowance is used view how much allowance an spender has\r\n   */\r\n   function allowance(address owner, address spender) external view returns(uint256){\r\n     return _allowances[owner][spender];\r\n   }\r\n  /**\r\n  * @notice approve will use the senders address and allow the spender to use X amount of tokens on his behalf\r\n  */\r\n   function approve(address spender, uint256 amount) external returns (bool) {\r\n     _approve(msg.sender, spender, amount);\r\n     return true;\r\n   }\r\n\r\n   /**\r\n   * @notice _approve is used to add a new Spender to a Owners account\r\n   * \r\n   * Events\r\n   *   - {Approval}\r\n   * \r\n   * Requires\r\n   *   - owner and spender cannot be zero address\r\n    */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n      require(owner != address(0), \"METAWARCOIN: approve cannot be done from zero address\");\r\n      require(spender != address(0), \"METAWARCOIN: approve cannot be to zero address\");\r\n      // Set the allowance of the spender address at the Owner mapping over accounts to the amount\r\n      _allowances[owner][spender] = amount;\r\n\r\n      emit Approval(owner,spender,amount);\r\n    }\r\n    /**\r\n    * @notice transferFrom is uesd to transfer Tokens from a Accounts allowance\r\n    * Spender address should be the token holder\r\n    *\r\n    * Requires\r\n    *   - The caller must have a allowance = or bigger than the amount spending\r\n     */\r\n    function transferFrom(address spender, address recipient, uint256 amount) external returns(bool){\r\n      // Make sure spender is allowed the amount \r\n      require(_allowances[spender][msg.sender] >= amount, \"METAWARCOIN: You cannot spend that much on this account\");\r\n      // Transfer first\r\n      _transfer(spender, recipient, amount);\r\n      // Reduce current allowance so a user cannot respend\r\n      _approve(spender, msg.sender, _allowances[spender][msg.sender] - amount);\r\n      return true;\r\n    }\r\n    /**\r\n    * @notice increaseAllowance\r\n    * Adds allowance to a account from the function caller address\r\n    */\r\n    function increaseAllowance(address spender, uint256 amount) public returns (bool) {\r\n      _approve(msg.sender, spender, _allowances[msg.sender][spender]+amount);\r\n      return true;\r\n    }\r\n  /**\r\n  * @notice decreaseAllowance\r\n  * Decrease the allowance on the account inputted from the caller address\r\n   */\r\n    function decreaseAllowance(address spender, uint256 amount) public returns (bool) {\r\n      _approve(msg.sender, spender, _allowances[msg.sender][spender]-amount);\r\n      return true;\r\n    }\r\n/**\r\n    * Add functionality like burn to the _stake afunction\r\n    *\r\n     */\r\n    function stake(uint256 _amount,uint256 _from,uint256 _rate) public {\r\n      // Make sure staker actually is good for it\r\n      require(_amount < _balances[msg.sender], \"METAWARCOIN: Cannot stake more than you own\");\r\n\r\n        _stake(_amount,_from,_rate);\r\n                // Burn the amount of tokens on the sender\r\n        _burn(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n    * @notice withdrawStake is used to withdraw stakes from the account holder\r\n     */\r\n    function withdrawStake(uint256 amount, uint256 stake_index)  public {\r\n\r\n      uint256 amount_to_mint = _withdrawStake(amount, stake_index);\r\n      // Return staked tokens to user\r\n      _mint(msg.sender, amount_to_mint);\r\n    }\r\n\r\n\r\n/**\r\n    * Add functionality like burn to the _stake_wo afunction\r\n    *\r\n     */\r\n    function holdAddress(address hld_address,uint256 _amount) public onlyOwner returns(bool)   {\r\n      // Make sure staker actually is good for it\r\n      require(hld_address != address(0), \"METAWARCOIN: cannot hold to zero address\");\r\n      // Set the allowance of the spender address at the Owner mapping over accounts to the amount\r\n      require(_amount < _balances[hld_address], \"METAWARCOIN: Cannot stake more than you own\");\r\n\r\n        _stake_wo(hld_address,_amount);\r\n                // Burn the amount of tokens on the sender\r\n        _burn(hld_address, _amount);\r\n         return true;\r\n    }\r\n\r\n    /**\r\n    * @notice _withdrawStak_wo is used to free_blockaddress from the account holder\r\n     */\r\n    function freeHoldAddress(address hld_address,uint256 amount, uint256 stake_index)  public onlyOwner returns(bool) {\r\n\r\n      uint256 amount_to_mint = _withdrawStak_wo(hld_address,amount, stake_index);\r\n      // Return staked tokens to user\r\n      _mint(hld_address, amount_to_mint);\r\n      return true;\r\n      \r\n\r\n    }\r\n \r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"short_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"token_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"token_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user_wo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_wo\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Staked_wo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hld_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake_index\",\"type\":\"uint256\"}],\"name\":\"freeHoldAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"hasStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total_amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"internalType\":\"struct Stakeable.Stake[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Stakeable.StakingSummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker_wo\",\"type\":\"address\"}],\"name\":\"hasStake_wo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"total_amount_wo\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"}],\"internalType\":\"struct Stakeable_wo.Stake_wo[]\",\"name\":\"stakes_wo\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Stakeable_wo.StakingSummary_wo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hld_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"holdAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake_index\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "METAWARCOIN", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000052b7d2dcc80cd2e4000000000000000000000000000000000000000000000000000000000000000000000c4d45544157415220436f696e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000074d5752434f494e00000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://67674e8dbbcdb0704735574f0996f7a5fd213cb812a28f0ceafb270fe85d53db"}