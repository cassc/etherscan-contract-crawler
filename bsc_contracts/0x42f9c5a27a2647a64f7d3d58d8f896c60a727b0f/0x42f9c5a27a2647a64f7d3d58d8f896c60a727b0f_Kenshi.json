{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.11;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165.\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others.\r\n *\r\n * For an implementation, see {ERC165}.\r\n *\r\n * Note: Name adjusted to BSC network.\r\n */\r\ninterface IBEP165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n/*\r\n  @source https://github.com/binance-chain/bsc-genesis-contract/blob/master/contracts/bep20_template/BEP20Token.template\r\n\r\n  CHANGES:\r\n  \r\n  - formatted with Prettier.\r\n  - Updated syntax to 0.8.10\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC1363 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1363.\r\n *\r\n * Standard functions a token contract and contracts working with tokens\r\n *  can implement to make a token Payable.\r\n *\r\n * For an implementation, see https://github.com/vittominacori/erc1363-payable-token.\r\n *\r\n * Note: Name adjusted to BSC network.\r\n */\r\ninterface IBEP1363 is IBEP20, IBEP165 {\r\n    /*\r\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\r\n     * 0xb0202a11 ===\r\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\r\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\r\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\r\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\r\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\r\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\r\n     */\r\n\r\n    /**\r\n     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 The amount of tokens to be transferred\r\n     * @return true unless throwing\r\n     */\r\n    function transferAndCall(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 The amount of tokens to be transferred\r\n     * @param data bytes Additional data with no specified format, sent in call to `to`\r\n     * @return true unless throwing\r\n     */\r\n    function transferAndCall(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 The amount of tokens to be transferred\r\n     * @return true unless throwing\r\n     */\r\n    function transferFromAndCall(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 The amount of tokens to be transferred\r\n     * @param data bytes Additional data with no specified format, sent in call to `to`\r\n     * @return true unless throwing\r\n     */\r\n    function transferFromAndCall(\r\n        address from,\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\r\n     * and then call `onApprovalReceived` on spender.\r\n     * @param spender address The address which will spend the funds\r\n     * @param value uint256 The amount of tokens to be spent\r\n     */\r\n    function approveAndCall(address spender, uint256 value)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\r\n     * and then call `onApprovalReceived` on spender.\r\n     * @param spender address The address which will spend the funds\r\n     * @param value uint256 The amount of tokens to be spent\r\n     * @param data bytes Additional data with no specified format, sent in call to `spender`\r\n     */\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1363Receiver interface\r\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\r\n *  from ERC1363 token contracts.\r\n */\r\ninterface IBEP1363Receiver {\r\n    /*\r\n     * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\r\n     * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\r\n     */\r\n\r\n    /**\r\n     * @notice Handle the receipt of ERC1363 tokens\r\n     * @dev Any ERC1363 smart contract calls this function on the recipient\r\n     * after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\r\n     * transfer. Return of other than the magic value MUST result in the\r\n     * transaction being reverted.\r\n     * Note: the token contract address is always the message sender.\r\n     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\r\n     * @param from address The address which are token transferred from\r\n     * @param value uint256 The amount of tokens transferred\r\n     * @param data bytes Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\r\n     *  unless throwing\r\n     */\r\n    function onTransferReceived(\r\n        address operator,\r\n        address from,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC1363Spender interface\r\n * @dev Interface for any contract that wants to support `approveAndCall`\r\n *  from ERC1363 token contracts.\r\n */\r\ninterface IBEP1363Spender {\r\n    /*\r\n     * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\r\n     * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\r\n     */\r\n\r\n    /**\r\n     * @notice Handle the approval of ERC1363 tokens\r\n     * @dev Any ERC1363 smart contract calls this function on the recipient\r\n     * after an `approve`. This function MAY throw to revert and reject the\r\n     * approval. Return of other than the magic value MUST result in the\r\n     * transaction being reverted.\r\n     * Note: the token contract address is always the message sender.\r\n     * @param owner address The address which called `approveAndCall` function\r\n     * @param value uint256 The amount of tokens to be spent\r\n     * @param data bytes Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\r\n     *  unless throwing\r\n     */\r\n    function onApprovalReceived(\r\n        address owner,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n// Note: Stripped the library from unused functions\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Kenshi is Context, IBEP20, IBEP165, IBEP1363, Ownable {\r\n    using Address for address;\r\n    /* BEP20 related */\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint8 private _decimals;\r\n\r\n    string private _symbol;\r\n    string private _name;\r\n\r\n    /* Kenshi related */\r\n\r\n    /* Reward calculation */\r\n\r\n    uint256 private _totalExcluded;\r\n    uint256 private _circulation;\r\n    uint256 private _balanceCoeff;\r\n    uint256 private _minBalanceCoeff;\r\n\r\n    /* Treasury */\r\n\r\n    address private _treasuryAddr;\r\n\r\n    /* Special addresses (lockers, reserve, liquidity pools...) */\r\n\r\n    mapping(address => bool) private _excludedFromTax;\r\n    mapping(address => bool) private _excludedFromFines;\r\n    mapping(address => bool) private _excludedFromReflects;\r\n    mapping(address => bool) private _excludedFromMaxBalance;\r\n    mapping(address => bool) private _excludedFromFineAndTaxDestinations;\r\n\r\n    /**\r\n     * Admins can exclude or include addresses from tax, reflections or\r\n     * maximum balance. An example is a Deployer creating a Kenshi Locker.\r\n     */\r\n\r\n    mapping(address => bool) private _adminAddrs;\r\n\r\n    /* Tokenomics */\r\n\r\n    mapping(address => uint256) private _purchaseTimes;\r\n\r\n    address private _burnAddr;\r\n\r\n    uint8 private _baseTax;\r\n    uint8 private _burnPercentage;\r\n    uint8 private _investPercentage;\r\n\r\n    uint256 private _minMaxBalance;\r\n    uint256 private _burnThreshold;\r\n\r\n    /**\r\n     * Instead of implementing log functions and calculating the fine\r\n     * amount on-demand, we decided to use pre-calculated values for it.\r\n     * Just a bit less accurate, but saves a lot of gas.\r\n     */\r\n    uint8[30] private _earlySaleFines = [\r\n        49,\r\n        39,\r\n        33,\r\n        29,\r\n        26,\r\n        23,\r\n        21,\r\n        19,\r\n        17,\r\n        16,\r\n        14,\r\n        13,\r\n        12,\r\n        11,\r\n        10,\r\n        9,\r\n        8,\r\n        7,\r\n        7,\r\n        6,\r\n        5,\r\n        4,\r\n        4,\r\n        3,\r\n        3,\r\n        2,\r\n        2,\r\n        1,\r\n        0,\r\n        0\r\n    ];\r\n\r\n    /* Security / Anti-bot measures */\r\n\r\n    bool private _tradeOpen;\r\n\r\n    constructor() {\r\n        _name = \"Kenshi\";\r\n        _symbol = \"KENSHI\";\r\n\r\n        /**\r\n         * Large supply and large decimal places are to help with\r\n         * the accuracy loss caused by the reward system.\r\n         */\r\n\r\n        _decimals = 18;\r\n        _totalSupply = 10e12 * 1e18;\r\n        _balances[msg.sender] = _totalSupply;\r\n\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n\r\n        /* Kenshi related */\r\n\r\n        _baseTax = 5;\r\n        _burnPercentage = 1;\r\n        _investPercentage = 50;\r\n\r\n        /* Give the required privileges to the owner */\r\n\r\n        _adminAddrs[msg.sender] = true;\r\n        _excludedFromTax[msg.sender] = true;\r\n        _excludedFromFines[msg.sender] = true;\r\n        _excludedFromReflects[msg.sender] = true;\r\n        _excludedFromMaxBalance[msg.sender] = true;\r\n        _excludedFromFineAndTaxDestinations[msg.sender] = true;\r\n\r\n        /* Burning */\r\n\r\n        _burnAddr = address(0xdead);\r\n        _burnThreshold = _totalSupply / 2;\r\n\r\n        _excludedFromReflects[_burnAddr] = true;\r\n        _excludedFromMaxBalance[_burnAddr] = true;\r\n        _excludedFromFineAndTaxDestinations[_burnAddr] = true;\r\n\r\n        /* Treasury */\r\n\r\n        _treasuryAddr = address(0);\r\n\r\n        /* Set initial max balance, this amount increases over time */\r\n\r\n        _minMaxBalance = _totalSupply / 100;\r\n\r\n        /**\r\n         * This value gives us maximum precision without facing overflows\r\n         * or underflows. Be careful when updating the _totalSupply or\r\n         * the value below.\r\n         */\r\n\r\n        _balanceCoeff = (~uint256(0)) / _totalSupply;\r\n        _minBalanceCoeff = 1e18;\r\n\r\n        /* Other initial variable values */\r\n\r\n        _totalExcluded = _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the admins.\r\n     */\r\n    modifier onlyAdmins() {\r\n        require(_adminAddrs[_msgSender()], \"Kenshi: Caller is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-totalSupply}.\r\n     */\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        if (isExcluded(account)) {\r\n            return _balances[account];\r\n        }\r\n        return _balances[account] / _balanceCoeff;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-allowance}.\r\n     */\r\n    function allowance(address addr, address spender)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _allowances[addr][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {BEP20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(\r\n            _allowances[sender][_msgSender()] > amount,\r\n            \"BEP20: transfer amount exceeds allowance\"\r\n        );\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()] - amount\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _allowances[_msgSender()][spender] > subtractedValue,\r\n            \"BEP20: decreased allowance below zero\"\r\n        );\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] - subtractedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    event Reflect(uint256 amount);\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     * Emits a {Reflect} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - `amount` should not exceed the maximum allowed\r\n     * - `amount` should not cause the recipient balance\r\n                  to get bigger than the maximum allowed\r\n       - trading should be open\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal {\r\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n        require(amount > 0, \"Kenshi: Transfer amount should be bigger than 0\");\r\n\r\n        if (\r\n            (isTaxless(sender) && isFineFree(sender)) ||\r\n            isTaxlessDestination(recipient)\r\n        ) {\r\n            uint256 rOutgoing = _getTransferAmount(sender, amount);\r\n            uint256 rIncoming = _getTransferAmount(recipient, amount);\r\n\r\n            require(\r\n                rOutgoing <= _balances[sender],\r\n                \"Kenshi: Balance is lower than the requested amount\"\r\n            );\r\n\r\n            /* Required for migrations and making a liquidity pool */\r\n            if (_tradeOpen || sender != owner()) {\r\n                require(\r\n                    _checkMaxBalance(recipient, rIncoming),\r\n                    \"Kenshi: Resulting balance more than the maximum allowed\"\r\n                );\r\n            }\r\n\r\n            _balances[sender] = _balances[sender] - rOutgoing;\r\n            _balances[recipient] = _balances[recipient] + rIncoming;\r\n\r\n            if (isExcluded(sender) && !isExcluded(recipient)) {\r\n                _totalExcluded = _totalExcluded - amount;\r\n            } else if (!isExcluded(sender) && isExcluded(recipient)) {\r\n                _totalExcluded = _totalExcluded + amount;\r\n            }\r\n\r\n            emit Transfer(sender, recipient, amount);\r\n\r\n            return;\r\n        }\r\n\r\n        require(_tradeOpen, \"Kenshi: Trading is not open yet\");\r\n\r\n        uint256 burn = _getBurnAmount(amount);\r\n        uint256 rawTax = _getTax(sender, amount);\r\n        uint256 tax = rawTax > burn ? rawTax - burn : 0;\r\n\r\n        /* Split the tax */\r\n\r\n        uint256 invest = (tax * _investPercentage) / 100;\r\n        uint256 reward = tax - invest;\r\n\r\n        uint256 remainingAmount = amount - tax - burn;\r\n        uint256 outgoing = _getTransferAmount(sender, amount);\r\n        uint256 incoming = _getTransferAmount(recipient, remainingAmount);\r\n\r\n        require(\r\n            outgoing <= _balances[sender],\r\n            \"Kenshi: Balance is lower than the requested amount\"\r\n        );\r\n\r\n        require(\r\n            _checkMaxBalance(recipient, incoming),\r\n            \"Kenshi: Resulting balance more than the maximum allowed\"\r\n        );\r\n\r\n        if (invest > 0) {\r\n            if (_treasuryAddr != address(0)) {\r\n                _balances[_treasuryAddr] = _balances[_treasuryAddr] + invest;\r\n                _totalExcluded = _totalExcluded + invest;\r\n                emit Transfer(sender, _treasuryAddr, invest);\r\n            } else {\r\n                reward = reward + invest;\r\n            }\r\n        }\r\n\r\n        if (burn > 0) {\r\n            _balances[_burnAddr] = _balances[_burnAddr] + burn;\r\n            _totalExcluded = _totalExcluded + burn;\r\n            emit Transfer(sender, _burnAddr, burn);\r\n        }\r\n\r\n        _balances[sender] = _balances[sender] - outgoing;\r\n        _balances[recipient] = _balances[recipient] + incoming;\r\n\r\n        emit Transfer(sender, recipient, remainingAmount);\r\n\r\n        if (isExcluded(sender)) {\r\n            _totalExcluded = _totalExcluded - amount;\r\n        }\r\n\r\n        if (isExcluded(recipient)) {\r\n            _totalExcluded = _totalExcluded + remainingAmount;\r\n        }\r\n\r\n        _circulation = _totalSupply - _totalExcluded;\r\n        uint256 delta = (_balanceCoeff * reward) / _circulation;\r\n        bool shouldReflect = _balanceCoeff - delta > _minBalanceCoeff;\r\n\r\n        if (reward > 0 && !shouldReflect && _treasuryAddr != address(0)) {\r\n            _balances[_treasuryAddr] = _balances[_treasuryAddr] + reward;\r\n            _totalExcluded = _totalExcluded + reward;\r\n            emit Transfer(sender, _treasuryAddr, reward);\r\n        } else if (shouldReflect && delta < _balanceCoeff) {\r\n            _balanceCoeff = _balanceCoeff - delta;\r\n            emit Reflect(reward);\r\n        } else if (reward > 0) {\r\n            _balances[_burnAddr] = _balances[_burnAddr] + reward;\r\n            _totalExcluded = _totalExcluded + reward;\r\n            emit Transfer(sender, _burnAddr, reward);\r\n        }\r\n\r\n        _recordPurchase(recipient, incoming);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `addr`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `addr` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address addr,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(addr != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[addr][spender] = amount;\r\n        emit Approval(addr, spender, amount);\r\n    }\r\n\r\n    /* ERC165 methods */\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        external\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IBEP1363).interfaceId;\r\n    }\r\n\r\n    /* BEP1363 methods */\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address and then execute a callback on recipient.\r\n     * @param recipient The address to transfer to.\r\n     * @param amount The amount to be transferred.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferAndCall(address recipient, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return transferAndCall(recipient, amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens to a specified address and then execute a callback on recipient.\r\n     * @param recipient The address to transfer to\r\n     * @param amount The amount to be transferred\r\n     * @param data Additional data with no specified format\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferAndCall(\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public returns (bool) {\r\n        transfer(recipient, amount);\r\n        require(\r\n            _checkAndCallTransfer(_msgSender(), recipient, amount, data),\r\n            \"BEP1363: _checkAndCallTransfer reverts\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another and then execute a callback on recipient.\r\n     * @param sender The address which you want to send tokens from\r\n     * @param recipient The address which you want to transfer to\r\n     * @param amount The amount of tokens to be transferred\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferFromAndCall(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        return transferFromAndCall(sender, recipient, amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another and then execute a callback on recipient.\r\n     * @param sender The address which you want to send tokens from\r\n     * @param recipient The address which you want to transfer to\r\n     * @param amount The amount of tokens to be transferred\r\n     * @param data Additional data with no specified format\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function transferFromAndCall(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public returns (bool) {\r\n        transferFrom(sender, recipient, amount);\r\n        require(\r\n            _checkAndCallTransfer(sender, recipient, amount, data),\r\n            \"BEP1363: _checkAndCallTransfer reverts\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve spender to transfer tokens and then execute a callback on recipient.\r\n     * @param spender The address allowed to transfer to\r\n     * @param amount The amount allowed to be transferred\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approveAndCall(address spender, uint256 amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        return approveAndCall(spender, amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Approve spender to transfer tokens and then execute a callback on recipient.\r\n     * @param spender The address allowed to transfer to.\r\n     * @param amount The amount allowed to be transferred.\r\n     * @param data Additional data with no specified format.\r\n     * @return A boolean that indicates if the operation was successful.\r\n     */\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public returns (bool) {\r\n        approve(spender, amount);\r\n        require(\r\n            _checkAndCallApprove(spender, amount, data),\r\n            \"BEP1363: _checkAndCallApprove reverts\"\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onTransferReceived` on a target address\r\n     *  The call is not executed if the target address is not a contract\r\n     * @param sender address Representing the previous owner of the given token value\r\n     * @param recipient address Target address that will receive the tokens\r\n     * @param amount uint256 The amount mount of tokens to be transferred\r\n     * @param data bytes Optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkAndCallTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal returns (bool) {\r\n        if (!recipient.isContract()) {\r\n            return false;\r\n        }\r\n        bytes4 retval = IBEP1363Receiver(recipient).onTransferReceived(\r\n            _msgSender(),\r\n            sender,\r\n            amount,\r\n            data\r\n        );\r\n        return (retval ==\r\n            IBEP1363Receiver(recipient).onTransferReceived.selector);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onApprovalReceived` on a target address\r\n     *  The call is not executed if the target address is not a contract\r\n     * @param spender address The address which will spend the funds\r\n     * @param amount uint256 The amount of tokens to be spent\r\n     * @param data bytes Optional data to send along with the call\r\n     * @return whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkAndCallApprove(\r\n        address spender,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal returns (bool) {\r\n        if (!spender.isContract()) {\r\n            return false;\r\n        }\r\n        bytes4 retval = IBEP1363Spender(spender).onApprovalReceived(\r\n            _msgSender(),\r\n            amount,\r\n            data\r\n        );\r\n        return (retval == IBEP1363Spender(spender).onApprovalReceived.selector);\r\n    }\r\n\r\n    /* Kenshi methods */\r\n\r\n    /**\r\n     * @dev Records weighted purchase times for fine calculation.\r\n     */\r\n    function _recordPurchase(address addr, uint256 amount) private {\r\n        uint256 current = _purchaseTimes[addr] *\r\n            _decoeff(addr, _balances[addr] - amount);\r\n\r\n        _purchaseTimes[addr] =\r\n            (current + block.timestamp * _decoeff(addr, amount)) /\r\n            balanceOf(addr);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes the coefficient factor from `addr` is not excluded.\r\n     */\r\n    function _decoeff(address addr, uint256 amount)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (isExcluded(addr)) {\r\n            return amount;\r\n        }\r\n        return amount / _balanceCoeff;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if `addr` is excluded from tax.\r\n     */\r\n    function isTaxlessDestination(address addr) public view returns (bool) {\r\n        return _excludedFromFineAndTaxDestinations[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Set `addr` is excluded from tax to `state`.\r\n     */\r\n    function setIsTaxlessDestination(address addr, bool state)\r\n        public\r\n        onlyAdmins\r\n    {\r\n        _excludedFromFineAndTaxDestinations[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if `addr` is excluded from tax.\r\n     */\r\n    function isTaxless(address addr) public view returns (bool) {\r\n        return _excludedFromTax[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Set `addr` is excluded from tax to `state`.\r\n     */\r\n    function setIsTaxless(address addr, bool state) public onlyAdmins {\r\n        _excludedFromTax[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if `addr` is excluded from fines.\r\n     */\r\n    function isFineFree(address addr) public view returns (bool) {\r\n        return _excludedFromFines[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Set `addr` is excluded from fines to `state`.\r\n     */\r\n    function setIsFineFree(address addr, bool state) public onlyAdmins {\r\n        _excludedFromFines[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if `addr` is excluded from reflects.\r\n     */\r\n    function isExcluded(address addr) public view returns (bool) {\r\n        return _excludedFromReflects[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Set `addr` is excluded from reflections to `state`.\r\n     */\r\n    function setIsExcluded(address addr, bool state) public onlyAdmins {\r\n        if (isExcluded(addr) && !state) {\r\n            uint256 balance = _balances[addr];\r\n            _totalExcluded = _totalExcluded - balance;\r\n            _balances[addr] = _balances[addr] * _balanceCoeff;\r\n        } else if (!isExcluded(addr) && state) {\r\n            uint256 balance = _balances[addr] / _balanceCoeff;\r\n            _totalExcluded = _totalExcluded + balance;\r\n            _balances[addr] = balance;\r\n        }\r\n\r\n        _excludedFromReflects[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if `addr` is excluded from max balance limit.\r\n     */\r\n    function isLimitless(address addr) public view returns (bool) {\r\n        return _excludedFromMaxBalance[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Set `addr` is excluded from max balance to `state`.\r\n     */\r\n    function setIsLimitless(address addr, bool state) public onlyAdmins {\r\n        _excludedFromMaxBalance[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if `addr` is an admin.\r\n     */\r\n    function isAdmin(address addr) external view returns (bool) {\r\n        return _adminAddrs[addr];\r\n    }\r\n\r\n    /**\r\n     * @dev Set `addr` is excluded from reflections to `state`.\r\n     */\r\n    function setIsAdmin(address addr, bool state) external onlyAdmins {\r\n        _adminAddrs[addr] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the burn amount for a transaction.\r\n     *\r\n     * Checks how many tokens are already burned, if it's more than the\r\n     * burn threshold then it returns zero, otherwise returns one percent\r\n     * of `amount`.\r\n     */\r\n    function _getBurnAmount(uint256 amount) private view returns (uint256) {\r\n        uint256 _burnedAmount = _balances[_burnAddr];\r\n        if (_burnedAmount >= _burnThreshold) {\r\n            return 0;\r\n        }\r\n        uint256 toBurn = amount / 100;\r\n        if (_burnThreshold - _burnedAmount < toBurn) {\r\n            return _burnThreshold - _burnedAmount;\r\n        }\r\n        return toBurn;\r\n    }\r\n\r\n    /**\r\n     * @dev Check how many tokens are currently burned.\r\n     */\r\n    function getTotalBurned() external view returns (uint256) {\r\n        return _balances[_burnAddr];\r\n    }\r\n\r\n    /**\r\n     * @dev Check how many tokens are currently excluded.\r\n     */\r\n    function getTotalExcluded() external view returns (uint256) {\r\n        return _totalExcluded;\r\n    }\r\n\r\n    /**\r\n     * @dev Check how many tokens are in circulation.\r\n     */\r\n    function getCirculation() external view returns (uint256) {\r\n        return _circulation;\r\n    }\r\n\r\n    /**\r\n     * @dev Get tax amount for `amount` moved from `sender`.\r\n     */\r\n    function _getTax(address sender, uint256 amount)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint8 taxPercentage = _getTaxPercentage(sender);\r\n        uint256 tax = (amount * taxPercentage) / 100;\r\n        return tax;\r\n    }\r\n\r\n    /**\r\n     * @dev calculate tax percentage for `sender` based on purchase times.\r\n     */\r\n    function _getTaxPercentage(address sender) private view returns (uint8) {\r\n        return getTaxPercentageAt(sender, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev calculate tax percentage for `sender` at `timestamp` based on purchase times.\r\n     */\r\n    function getTaxPercentageAt(address sender, uint256 timestamp)\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        bool taxFree = isTaxless(sender);\r\n        bool fineFree = isFineFree(sender);\r\n        if (taxFree && fineFree) {\r\n            return 0;\r\n        }\r\n        if (fineFree) {\r\n            return _baseTax;\r\n        }\r\n        uint256 daysPassed = (timestamp - _purchaseTimes[sender]) / 86400;\r\n        if (daysPassed >= 30) {\r\n            return taxFree ? 0 : _baseTax;\r\n        }\r\n        return\r\n            taxFree\r\n                ? _earlySaleFines[daysPassed]\r\n                : _baseTax + _earlySaleFines[daysPassed];\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates transfer amount based on reward exclusion and reward coeff.\r\n     */\r\n    function _getTransferAmount(address sender, uint256 amount)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (isExcluded(sender)) {\r\n            return amount;\r\n        }\r\n        return amount * _balanceCoeff;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `recipient` won't have more than max balance after a transfer.\r\n     */\r\n    function _checkMaxBalance(address recipient, uint256 incoming)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (isLimitless(recipient)) {\r\n            return true;\r\n        }\r\n        uint256 newBalance = _balances[recipient] + incoming;\r\n        return (newBalance / _balanceCoeff) <= getMaxBalance();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current maximum balance.\r\n     */\r\n    function getMaxBalance() public view returns (uint256) {\r\n        return _minMaxBalance + _circulation / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current balance coefficient.\r\n     */\r\n    function getCurrentCoeff() external view returns (uint256) {\r\n        return _balanceCoeff;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove `amount` from msg.sender and reflect it on all holders.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `amount` shouldn't be bigger than the msg.sender balance.\r\n     */\r\n    function deliver(uint256 amount) external {\r\n        address sender = _msgSender();\r\n        uint256 outgoing = _getTransferAmount(sender, amount);\r\n\r\n        require(\r\n            outgoing <= _balances[sender],\r\n            \"Kenshi: Cannot deliver more than the owned balance\"\r\n        );\r\n\r\n        _balances[sender] = _balances[sender] - outgoing;\r\n\r\n        if (isExcluded(sender)) {\r\n            _totalExcluded = _totalExcluded - amount;\r\n            _circulation = _totalSupply - _totalExcluded;\r\n        }\r\n\r\n        _balanceCoeff = _balanceCoeff - (_balanceCoeff * amount) / _circulation;\r\n\r\n        require(\r\n            _balanceCoeff > _minBalanceCoeff,\r\n            \"Kenshi: Coefficient smaller than the minimum defined\"\r\n        );\r\n\r\n        emit Reflect(amount);\r\n    }\r\n\r\n    event InvestmentPercentageChanged(uint8 percentage);\r\n\r\n    /**\r\n     * @dev Sets the treasury `percentage`, indirectly sets rewards percentage.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - percentage should be equal to or smaller than 100\r\n     *\r\n     * emits a {InvestmentPercentageChanged} event.\r\n     */\r\n    function setInvestPercentage(uint8 percentage) external onlyOwner {\r\n        require(percentage <= 100);\r\n        _investPercentage = percentage;\r\n        emit InvestmentPercentageChanged(percentage);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the investment percentage.\r\n     */\r\n    function getInvestPercentage() external view returns (uint8) {\r\n        return _investPercentage;\r\n    }\r\n\r\n    event BaseTaxChanged(uint8 percentage);\r\n\r\n    /**\r\n     * @dev Sets the base tax `percentage`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - percentage should be equal to or smaller than 15\r\n     *\r\n     * emits a {BaseTaxChanged} event.\r\n     */\r\n    function setBaseTaxPercentage(uint8 percentage) external onlyOwner {\r\n        require(percentage <= 15);\r\n        _baseTax = percentage;\r\n        emit BaseTaxChanged(percentage);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the base tax percentage.\r\n     */\r\n    function getBaseTaxPercentage() external view returns (uint8) {\r\n        return _baseTax;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the trading to open, allows making transfers.\r\n     */\r\n    function openTrades() external onlyOwner {\r\n        _tradeOpen = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `treasury` addr for collecting investment tokens.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `treasury` should not be address(0)\r\n     */\r\n    function setTreasuryAddr(address treasury) external onlyOwner {\r\n        require(treasury != address(0), \"Kenshi: Cannot set treasury to 0x0\");\r\n\r\n        if (_treasuryAddr != address(0)) {\r\n            setIsTaxless(_treasuryAddr, false);\r\n            setIsFineFree(_treasuryAddr, false);\r\n            setIsExcluded(_treasuryAddr, false);\r\n            setIsLimitless(_treasuryAddr, false);\r\n        }\r\n\r\n        _treasuryAddr = treasury;\r\n\r\n        setIsTaxless(_treasuryAddr, true);\r\n        setIsFineFree(_treasuryAddr, true);\r\n        setIsExcluded(_treasuryAddr, true);\r\n        setIsLimitless(_treasuryAddr, true);\r\n    }\r\n\r\n    event BurnThresholdChanged(uint256 threshold);\r\n\r\n    /**\r\n     * @dev Sets the `threshold` for automatic burns.\r\n     *\r\n     * emits a {BurnThresholdChanged} event.\r\n     */\r\n    function setBurnThreshold(uint256 threshold) external onlyOwner {\r\n        _burnThreshold = threshold;\r\n        emit BurnThresholdChanged(threshold);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the burn threshold amount.\r\n     */\r\n    function getBurnThreshold() external view returns (uint256) {\r\n        return _burnThreshold;\r\n    }\r\n\r\n    /**\r\n     * @dev Sends `amount` of BEP20 `token` from contract address to `recipient`\r\n     *\r\n     * Useful if someone sent bep20 tokens to the contract address by mistake.\r\n     */\r\n    function recoverBEP20(\r\n        address token,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external onlyOwner returns (bool) {\r\n        require(\r\n            token != address(this),\r\n            \"Kenshi: Cannot recover Kenshi from the contract\"\r\n        );\r\n        return IBEP20(token).transfer(recipient, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"BaseTaxChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"BurnThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"InvestmentPercentageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reflect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseTaxPercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentCoeff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInvestPercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getTaxPercentageAt\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalExcluded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isFineFree\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isLimitless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isTaxless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isTaxlessDestination\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverBEP20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"setBaseTaxPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setBurnThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percentage\",\"type\":\"uint8\"}],\"name\":\"setInvestPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setIsAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setIsExcluded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setIsFineFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setIsLimitless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setIsTaxless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setIsTaxlessDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"setTreasuryAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferFromAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFromAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Kenshi", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://675e868b8432dc26cbaf884333662c6357422d4f776d0e4a4c091bb3efca577e"}