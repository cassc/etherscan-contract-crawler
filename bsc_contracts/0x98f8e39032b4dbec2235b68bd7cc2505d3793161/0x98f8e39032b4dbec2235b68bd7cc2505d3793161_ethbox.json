{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\n\r\n//------------------------------------------------------------------------------------------------------------------\r\n//\r\n// ethbox\r\n//\r\n// https://www.ethbox.org/\r\n//\r\n//\r\n// ethbox is a smart contract based escrow service. Instead of sending funds from A to B,\r\n// users send funds through ethbox. This enables users to abort outgoing transactions\r\n// in case of a wrong recipient address.\r\n//\r\n// Funds are put in \"boxes\". Each box contains all the relevant data for that transaction.\r\n// Boxes can be secured with a passphrase. Users can request ETH or tokens in return\r\n// for their deposit (= OTC trade).\r\n//\r\n// The passphrase gets hashed twice. This is because the smart contract needs to do\r\n// its own hashing so that it cannot be manipulated - But the passphrase shouldn't\r\n// be submitted in clear-text all over the web, so it gets hashed, and the hash of\r\n// that is stored on the smart contract, so it can recognize when it is given the\r\n// correct passphrase.\r\n//\r\n// Depositing funds into contract = createBox(...)\r\n// Retrieving funds from contract = clearBox(...)\r\n//\r\n//------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\ncontract ethbox\r\n{\r\n    // Transaction data\r\n    struct Box {\r\n        address         payable sender;\r\n        address         recipient;\r\n        bytes32         passHashHash;\r\n        ERC20Interface  sendToken;\r\n        uint            sendValue;\r\n        ERC20Interface  requestToken;\r\n        uint            requestValue;\r\n        uint            timestamp;\r\n        bool            taken;\r\n    }\r\n\r\n\tstruct BoxWithPrivacy {\r\n        bytes32         senderHash;\r\n        bytes32         recipientHash;\r\n        bytes32         passHashHash;\r\n        ERC20Interface  sendToken;\r\n        uint            sendValue;\r\n        uint            timestamp;\r\n        bool            taken;\r\n    }\r\n    \r\n\taddress owner;\r\n\tbool public stopDeposits = false; \r\n\r\n\tBox[] boxes;\r\n\tBoxWithPrivacy[] boxesWithPrivacy;   \r\n\r\n    // Map box indexes to addresses for easier handling / privacy, so users are shown only their own boxes by the contract\r\n    mapping(address => uint[]) senderMap;\r\n    mapping(address => uint[]) recipientMap;\r\n\tmapping(bytes32 => uint[]) senderMapWithPrivacy;\r\n    mapping(bytes32 => uint[]) recipientMapWithPrivacy;\r\n\r\n\r\n    // Deposit funds into contract\r\n    function createBox(address _recipient, ERC20Interface _sendToken, uint _sendValue, ERC20Interface _requestToken, uint _requestValue, bytes32 _passHashHash) external payable\r\n    {\r\n        // Make sure deposits haven't been disabled (will be done when switching to new contract version)\r\n        require(!stopDeposits, \"Depositing to this ethbox contract has been disabled. You can still withdraw funds.\");\r\n        \r\n        // Max 20 outgoing boxes per address, for now\r\n        require(senderMap[msg.sender].length < 20, \"ethbox currently supports a maximum of 20 outgoing transactions per address.\");\r\n    \r\n        Box memory newBox;\r\n        newBox.sender       = payable(msg.sender);\r\n        newBox.recipient    = _recipient;\r\n        newBox.passHashHash = _passHashHash;\r\n        newBox.sendToken    = _sendToken;\r\n        newBox.sendValue    = _sendValue;\r\n        newBox.requestToken = _requestToken;\r\n        newBox.requestValue = _requestValue;\r\n        newBox.timestamp    = block.timestamp;\r\n        newBox.taken        = false;\r\n        boxes.push(newBox);\r\n        \r\n        // Save box index to mappings for sender & recipient\r\n        senderMap[msg.sender].push(boxes.length - 1);\r\n        recipientMap[_recipient].push(boxes.length - 1);\r\n        \r\n        if(_sendToken == ERC20Interface(address(0)))\r\n            // Sending ETH\r\n            require(msg.value == _sendValue, \"Insufficient ETH!\");\r\n        else {\r\n            // Sending tokens\r\n            require(_sendToken.balanceOf(msg.sender) >= _sendValue, \"Insufficient tokens!\");\r\n            require(_sendToken.transferFrom(msg.sender, address(this), _sendValue), \"Transferring tokens to ethbox smart contract failed!\");\r\n        }\r\n    }\r\n\r\n\tfunction createBoxWithPrivacy(bytes32 _recipientHash, ERC20Interface _sendToken, uint _sendValue, bytes32 _passHashHash) external payable\r\n    {\r\n        // Make sure deposits haven't been disabled (will be done when switching to new contract version)\r\n        require(!stopDeposits, \"Depositing to this ethbox contract has been disabled. You can still withdraw funds.\");\r\n        \r\n        // Max 20 outgoing boxes per address, for now\r\n        require(senderMapWithPrivacy[keccak256(abi.encodePacked(msg.sender))].length < 20, \"ethbox currently supports a maximum of 20 outgoing transactions per address.\");\r\n    \r\n        BoxWithPrivacy memory newBox;\r\n        newBox.senderHash       = keccak256(abi.encodePacked(msg.sender));\r\n        newBox.recipientHash    = _recipientHash;\r\n        newBox.passHashHash     = _passHashHash;\r\n        newBox.sendToken        = _sendToken;\r\n        newBox.sendValue        = _sendValue;\r\n        newBox.timestamp        = block.timestamp;\r\n        newBox.taken            = false;\r\n        boxesWithPrivacy.push(newBox);\r\n        \r\n        // Save box index to mappings for sender & recipient\r\n        senderMapWithPrivacy[newBox.senderHash].push(boxesWithPrivacy.length - 1);\r\n        recipientMapWithPrivacy[newBox.recipientHash].push(boxesWithPrivacy.length - 1);\r\n        \r\n        if(_sendToken == ERC20Interface(address(0)))\r\n            // Sending ETH\r\n            require(msg.value == _sendValue, \"Insufficient ETH!\");\r\n        else {\r\n            // Sending tokens\r\n            require(_sendToken.balanceOf(msg.sender) >= _sendValue, \"Insufficient tokens!\");\r\n            require(_sendToken.transferFrom(msg.sender, address(this), _sendValue), \"Transferring tokens to ethbox smart contract failed!\");\r\n        }\r\n    }\r\n    \r\n    // Retrieve funds from contract, only as recipient (when sending tokens: have to ask for approval beforehand in web browser interface)\r\n    function clearBox(uint _boxIndex, bytes32 _passHash) external payable\r\n    {\r\n        require((_boxIndex < boxes.length) && (!boxes[_boxIndex].taken), \"Invalid box index!\");\r\n        require(msg.sender != boxes[_boxIndex].sender, \"Please use 'cancelBox' to cancel transactions as sender!\");\r\n\r\n        // Recipient needs to have correct passphrase (hashed) and requested ETH / tokens\r\n        require(\r\n            (msg.sender == boxes[_boxIndex].recipient)\r\n            && (boxes[_boxIndex].passHashHash == keccak256(abi.encodePacked(_passHash)))\r\n        ,\r\n            \"Deposited funds can only be retrieved by recipient with correct passphrase.\"\r\n        );\r\n        \r\n\t\t// Mark box as taken, so it can't be taken another time\r\n        boxes[_boxIndex].taken = true;\r\n        \r\n        // Transfer requested ETH / tokens to sender\r\n        if(boxes[_boxIndex].requestValue != 0) {\r\n            if(boxes[_boxIndex].requestToken == ERC20Interface(address(0))) {\r\n                require(msg.value == boxes[_boxIndex].requestValue, \"Incorrect amount of ETH attached to transaction, has to be exactly as much as requested!\");\r\n                payable(boxes[_boxIndex].sender).transfer(msg.value);\r\n            } else {\r\n                require(boxes[_boxIndex].requestToken.balanceOf(msg.sender) >= boxes[_boxIndex].requestValue, \"Recipient does not have enough tokens to fulfill sender's request!\");\r\n                require(boxes[_boxIndex].requestToken.transferFrom(msg.sender, boxes[_boxIndex].sender, boxes[_boxIndex].requestValue), \"Transferring requested tokens to sender failed!\");\r\n            }\r\n        }\r\n\r\n        // Transfer sent ETH / tokens to recipient\r\n        if(boxes[_boxIndex].sendToken == ERC20Interface(address(0)))\r\n            payable(msg.sender).transfer(boxes[_boxIndex].sendValue);\r\n        else\r\n            require(boxes[_boxIndex].sendToken.transfer(msg.sender, boxes[_boxIndex].sendValue), \"Transferring tokens to recipient failed!\");\r\n    }\r\n\r\n\tfunction clearBoxWithPrivacy(uint _boxIndex, bytes32 _passHash) external payable\r\n    {\r\n        require((_boxIndex < boxesWithPrivacy.length) && (!boxesWithPrivacy[_boxIndex].taken), \"Invalid box index!\");\r\n        require(keccak256(abi.encodePacked(msg.sender)) != boxesWithPrivacy[_boxIndex].senderHash, \"Please use 'cancelBox' to cancel transactions as sender!\");\r\n\r\n        // Recipient needs to have correct passphrase (hashed)\r\n        require(\r\n            (keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].recipientHash)\r\n            && (boxesWithPrivacy[_boxIndex].passHashHash == keccak256(abi.encodePacked(_passHash)))\r\n        ,\r\n            \"Deposited funds can only be retrieved by recipient with correct passphrase.\"\r\n        );\r\n        \r\n        // Mark box as taken, so it can't be taken another time\r\n        boxesWithPrivacy[_boxIndex].taken = true;\r\n        \r\n        // Transfer sent ETH / tokens to recipient\r\n        if(boxesWithPrivacy[_boxIndex].sendToken == ERC20Interface(address(0)))\r\n            payable(msg.sender).transfer(boxesWithPrivacy[_boxIndex].sendValue);\r\n        else\r\n            require(boxesWithPrivacy[_boxIndex].sendToken.transfer(msg.sender, boxesWithPrivacy[_boxIndex].sendValue), \"Transferring tokens to recipient failed!\");\r\n    }\r\n    \r\n    // Cancel transaction, only as sender (when sending tokens: have to ask for approval beforehand in web browser interface)\r\n    function cancelBox(uint _boxIndex) external payable\r\n    {\r\n        require((_boxIndex < boxes.length) && (!boxes[_boxIndex].taken), \"Invalid box index!\");\r\n        require(msg.sender == boxes[_boxIndex].sender, \"Transactions can only be cancelled by sender.\");\r\n        \r\n        // Mark box as taken, so it can't be taken another time\r\n        boxes[_boxIndex].taken = true;\r\n        \r\n        // Transfer ETH / tokens back to sender\r\n        if(boxes[_boxIndex].sendToken == ERC20Interface(address(0)))\r\n            payable(msg.sender).transfer(boxes[_boxIndex].sendValue);\r\n        else\r\n            require(boxes[_boxIndex].sendToken.transfer(msg.sender, boxes[_boxIndex].sendValue), \"Transferring tokens back to sender failed!\");\r\n    }\r\n\r\n\tfunction cancelBoxWithPrivacy(uint _boxIndex) external payable\r\n    {\r\n        require((_boxIndex < boxesWithPrivacy.length) && (!boxesWithPrivacy[_boxIndex].taken), \"Invalid box index!\");\r\n        require(keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].senderHash, \"Transactions can only be cancelled by sender.\");\r\n        \r\n         // Mark box as taken, so it can't be taken another time\r\n        boxesWithPrivacy[_boxIndex].taken = true;\r\n        \r\n        // Transfer ETH / tokens back to sender\r\n        if(boxesWithPrivacy[_boxIndex].sendToken == ERC20Interface(address(0)))\r\n            payable(msg.sender).transfer(boxesWithPrivacy[_boxIndex].sendValue);\r\n        else\r\n            require(boxesWithPrivacy[_boxIndex].sendToken.transfer(msg.sender, boxesWithPrivacy[_boxIndex].sendValue), \"Transferring tokens back to sender failed!\");\r\n    }\r\n      \r\n    // Retrieve single box by index - only for sender / recipient & contract owner\r\n    function getBox(uint _boxIndex) external view returns(Box memory)\r\n    {\r\n        require(\r\n            (msg.sender == owner)\r\n            || (msg.sender == boxes[_boxIndex].sender)\r\n            || (msg.sender == boxes[_boxIndex].recipient)\r\n        , \r\n            \"Transaction data is only accessible by sender or recipient.\"\r\n        );\r\n        \r\n        return boxes[_boxIndex];\r\n    }\r\n\r\n\tfunction getBoxWithPrivacy(uint _boxIndex) external view returns(BoxWithPrivacy memory)\r\n    {\r\n        require(\r\n            (msg.sender == owner)\r\n            || (keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].senderHash)\r\n            || (keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].recipientHash)\r\n        , \r\n            \"Transaction data is only accessible by sender or recipient.\"\r\n        );\r\n        \r\n        return boxesWithPrivacy[_boxIndex];\r\n    }\r\n    \r\n    // Retrieve sender address => box index mapping for user\r\n    function getBoxesOutgoing() external view returns(uint[] memory)\r\n    {\r\n        return senderMap[msg.sender];\r\n    }\r\n\r\n\tfunction getBoxesOutgoingWithPrivacy() external view returns(uint[] memory)\r\n    {\r\n        return senderMapWithPrivacy[keccak256(abi.encodePacked(msg.sender))];\r\n    }\r\n    \r\n    // Retrieve recipient address => box index mapping for user\r\n    function getBoxesIncoming() external view returns(uint[] memory)\r\n    {\r\n        return recipientMap[msg.sender];\r\n    }\r\n\r\n\tfunction getBoxesIncomingWithPrivacy() external view returns(uint[] memory)\r\n    {\r\n        return recipientMapWithPrivacy[keccak256(abi.encodePacked(msg.sender))];\r\n    }\r\n    \r\n    // Retrieve complete boxes array, only for contract owner\r\n    function getBoxesAll() external view returns(Box[] memory)\r\n    {\r\n        require(msg.sender == owner, \"Non-specific transaction data is not accessible by the general public.\");\r\n        return boxes;\r\n    }\r\n\r\n\tfunction getBoxesAllWithPrivacy() external view returns(BoxWithPrivacy[] memory)\r\n    {\r\n        require(msg.sender == owner, \"Non-specific transaction data is not accessible by the general public.\");\r\n        return boxesWithPrivacy;\r\n    }\r\n    \r\n    // Retrieve number of boxes, only for contract owner\r\n    function getNumBoxes() external view returns(uint)\r\n    {\r\n        require(msg.sender == owner, \"Non-specific transaction data is not accessible by the general public.\");\r\n        return boxes.length;\r\n    }\r\n\r\n\tfunction getNumBoxesWithPrivacy() external view returns(uint)\r\n    {\r\n        require(msg.sender == owner, \"Non-specific transaction data is not accessible by the general public.\");\r\n        return boxesWithPrivacy.length;\r\n    }\r\n\r\n\tfunction cancelAllNonPrivacyBoxes() external\r\n    {\r\n\t\trequire(msg.sender == owner, \"This function is reserved for administration.\");\r\n\r\n\t\tfor(uint i = 0; i < boxes.length; i++)\r\n\t\t\tif(!boxes[i].taken) {\r\n\t\t\t\t// Mark box as taken, so it can't be taken another time\r\n\t\t\t\tboxes[i].taken = true;\r\n\r\n\t\t\t\t// Transfer ETH / tokens back to sender\r\n\t\t\t\tif(boxes[i].sendToken == ERC20Interface(address(0)))\r\n\t\t\t\t\tboxes[i].sender.transfer(boxes[i].sendValue);\r\n\t\t\t\telse\r\n\t\t\t\t\trequire(boxes[i].sendToken.transfer(boxes[i].sender, boxes[i].sendValue), \"Transferring tokens back to sender failed!\");\r\n\t\t\t}\r\n    }\r\n\r\n\tfunction setStopDeposits(bool _state) external\r\n\t{\r\n\t\trequire(msg.sender == owner, \"This function is reserved for administration.\");\r\n\r\n\t\tstopDeposits = _state;\r\n\t}\r\n    \r\n    // Don't accept incoming ETH\r\n    fallback() external payable\r\n    {\r\n        revert(\"Please don't send funds directly to the ethbox smart contract.\");\r\n    }\r\n    \r\n    constructor()\r\n    {\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20Interface\r\n{\r\n    // Standard ERC 20 token interface\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address tokenOwner) external view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function approve(address spender, uint tokens) external returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"cancelAllNonPrivacyBoxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boxIndex\",\"type\":\"uint256\"}],\"name\":\"cancelBox\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boxIndex\",\"type\":\"uint256\"}],\"name\":\"cancelBoxWithPrivacy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boxIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_passHash\",\"type\":\"bytes32\"}],\"name\":\"clearBox\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boxIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_passHash\",\"type\":\"bytes32\"}],\"name\":\"clearBoxWithPrivacy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sendValue\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"_requestToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requestValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_passHashHash\",\"type\":\"bytes32\"}],\"name\":\"createBox\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_recipientHash\",\"type\":\"bytes32\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"_sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sendValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_passHashHash\",\"type\":\"bytes32\"}],\"name\":\"createBoxWithPrivacy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boxIndex\",\"type\":\"uint256\"}],\"name\":\"getBox\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"passHashHash\",\"type\":\"bytes32\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sendValue\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"requestToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"taken\",\"type\":\"bool\"}],\"internalType\":\"struct ethbox.Box\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boxIndex\",\"type\":\"uint256\"}],\"name\":\"getBoxWithPrivacy\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"senderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"passHashHash\",\"type\":\"bytes32\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sendValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"taken\",\"type\":\"bool\"}],\"internalType\":\"struct ethbox.BoxWithPrivacy\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxesAll\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"passHashHash\",\"type\":\"bytes32\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sendValue\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"requestToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requestValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"taken\",\"type\":\"bool\"}],\"internalType\":\"struct ethbox.Box[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxesAllWithPrivacy\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"senderHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recipientHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"passHashHash\",\"type\":\"bytes32\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"sendToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sendValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"taken\",\"type\":\"bool\"}],\"internalType\":\"struct ethbox.BoxWithPrivacy[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxesIncoming\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxesIncomingWithPrivacy\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxesOutgoing\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBoxesOutgoingWithPrivacy\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumBoxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumBoxesWithPrivacy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setStopDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopDeposits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ethbox", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5c094b23fdb1c2074c12f1559efb45d65066a93df9d7389135edae4fc22e1110"}