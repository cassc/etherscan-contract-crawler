{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/ve_dist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\n/*\\n\\n@title Curve Fee Distribution modified for ve(3,3) emissions\\n@author Curve Finance, andrecronje\\n@license MIT\\n\\n*/\\n\\ninterface erc20 {\\n    function totalSupply() external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address) external view returns (uint);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n}\\n\\nlibrary Math {\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n}\\n\\ninterface VotingEscrow {\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint ts;\\n        uint blk; // block\\n    }\\n\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\n\\n    function epoch() external view returns (uint);\\n\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\n\\n    function point_history(uint loc) external view returns (Point memory);\\n\\n    function checkpoint() external;\\n\\n    function deposit_for(uint tokenId, uint value) external;\\n\\n    function token() external view returns (address);\\n}\\n\\ncontract ve_dist {\\n    event CheckpointToken(uint time, uint tokens);\\n\\n    event Claimed(uint tokenId, uint amount, uint claim_epoch, uint max_epoch);\\n\\n    uint constant EPOCH = 1 days;\\n    int128 internal constant WAD = 1e9; //Must be consistent with ve's WAD\\n\\n    uint public start_time;\\n    uint public time_cursor;\\n    mapping(uint => uint) public time_cursor_of;\\n    mapping(uint => uint) public user_epoch_of;\\n\\n    uint public last_token_time;\\n    uint[1000000000000000] public tokens_per_day;\\n\\n    address public voting_escrow;\\n    address public token;\\n    uint public token_last_balance;\\n\\n    uint[1000000000000000] public ve_supply;\\n\\n    address public depositor;\\n\\n    constructor(address _voting_escrow) {\\n        uint _t = (block.timestamp / EPOCH) * EPOCH;\\n        start_time = _t;\\n        last_token_time = _t;\\n        time_cursor = _t;\\n        address _token = VotingEscrow(_voting_escrow).token();\\n        token = _token;\\n        voting_escrow = _voting_escrow;\\n        depositor = msg.sender;\\n        require(erc20(_token).approve(_voting_escrow, type(uint).max));\\n    }\\n\\n    function timestamp() external view returns (uint) {\\n        return (block.timestamp / EPOCH) * EPOCH;\\n    }\\n\\n    function _checkpoint_token() internal {\\n        uint token_balance = erc20(token).balanceOf(address(this));\\n        uint to_distribute = token_balance - token_last_balance;\\n        token_last_balance = token_balance;\\n\\n        uint t = last_token_time;\\n        uint since_last = block.timestamp - t;\\n        last_token_time = block.timestamp;\\n        uint this_day = (t / EPOCH) * EPOCH;\\n        uint next_day = 0;\\n\\n        for (uint i = 0; i < 20; i++) {\\n            next_day = this_day + EPOCH;\\n            if (block.timestamp < next_day) {\\n                // slither-disable-next-line incorrect-equality\\n                if (since_last == 0 && block.timestamp == t) {\\n                    tokens_per_day[this_day] += to_distribute;\\n                } else {\\n                    tokens_per_day[this_day] += (to_distribute * (block.timestamp - t)) / since_last;\\n                }\\n                break;\\n            } else {\\n                // slither-disable-next-line incorrect-equality\\n                if (since_last == 0 && next_day == t) {\\n                    tokens_per_day[this_day] += to_distribute;\\n                } else {\\n                    tokens_per_day[this_day] += (to_distribute * (next_day - t)) / since_last;\\n                }\\n            }\\n            t = next_day;\\n            this_day = next_day;\\n        }\\n        emit CheckpointToken(block.timestamp, to_distribute);\\n    }\\n\\n    function checkpoint_token() external {\\n        assert(msg.sender == depositor);\\n        _checkpoint_token();\\n    }\\n\\n    function _find_timestamp_epoch(address ve, uint _timestamp) internal view returns (uint) {\\n        uint _min = 0;\\n        uint _max = VotingEscrow(ve).epoch();\\n        for (uint i = 0; i < 128; i++) {\\n            if (_min >= _max) break;\\n            uint _mid = (_min + _max + 2) / 2;\\n            VotingEscrow.Point memory pt = VotingEscrow(ve).point_history(_mid);\\n            if (pt.ts <= _timestamp) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n        return _min;\\n    }\\n\\n    function _find_timestamp_user_epoch(\\n        address ve,\\n        uint tokenId,\\n        uint _timestamp,\\n        uint max_user_epoch\\n    ) internal view returns (uint) {\\n        uint _min = 0;\\n        uint _max = max_user_epoch;\\n        for (uint i = 0; i < 128; i++) {\\n            if (_min >= _max) break;\\n            uint _mid = (_min + _max + 2) / 2;\\n            VotingEscrow.Point memory pt = VotingEscrow(ve).user_point_history(tokenId, _mid);\\n            if (pt.ts <= _timestamp) {\\n                _min = _mid;\\n            } else {\\n                _max = _mid - 1;\\n            }\\n        }\\n        return _min;\\n    }\\n\\n    function ve_for_at(uint _tokenId, uint _timestamp) external view returns (uint) {\\n        address ve = voting_escrow;\\n        uint max_user_epoch = VotingEscrow(ve).user_point_epoch(_tokenId);\\n        uint epoch = _find_timestamp_user_epoch(ve, _tokenId, _timestamp, max_user_epoch);\\n        VotingEscrow.Point memory pt = VotingEscrow(ve).user_point_history(_tokenId, epoch);\\n        return Math.max(uint(int(pt.bias - (pt.slope * (int128(int(_timestamp - pt.ts)))) / WAD)), 0);\\n    }\\n\\n    function _checkpoint_total_supply() internal {\\n        address ve = voting_escrow;\\n        uint t = time_cursor;\\n        uint rounded_timestamp = (block.timestamp / EPOCH) * EPOCH;\\n        // slither-disable-next-line reentrancy-no-eth\\n        VotingEscrow(ve).checkpoint();\\n\\n        for (uint i = 0; i < 20; i++) {\\n            if (t > rounded_timestamp) {\\n                break;\\n            } else {\\n                uint epoch = _find_timestamp_epoch(ve, t);\\n                VotingEscrow.Point memory pt = VotingEscrow(ve).point_history(epoch);\\n                int128 dt = 0;\\n                if (t > pt.ts) {\\n                    dt = int128(int(t - pt.ts));\\n                }\\n                ve_supply[t] = Math.max(uint(int(pt.bias - (pt.slope * dt) / WAD)), 0);\\n            }\\n            t += EPOCH;\\n        }\\n        time_cursor = t;\\n    }\\n\\n    function checkpoint_total_supply() external {\\n        _checkpoint_total_supply();\\n    }\\n\\n    function _claim(\\n        uint _tokenId,\\n        address ve,\\n        uint _last_token_time\\n    ) internal returns (uint) {\\n        uint user_epoch = 0;\\n        uint to_distribute = 0;\\n\\n        uint max_user_epoch = VotingEscrow(ve).user_point_epoch(_tokenId);\\n        uint _start_time = start_time;\\n\\n        if (max_user_epoch == 0) return 0;\\n\\n        uint day_cursor = time_cursor_of[_tokenId];\\n        // slither-disable-next-line incorrect-equality\\n        if (day_cursor == 0) {\\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\\n        } else {\\n            user_epoch = user_epoch_of[_tokenId];\\n        }\\n\\n        if (user_epoch == 0) user_epoch = 1;\\n\\n        VotingEscrow.Point memory user_point = VotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\n        // slither-disable-next-line incorrect-equality\\n        if (day_cursor == 0) day_cursor = ((user_point.ts + EPOCH - 1) / EPOCH) * EPOCH;\\n        if (day_cursor >= last_token_time) return 0;\\n        if (day_cursor < _start_time) day_cursor = _start_time;\\n\\n        // slither-disable-next-line uninitialized-local\\n        VotingEscrow.Point memory old_user_point;\\n\\n        for (uint i = 0; i < 50; i++) {\\n            if (day_cursor >= _last_token_time) break;\\n\\n            if (day_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\\n                user_epoch += 1;\\n                old_user_point = user_point;\\n                if (user_epoch > max_user_epoch) {\\n                    user_point = VotingEscrow.Point(0, 0, 0, 0);\\n                } else {\\n                    user_point = VotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\n                }\\n            } else {\\n                int128 dt = int128(int(day_cursor - old_user_point.ts));\\n                uint balance_of = Math.max(uint(int(old_user_point.bias - (dt * old_user_point.slope) / WAD)), 0);\\n                // slither-disable-next-line incorrect-equality\\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\\n                if (balance_of > 0) {\\n                    to_distribute += (balance_of * tokens_per_day[day_cursor]) / ve_supply[day_cursor];\\n                }\\n                day_cursor += EPOCH;\\n            }\\n        }\\n\\n        user_epoch = Math.min(max_user_epoch, user_epoch - 1);\\n        user_epoch_of[_tokenId] = user_epoch;\\n        time_cursor_of[_tokenId] = day_cursor;\\n\\n        emit Claimed(_tokenId, to_distribute, user_epoch, max_user_epoch);\\n\\n        return to_distribute;\\n    }\\n\\n    function _claimable(\\n        uint _tokenId,\\n        address ve,\\n        uint _last_token_time\\n    ) internal view returns (uint) {\\n        uint user_epoch = 0;\\n        uint to_distribute = 0;\\n\\n        uint max_user_epoch = VotingEscrow(ve).user_point_epoch(_tokenId);\\n        uint _start_time = start_time;\\n\\n        if (max_user_epoch == 0) return 0;\\n\\n        uint day_cursor = time_cursor_of[_tokenId];\\n        // slither-disable-next-line incorrect-equality\\n        if (day_cursor == 0) {\\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\\n        } else {\\n            user_epoch = user_epoch_of[_tokenId];\\n        }\\n\\n        if (user_epoch == 0) user_epoch = 1;\\n\\n        VotingEscrow.Point memory user_point = VotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\n        // slither-disable-next-line incorrect-equality\\n        if (day_cursor == 0) day_cursor = ((user_point.ts + EPOCH - 1) / EPOCH) * EPOCH;\\n        if (day_cursor >= last_token_time) return 0;\\n        if (day_cursor < _start_time) day_cursor = _start_time;\\n\\n        // slither-disable-next-line uninitialized-local\\n        VotingEscrow.Point memory old_user_point;\\n\\n        for (uint i = 0; i < 50; i++) {\\n            if (day_cursor >= _last_token_time) break;\\n\\n            if (day_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\\n                user_epoch += 1;\\n                old_user_point = user_point;\\n                if (user_epoch > max_user_epoch) {\\n                    user_point = VotingEscrow.Point(0, 0, 0, 0);\\n                } else {\\n                    user_point = VotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\n                }\\n            } else {\\n                int128 dt = int128(int(day_cursor - old_user_point.ts));\\n                uint balance_of = Math.max(uint(int(old_user_point.bias - (dt * old_user_point.slope) / WAD)), 0);\\n                // slither-disable-next-line incorrect-equality\\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\\n                if (balance_of > 0) {\\n                    to_distribute += (balance_of * tokens_per_day[day_cursor]) / ve_supply[day_cursor];\\n                }\\n                day_cursor += EPOCH;\\n            }\\n        }\\n\\n        return to_distribute;\\n    }\\n\\n    function claimable(uint _tokenId) external view returns (uint) {\\n        uint _last_token_time = (last_token_time / EPOCH) * EPOCH;\\n        return _claimable(_tokenId, voting_escrow, _last_token_time);\\n    }\\n\\n    function claim(uint _tokenId) external returns (uint) {\\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\\n        uint _last_token_time = last_token_time;\\n        _last_token_time = (_last_token_time / EPOCH) * EPOCH;\\n        uint amount = _claim(_tokenId, voting_escrow, _last_token_time);\\n        if (amount != 0) {\\n            VotingEscrow(voting_escrow).deposit_for(_tokenId, amount);\\n            token_last_balance -= amount;\\n        }\\n        return amount;\\n    }\\n\\n    function claim_many(uint[] memory _tokenIds) external returns (bool) {\\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\\n        uint _last_token_time = last_token_time;\\n        _last_token_time = (_last_token_time / EPOCH) * EPOCH;\\n        address _voting_escrow = voting_escrow;\\n        uint total = 0;\\n\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\n            uint _tokenId = _tokenIds[i];\\n            if (_tokenId == 0) break;\\n            uint amount = _claim(_tokenId, _voting_escrow, _last_token_time);\\n            if (amount != 0) {\\n                VotingEscrow(_voting_escrow).deposit_for(_tokenId, amount);\\n                total += amount;\\n            }\\n        }\\n        if (total != 0) {\\n            token_last_balance -= total;\\n        }\\n\\n        return true;\\n    }\\n\\n    // Once off event on contract initialize\\n    function setDepositor(address _depositor) external {\\n        require(msg.sender == depositor);\\n        depositor = _depositor;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voting_escrow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"CheckpointToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claim_epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_epoch\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"checkpoint_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint_total_supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claim_many\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_token_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time_cursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"time_cursor_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_last_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens_per_day\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_epoch_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ve_for_at\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ve_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voting_escrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ve_dist", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000eb84193d6d8ebfed5848517a923b8dc84f3de0a7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}