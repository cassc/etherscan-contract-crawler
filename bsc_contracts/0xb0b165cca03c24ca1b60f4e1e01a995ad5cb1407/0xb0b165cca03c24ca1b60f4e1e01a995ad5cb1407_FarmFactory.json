{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `to`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `from` to `to` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the contract setting the deployer as the initial owner.\r\n   */\r\n  constructor() {\r\n    _transferOwnership(_msgSender());\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the current owner.\r\n   */\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(owner() == _msgSender(), 'Ownable: caller is not the owner');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Leaves the contract without owner. It will not be possible to call\r\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n   *\r\n   * NOTE: Renouncing ownership will leave the contract without an owner,\r\n   * thereby removing any functionality that is only available to the owner.\r\n   */\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Can only be called by the current owner.\r\n   */\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n   * Internal function without access restriction.\r\n   */\r\n  function _transferOwnership(address newOwner) internal virtual {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n\r\n// File: contracts/FarmsFeeManager.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\ncontract FarmsFeeManager is Ownable {\r\n  address public feeReceiver;\r\n  uint256 public deploymentFee;\r\n  uint256 public claimRewardsFee;\r\n  uint256 public referralFee;\r\n\r\n  mapping(address => bool) public isFarmExcludedFromFees;\r\n\r\n  constructor(\r\n    address payable _feeReceiver,\r\n    uint256 _deploymentFee,\r\n    uint256 _referralFee,\r\n    uint256 _claimRewardsFee\r\n  ) {\r\n    feeReceiver = _feeReceiver;\r\n    deploymentFee = _deploymentFee;\r\n    require(_referralFee <= 10**4 / 2, 'referralFee must be <= 50%');\r\n    referralFee = _referralFee;\r\n    require(claimRewardsFee <= 10**4 / 10, 'claimRewardsFee must be <= 10%');\r\n    claimRewardsFee = _claimRewardsFee;\r\n  }\r\n\r\n  function setFeeReceiver(address _feeReceiver) external onlyOwner {\r\n    feeReceiver = _feeReceiver;\r\n  }\r\n\r\n  function setDeploymentFee(uint256 _deploymentFee) external onlyOwner {\r\n    deploymentFee = _deploymentFee;\r\n  }\r\n\r\n  function setReferralFee(uint256 _referralFee) external onlyOwner {\r\n    require(_referralFee <= 10**4 / 2, 'referralFee must be <= 50%');\r\n    referralFee = _referralFee;\r\n  }\r\n\r\n  function setClaimRewardsFee(uint256 _claimRewardsFee) external onlyOwner {\r\n    require(_claimRewardsFee <= 10**4 / 10, 'claimRewardsFee must be <= 10%');\r\n    claimRewardsFee = _claimRewardsFee;\r\n  }\r\n\r\n  function setFarmExcludedFromFees(address _farm, bool _excluded)\r\n    external\r\n    onlyOwner\r\n  {\r\n    isFarmExcludedFromFees[_farm] = _excluded;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n   *\r\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n   * constructor.\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize/address.code.length, which returns 0\r\n    // for contracts in construction, since the code is only stored at the end\r\n    // of the constructor execution.\r\n\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    (bool success, ) = recipient.call{value: amount}('');\r\n    require(\r\n      success,\r\n      'Address: unable to send value, recipient may have reverted'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, 'Address: low-level call failed');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        'Address: low-level call with value failed'\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      'Address: insufficient balance for call'\r\n    );\r\n    require(isContract(target), 'Address: call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, 'Address: low-level static call failed');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), 'Address: static call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionDelegateCall(\r\n        target,\r\n        data,\r\n        'Address: low-level delegate call failed'\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a delegate call.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), 'Address: delegate call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n   * revert reason using the provided one.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transfer.selector, to, value)\r\n    );\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Deprecated. This function has issues similar to the ones found in\r\n   * {IERC20-approve}, and its usage is discouraged.\r\n   *\r\n   * Whenever possible, use {safeIncreaseAllowance} and\r\n   * {safeDecreaseAllowance} instead.\r\n   */\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      'SafeERC20: approve from non-zero to non-zero allowance'\r\n    );\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, value)\r\n    );\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n    );\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    unchecked {\r\n      uint256 oldAllowance = token.allowance(address(this), spender);\r\n      require(\r\n        oldAllowance >= value,\r\n        'SafeERC20: decreased allowance below zero'\r\n      );\r\n      uint256 newAllowance = oldAllowance - value;\r\n      _callOptionalReturn(\r\n        token,\r\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n   * @param token The token targeted by the call.\r\n   * @param data The call data (encoded using abi.encode or one of its variants).\r\n   */\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n    // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n    bytes memory returndata = address(token).functionCall(\r\n      data,\r\n      'SafeERC20: low-level call failed'\r\n    );\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      require(\r\n        abi.decode(returndata, (bool)),\r\n        'SafeERC20: ERC20 operation did not succeed'\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Set type with\r\n  // bytes32 values.\r\n  // The Set implementation uses private functions, and user-facing\r\n  // implementations (such as AddressSet) are just wrappers around the\r\n  // underlying Set.\r\n  // This means that we can only create new EnumerableSets for types that fit\r\n  // in bytes32.\r\n\r\n  struct Set {\r\n    // Storage of set values\r\n    bytes32[] _values;\r\n    // Position of the value in the `values` array, plus 1 because index 0\r\n    // means a value is not in the set.\r\n    mapping(bytes32 => uint256) _indexes;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function _add(Set storage set, bytes32 value) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      // The value is stored at length-1, but we add 1 to all indexes\r\n      // and use 0 as a sentinel value\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n    // We read and store the value's index to prevent multiple reads from the same storage slot\r\n    uint256 valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      // Equivalent to contains(set, value)\r\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n      // This modifies the order of the array, as noted in {at}.\r\n\r\n      uint256 toDeleteIndex = valueIndex - 1;\r\n      uint256 lastIndex = set._values.length - 1;\r\n\r\n      if (lastIndex != toDeleteIndex) {\r\n        bytes32 lastvalue = set._values[lastIndex];\r\n\r\n        // Move the last value to the index where the value to delete is\r\n        set._values[toDeleteIndex] = lastvalue;\r\n        // Update the index for the moved value\r\n        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n      }\r\n\r\n      // Delete the slot where the moved value was stored\r\n      set._values.pop();\r\n\r\n      // Delete the index for the deleted slot\r\n      delete set._indexes[value];\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function _contains(Set storage set, bytes32 value)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function _length(Set storage set) private view returns (uint256) {\r\n    return set._values.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n    return set._values[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function _values(Set storage set) private view returns (bytes32[] memory) {\r\n    return set._values;\r\n  }\r\n\r\n  // Bytes32Set\r\n\r\n  struct Bytes32Set {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _add(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(Bytes32Set storage set, bytes32 value)\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return _remove(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(Bytes32Set storage set, bytes32 value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(Bytes32Set storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(Bytes32Set storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return _at(set._inner, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(Bytes32Set storage set)\r\n    internal\r\n    view\r\n    returns (bytes32[] memory)\r\n  {\r\n    return _values(set._inner);\r\n  }\r\n\r\n  // AddressSet\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(AddressSet storage set, address value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(AddressSet storage set, address value)\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(AddressSet storage set, address value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n   */\r\n  function length(AddressSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(AddressSet storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (address)\r\n  {\r\n    return address(uint160(uint256(_at(set._inner, index))));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(AddressSet storage set)\r\n    internal\r\n    view\r\n    returns (address[] memory)\r\n  {\r\n    bytes32[] memory store = _values(set._inner);\r\n    address[] memory result;\r\n\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // UintSet\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n   *\r\n   * Returns true if the value was added to the set, that is if it was not\r\n   * already present.\r\n   */\r\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n   *\r\n   * Returns true if the value was removed from the set, that is if it was\r\n   * present.\r\n   */\r\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n   */\r\n  function contains(UintSet storage set, uint256 value)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n   */\r\n  function length(UintSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n   *\r\n   * Note that there are no guarantees on the ordering of values inside the\r\n   * array, and it may change when more values are added or removed.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `index` must be strictly less than {length}.\r\n   */\r\n  function at(UintSet storage set, uint256 index)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return uint256(_at(set._inner, index));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n   *\r\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n   */\r\n  function values(UintSet storage set)\r\n    internal\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    bytes32[] memory store = _values(set._inner);\r\n    uint256[] memory result;\r\n\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      uint256 c = a + b;\r\n      if (c < a) return (false, 0);\r\n      return (true, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (b > a) return (false, 0);\r\n      return (true, a - b);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n      // benefit is lost if 'b' is also tested.\r\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n      if (a == 0) return (true, 0);\r\n      uint256 c = a * b;\r\n      if (c / a != b) return (false, 0);\r\n      return (true, c);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (b == 0) return (false, 0);\r\n      return (true, a / b);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n   *\r\n   * _Available since v3.4._\r\n   */\r\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n    unchecked {\r\n      if (b == 0) return (false, 0);\r\n      return (true, a % b);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a + b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a * b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers, reverting on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * reverting when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a % b;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n   * message unnecessarily. For custom revert reasons use {trySub}.\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b <= a, errorMessage);\r\n      return a - b;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b > 0, errorMessage);\r\n      return a / b;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * reverting with custom message when dividing by zero.\r\n   *\r\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n   * message unnecessarily. For custom revert reasons use {tryMod}.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    unchecked {\r\n      require(b > 0, errorMessage);\r\n      return a % b;\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/Farm.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Farm is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint256 public constant VERSION = 1;\r\n  FarmsFeeManager public feeManager;\r\n  address public creator;\r\n\r\n  // Info of each user.\r\n  struct UserInfo {\r\n    uint256 depositedAt; // The block number when the user deposited LP.\r\n    uint256 amount; // How many LP tokens the user has provided.\r\n    uint256 rewardDebt; // Reward debt. See explanation below.\r\n    //\r\n    // We do some fancy math here. Basically, any point in time, the amount of ERC20s\r\n    // entitled to a user but is pending to be distributed is:\r\n    //\r\n    //   pending reward = (user.amount * pool.accERC20PerShare) - user.rewardDebt\r\n    //\r\n    // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n    //   1. The pool's `accERC20PerShare` (and `lastRewardBlock`) gets updated.\r\n    //   2. User receives the pending reward sent to his/her address.\r\n    //   3. User's `amount` gets updated.\r\n    //   4. User's `rewardDebt` gets updated.\r\n  }\r\n\r\n  // Info of each pool.\r\n  struct PoolInfo {\r\n    IERC20 lpToken; // Address of LP token contract.\r\n    uint256 lockPeriod; // How many blocks the LP token is locked.\r\n    uint256 earlyWithdrawFee; // Early withdraw fee in percentage.\r\n    uint256 allocPoint; // How many allocation points assigned to this pool. ERC20s to distribute per block.\r\n    uint256 lastRewardBlock; // Last block number that ERC20s distribution occurs.\r\n    uint256 accERC20PerShare; // Accumulated ERC20s per share, times 1e36.\r\n  }\r\n\r\n  // Address of the ERC20 Token contract.\r\n  IERC20 public erc20;\r\n  // The total amount of ERC20 that's paid out as reward.\r\n  uint256 public paidOut = 0;\r\n  // ERC20 tokens rewarded per block.\r\n  uint256 public rewardPerBlock;\r\n\r\n  // Info of each pool.\r\n  PoolInfo[] public poolInfo;\r\n  // Info of each user that stakes LP tokens.\r\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n  // Total allocation points. Must be the sum of all allocation points in all pools.\r\n  uint256 public totalAllocPoint = 0;\r\n  // Total amount of users that are staking LP tokens.\r\n  mapping(uint256 => uint256) public usersCount;\r\n\r\n  // The block number when farming starts.\r\n  uint256 public startBlock;\r\n  // The block number when farming ends.\r\n  uint256 public endBlock;\r\n\r\n  // The current lp supply.\r\n  uint256 public lpSupply;\r\n\r\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n  event RewardUser(\r\n    address indexed user,\r\n    uint256 indexed pid,\r\n    uint256 amount,\r\n    uint256 fee\r\n  );\r\n  event CollectFee(\r\n    address indexed user,\r\n    address indexed recipient,\r\n    uint256 indexed pid,\r\n    uint256 amount\r\n  );\r\n  event EmergencyWithdraw(\r\n    address indexed user,\r\n    uint256 indexed pid,\r\n    uint256 amount\r\n  );\r\n\r\n  constructor(\r\n    IERC20 _erc20,\r\n    uint256 _rewardPerBlock,\r\n    uint256 _startBlock,\r\n    address _creator,\r\n    address _feeManager\r\n  ) {\r\n    erc20 = _erc20;\r\n    rewardPerBlock = _rewardPerBlock;\r\n    startBlock = _startBlock;\r\n    endBlock = _startBlock;\r\n    creator = _creator;\r\n\r\n    feeManager = FarmsFeeManager(_feeManager);\r\n  }\r\n\r\n  function deploymentFee() public view returns (uint256) {\r\n    return feeManager.deploymentFee();\r\n  }\r\n\r\n  function claimRewardsFee() public view returns (uint256) {\r\n    return feeManager.claimRewardsFee();\r\n  }\r\n\r\n  function hasClaimRewardsFee() public view returns (bool) {\r\n    return !feeManager.isFarmExcludedFromFees(address(this));\r\n  }\r\n\r\n  function feeReceiver() public view returns (address) {\r\n    return feeManager.feeReceiver();\r\n  }\r\n\r\n  // Number of LP pools\r\n  function poolLength() external view returns (uint256) {\r\n    return poolInfo.length;\r\n  }\r\n\r\n  // Fund the farm, increase the end block\r\n  function fund(uint256 _amount) public {\r\n    require(block.number < endBlock, 'Farm.fund: too late, the farm is closed');\r\n\r\n    uint256 beforeBalance = erc20.balanceOf(address(this));\r\n\r\n    erc20.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\r\n    // calculate difference to avoid issues with token fees\r\n    uint256 difference = erc20.balanceOf(address(this)).sub(beforeBalance);\r\n\r\n    endBlock += difference.div(rewardPerBlock);\r\n  }\r\n\r\n  // Add a new lp to the pool. Can only be called by the owner.\r\n  // DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n  // If _lockPeriod = 0 it will be ignored.\r\n  function add(\r\n    uint256 _allocPoint,\r\n    IERC20 _lpToken,\r\n    uint256 _lockPeriod,\r\n    uint256 _earlyWithdrawFee,\r\n    bool _withUpdate\r\n  ) public onlyOwner {\r\n    require(\r\n      _earlyWithdrawFee <= 10**4 / 4,\r\n      'Farm.add: earlyWithdrawFee must be <= 25%'\r\n    );\r\n    require(_allocPoint > 0, 'Farm.add: allocPoint must be > 0');\r\n    require(_lockPeriod >= 0, 'Farm.add: lockPeriod must be >= 0');\r\n    for (uint256 index = 0; index < poolInfo.length; index++) {\r\n      require(\r\n        poolInfo[index].lpToken != _lpToken,\r\n        'Farm.add: you can not add the same LP token twice'\r\n      );\r\n    }\r\n    if (_withUpdate) {\r\n      massUpdatePools();\r\n    }\r\n    uint256 lastRewardBlock = block.number > startBlock\r\n      ? block.number\r\n      : startBlock;\r\n    totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n    poolInfo.push(\r\n      PoolInfo({\r\n        lpToken: _lpToken,\r\n        allocPoint: _allocPoint,\r\n        lockPeriod: _lockPeriod,\r\n        earlyWithdrawFee: _earlyWithdrawFee,\r\n        lastRewardBlock: lastRewardBlock,\r\n        accERC20PerShare: 0\r\n      })\r\n    );\r\n  }\r\n\r\n  // Update the given pool's ERC20 allocation point. Can only be called by the owner.\r\n  function set(\r\n    uint256 _pid,\r\n    uint256 _allocPoint,\r\n    uint256 _lockPeriod,\r\n    uint256 _earlyWithdrawFee,\r\n    bool _withUpdate\r\n  ) public onlyOwner {\r\n    if (_withUpdate) {\r\n      massUpdatePools();\r\n    }\r\n    totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\r\n      _allocPoint\r\n    );\r\n    poolInfo[_pid].allocPoint = _allocPoint;\r\n    poolInfo[_pid].lockPeriod = _lockPeriod;\r\n    poolInfo[_pid].earlyWithdrawFee = _earlyWithdrawFee;\r\n  }\r\n\r\n  // View function to see deposited LP for a user.\r\n  function deposited(uint256 _pid, address _user)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    UserInfo storage user = userInfo[_pid][_user];\r\n    return user.amount;\r\n  }\r\n\r\n  // View function to see pending ERC20s for a user.\r\n  function pending(uint256 _pid, address _user)\r\n    external\r\n    view\r\n    returns (uint256)\r\n  {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][_user];\r\n    uint256 accERC20PerShare = pool.accERC20PerShare;\r\n    uint256 lastBlock = block.number < endBlock ? block.number : endBlock;\r\n\r\n    if (\r\n      lastBlock > pool.lastRewardBlock &&\r\n      block.number > pool.lastRewardBlock &&\r\n      lpSupply != 0\r\n    ) {\r\n      uint256 nrOfBlocks = lastBlock.sub(pool.lastRewardBlock);\r\n      uint256 erc20Reward = nrOfBlocks\r\n        .mul(rewardPerBlock)\r\n        .mul(pool.allocPoint)\r\n        .div(totalAllocPoint);\r\n      accERC20PerShare = accERC20PerShare.add(\r\n        erc20Reward.mul(1e36).div(lpSupply)\r\n      );\r\n    }\r\n\r\n    return user.amount.mul(accERC20PerShare).div(1e36).sub(user.rewardDebt);\r\n  }\r\n\r\n  // View function for total reward the farm has yet to pay out.\r\n  function totalPending() external view returns (uint256) {\r\n    if (block.number <= startBlock) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 lastBlock = block.number < endBlock ? block.number : endBlock;\r\n    return rewardPerBlock.mul(lastBlock - startBlock).sub(paidOut);\r\n  }\r\n\r\n  // Update reward variables for all pools. Be careful of gas spending!\r\n  function massUpdatePools() public {\r\n    uint256 length = poolInfo.length;\r\n    for (uint256 pid = 0; pid < length; ++pid) {\r\n      updatePool(pid);\r\n    }\r\n  }\r\n\r\n  // Update reward variables of the given pool to be up-to-date.\r\n  function updatePool(uint256 _pid) public {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    uint256 lastBlock = block.number < endBlock ? block.number : endBlock;\r\n\r\n    if (lastBlock <= pool.lastRewardBlock) {\r\n      return;\r\n    }\r\n\r\n    if (lpSupply == 0) {\r\n      pool.lastRewardBlock = lastBlock;\r\n      return;\r\n    }\r\n\r\n    uint256 nrOfBlocks = lastBlock.sub(pool.lastRewardBlock);\r\n    uint256 erc20Reward = nrOfBlocks\r\n      .mul(rewardPerBlock)\r\n      .mul(pool.allocPoint)\r\n      .div(totalAllocPoint);\r\n\r\n    pool.accERC20PerShare = pool.accERC20PerShare.add(\r\n      erc20Reward.mul(1e36).div(lpSupply)\r\n    );\r\n    pool.lastRewardBlock = block.number;\r\n  }\r\n\r\n  // Deposit LP tokens to Farm for ERC20 allocation.\r\n  function deposit(\r\n    uint256 _pid,\r\n    uint256 _amount,\r\n    address _to\r\n  ) external onlyOwner {\r\n    require(_amount > 0, 'Farm.deposit: amount must be > 0');\r\n\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][_to];\r\n\r\n    if (user.amount == 0) {\r\n      usersCount[_pid]++;\r\n    }\r\n\r\n    updatePool(_pid);\r\n\r\n    _rewardUser(_pid, _to);\r\n\r\n    uint256 beforeBalance = pool.lpToken.balanceOf(address(this));\r\n\r\n    pool.lpToken.safeTransferFrom(address(_to), address(this), _amount);\r\n\r\n    // calculate difference to avoid issues with token fees\r\n    uint256 difference = pool.lpToken.balanceOf(address(this)).sub(\r\n      beforeBalance\r\n    );\r\n\r\n    lpSupply = lpSupply.add(difference);\r\n\r\n    user.depositedAt = block.number;\r\n    user.amount = user.amount.add(_amount);\r\n    user.rewardDebt = user.amount.mul(pool.accERC20PerShare).div(1e36);\r\n\r\n    emit Deposit(_to, _pid, _amount);\r\n  }\r\n\r\n  // Withdraw LP tokens from Farm.\r\n  function withdraw(\r\n    uint256 _pid,\r\n    uint256 _amount,\r\n    address _to\r\n  ) external onlyOwner {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][_to];\r\n    require(\r\n      user.amount > 0,\r\n      \"Farm.withdraw: can't withdraw from user with no LP tokens deposited\"\r\n    );\r\n    require(\r\n      user.amount >= _amount,\r\n      \"Farm.withdraw: can't withdraw more than deposited amount\"\r\n    );\r\n    updatePool(_pid);\r\n\r\n    _rewardUser(_pid, _to);\r\n\r\n    user.amount = user.amount.sub(_amount);\r\n    user.rewardDebt = user.amount.mul(pool.accERC20PerShare).div(1e36);\r\n    pool.lpToken.safeTransfer(address(_to), _amount);\r\n    lpSupply = lpSupply.sub(_amount);\r\n\r\n    if (user.amount == 0) {\r\n      usersCount[_pid]--;\r\n    }\r\n\r\n    emit Withdraw(_to, _pid, _amount);\r\n  }\r\n\r\n  // Transfer, if necessary, rewards to a specific address and charge fees if applied.\r\n  function _rewardUser(uint256 _pid, address _address) internal {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][_address];\r\n    if (user.amount > 0) {\r\n      uint256 pendingAmount = user\r\n        .amount\r\n        .mul(pool.accERC20PerShare)\r\n        .div(1e36)\r\n        .sub(user.rewardDebt);\r\n      uint256 rewards = pendingAmount;\r\n      uint256 totalFee = 0;\r\n\r\n      // Check and charge claim rewards fee\r\n      if (hasClaimRewardsFee() && claimRewardsFee() > 0) {\r\n        uint256 fee = (rewards * claimRewardsFee()) / 10**4;\r\n        totalFee += fee;\r\n        erc20Transfer(feeReceiver(), fee);\r\n        rewards -= fee;\r\n        emit CollectFee(_address, feeReceiver(), _pid, fee);\r\n      }\r\n\r\n      // Check and charge early withdraw fee\r\n      if (\r\n        pool.lockPeriod > 0 && // lock period is set\r\n        pool.earlyWithdrawFee > 0 && // early withdraw fee is set\r\n        pendingAmount > 0 && // there is pending rewards\r\n        (user.depositedAt + pool.lockPeriod) > block.number // user is in lock period\r\n      ) {\r\n        uint256 fee = (rewards * pool.earlyWithdrawFee) / 10**4;\r\n        totalFee += fee;\r\n        erc20Transfer(creator, fee);\r\n        rewards -= fee;\r\n        emit CollectFee(_address, creator, _pid, fee);\r\n      }\r\n\r\n      // Transfer rewards to user\r\n      erc20Transfer(_address, rewards);\r\n      emit RewardUser(_address, _pid, rewards, totalFee);\r\n    }\r\n  }\r\n\r\n  // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n  function emergencyWithdraw(uint256 _pid, address _address) public onlyOwner {\r\n    PoolInfo storage pool = poolInfo[_pid];\r\n    UserInfo storage user = userInfo[_pid][_address];\r\n    pool.lpToken.safeTransfer(_address, user.amount);\r\n    emit EmergencyWithdraw(_address, _pid, user.amount);\r\n    user.amount = 0;\r\n    user.rewardDebt = 0;\r\n  }\r\n\r\n  function emergencyRecovery() external onlyOwner {\r\n    uint256 erc20Balance = erc20.balanceOf(address(this));\r\n    if (erc20Balance > 0) {\r\n      erc20Transfer(creator, erc20Balance);\r\n    }\r\n  }\r\n\r\n  // Transfer ERC20 and update the required ERC20 to payout all rewards\r\n  function erc20Transfer(address _to, uint256 _amount) internal {\r\n    erc20.transfer(_to, _amount);\r\n    paidOut += _amount;\r\n  }\r\n}\r\n\r\n// File: contracts/FarmFactory.sol\r\n\r\npragma solidity =0.8.7;\r\n\r\ncontract FarmFactory is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public constant VERSION = 1;\r\n\r\n  FarmsFeeManager public feeManager;\r\n\r\n  bool public isEnabled = true;\r\n\r\n  event FarmCreated(address indexed owner, address indexed token, address farm);\r\n  event CollectDeploymentFee(\r\n    address indexed receiver,\r\n    address indexed sender,\r\n    uint256 amount\r\n  );\r\n  event CollectReferralFee(\r\n    address indexed receiver,\r\n    address indexed sender,\r\n    uint256 amount\r\n  );\r\n\r\n  Farm[] public farms;\r\n\r\n  struct UserFarm {\r\n    Farm farm;\r\n    uint256 deposited;\r\n  }\r\n\r\n  mapping(address => UserFarm[]) public userFarms;\r\n\r\n  struct CreateFarmParams {\r\n    // constructor\r\n    IERC20 erc20;\r\n    uint256 rewardPerBlock;\r\n    uint256 startBlock;\r\n    // add\r\n    IERC20 lpToken;\r\n    uint256 lockPeriod;\r\n    uint256 earlyWithdrawFee;\r\n    // fund\r\n    uint256 amount;\r\n    // referral\r\n    address referral;\r\n  }\r\n\r\n  constructor(\r\n    address payable _feeReceiver,\r\n    uint256 _deploymentFee,\r\n    uint256 _referralFee,\r\n    uint256 _claimRewardsFee\r\n  ) {\r\n    feeManager = new FarmsFeeManager(\r\n      _feeReceiver,\r\n      _deploymentFee,\r\n      _referralFee,\r\n      _claimRewardsFee\r\n    );\r\n    feeManager.transferOwnership(msg.sender);\r\n  }\r\n\r\n  function deploymentFee() public view returns (uint256) {\r\n    return feeManager.deploymentFee();\r\n  }\r\n\r\n  function referralFee() public view returns (uint256) {\r\n    return feeManager.referralFee();\r\n  }\r\n\r\n  function claimRewardsFee() public view returns (uint256) {\r\n    return feeManager.claimRewardsFee();\r\n  }\r\n\r\n  function feeReceiver() public view returns (address) {\r\n    return feeManager.feeReceiver();\r\n  }\r\n\r\n  function _deploy(CreateFarmParams memory info) internal {\r\n    require(isEnabled, 'FarmFactory.deploy: deployments are disabled');\r\n\r\n    Farm farm = new Farm(\r\n      info.erc20,\r\n      info.rewardPerBlock,\r\n      info.startBlock,\r\n      msg.sender,\r\n      address(feeManager)\r\n    );\r\n\r\n    farm.add(1, info.lpToken, info.lockPeriod, info.earlyWithdrawFee, false);\r\n\r\n    info.erc20.transferFrom(msg.sender, address(this), info.amount);\r\n    info.erc20.approve(address(farm), info.amount);\r\n    farm.fund(info.amount);\r\n\r\n    farms.push(farm);\r\n\r\n    emit FarmCreated(msg.sender, address(info.erc20), address(farm));\r\n  }\r\n\r\n  function _payDeploymentFee(uint256 _deploymentFee) internal {\r\n    (bool sent, ) = feeReceiver().call{value: _deploymentFee}('');\r\n    require(sent, 'FarmFactory.deploy: failed to pay deployment fee');\r\n\r\n    emit CollectDeploymentFee(feeReceiver(), msg.sender, _deploymentFee);\r\n  }\r\n\r\n  function _payReferralFee(uint256 _referralFee, address referrer) internal {\r\n    (bool sentReferralFee, ) = referrer.call{value: _referralFee}('');\r\n    require(sentReferralFee, 'FarmFactory.deploy: failed to pay referral fee');\r\n\r\n    emit CollectReferralFee(referrer, msg.sender, _referralFee);\r\n  }\r\n\r\n  function deploy(CreateFarmParams memory info) public payable {\r\n    _deploy(info);\r\n\r\n    uint256 _referralFee = 0;\r\n\r\n    if (info.referral != address(0)) {\r\n      _referralFee = deploymentFee().mul(referralFee()).div(10**4);\r\n      _payReferralFee(_referralFee, info.referral);\r\n    }\r\n\r\n    _payDeploymentFee(deploymentFee().sub(_referralFee));\r\n  }\r\n\r\n  function farmsLength() external view returns (uint256) {\r\n    return farms.length;\r\n  }\r\n\r\n  function setIsEnabled(bool _isEnabled) external onlyOwner {\r\n    isEnabled = _isEnabled;\r\n  }\r\n\r\n  function deposit(address farmAddress, uint256 amount) external {\r\n    require(amount > 0, 'FarmFactory.deposit: amount must be greater than 0');\r\n\r\n    UserFarm[] storage _userFarms = userFarms[msg.sender];\r\n    UserFarm memory farm;\r\n    bool found = false;\r\n\r\n    uint256 index = 0;\r\n\r\n    for (index = 0; index < _userFarms.length; index++) {\r\n      if (address(_userFarms[index].farm) == farmAddress) {\r\n        farm = _userFarms[index];\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    Farm farmInstance = Farm(farmAddress);\r\n    farmInstance.deposit(0, amount, msg.sender);\r\n\r\n    farm.farm = farmInstance;\r\n    farm.deposited = farm.deposited + amount;\r\n\r\n    if (found) {\r\n      _userFarms[index] = farm;\r\n      return;\r\n    }\r\n\r\n    _userFarms.push(farm);\r\n    userFarms[msg.sender] = _userFarms;\r\n  }\r\n\r\n  function withdraw(address farmAddress, uint256 amount) external {\r\n    UserFarm[] storage _userFarms = userFarms[msg.sender];\r\n    UserFarm memory farm;\r\n    bool found = false;\r\n\r\n    uint256 index = 0;\r\n\r\n    for (index = 0; index < _userFarms.length; index++) {\r\n      if (address(_userFarms[index].farm) == farmAddress) {\r\n        farm = _userFarms[index];\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    Farm farmInstance = Farm(farmAddress);\r\n    farmInstance.withdraw(0, amount, msg.sender);\r\n\r\n    farm.farm = farmInstance;\r\n    farm.deposited = farm.deposited - amount;\r\n\r\n    if (found) {\r\n      _userFarms[index] = farm;\r\n      return;\r\n    }\r\n\r\n    _userFarms.push(farm);\r\n    userFarms[msg.sender] = _userFarms;\r\n  }\r\n\r\n  function emergencyWithdraw(address farmAddress, uint256 amount) external {\r\n    UserFarm[] storage _userFarms = userFarms[msg.sender];\r\n    UserFarm memory farm;\r\n    bool found = false;\r\n\r\n    uint256 index = 0;\r\n\r\n    for (index = 0; index < _userFarms.length; index++) {\r\n      if (address(_userFarms[index].farm) == farmAddress) {\r\n        farm = _userFarms[index];\r\n        found = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    Farm farmInstance = Farm(farmAddress);\r\n    farmInstance.emergencyWithdraw(0, msg.sender);\r\n\r\n    farm.farm = farmInstance;\r\n    farm.deposited = farm.deposited - amount;\r\n\r\n    if (found) {\r\n      _userFarms[index] = farm;\r\n      return;\r\n    }\r\n\r\n    _userFarms.push(farm);\r\n    userFarms[msg.sender] = _userFarms;\r\n  }\r\n\r\n  function emergencyRecovery(address farm) external onlyOwner {\r\n    Farm farmInstance = Farm(farm);\r\n    farmInstance.emergencyRecovery();\r\n  }\r\n\r\n  function pending(address farm) external view returns (uint256) {\r\n    Farm farmInstance = Farm(farm);\r\n    uint256 pendingRewards = farmInstance.pending(0, msg.sender);\r\n    return pendingRewards;\r\n  }\r\n\r\n  function userFarmsLength(address user) external view returns (uint256) {\r\n    UserFarm[] storage _userFarms = userFarms[user];\r\n    return _userFarms.length;\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deploymentFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referralFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimRewardsFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollectDeploymentFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollectReferralFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farm\",\"type\":\"address\"}],\"name\":\"FarmCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earlyWithdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"internalType\":\"struct FarmFactory.CreateFarmParams\",\"name\":\"info\",\"type\":\"tuple\"}],\"name\":\"deploy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farm\",\"type\":\"address\"}],\"name\":\"emergencyRecovery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"farms\",\"outputs\":[{\"internalType\":\"contract Farm\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeManager\",\"outputs\":[{\"internalType\":\"contract FarmsFeeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farm\",\"type\":\"address\"}],\"name\":\"pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setIsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userFarms\",\"outputs\":[{\"internalType\":\"contract Farm\",\"name\":\"farm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userFarmsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"farmAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FarmFactory", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000020337f3a0182cd08bf0a1de9dcfa997681c77fc70000000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000000000000000000000000000000000000000009c40000000000000000000000000000000000000000000000000000000000000096", "EVMVersion": "constantinople", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://717d3bc420f328a5123d64cbd59127e9421e58f437f6217e16d014ad44f9862d"}