{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.18;\r\n\r\ninterface IFactory {\r\n    function isOperator(address) external view returns (bool);\r\n}\r\ninterface JsonTool {\r\n    struct JsonValue {\r\n        bool executeFlag;\r\n        string p;\r\n        string op;\r\n        string tick;\r\n        uint256 max;\r\n        uint256 lim;\r\n        uint256 amt;\r\n        address receiver;\r\n        uint256 price;\r\n        uint256 listid;\r\n    }\r\n    function parseJsonAndExecute(string calldata content) external pure returns (JsonValue memory);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract SRC20 is IERC20 {\r\n    uint256 public _maxSupply;\r\n    uint256 public _amountPerMint;\r\n    uint256 public _totalMinted;\r\n    address public _factory;\r\n    uint public holderAmount;\r\n    uint public txAmount;\r\n    uint public deployTime;\r\n\r\n\r\n    mapping(address => uint256) private _balances;\r\n    uint256 private _totalSupply;\r\n\r\n    constructor(\r\n        uint256 maxSupply,\r\n        uint256 amountPerMint,\r\n        address factory\r\n    ){\r\n        _maxSupply = maxSupply;\r\n        _amountPerMint = amountPerMint;\r\n        _factory = factory;\r\n\r\n        _totalMinted = 0;\r\n        deployTime = block.timestamp;\r\n    }\r\n\r\n\r\n    function mint(address to, uint256 amount) external {\r\n        require(msg.sender == _factory, \"only factory can mint\");\r\n        uint256 mintAmount = amount;\r\n        require(mintAmount <= _amountPerMint, \"amount exceeds limit\");\r\n        require(_totalMinted + mintAmount <= _maxSupply, \"max supply exceeded\");\r\n        _mint(to, mintAmount);\r\n        _totalMinted += mintAmount;\r\n    }\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    \r\n    function decimals() public pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns(uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"transfer from the zero address\");\r\n        require(recipient != address(0), \"transfer to the zero address\");\r\n        require(IFactory(_factory).isOperator(msg.sender), \"!operator\");\r\n        require(amount > 0, \"transfer 0\");\r\n\r\n        if(balanceOf(recipient) == 0) holderAmount++;\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"transfer amount exceeds balance\");\r\n        \r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n            _balances[recipient] += amount;\r\n        }\r\n        if(balanceOf(sender) == 0) holderAmount--;\r\n        txAmount++;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"mint to the zero address\");\r\n\r\n        if(balanceOf(account) == 0) holderAmount++;\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            _balances[account] += amount;\r\n        }\r\n        txAmount++;\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    struct Counter {\r\n        uint256 _value; \r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\nlibrary JsmnSolLib {\r\n\r\n    enum JsmnType { UNDEFINED, OBJECT, ARRAY, STRING, PRIMITIVE }\r\n\r\n    uint constant RETURN_SUCCESS = 0;\r\n    uint constant RETURN_ERROR_INVALID_JSON = 1;\r\n    uint constant RETURN_ERROR_PART = 2;\r\n    uint constant RETURN_ERROR_NO_MEM = 3;\r\n\r\n    string constant FTMS_HEADER_HASH = \"data:application/json,\";\r\n    string constant SRC20_OP_HASH_DEPLOY = \"deploy\";\r\n    string constant SRC20_OP_HASH_MINT = \"mint\";\r\n    string constant SRC20_OP_HASH_TRANSFER = \"transfer\";\r\n    string constant SRC20_OP_HASH_LIST = \"list\";\r\n    string constant SRC20_OP_HASH_UNLIST = \"unlist\";\r\n    string constant SRC20_OP_HASH_BUY = \"buy\";\r\n\r\n    struct Token {\r\n        JsmnType jsmnType;\r\n        uint start;\r\n        bool startSet;\r\n        uint end;\r\n        bool endSet;\r\n        uint8 size;\r\n    }\r\n\r\n    struct Parser {\r\n        uint pos;\r\n        uint toknext;\r\n        int toksuper;\r\n    }\r\n\r\n    function init(uint length) internal pure returns (Parser memory, Token[] memory) {\r\n        Parser memory p = Parser(0, 0, -1);\r\n        Token[] memory t = new Token[](length);\r\n        return (p, t);\r\n    }\r\n\r\n    function allocateToken(Parser memory parser, Token[] memory tokens) internal pure returns (bool, Token memory) {\r\n        if (parser.toknext >= tokens.length) {\r\n\r\n            return (false, tokens[tokens.length-1]);\r\n        }\r\n        Token memory token = Token(JsmnType.UNDEFINED, 0, false, 0, false, 0);\r\n        tokens[parser.toknext] = token;\r\n        parser.toknext++;\r\n        return (true, token);\r\n    }\r\n\r\n    function fillToken(Token memory token, JsmnType jsmnType, uint start, uint end) internal pure {\r\n        token.jsmnType = jsmnType;\r\n        token.start = start;\r\n        token.startSet = true;\r\n        token.end = end;\r\n        token.endSet = true;\r\n        token.size = 0;\r\n    }\r\n\r\n    function parseString(Parser memory parser, Token[] memory tokens, bytes memory s) internal pure returns (uint) {\r\n        uint start = parser.pos;\r\n        bool success;\r\n        Token memory token;\r\n        parser.pos++;\r\n\r\n        for (; parser.pos<s.length; parser.pos++) {\r\n            bytes1 c = s[parser.pos];\r\n\r\n   \r\n            if (c == '\"') {\r\n                (success, token) = allocateToken(parser, tokens);\r\n                if (!success) {\r\n                    parser.pos = start;\r\n                    return RETURN_ERROR_NO_MEM;\r\n                }\r\n                fillToken(token, JsmnType.STRING, start+1, parser.pos);\r\n                return RETURN_SUCCESS;\r\n            }\r\n\r\n            if (uint8(c) == 92 && parser.pos + 1 < s.length) {\r\n       \r\n                parser.pos++;\r\n                if (s[parser.pos] == '\\\"' || s[parser.pos] == '/' || s[parser.pos] == '\\\\'\r\n                    || s[parser.pos] == 'f' || s[parser.pos] == 'r' || s[parser.pos] == 'n'\r\n                    || s[parser.pos] == 'b' || s[parser.pos] == 't') {\r\n                        continue;\r\n                        } else {\r\n                            parser.pos = start;\r\n                            return(RETURN_ERROR_INVALID_JSON);\r\n                        }\r\n                    }\r\n            }\r\n        parser.pos = start;\r\n        return RETURN_ERROR_PART;\r\n    }\r\n\r\n    function parsePrimitive(Parser memory parser, Token[] memory tokens, bytes memory s) internal pure returns (uint) {\r\n        bool found = false;\r\n        uint start = parser.pos;\r\n        bytes1 c;\r\n        bool success;\r\n        Token memory token;\r\n        for (; parser.pos < s.length; parser.pos++) {\r\n            c = s[parser.pos];\r\n            if (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == ','\r\n                || c == 0x7d || c == 0x5d) {\r\n                    found = true;\r\n                    break;\r\n            }\r\n            if (uint8(c) < 32 || uint8(c) > 127) {\r\n                parser.pos = start;\r\n                return RETURN_ERROR_INVALID_JSON;\r\n            }\r\n        }\r\n        if (!found) {\r\n            parser.pos = start;\r\n            return RETURN_ERROR_PART;\r\n        }\r\n\r\n        (success, token) = allocateToken(parser, tokens);\r\n        if (!success) {\r\n            parser.pos = start;\r\n            return RETURN_ERROR_NO_MEM;\r\n        }\r\n        fillToken(token, JsmnType.PRIMITIVE, start, parser.pos);\r\n        parser.pos--;\r\n        return RETURN_SUCCESS;\r\n    }\r\n\r\n    function parse(string memory json, uint numberElements) internal pure returns (uint, Token[] memory tokens, uint) {\r\n        bytes memory s = bytes(json);\r\n        bool success;\r\n        Parser memory parser;\r\n        (parser, tokens) = init(numberElements);\r\n\r\n \r\n        uint r;\r\n        uint count = parser.toknext;\r\n        uint i;\r\n        Token memory token;\r\n\r\n        for (; parser.pos<s.length; parser.pos++) {\r\n            bytes1 c = s[parser.pos];\r\n\r\n\r\n            if (c == 0x7b || c == 0x5b) {\r\n                count++;\r\n                (success, token) = allocateToken(parser, tokens);\r\n                if (!success) {\r\n                    return (RETURN_ERROR_NO_MEM, tokens, 0);\r\n                }\r\n                if (parser.toksuper != -1) {\r\n                    tokens[uint(parser.toksuper)].size++;\r\n                }\r\n                token.jsmnType = (c == 0x7b ? JsmnType.OBJECT : JsmnType.ARRAY);\r\n                token.start = parser.pos;\r\n                token.startSet = true;\r\n                parser.toksuper = int(parser.toknext - 1);\r\n                continue;\r\n            }\r\n\r\n         \r\n            if (c == 0x7d || c == 0x5d) {\r\n                JsmnType tokenType = (c == 0x7d ? JsmnType.OBJECT : JsmnType.ARRAY);\r\n                bool isUpdated = false;\r\n                for (i=parser.toknext-1; i>=0; i--) {\r\n                    token = tokens[i];\r\n                    if (token.startSet && !token.endSet) {\r\n                        if (token.jsmnType != tokenType) {\r\n                         \r\n                            return (RETURN_ERROR_INVALID_JSON, tokens, 0);\r\n                        }\r\n                        parser.toksuper = -1;\r\n                        tokens[i].end = parser.pos + 1;\r\n                        tokens[i].endSet = true;\r\n                        isUpdated = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!isUpdated) {\r\n                    return (RETURN_ERROR_INVALID_JSON, tokens, 0);\r\n                }\r\n                for (; i>0; i--) {\r\n                    token = tokens[i];\r\n                    if (token.startSet && !token.endSet) {\r\n                        parser.toksuper = int(i);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (i==0) {\r\n                    token = tokens[i];\r\n                    if (token.startSet && !token.endSet) {\r\n                        parser.toksuper = int128(uint128(i));\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n\r\n\r\n            if (c == '\"') {\r\n                r = parseString(parser, tokens, s);\r\n\r\n                if (r != RETURN_SUCCESS) {\r\n                    return (r, tokens, 0);\r\n                }\r\n        \r\n                count++;\r\n\t\t\t\tif (parser.toksuper != -1)\r\n\t\t\t\t\ttokens[uint(parser.toksuper)].size++;\r\n                continue;\r\n            }\r\n\r\n   \r\n            if (c == ' ' || c == 0x11 || c == 0x12 || c == 0x14) {\r\n                continue;\r\n            }\r\n\r\n       \r\n            if (c == ':') {\r\n                parser.toksuper = int(parser.toknext -1);\r\n                continue;\r\n            }\r\n\r\n            if (c == ',') {\r\n                if (parser.toksuper != -1\r\n                    && tokens[uint(parser.toksuper)].jsmnType != JsmnType.ARRAY\r\n                    && tokens[uint(parser.toksuper)].jsmnType != JsmnType.OBJECT) {\r\n                        for(i = parser.toknext-1; i>=0; i--) {\r\n                            if (tokens[i].jsmnType == JsmnType.ARRAY || tokens[i].jsmnType == JsmnType.OBJECT) {\r\n                                if (tokens[i].startSet && !tokens[i].endSet) {\r\n                                    parser.toksuper = int(i);\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                continue;\r\n            }\r\n\r\n            if ((c >= '0' && c <= '9') || c == '-' || c == 'f' || c == 't' || c == 'n') {\r\n                if (parser.toksuper != -1) {\r\n                    token = tokens[uint(parser.toksuper)];\r\n                    if (token.jsmnType == JsmnType.OBJECT\r\n                        || (token.jsmnType == JsmnType.STRING && token.size != 0)) {\r\n                            return (RETURN_ERROR_INVALID_JSON, tokens, 0);\r\n                        }\r\n                }\r\n\r\n                r = parsePrimitive(parser, tokens, s);\r\n                if (r != RETURN_SUCCESS) {\r\n                    return (r, tokens, 0);\r\n                }\r\n                count++;\r\n                if (parser.toksuper != -1) {\r\n                    tokens[uint(parser.toksuper)].size++;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (c >= 0x20 && c <= 0x7e) {\r\n                return (RETURN_ERROR_INVALID_JSON, tokens, 0);\r\n            }\r\n        }\r\n\r\n        return (RETURN_SUCCESS, tokens, parser.toknext);\r\n    }\r\n\r\n    function getBytes(string memory json, uint start, uint end) internal pure returns (string memory) {\r\n        bytes memory s = bytes(json);\r\n        bytes memory result = new bytes(end-start);\r\n        for (uint i=start; i<end; i++) {\r\n            result[i-start] = s[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function parseInt(string memory _a) internal pure returns (int) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n\r\n    function parseInt(string memory _a, uint _b) internal pure returns (int) {\r\n        bytes memory bresult = bytes(_a);\r\n        int mint = 0;\r\n        bool decimals = false;\r\n        bool negative = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((i == 0) && (bresult[i] == '-')) {\r\n                negative = true;\r\n            }\r\n            if ((uint8(bresult[i]) >= 48) && (uint8(bresult[i]) <= 57)) {\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += int256(uint256(uint8(bresult[i]) - 48));\r\n            } else if (uint8(bresult[i]) == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= int(10**_b);\r\n        if (negative) mint *= -1;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = bytes1(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function parseBool(string memory _a) internal pure returns (bool) {\r\n        if (strCompare(_a, 'true') == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function strCompare(string memory _a, string memory _b) internal pure returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n\r\n    function equals(string memory _a, string memory _b) internal pure returns (bool){\r\n        return keccak256(bytes(_a)) == keccak256(bytes(_b));\r\n    }\r\n\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n \r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function toUint(string memory s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint256 i = 0; i < b.length; i++) {\r\n            uint256 c = uint256(uint8(b[i]));\r\n            if (c >= 48 && c <= 57) {\r\n                result = result * 10 + (c - 48);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function isDigit(string memory s) internal pure returns (bool) {\r\n        bytes memory b = bytes(s);\r\n        for (uint i = 0; i < b.length; i++) {\r\n            uint256 c = uint256(uint8(b[i]));\r\n            if (c < 48 || c > 57) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function isAddr(string memory s) internal pure returns (bool) {\r\n        bytes memory b = bytes(s);\r\n        if (b.length >= 1 + 20 && b[0] == '0' && (b[1] == 'x' || b[1] == 'X')) {\r\n            return true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function toAddress(string memory s) internal pure returns (address) {\r\n        bytes memory _bytes = hexStringToAddress(s);\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), 1)), 0x1000000000000000000000000)\r\n        }\r\n        return tempAddress;\r\n    }\r\n\r\n    function hexStringToAddress(string memory s) internal pure returns (bytes memory) {\r\n        bytes memory ss = bytes(s);\r\n        bytes memory r = new bytes(ss.length/2);\r\n        for (uint i=0; i<ss.length/2; ++i) {\r\n            r[i] = bytes1(fromHexChar(uint8(ss[2*i])) * 16 +\r\n                        fromHexChar(uint8(ss[2*i+1])));\r\n        }\r\n\r\n        return r;\r\n\r\n    }\r\n\r\n    function fromHexChar(uint8 c) internal pure returns (uint8) {\r\n        if (bytes1(c) >= bytes1('0') && bytes1(c) <= bytes1('9')) {\r\n            return c - uint8(bytes1('0'));\r\n        }\r\n        if (bytes1(c) >= bytes1('a') && bytes1(c) <= bytes1('f')) {\r\n            return 10 + c - uint8(bytes1('a'));\r\n        }\r\n        if (bytes1(c) >= bytes1('A') && bytes1(c) <= bytes1('F')) {\r\n            return 10 + c - uint8(bytes1('A'));\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\nabstract contract Ownable{\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract BSXC_Center is Ownable, IFactory {\r\n    using Counters for Counters.Counter;\r\n    \r\n    Counters.Counter private _inscriptionIdTracker;\r\n    address _jsonTool;\r\n    mapping(string => address) private src20Contracts;\r\n    mapping(address => uint256) private src20TokenIndex;\r\n    mapping(address => string[]) public holderTokens;\r\n    mapping(address => bool) public isOperator;\r\n    struct SRC20Token {\r\n        address tokenAddress;\r\n        string tick;\r\n        uint256 maxSupply;\r\n        uint256 amountPerMint;\r\n        uint256 deployId;\r\n        address deployer;\r\n        uint256 timestamp;\r\n    }\r\n    SRC20Token[] public src20Tokens;\r\n    struct ListTick {\r\n        string tick;\r\n        uint256 listId;\r\n        address listOwner;\r\n        uint256 amt;\r\n        uint256 price;\r\n        uint256 perPrice;\r\n        uint256 timestamp;\r\n    }\r\n    mapping(string => ListTick[]) public tickLists;\r\n    mapping(string => mapping(uint256 => uint256))  tickListsindex;\r\n    mapping(uint256 => address) public listOwnerAddr;\r\n    mapping(address => ListTick[]) public ownerList;\r\n    mapping(address => mapping(uint256 => uint256)) ownerListindex;\r\n    uint256 nonce = 0;\r\n    event Deploy(\r\n        address indexed tokenAddress,\r\n        SRC20Token  tokenInfo\r\n    );\r\n    event Transfer(\r\n        address indexed from, \r\n        address indexed to,\r\n        address tokenAddress,\r\n        uint256 value\r\n    );\r\n    event List(\r\n        address indexed tokenAddress,\r\n        address indexed seller,\r\n        uint256 indexed liatId,\r\n        string  tick,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 timestamp\r\n    );\r\n    event UnList(\r\n        address indexed tokenAddr,\r\n        address indexed seller,\r\n        uint256 indexed liatId,\r\n        string  tick,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 timestamp\r\n    );\r\n    event Buy(\r\n        address indexed tokenAddr,\r\n        address indexed buyer,\r\n        uint256 indexed liatId,\r\n        string  tick,\r\n        address seller,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 timestamp\r\n    );\r\n   event Sold(\r\n        address indexed tokenAddr,\r\n        address indexed seller,\r\n        uint256 indexed liatId,\r\n        string  tick,\r\n        address buyer,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 timestamp\r\n    ); \r\n    constructor(address _jsonToolAddr) {\r\n        isOperator[msg.sender] = true;\r\n        isOperator[address(this)] = true;\r\n        _jsonTool = _jsonToolAddr;\r\n        _inscriptionIdTracker.increment(); \r\n    }\r\n    \r\n    uint256 public Val = 100000000000000;\r\n    bool IsDeploy = true;\r\n\r\n\r\n    function setIsDeploy(bool _is) external onlyOwner {\r\n        IsDeploy = _is;\r\n    }\r\n\r\n    function setVal(uint _val) external onlyOwner {\r\n        Val = _val;\r\n    }\r\n\r\n\r\n    fallback(bytes calldata input) external payable returns (bytes memory) {\r\n        require(msg.sender == tx.origin, \"!EOA\");\r\n        require(JsmnSolLib.equals(string(input[0:22]),JsmnSolLib.FTMS_HEADER_HASH), \"!header\");\r\n        uint256 id = _inscriptionIdTracker.current();\r\n        _inscriptionIdTracker.increment();\r\n        string memory content = string(input[22:bytes(input).length]);\r\n        JsonTool.JsonValue memory jsonVal = JsonTool(_jsonTool).parseJsonAndExecute(content);\r\n        require(jsonVal.executeFlag, \"!json execute failed\");\r\n        if (JsmnSolLib.equals(jsonVal.op,JsmnSolLib.SRC20_OP_HASH_DEPLOY)) {\r\n                if(IsDeploy){\r\n                    require(owner() == msg.sender,\"!deploy\");\r\n                }\r\n                require(src20Contracts[jsonVal.tick] == address(0),\"!deploy\");\r\n                createSRC20(jsonVal.tick, jsonVal.max, jsonVal.lim, id);\r\n                emit Deploy(src20Contracts[jsonVal.tick],src20Tokens[src20TokenIndex[src20Contracts[jsonVal.tick]]]);\r\n            } else if (JsmnSolLib.equals(jsonVal.op,JsmnSolLib.SRC20_OP_HASH_MINT)) {\r\n                address tokenAddr = src20Contracts[jsonVal.tick];\r\n\r\n                require(tokenAddr != address(0), \"!mint\");\r\n                require(msg.value >= Val, \"!mint\");\r\n\r\n                SRC20(tokenAddr).mint(msg.sender, jsonVal.amt);\r\n                if(!checkHoldTick(msg.sender,jsonVal.tick)){\r\n                    addHoldTick(msg.sender,jsonVal.tick);\r\n                }\r\n                emit Transfer(address(0),msg.sender,src20Contracts[jsonVal.tick],jsonVal.amt);\r\n            }else if (JsmnSolLib.equals(jsonVal.op,JsmnSolLib.SRC20_OP_HASH_TRANSFER)) {\r\n                address tokenAddr = src20Contracts[jsonVal.tick];\r\n                SRC20(tokenAddr).transferFrom(msg.sender, jsonVal.receiver,jsonVal.amt);\r\n                if(!checkHoldTick(jsonVal.receiver,jsonVal.tick)){\r\n                    addHoldTick(jsonVal.receiver,jsonVal.tick);\r\n                }\r\n                if(balanceOfTick(jsonVal.tick,msg.sender)==0){\r\n                    removeHoldTick(msg.sender,jsonVal.tick);\r\n                }\r\n                emit Transfer(msg.sender,jsonVal.receiver,src20Contracts[jsonVal.tick],jsonVal.amt);\r\n            }else if (JsmnSolLib.equals(jsonVal.op,JsmnSolLib.SRC20_OP_HASH_LIST)) {\r\n                require(src20Contracts[jsonVal.tick] != address(0),\"!list\");\r\n                uint256 listId = creatNewList(jsonVal.tick,jsonVal.amt,jsonVal.price);\r\n                emit List(src20Contracts[jsonVal.tick],msg.sender,listId,jsonVal.tick,jsonVal.amt,jsonVal.price,block.timestamp);\r\n            }else if (JsmnSolLib.equals(jsonVal.op,JsmnSolLib.SRC20_OP_HASH_UNLIST)) {\r\n                require(src20Contracts[jsonVal.tick] != address(0) \r\n                    && listOwnerAddr[jsonVal.listid] == msg.sender,\"!unlist\");\r\n                removeList(jsonVal.tick,msg.sender,jsonVal.listid);\r\n            }else if (JsmnSolLib.equals(jsonVal.op,JsmnSolLib.SRC20_OP_HASH_BUY)) {\r\n                require(src20Contracts[jsonVal.tick] != address(0) \r\n                    && listOwnerAddr[jsonVal.listid] != address(0),\"!buy\");\r\n                buyToken(jsonVal.tick,listOwnerAddr[jsonVal.listid],jsonVal.listid);\r\n                removeList(jsonVal.tick,listOwnerAddr[jsonVal.listid],jsonVal.listid);\r\n                emit Transfer(listOwnerAddr[jsonVal.listid],msg.sender,src20Contracts[jsonVal.tick],jsonVal.amt);\r\n            } else {\r\n                revert();\r\n            }\r\n        return abi.encode(0);\r\n    }\r\n\r\n    function createSRC20(\r\n        string memory tick,\r\n        uint256 maxSupply,\r\n        uint256 amountPerMint,\r\n        uint256 scriptionId\r\n    ) internal {\r\n        require(bytes(tick).length == 4, \"!tick\");\r\n        require(maxSupply > 0, \"!maxSupply\");\r\n        require(amountPerMint > 0, \"!amountPerMint\");\r\n        require(maxSupply >= amountPerMint, \"maxSupply < amountPerMint\");\r\n        require(src20Contracts[tick] == address(0), \"deployed\");\r\n        SRC20 token = new SRC20(maxSupply, amountPerMint, address(this));\r\n        src20Contracts[tick] = address(token);\r\n        SRC20Token memory tokenInfo = SRC20Token(\r\n            address(token),\r\n            tick,\r\n            maxSupply,\r\n            amountPerMint,\r\n            scriptionId,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n        src20Tokens.push(tokenInfo);\r\n        src20TokenIndex[address(token)] = src20Tokens.length-1;\r\n    }\r\n\r\n    receive() external payable {revert();}\r\n\r\n\r\n    function withdraw() external onlyOwner {\r\n        require(address(this).balance > 0, \"no balance\");\r\n        uint256 balance = address(this).balance;\r\n        payable(owner()).transfer(balance);\r\n    }\r\n\r\n    function setOperator(address operator, bool _isOperator) external onlyOwner {\r\n        isOperator[operator] = _isOperator;\r\n    }\r\n\r\n\r\n    function getTokensByPage(uint256 page, uint256 pageSize) external view returns (SRC20Token[] memory tokens, uint256[] memory totalSupplies) {\r\n        require(page > 0, \"!pNumber\");\r\n        require(pageSize > 0, \"!pSize\");\r\n        uint256 start = (page - 1) * pageSize;\r\n        uint256 end = start + pageSize;\r\n        if (end > src20Tokens.length) {\r\n            end = src20Tokens.length;\r\n        }\r\n        tokens = new SRC20Token[](end - start);\r\n        totalSupplies = new uint256[](end - start);\r\n        for (uint256 i = start; i < end; i++) {\r\n            tokens[i - start] = src20Tokens[i];\r\n            totalSupplies[i - start] = SRC20(src20Tokens[i].tokenAddress).totalSupply();\r\n        }\r\n    }\r\n\r\n    function getTokenByTick(string memory tick) public view returns (SRC20Token memory tokenInfo, uint256 totalSupply) {\r\n        address tokenAddr = src20Contracts[tick];\r\n        if (tokenAddr != address(0)) {\r\n            tokenInfo = src20Tokens[src20TokenIndex[tokenAddr]];\r\n            totalSupply = SRC20(tokenAddr).totalSupply();\r\n        }\r\n    }\r\n\r\n    function getTokenCount() public view returns (uint256) {\r\n        return src20Tokens.length;\r\n    }\r\n\r\n    function getTickListeds(string memory tick,uint256 page, uint256 pageSize) public view returns (ListTick[] memory listedTicks) {\r\n        require(page > 0, \"!pNumber\");\r\n        require(pageSize > 0, \"!pSize\");\r\n        uint256 start = (page - 1) * pageSize;\r\n        uint256 end = start + pageSize;\r\n        if (end > tickLists[tick].length) {\r\n            end = tickLists[tick].length;\r\n        }\r\n        listedTicks = new ListTick[](end - start);\r\n        for (uint256 i = start; i < end; i++) {\r\n            listedTicks[i - start] = tickLists[tick][i];\r\n        }\r\n    }\r\n\r\n    function getuserLists(address addr,uint256 page, uint256 pageSize) public view returns (ListTick[] memory listedTicks) {\r\n        require(page > 0, \"!pNumber\");\r\n        require(pageSize > 0, \"!pSize\");\r\n        uint256 start = (page - 1) * pageSize;\r\n        uint256 end = start + pageSize;\r\n        if (end > ownerList[addr].length) {\r\n            end = ownerList[addr].length;\r\n        }\r\n        listedTicks = new ListTick[](end - start);\r\n        for (uint256 i = start; i < end; i++) {\r\n            listedTicks[i - start] = ownerList[addr][i];\r\n        }\r\n    }\r\n\r\n    function checkHoldTick(address holder,string memory tick) public view returns (bool) {\r\n        for (uint256 i = 0; i < holderTokens[holder].length; i++) {\r\n            if (JsmnSolLib.equals(holderTokens[holder][i],tick)) {return true;}\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function addHoldTick(address holder,string memory tick) internal returns (bool) {\r\n        if (!checkHoldTick(holder,tick)) {\r\n            holderTokens[holder].push(tick);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function removeHoldTick(address holder,string memory tick) internal returns (bool) {\r\n        if (!checkHoldTick(holder,tick)) {return false;}\r\n    \r\n        string[] memory newkeyArray = new string[](holderTokens[holder].length - 1);\r\n        uint256 j = 0;\r\n        for (uint256 i = 0; i < holderTokens[holder].length; i++) {\r\n        if (!JsmnSolLib.equals(holderTokens[holder][i],tick)) {\r\n            newkeyArray[j] = holderTokens[holder][i];\r\n            j++;\r\n        }\r\n        }\r\n\r\n        holderTokens[holder] = newkeyArray;\r\n        return true;\r\n    }\r\n\r\n    function balanceOfTick(string memory tick,address account) public view returns(uint256 holdbalance) {\r\n        address tokenAddr = src20Contracts[tick];\r\n        if (tokenAddr != address(0)) {\r\n            holdbalance = SRC20(tokenAddr).balanceOf(account);\r\n        }\r\n    }\r\n\r\n    function creatNewList(string memory tick,uint256 amt,uint256 price) internal returns (uint256) {\r\n        require(listamontcheck(tick,amt), \"Insufficient balance!\");\r\n        uint256 listId = listidCrate(amt,price);\r\n        ListTick memory listInfo = ListTick(\r\n            tick,\r\n            listId,\r\n            msg.sender,\r\n            amt,\r\n            price,\r\n            price/amt,\r\n            block.timestamp\r\n        );\r\n        tickLists[tick].push(listInfo);\r\n        tickListsindex[tick][listId]=tickLists[tick].length-1;\r\n\r\n        ownerList[msg.sender].push(listInfo);\r\n        ownerListindex[msg.sender][listId]=ownerList[msg.sender].length-1;\r\n\r\n        listOwnerAddr[listId] = msg.sender;\r\n        return listId;\r\n\r\n    }\r\n\r\n    function removeList(string memory tick,address listowner,uint256 listId) internal returns (bool) {\r\n   \r\n        uint256 index = tickListsindex[tick][listId];\r\n        ListTick memory deletListInfo =tickLists[tick][index];\r\n        uint256 movedListId = tickLists[tick][tickLists[tick].length-1].listId;\r\n        tickLists[tick][index] = tickLists[tick][tickLists[tick].length-1];\r\n        tickLists[tick].pop();\r\n        delete tickListsindex[tick][listId];\r\n        tickListsindex[tick][movedListId]=index;\r\n\r\n\r\n        uint256 userIndex = ownerListindex[listowner][listId];\r\n        uint256 usermovedListId = ownerList[listowner][ownerList[listowner].length-1].listId;\r\n        ownerList[listowner][userIndex] = ownerList[listowner][ownerList[listowner].length-1];\r\n        ownerList[listowner].pop();\r\n        delete ownerListindex[listowner][usermovedListId];\r\n        ownerListindex[listowner][usermovedListId]=userIndex;\r\n        address ownaddr = listOwnerAddr[listId];\r\n        delete listOwnerAddr[listId];\r\n        if(listowner == ownaddr){\r\n            emit UnList(src20Contracts[tick],msg.sender,listId,tick,deletListInfo.amt,deletListInfo.price,block.timestamp);\r\n        }else{\r\n            emit Sold(src20Contracts[tick],listowner,listId,tick,msg.sender,deletListInfo.amt,deletListInfo.price,block.timestamp);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function buyToken(string memory tick,address listowner,uint256 listId) internal returns (bool) {\r\n        ListTick memory listInfo = tickLists[tick][tickListsindex[tick][listId]];\r\n        require(listInfo.price == msg.value, \"!Insufficient payvalue\");\r\n        SRC20(src20Contracts[tick]).transferFrom(listowner, msg.sender,listInfo.amt);\r\n        payable(listowner).transfer(msg.value * 995 / 1000);\r\n        return true;\r\n    }\r\n\r\n    function listamontcheck(string memory tick,uint256 amt) internal view returns (bool) {\r\n        uint256 listAmut = 0;\r\n        for (uint256 i = 0; i < ownerList[msg.sender].length; i++) {\r\n            if (!JsmnSolLib.equals(ownerList[msg.sender][i].tick,tick)) {\r\n                listAmut=listAmut+ownerList[msg.sender][i].amt;\r\n            }\r\n        }\r\n        return balanceOfTick(tick,msg.sender)>=listAmut+amt;\r\n    }\r\n    \r\n    function listidCrate(uint256 amt,uint256 price) internal returns(uint256) {\r\n        nonce += 1;\r\n        return uint256(keccak256(abi.encodePacked(amt,price,nonce, msg.sender, block.number)));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_jsonToolAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deployId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BSXC_Center.SRC20Token\",\"name\":\"tokenInfo\",\"type\":\"tuple\"}],\"name\":\"Deploy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"List\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Sold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liatId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UnList\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"Val\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOfTick\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"holdbalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"}],\"name\":\"checkHoldTick\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getTickListeds\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"listOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct BSXC_Center.ListTick[]\",\"name\":\"listedTicks\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"}],\"name\":\"getTokenByTick\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deployId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct BSXC_Center.SRC20Token\",\"name\":\"tokenInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getTokensByPage\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deployId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct BSXC_Center.SRC20Token[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"totalSupplies\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"page\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getuserLists\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"listOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct BSXC_Center.ListTick[]\",\"name\":\"listedTicks\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holderTokens\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listOwnerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerList\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"listOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_is\",\"type\":\"bool\"}],\"name\":\"setIsDeploy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isOperator\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setVal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"src20Tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deployId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickLists\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"tick\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"listOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BSXC_Center", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000321185aa7023b306094dfc9617874f31636f8129", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a2e838b4086e5c094e8bffa6c7fc8d9ac32dbe07c5ea6b1a6951e1dddc5b0d2f"}