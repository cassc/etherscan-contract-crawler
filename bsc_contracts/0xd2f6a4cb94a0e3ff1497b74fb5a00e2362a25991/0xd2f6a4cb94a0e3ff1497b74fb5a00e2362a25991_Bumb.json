{"SourceCode": "/* \r\n \r\n                       .::::. \r\n                     .::::::::. \r\n                    :::::::::::    Spend 10u, you can't buy a loss, \r\n                ..:::::::::::'      you can't be fooled, you support Bumb for a while, \r\n              '::::::::::::'        and Bumb will support you for a lifetime\r\n                .:::::::::: \r\n           '::::::::::::::..                                              -----please don't copy my code\r\n                ..::::::::::::. \r\n              ``:::::::::::::::: \r\n               ::::``:::::::::'        .:::. \r\n              ::::'   ':::::'       .::::::::. \r\n            .::::'      ::::     .:::::::'::::. \r\n           .:::'       :::::  .:::::::::' ':::::. \r\n          .::'        :::::.:::::::::'      ':::::. \r\n         .::'         ::::::::::::::'         ``::::. \r\n     ...:::           ::::::::::::'              ``::. \r\n    ```` ':.          ':::::::::'                  ::::.. \r\n                       '.:::::'                    ':'````.. \r\n \r\n \r\n*/ \r\n\r\n\r\npragma solidity ^0.8.6;\r\n\r\n// SPDX-License-Identifier: Unlicensed\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor ()  {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IUsdtHub {\r\n    function withdraw() external;\r\n    \r\n}\r\n\r\ncontract UsdtHub is IUsdtHub {\r\n    using SafeMath for uint256;\r\n\r\n    address _token;\r\n\r\n    IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\nconstructor () {\r\n   \r\n        _token = msg.sender;\r\n    }\r\n\r\n    function withdraw() external override onlyToken(){\r\n        \r\n        usdt.transfer(_token, usdt.balanceOf(address(this)));\r\n       \r\n    }\r\n}\r\ncontract Bumb is IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string private _name = \"Bumb\";\r\n    string private _symbol =  \"Bumb\";\r\n    uint8 private _decimals = 18;  \r\n    mapping(address => uint256) private _tOwned;\r\n    uint256 private _tTotal = 2100*10**4 * 10**18; \r\n    uint256 public _burnAward = 640;    \r\n    uint256 public _inviterFee = 160; \r\n    uint256 public _devoteFee = 300;     \r\n    uint256 public _DevoteFee = 1100;     \r\n    uint256 public _burninviter = 3200; \r\n    //uint256 public _price = 7*10**14;   \r\n    //uint256 public multiple = 1;   \r\n   \r\n    address public beforeaction ; \r\n    address public projectad = 0x421C1Ac3d4492649E8d9646E978e4A996da7AEc1;    \r\n    address public projectDAO = 0xeBa2DeFb11134667362830cB2D065aFE6Ca70EaD;   \r\n    uint256 distributorGas = 200000; \r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    mapping(address => bool) private _isExcludedFromFee;\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n\r\n\r\n    mapping(address => bool) public _iscommunity;  \r\n    address[] public communiters;\r\n    mapping (address => uint256) public comdexes;\r\n\r\n    uint256 public votetime;\r\n    uint256 public vote;\r\n    uint256 public votegap = 3600 seconds;\r\n\r\n    mapping(uint256 => mapping(address => bool)) public _istimepoll;\r\n\r\n     modifier onlycommunity {      \r\n        require(_iscommunity[msg.sender]);     \r\n        _;\r\n    }\r\n\r\n    mapping(address => bool) public groupEquity;   //Allow groups to buy ahead\r\n    address[] public groupers; \r\n    mapping(address => bool) public isgroup;  \r\n    mapping (address => uint256) public groupdexes; \r\n    mapping (address => uint256) public groupLock;\r\n    mapping (address => uint256) public GroupLock;  \r\n    mapping (address => uint16) public GroupGrade;  \r\n\r\n    mapping (address => uint256) public Burnbusiness;  \r\n    mapping (address => uint256) public Swapbusiness;\r\n\r\n    address public Totalprojectad;\r\n    uint256 public Totalnode; \r\n    uint256 public Totalburn; \r\n\r\n    address[] public holders;\r\n    mapping (address => uint256) public holderIndexes;\r\n    mapping (address => uint256) public Damount;  \r\n\r\n    mapping(address => mapping(address => bool)) public _advance;\r\n    mapping(address => address) public inviter;\r\n    mapping(address => address[]) public offline;\r\n    mapping(address => uint256) public  lcycle; \r\n  \r\n    address[] public lowers;\r\n    uint256 public lowersnumber;\r\n\r\n\r\n\r\n    uint256 public currentIndex;  \r\n\r\n    uint256 public burnIndex;  \r\n\r\n     uint256 public nowbanance;  \r\n   \r\n   \r\n     IUniswapV2Router02 public immutable uniswapV2Router;\r\n     address public immutable uniswapV2Pair;\r\n     mapping(address => bool) public allowpair;  \r\n  \r\n    modifier onlyvote {   \r\n        if(block.timestamp > votetime.add(votegap))vote = 0; \r\n        \r\n        require((vote > communiters.length.div(2) && beforeaction == msg.sender) || owner() == msg.sender);    \r\n        _;\r\n        vote = 0;\r\n    }\r\n\r\n    uint256 public fomopond;  \r\n    uint256 public fomotime;   \r\n    //uint256 public fomogap = 1 minutes;\r\n    uint256 public blastingpond = 6000* 10**18;     \r\n    \r\n    uint256 public fomoWeights;  \r\n    uint256[] public Weights; \r\n\r\n    struct FomoallInfo {\r\n        address fomoad;           \r\n        uint256 fomoamount;       \r\n        uint256 fomotime;  \r\n    }\r\n\r\n    FomoallInfo[] public fomoallInfo;\r\n\r\n    uint256 public liquiditypond;  \r\n    bool public swapAndLiquifyEnabled = false;\r\n    address public USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    uint256 public StartTime;\r\n    uint256 public  hourstime = 1 minutes;      \r\n    bool public _Power = false;\r\n\r\n\r\n    uint256 payspeed = 3;\r\n\r\n\r\n\r\n    UsdtHub  usdthub;\r\n\r\n    mapping(address => bool) public onebuy; \r\n\r\n    constructor() {\r\n        _tOwned[projectad] = _tTotal;  \r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n        );           \r\n\r\n       groupers.push(address(0));  \r\n     \r\n       _iscommunity[projectad] = true;   \r\n       comdexes[projectad] = 0;\r\n       communiters.push(projectad);\r\n\r\n       uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), USDT);\r\n       uniswapV2Router = _uniswapV2Router;\r\n\r\n       \r\n       usdthub = new UsdtHub();\r\n\r\n        //exclude owner and this contract from fee\r\n        _isExcludedFromFee[msg.sender] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        \r\n        _isExcludedFromFee[projectad] = true;\r\n        _isExcludedFromFee[address(_uniswapV2Router)] = true;\r\n       \r\n        allowpair[address(this)] = true;\r\n        allowpair[address(_uniswapV2Router)] = true;\r\n        emit Transfer(address(0), projectad, _tTotal);\r\n    }\r\n\r\n  \r\n\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _tOwned[account];\r\n    }\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {   \r\n        \r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n   \r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n        ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            _allowances[sender][msg.sender].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    \r\n     function Opening( ) public view returns (uint256,uint256) {\r\n        uint256 openingtime = (block.timestamp <  StartTime.add(hourstime*24*60) ? StartTime.add(hourstime*24*60) - block.timestamp : 0) ;   \r\n        uint256 Limitbuy = (block.timestamp <  StartTime.add(hourstime*24*60 +600) ? StartTime.add(hourstime*24*60 +600) - block.timestamp : 0) ; \r\n        return  (openingtime,Limitbuy);\r\n    }\r\n    \r\n    function querygroup( address _addr ) public view returns (uint256,uint256,uint256,uint256,uint16) {\r\n        return (Burnbusiness[_addr], Swapbusiness[_addr],groupLock[_addr],GroupLock[_addr],GroupGrade[_addr]) ;\r\n    }\r\n   \r\n    function queryTotal() public view returns (address,uint256,uint256,uint256) {\r\n        return (Totalprojectad, Totalnode,Totalburn,_tOwned[Totalprojectad]) ;\r\n    }\r\n  \r\n    function findtime() public view returns (uint256,uint256,bool) {\r\n        return (block.timestamp,votetime+votegap,block.timestamp < votetime+votegap);\r\n    }\r\n    \r\n    function isinviter( address _addr ) public view returns (address) {\r\n        return inviter[_addr];\r\n    }\r\n   \r\n    function isoffline( address _addr ,uint256 amount) public view returns (address,uint256) {\r\n         return (offline[_addr][amount] ,offline[_addr].length);\r\n    }\r\n   \r\n    function holdamount( uint256 holds) public view returns (address,uint256,uint256) {\r\n        return (holders[holds],Damount[holders[holds]],holderIndexes[holders[holds]] );\r\n    }\r\n      \r\n    function getholderlength( ) public view returns (uint256) {\r\n        return holders.length;\r\n    }\r\n  \r\n    function isExcludedFromFee(address account) public view returns (bool) {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n\r\n    function isContract( address _addr ) internal view returns (bool addressCheck) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(_addr) }\r\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n function buytoUSDT(uint256 cxBalance) public view returns(uint256){\r\n        address[] memory routerAddress = new address[](2);\r\n        routerAddress[0] = USDT;\r\n        routerAddress[1] = address(this);\r\n        uint[] memory amounts = uniswapV2Router.getAmountsIn(cxBalance,routerAddress);\r\n        return amounts[0];\r\n    }\r\n\r\n    function selltoUSDT(uint256 cxBalance) public view returns(uint256){\r\n        address[] memory routerAddress = new address[](2);\r\n        routerAddress[0] = address(this);\r\n        routerAddress[1] = USDT;\r\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(cxBalance,routerAddress);        \r\n        return amounts[1];\r\n    }\r\n\r\n     function USDTtoToken(uint256 _Tamount) public view returns(uint256){\r\n        address[] memory routerAddress = new address[](2);\r\n        routerAddress[0] = USDT;\r\n        routerAddress[1] = address(this);\r\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(_Tamount,routerAddress);        \r\n        return amounts[1];\r\n    }\r\n\r\n    function fomoinfo( ) public view returns (bool,uint256,uint256) {\r\n        \r\n        uint256 timegap = (block.timestamp >= fomotime +hourstime*3*60 ? 0 : fomotime +hourstime*3*60 - block.timestamp) ;    \r\n      \r\n        uint256 fomoaward = (fomopond >= blastingamount( ) ? fomopond - blastingamount( ).div(2) : fomopond) ;   \r\n        return (block.timestamp >= fomotime +hourstime*3*60,timegap,fomoaward) ;\r\n    }\r\n    function fomoLength() external view returns (uint256) {\r\n        return fomoallInfo.length;\r\n    }\r\n    function allfomoinfo( uint256 fomonumber) public view returns(FomoallInfo memory) {        \r\n       return fomoallInfo[fomonumber];\r\n    }\r\n    function blastinginfo(uint256 position) public view returns (bool,address,uint256) {\r\n        uint256 blastingaward = blastingamount( ).div(2).mul(Damount[holders[holders.length - position]]).div(fomoWeights);\r\n        return (fomopond >= blastingamount( ) && holders.length >=10, holders[holders.length - position],blastingaward) ;\r\n    } \r\n\r\n\r\n    function blastingamount( ) public view returns (uint256) {\r\n        uint256 amount = (owner() != address(0) ? blastingpond : USDTtoToken(4000*10**18) );     \r\n        return amount;\r\n    } \r\n\r\n    //function ismultiple(uint256 Amount,uint256 getprich ) private  returns (uint256) {   \r\n        //uint256 Multiple = getprich.mul(10**18).div(Amount).div(_price);\r\n        //if(Multiple > multiple ) multiple = Multiple;\r\n        //uint256 _multiple = (100 >= multiple ?  200/multiple : 2);\r\n        //return _multiple;\r\n   // }\r\n   \r\n    function setgroup(address[] memory  groupAD ,uint256 lockamount,uint16 grade) external onlyOwner() {   \r\n          for(uint j = 0; j < groupAD.length; j++){          \r\n              require(!isgroup[groupAD[j]] &&  groupAD[j] != address(0) && groupdexes[groupAD[j]] == 0);   \r\n\r\n              groupdexes[groupAD[j]] = groupers.length;\r\n              isgroup[groupAD[j]] = true; \r\n              groupers.push(groupAD[j]);\r\n              groupLock[groupAD[j]] = lockamount* 10**18;\r\n              GroupLock[groupAD[j]] = lockamount* 10**18;\r\n              GroupGrade[groupAD[j]] = grade;  \r\n          \r\n              if(grade == 3)Totalprojectad = groupAD[j]; \r\n           }\r\n    }  \r\n    function setgroupEquity(address[] memory  groupAD) external onlyOwner() {    \r\n          for(uint j = 0; j < groupAD.length; j++){   \r\n              groupEquity[groupAD[j]] = true;    \r\n           }\r\n    }\r\n    function setprojectad(address projectAd) external onlyOwner(){\r\n        projectad = projectAd; \r\n        _isExcludedFromFee[projectAd] = true;\r\n    }\r\n \r\n    function setallFee(uint256 burnAward,uint256 inviterFee,uint256 devoteFee,uint256 burninviter,uint256 _votegap) external onlyOwner() {\r\n        require(burnAward + inviterFee + devoteFee <= 3000);\r\n        _burnAward = burnAward;   \r\n        _inviterFee = inviterFee; \r\n        _devoteFee = devoteFee;    \r\n        _burninviter = burninviter;   \r\n        _DevoteFee =  burnAward + inviterFee + devoteFee ;\r\n        votegap = _votegap;  \r\n    }\r\n\r\n    function setspeed(uint256 _speed) external onlyvote {     //Revise \r\n        payspeed = _speed;       \r\n    }\r\n\r\n\r\n    function setCommunity(address  CommAD) external onlyvote {\r\n               require(!_iscommunity[CommAD]); \r\n                _iscommunity[CommAD] = true;  \r\n                comdexes[CommAD] = communiters.length;\r\n                communiters.push(CommAD);   \r\n                _isExcludedFromFee[CommAD] = true;\r\n           \r\n    }  \r\n    \r\n    function outCommunity(address  CommAD) external onlyvote {\r\n           require(_iscommunity[CommAD]);\r\n           _iscommunity[CommAD] = false;\r\n           _isExcludedFromFee[CommAD] = false;\r\n          \r\n           communiters[comdexes[CommAD]] = communiters[communiters.length - 1];\r\n           comdexes[communiters[communiters.length - 1]] = comdexes[CommAD];  \r\n           communiters.pop();             \r\n    }  \r\n   \r\n     function setgas(uint256 gas) external onlyvote {\r\n        require(gas <= 750000 && gas >= 200000);\r\n        distributorGas = gas; \r\n    }\r\n \r\n    function setairdrop(IERC20 airdropaddress,uint256 airgas) external onlyvote{   \r\n       \r\n            require(airdropaddress.balanceOf(address(this)) > 0 && holders.length.sub(burnIndex) > 0);\r\n            uint256 airbanance = airdropaddress.balanceOf(address(this));\r\n            uint256 gasUsed = 0;\r\n            uint256 gasLeft = gasleft();\r\n            uint256 iterations = 0;\r\n            uint256 rentIndex = burnIndex;\r\n            while(gasUsed < airgas && iterations < holders.length) {\r\n                 if(rentIndex >= holders.length){\r\n                      rentIndex = burnIndex;\r\n                 }           \r\n                 uint256 amount = airbanance.mul(Damount[holders[currentIndex]]).div(Totalburn);\r\n       \r\n                if(airdropaddress.balanceOf(address(this))  < amount )return;\r\n                airdropaddress.transfer(holders[currentIndex],amount);\r\n                gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n                gasLeft = gasleft();\r\n                rentIndex++;\r\n                iterations++;\r\n            }    \r\n}\r\n\r\n    \r\n    function setfomo(uint256 _hourstime,uint256 _fomopond,uint256 _liquiditypond) external onlyvote {\r\n        hourstime = _hourstime;      \r\n        //blastingpond =  blastingpond *10**18;\r\n        fomopond = fomopond.add(_fomopond);\r\n        \r\n        liquiditypond = liquiditypond.add(_liquiditypond);\r\n        bacistransfer(projectad,address(this),_fomopond + _liquiditypond,_fomopond + _liquiditypond); \r\n    }\r\n    \r\n    function setpair(address account) external onlyvote {\r\n        allowpair[account] = true;       \r\n    }\r\n    \r\n     function setSwapAndLiquifyEnabled(bool _enabled) public onlyvote {\r\n        swapAndLiquifyEnabled = _enabled;\r\n        \r\n    }\r\n    \r\n    function setFee(address account,bool feelist) external onlyvote {\r\n        require(account != uniswapV2Pair && account != address(uniswapV2Router));\r\n        _isExcludedFromFee[account] = feelist;       \r\n    }\r\n\r\n    function setblasting(uint256 _blasting) external onlyvote {\r\n        require(_blasting >= 100* 10**18 && _blasting <= 500000* 10**18);\r\n        blastingpond = _blasting;       \r\n    }\r\n     function setprocess(uint256 Pgas) external onlycommunity{   \r\n        process(Pgas); \r\n    }\r\n    \r\n    function setvote() external onlycommunity{  \r\n        if(block.timestamp >  votetime.add(votegap)){   \r\n             \r\n              if(communiters.length >2)require(beforeaction != msg.sender); \r\n              votetime = block.timestamp; \r\n              vote = 1;\r\n              _istimepoll[votetime][msg.sender] = true;  \r\n              beforeaction = msg.sender;\r\n         } else {\r\n              \r\n              require(!_istimepoll[votetime][msg.sender]);\r\n              vote++;  \r\n              _istimepoll[votetime][msg.sender] = true;\r\n         }\r\n    }\r\n\r\n    function Release(address fromgroup)  private {  \r\n        if(groupers[groupdexes[fromgroup]] != fromgroup || groupLock[fromgroup] == 0) return;\r\n        uint256 base;\r\n        uint256 business;           \r\n        business = Burnbusiness[fromgroup]+Swapbusiness[fromgroup];                  \r\n        if(GroupGrade[fromgroup] == 1){\r\n               base = 1;\r\n               \r\n            }else if(GroupGrade[fromgroup] == 2){\r\n               base = 3;\r\n              \r\n            }else{\r\n               base = 60;\r\n               business = Totalnode;\r\n            }\r\n        if( business >=base*90000*10**18){\r\n                groupLock[fromgroup] = 0;\r\n        }else if( business >=base*60000*10**18){\r\n                groupLock[fromgroup] =  GroupLock[fromgroup].mul(20).div(100);\r\n        }else if( business >=base*36000*10**18){\r\n                groupLock[fromgroup] =  GroupLock[fromgroup].mul(40).div(100);\r\n        }else if( business >=base*18000*10**18){\r\n                groupLock[fromgroup] =  GroupLock[fromgroup].mul(60).div(100);\r\n        }else if( business >=base*6000*10**18){\r\n                groupLock[fromgroup] =  GroupLock[fromgroup].mul(80).div(100);\r\n        }\r\n\r\n        emit Transfer(projectad, fromgroup, GroupLock[fromgroup] - groupLock[fromgroup]);                                                                      \r\n    } \r\n      \r\n\r\n    \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n        ) private {\r\n        if(isContract(to) && !allowpair[to] && from == projectad)allowpair[to] = true;\r\n        if(isContract(to))require(allowpair[to]);\r\n        Release(from);\r\n        if(isgroup[from] && _tOwned[from] >= groupLock[from] && groupLock[from] >0)require(amount <= _tOwned[from].sub(groupLock[from]));\r\n\r\n        OpenLimit(from,to,amount);\r\n       \r\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\r\n            bacistransfer(from,to,amount,amount);\r\n            \r\n            if(from ==  uniswapV2Pair)Totalnode = Totalnode.add(buytoUSDT(amount));\r\n       } else {\r\n            \r\n            require(amount < _tOwned[from]);\r\n            maintransfer(from,to,amount);\r\n       }\r\n    }\r\n  \r\n     function OpenLimit(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        if(_Power && block.timestamp >=  StartTime.add(hourstime*24*60 +600) )return;\r\n        if(from == projectad && to == uniswapV2Pair && !_Power){\r\n             StartTime = block.timestamp;\r\n             _Power = true;\r\n        }\r\n        if(block.timestamp <  StartTime.add(hourstime*24*60 - 5) )require(from != uniswapV2Pair);   \r\n        if(block.timestamp <  StartTime.add(hourstime*24*60) && !_isExcludedFromFee[to] && from == uniswapV2Pair )require(gasleft() <= 10000 );\r\n            \r\n        if(block.timestamp <  StartTime.add(hourstime*24*60 +300) && !_isExcludedFromFee[to] && from == uniswapV2Pair && !groupEquity[to])require( gasleft() <= 10000);\r\n            \r\n        if(block.timestamp <  StartTime.add(hourstime*24*60 +600) && from == uniswapV2Pair ){\r\n             require( buytoUSDT(amount) <= 40*10**18 && !onebuy[to]);\r\n             onebuy[to] = true;\r\n        }\r\n\r\n    }\r\n    function bacistransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 Amount,uint256 amount\r\n    ) private {\r\n        _tOwned[sender] = _tOwned[sender].sub(Amount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(amount);\r\n        emit Transfer(sender, recipient, Amount);\r\n    }\r\n    function maintransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n        ) private {\r\n        if(to == DEAD && !isContract(from)){\r\n            burntransfer(from,amount);\r\n\r\n            if(isgroup[groupers[groupdexes[from]]])Burnbusiness[groupers[groupdexes[from]]] = Burnbusiness[groupers[groupdexes[from]]].add(selltoUSDT(amount));\r\n            if(GroupGrade[groupers[groupdexes[from]]] == 1 &&  Burnbusiness[groupers[groupdexes[from]]]  + Swapbusiness[groupers[groupdexes[from]]] >= 90000*10**18 &&  isgroup[ inviter[groupers[groupdexes[from]]]])\r\n                 Burnbusiness[inviter[groupers[groupdexes[from]]]] = Burnbusiness[inviter[groupers[groupdexes[from]]]].add(selltoUSDT(amount));\r\n            Totalnode = Totalnode.add(selltoUSDT(amount));\r\n\r\n            return;\r\n        }\r\n\r\n        if(!isContract(from) && !isContract(to)){     \r\n              if(!_advance[to][from]) _advance[from][to] = true; \r\n              if(_advance[to][from]){         \r\n                   if(inviter[from] == address(0) && inviter[to] != from ) {  \r\n                       inviter[from] = to;      \r\n                       offline[to].push(from);      \r\n                   }          \r\n                                     \r\n                   if(inviter[from] == to && isgroup[groupers[groupdexes[to]]] && groupdexes[from] == 0)   \r\n                      groupdexes[from] = groupdexes[to];\r\n              }                  \r\n            _takeDevoter(from,amount.mul(_DevoteFee).div(10000));\r\n            uint256 recipientRate = 10000 -_DevoteFee;\r\n            bacistransfer(from,to,amount,amount.mul(recipientRate).div(10000));   \r\n            process(distributorGas);\r\n            return;\r\n        }\r\n        \r\n        if(!isContract(to) && inviter[to] == address(0) && _tOwned[to] == 0 && to != DEAD)lowers.push(to);\r\n        if(swapAndLiquifyEnabled && !isContract(from) && liquiditypond >0 && selltoUSDT(liquiditypond) >= 40*10**18  )swapAndLiquify(liquiditypond);  \r\n        _transferStandard(from,to,amount);\r\n    }\r\n    function burntransfer(\r\n        address from,\r\n        uint256 amount\r\n        ) private {\r\n        require( Damount[from] == 0 && selltoUSDT(amount) >= 20*10**18 && selltoUSDT(amount) <= 2000*10**18); \r\n        blasting( );\r\n        if(block.timestamp >=  fomotime.add(hourstime*3*60) && fomopond >0 && holders.length >0){   \r\n            fomoallInfo.push(FomoallInfo({\r\n            fomoad: holders[holders.length - 1],\r\n            fomoamount: fomopond,\r\n            fomotime: block.timestamp\r\n            }));\r\n            bacistransfer(address(this),holders[holders.length - 1],fomopond,fomopond);\r\n            fomopond = 0;\r\n        }\r\n        fomotime = block.timestamp;\r\n        setShare(from,amount);\r\n        uint256 recipientRate = 10000 -_burninviter; \r\n        \r\n        _takeInviterFee(from,DEAD,amount,_burninviter);\r\n        bacistransfer(from,DEAD,amount,amount.mul(recipientRate).div(10000));\r\n    }\r\n   \r\n    function blasting(\r\n       ) private {\r\n        if(fomopond < blastingamount( ) || holders.length <10)return;\r\n        \r\n        for (uint256 i = 1; i <= 10; i++) {\r\n             \r\n             ( , ,uint256 blastingam) = blastinginfo(i);\r\n             if(fomopond < blastingam)return;\r\n             bacistransfer(address(this),holders[holders.length - i],blastingam,blastingam); \r\n             fomopond = fomopond.sub(blastingam);\r\n        }\r\n    }\r\n     function swapAndLiquify(uint256 contractTokenBalance) private {\r\n       \r\n        uint256 half = contractTokenBalance.div(2);\r\n        uint256 otherHalf = contractTokenBalance.sub(half);\r\n       \r\n        uint256 initialBalance = IERC20(USDT).balanceOf(address(usdthub));\r\n\r\n        swapTokensForUSDT(half); \r\n\r\n        \r\n        uint256 newBalance = IERC20(USDT).balanceOf(address(usdthub)).sub(initialBalance);\r\n\r\n        usdthub.withdraw();\r\n\r\n        // add liquidity to uniswap\r\n        addLiquidity(otherHalf, newBalance);\r\n        \r\n        \r\n    }\r\n     function swapTokensForUSDT(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = USDT;\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(usdthub),\r\n            block.timestamp\r\n        );\r\n    }\r\n     function addLiquidity(uint256 tokenAmount, uint256 usdtAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        IERC20(USDT).approve(address(uniswapV2Router), usdtAmount);  \r\n        // add the liquidity\r\n        uniswapV2Router.addLiquidity(\r\n            address(this),\r\n            USDT,\r\n            tokenAmount,\r\n            usdtAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            projectad,\r\n            block.timestamp\r\n        );\r\n        liquiditypond = 0;\r\n    }\r\n    function setShare(address shareholder,uint256 amount) private {\r\n        \r\n        Damount[shareholder] = selltoUSDT(amount).mul(2);  \r\n        Totalburn = Totalburn.add(Damount[shareholder]);\r\n        fomoWeights = fomoWeights.add(Damount[shareholder]);\r\n        if(holders.length >=10)fomoWeights = fomoWeights.sub(Weights[holders.length - 10]);\r\n        holderIndexes[shareholder] = holders.length;  \r\n        holders.push(shareholder);\r\n        Weights.push(Damount[shareholder]);\r\n    }\r\n   \r\n    function process(uint256 gas) private {\r\n        \r\n        if(holders.length.sub(burnIndex) == 0 || _tOwned[address(this)].sub(fomopond + liquiditypond) < _tTotal.div(10**6) ) return;\r\n       \r\n        nowbanance = _tOwned[address(this)].sub(fomopond+ liquiditypond);\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n\r\n        while(gasUsed < gas && iterations < holders.length) {\r\n            if(currentIndex >= holders.length){\r\n                currentIndex = burnIndex;\r\n            }\r\n           \r\n            uint256 amount = nowbanance.mul(Damount[holders[currentIndex]]).div(Totalburn);\r\n            \r\n            if(lowersnumber < lowers.length && lowers[lowersnumber] != holders[currentIndex] ){\r\n                    \r\n                 if(inviter[lowers[lowersnumber]] == address(0))offline[holders[currentIndex]].push(lowers[lowersnumber]);\r\n                \r\n                 if(inviter[lowers[lowersnumber]] == address(0))inviter[lowers[lowersnumber]] = holders[currentIndex];\r\n                 \r\n                 if(inviter[lowers[lowersnumber]] == holders[currentIndex] && isgroup[groupers[groupdexes[holders[currentIndex]]]] && groupdexes[lowers[lowersnumber]] == 0) \r\n                      groupdexes[lowers[lowersnumber]] = groupdexes[holders[currentIndex]];\r\n                 \r\n                 lowersnumber++;\r\n            }  \r\n           \r\n            if(_tOwned[address(this)].sub(fomopond + liquiditypond)  < amount )return;\r\n            if( amount >= _tTotal.div(10**12))bacistransfer(address(this),holders[currentIndex],amount,amount);\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n      \r\n    function _takeburnAward(address sender,uint256 tAmount) private {\r\n        if (_burnAward == 0) return;\r\n        addmanp(sender,address(this),tAmount.mul(54).div(64));   \r\n        addmanp(sender,projectDAO,tAmount.mul(10).div(64));  \r\n        fomopond =  fomopond.add(tAmount.mul(20).div(64));\r\n        liquiditypond = liquiditypond.add(tAmount.mul(10).div(64));\r\n    }\r\n\r\n    function _takeInviterFee(address sender,address recipient,uint256 tAmount,uint256 fee) private {\r\n        if (fee == 0) return;\r\n        address cur;\r\n        address linecur;\r\n        if (isContract(sender)) {\r\n            cur = recipient;\r\n            linecur = recipient;\r\n        } else {\r\n            cur = sender;\r\n            linecur = sender;\r\n        }\r\n        uint256 accurRate;\r\n        uint256 rate = fee.div(8);\r\n        for (int256 i = 0; i < 7; i++) {  \r\n            cur = inviter[cur]; \r\n            if (cur == address(0)) {\r\n                break;  \r\n            }\r\n            accurRate = accurRate.add(rate);  \r\n            if(_tOwned[cur] == 0 || selltoUSDT(_tOwned[cur]) < 89*10**18){        \r\n                addmanp(sender, address(this),tAmount.mul(rate).div(10000));  \r\n                fomopond = fomopond.add(tAmount.mul(rate).div(10000));\r\n            }else{\r\n               addmanp(sender, cur,tAmount.mul(rate).div(10000));               \r\n            }\r\n        }\r\n        if(offline[linecur].length  == 0){\r\n              addmanp(sender, address(this),tAmount.mul(fee - accurRate).div(10000));  \r\n              fomopond = fomopond.add(tAmount.mul(fee - accurRate).div(10000)); \r\n        }else {\r\n            if(lcycle[linecur] >= offline[linecur].length){\r\n                lcycle[linecur] = 0;\r\n            }\r\n            if(_tOwned[offline[linecur][lcycle[linecur]]] == 0 || selltoUSDT(_tOwned[offline[linecur][lcycle[linecur]]]) < 89*10**18){        \r\n                addmanp(sender, address(this),tAmount.mul(fee - accurRate).div(10000));  \r\n                fomopond = fomopond.add(tAmount.mul(fee - accurRate).div(10000));  \r\n            }else{   \r\n                addmanp(sender, offline[linecur][lcycle[linecur]],tAmount.mul(fee - accurRate).div(10000));  \r\n             }         \r\n            lcycle[linecur]++;\r\n           \r\n        }\r\n    }\r\n\r\n    function _takeDevoter(address sender,uint256 tAmount) private {\r\n        if(_devoteFee == 0 )return;   \r\n        addmanp(sender,DEAD,tAmount);   \r\n        if(holders.length.sub(burnIndex) == 0) {\r\n            return;          \r\n        }\r\n       \r\n        if(_tOwned[DEAD] >= tAmount.mul(payspeed)) tAmount = tAmount.mul(payspeed);    \r\n        \r\n        if(tAmount >=  USDTtoToken(Damount[holders[burnIndex]])){          //optimize code\r\n           \r\n            bacistransfer(DEAD,holders[burnIndex],USDTtoToken(Damount[holders[burnIndex]]),USDTtoToken(Damount[holders[burnIndex]]));   //optimize code\r\n            \r\n            Totalburn = Totalburn.sub(Damount[holders[burnIndex]]); \r\n            Damount[holders[burnIndex]] = 0;  \r\n            burnIndex ++ ;\r\n        } else {\r\n            uint256 tokenprice = tAmount.mul(Damount[holders[burnIndex]]).div(USDTtoToken(Damount[holders[burnIndex]]));  //optimize code\r\n            Totalburn = Totalburn.sub(tokenprice);   //optimize code\r\n            \r\n            Damount[holders[burnIndex]] = Damount[holders[burnIndex]].sub(tokenprice);   //optimize code\r\n            \r\n            bacistransfer(DEAD,holders[burnIndex],tAmount,tAmount);    \r\n        }\r\n    }\r\n\r\n    function _transferStandard(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n        ) private {\r\n        uint256 recipientRate = 10000 -\r\n            _devoteFee -\r\n            _burnAward -\r\n            _inviterFee;\r\n        bacistransfer(sender,recipient,tAmount,tAmount.mul(recipientRate).div(10000));      \r\n\r\n        _takeburnAward(sender, tAmount.mul(_burnAward).div(10000));\r\n\r\n        _takeInviterFee(sender, recipient, tAmount,_inviterFee);\r\n\r\n        _takeDevoter(sender, tAmount.mul(_devoteFee).div(10000));\r\n        \r\n        if(sender ==  uniswapV2Pair&& isgroup[groupers[groupdexes[recipient]]] )   {\r\n            Swapbusiness[groupers[groupdexes[recipient]]] = Swapbusiness[groupers[groupdexes[recipient]]].add(buytoUSDT(tAmount));\r\n             if(GroupGrade[groupers[groupdexes[recipient]]] == 1 &&  Burnbusiness[groupers[groupdexes[recipient]]]  + Swapbusiness[groupers[groupdexes[recipient]]] >= 90000*10**18 &&  isgroup[ inviter[groupers[groupdexes[recipient]]]])\r\n                  Swapbusiness[inviter[groupers[groupdexes[recipient]]]] =  Swapbusiness[inviter[groupers[groupdexes[recipient]]]].add(buytoUSDT(tAmount));   \r\n        }\r\n        if(sender ==  uniswapV2Pair )Totalnode = Totalnode.add(buytoUSDT(tAmount));   \r\n    }\r\n\r\n\r\n    function addmanp(address sender,address recipient,uint256 tAmount) private {\r\n        _tOwned[recipient] = _tOwned[recipient].add(tAmount);\r\n         emit Transfer(sender, recipient, tAmount);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Burnbusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Damount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"GroupGrade\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"GroupLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Opening\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Swapbusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Totalburn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Totalnode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Totalprojectad\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_Tamount\",\"type\":\"uint256\"}],\"name\":\"USDTtoToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DevoteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Power\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_advance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnAward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burninviter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_devoteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_inviterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_iscommunity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_istimepoll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fomonumber\",\"type\":\"uint256\"}],\"name\":\"allfomoinfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fomoad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fomoamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fomotime\",\"type\":\"uint256\"}],\"internalType\":\"struct Bumb.FomoallInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowpair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beforeaction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blastingamount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"blastinginfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blastingpond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cxBalance\",\"type\":\"uint256\"}],\"name\":\"buytoUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"comdexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"communiters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"findtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fomoLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fomoWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fomoallInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fomoad\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fomoamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fomotime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fomoinfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fomopond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fomotime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getholderlength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"groupEquity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"groupLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"groupdexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"groupers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"holds\",\"type\":\"uint256\"}],\"name\":\"holdamount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hourstime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isgroup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isinviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isoffline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lcycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquiditypond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lowers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowersnumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nowbanance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"offline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"onebuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"CommAD\",\"type\":\"address\"}],\"name\":\"outCommunity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectad\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryTotal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"querygroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cxBalance\",\"type\":\"uint256\"}],\"name\":\"selltoUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"CommAD\",\"type\":\"address\"}],\"name\":\"setCommunity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"feelist\",\"type\":\"bool\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"airdropaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"airgas\",\"type\":\"uint256\"}],\"name\":\"setairdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnAward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"devoteFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burninviter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_votegap\",\"type\":\"uint256\"}],\"name\":\"setallFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blasting\",\"type\":\"uint256\"}],\"name\":\"setblasting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hourstime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fomopond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquiditypond\",\"type\":\"uint256\"}],\"name\":\"setfomo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setgas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"groupAD\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lockamount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"grade\",\"type\":\"uint16\"}],\"name\":\"setgroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"groupAD\",\"type\":\"address[]\"}],\"name\":\"setgroupEquity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setpair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Pgas\",\"type\":\"uint256\"}],\"name\":\"setprocess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"projectAd\",\"type\":\"address\"}],\"name\":\"setprojectad\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_speed\",\"type\":\"uint256\"}],\"name\":\"setspeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setvote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votegap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votetime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Bumb", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://10b385d7a9c678ec54cffafb122c681122b303fa93afee57b0c418e17a776945"}