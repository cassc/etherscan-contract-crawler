{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BSCFOMO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n//9ecc02a53f8032a599c51cbc7f7c474835c40cb0e92543f7995708cce9e06df9\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\"; \\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n}\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\ncontract BSCFOMO is ReentrancyGuard{\\r\\n\\tusing SafeMath for uint256;\\r\\n    using SafeMath for uint8;\\r\\n\\r\\n\\tuint256 constant public INVEST_MIN_AMOUNT = 0.05 ether; // BNB\\r\\n\\tuint256[] public REFERRAL_PERCENTS = [50, 30, 20];\\r\\n\\tuint256 constant public PROJECT_FEE = 80;\\r\\n\\tuint256 constant public DEVELOPER_FEE = 20;\\r\\n\\tuint256 constant public PERCENT_STEP = 5;\\r\\n\\tuint256 constant public PERCENTS_DIVIDER= 1000;\\r\\n\\tuint256 constant public TIME_STEP = 1 days;\\r\\n\\t\\r\\n\\tuint256 constant public MAX_HOLD_PERCENT = 15;\\r\\n\\t\\r\\n\\tuint256 WITHDRAW_FEE_1 = 50; //5%\\r\\n\\tuint256 WITHDRAW_FEE_2 = 100; //10%\\r\\n\\r\\n\\taddress constant public BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\r\\n\\taddress constant public SWORD_ADDRESS = 0x778db6aEeBBb78dbC1b63dcD8571dA2D74897bEB;\\r\\n\\r\\n\\tuint256 constant public SWORD_BURN_FEE = 10;\\r\\n\\r\\n\\tIUniswapV2Router02 constant public router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n\\r\\n\\r\\n    \\r\\n\\t\\r\\n\\tuint256 public totalStaked;\\r\\n\\tuint256 public totalRefBonus;\\r\\n\\tuint256 public totalUsers;\\r\\n\\r\\n    struct Plan {\\r\\n        uint256 time;\\r\\n        uint256 percent;\\r\\n    }\\r\\n\\r\\n    Plan[] internal plans;\\r\\n\\r\\n\\tstruct Deposit {\\r\\n        uint8 plan;\\r\\n\\t\\tuint256 percent;\\r\\n\\t\\tuint256 amount;\\r\\n\\t\\tuint256 profit;\\r\\n\\t\\tuint256 start;\\r\\n\\t\\tuint256 finish;\\r\\n\\t}\\r\\n\\r\\n\\tstruct User {\\r\\n\\t\\tDeposit[] deposits;\\r\\n\\t\\tuint256 checkpoint;\\r\\n\\t\\tuint256 holdBonusCheckpoint;\\r\\n\\t\\taddress referrer;\\r\\n\\t\\tuint256 referrals;\\r\\n\\t\\tuint256 totalBonus;\\r\\n\\t\\tuint256 withdrawn;\\r\\n\\t}\\r\\n\\r\\n\\tmapping (address => User) internal users;\\r\\n\\r\\n\\tuint256 public startUNIX;\\r\\n\\taddress private commissionWallet;\\r\\n\\taddress private developerWallet;\\r\\n\\r\\n\\tbool private launched = false;\\r\\n\\r\\n\\tevent Newbie(address user);\\r\\n\\tevent NewDeposit(address indexed user, uint8 plan, uint256 percent, uint256 amount, uint256 profit, uint256 start, uint256 finish);\\r\\n\\tevent Withdrawn(address indexed user, uint256 amount);\\r\\n\\tevent RefBonus(address indexed referrer, address indexed referral, uint256 indexed level, uint256 amount);\\r\\n\\tevent Swap(uint256 amount);\\r\\n\\r\\n\\tconstructor(address wallet, address _developer) {\\r\\n\\t\\trequire(!isContract(wallet));\\r\\n\\t\\trequire(!isContract(_developer));\\r\\n\\t\\tcommissionWallet = wallet;\\r\\n\\t\\tdeveloperWallet = _developer;\\r\\n        startUNIX = block.timestamp.add(365 days);\\r\\n\\r\\n        plans.push(Plan(14, 80)); // 8% per day for 14 days\\r\\n        plans.push(Plan(21, 75)); // 7.5% per day for 21 days\\r\\n        plans.push(Plan(28, 70)); // 7% per day for 28 days\\r\\n\\t\\tplans.push(Plan(14, 80)); // 8% per day for 14 days (at the end, compounding)\\r\\n        plans.push(Plan(21, 75)); // 7.5% per day for 21 days (at the end, compounding)\\r\\n        plans.push(Plan(28, 70)); // 7% per day for 28 days (at the end, compounding)\\r\\n\\t}\\r\\n\\r\\n    function launch() public {\\r\\n        require(msg.sender == developerWallet);\\r\\n\\t\\trequire(!launched,\\\"already launched\\\");\\r\\n\\r\\n\\t\\tstartUNIX = block.timestamp;\\r\\n\\t\\tlaunched = true;\\r\\n    } \\r\\n\\r\\n\\r\\n    function invest(address referrer,uint8 plan) public payable nonReentrant {\\r\\n        _invest(referrer, plan, msg.sender, msg.value);\\r\\n\\r\\n\\t\\tuint256 swapAndBurnAmount = msg.value.mul(SWORD_BURN_FEE).div(PERCENTS_DIVIDER);\\r\\n\\t\\tswapAndBurn(swapAndBurnAmount);\\r\\n           \\r\\n    }\\r\\n\\r\\n\\r\\n\\tfunction _invest(address referrer, uint8 plan, address sender, uint256 value) private {\\r\\n\\t\\trequire(value >= INVEST_MIN_AMOUNT);\\r\\n        require(plan < 6, \\\"Invalid plan\\\");\\r\\n        require(startUNIX < block.timestamp, \\\"contract hasn`t started yet\\\");\\r\\n\\t\\t\\r\\n\\r\\n\\t\\tuint256 fee = value.mul(PROJECT_FEE).div(PERCENTS_DIVIDER);\\r\\n\\t\\tpayable(commissionWallet).transfer(fee);\\r\\n\\t\\tuint256 developerFee = value.mul(DEVELOPER_FEE).div(PERCENTS_DIVIDER);\\r\\n\\t\\tpayable(developerWallet).transfer(developerFee);\\r\\n\\t\\t\\r\\n\\t\\tUser storage user = users[sender];\\r\\n\\r\\n\\t\\tif (user.referrer == address(0)) {\\r\\n\\t\\t\\tif (users[referrer].deposits.length > 0 && referrer != sender) {\\r\\n\\t\\t\\t\\tuser.referrer = referrer;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\taddress upline = user.referrer;\\r\\n\\t\\t\\tfor (uint256 i = 0; i < 3; i++) {\\r\\n\\t\\t\\t\\tif (upline != address(0)) {\\r\\n\\t\\t\\t\\t\\tusers[upline].referrals = users[upline].referrals.add(1);\\r\\n\\t\\t\\t\\t\\tupline = users[upline].referrer;\\r\\n\\t\\t\\t\\t} else break;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t\\t\\tif (user.referrer != address(0)) {\\r\\n\\t\\t\\t\\t\\tuint256 _refBonus = 0;\\r\\n\\t\\t\\t\\t\\taddress upline = user.referrer;\\r\\n\\t\\t\\t\\t\\tfor (uint256 i = 0; i < 3; i++) {\\r\\n\\t\\t\\t\\t\\t\\tif (upline != address(0)) {\\r\\n\\t\\t\\t\\t\\t\\t\\tuint256 amount = value.mul(REFERRAL_PERCENTS[i]).div(PERCENTS_DIVIDER);\\r\\n\\t\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\tusers[upline].totalBonus = users[upline].totalBonus.add(amount);\\r\\n                            payable(upline).transfer(amount);\\r\\n\\t\\t\\t\\t\\t\\t\\t_refBonus = _refBonus.add(amount);\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t\\t\\temit RefBonus(upline, sender, i, amount);\\r\\n\\t\\t\\t\\t\\t\\t\\tupline = users[upline].referrer;\\r\\n\\t\\t\\t\\t\\t\\t} else break;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\ttotalRefBonus = totalRefBonus.add(_refBonus);\\r\\n\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\r\\n\\r\\n\\t\\tif (user.deposits.length == 0) {\\r\\n\\t\\t\\tuser.checkpoint = block.timestamp;\\r\\n\\t\\t\\tuser.holdBonusCheckpoint = block.timestamp;\\r\\n\\t\\t\\temit Newbie(sender);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t\\r\\n\\r\\n\\t\\t(uint256 percent, uint256 profit, uint256 finish) = getResult(plan, value);\\r\\n\\t\\t\\r\\n\\t\\tuser.deposits.push(Deposit(plan, percent, value, profit, block.timestamp, finish));\\r\\n\\r\\n\\t\\ttotalStaked = totalStaked.add(value);\\r\\n        totalUsers = totalUsers.add(1);\\r\\n\\t\\t\\r\\n\\t\\temit NewDeposit(sender, plan, percent, value, profit, block.timestamp, finish);\\r\\n\\t}\\r\\n\\r\\n\\tfunction withdraw() public nonReentrant{\\r\\n\\t\\tUser storage user = users[msg.sender];\\r\\n\\r\\n\\t\\tuint256 totalAmount = getUserDividends(msg.sender);\\r\\n\\r\\n\\t\\trequire(totalAmount > 0, \\\"User has no dividends\\\");\\r\\n\\r\\n\\t\\tuint256 contractBalance = address(this).balance;\\r\\n\\t\\tif (contractBalance < totalAmount) {\\r\\n\\t\\t\\ttotalAmount = contractBalance;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuser.checkpoint = block.timestamp;\\r\\n\\t\\tuser.holdBonusCheckpoint = block.timestamp;\\r\\n\\r\\n\\t\\tuser.withdrawn = user.withdrawn.add(totalAmount);\\r\\n\\r\\n\\t\\tuint256 swapAndBurnAmount = totalAmount.mul(SWORD_BURN_FEE).div(PERCENTS_DIVIDER);\\r\\n\\t\\tswapAndBurn(swapAndBurnAmount);\\r\\n\\r\\n\\t\\tpayable(msg.sender).transfer(totalAmount.sub(swapAndBurnAmount));\\r\\n\\r\\n\\t\\temit Withdrawn(msg.sender, totalAmount);\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction swapAndBurn(uint256 amount) internal {\\r\\n\\t\\taddress[] memory path = new address[](2);\\r\\n\\r\\n\\t\\tpath[0] = router.WETH();\\r\\n        path[1] = SWORD_ADDRESS;\\r\\n\\r\\n\\t\\trouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\\r\\n            0,\\r\\n            path,\\r\\n            BURN_ADDRESS,\\r\\n            block.timestamp.add(300)\\r\\n        );\\r\\n\\r\\n\\t\\temit Swap(amount);\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\t\\r\\n    \\r\\n\\r\\n\\tfunction getContractBalance() public view returns (uint256) {\\r\\n\\t\\treturn address(this).balance;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getPlanInfo(uint8 plan) public view returns(uint256 time, uint256 percent) {\\r\\n\\t\\ttime = plans[plan].time;\\r\\n\\t\\tpercent = getPercent(plan);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getPercent(uint8 plan) public view returns (uint256) {\\r\\n\\t    \\r\\n\\t\\t\\treturn plans[plan].percent.add(PERCENT_STEP.mul(block.timestamp.sub(startUNIX)).div(TIME_STEP));\\r\\n\\t\\t\\r\\n    }\\r\\n    \\r\\n\\r\\n\\tfunction getResult(uint8 plan, uint256 deposit) public view returns (uint256 percent, uint256 profit, uint256 finish) {\\r\\n\\t\\tpercent = getPercent(plan);\\r\\n\\r\\n\\t\\r\\n\\t\\tif (plan < 3) {\\r\\n\\t\\t\\tprofit = deposit.mul(percent).div(PERCENTS_DIVIDER).mul(plans[plan].time);\\r\\n\\t\\t} else if (plan < 6) {\\r\\n\\t\\t\\tfor (uint256 i = 0; i < plans[plan].time; i++) {\\r\\n\\t\\t\\t\\tprofit = profit.add((deposit.add(profit)).mul(percent).div(PERCENTS_DIVIDER));\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfinish = block.timestamp.add(plans[plan].time.mul(TIME_STEP));\\r\\n\\t}\\r\\n\\t\\r\\n\\t function getUserPercentRate(address userAddress) public view returns (uint) {\\r\\n        User storage user = users[userAddress];\\r\\n\\r\\n        uint256 timeMultiplier = block.timestamp.sub(user.holdBonusCheckpoint).div(TIME_STEP); // +0.1% per day\\r\\n            if (timeMultiplier > MAX_HOLD_PERCENT) {\\r\\n                timeMultiplier = MAX_HOLD_PERCENT;\\r\\n            }\\r\\n\\r\\n         return timeMultiplier;\\r\\n    }\\r\\n    \\r\\n\\r\\n\\tfunction getUserDividends(address userAddress) public view returns (uint256) {\\r\\n\\t\\tUser storage user = users[userAddress];\\r\\n\\r\\n\\t\\tuint256 totalAmount;\\r\\n\\t\\t\\r\\n\\t\\tuint256 holdBonus = getUserPercentRate(userAddress);\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i < user.deposits.length; i++) {\\r\\n\\r\\n\\r\\n\\t\\t\\tif (user.checkpoint < user.deposits[i].finish) {\\r\\n\\t\\t\\t\\tif (user.deposits[i].plan < 3) {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tuint256 share = user.deposits[i].amount.mul(user.deposits[i].percent.add(holdBonus)).div(PERCENTS_DIVIDER);\\r\\n\\t\\t\\t\\t\\tuint256 from = user.deposits[i].start > user.checkpoint ? user.deposits[i].start : user.checkpoint;\\r\\n\\t\\t\\t\\t\\tuint256 to = user.deposits[i].finish < block.timestamp ? user.deposits[i].finish : block.timestamp;\\r\\n\\t\\t\\t\\t\\tif (from < to) {\\r\\n\\t\\t\\t\\t\\t\\tuint256 _dividends = share.mul(to.sub(from)).div(TIME_STEP);\\r\\n\\t\\t\\t\\t\\t\\tuint256 _dividendsWithFee = _dividends.sub(_dividends.mul(WITHDRAW_FEE_1).div(PERCENTS_DIVIDER));\\r\\n\\t\\t\\t\\t\\t\\ttotalAmount = totalAmount.add(_dividendsWithFee);\\r\\n\\t\\t\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif(block.timestamp > user.deposits[i].finish) {\\r\\n\\t\\t\\t\\t\\t\\tuint256 _profit = user.deposits[i].profit;\\r\\n\\t\\t\\t\\t\\t\\tuint256 _profitWithFee = _profit.sub(_profit.mul(WITHDRAW_FEE_2).div(PERCENTS_DIVIDER));\\r\\n\\t\\t\\t\\t\\t\\ttotalAmount = totalAmount.add(_profitWithFee);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n       \\r\\n\\t\\treturn totalAmount;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getUserAvailable(address userAddress) public view returns (uint256) {\\r\\n\\t\\tUser storage user = users[userAddress];\\r\\n\\r\\n\\t\\tuint256 totalAmount;\\r\\n\\t\\t\\r\\n\\t\\tuint256 holdBonus = getUserPercentRate(userAddress);\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i < user.deposits.length; i++) {\\r\\n\\r\\n\\r\\n\\t\\t\\tif (user.checkpoint < user.deposits[i].finish) {\\r\\n\\t\\t\\t\\tif (user.deposits[i].plan < 3) {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t\\tuint256 share = user.deposits[i].amount.mul(user.deposits[i].percent.add(holdBonus)).div(PERCENTS_DIVIDER);\\r\\n\\t\\t\\t\\t\\tuint256 from = user.deposits[i].start > user.checkpoint ? user.deposits[i].start : user.checkpoint;\\r\\n\\t\\t\\t\\t\\tuint256 to = user.deposits[i].finish < block.timestamp ? user.deposits[i].finish : block.timestamp;\\r\\n\\t\\t\\t\\t\\tif (from < to) {\\r\\n\\t\\t\\t\\t\\t\\ttotalAmount = totalAmount.add(share.mul(to.sub(from)).div(TIME_STEP));\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tif(block.timestamp > user.deposits[i].finish) {\\r\\n\\t\\t\\t\\t\\t\\ttotalAmount = totalAmount.add(user.deposits[i].profit);\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n       \\r\\n\\t\\treturn totalAmount;\\r\\n\\t}\\r\\n\\r\\n    function getContractInfo() public view returns(uint256, uint256, uint256) {\\r\\n        return(totalStaked, totalRefBonus, totalUsers);\\r\\n    }\\r\\n\\r\\n\\tfunction getUserWithdrawn(address userAddress) public view returns(uint256) {\\r\\n\\t\\treturn users[userAddress].withdrawn;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getUserCheckpoint(address userAddress) public view returns(uint256) {\\r\\n\\t\\treturn users[userAddress].checkpoint;\\r\\n\\t}\\r\\n    \\r\\n\\tfunction getUserReferrer(address userAddress) public view returns(address) {\\r\\n\\t\\treturn users[userAddress].referrer;\\r\\n\\t} \\r\\n\\r\\n\\tfunction getUserDownlineCount(address userAddress) public view returns(uint256) {\\r\\n\\t\\treturn (users[userAddress].referrals);\\r\\n\\t}\\r\\n\\r\\n\\tfunction getUserReferralTotalBonus(address userAddress) public view returns(uint256) {\\r\\n\\t\\treturn users[userAddress].totalBonus;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\tfunction getUserAmountOfDeposits(address userAddress) public view returns(uint256) {\\r\\n\\t\\treturn users[userAddress].deposits.length;\\r\\n\\t}\\r\\n\\r\\n\\tfunction getUserTotalDeposits(address userAddress) public view returns(uint256 amount) {\\r\\n\\t\\tfor (uint256 i = 0; i < users[userAddress].deposits.length; i++) {\\r\\n\\t\\t\\tamount = amount.add(users[userAddress].deposits[i].amount);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction getUserDepositInfo(address userAddress, uint256 index) public view returns(uint8 plan, uint256 percent, uint256 amount, uint256 profit, uint256 start, uint256 finish) {\\r\\n\\t    User storage user = users[userAddress];\\r\\n\\r\\n\\t\\tplan = user.deposits[index].plan;\\r\\n\\t\\tpercent = user.deposits[index].percent;\\r\\n\\t\\tamount = user.deposits[index].amount;\\r\\n\\t\\tprofit = user.deposits[index].profit;\\r\\n\\t\\tstart = user.deposits[index].start;\\r\\n\\t\\tfinish = user.deposits[index].finish;\\r\\n\\t}\\r\\n\\r\\n\\tfunction isContract(address addr) internal view returns (bool) {\\r\\n        uint size;\\r\\n        assembly { size := extcodesize(addr) }\\r\\n        return size > 0;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    \\r\\n     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEVELOPER_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVEST_MIN_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_HOLD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWORD_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWORD_BURN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"getPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"getPlanInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"getResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserAmountOfDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserDepositInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDownlineCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserPercentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralTotalBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserTotalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startUNIX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRefBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BSCFOMO", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000027799a2d63a9c3c085f05c25df1571fe10b80d7e00000000000000000000000014f3afddda5133a13e5068fd51ce57a066d94a01", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}