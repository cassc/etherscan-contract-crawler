{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n\r\n// router inferface\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n}\r\n\r\n// Interface of the ERC20 standard as defined in the EIP.\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address from, address to) external view returns (uint256);\r\n    function approve(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// safe transfer\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        // (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n\r\n// PriceUSDTCalcuator interface\r\ninterface IPriceUSDTCalcuator {\r\n    function tokenPriceUSDT(address token) external view returns (uint256);\r\n    function lpPriceUSDT(address lp) external view returns (uint256);\r\n}\r\n\r\n// ETELeaderTracker interface\r\ninterface IETELeaderTracker {\r\n    function swapToLeader(address _eteToken) external;\r\n}\r\n\r\n// owner\r\nabstract contract Ownable {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"owner error\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// new swap V2.\r\n// ete is mos.\r\n// new..\r\ncontract NewSwapV2 is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    address public priceUSDTCalcuator;  // price usdt calculator contract address.\r\n    address public eteLeaderTracker;    // ete leader tracker contract address.\r\n    address public ete;                 // ete address.\r\n    address public usdt;                // usdt address.\r\n    address public router;              // router address.\r\n\r\n    mapping(uint256 => swapMsg) public swapMsgOf; // all swap.\r\n    struct swapMsg {\r\n        address fromToken;  // pay token address.\r\n        bool fromIsLp;      //  from is lp.\r\n        address toToken;    // gain token address.\r\n        bool toIsLp;        //  to is lp.\r\n        bool isOpen;        // is open.\r\n    }\r\n    mapping(address => bool) public priceIsUsdt;      // price is usdt.(like xete, sete, bete, cete, ...)\r\n    mapping(address => uint256) public priceIsExist;  // price is user-defined. (if umos price usdt is 1e19, 1umos = 10usdt, if 0 is not exist).\r\n\r\n    uint256 public swapMsgOfCount;               // swap pool count.\r\n    bool public allIsOpen = true;                // all pool is open.\r\n    bool public usdtSwapIsAddLiquidity = true;   // true= is add. false = not add.\r\n\r\n    constructor(\r\n        address priceUSDTCalcuator_,\r\n        address eteLeaderTracker_,\r\n        address mos_,\r\n        address usdt_,\r\n        address router_\r\n    ) {\r\n        priceUSDTCalcuator = priceUSDTCalcuator_;\r\n        eteLeaderTracker = eteLeaderTracker_;\r\n        ete = mos_;\r\n        usdt = usdt_;\r\n        router = router_;\r\n\r\n        TransferHelper.safeApprove(ete, router, type(uint256).max);\r\n        TransferHelper.safeApprove(usdt, router, type(uint256).max);\r\n    }\r\n\r\n\r\n    event SwapTo(address account, address fromToken, uint256 fromAmount, address toToken, uint256 toAmount);\r\n\r\n\r\n    function addApprove(address _token, address _to, uint256 _amount) public onlyOwner {\r\n        TransferHelper.safeApprove(_token, _to, _amount);\r\n    }\r\n\r\n    function setPriceUSDTCalcuator(address newPriceUSDTCalcuator) public onlyOwner {\r\n        priceUSDTCalcuator = newPriceUSDTCalcuator;\r\n    }\r\n\r\n    function setEteLeaderTracker(address newEteLeaderTracker) public onlyOwner {\r\n        eteLeaderTracker = newEteLeaderTracker;\r\n    }\r\n\r\n    function setEte(address newEte) public onlyOwner {\r\n        ete = newEte;\r\n    }\r\n\r\n    function setUsdt(address newUsdt) public onlyOwner {\r\n        usdt = newUsdt;\r\n    }\r\n\r\n    function setRouter(address newRouter) public onlyOwner {\r\n        router = newRouter;\r\n    }\r\n\r\n    function setAllIsOpen(bool newAllIsOpen) public onlyOwner {\r\n        allIsOpen = newAllIsOpen;\r\n    }\r\n\r\n    function setUsdtSwapIsAddLiquidity(bool newUsdtSwapIsAddLiquidity) public onlyOwner {\r\n        usdtSwapIsAddLiquidity = newUsdtSwapIsAddLiquidity;\r\n    }\r\n    \r\n    // add price eq usdt of token.\r\n    function addPriceIsUsdt(address _token, bool _isPriceUsdt) public onlyOwner {\r\n        require(_token != address(0), \"zero address error 0\");\r\n        priceIsUsdt[_token] = _isPriceUsdt;\r\n    }\r\n\r\n    // add token price is exist.\r\n    function addPriceIsExist(address _token, uint256 _priceUsdtAmount) public onlyOwner {\r\n        require(_token != address(0), \"zero address error 0\");\r\n        priceIsExist[_token] = _priceUsdtAmount;\r\n    }\r\n\r\n    // add swap msg\r\n    function addSwapMsg(address _fromToken, bool _fromIsLp, address _toToken, bool _toIsLp, bool _isOpen) public onlyOwner {\r\n        require(_fromToken != address(0), \"zero address error 0\");\r\n        require(_toToken != address(0), \"zero address error 1\");\r\n\r\n        swapMsgOfCount++;\r\n        swapMsgOf[swapMsgOfCount] = swapMsg({\r\n            fromToken: _fromToken,\r\n            fromIsLp: _fromIsLp,\r\n            toToken: _toToken,\r\n            toIsLp: _toIsLp,\r\n            isOpen: _isOpen\r\n        });\r\n    }\r\n\r\n    // change swap smg\r\n    function changeSwapMsg(uint256 _index, address _fromToken, bool _fromIsLp, address _toToken, bool _toIsLp, bool _isOpen) public onlyOwner {\r\n        require(_index > 0 && _index <= swapMsgOfCount, \"index error\");\r\n        require(_fromToken != address(0), \"zero address error 0\");\r\n        require(_toToken != address(0), \"zero address error 1\");\r\n\r\n        swapMsgOf[_index] = swapMsg({\r\n            fromToken: _fromToken,\r\n            fromIsLp: _fromIsLp,\r\n            toToken: _toToken,\r\n            toIsLp: _toIsLp,\r\n            isOpen: _isOpen\r\n        });\r\n    }\r\n\r\n    // get swap lock\r\n    function getAllSwapMsg()external view returns (swapMsg[] memory allSwapMsg){\r\n        uint256 _count = swapMsgOfCount; // save gas.\r\n        allSwapMsg = new swapMsg[](_count);\r\n        for (uint256 i = 1; i <= _count; i++) {\r\n            allSwapMsg[i - 1] = swapMsgOf[i];\r\n        }\r\n    }\r\n\r\n    // token -> usdt\r\n    function calculateTokenAmountEqUsdtAmount(address _tokenOrLp, uint256 _tokenAmount, bool _isLp) public view returns (uint256) {\r\n        if(priceIsExist[_tokenOrLp] > 0) {\r\n            // is exist.\r\n            uint256 _price = priceIsExist[_tokenOrLp];\r\n            uint256 usdtAmount = _tokenAmount.mul(_price).div(1e18);\r\n            return usdtAmount;\r\n        }\r\n\r\n        if (priceIsUsdt[_tokenOrLp]) {\r\n            // if price eq usdt.\r\n            return _tokenAmount;\r\n        } else if (_isLp) {\r\n            // is lp\r\n            uint256 lpPrice = IPriceUSDTCalcuator(priceUSDTCalcuator).lpPriceUSDT(_tokenOrLp);\r\n            uint256 usdtAmount = _tokenAmount.mul(lpPrice).div(1e18);\r\n            return usdtAmount;\r\n        } else {\r\n            // is token\r\n            uint256 tokenPrice = IPriceUSDTCalcuator(priceUSDTCalcuator).tokenPriceUSDT(_tokenOrLp);\r\n            uint256 usdtAmount = _tokenAmount.mul(tokenPrice).div(1e18);\r\n            return usdtAmount;\r\n        }\r\n    }\r\n\r\n    // usdt -> token\r\n    function calculateUsdtAmountEqTokenAmount(address _tokenOrLp, uint256 _usdtAmount, bool _isLp) public view returns (uint256) {\r\n        if(priceIsExist[_tokenOrLp] > 0) {\r\n            // is exist.\r\n            uint256 _price = priceIsExist[_tokenOrLp];\r\n            uint256 tokenAmount = _usdtAmount.mul(1e18).div(_price);\r\n            return tokenAmount;\r\n        }\r\n\r\n        if (priceIsUsdt[_tokenOrLp]) {\r\n            // if price eq usdt.\r\n            return _usdtAmount;\r\n        } else if (_isLp) {\r\n            // is lp\r\n            uint256 lpPrice = IPriceUSDTCalcuator(priceUSDTCalcuator).lpPriceUSDT(_tokenOrLp); // 5e18\r\n            uint256 lpAmount = _usdtAmount.mul(1e18).div(lpPrice);\r\n            return lpAmount;\r\n        } else {\r\n            // is token\r\n            uint256 tokenPrice = IPriceUSDTCalcuator(priceUSDTCalcuator).tokenPriceUSDT(_tokenOrLp);\r\n            uint256 tokenAmount = _usdtAmount.mul(1e18).div(tokenPrice);\r\n            return tokenAmount;\r\n        }\r\n    }\r\n\r\n    // swap before\r\n    function swapToBefore(uint256 _index, uint256 _fromAmount) public view returns (uint256 toAmount) {\r\n        swapMsg memory _swapMsg = swapMsgOf[_index];\r\n        // calculate to amount.\r\n        uint256 _fromAmountPriceUsdt = calculateTokenAmountEqUsdtAmount(_swapMsg.fromToken, _fromAmount, _swapMsg.fromIsLp);\r\n        toAmount = calculateUsdtAmountEqTokenAmount(_swapMsg.toToken, _fromAmountPriceUsdt, _swapMsg.toIsLp);\r\n\r\n        // if from is usdt. fee is 2%.\r\n        if(_swapMsg.fromToken == usdt) {\r\n            toAmount = toAmount.mul(98).div(100);\r\n        }\r\n    }\r\n\r\n    // swap\r\n    function swapTo(uint256 _index, uint256 _fromAmount) public nonReentrant {\r\n        require(allIsOpen, \"not all open\");\r\n        address account = msg.sender;\r\n        swapMsg memory _swapMsg = swapMsgOf[_index];\r\n        require(_swapMsg.isOpen, \"not open\");\r\n        require(!isContract(account), \"not user1\");\r\n        require(tx.origin == account, \"not user2\");\r\n\r\n        // calculate to amount.\r\n        uint256 _toAmount = swapToBefore(_index, _fromAmount);\r\n        require(_fromAmount > 0, \"from amount is zero\");\r\n        require(_toAmount > 0, \"to amount is zero\");\r\n        TransferHelper.safeTransferFrom(_swapMsg.fromToken, account, address(this), _fromAmount);\r\n        TransferHelper.safeTransfer(_swapMsg.toToken, account, _toAmount);\r\n\r\n        // emit\r\n        emit SwapTo(account, _swapMsg.fromToken, _fromAmount, _swapMsg.toToken, _toAmount);\r\n        \r\n        // if is add && fromtoken is usdt, add ete-usdt pool.\r\n        if (usdtSwapIsAddLiquidity && _swapMsg.fromToken == usdt) _addPool(_fromAmount);\r\n\r\n        // help swap\r\n        _helpSwap();\r\n    }\r\n\r\n    // help swap earn.\r\n    function _helpSwap() private {\r\n        try IETELeaderTracker(eteLeaderTracker).swapToLeader(ete) {} catch {}\r\n    }\r\n\r\n    function _addPool(uint256 _usdtAmount) private {\r\n        // swap ete\r\n        uint256 _usdtSwapEteAmount = _usdtAmount.div(2);\r\n        // ete balance before.\r\n        uint256 _eteBalanceBefore = IERC20(ete).balanceOf(address(this));\r\n\r\n        // usdt swap ete\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = usdt;\r\n        _path[1] = ete;\r\n        IUniswapV2Router02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            _usdtSwapEteAmount,\r\n            0,\r\n            _path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        // ete balance last.\r\n        uint256 _eteBalanceLast = IERC20(ete).balanceOf(address(this));\r\n        // add pool\r\n        uint256 _eteAddPoolAmount = _eteBalanceLast.sub(_eteBalanceBefore);\r\n        IUniswapV2Router02(router).addLiquidity(\r\n            usdt,\r\n            ete,\r\n            _usdtSwapEteAmount,\r\n            _eteAddPoolAmount,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // take token\r\n    function takeToken(address token, address to, uint256 value) external onlyOwner {\r\n        require(to != address(0), \"zero address error\");\r\n        require(value > 0, \"value zero error\");\r\n        TransferHelper.safeTransfer(token, to, value);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceUSDTCalcuator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"eteLeaderTracker_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mos_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"SwapTo\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceUsdtAmount\",\"type\":\"uint256\"}],\"name\":\"addPriceIsExist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isPriceUsdt\",\"type\":\"bool\"}],\"name\":\"addPriceIsUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_fromIsLp\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_toIsLp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"addSwapMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allIsOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOrLp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLp\",\"type\":\"bool\"}],\"name\":\"calculateTokenAmountEqUsdtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenOrLp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLp\",\"type\":\"bool\"}],\"name\":\"calculateUsdtAmountEqTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fromToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_fromIsLp\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_toIsLp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"changeSwapMsg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ete\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eteLeaderTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllSwapMsg\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromIsLp\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toIsLp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"internalType\":\"struct NewSwapV2.swapMsg[]\",\"name\":\"allSwapMsg\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceIsExist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceIsUsdt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceUSDTCalcuator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newAllIsOpen\",\"type\":\"bool\"}],\"name\":\"setAllIsOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newEte\",\"type\":\"address\"}],\"name\":\"setEte\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newEteLeaderTracker\",\"type\":\"address\"}],\"name\":\"setEteLeaderTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPriceUSDTCalcuator\",\"type\":\"address\"}],\"name\":\"setPriceUSDTCalcuator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUsdt\",\"type\":\"address\"}],\"name\":\"setUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newUsdtSwapIsAddLiquidity\",\"type\":\"bool\"}],\"name\":\"setUsdtSwapIsAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swapMsgOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromIsLp\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toIsLp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapMsgOfCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromAmount\",\"type\":\"uint256\"}],\"name\":\"swapTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromAmount\",\"type\":\"uint256\"}],\"name\":\"swapToBefore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"takeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtSwapIsAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NewSwapV2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008c8fb55f72b5bd5068e514f1095b91cef38a8b5f000000000000000000000000d8ae6c8174c4c82fec8f510a2b933df4b35a78d7000000000000000000000000762b0f0fdaa605a24893ce80081ff4e8dbba58b000000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e61ae9ff15f0d38f5345bd584b226716847617dfd7a4365f149b57f14ce1add5"}