{"SourceCode": "// File: contracts/util/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.7;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/util/Ownable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\n abstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/token/VIPLockToken.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\nabstract contract VIPLockToken is Ownable {\r\n\r\n    struct vipLockedToken {\r\n        uint256 lockedToken;\r\n        uint256 unlockRegisteredTime;\r\n        uint256 unlockAfter;\r\n        uint256 unlockActualTime;\r\n        bool unlocked;\r\n        bool existed;\r\n    }\r\n\r\n    address public _locker;\r\n    uint256 unlockAddedTime;\r\n    uint256 relockVIPAddedTime;\r\n    mapping(address => vipLockedToken) mappingAddressToVIPLock;\r\n\r\n    // Event\r\n    event VIPTokenLocked(address indexed account, uint256 amount);\r\n    event VIPTokenUnlocked(address indexed account, uint256 amount);\r\n    event VIPTokenUnlockRegisted(address account);\r\n    event VIPLockerTransferred(\r\n        address indexed previousLocker,\r\n        address indexed newLocker\r\n    );\r\n    event VIPUnlockAddedTimeModified(\r\n        uint256 indexed previousAddedTime,\r\n        uint256 indexed newAddedTime\r\n    );\r\n\r\n    event VIPRelockAddedTimeModified(\r\n        uint256 indexed previousAddedTime,\r\n        uint256 indexed newAddedTime\r\n    );\r\n\r\n    modifier onlyLocker() {\r\n        require(_locker == _msgSender(), \"Caller is not the locker\");\r\n        _;\r\n    }\r\n\r\n    function transferLocker(address newLockerAddress)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(newLockerAddress != address(0));\r\n        emit VIPLockerTransferred(_locker, newLockerAddress);\r\n        _locker = newLockerAddress;\r\n        return true;\r\n    }\r\n\r\n    function modifyUnlockAddedTime(uint256 newUnlockAddedTime)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        emit VIPUnlockAddedTimeModified(unlockAddedTime, newUnlockAddedTime);\r\n        unlockAddedTime = newUnlockAddedTime;\r\n        return true;\r\n    }\r\n\r\n    function modifyRelockVIPAddedTime(uint256 newRelockVIPAddedTime)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        emit VIPRelockAddedTimeModified(\r\n            relockVIPAddedTime,\r\n            newRelockVIPAddedTime\r\n        );\r\n        relockVIPAddedTime = newRelockVIPAddedTime;\r\n        return true;\r\n    }\r\n\r\n    /** @dev Get `relockVIPAddedTime` that is added from time of unlock\r\n     * token request action. After that time, user can do lock action again\r\n     */\r\n    function getRelockVIPAddedTime() public view returns (uint256) {\r\n        return relockVIPAddedTime;\r\n    }\r\n\r\n    /** @dev Get `unlockAddedTime` that is added from time of unlock token request action\r\n     */\r\n    function getUnlockAddedTime() public view returns (uint256) {\r\n        return unlockAddedTime;\r\n    }\r\n\r\n    /** @dev Current locked token of `address`\r\n     */\r\n    function currentVIPLockTokenOf(address account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[\r\n            account\r\n        ];\r\n        if (!vipLockOfAddress.existed) {\r\n            return 0;\r\n        }\r\n        if (vipLockOfAddress.unlocked) {\r\n            return 0;\r\n        }\r\n        if (\r\n            vipLockOfAddress.unlockAfter > 0 &&\r\n            vipLockOfAddress.unlockAfter <= block.timestamp\r\n        ) {\r\n            return 0;\r\n        }\r\n        return vipLockOfAddress.lockedToken;\r\n    }\r\n\r\n    /** @dev Lock `amount` of token for current sender\r\n     */\r\n    function vipLockToken(uint256 amount) public returns (bool) {\r\n        _vipUnlock(_msgSender());\r\n        bool done = _vipLock(_msgSender(), amount);\r\n        require(done);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Lock `amount` of token for `account`\r\n     */\r\n    function _vipLock(address account, uint256 amount) internal returns (bool) {\r\n        // check previous unlock time\r\n        require(amount > 0);\r\n        require(\r\n            getAvailableBalance(account) >= amount,\r\n            \"Not enough unlocked tokens\"\r\n        );\r\n        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[\r\n            account\r\n        ];\r\n        if (vipLockOfAddress.existed) {\r\n            require(vipLockOfAddress.unlocked, \"Already has locked VIP\");\r\n            require(\r\n                block.timestamp >=\r\n                    vipLockOfAddress.unlockRegisteredTime + relockVIPAddedTime, \"Await next lock VIP\"\r\n            );\r\n        }\r\n        mappingAddressToVIPLock[account] = vipLockedToken(\r\n            amount,\r\n            0,\r\n            0,\r\n            0,\r\n            false,\r\n            true\r\n        );\r\n        emit VIPTokenLocked(account, amount);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Get vip locked token info\r\n     */\r\n    function vipLockInfo(address account)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            bool,\r\n            bool\r\n        )\r\n    {\r\n        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[\r\n            account\r\n        ];\r\n        return (\r\n            vipLockOfAddress.lockedToken,\r\n            vipLockOfAddress.unlockRegisteredTime,\r\n            vipLockOfAddress.unlockAfter,\r\n            vipLockOfAddress.unlockActualTime,\r\n            vipLockOfAddress.unlocked,\r\n            vipLockOfAddress.existed\r\n        );\r\n    }\r\n\r\n    /** @dev Register unlock vip token of sender\r\n     */\r\n    function vipUnlockRequest() public returns (bool) {\r\n        address account = _msgSender();\r\n        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[\r\n            account\r\n        ];\r\n        require(vipLockOfAddress.existed  && \r\n          !vipLockOfAddress.unlocked &&\r\n          vipLockOfAddress.unlockAfter == 0 && \r\n          vipLockOfAddress.unlockRegisteredTime  == 0,\"Not valid unlock request\");\r\n        vipLockOfAddress.unlockAfter = block.timestamp + unlockAddedTime;\r\n        vipLockOfAddress.unlockRegisteredTime = block.timestamp;\r\n        mappingAddressToVIPLock[account] = vipLockOfAddress;\r\n        if (unlockAddedTime == 0) {\r\n            return _vipUnlock(account);\r\n        }\r\n        emit VIPTokenUnlockRegisted(account);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Unlock vip locked token for `account`\r\n     */\r\n    function _vipUnlock(address account) internal returns (bool) {\r\n        vipLockedToken memory vipLockOfAddress = mappingAddressToVIPLock[\r\n            account\r\n        ];\r\n        if (\r\n            !vipLockOfAddress.existed ||\r\n            vipLockOfAddress.unlocked ||\r\n            vipLockOfAddress.unlockAfter == 0 ||\r\n            block.timestamp < vipLockOfAddress.unlockAfter\r\n        ) {\r\n            return false;\r\n        }\r\n        vipLockOfAddress.unlocked = true;\r\n        vipLockOfAddress.lockedToken = 0;\r\n        vipLockOfAddress.unlockActualTime = block.timestamp;\r\n        mappingAddressToVIPLock[account] = vipLockOfAddress;\r\n        emit VIPTokenUnlocked(account, vipLockOfAddress.lockedToken);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Get current balance for vip lock token action of `account`\r\n     */\r\n    function getAvailableBalance(address account)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/token/IBEP20.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the BEP20 standard. Does not include\r\n * the optional functions; to access them see {BEP20Detailed}.\r\n */\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/util/Pausable.sol\r\n\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool private paused = false;\r\n\r\n\r\n  /**\r\n  * @dev modifier to allow actions only when the contract IS paused\r\n  */\r\n  modifier whenNotPaused() {\r\n    require (!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev modifier to allow actions only when the contract IS NOT paused\r\n  */\r\n  modifier whenPaused {\r\n    require (paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @dev called by the owner to pause, triggers stopped state\r\n  */\r\n  function pause() onlyOwner external whenNotPaused returns (bool) {\r\n    paused = true;\r\n    emit Pause();\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev called by the owner to unpause, returns to normal state\r\n  */\r\n  function unpause() onlyOwner external whenPaused returns (bool) {\r\n    paused = false;\r\n    emit Unpause();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/util/SafeMath.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/token/BEP20.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract BEP20 is Context, IBEP20, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev See {IBEP20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IBEP20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IBEP20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public override virtual whenNotPaused returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IBEP20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IBEP20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) external whenNotPaused override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IBEP20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {BEP20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public whenNotPaused override virtual returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IBEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) external whenNotPaused returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IBEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external whenNotPaused returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\"));\r\n    }\r\n}\r\n\r\n// File: contracts/token/SavingToken.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\nabstract contract SavingToken is Ownable {\r\n    struct SavingItem {\r\n        uint256 savingAmount;\r\n        uint8 periodPlan;\r\n        uint256 createdTime;\r\n        uint256 expectedReleaseTime;\r\n        uint256 resavingTime;\r\n        uint256 savingRate;\r\n        bool autoResaving;\r\n        address savingOwner;\r\n    }\r\n\r\n    struct SavingInterestRate {\r\n        uint256 rate;\r\n        bool existed;\r\n    }\r\n    mapping(address => mapping(uint256 => SavingItem)) mappingSavingIDToDetail;\r\n    mapping(address => uint256) mappingAdressToSavingTotal;\r\n    mapping(uint8 => SavingInterestRate) mappingPeriodPlanToRate;\r\n    bool _savingPaused;\r\n    address private _savingOperator;\r\n\r\n    event SavingEarlyClosed(\r\n        address account,\r\n        uint256 savingID,\r\n        uint256 closeTime,\r\n        uint256 expectedReleaseTime\r\n    );\r\n\r\n    event SavingOperatorTransferred(\r\n        address indexed previousOperator,\r\n        address indexed newOperator\r\n    );\r\n\r\n    event AutoResavingConfigured(\r\n        address indexed account,\r\n        uint256 indexed savingID,\r\n        bool indexed autoResaving\r\n    );\r\n\r\n    event SavingRatesOverrided(uint8[] _periods, uint256[] _rates);\r\n\r\n    event SavingCreated(address account, uint256 savingID);\r\n    event SavingPaymentProcessed(uint256[] savingIDs, uint256 totalInterests);\r\n    event SavingFeaturePaused(uint256 pausedTime);\r\n    event SavingFeatureUnPaused(uint256 unpausedTime);\r\n\r\n    modifier onlySavingOperator() {\r\n        require(_savingOperator == _msgSender());\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!_savingPaused);\r\n        _;\r\n    }\r\n\r\n    /** @dev Transfer saving operator address to new one `account` by owner of token\r\n     */\r\n    function transferSavingOperator(address account)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(account != address(0));\r\n        emit SavingOperatorTransferred(_savingOperator, account);\r\n        _savingOperator = account;\r\n        return true;\r\n    }\r\n\r\n    /** @dev Get saving info of `account` and `savingID`\r\n     */\r\n    function savingInfo(address account, uint256 savingID)\r\n        public\r\n        view\r\n        returns (SavingItem memory)\r\n    {\r\n        return mappingSavingIDToDetail[account][savingID];\r\n    }\r\n\r\n    /** @dev Set paused mode for saving feature by `savingPaused`\r\n     */\r\n    function savingFeaturePausedMode(bool savingPaused) public onlyOwner {\r\n        _savingPaused = savingPaused;\r\n        if (_savingPaused) {\r\n            emit SavingFeaturePaused(block.timestamp);\r\n            return;\r\n        }\r\n        emit SavingFeatureUnPaused(block.timestamp);\r\n    }\r\n\r\n    /** @dev Override rates with `_periodPlans` mapping to `_rates`\r\n     */\r\n    function overrideRates(\r\n        uint8[] calldata _periodPlans,\r\n        uint256[] calldata _rates\r\n    ) external onlyOwner {\r\n        require(_periodPlans.length == _rates.length);\r\n        for (uint8 i = 0; i < _periodPlans.length; i++) {\r\n            mappingPeriodPlanToRate[_periodPlans[i]] = SavingInterestRate(\r\n                _rates[i],\r\n                true\r\n            );\r\n        }\r\n        emit SavingRatesOverrided(_periodPlans, _rates);\r\n    }\r\n\r\n    function getSavingRate(uint8 periodPlan) public view returns (uint256) {\r\n        return mappingPeriodPlanToRate[periodPlan].rate;\r\n    }\r\n\r\n    /** @dev Current total saving token of `account`\r\n     */\r\n    function currentSavingTokenOf(address account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return mappingAdressToSavingTotal[account];\r\n    }\r\n\r\n    /** @dev Balance token of `account`\r\n     */\r\n    function getAvailableBalance(address account)\r\n        public\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /** @dev Create saving  with `amount`, `_periodPlan`, `_autoResaving`, `_expectedReleaseTime`\r\n     * and `savingID` by account\r\n     */\r\n    function createSaving(\r\n        uint256 _amount,\r\n        uint8 _periodPlan,\r\n        bool _autoResaving,\r\n        uint256 savingID\r\n    ) public notPaused {\r\n        address account = _msgSender();\r\n        require(_amount != 0);\r\n        require(getAvailableBalance(account) >= _amount, \"Insufficient amount\");\r\n        require(mappingPeriodPlanToRate[_periodPlan].existed, \"Not existed period\");\r\n        require(mappingSavingIDToDetail[account][savingID].savingAmount == 0, \"Existed SavingID\");\r\n        mappingSavingIDToDetail[account][savingID] = SavingItem(\r\n            _amount,\r\n            _periodPlan,\r\n            block.timestamp,\r\n            block.timestamp +  (_periodPlan * 1 days),\r\n            0,\r\n            mappingPeriodPlanToRate[_periodPlan].rate,\r\n            _autoResaving,\r\n            account\r\n        );\r\n        mappingAdressToSavingTotal[account] =\r\n            mappingAdressToSavingTotal[account] +\r\n            _amount;\r\n        emit SavingCreated(account, savingID);\r\n    }\r\n\r\n    /** @dev Early close saving by `savingID` from account\r\n     */\r\n    function earlyCloseSaving(uint256 savingID) public notPaused {\r\n        address account = _msgSender();\r\n        require(mappingSavingIDToDetail[account][savingID].savingAmount != 0);\r\n        require(\r\n            mappingSavingIDToDetail[account][savingID].expectedReleaseTime >\r\n                block.timestamp\r\n        );\r\n        mappingAdressToSavingTotal[account] =\r\n            mappingAdressToSavingTotal[account] -\r\n            mappingSavingIDToDetail[account][savingID].savingAmount;\r\n        uint256 expectedReleaseTime =  mappingSavingIDToDetail[account][savingID].expectedReleaseTime;\r\n        delete mappingSavingIDToDetail[account][savingID];\r\n        emit SavingEarlyClosed(account, savingID, block.timestamp,expectedReleaseTime);\r\n    }\r\n\r\n    function configureAutoResaving(uint256 savingID, bool autoResaving)\r\n        public\r\n        returns (bool)\r\n    {\r\n        address account = _msgSender();\r\n        require(mappingSavingIDToDetail[account][savingID].savingAmount != 0 , \"Not Existed SavingID\");\r\n        mappingSavingIDToDetail[account][savingID].autoResaving = autoResaving;\r\n        emit AutoResavingConfigured(account, savingID, autoResaving);\r\n        return true;\r\n    }\r\n\r\n    /** @dev Transfer interest and reautosaving for `savingIDs` and `accounts`\r\n     * with `interests`\r\n     */\r\n    function processSaving(\r\n        uint256[] calldata savingIDs,\r\n        address[] calldata accounts\r\n    ) external onlySavingOperator {\r\n        require(savingIDs.length == accounts.length);\r\n        uint256 totalInterests = 0;\r\n        for (uint8 i = 0; i < savingIDs.length; i++) {\r\n            address account = accounts[i];\r\n            SavingItem memory savingItem = mappingSavingIDToDetail[account][\r\n                savingIDs[i]\r\n            ];\r\n            if (savingItem.autoResaving) {\r\n                savingItem.resavingTime = block.timestamp;\r\n                savingItem.expectedReleaseTime =\r\n                    block.timestamp + \r\n                    (savingItem.periodPlan *\r\n                    1 days);\r\n                savingItem.savingRate = mappingPeriodPlanToRate[\r\n                    savingItem.periodPlan\r\n                ].rate;\r\n                mappingSavingIDToDetail[account][savingIDs[i]] = savingItem;\r\n            }\r\n            if (!savingItem.autoResaving) {\r\n                mappingAdressToSavingTotal[account] =\r\n                    mappingAdressToSavingTotal[account] -\r\n                    savingItem.savingAmount;\r\n                delete mappingSavingIDToDetail[account][savingIDs[i]];\r\n            }\r\n            uint256 interest = calculateSavingInterest(\r\n                savingItem.savingAmount,\r\n                savingItem.periodPlan,\r\n                savingItem.savingRate\r\n            );\r\n            bool done = BEP20(address(this)).transfer(accounts[i], interest);\r\n            require(done, \"Failed tranfer\");\r\n            totalInterests += interest;\r\n        }\r\n        emit SavingPaymentProcessed(savingIDs, totalInterests);\r\n    }\r\n\r\n    function getTokenDecimal() internal view virtual returns (uint8);\r\n\r\n    function calculateSavingInterest(\r\n        uint256 savingAmount,\r\n        uint8 savingPeriodPlan,\r\n        uint256 savingRate\r\n    ) public view returns (uint256) {\r\n        return\r\n            (savingAmount * savingPeriodPlan * savingRate) /\r\n            (10**uint256(getTokenDecimal()));\r\n    }\r\n}\r\n\r\n// File: contracts/token/BEP20Detailed.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Optional functions from the BEP20 standard.\r\n */\r\nabstract contract BEP20Detailed is IBEP20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n     * these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor (string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals) {\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = tokenDecimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IBEP20-balanceOf} and {IBEP20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n// File: contracts/token/TimeLockedToken.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n\r\nabstract contract TimeLockedToken is BEP20Detailed, BEP20 {\r\n\r\n    struct ScheduleLock {\r\n        uint256 unlockTime;\r\n        uint256 amount;\r\n    }\r\n    struct TimeLockByAddress {\r\n        uint256 nextIndexTimeLock;\r\n        uint256 totalLock;\r\n        ScheduleLock[] arrTimeLock;\r\n    }\r\n\r\n    address public _manager;\r\n    mapping(address => TimeLockByAddress) mappingAddressToLock;\r\n    event TokenUnlocked(address indexed addressLock, uint256 amount);\r\n    event AddressLockItemAdded(address indexed addressLock, uint256 amount);\r\n\r\n    event ManagerTransferred(\r\n        address indexed previousManager,\r\n        address indexed newManager\r\n    );\r\n\r\n    modifier onlyManager() {\r\n        require(_manager == _msgSender(), \"Caller is not the Manager\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        uint256 _totalSupply\r\n    ) BEP20Detailed(_tokenName, _tokenSymbol, 18) Ownable() {\r\n        _mint(_msgSender(), _totalSupply * 10**uint256(18));\r\n    }\r\n\r\n    /**\r\n     * @dev add lock amount and unlock time of address. Append at the end of array\r\n     */\r\n    function _addScheduleLockByAddress(\r\n        address _addressLock,\r\n        uint256 _unlockTime,\r\n        uint256 _amount\r\n    ) internal {\r\n        mappingAddressToLock[_addressLock].arrTimeLock.push(\r\n            ScheduleLock(_unlockTime, _amount)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Update the next index for unlock item, total lock of address\r\n     */\r\n    function _updateTotalLockByAddress(\r\n        address _addressLock,\r\n        uint256 _totalLock,\r\n        uint256 _nextIndexLock\r\n    ) internal {\r\n        mappingAddressToLock[_addressLock].nextIndexTimeLock = _nextIndexLock;\r\n        mappingAddressToLock[_addressLock].totalLock = _totalLock;\r\n        emit AddressLockItemAdded(_addressLock, _totalLock);\r\n    }\r\n\r\n    /**\r\n     * @dev Unlock token of \"_addressLock\" with timeline lock\r\n     */\r\n    function _unLockTimeLockedToken(address _addressLock) internal {\r\n        if (mappingAddressToLock[_addressLock].totalLock == 0) {\r\n            return;\r\n        }\r\n        TimeLockByAddress memory timeLockByAddress = mappingAddressToLock[\r\n            _addressLock\r\n        ];\r\n        uint256 totalUnlock = 0;\r\n        while (\r\n            timeLockByAddress.nextIndexTimeLock <\r\n            timeLockByAddress.arrTimeLock.length &&\r\n            block.timestamp >=\r\n            timeLockByAddress\r\n                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]\r\n                .unlockTime\r\n        ) {\r\n            emit TokenUnlocked(\r\n                _addressLock,\r\n                timeLockByAddress\r\n                    .arrTimeLock[timeLockByAddress.nextIndexTimeLock]\r\n                    .amount\r\n            );\r\n            totalUnlock += timeLockByAddress\r\n                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]\r\n                .amount;\r\n            timeLockByAddress.nextIndexTimeLock += 1;\r\n        }\r\n        if (totalUnlock > 0) {\r\n            _updateTotalLockByAddress(\r\n                _addressLock,\r\n                timeLockByAddress.totalLock - totalUnlock,\r\n                timeLockByAddress.nextIndexTimeLock\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev get total amount lock of address\r\n     */\r\n    function getLockedAmount(address _addressLock)\r\n        public\r\n        view\r\n        returns (uint256 amount)\r\n    {\r\n        return mappingAddressToLock[_addressLock].totalLock;\r\n    }\r\n\r\n    /**\r\n     * @dev get next shedule unlock time of address lock\r\n     */\r\n    function getNextScheduleUnlock(address _addressLock)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 index,\r\n            uint256 unlockTime,\r\n            uint256 amount\r\n        )\r\n    {\r\n        TimeLockByAddress memory timeLockByAddress = mappingAddressToLock[\r\n            _addressLock\r\n        ];\r\n        return (\r\n            timeLockByAddress.nextIndexTimeLock,\r\n            timeLockByAddress\r\n                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]\r\n                .unlockTime,\r\n            timeLockByAddress\r\n                .arrTimeLock[timeLockByAddress.nextIndexTimeLock]\r\n                .amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev update array schedule lock token of address\r\n     */\r\n    function overwriteScheduleLock(\r\n        address _addressLock,\r\n        uint256[] calldata _arrAmount,\r\n        uint256[] calldata _arrUnlockTime\r\n    ) external onlyManager {\r\n        require(\r\n            _arrAmount.length > 0 && _arrAmount.length == _arrUnlockTime.length,\r\n            \"The parameter passed was wrong\"\r\n        );\r\n        require(\r\n            mappingAddressToLock[_addressLock].totalLock > 0,\r\n            \"Address must in list lock\"\r\n        );\r\n        _overwriteTimeLockByAddress(_addressLock, _arrAmount, _arrUnlockTime);\r\n    }\r\n\r\n    /**\r\n     * @dev get lock time and amount lock by address at a time\r\n     */\r\n    function getScheduleLock(address _addressLock, uint256 _index)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (\r\n            mappingAddressToLock[_addressLock].arrTimeLock[_index].amount,\r\n            mappingAddressToLock[_addressLock].arrTimeLock[_index].unlockTime\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev add list timeline lock and total amount lock by address\r\n     */\r\n    function addScheduleLockByAddress(\r\n        address _addressLock,\r\n        uint256[] calldata _arrAmount,\r\n        uint256[] calldata _arrUnlockTime\r\n    ) external onlyManager {\r\n        require(\r\n            _arrAmount.length > 0 && _arrAmount.length == _arrUnlockTime.length,\r\n            \"The parameter passed was wrong\"\r\n        );\r\n        require(\r\n            mappingAddressToLock[_addressLock].totalLock == 0,\r\n            \"Address must not in list lock\"\r\n        );\r\n        _overwriteTimeLockByAddress(_addressLock, _arrAmount, _arrUnlockTime);\r\n    }\r\n\r\n    /**\r\n     * @dev function overwrite schedule time lock and total by address lock\r\n     */\r\n    function _overwriteTimeLockByAddress(\r\n        address _addressLock,\r\n        uint256[] memory _arrAmount,\r\n        uint256[] memory _arrUnlockTime\r\n    ) internal returns (uint256) {\r\n        uint256 totalLock = 0;\r\n        delete mappingAddressToLock[_addressLock].arrTimeLock;\r\n        _updateTotalLockByAddress(_addressLock, 0, 0);\r\n        for (uint256 i = 0; i < _arrAmount.length; i++) {\r\n            require(\r\n                _arrUnlockTime[i] > 0,\r\n                \"The timeline must be greater than 0\"\r\n            );\r\n            if (i != _arrAmount.length - 1) {\r\n                require(\r\n                    _arrUnlockTime[i + 1] > _arrUnlockTime[i],\r\n                    \"The next timeline must be greater than the previous\"\r\n                );\r\n            }\r\n            totalLock += _arrAmount[i];\r\n            require(getAvailableBalance(_addressLock) >=  totalLock, \"Insufficient amount to lock\");\r\n            _addScheduleLockByAddress(\r\n                _addressLock,\r\n                _arrUnlockTime[i],\r\n                _arrAmount[i]\r\n            );\r\n        }\r\n        _updateTotalLockByAddress(_addressLock, totalLock, 0);\r\n        return totalLock;\r\n    }\r\n\r\n    /**\r\n     * @dev unlock time locked token for address for manager\r\n     */\r\n    function _unLockTimeLockedTokenForAddress(address _address)\r\n        external\r\n        onlyManager\r\n    {\r\n        _unLockTimeLockedToken(_address);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer current manager to new manager\r\n     */\r\n    function transferManager(address newManager) public onlyOwner {\r\n        _transferManager(newManager);\r\n    }\r\n\r\n    function _transferManager(address newManager) internal {\r\n        require(newManager != address(0), \"New Manager is the zero address\");\r\n        emit ManagerTransferred(_manager, newManager);\r\n        _manager = newManager;\r\n    }\r\n\r\n\r\n    /** @dev Get current balance for locked token action of `account`\r\n     */\r\n    function getAvailableBalance(address account)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/token/ShopNextToken.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n\r\ncontract ShopNextToken is TimeLockedToken, VIPLockToken, SavingToken {\r\n    bool transfersEnabled;\r\n    event TransfersEnabled(bool newStatus);\r\n\r\n    modifier transfersAllowed() {\r\n        require(transfersEnabled, \"Transfers not available\");\r\n        _;\r\n    }\r\n\r\n    constructor() TimeLockedToken(\"ShopNext Token\", \"NEXT\", 1000000000) {}\r\n\r\n    function transfer(address _receiver, uint256 _amount)\r\n        public\r\n        override\r\n        returns (bool success)\r\n    {\r\n        _unLockTimeLockedToken(_msgSender());\r\n        _vipUnlock(_msgSender());\r\n        require(\r\n            getAvailableBalance(_msgSender()) >= _amount,\r\n            \"Not enough unlocked token balance\"\r\n        );\r\n        bool done = BEP20.transfer(_receiver, _amount);\r\n        require(done, \"Failed transfer\");\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _receiver,\r\n        uint256 _amount\r\n    ) public override returns (bool) {\r\n        require(_amount <= allowance(_from, msg.sender), \"Invalid allowance amount\");\r\n        _unLockTimeLockedToken(_from);\r\n        _vipUnlock(_from);\r\n        require(\r\n            getAvailableBalance(_from) >= _amount,\r\n            \"Not enough unlocked token balance of sender\"\r\n        );\r\n        bool done = BEP20.transferFrom(_from, _receiver, _amount);\r\n        require(done, \"Failed transfer\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get current balance for all businesses of `account`\r\n     */\r\n    function getAvailableBalance(address _address)\r\n        public\r\n        view\r\n        override(SavingToken, TimeLockedToken, VIPLockToken)\r\n        returns (uint256 amount)\r\n    {\r\n        uint256 balance = balanceOf(_address);\r\n        uint256 lockedAmount = getLockedAmount(_address);\r\n        uint256 vipLockedAmount = currentVIPLockTokenOf(_address);\r\n        uint256 savingLockedAmount = currentSavingTokenOf(_address);\r\n        if (balance <= (lockedAmount + vipLockedAmount + savingLockedAmount))\r\n            return 0;\r\n        return balance - (lockedAmount + vipLockedAmount + savingLockedAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens in batch\r\n     * @param recipients an array of recipient addresses\r\n     * @param values an array of specified amount of tokens to be transferred\r\n     * @return success status of the batch transferring\r\n     */\r\n    function transfers(address[] calldata recipients, uint256[] calldata values)\r\n        external\r\n        transfersAllowed\r\n        returns (bool)\r\n    {\r\n        require(\r\n            recipients.length == values.length,\r\n            \"Input lengths do not match\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < recipients.length; i++) {\r\n            bool done = transfer(recipients[i], values[i]);\r\n            require (done, \"Failed tranfer\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Enables the method ``transfers()`` if ``enable=true``,\r\n     * and disables ``transfers()`` otherwise\r\n     * @param enable the expected new availability of the method ``transfers()``\r\n     */\r\n    function enableTransfers(bool enable) public onlyOwner returns (bool) {\r\n        transfersEnabled = enable;\r\n        emit TransfersEnabled(enable);\r\n        return true;\r\n    }\r\n\r\n    function getTokenDecimal() internal view override returns (uint8) {\r\n        return decimals();\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addressLock\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddressLockItemAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"autoResaving\",\"type\":\"bool\"}],\"name\":\"AutoResavingConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"}],\"name\":\"SavingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expectedReleaseTime\",\"type\":\"uint256\"}],\"name\":\"SavingEarlyClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pausedTime\",\"type\":\"uint256\"}],\"name\":\"SavingFeaturePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unpausedTime\",\"type\":\"uint256\"}],\"name\":\"SavingFeatureUnPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SavingOperatorTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"savingIDs\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInterests\",\"type\":\"uint256\"}],\"name\":\"SavingPaymentProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"_periods\",\"type\":\"uint8[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_rates\",\"type\":\"uint256[]\"}],\"name\":\"SavingRatesOverrided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addressLock\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"TransfersEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousLocker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLocker\",\"type\":\"address\"}],\"name\":\"VIPLockerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousAddedTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAddedTime\",\"type\":\"uint256\"}],\"name\":\"VIPRelockAddedTimeModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VIPTokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"VIPTokenUnlockRegisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VIPTokenUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousAddedTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAddedTime\",\"type\":\"uint256\"}],\"name\":\"VIPUnlockAddedTimeModified\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_unLockTimeLockedTokenForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressLock\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_arrAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_arrUnlockTime\",\"type\":\"uint256[]\"}],\"name\":\"addScheduleLockByAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"savingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"savingPeriodPlan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"savingRate\",\"type\":\"uint256\"}],\"name\":\"calculateSavingInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"autoResaving\",\"type\":\"bool\"}],\"name\":\"configureAutoResaving\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_periodPlan\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_autoResaving\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"}],\"name\":\"createSaving\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"currentSavingTokenOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"currentVIPLockTokenOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"}],\"name\":\"earlyCloseSaving\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAvailableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressLock\",\"type\":\"address\"}],\"name\":\"getLockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressLock\",\"type\":\"address\"}],\"name\":\"getNextScheduleUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRelockVIPAddedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"periodPlan\",\"type\":\"uint8\"}],\"name\":\"getSavingRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressLock\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getScheduleLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockAddedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRelockVIPAddedTime\",\"type\":\"uint256\"}],\"name\":\"modifyRelockVIPAddedTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUnlockAddedTime\",\"type\":\"uint256\"}],\"name\":\"modifyUnlockAddedTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"_periodPlans\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rates\",\"type\":\"uint256[]\"}],\"name\":\"overrideRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressLock\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_arrAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_arrUnlockTime\",\"type\":\"uint256[]\"}],\"name\":\"overwriteScheduleLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"savingIDs\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"processSaving\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"savingPaused\",\"type\":\"bool\"}],\"name\":\"savingFeaturePausedMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"savingID\",\"type\":\"uint256\"}],\"name\":\"savingInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"savingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"periodPlan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"createdTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedReleaseTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resavingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"savingRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"autoResaving\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"savingOwner\",\"type\":\"address\"}],\"internalType\":\"struct SavingToken.SavingItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLockerAddress\",\"type\":\"address\"}],\"name\":\"transferLocker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferSavingOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"transfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"vipLockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vipLockToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vipUnlockRequest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ShopNextToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d24f51149090ececb233acd0ba91e02d9432c52141cdb50278cf9b5ecadc27b6"}