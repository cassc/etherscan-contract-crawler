{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Other/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Staking/StakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../Other/interfaces/IERC20.sol\\\";\\n\\n// - Rewards user for staking their tokens\\n// - User can withdraw and deposit\\n// - Earns token while withdrawing\\n\\n/// rewards are calculated with reward rate and time period staked for\\n\\ncontract StakingPool {\\n    // tokens intialized\\n    IERC20 public rewardsToken;\\n    IERC20 public stakingToken;\\n\\n    // 100 wei per second , calculated for per anum\\n    uint256 public rewardRate = 100;\\n\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n\\n    // mapping for the rewards for an address\\n    mapping(address => uint256) public rewards;\\n\\n    // mapping for the rewards per token paid\\n    mapping(address => uint256) public rewardsPerTokenPaid;\\n\\n    // mapping for staked amount by an address\\n    mapping(address => uint256) public staked;\\n\\n    // total supply for the staked token in the contract\\n    uint256 public _totalSupply;\\n\\n    constructor(address _stakingToken, address _rewardsToken) {\\n        stakingToken = IERC20(_stakingToken);\\n        rewardsToken = IERC20(_rewardsToken);\\n    }\\n\\n    /// @dev - to calculate the amount of rewards per token staked at current instance\\n    /// @return uint - the amount of rewardspertoken\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored +\\n            (((block.timestamp - lastUpdateTime) * rewardRate * 1e18) /\\n                _totalSupply);\\n    }\\n\\n    /// @dev - to calculate the earned rewards for the token staked\\n    /// @param account - for which it is to be calculated\\n    /// @return uint -  amount of earned rewards\\n    function earned(address account) public view returns (uint256) {\\n        /// amount will be the earned amount according to the staked + the rewards the user earned earlier\\n        return\\n            ((staked[account] *\\n                (rewardPerToken() - rewardsPerTokenPaid[account])) / 1e18) +\\n            rewards[account];\\n    }\\n\\n    /// modifier that will calculate the amount every time the user calls , and update them in the rewards array\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = block.timestamp;\\n\\n        /// updating the total rewards owned by the user\\n        rewards[account] = earned(account);\\n        /// updatig per token reward amount in the mapping\\n        rewardsPerTokenPaid[account] = rewardPerTokenStored;\\n        _;\\n    }\\n\\n    /// @dev to stake some amount of token\\n    /// @param _amount -  amount to be staked\\n    function stake(uint256 _amount, address user) external updateReward(user) {\\n        _totalSupply += _amount;\\n        staked[user] += _amount;\\n\\n        ///  need approval\\n        stakingToken.transferFrom(user, address(this), _amount);\\n    }\\n\\n    /// @dev to withdraw the staked amount\\n    /// @param _amount - amount to be withdrawn\\n    function withdraw(uint256 _amount, address user)\\n        external\\n        updateReward(user)\\n    {\\n        _totalSupply -= _amount;\\n        staked[user] -= _amount;\\n        stakingToken.transfer(user, _amount);\\n    }\\n\\n    /// @dev to withdraw the reward token\\n    function reedemReward(address user) external updateReward(msg.sender) {\\n        uint256 reward = rewards[user];\\n        rewards[user] = 0;\\n        rewardsToken.transfer(user, reward);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Staking/StakingPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./StakingPool.sol\\\";\\n\\ncontract StakingPoolFactory {\\n    /// The address supposed to get the protocol fee\\n    address public feeTo;\\n\\n    /// address that can set the address\\n    address public feeToSetter;\\n\\n    ///  mapping from Token => Pool address\\n    mapping(address => address) public getPool;\\n    address[] public allPools;\\n\\n    event PoolCreated(address indexed token, address pool, uint256 timeStamp);\\n\\n    constructor(address _feeToSetter) {\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    function allPoolsLength() external view returns (uint256) {\\n        return allPools.length;\\n    }\\n\\n    function createPool(address stoken, address rtoken)\\n        external\\n        returns (address)\\n    {\\n        require(stoken != address(0), \\\"ZERO_ADDRESS\\\");\\n        require(getPool[stoken] == address(0), \\\"PAIR_EXISTS\\\");\\n\\n        StakingPool _pool = new StakingPool(stoken, rtoken);\\n\\n        getPool[stoken] = address(_pool);\\n        allPools.push(address(_pool));\\n        emit PoolCreated(stoken, address(_pool), block.timestamp);\\n        return address(_pool);\\n    }\\n\\n    function setFeeTo(address _feeTo) external {\\n        require(msg.sender == feeToSetter, \\\"FORBIDDEN\\\");\\n        feeTo = _feeTo;\\n    }\\n\\n    function setFeeToSetter(address _feeToSetter) external {\\n        require(msg.sender == feeToSetter, \\\"FORBIDDEN\\\");\\n        feeToSetter = _feeToSetter;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"PoolCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPoolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rtoken\",\"type\":\"address\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingPoolFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "000000000000000000000000c53a48789b0f77856037c235b91b515b40f4ee7e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}