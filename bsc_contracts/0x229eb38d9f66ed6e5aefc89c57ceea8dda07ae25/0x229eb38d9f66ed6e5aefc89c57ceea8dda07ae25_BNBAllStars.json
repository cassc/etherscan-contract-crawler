{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BNBAllStars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract BNBAllStars {\\n    using SafeMath for uint256;\\n    using SafeMath for uint8;\\n\\n    bool internal locked;\\n    modifier notReentrant() {\\n        require(!locked, \\\"No re-entrancy\\\");\\n        locked = true;\\n        _;\\n        locked = false;\\n    }\\n\\n    struct User {\\n        address upline;\\n        uint256 referrals;\\n        uint256 payouts;\\n        uint256 direct_bonus;\\n        uint256 match_bonus;\\n        uint256 deposit_amount;\\n        uint256 deposit_payouts;\\n        uint256 total_direct_deposits;\\n        uint256 total_payouts;\\n        uint256 total_structure;\\n        uint256 total_downline_deposit;\\n        uint256 checkpoint;\\n    }\\n\\n    struct Airdrop {\\n        uint256 airdrops;\\n        uint256 airdrops_sent;\\n        uint256 airdrops_sent_count;\\n        uint256 airdrops_received;\\n        uint256 airdrops_received_count;\\n        uint256 last_airdrop;\\n        uint256 last_airdrop_received;\\n        uint256 airdrop_bonus;\\n    }\\n\\n    struct Team {\\n        address[] members; // owner is also in member-array!\\n        address owner; // owner is able to add users\\n        uint256 id;\\n        uint256 created_at;\\n        string name;\\n        bool is_referral_team; // first team of upline-user is the referral team. all ref users are added automatically\\n    }\\n\\n    struct TeamInfo {\\n        uint256 id;\\n        bool exists;\\n    }\\n\\n    struct UserBonusStats {\\n        uint256 direct_bonus_withdrawn;\\n        uint256 match_bonus_withdrawn;\\n        uint256 airdrops_withdrawn;\\n        uint256 income_reinvested;\\n        uint256 bonus_reinvested;\\n        uint256 airdrops_reinvested;\\n        uint256 reinvested_gross;\\n    }\\n\\t\\n    mapping(address => address) public uplinesOld;\\n    mapping(address => UserBonusStats) public userBonusStats;\\n    mapping(address => string) nicknames;\\n    mapping(address => User) public users;\\n    mapping(uint256 => address) public id2Address;\\n    mapping(address => Airdrop) public airdrops;\\n    mapping(uint256 => Team) public teams;\\n    mapping(address => uint8) public user_teams_counter; // holds the number of teams of a user\\n    mapping(address => TeamInfo[]) public user_teams;\\n    mapping(address => TeamInfo) public user_referral_team;\\n\\n    address payable public projectManager;\\n    \\n    address[14] public marketingWallets;\\n    uint256[14] public marketingBasis;\\n    \\n    uint256 constant public REFERRAL = 50;\\n    uint256 constant public PROJECT = 10;\\n    uint256 constant public MARKETING = 90;\\n    uint256 constant public AIRDROP = 0;\\n    uint256 constant public REINVEST_BONUS = 10;\\n    uint256 constant public MAX_PAYOUT = 3650;\\n    uint256 constant public BASE_PERCENT = 15;\\n    uint256 constant public TIME_STEP = 1 days;\\n    uint8 constant public MAX_TEAMS_PER_ADDRESS = 6;\\n    uint8 constant public MAX_LENGTH_NICKNAME = 10;\\n    \\n    uint256 constant public PERCENTS_DIVIDER = 1000;\\n    uint256 constant public FEE_DIVIDER = 10000;\\n\\n    uint8[3] public ref_bonuses;\\n    uint256 constant public ref_depth = 3;\\n    \\n    uint256 public total_users;\\n    uint256 public total_deposited;\\n    uint256 public total_withdraw;\\n    uint256 public total_reinvested;\\n    uint256 public total_airdrops;\\n    uint256 public total_teams_created;\\n    uint256 public timestamp_cutoff_release;\\n\\n    bool public started;\\n    bool public airdrop_enabled;\\n    uint256 public MIN_DEPOSIT = 1 * 1e17; //0.1 BNB\\n    uint256 public AIRDROP_MIN = 1 * 1e17; //0.1 BNB\\n    uint256 public MAX_WALLET_DEPOSIT = 25 ether; //25 BNB\\n\\n    uint256 public MAX_REINVEST_MULTIPLIER = 500;\\n    uint256 public MAX_REINVEST_AMOUNT = 5;\\n    uint256 public MAX_PAYOUT_CAP = 200 ether; // no wallet can withdraw more than this\\n\\t\\n\\tmapping(address => uint8) public user_reinvest_count; // holds the user's reinvest count.\\n\\tuint256 constant public ACTION_COOLDOWN = 1 days; // 24 hour WITHDRAW_COOLDOWN \\n    uint8 constant public MANDATORY_REINVEST_COUNT = 3; // 3x MANDATORY REINVEST\\n\\tbool public MANDATORY_REINVEST_ENABLED = true; // enable/disable the new feature global\\n\\n    event Upline(address indexed addr, address indexed upline);\\n    event NewDeposit(address indexed addr, uint256 amount);\\n    event DirectPayout(address indexed addr, address indexed from, uint256 amount);\\n    event MatchPayout(address indexed addr, address indexed from, uint256 amount);\\n    event Withdraw(address indexed addr, uint256 amount);\\n    event LimitReached(address indexed addr, uint256 amount);\\n\\tevent ReinvestedDeposit(address indexed user, uint256 amount);\\n    event NewAirdrop(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\\n\\n    constructor (address payable projectManagerAddress) {\\n        require(!isContract(projectManagerAddress));\\n\\n\\t\\tprojectManager = projectManagerAddress;\\n\\t\\t\\n        total_users = 1;\\n\\n        ref_bonuses[0] = 5;\\n        ref_bonuses[1] = 5;\\n        ref_bonuses[2] = 5;\\n\\n        marketingWallets[0] = 0x19Bd4C1Cb88f3ad65B6B30F578cdA0F31c0dE2d2;\\n        marketingBasis[0] = 25;\\n        marketingWallets[1] = 0x02D17fDFdA84eaD75DCF8c9a9a98D8F0F911D155;\\n        marketingBasis[1] = 25;\\n        marketingWallets[2] = 0x6460d7D0B666FCE0c31ae78f0dd4aC077e09095A;\\n        marketingBasis[2] = 100;\\n        marketingWallets[3] = 0x52a7dA086FA3ef404Af4aE7231a3D64B6A173cac;\\n        marketingBasis[3] = 25;\\n        marketingWallets[4] = 0x3A723811eC967615F0cD054088b0CBf05C1C6c1f;\\n        marketingBasis[4] = 25;\\n        marketingWallets[5] = 0xA5ed96593E54B45283ccfFbACeD0b15425b7cfff;\\n        marketingBasis[5] = 25;\\n        marketingWallets[6] = 0x5aA424FBFb4801D60fbe2919C7D3F0E2776E67db;\\n        marketingBasis[6] = 50;\\n        marketingWallets[7] = 0x32666288Df2180e5F0c5534025e506909a7a5Ea7;\\n        marketingBasis[7] = 25;\\n        marketingWallets[8] = 0x57a34Af3e29AA3339977B522414Ec473397C2B8a;\\n        marketingBasis[8] = 25;\\n        marketingWallets[9] = 0x9FE93Ce9C1721BEC752276f7c63F6CAC9ba9ce0C;\\n        marketingBasis[9] = 100;\\n        marketingWallets[10] = 0xA4D959346fa29d1e56F4ad5Ce2B3D3Ec8227B5C2;\\n        marketingBasis[10] = 125;\\n        marketingWallets[11] = 0xb3003286799EE733d282f6BD5b4977b418Fd5902;\\n        marketingBasis[11] = 100;\\n        marketingWallets[12] = 0xE9e15A7eEcDdF4664b282FeE7cc5C863730871e8;\\n        marketingBasis[12] = 100;\\n        marketingWallets[13] = 0x2B5AA01F1cb6529d95504deCAE993aeA0838Fed1;\\n        marketingBasis[13] = 150;\\n    }\\n\\n\\tfunction isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly { size := extcodesize(addr) }\\n        return size > 0;\\n    }\\n\\t\\n    //deposit_amount -- can only be done by the projectManager address for first deposit.\\n    function deposit() payable external {\\n        _deposit(msg.sender, msg.value);\\n    }\\n\\n    //deposit with upline\\n    function deposit(address _upline) payable external notReentrant {\\n        require(started, \\\"Contract not yet started.\\\");\\n\\t\\t\\t\\t\\n\\t\\tif (uplinesOld[msg.sender] != address(0)) {\\n            _setUpline(msg.sender, uplinesOld[msg.sender]);\\n\\t\\t} else {\\n\\t\\t\\t_setUpline(msg.sender, _upline);\\n\\t\\t}\\n        _deposit(msg.sender, msg.value);\\n    }\\n\\n    //invest\\n    function _deposit(address _addr, uint256 _amount) private {\\n        if (!started) {\\n    \\t\\tif (msg.sender == projectManager) {\\n    \\t\\t\\tstarted = true;\\n                timestamp_cutoff_release = block.timestamp;\\n    \\t\\t} else revert(\\\"Contract not yet started.\\\");\\n    \\t}\\n        \\n        require(users[_addr].upline != address(0) || _addr == projectManager, \\\"No upline\\\");\\n        require(_amount >= MIN_DEPOSIT, \\\"Mininum deposit not met.\\\");\\n        require(users[_addr].total_direct_deposits.add(_amount) <= MAX_WALLET_DEPOSIT, \\\"Max deposit limit reached.\\\");\\n\\n        if (users[_addr].deposit_amount == 0 ) { // new user\\n            id2Address[total_users] = _addr;\\n            total_users++;\\n        }\\n\\n        // reinvest before deposit because the checkpoint gets an reset here\\n        uint256 to_reinvest = payoutToReinvest(msg.sender);\\n        if (to_reinvest > 0 && users[_addr].deposit_amount.add(_amount) < maxReinvestOf(users[_addr].total_direct_deposits)) {\\n            userBonusStats[msg.sender].income_reinvested += to_reinvest;\\n            to_reinvest = to_reinvest.add(to_reinvest.mul(REINVEST_BONUS).div(PERCENTS_DIVIDER)); //add more bonus for reinvest action.\\n            users[msg.sender].deposit_amount += to_reinvest;\\t\\n            userBonusStats[msg.sender].reinvested_gross += to_reinvest;        \\n            total_reinvested += to_reinvest;\\n            emit ReinvestedDeposit(msg.sender, to_reinvest);\\n        }\\n\\n        // deposit\\n        users[_addr].deposit_amount += _amount;\\n        users[_addr].checkpoint = block.timestamp;\\n        users[_addr].total_direct_deposits += _amount;\\n\\n        total_deposited += _amount;\\n\\n        emit NewDeposit(_addr, _amount);\\n        if (users[_addr].upline != address(0)) {\\n            uint256 refBonus = _amount.mul(REFERRAL).div(PERCENTS_DIVIDER);\\n\\n\\t\\t\\tif (users[users[_addr].upline].checkpoint > 0 && users[users[_addr].upline].deposit_amount < maxReinvestOf(users[users[_addr].upline].total_direct_deposits)) {\\n                if (users[users[_addr].upline].deposit_amount.add(refBonus) > maxReinvestOf(users[users[_addr].upline].total_direct_deposits)) {\\n                    refBonus = maxReinvestOf(users[users[_addr].upline].total_direct_deposits).sub(users[users[_addr].upline].deposit_amount);\\n                }\\n                users[users[_addr].upline].direct_bonus += refBonus;\\n                emit DirectPayout(users[_addr].upline, _addr, refBonus);\\n\\t\\t\\t}\\n        }        \\n        _downLineDeposits(_addr, _amount);\\n        fees(_amount);\\n    }\\n\\n    function checkUplineValid(address _addr, address _upline) public view returns (bool isValid) {\\n        if (uplinesOld[_addr] == _upline && users[_addr].checkpoint == 0) {\\n            isValid = true;\\n        }\\t\\t\\n        if (users[_addr].upline == address(0) && _upline != _addr && _addr != projectManager && (users[_upline].checkpoint > 0 || _upline == projectManager)) {\\n            isValid = true;        \\n        }\\n    }\\n\\n    function _setUpline(address _addr, address _upline) private {\\n        if (checkUplineValid(_addr, _upline)) {\\n            users[_addr].upline = _upline;\\n            users[_upline].referrals++;\\n\\n            if (user_referral_team[_upline].exists == false) {\\n                uint256 teamId = _createTeam(_upline, true); // create first team on upline-user. this contains the direct referrals\\n                user_referral_team[_upline].id = teamId;\\n                user_referral_team[_upline].exists = true;\\n            }\\n\\n            // check if current user is in ref-team\\n            bool memberExists = false;\\n            for (uint256 i = 0; i < teams[user_referral_team[_upline].id].members.length; i++) {\\n                if (teams[user_referral_team[_upline].id].members[i] == _addr) {\\n                    memberExists = true;\\n                }\\n            }\\n            if (memberExists == false) {\\n                _addTeamMember (user_referral_team[_upline].id, _addr); // add referral user to upline users referral-team\\n            }\\n\\n            emit Upline(_addr, _upline);\\n\\n            for (uint8 i = 0; i < ref_bonuses.length; i++) {\\n                if (_upline == address(0)) break;\\n                users[_upline].total_structure++;\\n                _upline = users[_upline].upline;\\n            }\\n        }\\n    }\\n\\n    \\n    function _downLineDeposits(address _addr, uint256 _amount) private {\\n      address _upline = users[_addr].upline;\\n      for (uint8 i = 0; i < ref_bonuses.length; i++) {\\n        if (_upline == address(0)) {\\n            break;\\n        }\\n        if (users[_upline].checkpoint > 0) {\\n            users[_upline].total_downline_deposit = users[_upline].total_downline_deposit.add(_amount);\\n        }\\n        _upline = users[_upline].upline;\\n      }\\n    }\\n\\n    function _refPayout(address _addr, uint256 _amount) private {\\n        address up = users[_addr].upline;\\n        for (uint8 i = 0; i < ref_depth; i++) {\\n            if (up == address(0)) {\\n                break;\\n            }\\n            if (users[up].referrals >= i.add(1) && users[up].deposit_amount.add(_amount) < maxReinvestOf(users[up].total_direct_deposits)) {\\n                if (users[up].checkpoint > block.timestamp.sub(48 hours)) {  // 48h accumulation stop\\n                    uint256 bonus = _amount * ref_bonuses[i] / 100;\\n                    if (users[up].checkpoint!= 0) { // only pay match payout if user is present\\n                        users[up].match_bonus += bonus;\\n                        emit MatchPayout(up, _addr, bonus);   \\n                    }     \\n                }  \\n            }\\n            up = users[up].upline;\\n        }\\n    }\\n\\n    function withdraw() external notReentrant {\\n        if (!started) {\\n\\t\\t\\trevert(\\\"Contract not yet started.\\\");\\n\\t\\t}\\n\\t\\tif (MANDATORY_REINVEST_ENABLED) {\\n\\t\\t\\trequire(user_reinvest_count[msg.sender] >= MANDATORY_REINVEST_COUNT, \\\"User is required to reinvest 3 times before being allowed to withdraw.\\\" );\\n\\t\\t\\tif (users[msg.sender].checkpoint.add(ACTION_COOLDOWN) > block.timestamp) revert(\\\"Withdrawals can only be done after action cooldown.\\\");\\n\\t\\t}\\n        (uint256 to_payout, uint256 max_payout) = payoutOf(msg.sender);\\n        require(users[msg.sender].payouts < max_payout, \\\"Max payout already received.\\\");\\n        require(users[msg.sender].payouts < MAX_PAYOUT_CAP, \\\"Max payout cap 200bnb reached.\\\");\\n\\n        // Deposit payout\\n        if (to_payout > 0) {\\n            if (users[msg.sender].payouts.add(to_payout) > max_payout) {\\n                to_payout = max_payout.sub(users[msg.sender].payouts);\\n            }\\n            users[msg.sender].deposit_payouts += to_payout;\\n            users[msg.sender].payouts += to_payout;\\n            _refPayout(msg.sender, to_payout);\\n        }\\n\\n        // Direct bonnus payout\\n        if (users[msg.sender].payouts < max_payout && users[msg.sender].direct_bonus > 0) {\\n            uint256 direct_bonus = users[msg.sender].direct_bonus;\\n            if (users[msg.sender].payouts.add(direct_bonus) > max_payout) {\\n                direct_bonus = max_payout.sub(users[msg.sender].payouts);\\n            }\\n            users[msg.sender].direct_bonus -= direct_bonus;\\n            users[msg.sender].payouts += direct_bonus;\\n            userBonusStats[msg.sender].direct_bonus_withdrawn += direct_bonus;\\n            to_payout += direct_bonus;\\n        }\\n\\n        // Match payout\\n        if (users[msg.sender].payouts < max_payout && users[msg.sender].match_bonus > 0) {\\n            uint256 match_bonus = users[msg.sender].match_bonus;\\n            if (users[msg.sender].payouts.add(match_bonus) > max_payout) {\\n                match_bonus = max_payout.sub(users[msg.sender].payouts);\\n            }\\n            users[msg.sender].match_bonus -= match_bonus;\\n            users[msg.sender].payouts += match_bonus;\\n            userBonusStats[msg.sender].match_bonus_withdrawn += match_bonus;\\n            to_payout += match_bonus;  \\n        }\\n\\n        // Airdrop payout\\n        if (users[msg.sender].payouts < max_payout && airdrops[msg.sender].airdrop_bonus > 0) {\\n            uint256 airdrop_bonus = airdrops[msg.sender].airdrop_bonus;\\n            if (users[msg.sender].payouts.add(airdrop_bonus) > max_payout) {\\n                airdrop_bonus = max_payout.sub(users[msg.sender].payouts);\\n            }\\n            airdrops[msg.sender].airdrop_bonus -= airdrop_bonus;\\n            users[msg.sender].payouts += airdrop_bonus;\\n            userBonusStats[msg.sender].airdrops_withdrawn += airdrop_bonus;\\n            to_payout += airdrop_bonus;\\n        }\\n\\n        if (users[msg.sender].total_payouts.add(to_payout) > MAX_PAYOUT_CAP) {\\n            to_payout = MAX_PAYOUT_CAP.sub(users[msg.sender].payouts); // only allow the amount up to MAX_PAYOUT_CAP\\n        }\\n\\n        require(to_payout > 0, \\\"User has zero dividends payout.\\\");\\n        //check for withdrawal tax and get final payout.\\n        to_payout = withdrawalTaxPercentage(to_payout);\\n        users[msg.sender].total_payouts += to_payout;\\n        total_withdraw += to_payout;\\n        users[msg.sender].checkpoint = block.timestamp;\\n        \\n        //pay investor\\n        uint256 payout = to_payout.sub(fees(to_payout));\\n        payable(address(msg.sender)).transfer(payout);\\n\\t\\tif (MANDATORY_REINVEST_ENABLED) {\\n\\t\\t\\tuser_reinvest_count[msg.sender] = 0;\\n\\t\\t}\\n\\n        emit Withdraw(msg.sender, payout);\\n        //max payout \\n        if (users[msg.sender].payouts >= max_payout) {\\n            emit LimitReached(msg.sender, users[msg.sender].payouts);\\n        }\\n    }\\n\\n    //re-invest direct deposit payouts and direct referrals.\\n    function reinvest() external {\\n\\t\\tif (!started) {\\n\\t\\t\\trevert(\\\"Not started yet\\\");\\n\\t\\t}\\n\\n\\t\\tif (MANDATORY_REINVEST_ENABLED) {\\n\\t\\t\\tif (users[msg.sender].checkpoint.add(ACTION_COOLDOWN) > block.timestamp) revert(\\\"Reinvestment can only be done after action cooldown.\\\");\\n\\t\\t}\\n\\n        (, uint256 max_payout) = payoutOf(msg.sender);\\n        require(users[msg.sender].payouts < max_payout, \\\"Max payout already received.\\\");\\n\\n        // Deposit payout\\n        uint256 to_reinvest = payoutToReinvest(msg.sender);\\n\\n        userBonusStats[msg.sender].income_reinvested += to_reinvest;\\n\\n        // Direct payout\\n        uint256 direct_bonus = users[msg.sender].direct_bonus;\\n        users[msg.sender].direct_bonus -= direct_bonus;\\n        userBonusStats[msg.sender].bonus_reinvested += direct_bonus;\\n        to_reinvest += direct_bonus;\\n       \\n        // Match payout\\n        uint256 match_bonus = users[msg.sender].match_bonus;\\n        users[msg.sender].match_bonus -= match_bonus;\\n        userBonusStats[msg.sender].bonus_reinvested += match_bonus;\\n        to_reinvest += match_bonus;    \\n\\n        // Airdrop payout\\n        uint256 airdrop_bonus = airdrops[msg.sender].airdrop_bonus;\\n        airdrops[msg.sender].airdrop_bonus -= airdrop_bonus;\\n        userBonusStats[msg.sender].airdrops_reinvested += airdrop_bonus;\\n        to_reinvest += airdrop_bonus; \\n\\n        require(to_reinvest > 0, \\\"User has zero dividends re-invest.\\\");\\n        //add more bonus for reinvest action.\\n        to_reinvest = to_reinvest.add(to_reinvest.mul(REINVEST_BONUS).div(PERCENTS_DIVIDER));\\n\\n        //check the reinvest amount if already exceeds max re-investment\\n        uint256 finalReinvestAmount = reinvestAmountOf(msg.sender, to_reinvest);\\n\\n        users[msg.sender].deposit_amount += finalReinvestAmount;\\n        users[msg.sender].checkpoint = block.timestamp;\\n        userBonusStats[msg.sender].reinvested_gross += finalReinvestAmount;\\n        total_reinvested += finalReinvestAmount;\\n        \\n\\t\\tif (MANDATORY_REINVEST_ENABLED) {\\n\\t\\t\\t//count user reinvestments\\n\\t\\t\\tuser_reinvest_count[msg.sender]++;\\n\\t\\t}\\n\\n        emit ReinvestedDeposit(msg.sender, finalReinvestAmount);\\n\\t}\\n\\n    function reinvestAmountOf(address _addr, uint256 _toBeRolledAmount) view public returns(uint256 reinvestAmount) {\\n        \\n        //validate the total amount that can be rolled is 5x the users real deposit only.\\n        uint256 maxReinvestAmount = maxReinvestOf(users[_addr].total_direct_deposits); \\n        reinvestAmount = _toBeRolledAmount; \\n        if (users[_addr].deposit_amount >= maxReinvestAmount) { // user already got max reinvest\\n            revert(\\\"User exceeded x5 of total deposit to be rolled.\\\");\\n        }\\n        if (users[_addr].deposit_amount.add(reinvestAmount) >= maxReinvestAmount) { // user will reach max reinvest with current reinvest\\n            reinvestAmount = maxReinvestAmount.sub(users[_addr].deposit_amount); // only let him reinvest until max reinvest is reached\\n        }        \\n    }\\n\\n    //max reinvestment per user is 5x user deposit.\\n    function maxReinvestOf(uint256 _amount) view public returns(uint256) {\\n        return _amount.mul(MAX_REINVEST_AMOUNT);\\n    }\\n\\n    function airdrop(address _to) payable external notReentrant {\\n        require(airdrop_enabled, \\\"Airdrop not Enabled.\\\");\\n\\n        address _addr = msg.sender;\\n        uint256 _amount = msg.value;\\n\\n        require(_amount >= AIRDROP_MIN, \\\"Mininum airdrop amount not met.\\\");\\n\\n        if (users[_to].deposit_amount.add(_amount) >= maxReinvestOf(users[_to].total_direct_deposits) ) {\\n            revert(\\\"User exceeded x5 of total deposit.\\\");\\n        }\\n\\n        // transfer to recipient        \\n        uint256 project_fee = _amount.mul(AIRDROP).div(PERCENTS_DIVIDER); // tax on airdrop if enabled\\n        uint256 payout = _amount.sub(project_fee);\\n        if (project_fee > 0) {\\n            projectManager.transfer(project_fee);\\n        }\\n\\n        //Make sure _to exists in the system; we increase\\n        require(users[_to].upline != address(0), \\\"_to not found\\\");\\n\\n        //Fund to airdrop bonus (not a transfer - user will be able to claim/reinvest)\\n        airdrops[_to].airdrop_bonus += payout;\\n\\n        //User stats\\n        airdrops[_addr].airdrops += payout; // sender\\n        airdrops[_addr].last_airdrop = block.timestamp; // sender\\n        airdrops[_addr].airdrops_sent += payout; // sender\\n        airdrops[_addr].airdrops_sent_count = airdrops[_addr].airdrops_sent_count.add(1); // sender add count for airdrop sent count\\n        airdrops[_to].airdrops_received += payout; // recipient\\n        airdrops[_to].airdrops_received_count = airdrops[_to].airdrops_received_count.add(1); // recipient add count for airdrop received count\\n        airdrops[_to].last_airdrop_received = block.timestamp; // recipient\\n\\n        //Keep track of overall stats\\n        total_airdrops += payout;\\n\\n        emit NewAirdrop(_addr, _to, payout, block.timestamp);\\n    }\\n\\n    function teamAirdrop(uint256 teamId, bool excludeOwner) payable external notReentrant {\\n        require(airdrop_enabled, \\\"Airdrop not Enabled.\\\");\\n        \\n        address _addr = msg.sender;\\n        uint256 _amount = msg.value;\\n        \\n        require(_amount >= AIRDROP_MIN, \\\"Mininum airdrop amount not met.\\\");\\n\\n        // transfer to recipient        \\n        uint256 project_fee = _amount.mul(AIRDROP).div(PERCENTS_DIVIDER); // tax on airdrop\\n        uint256 payout = _amount.sub(project_fee);\\n        if (project_fee > 0) {\\n            projectManager.transfer(project_fee);\\n        }\\n        //Make sure _to exists in the system; we increase\\n        require(teams[teamId].owner != address(0), \\\"team not found\\\");\\n        uint256 memberDivider = teams[teamId].members.length;\\n        if (excludeOwner == true) {\\n            memberDivider--;\\n        }\\n        uint256 amountDivided = _amount.div(memberDivider);\\n        for (uint8 i = 0; i < teams[teamId].members.length; i++) {\\n            address _to = address(teams[teamId].members[i]);\\n            if (excludeOwner == true && _to == teams[teamId].owner) {\\n                continue;\\n            }\\n            //Fund to airdrop bonus (not a transfer - user will be able to claim/reinvest)\\n            airdrops[_to].airdrop_bonus += amountDivided;\\n            //User stats\\n            airdrops[_addr].airdrops += amountDivided; // sender\\n            airdrops[_addr].last_airdrop = block.timestamp; // sender\\n            airdrops[_addr].airdrops_sent += amountDivided; // sender\\n            airdrops[_addr].airdrops_sent_count = airdrops[_addr].airdrops_sent_count.add(1); // sender add count for airdrop sent count\\n            airdrops[_to].airdrops_received += amountDivided; // recipient\\n            airdrops[_to].airdrops_received_count = airdrops[_to].airdrops_received_count.add(1); // recipient add count for airdrop received count\\n            airdrops[_to].last_airdrop_received = block.timestamp; // recipient\\n            emit NewAirdrop(_addr, _to, payout, block.timestamp);\\n        }\\n        //Keep track of overall stats\\n        total_airdrops += payout;\\n    }\\n\\n    function payoutOf(address _addr) view public returns(uint256 payout, uint256 max_payout) {\\n        max_payout = maxPayoutOf(users[_addr].deposit_amount);\\n        if (users[_addr].deposit_payouts < max_payout) {\\n            uint256 timestamp_user_action = users[_addr].checkpoint;\\n            uint256 timestamp_now = block.timestamp;\\n            if (timestamp_user_action < timestamp_cutoff_release.sub(48 hours)) { // last action was before cut off upgrade\\n                timestamp_now = timestamp_cutoff_release; // stop accumulation at upgrade time\\n            } else if (timestamp_user_action < block.timestamp.sub(48 hours)) { // last action was after cut off upgrade but longer than 48h ago\\n                timestamp_user_action = block.timestamp.sub(48 hours); // accumulate only 48h\\n            }\\n            payout = (users[_addr].deposit_amount.mul(BASE_PERCENT).div(PERCENTS_DIVIDER))\\n                    .mul(timestamp_now.sub(timestamp_user_action))\\n                    .div(TIME_STEP);\\n            if (users[_addr].deposit_payouts.add(payout) > max_payout) {\\n                payout = max_payout.sub(users[_addr].deposit_payouts);\\n\\n            }\\n        }\\n    }\\n\\n    function payoutToReinvest(address _addr) view public returns(uint256 payout) {\\n        uint256 max_payout = maxPayoutOf(users[_addr].deposit_amount);\\n        if (users[_addr].deposit_payouts < max_payout) {\\n            uint256 timestamp_user_action = users[_addr].checkpoint;\\n            uint256 timestamp_now = block.timestamp;\\n            if (timestamp_user_action < timestamp_cutoff_release.sub(48 hours)) { // last action was before cut off upgrade\\n                timestamp_now = timestamp_cutoff_release; // stop accumulation at upgrade time\\n            } else if (timestamp_user_action < block.timestamp.sub(48 hours)) { // last action was after cut off upgrade but longer than 48h ago\\n                timestamp_user_action = block.timestamp.sub(48 hours); // accumulate only 48h\\n            }\\n            payout = (users[_addr].deposit_amount.mul(BASE_PERCENT).div(PERCENTS_DIVIDER))\\n                    .mul(timestamp_now.sub(timestamp_user_action))\\n                    .div(TIME_STEP);\\n        }\\n    }\\n\\n    function maxPayoutOf(uint256 _amount) pure public returns(uint256) {\\n        return _amount.mul(MAX_PAYOUT).div(PERCENTS_DIVIDER);\\n    }\\n\\n    function fees(uint256 amount) internal returns(uint256) {\\n        uint256 project = amount.mul(PROJECT).div(PERCENTS_DIVIDER);\\n        uint256 marketing = amount.mul(MARKETING).div(PERCENTS_DIVIDER);\\n        projectManager.transfer(project);\\n        for (uint256 i = 0; i < marketingWallets.length; i++) {\\n            uint256 feeShare = amount.mul(marketingBasis[i]).div(FEE_DIVIDER);\\n            payable(marketingWallets[i]).transfer(feeShare);\\n        }\\n        return project.add(marketing);\\n    }\\n\\n    function withdrawalTaxPercentage(uint256 to_payout) view public returns(uint256 finalPayout) {\\n      uint256 contractBalance = address(this).balance;\\n\\t  \\n      if (to_payout < contractBalance.mul(10).div(PERCENTS_DIVIDER)) {           // 0% tax if amount is  <  1% of contract balance\\n          finalPayout = to_payout; \\n      } else if (to_payout >= contractBalance.mul(10).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(50).div(PERCENTS_DIVIDER));  // 5% tax if amount is >=  1% of contract balance\\n      } else if (to_payout >= contractBalance.mul(20).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(100).div(PERCENTS_DIVIDER)); //10% tax if amount is >=  2% of contract balance\\n      } else if (to_payout >= contractBalance.mul(30).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(150).div(PERCENTS_DIVIDER)); //15% tax if amount is >=  3% of contract balance\\n      } else if (to_payout >= contractBalance.mul(40).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(200).div(PERCENTS_DIVIDER)); //20% tax if amount is >=  4% of contract balance\\n      } else if (to_payout >= contractBalance.mul(50).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(250).div(PERCENTS_DIVIDER)); //25% tax if amount is >=  5% of contract balance\\n      } else if (to_payout >= contractBalance.mul(60).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(300).div(PERCENTS_DIVIDER)); //30% tax if amount is >=  6% of contract balance\\n      } else if (to_payout >= contractBalance.mul(70).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(350).div(PERCENTS_DIVIDER)); //35% tax if amount is >=  7% of contract balance\\n      } else if (to_payout >= contractBalance.mul(80).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(400).div(PERCENTS_DIVIDER)); //40% tax if amount is >=  8% of contract balance\\n      } else if (to_payout >= contractBalance.mul(90).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(450).div(PERCENTS_DIVIDER)); //45% tax if amount is >=  9% of contract balance\\n      } else if (to_payout >= contractBalance.mul(100).div(PERCENTS_DIVIDER)) {\\n          finalPayout = to_payout.sub(to_payout.mul(500).div(PERCENTS_DIVIDER)); //50% tax if amount is >= 10% of contract balance\\n      }\\n    }\\n\\n    function _createTeam(address userAddress, bool is_referral_team) private returns(uint256 teamId) {\\n        uint8 numberOfExistingTeams = user_teams_counter[userAddress];\\n        require(numberOfExistingTeams <= MAX_TEAMS_PER_ADDRESS, \\\"Max number of teams reached.\\\");\\n        teamId = total_teams_created++;\\n        teams[teamId].id = teamId;\\n        teams[teamId].created_at = block.timestamp;\\n        teams[teamId].owner = userAddress;\\n        teams[teamId].members.push(userAddress);\\n        teams[teamId].is_referral_team = is_referral_team;\\n        user_teams[userAddress].push(TeamInfo(teamId, true));\\n        user_teams_counter[userAddress]++;\\n    }\\n\\n    function _addTeamMember(uint256 teamId, address member) private {\\n        Team storage team = teams[teamId];\\n\\n        team.members.push(member);\\n        user_teams[member].push(TeamInfo(teamId, true));\\n        user_teams_counter[member]++;\\n    }\\n\\n\\n    /* Views */\\n    function userInfo(address _addr) view external returns(address upline, uint256 checkpoint, uint256 deposit_amount, uint256 payouts, uint256 direct_bonus, uint256 match_bonus) {\\n        return (users[_addr].upline, users[_addr].checkpoint, users[_addr].deposit_amount, users[_addr].payouts, users[_addr].direct_bonus, users[_addr].match_bonus);\\n    }\\n\\n    function userInfo2(address _addr) view external returns(uint256 last_airdrop, uint8 teams_counter, TeamInfo[] memory member_of_teams, string memory nickname, uint256 airdrop_bonus, uint8 reinvest_count) {\\n        return (airdrops[_addr].last_airdrop, user_teams_counter[_addr], user_teams[_addr], nicknames[_addr], airdrops[_addr].airdrop_bonus, user_reinvest_count[_addr]);\\n    }\\n\\n    function userDirectTeamsInfo(address _addr) view external returns(uint256 referral_team, bool referral_team_exists, uint256 upline_team, bool upline_team_exists) {\\n        User memory user = users[_addr];\\n        return (user_referral_team[_addr].id, user_referral_team[_addr].exists, user_referral_team[user.upline].id, user_referral_team[user.upline].exists);\\n    }\\n\\n    function teamInfo(uint256 teamId) view external returns(Team memory _team, string[] memory nicks) {\\n        Team memory team = teams[teamId];\\n        nicks = new string[](team.members.length);\\n\\n        for (uint256 i = 0; i < team.members.length; i++) {\\n            nicks[i] = nicknames[team.members[i]];\\n        }\\n        return (team, nicks);\\n    }\\n\\n    function userInfoTotals(address _addr) view external returns(uint256 referrals, uint256 total_deposits, uint256 total_payouts, uint256 total_structure,uint256 total_downline_deposit, uint256 airdrops_total, uint256 airdrops_received) {\\n        return (users[_addr].referrals, users[_addr].total_direct_deposits, users[_addr].total_payouts, users[_addr].total_structure, users[_addr].total_downline_deposit, airdrops[_addr].airdrops, airdrops[_addr].airdrops_received);\\n    }\\n\\n    function contractInfo() view external returns(uint256 _total_users, uint256 _total_deposited, uint256 _total_withdraw, uint256 _total_airdrops) {\\n        return (total_users, total_deposited, total_withdraw, total_airdrops);\\n    }\\n\\t\\t\\n    /*  Admin only */\\n\\tfunction UPGRADE_REFERRAL() external {\\n        require(msg.sender == projectManager, \\\"Admin use only\\\");\\n        ref_bonuses[0] = 10;\\n        ref_bonuses[1] = 10;\\n        ref_bonuses[2] = 10;\\n    }\\n    \\n    function SET_AIRDROP(bool value) external {\\n        require(msg.sender == projectManager, \\\"Admin use only\\\");\\n        airdrop_enabled = value;\\n    }\\n\\t\\n    function SET_MANDATORY_REINVEST(bool value) external {\\n        require(msg.sender == projectManager, \\\"Admin use only\\\");\\n\\t\\tMANDATORY_REINVEST_ENABLED = value;\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"projectManagerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DirectPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LimitReached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MatchPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"NewAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReinvestedDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"}],\"name\":\"Upline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACTION_COOLDOWN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AIRDROP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AIRDROP_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANDATORY_REINVEST_COUNT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANDATORY_REINVEST_ENABLED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MARKETING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LENGTH_NICKNAME\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PAYOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PAYOUT_CAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REINVEST_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REINVEST_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TEAMS_PER_ADDRESS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_WALLET_DEPOSIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEPOSIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REINVEST_BONUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SET_AIRDROP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SET_MANDATORY_REINVEST\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPGRADE_REFERRAL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop_enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"airdrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"airdrops\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_sent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_sent_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_received_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_airdrop\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_airdrop_received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"checkUplineValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_total_users\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total_airdrops\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"id2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingBasis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketingWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"maxPayoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"maxReinvestOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"payoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"payoutToReinvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectManager\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ref_bonuses\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ref_depth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toBeRolledAmount\",\"type\":\"uint256\"}],\"name\":\"reinvestAmountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reinvestAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"excludeOwner\",\"type\":\"bool\"}],\"name\":\"teamAirdrop\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"teamId\",\"type\":\"uint256\"}],\"name\":\"teamInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"members\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created_at\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"is_referral_team\",\"type\":\"bool\"}],\"internalType\":\"struct BNBAllStars.Team\",\"name\":\"_team\",\"type\":\"tuple\"},{\"internalType\":\"string[]\",\"name\":\"nicks\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created_at\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"is_referral_team\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp_cutoff_release\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_airdrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_reinvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_teams_created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uplinesOld\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBonusStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"direct_bonus_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"match_bonus_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"income_reinvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus_reinvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_reinvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvested_gross\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userDirectTeamsInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referral_team\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"referral_team_exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"upline_team\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"upline_team_exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"match_bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userInfo2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"last_airdrop\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"teams_counter\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"internalType\":\"struct BNBAllStars.TeamInfo[]\",\"name\":\"member_of_teams\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"nickname\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"airdrop_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"reinvest_count\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userInfoTotals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_structure\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_downline_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdrops_received\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_referral_team\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_reinvest_count\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_teams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_teams_counter\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"direct_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"match_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit_payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_direct_deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_payouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_structure\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_downline_deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"to_payout\",\"type\":\"uint256\"}],\"name\":\"withdrawalTaxPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalPayout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BNBAllStars", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000aa9ea734eb308e0a44efe5bae8a30e076970fc49", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}