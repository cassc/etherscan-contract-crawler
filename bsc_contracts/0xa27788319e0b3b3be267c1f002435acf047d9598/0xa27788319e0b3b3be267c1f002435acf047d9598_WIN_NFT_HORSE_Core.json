{"SourceCode": "pragma solidity ^0.4.19;\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes _data) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract AxieAccessControl {\r\n\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    function AxieAccessControl() internal {\r\n        ceoAddress = msg.sender;\r\n    }\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require(\r\n        // solium-disable operator-whitespace\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress ||\r\n            msg.sender == cooAddress\r\n        // solium-enable operator-whitespace\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    function withdrawBalance() external onlyCFO {\r\n        cfoAddress.transfer(this.balance);\r\n    }\r\n}\r\n\r\ncontract AxiePausable is AxieAccessControl {\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n\r\ninterface AxieSpawningManager {\r\n    function isSpawningAllowed(uint256 _genes, address _owner) external returns (bool);\r\n    function isRebirthAllowed(uint256 _axieId, uint256 _genes) external returns (bool);\r\n}\r\n\r\ninterface AxieRetirementManager {\r\n    function isRetirementAllowed(uint256 _axieId, bool _rip) external returns (bool);\r\n}\r\n\r\ninterface AxieMarketplaceManager {\r\n    function isTransferAllowed(address _from, address _to, uint256 _axieId) external returns (bool);\r\n}\r\n\r\ninterface AxieGeneManager {\r\n    function isEvolvementAllowed(uint256 _axieId, uint256 _newGenes) external returns (bool);\r\n}\r\n\r\ncontract AxieDependency {\r\n\r\n    address public whitelistSetterAddress;\r\n\r\n    AxieSpawningManager public spawningManager;\r\n    AxieRetirementManager public retirementManager;\r\n    AxieMarketplaceManager public marketplaceManager;\r\n    AxieGeneManager public geneManager;\r\n\r\n    mapping (address => bool) public whitelistedSpawner;\r\n    mapping (address => bool) public whitelistedByeSayer;\r\n    mapping (address => bool) public whitelistedMarketplace;\r\n    mapping (address => bool) public whitelistedGeneScientist;\r\n\r\n    constructor() internal {\r\n        whitelistSetterAddress = msg.sender;\r\n    }\r\n\r\n    modifier onlyWhitelistSetter() {\r\n        require(msg.sender == whitelistSetterAddress);\r\n        _;\r\n    }\r\n\r\n    modifier whenSpawningAllowed(uint256 _genes, address _owner) {\r\n        require(\r\n            spawningManager == address(0) ||\r\n            spawningManager.isSpawningAllowed(_genes, _owner)\r\n        ,\"whenSpawningAllowed\");\r\n        _;\r\n    }\r\n\r\n    modifier whenRebirthAllowed(uint256 _axieId, uint256 _genes) {\r\n        require(\r\n            spawningManager == address(0) ||\r\n            spawningManager.isRebirthAllowed(_axieId, _genes)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenRetirementAllowed(uint256 _axieId, bool _rip) {\r\n        require(\r\n            retirementManager == address(0) ||\r\n            retirementManager.isRetirementAllowed(_axieId, _rip)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenTransferAllowed(address _from, address _to, uint256 _axieId) {\r\n        require(\r\n            marketplaceManager == address(0) ||\r\n            marketplaceManager.isTransferAllowed(_from, _to, _axieId)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenEvolvementAllowed(uint256 _axieId, uint256 _newGenes) {\r\n        require(\r\n            geneManager == address(0) ||\r\n            geneManager.isEvolvementAllowed(_axieId, _newGenes)\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlySpawner() {\r\n        require(whitelistedSpawner[msg.sender],\"onlySpawner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyByeSayer() {\r\n        require(whitelistedByeSayer[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMarketplace() {\r\n        require(whitelistedMarketplace[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyGeneScientist() {\r\n        require(whitelistedGeneScientist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * @dev Setting the whitelist setter address to `address(0)` would be a irreversible process.\r\n     *  This is to lock changes to Axie's contracts after their development is done.\r\n     */\r\n    function setWhitelistSetter(address _newSetter) external onlyWhitelistSetter {\r\n        whitelistSetterAddress = _newSetter;\r\n    }\r\n\r\n    function setSpawningManager(address _manager) external onlyWhitelistSetter {\r\n        spawningManager = AxieSpawningManager(_manager);\r\n    }\r\n\r\n    function setRetirementManager(address _manager) external onlyWhitelistSetter {\r\n        retirementManager = AxieRetirementManager(_manager);\r\n    }\r\n\r\n    function setMarketplaceManager(address _manager) external onlyWhitelistSetter {\r\n        marketplaceManager = AxieMarketplaceManager(_manager);\r\n    }\r\n\r\n    function setGeneManager(address _manager) external onlyWhitelistSetter {\r\n        geneManager = AxieGeneManager(_manager);\r\n    }\r\n\r\n    function setSpawner(address _spawner, bool _whitelisted) external onlyWhitelistSetter {\r\n        require(whitelistedSpawner[_spawner] != _whitelisted);\r\n        whitelistedSpawner[_spawner] = _whitelisted;\r\n    }\r\n\r\n    function setByeSayer(address _byeSayer, bool _whitelisted) external onlyWhitelistSetter {\r\n        require(whitelistedByeSayer[_byeSayer] != _whitelisted);\r\n        whitelistedByeSayer[_byeSayer] = _whitelisted;\r\n    }\r\n\r\n    function setMarketplace(address _marketplace, bool _whitelisted) external onlyWhitelistSetter {\r\n        require(whitelistedMarketplace[_marketplace] != _whitelisted);\r\n        whitelistedMarketplace[_marketplace] = _whitelisted;\r\n    }\r\n\r\n    function setGeneScientist(address _geneScientist, bool _whitelisted) external onlyWhitelistSetter {\r\n        require(whitelistedGeneScientist[_geneScientist] != _whitelisted);\r\n        whitelistedGeneScientist[_geneScientist] = _whitelisted;\r\n    }\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63\r\ninterface IERC721Enumerable /* is IERC721Base */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId);\r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x6466353c\r\ninterface IERC721Base /* is IERC165  */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param _data Additional data with no specified format, sent in call to `_to`\r\n    // solium-disable-next-line arg-overflow\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to []\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your asset.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-165 Standard Interface Detection\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC165 is IERC165 {\r\n    /// @dev You must not set element 0xffffffff to true\r\n    mapping (bytes4 => bool) internal supportedInterfaces;\r\n\r\n    function ERC165() internal {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC-165\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[interfaceID];\r\n    }\r\n}\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f\r\ninterface IERC721Metadata /* is IERC721Base */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external pure returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external pure returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ncontract AxieERC721BaseEnumerable is ERC165, IERC721Base, IERC721Enumerable, AxieDependency, AxiePausable {\r\n    using SafeMath for uint256;\r\n\r\n    // @dev Total amount of tokens.\r\n    uint256 private _totalTokens;\r\n\r\n    // @dev Mapping from token index to ID.\r\n    mapping (uint256 => uint256) private _overallTokenId;\r\n\r\n    // @dev Mapping from token ID to index.\r\n    mapping (uint256 => uint256) private _overallTokenIndex;\r\n\r\n    // @dev Mapping from token ID to owner.\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // @dev For a given owner and a given operator, store whether\r\n    //  the operator is allowed to manage tokens on behalf of the owner.\r\n    mapping (address => mapping (address => bool)) private _tokenOperator;\r\n\r\n    // @dev Mapping from token ID to approved address.\r\n    mapping (uint256 => address) private _tokenApproval;\r\n\r\n    // @dev Mapping from owner to list of owned token IDs.\r\n    mapping (address => uint256[]) private _ownedTokens;\r\n\r\n    // @dev Mapping from token ID to index in the owned token list.\r\n    mapping (uint256 => uint256) private _ownedTokenIndex;\r\n\r\n    function AxieERC721BaseEnumerable() internal {\r\n        supportedInterfaces[0x6466353c] = true; // ERC-721 Base\r\n        supportedInterfaces[0x780e9d63] = true; // ERC-721 Enumerable\r\n    }\r\n\r\n    // solium-disable function-order\r\n\r\n    modifier mustBeValidToken(uint256 _tokenId) {\r\n        require(_tokenOwner[_tokenId] != address(0));\r\n        _;\r\n    }\r\n\r\n    function _isTokenOwner(address _ownerToCheck, uint256 _tokenId) private view returns (bool) {\r\n        return _tokenOwner[_tokenId] == _ownerToCheck;\r\n    }\r\n\r\n    function _isTokenOperator(address _operatorToCheck, uint256 _tokenId) private view returns (bool) {\r\n        return whitelistedMarketplace[_operatorToCheck] ||\r\n        _tokenOperator[_tokenOwner[_tokenId]][_operatorToCheck];\r\n    }\r\n\r\n    function _isApproved(address _approvedToCheck, uint256 _tokenId) private view returns (bool) {\r\n        return _tokenApproval[_tokenId] == _approvedToCheck;\r\n    }\r\n\r\n    modifier onlyTokenOwner(uint256 _tokenId) {\r\n        require(_isTokenOwner(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenOwnerOrOperator(uint256 _tokenId) {\r\n        require(_isTokenOwner(msg.sender, _tokenId) || _isTokenOperator(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenAuthorized(uint256 _tokenId) {\r\n        require(\r\n        // solium-disable operator-whitespace\r\n            _isTokenOwner(msg.sender, _tokenId) ||\r\n            _isTokenOperator(msg.sender, _tokenId) ||\r\n            _isApproved(msg.sender, _tokenId)\r\n        // solium-enable operator-whitespace\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ERC-721 Base\r\n\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return _ownedTokens[_owner].length;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view mustBeValidToken(_tokenId) returns (address) {\r\n        return _tokenOwner[_tokenId];\r\n    }\r\n\r\n    function _addTokenTo(address _to, uint256 _tokenId) private {\r\n        require(_to != address(0),\"_to != address(0)\");\r\n\r\n        _tokenOwner[_tokenId] = _to;\r\n\r\n        uint256 length = _ownedTokens[_to].length;\r\n        _ownedTokens[_to].push(_tokenId);\r\n        _ownedTokenIndex[_tokenId] = length;\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_tokenOwner[_tokenId] == address(0),\"_tokenOwner[_tokenId] == address(0)\");\r\n\r\n        _addTokenTo(_to, _tokenId);\r\n\r\n        _overallTokenId[_totalTokens] = _tokenId;\r\n        _overallTokenIndex[_tokenId] = _totalTokens;\r\n        _totalTokens = _totalTokens.add(1);\r\n\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    function _removeTokenFrom(address _from, uint256 _tokenId) private {\r\n        require(_from != address(0));\r\n\r\n        uint256 _tokenIndex = _ownedTokenIndex[_tokenId];\r\n        uint256 _lastTokenIndex = _ownedTokens[_from].length.sub(1);\r\n        uint256 _lastTokenId = _ownedTokens[_from][_lastTokenIndex];\r\n\r\n        _tokenOwner[_tokenId] = address(0);\r\n\r\n        // Insert the last token into the position previously occupied by the removed token.\r\n        _ownedTokens[_from][_tokenIndex] = _lastTokenId;\r\n        _ownedTokenIndex[_lastTokenId] = _tokenIndex;\r\n\r\n        // Resize the array.\r\n        delete _ownedTokens[_from][_lastTokenIndex];\r\n        _ownedTokens[_from].length--;\r\n\r\n        // Remove the array if no more tokens are owned to prevent pollution.\r\n        if (_ownedTokens[_from].length == 0) {\r\n            delete _ownedTokens[_from];\r\n        }\r\n\r\n        // Update the index of the removed token.\r\n        delete _ownedTokenIndex[_tokenId];\r\n    }\r\n\r\n    function _burn(uint256 _tokenId) internal {\r\n        address _from = _tokenOwner[_tokenId];\r\n\r\n        require(_from != address(0));\r\n\r\n        _removeTokenFrom(_from, _tokenId);\r\n        _totalTokens = _totalTokens.sub(1);\r\n\r\n        uint256 _tokenIndex = _overallTokenIndex[_tokenId];\r\n        uint256 _lastTokenId = _overallTokenId[_totalTokens];\r\n\r\n        delete _overallTokenIndex[_tokenId];\r\n        delete _overallTokenId[_totalTokens];\r\n        _overallTokenId[_tokenIndex] = _lastTokenId;\r\n        _overallTokenIndex[_lastTokenId] = _tokenIndex;\r\n\r\n        Transfer(_from, address(0), _tokenId);\r\n    }\r\n\r\n    function _isContract(address _address) private view returns (bool) {\r\n        uint _size;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { _size := extcodesize(_address) }\r\n        return _size > 0;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data,\r\n        bool _check\r\n    )\r\n    internal\r\n    mustBeValidToken(_tokenId)\r\n    onlyTokenAuthorized(_tokenId)\r\n    whenTransferAllowed(_from, _to, _tokenId)\r\n    {\r\n        require(_isTokenOwner(_from, _tokenId));\r\n        require(_to != address(0));\r\n        require(_to != _from);\r\n\r\n        _removeTokenFrom(_from, _tokenId);\r\n\r\n        delete _tokenApproval[_tokenId];\r\n        Approval(_from, address(0), _tokenId);\r\n\r\n        _addTokenTo(_to, _tokenId);\r\n\r\n        if (_check && _isContract(_to)) {\r\n            IERC721TokenReceiver(_to).onERC721Received.gas(50000)(_from, _tokenId, _data);\r\n        }\r\n\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    // solium-disable arg-overflow\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external payable {\r\n        _transferFrom(_from, _to, _tokenId, _data, true);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n        _transferFrom(_from, _to, _tokenId, \"\", true);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n        _transferFrom(_from, _to, _tokenId, \"\", false);\r\n    }\r\n\r\n    // solium-enable arg-overflow\r\n\r\n    function approve(\r\n        address _approved,\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    payable\r\n    mustBeValidToken(_tokenId)\r\n    onlyTokenOwnerOrOperator(_tokenId)\r\n    whenNotPaused\r\n    {\r\n        address _owner = _tokenOwner[_tokenId];\r\n\r\n        require(_owner != _approved);\r\n        require(_tokenApproval[_tokenId] != _approved);\r\n\r\n        _tokenApproval[_tokenId] = _approved;\r\n\r\n        Approval(_owner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external whenNotPaused {\r\n        require(_tokenOperator[msg.sender][_operator] != _approved);\r\n        _tokenOperator[msg.sender][_operator] = _approved;\r\n        ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view mustBeValidToken(_tokenId) returns (address) {\r\n        return _tokenApproval[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return _tokenOperator[_owner][_operator];\r\n    }\r\n\r\n    // ERC-721 Enumerable\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalTokens;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < _totalTokens);\r\n        return _overallTokenId[_index];\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 _tokenId) {\r\n        require(_owner != address(0));\r\n        require(_index < _ownedTokens[_owner].length);\r\n        return _ownedTokens[_owner][_index];\r\n    }\r\n}\r\n\r\ncontract AxieERC721Metadata is AxieERC721BaseEnumerable, IERC721Metadata {\r\n    string public tokenURIPrefix = \"https://api.winnfthorse.io/api/erc/721/horse/\";\r\n    string public tokenURISuffix = \".json\";\r\n\r\n    function AxieERC721Metadata() internal {\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC-721 Metadata\r\n    }\r\n\r\n    function name() external pure returns (string) {\r\n        return \"WIN_NFT_HORSE\";\r\n    }\r\n\r\n    function symbol() external pure returns (string) {\r\n        return \"WNH\";\r\n    }\r\n\r\n    function setTokenURIAffixes(string _prefix, string _suffix) external onlyCEO {\r\n        tokenURIPrefix = _prefix;\r\n        tokenURISuffix = _suffix;\r\n    }\r\n\r\n    function tokenURI(\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    view\r\n    mustBeValidToken(_tokenId)\r\n    returns (string)\r\n    {\r\n        bytes memory _tokenURIPrefixBytes = bytes(tokenURIPrefix);\r\n        bytes memory _tokenURISuffixBytes = bytes(tokenURISuffix);\r\n        uint256 _tmpTokenId = _tokenId;\r\n        uint256 _length;\r\n\r\n        do {\r\n            _length++;\r\n            _tmpTokenId /= 10;\r\n        } while (_tmpTokenId > 0);\r\n\r\n        bytes memory _tokenURIBytes = new bytes(_tokenURIPrefixBytes.length + _length + 5);\r\n        uint256 _i = _tokenURIBytes.length - 6;\r\n\r\n        _tmpTokenId = _tokenId;\r\n\r\n        do {\r\n            _tokenURIBytes[_i--] = byte(48 + _tmpTokenId % 10);\r\n            _tmpTokenId /= 10;\r\n        } while (_tmpTokenId > 0);\r\n\r\n        for (_i = 0; _i < _tokenURIPrefixBytes.length; _i++) {\r\n            _tokenURIBytes[_i] = _tokenURIPrefixBytes[_i];\r\n        }\r\n\r\n        for (_i = 0; _i < _tokenURISuffixBytes.length; _i++) {\r\n            _tokenURIBytes[_tokenURIBytes.length + _i - 5] = _tokenURISuffixBytes[_i];\r\n        }\r\n\r\n        return string(_tokenURIBytes);\r\n    }\r\n}\r\n\r\n// solium-disable-next-line no-empty-blocks\r\ncontract AxieERC721 is AxieERC721BaseEnumerable, AxieERC721Metadata {\r\n}\r\n\r\n// solium-disable-next-line no-empty-blocks\r\ncontract WIN_NFT_HORSE_Core is AxieERC721 {\r\n    struct Axie {\r\n        uint256 genes;\r\n        uint256 bornAt;\r\n    }\r\n\r\n    Axie[] axies;\r\n\r\n    event AxieSpawned(uint256 indexed _axieId, address indexed _owner, uint256 _genes);\r\n    event AxieRebirthed(uint256 indexed _axieId, uint256 _genes);\r\n    event AxieRetired(uint256 indexed _axieId);\r\n    event AxieEvolved(uint256 indexed _axieId, uint256 _oldGenes, uint256 _newGenes);\r\n\r\n    function WIN_NFT_HORSE_Core() public {\r\n        axies.push(Axie(0, now)); // The void Axie\r\n        _spawnAxie(0, msg.sender); // Will be Puff\r\n        _spawnAxie(0, msg.sender); // Will be Kotaro\r\n        _spawnAxie(0, msg.sender); // Will be Ginger\r\n        _spawnAxie(0, msg.sender); // Will be Stella\r\n    }\r\n\r\n    function getAxie(\r\n        uint256 _axieId\r\n    )\r\n    external\r\n    view\r\n    mustBeValidToken(_axieId)\r\n    returns (uint256 /* _genes */, uint256 /* _bornAt */)\r\n    {\r\n        Axie storage _axie = axies[_axieId];\r\n        return (_axie.genes, _axie.bornAt);\r\n    }\r\n\r\n    function spawnAxie(uint256 _genes, address _owner) external\r\n    onlySpawner\r\n    whenSpawningAllowed(_genes, _owner)\r\n    returns (uint256)\r\n    {\r\n        return _spawnAxie(_genes, _owner);\r\n    }\r\n\r\n    function rebirthAxie(\r\n        uint256 _axieId,\r\n        uint256 _genes\r\n    )\r\n    external\r\n    onlySpawner\r\n    mustBeValidToken(_axieId)\r\n    whenRebirthAllowed(_axieId, _genes)\r\n    {\r\n        Axie storage _axie = axies[_axieId];\r\n        _axie.genes = _genes;\r\n        _axie.bornAt = now;\r\n        AxieRebirthed(_axieId, _genes);\r\n    }\r\n\r\n    function retireAxie(\r\n        uint256 _axieId,\r\n        bool _rip\r\n    )\r\n    external\r\n    onlyByeSayer\r\n    whenRetirementAllowed(_axieId, _rip)\r\n    {\r\n        _burn(_axieId);\r\n\r\n        if (_rip) {\r\n            delete axies[_axieId];\r\n        }\r\n\r\n        AxieRetired(_axieId);\r\n    }\r\n\r\n    function evolveAxie(\r\n        uint256 _axieId,\r\n        uint256 _newGenes\r\n    )\r\n    external\r\n    onlyGeneScientist\r\n    mustBeValidToken(_axieId)\r\n    whenEvolvementAllowed(_axieId, _newGenes)\r\n    {\r\n        uint256 _oldGenes = axies[_axieId].genes;\r\n        axies[_axieId].genes = _newGenes;\r\n        AxieEvolved(_axieId, _oldGenes, _newGenes);\r\n    }\r\n\r\n    function _spawnAxie(uint256 _genes, address _owner) private returns (uint256 _axieId) {\r\n        Axie memory _axie = Axie(_genes, now);\r\n        _axieId = axies.push(_axie) - 1;\r\n        _mint(_owner, _axieId);\r\n        emit AxieSpawned(_axieId, _owner, _genes);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_axieId\",\"type\":\"uint256\"},{\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"rebirthAxie\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistSetterAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketplaceManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setRetirementManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_geneScientist\",\"type\":\"address\"},{\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setGeneScientist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setMarketplaceManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"retirementManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSetter\",\"type\":\"address\"}],\"name\":\"setWhitelistSetter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"spawnAxie\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_marketplace\",\"type\":\"address\"},{\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setMarketplace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"geneManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_byeSayer\",\"type\":\"address\"},{\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setByeSayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setSpawningManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setGeneManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedByeSayer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spawningManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedGeneScientist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spawner\",\"type\":\"address\"},{\"name\":\"_whitelisted\",\"type\":\"bool\"}],\"name\":\"setSpawner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedMarketplace\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_axieId\",\"type\":\"uint256\"}],\"name\":\"getAxie\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_axieId\",\"type\":\"uint256\"},{\"name\":\"_newGenes\",\"type\":\"uint256\"}],\"name\":\"evolveAxie\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenURIPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedSpawner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_axieId\",\"type\":\"uint256\"},{\"name\":\"_rip\",\"type\":\"bool\"}],\"name\":\"retireAxie\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenURISuffix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prefix\",\"type\":\"string\"},{\"name\":\"_suffix\",\"type\":\"string\"}],\"name\":\"setTokenURIAffixes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_axieId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"AxieSpawned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_axieId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_genes\",\"type\":\"uint256\"}],\"name\":\"AxieRebirthed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_axieId\",\"type\":\"uint256\"}],\"name\":\"AxieRetired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_axieId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_oldGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newGenes\",\"type\":\"uint256\"}],\"name\":\"AxieEvolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "WIN_NFT_HORSE_Core", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://5ce791bc2ce77af035ab275bc6d946a3d496ad9ed177a4b2bd6782fde9985cc2"}