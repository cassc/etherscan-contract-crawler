{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n// Not Open Source - Do Not Copy\r\n\r\n/*\r\n    \r\n    GEN [GEN]\r\n\r\n        Factory Website:    https://tokensbygen.com\r\n        Token Website:      https://gentokens.com/\r\n        Community Group:    https://t.me/GenTokens\r\n        Token Group:        https://t.me/gen_gentokens\r\n        Twitter:            https://twitter.com/GEN_GenTokens\r\n        YouTube:            https://youtube.com/c/gentokens\r\n\r\n    Why Buy GEN? \r\n\r\n        GEN is the flagship token on the GenTokens Community. \r\n        Free Reward Tokens created at www.tokensbygen.com include an immutable 5% GEN Reward\r\n        Every new reward token created pumps GEN! \r\n\r\n    GEN Tokenomics\r\n\r\n        2% GEN Reflection rewards to Holders on every sell\r\n\r\n        Total Buy Fee: 9%\r\n        Total Sell Fee: 9%\r\n\r\n    Buyer Protection\r\n\r\n        Fees are capped at 9% on buys and sells\r\n        Immutable Wallet limits are hard-coded to 1.5% (3,000,000 Tokens)\r\n        Trade can not be paused\r\n        Developer Doxed \r\n        Liquidity Locked\r\n        No team tokens\r\n        See \"Project_Information\" on BSCScan Contract Read Page for links to the Liquidity Lock, Security Audit, and KYC Certificate.\r\n\r\n*/\r\n\r\n\r\npragma solidity 0.8.19;\r\n \r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function factory() external view returns (address);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract GEN is Context, IERC20 { \r\n\r\n    // Contract Wallets\r\n    address public _owner = 0x888220cf888894A717EAFFd9c29480C52C5cBBb7;\r\n    address payable public FeeCollector = payable(0x091207Db05D3Ca5afeCDb01c739F5665317854f0);\r\n    address public constant Wallet_Burn = 0x000000000000000000000000000000000000dEaD; \r\n\r\n\r\n    // Token Info\r\n    string private constant _name = \"GEN\";\r\n    string private constant _symbol = \"GEN\";\r\n    uint8 private constant  _decimals = 9;\r\n\r\n    // Buy fees (Project fee includes marketing, liquidity, team etc.)\r\n    uint8 public FeeBuy_Reflect = 0;\r\n    uint8 public FeeBuy_Project = 9;\r\n\r\n    // Sell Fees\r\n    uint8 public FeeSell_Reflect = 2;\r\n    uint8 public FeeSell_Project = 7;\r\n\r\n    // Fee Processing Triggers\r\n    uint8 private swapTrigger = 12;\r\n    uint8 private swapCounter = 1;    \r\n    \r\n\r\n    uint256 private constant _tTotal   = 200_000_000 * (10 ** _decimals); \r\n    uint256 private constant max_Hold  =   3_000_000 * (10 ** _decimals); // Max wallet and max transaction are 1.5% of total supply\r\n\r\n    // Project links\r\n    string private _Website = \"https://gentokens.com/\";\r\n    string private _Telegram = \"https://t.me/gen_gentokens\";\r\n    string private _audit;\r\n    string private _dox;\r\n    string private _LP_Lock;\r\n\r\n    // Supply Tracking for RFI\r\n    uint256 private _tFeeTotal;\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n\r\n    // Set factory\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n        constructor () {\r\n\r\n        // Transfer token supply to owner wallet\r\n        _rOwned[_owner] = _rTotal;\r\n\r\n        // Set PancakeSwap Router Address\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n        // Create initial liquidity pair with BNB on PancakeSwap factory\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        // Wallets excluded from holding limits\r\n        _isLimitExempt[_owner] = true;\r\n        _isLimitExempt[address(this)] = true;\r\n        _isLimitExempt[Wallet_Burn] = true;\r\n        _isLimitExempt[uniswapV2Pair] = true;\r\n\r\n        // Wallets excluded from fees\r\n        _isExcludedFromFee[_owner] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[Wallet_Burn] = true;\r\n\r\n        // Set the initial liquidity pair\r\n        _isPair[uniswapV2Pair] = true;    \r\n\r\n        // Exclude from Rewards\r\n        _isExcludedFromRewards[Wallet_Burn] = true;\r\n        _isExcludedFromRewards[uniswapV2Pair] = true;\r\n        _isExcludedFromRewards[address(this)] = true;\r\n\r\n        // Push excluded wallets to array\r\n        _excluded.push(Wallet_Burn);\r\n        _excluded.push(uniswapV2Pair);\r\n        _excluded.push(address(this));\r\n\r\n        // Wallets granted access before trade is open\r\n        _isWhiteListed[_owner] = true;\r\n\r\n        // Emit Supply Transfer to Owner\r\n        emit Transfer(address(0), _owner, _tTotal);\r\n\r\n        // Emit ownership transfer\r\n        emit OwnershipTransferred(address(0), _owner);\r\n\r\n    }\r\n\r\n    \r\n    // Events\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event updated_Buy_fees(uint256 TotalBuyFee);\r\n    event updated_Sell_fees(uint256 TotalSellFee);\r\n    event updated_AutoFeeProcesing(bool AutoFeeProcessing);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\r\n    // Restrict function to contract owner only \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Address mappings\r\n    mapping (address => uint256) private _tOwned;                               // Tokens Owned\r\n    mapping (address => uint256) private _rOwned;                               // Reflected balance\r\n    mapping (address => mapping (address => uint256)) private _allowances;      // Allowance to spend another wallets tokens\r\n    mapping (address => bool) public _isExcludedFromFee;                        // Wallets that do not pay fees\r\n    mapping (address => bool) public _isExcludedFromRewards;                    // Excluded from RFI rewards\r\n    mapping (address => bool) public _isWhiteListed;                            // Wallets that have access before trade is open\r\n    mapping (address => bool) public _isLimitExempt;                            // Wallets that are excluded from HOLD and TRANSFER limits\r\n    mapping (address => bool) public _isPair;                                   // Address is liquidity pair\r\n    address[] private _excluded;                                                // Array of wallets excluded from rewards\r\n\r\n\r\n    // Fee Processing Switch                  \r\n    bool public processingFees;\r\n    bool public autoFeeProcessing; \r\n\r\n    // Launch Settings\r\n    bool public tradeOpen;\r\n    bool public noFeeWhenProcessing;\r\n    bool public freeWalletTransfers = true;\r\n\r\n    // Fee Tracker\r\n    bool private takeFee;\r\n\r\n    // Project info\r\n    function Project_Information() external view returns(address Owner_Wallet,\r\n                                                         uint256 Max_Wallet,\r\n                                                         uint256 Fee_When_Buying,\r\n                                                         uint256 Fee_When_Selling,\r\n                                                         string memory Website,\r\n                                                         string memory Telegram,\r\n                                                         string memory Security_Audit,\r\n                                                         string memory Dox_Certificate,\r\n                                                         string memory Liquidity_Lock) {\r\n                                                           \r\n        uint256 Total_buy = FeeBuy_Project + FeeBuy_Reflect;\r\n        uint256 Total_sell = FeeSell_Project + FeeSell_Reflect;\r\n        uint256 _max_Hold = max_Hold / (10 ** _decimals);\r\n\r\n        // Return Token Data\r\n        return (_owner,\r\n                _max_Hold,\r\n                Total_buy,\r\n                Total_sell,\r\n                _Website,\r\n                _Telegram,\r\n                _audit,\r\n                _dox,\r\n                _LP_Lock);\r\n\r\n    }\r\n\r\n    // Set Fees\r\n    function set_Fees(\r\n\r\n        uint8 ProjectFee_BUY, \r\n        uint8 Reflection_BUY,  \r\n\r\n        uint8 ProjectFee_SELL, \r\n        uint8 Reflection_SELL\r\n\r\n        ) external onlyOwner {\r\n\r\n        require (ProjectFee_BUY + Reflection_BUY <= 9, \"F1\"); // Max buy fee is 9%\r\n        require (ProjectFee_SELL + Reflection_SELL <= 9, \"F2\"); // Max sell fee is 9%\r\n\r\n        // Update Buy Fees\r\n        FeeBuy_Project = ProjectFee_BUY;\r\n        FeeBuy_Reflect = Reflection_BUY;\r\n\r\n        // Update Sell Fees\r\n        FeeSell_Project = ProjectFee_SELL;\r\n        FeeSell_Reflect = Reflection_SELL;\r\n\r\n        emit updated_Buy_fees(FeeBuy_Project + FeeBuy_Reflect);\r\n        emit updated_Sell_fees(FeeSell_Project + FeeSell_Reflect);\r\n    }\r\n\r\n\r\n    // Open Trade\r\n    function open_Trade() external onlyOwner {\r\n\r\n        autoFeeProcessing = true;\r\n        tradeOpen = true;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    ----------------------\r\n    UPDATE PROJECT WALLETS\r\n    ----------------------\r\n\r\n    */\r\n\r\n\r\n\r\n    function update_FeeCollector( \r\n\r\n        address payable Fee_Collector\r\n\r\n        ) external onlyOwner {\r\n\r\n        require(Fee_Collector != address(0), \"W1\"); // Enter a valid Address\r\n        FeeCollector = payable(Fee_Collector);\r\n\r\n    }\r\n\r\n\r\n    /*\r\n\r\n    --------------------\r\n    UPDATE PROJECT LINKS\r\n    --------------------\r\n\r\n    */\r\n\r\n    function update_Link_Website(\r\n\r\n        string memory Website_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _Website = Website_URL;\r\n\r\n    }\r\n\r\n\r\n    function update_Link_Telegram(\r\n\r\n        string memory Telegram_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _Telegram = Telegram_URL;\r\n\r\n    }\r\n\r\n\r\n    function update_Link_Audit(\r\n\r\n        string memory Audit_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _audit = Audit_URL;\r\n\r\n    }\r\n\r\n\r\n    function update_Link_Dox(\r\n\r\n        string memory Dox_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _dox = Dox_URL;\r\n\r\n    }\r\n\r\n\r\n    function update_Link_Liquidity_Lock(\r\n\r\n        string memory LP_Lock_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _LP_Lock = LP_Lock_URL;\r\n\r\n    }\r\n\r\n\r\n    // Add Liquidity Pair - required for correct fee calculations \r\n    function add_Liquidity_Pair(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false)\r\n\r\n        external onlyOwner {\r\n\r\n        _isPair[Wallet_Address] = true_or_false;\r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n        _isExcludedFromRewards[Wallet_Address] = true;\r\n\r\n        // Push excluded wallets to array\r\n        _excluded.push(Wallet_Address);\r\n    } \r\n\r\n    /* \r\n\r\n    ----------------------------\r\n    CONTRACT OWNERSHIP FUNCTIONS\r\n    ----------------------------\r\n\r\n    Before renouncing ownership, set the freeWalletTransfers to false \r\n\r\n    */\r\n  \r\n    // Renounce Ownership - To prevent accidental renounce, you must enter the Confirmation_Code: 1234\r\n    function ownership_RENOUNCE(uint256 Confirmation_Code) public virtual onlyOwner {\r\n\r\n        require(Confirmation_Code == 1234, \"O1\"); // Renounce confirmation not correct\r\n\r\n        // Remove old owner status \r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    // Transfer to New Owner - To prevent accidental renounce, you must enter the Confirmation_Code: 1234\r\n    function ownership_TRANSFER(address payable newOwner, uint256 Confirmation_Code) public onlyOwner {\r\n\r\n        require(Confirmation_Code == 1234, \"O2\"); // Renounce confirmation not correct\r\n        require(newOwner != address(0), \"O3\"); // Enter a valid BSC wallet\r\n\r\n        // Revoke old owner status\r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n\r\n        // Set up new owner status \r\n        _isLimitExempt[owner()]     = true;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isWhiteListed[owner()]     = true;\r\n\r\n    }\r\n\r\n\r\n    /*\r\n    \r\n    ---------------------------------\r\n    NO FEE WALLET TO WALLET TRANSFERS \r\n    ---------------------------------\r\n\r\n    Default = true\r\n\r\n    Having no fee on wallet-to-wallet transfers means that people can move tokens between wallets, \r\n    or send them to friends etc without incurring a fee. \r\n\r\n    If false, the 'Buy' fee will apply to all wallet to wallet transfers.\r\n\r\n    */\r\n\r\n    function free_Wallet_Transfers(bool true_or_false) public onlyOwner {\r\n\r\n        freeWalletTransfers = true_or_false;\r\n\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n    --------------\r\n    FEE PROCESSING\r\n    --------------\r\n\r\n    */\r\n\r\n    // Auto Fee Processing Switch \r\n    function process__Auto_Process(bool true_or_false) external onlyOwner {\r\n        autoFeeProcessing = true_or_false;\r\n        emit updated_AutoFeeProcesing(true_or_false);\r\n    }\r\n\r\n    // Manually Process Fees\r\n    function process__Process_Now (uint256 percent) external onlyOwner {\r\n\r\n        require(!processingFees, \"P1\"); // Already in swap, try later\r\n        require(percent <= 100, \"P2\"); // Max percent is 100 \r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract * percent / 100;\r\n        processFees(sendTokens);\r\n\r\n    }\r\n\r\n    // Update Swap Count Trigger\r\n    function process__Swap_Trigger_Count(uint8 Transaction_Count) external onlyOwner {\r\n\r\n        swapTrigger = Transaction_Count + 1; // Reset to 1 (not 0) to save gas\r\n    }\r\n\r\n    // Rescue Tokens Accidentally Sent to Contract Address\r\n    function process__Rescue_Tokens(\r\n\r\n        address random_Token_Address,\r\n        uint256 number_of_Tokens\r\n\r\n        ) external onlyOwner {\r\n\r\n            require (random_Token_Address != address(this), \"P3\"); // Can not remove the native token\r\n            IERC20(random_Token_Address).transfer(msg.sender, number_of_Tokens);\r\n            \r\n    }\r\n\r\n    // Remove fee for the sell that triggers fee processing\r\n    function process__RemoveFeeWhenProcessing(bool true_or_false) external onlyOwner {\r\n        noFeeWhenProcessing = true_or_false;\r\n    }\r\n\r\n    /*\r\n\r\n    ------------------\r\n    REFLECTION REWARDS\r\n    ------------------\r\n\r\n    The following functions are used to exclude or include a wallet in the reflection rewards.\r\n    By default, all wallets are included. \r\n\r\n    Wallets that are excluded:\r\n\r\n            The Burn address \r\n            The Liquidity Pair\r\n            The Contract Address\r\n\r\n    ------------------------------------\r\n    *** WARNING - 'OUT OF GAS' Risk! ***\r\n    ------------------------------------\r\n\r\n    A reflections contract needs to loop through all excluded wallets to correctly process several functions. \r\n    This loop can break the contract if it runs out of gas before completion.\r\n\r\n    To prevent this, keep the number of wallets that are excluded from rewards to an absolute minimum. \r\n    In addition to the default excluded wallets, you may need to exclude the address of any locked tokens.\r\n\r\n    */\r\n\r\n\r\n    // Wallet will not get reflections\r\n    function rewards_Exclude_Wallet(address account) public onlyOwner() {\r\n        require(!_isExcludedFromRewards[account], \"R1\"); // Account is already excluded\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcludedFromRewards[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n\r\n    // Wallet will get reflections - DEFAULT\r\n    function rewards_Include_Wallet(address account) external onlyOwner() {\r\n        require(_isExcludedFromRewards[account], \"R2\"); // Account is already included\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcludedFromRewards[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /*\r\n\r\n    ---------------\r\n    WALLET SETTINGS\r\n    ---------------\r\n\r\n    */\r\n\r\n    // Exclude From Fees\r\n    function wallet_Exclude_From_Fees(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {\r\n        _isExcludedFromFee[Wallet_Address] = true_or_false;\r\n\r\n    }\r\n\r\n    // Exclude From Transaction and Holding Limits\r\n    function wallet_Exempt_From_Limits(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {  \r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    // Grant Pre-Launch Access (Required for Airdrop contract during migration) \r\n    function wallet_Pre_Launch_Access( \r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {    \r\n        _isWhiteListed[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    /*\r\n\r\n    -----------------------------\r\n    BEP20 STANDARD AND COMPLIANCE\r\n    -----------------------------\r\n\r\n    */\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) { \r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcludedFromRewards[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n   \r\n    function tokenFromReflection(uint256 _rAmount) internal view returns(uint256) {\r\n        require(_rAmount <= _rTotal, \"rAmount can not be greater than rTotal\");\r\n        uint256 currentRate =  _getRate();\r\n        return _rAmount / currentRate;\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;      \r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n            rSupply = rSupply - _rOwned[_excluded[i]];\r\n            tSupply = tSupply - _tOwned[_excluded[i]];\r\n        }\r\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function send_BNB(address _to, uint256 _amount) internal returns (bool SendSuccess) {\r\n                                \r\n        (SendSuccess,) = payable(_to).call{value: _amount}(\"\");\r\n\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return (_tTotal - balanceOf(address(Wallet_Burn)));\r\n    }\r\n\r\n    /*\r\n\r\n    ---------------\r\n    TOKEN TRANSFERS\r\n    ---------------\r\n\r\n    */\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n      ) private {\r\n\r\n\r\n        require(balanceOf(from) >= amount, \"T1\"); // Sender does not have enough tokens!\r\n\r\n        if (!tradeOpen){\r\n            require(_isWhiteListed[from] || _isWhiteListed[to], \"T2\");\r\n        }\r\n\r\n        // Wallet Limit\r\n        if (!_isLimitExempt[to] && from != owner()) {\r\n\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= max_Hold, \"T3\"); // Over max wallet limit\r\n\r\n        }\r\n\r\n        // Transaction limit - To send over the transaction limit the sender AND the recipient must be limit exempt \r\n        if (!_isLimitExempt[to] || !_isLimitExempt[from]){\r\n            require(amount <= max_Hold, \"T4\"); // Over max transaction limit\r\n            \r\n        }\r\n\r\n        // Compliance and safety checks\r\n        require(from != address(0), \"T5\"); // Not a valid BSC wallet address\r\n        require(to != address(0), \"T6\"); // Not a valid BSC wallet address\r\n        require(amount > 0, \"T7\"); // Amount must be greater than 0\r\n\r\n\r\n        // Remove fee is fee exempt, or during wallet to wallet transfers\r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (freeWalletTransfers && !_isPair[to] && !_isPair[from])){\r\n            takeFee = false;\r\n        } else {\r\n            takeFee = true;\r\n        }\r\n\r\n        // Check if fee processing is possible\r\n        if( _isPair[to] && !processingFees && autoFeeProcessing) {\r\n\r\n            // Check that enough transactions have passed since last swap\r\n            if(swapCounter >= swapTrigger){\r\n\r\n                // Check number of tokens on contract\r\n                uint256 contractTokens = balanceOf(address(this));\r\n\r\n                // Only trigger fee processing if there are tokens to swap!\r\n                if (contractTokens > 0){\r\n\r\n                    // Remove fee on transaction that triggers fee processing\r\n                    if(noFeeWhenProcessing && takeFee) {takeFee = false;}\r\n\r\n                    // Limit number of tokens that can be swapped \r\n                    if (contractTokens <= max_Hold){\r\n                        processFees (contractTokens);   \r\n                        } else {\r\n                        processFees (max_Hold);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n    _tokenTransfer(from, to, amount, takeFee);\r\n\r\n    }\r\n\r\n    /*\r\n    \r\n    ------------\r\n    PROCESS FEES\r\n    ------------\r\n\r\n    */\r\n\r\n    function processFees(uint256 Tokens) private {\r\n\r\n        // Lock \r\n        processingFees = true;  \r\n\r\n        swapTokensForBNB(Tokens);\r\n        uint256 contract_BNB = address(this).balance;\r\n\r\n        if(contract_BNB > 0){\r\n            send_BNB(FeeCollector, contract_BNB);\r\n        }\r\n\r\n        // Reset transaction counter (reset to 1 not 0 to save gas)\r\n        swapCounter = 1;\r\n\r\n        // Unlock\r\n        processingFees = false;\r\n    }\r\n\r\n    // Swap tokens for BNB\r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /*\r\n    \r\n    ----------------------------------\r\n    TRANSFER TOKENS AND CALCULATE FEES\r\n    ----------------------------------\r\n\r\n    */\r\n\r\n    uint256 private rAmount;\r\n\r\n    uint256 private tReflect;\r\n    uint256 private rReflect;\r\n\r\n    uint256 private tSwapFeeTotal;\r\n    uint256 private rSwapFeeTotal;\r\n\r\n    uint256 private tTransferAmount;\r\n    uint256 private rTransferAmount;\r\n\r\n    \r\n\r\n    // Transfer Tokens and Calculate Fees\r\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool Fee) private {\r\n\r\n        \r\n        if (Fee){\r\n\r\n            if(_isPair[recipient]){\r\n\r\n                // Sell fees\r\n                tReflect        = tAmount * FeeSell_Reflect / 100;\r\n                tSwapFeeTotal   = tAmount * FeeSell_Project / 100;\r\n\r\n            } else {\r\n\r\n                // Buy fees\r\n                tReflect        = tAmount * FeeBuy_Reflect / 100;\r\n                tSwapFeeTotal   = tAmount * FeeBuy_Project / 100;\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n                // No fee\r\n                tReflect        = 0;\r\n                tSwapFeeTotal   = 0;\r\n\r\n        }\r\n\r\n        // Calculate reflected fees for RFI\r\n        uint256 RFI     = _getRate(); \r\n\r\n        rAmount         = tAmount       * RFI;\r\n        rReflect        = tReflect      * RFI;\r\n        rSwapFeeTotal   = tSwapFeeTotal * RFI;\r\n\r\n        tTransferAmount = tAmount - (tReflect + tSwapFeeTotal);\r\n        rTransferAmount = rAmount - (rReflect + rSwapFeeTotal);\r\n\r\n        // Transfer tokens\r\n        _rOwned[sender] -= rAmount;\r\n        _rOwned[recipient] += rTransferAmount;\r\n\r\n\r\n        if(_isExcludedFromRewards[sender]){\r\n            _tOwned[sender] -= tAmount;\r\n        }\r\n\r\n        if(_isExcludedFromRewards[recipient]){\r\n            _tOwned[recipient] += tTransferAmount;\r\n        }\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        // Take reflections\r\n        if(tReflect > 0){\r\n\r\n            _rTotal -= rReflect;\r\n            _tFeeTotal += tReflect;\r\n        }\r\n\r\n        // Take fees that require processing during swap and liquify\r\n        if(tSwapFeeTotal > 0){\r\n\r\n            _rOwned[address(this)] += rSwapFeeTotal;\r\n            if(_isExcludedFromRewards[address(this)]){_tOwned[address(this)] += tSwapFeeTotal;}\r\n            emit Transfer(sender, address(this), tSwapFeeTotal);\r\n\r\n            // Increase the transaction counter\r\n            unchecked{swapCounter++;}\r\n                \r\n        }\r\n\r\n    }   \r\n\r\n    // This function is required so that the contract can receive BNB during fee processing\r\n    receive() external payable {}\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"AutoFeeProcessing\",\"type\":\"bool\"}],\"name\":\"updated_AutoFeeProcesing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TotalBuyFee\",\"type\":\"uint256\"}],\"name\":\"updated_Buy_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TotalSellFee\",\"type\":\"uint256\"}],\"name\":\"updated_Sell_fees\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FeeBuy_Project\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FeeBuy_Reflect\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FeeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FeeSell_Project\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FeeSell_Reflect\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Project_Information\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"Owner_Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Max_Wallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Fee_When_Buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Fee_When_Selling\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Website\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Telegram\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Security_Audit\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Dox_Certificate\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Liquidity_Lock\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Burn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"add_Liquidity_Pair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoFeeProcessing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeWalletTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"free_Wallet_Transfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noFeeWhenProcessing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open_Trade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Confirmation_Code\",\"type\":\"uint256\"}],\"name\":\"ownership_RENOUNCE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Confirmation_Code\",\"type\":\"uint256\"}],\"name\":\"ownership_TRANSFER\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"process__Auto_Process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"process__Process_Now\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"process__RemoveFeeWhenProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number_of_Tokens\",\"type\":\"uint256\"}],\"name\":\"process__Rescue_Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"Transaction_Count\",\"type\":\"uint8\"}],\"name\":\"process__Swap_Trigger_Count\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewards_Exclude_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewards_Include_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"ProjectFee_BUY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Reflection_BUY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"ProjectFee_SELL\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Reflection_SELL\",\"type\":\"uint8\"}],\"name\":\"set_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"Fee_Collector\",\"type\":\"address\"}],\"name\":\"update_FeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Audit_URL\",\"type\":\"string\"}],\"name\":\"update_Link_Audit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Dox_URL\",\"type\":\"string\"}],\"name\":\"update_Link_Dox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"LP_Lock_URL\",\"type\":\"string\"}],\"name\":\"update_Link_Liquidity_Lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Telegram_URL\",\"type\":\"string\"}],\"name\":\"update_Link_Telegram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Website_URL\",\"type\":\"string\"}],\"name\":\"update_Link_Website\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"wallet_Exclude_From_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"wallet_Exempt_From_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"wallet_Pre_Launch_Access\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GEN", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://af5f5eb6754e6a367eefa3dcf525a5f1dc1ec27d53abb2e0256c2c91649753d9"}