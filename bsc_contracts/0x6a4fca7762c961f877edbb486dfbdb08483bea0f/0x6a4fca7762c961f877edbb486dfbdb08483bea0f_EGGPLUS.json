{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.7.4;\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != - 1 || a != MIN_INT256);\r\n\r\n        return a / b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? - a : a;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IPancakeSwapPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeSwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IPancakeSwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(_owner);\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n\r\ninterface EGGNFT {\r\n    function createNFT(\r\n        address _to,\r\n        uint256 _catId,\r\n        bytes memory _data\r\n    ) external returns (uint256 tokenId);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n}\r\n\r\ncontract Recv {\r\n    IERC20 public token;\r\n    IERC20 public usdt;\r\n\r\n    constructor (IERC20 _token, IERC20 _usdt) public {\r\n        token = _token;\r\n        usdt = _usdt;\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint256 usdtBalance = usdt.balanceOf(address(this));\r\n        if (usdtBalance > 0) {\r\n            usdt.transfer(address(token), usdtBalance);\r\n        }\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        if (tokenBalance > 0) {\r\n            token.transfer(address(token), tokenBalance);\r\n        }\r\n    }\r\n}\r\n\r\ncontract EGGPLUS is ERC20Detailed, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\r\n\r\n    string public _name = \"EGGPLUS\";\r\n    string public _symbol = \"EGGPLUS\";\r\n    uint8 public _decimals = 8;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    mapping(address => bool) _isFeeExempt;\r\n\r\n    modifier validRecipient(address to) {\r\n        require(to != address(0x0));\r\n        _;\r\n    }\r\n\r\n    uint256 public constant DECIMALS = 8;\r\n    uint256 public constant MAX_UINT256 = ~uint256(0);\r\n    uint8 public constant RATE_DECIMALS = 8;\r\n\r\n    struct UserInfo {\r\n        uint256 referTime;\r\n        address parent;\r\n        bool isShare;\r\n        uint256 referIdoNum;\r\n        bool shareRefund;\r\n        uint256 idoAmount;\r\n        bool idoRefund;\r\n        uint256 buyAmount;\r\n    }\r\n\r\n    address[] public shareHolder;\r\n\r\n    mapping(address => UserInfo) public userInfo;\r\n    mapping(address => address[]) public userInviters;\r\n\r\n\r\n    uint256 public liquidityFee = 50; //5%  only for buy\r\n    uint256 public inviteFee = 100;//10% //only for buy\r\n    uint256[] public REFERRAL_PERCENTS = [40, 20, 5, 5, 5, 5, 5, 5, 5, 5];\r\n\r\n    uint256 public treasuryFee = 50;//5% only for sell\r\n    uint256 public consensusFundFee = 25;//2.5% only for sell\r\n    uint256 public daoFee = 50;//5% dao fee.only for sell\r\n    uint256 public firePitFee = 25;//2.5% only for sell\r\n    uint256 public feeDenominator = 1000;\r\n\r\n    uint256 public totalInviteAmount = 0;\r\n    uint256 public totalDaoAmount = 0;\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    address public autoLiquidityReceiver;\r\n    address public freeDaoAddress;\r\n    address public treasuryReceiver;\r\n    address public safuuInsuranceFundReceiver;\r\n    address public idoAddress;\r\n\r\n    address public firePit = ZERO;\r\n\r\n    bool public swapEnabled = true;\r\n    IPancakeSwapRouter public router;\r\n    address public pair;\r\n\r\n    Recv public recv;\r\n\r\n    address public eggNFTAddress;\r\n\r\n    IERC20 public usdt;\r\n    bool inSwap = false;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    uint256 private TOTAL_GONS;\r\n    uint256 private constant MAX_SUPPLY = 3250000000 * 10 ** DECIMALS;\r\n\r\n    bool public _autoRebase;\r\n    bool public _autoSwapBack;\r\n    bool public _autoAddLiquidity;\r\n\r\n    uint256 public _lastRebasedTime;\r\n    uint256 public _lastAddLiquidityTime;\r\n    uint256 public _lastSwapBackTime;\r\n    uint256 public _totalSupply;\r\n    uint256 private _gonsPerFragment;\r\n    uint256 public pairBalance;\r\n    mapping(address => uint256) private _gonBalances;\r\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\r\n    mapping(address => bool) public blacklist;\r\n\r\n    uint256 public startTradingTime;\r\n    uint256 public autoLiquidityInterval = 60 minutes;\r\n    uint256 public swapBackInterval = 240 minutes;\r\n\r\n    uint256 public shareMx = 300 * 10 ** 18;\r\n    uint256 public idoMx = 100 * 10 ** 18;\r\n    uint256 public idoTotal = 0;\r\n    bool public idoPaused = true;\r\n    uint256 public startIdoTime;\r\n    uint256 public idoInterval = 1 weeks;\r\n\r\n    event parentInfo(\r\n        address indexed childAddress,\r\n        address indexed parentAddress\r\n    );\r\n\r\n    constructor(address _router, IERC20 _usdt, address _eggNFTAddress, address _idoAddress, address _autoLiquidityReceiver, address _treasuryReceiver, address _safuuInsuranceFundReceiver) ERC20Detailed(_name, _symbol, uint8(DECIMALS)) Ownable() {\r\n        usdt = _usdt;\r\n        eggNFTAddress = _eggNFTAddress;\r\n        idoAddress = _idoAddress;\r\n        treasuryReceiver = _treasuryReceiver;\r\n        safuuInsuranceFundReceiver = _safuuInsuranceFundReceiver;\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        router = IPancakeSwapRouter(_router);\r\n\r\n        pair = IPancakeSwapFactory(router.factory()).createPair(address(usdt), address(this));\r\n\r\n        _totalSupply = 3520000 * 10 ** DECIMALS;\r\n        TOTAL_GONS = MAX_UINT256 / 1e10 - (MAX_UINT256 / 1e10 % _totalSupply);\r\n        _gonBalances[msg.sender] = TOTAL_GONS;\r\n        emit Transfer(address(0x0), msg.sender, _totalSupply);\r\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\r\n\r\n        _allowedFragments[idoAddress][address(this)] = MAX;\r\n        _allowedFragments[address(this)][address(router)] = MAX;\r\n        usdt.approve(address(router), MAX);\r\n\r\n        recv = new Recv(IERC20(this), usdt);\r\n\r\n        _isFeeExempt[msg.sender] = true;\r\n        _isFeeExempt[address(this)] = true;\r\n        _isFeeExempt[idoAddress] = true;\r\n        _isFeeExempt[autoLiquidityReceiver] = true;\r\n        _isFeeExempt[treasuryReceiver] = true;\r\n        _isFeeExempt[safuuInsuranceFundReceiver] = true;\r\n        _isFeeExempt[firePit] = true;\r\n    }\r\n\r\n    function refundShare() public swapping {\r\n        require(!isContract(msg.sender), \"robot\");\r\n        require(startIdoTime != 0 && block.timestamp.sub(startIdoTime) > idoInterval, \"ido have not ended\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.isShare && !user.shareRefund, \"user have refunded\");\r\n        require(user.referIdoNum >= 10, \"referIdoNum not good\");\r\n        uint256 uAmount = shareMx;\r\n        user.shareRefund = true;\r\n        usdt.transfer(msg.sender, uAmount);\r\n        require(eggNFTAddress != address(0x0), \"eggNFTAddress is 0x00\");\r\n        EGGNFT(eggNFTAddress).createNFT(msg.sender, 1, new bytes(0));\r\n    }\r\n\r\n    function takeShare() public swapping {\r\n        require(!isContract(msg.sender), \"robot\");\r\n        require(startIdoTime == 0 || block.timestamp.sub(startIdoTime) <= idoInterval, \"ido have ended\");\r\n        if (userInfo[msg.sender].parent == address(0)) {\r\n            referParent(owner());\r\n        }\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(!user.isShare, \"user have joined the share\");\r\n        uint256 uAmount = shareMx;\r\n        usdt.transferFrom(msg.sender, address(this), uAmount);\r\n        user.isShare = true;\r\n        shareHolder.push(msg.sender);\r\n    }\r\n\r\n    function claimIdo() public swapping {\r\n        require(!isContract(msg.sender), \"robot\");\r\n        require(block.timestamp.sub(startIdoTime) > idoInterval, \"ido have not ended\");\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(!user.idoRefund, \"user have refunded\");\r\n        require(user.idoAmount > 0, \"user have not joined the ido\");\r\n\r\n        uint256 price = 50 * 10 ** DECIMALS;\r\n        uint256 getAmount = price.mul(user.idoAmount).div(100 * 10 ** 18);\r\n        user.idoRefund = true;\r\n        _basicTransfer(idoAddress, msg.sender, getAmount);\r\n    }\r\n\r\n    function ido(uint256 uAmount) public swapping {\r\n        require(!isContract(msg.sender), \"robot\");\r\n        require(!idoPaused, \"ido have paused\");\r\n        require(block.timestamp.sub(startIdoTime) <= idoInterval, \"ido not start or have ended\");\r\n        uint256 uTotal = idoMx;\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        if (user.isShare) {\r\n            uTotal = 2 * uTotal;\r\n        }\r\n        require(uAmount % idoMx == 0 && uAmount >= idoMx, \"uAmount error\");\r\n        require(user.idoAmount <= uTotal.sub(uAmount), \"ido too big\");\r\n        usdt.transferFrom(msg.sender, idoAddress, uAmount);\r\n        if (user.idoAmount == 0 && user.parent != address(0x0)) {\r\n            UserInfo storage parent = userInfo[user.parent];\r\n            parent.referIdoNum = parent.referIdoNum + 1;\r\n        }\r\n        user.idoAmount = user.idoAmount.add(uAmount);\r\n        idoTotal = idoTotal.add(uAmount);\r\n        require(idoTotal <= 2000000 * 10 ** 18, \"ido have overflowed\");\r\n    }\r\n\r\n    function setIdo(uint256 _time, uint256 _time2, bool _idoPaused) public onlyOwner {\r\n        idoPaused = _idoPaused;\r\n        if (_time > 0) {\r\n            startIdoTime = _time;\r\n        } else {\r\n            startIdoTime = block.timestamp;\r\n        }\r\n        if (_time2 > 0) {\r\n            idoInterval = _time2;\r\n        }\r\n    }\r\n\r\n    function setEggNFTAddress(address _eggNFTAddress) public onlyOwner {\r\n        eggNFTAddress = _eggNFTAddress;\r\n    }\r\n\r\n    function referParent(address parentAddress) public {\r\n        require(\r\n            parentAddress != msg.sender,\r\n            \"Error: parent address can not equal sender!\"\r\n        );\r\n        require(\r\n            userInfo[msg.sender].parent == address(0),\r\n            \"Error: sender must be has no parent!\"\r\n        );\r\n        require(\r\n            parentAddress == owner() || userInfo[parentAddress].parent != address(0),\r\n            \"Error: parentAddress must be has parent!\"\r\n        );\r\n        require(\r\n            !isContract(parentAddress),\r\n            \"Error: parent address must be a address!\"\r\n        );\r\n        userInfo[msg.sender].parent = parentAddress;\r\n        userInfo[msg.sender].referTime = block.timestamp;\r\n        userInviters[parentAddress].push(msg.sender);\r\n        emit parentInfo(msg.sender, parentAddress);\r\n    }\r\n\r\n    function manualRebase() external {\r\n        require(shouldRebase(), \"rebase not required\");\r\n        rebase();\r\n    }\r\n\r\n    function rebase() internal {\r\n\r\n        if (inSwap) return;\r\n        uint256 rebaseRate = 21447;\r\n        uint256 deltaTime = block.timestamp - _lastRebasedTime;\r\n        uint256 times = deltaTime.div(15 minutes);\r\n        uint256 epoch = times.mul(15);\r\n\r\n\r\n        for (uint256 i = 0; i < times; i++) {\r\n            _totalSupply = _totalSupply\r\n            .mul((10 ** RATE_DECIMALS).add(rebaseRate))\r\n            .div(10 ** RATE_DECIMALS);\r\n        }\r\n\r\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\r\n        _lastRebasedTime = _lastRebasedTime.add(times.mul(15 minutes));\r\n\r\n        emit LogRebase(epoch, _totalSupply);\r\n    }\r\n\r\n    function setStartTradingTime(uint256 _time) public onlyOwner {\r\n        startTradingTime = _time;\r\n        if (_time > 0) {\r\n            _lastAddLiquidityTime = _time;\r\n            if (_lastRebasedTime == 0) {\r\n                _lastRebasedTime = _time;\r\n            }\r\n        }\r\n    }\r\n\r\n    function transfer(address to, uint256 value)\r\n    external\r\n    override\r\n    validRecipient(to)\r\n    returns (bool)\r\n    {\r\n        _transferFrom(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external override validRecipient(to) returns (bool) {\r\n\r\n        if (_allowedFragments[from][msg.sender] != uint256(- 1)) {\r\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][\r\n            msg.sender\r\n            ].sub(value, \"Insufficient Allowance\");\r\n        }\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\r\n        if (from == pair) {\r\n            pairBalance = pairBalance.sub(amount);\r\n        } else {\r\n            _gonBalances[from] = _gonBalances[from].sub(gonAmount);\r\n        }\r\n        if (to == pair) {\r\n            pairBalance = pairBalance.add(amount);\r\n        } else {\r\n            _gonBalances[to] = _gonBalances[to].add(gonAmount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n\r\n        require(!blacklist[sender], \"in_blacklist\");\r\n        if (inSwap || !shouldTakeFee(sender, recipient)) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n        if (shouldRebase()) {\r\n            rebase();\r\n        }\r\n\r\n        if (shouldAddLiquidity()) {\r\n            addLiquidity();\r\n        }\r\n\r\n        if (shouldSwapBack()) {\r\n            swapBack();\r\n        }\r\n\r\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\r\n        if (recipient == pair && _isFeeExempt[sender] == false && _isFeeExempt[recipient] == false) {\r\n            //only can sell 99% of balance\r\n            if (gonAmount >= _gonBalances[sender].div(1000).mul(999)) {\r\n                gonAmount = _gonBalances[sender].div(1000).mul(999);\r\n            }\r\n        }\r\n        if (sender == pair) {\r\n            pairBalance = pairBalance.sub(amount);\r\n            if (userInfo[recipient].parent != address(0x0)) {\r\n                userInfo[recipient].buyAmount = userInfo[recipient].buyAmount.add(amount);\r\n            }\r\n        } else {\r\n            _gonBalances[sender] = _gonBalances[sender].sub(gonAmount);\r\n        }\r\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient)\r\n        ? takeFee(sender, recipient, gonAmount)\r\n        : gonAmount;\r\n\r\n        if (recipient == pair) {\r\n            pairBalance = pairBalance.add(gonAmountReceived.div(_gonsPerFragment));\r\n        } else {\r\n            _gonBalances[recipient] = _gonBalances[recipient].add(gonAmountReceived);\r\n        }\r\n        emit Transfer(\r\n            sender,\r\n            recipient,\r\n            gonAmountReceived.div(_gonsPerFragment)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function takeFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 gonAmount\r\n    ) internal returns (uint256) {\r\n        uint256 _totalFee = 0;\r\n        uint256 _robotsFee = 550;\r\n        //sell token or transfer token\r\n        if (sender != pair) {\r\n            _totalFee = firePitFee.add(treasuryFee).add(daoFee).add(consensusFundFee);\r\n            //when sell token .\r\n            uint256 fee = gonAmount.div(feeDenominator).mul(firePitFee);\r\n            _gonBalances[firePit] = _gonBalances[firePit].add(fee);\r\n            emit Transfer(sender, firePit, fee.div(_gonsPerFragment));\r\n\r\n            fee = gonAmount.div(feeDenominator).mul(treasuryFee.add(consensusFundFee));\r\n            _gonBalances[address(this)] = _gonBalances[address(this)].add(fee);\r\n            emit Transfer(sender, address(this), fee.div(_gonsPerFragment));\r\n\r\n            fee = gonAmount.div(feeDenominator).mul(daoFee);\r\n            _gonBalances[freeDaoAddress] = _gonBalances[freeDaoAddress].add(fee);\r\n            emit Transfer(sender, freeDaoAddress, fee.div(_gonsPerFragment));\r\n            totalDaoAmount = totalDaoAmount.add(fee.div(_gonsPerFragment));\r\n\r\n        }\r\n        if (sender == pair) {//when buy token\r\n            _totalFee = inviteFee.add(liquidityFee);\r\n            uint256 fee = gonAmount.div(feeDenominator).mul(liquidityFee);\r\n            _gonBalances[autoLiquidityReceiver] = _gonBalances[autoLiquidityReceiver].add(fee);\r\n            emit Transfer(sender, autoLiquidityReceiver, fee.div(_gonsPerFragment));\r\n\r\n            _takeInviterFee(sender, recipient, gonAmount);\r\n            totalInviteAmount = totalInviteAmount.add(gonAmount.div(_gonsPerFragment).mul(inviteFee).div(feeDenominator));\r\n\r\n        }\r\n        if (recipient == pair || sender == pair) {\r\n            //sell token\r\n            require(startTradingTime > 0 && block.timestamp >= startTradingTime, \"can not trade now!\");\r\n            if (block.timestamp <= startTradingTime + 6) {\r\n                _totalFee = _totalFee.add(_robotsFee);\r\n                _gonBalances[autoLiquidityReceiver] = _gonBalances[autoLiquidityReceiver].add(gonAmount.div(feeDenominator).mul(_robotsFee));\r\n                emit Transfer(sender, autoLiquidityReceiver, gonAmount.div(feeDenominator).mul(_robotsFee).div(_gonsPerFragment));\r\n            }\r\n        }\r\n        uint256 feeAmount = gonAmount.div(feeDenominator).mul(_totalFee);\r\n        return gonAmount.sub(feeAmount);\r\n    }\r\n\r\n    function _takeInviterFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private returns (uint256) {\r\n        uint256 tFee = amount.div(feeDenominator).mul(inviteFee);\r\n        address cur;\r\n        if (sender == pair) {\r\n            cur = recipient;\r\n        } else {\r\n            cur = sender;\r\n        }\r\n        uint256 accurAmount = 0;\r\n        for (uint256 i = 0; i < REFERRAL_PERCENTS.length; i++) {\r\n            cur = userInfo[cur].parent;\r\n            if (cur == address(0)) {\r\n                break;\r\n            }\r\n            uint256 curTAmount = amount.div(feeDenominator).mul(REFERRAL_PERCENTS[i]);\r\n            accurAmount = accurAmount.add(curTAmount);\r\n            _gonBalances[cur] = _gonBalances[cur].add(curTAmount);\r\n            emit Transfer(sender, cur, curTAmount.div(_gonsPerFragment));\r\n        }\r\n        if (tFee.sub(accurAmount) > 0) {\r\n            _gonBalances[address(this)] = _gonBalances[address(this)].add(tFee.sub(accurAmount));\r\n            emit Transfer(sender, address(this), tFee.sub(accurAmount).div(_gonsPerFragment));\r\n        }\r\n        return tFee;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 amountToSwap = _gonBalances[address(this)].div(_gonsPerFragment);\r\n        if (amountToSwap == 0) {\r\n            return;\r\n        }\r\n        uint256 initialUsdt = usdt.balanceOf(address(this));\r\n        swapTokensForUSDT(amountToSwap);\r\n        uint256 afterUsdt = usdt.balanceOf(address(this));\r\n        uint256 addUsdt = afterUsdt.sub(initialUsdt);\r\n        usdt.transfer(treasuryReceiver, addUsdt.mul(treasuryFee).div(treasuryFee + consensusFundFee));\r\n        usdt.transfer(safuuInsuranceFundReceiver, addUsdt.mul(consensusFundFee).div(treasuryFee + consensusFundFee));\r\n\r\n        _lastSwapBackTime = block.timestamp;\r\n    }\r\n\r\n\r\n    function shouldTakeFee(address from, address to)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        return\r\n        // (pair == from || pair == to) &&\r\n        !_isFeeExempt[from] && !_isFeeExempt[to];\r\n    }\r\n\r\n    function shouldRebase() internal view returns (bool) {\r\n        return\r\n        _autoRebase &&\r\n        (_totalSupply < MAX_SUPPLY) &&\r\n        msg.sender != pair &&\r\n        !inSwap &&\r\n        block.timestamp >= (_lastRebasedTime + 15 minutes);\r\n    }\r\n\r\n    function shouldAddLiquidity() internal view returns (bool) {\r\n        return\r\n        _autoAddLiquidity &&\r\n        !inSwap &&\r\n        msg.sender != pair &&\r\n        _lastAddLiquidityTime > 0 &&\r\n        block.timestamp >= (_lastAddLiquidityTime + autoLiquidityInterval);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return\r\n        _autoSwapBack && !inSwap &&\r\n        msg.sender != pair &&\r\n        _lastSwapBackTime > 0 &&\r\n        block.timestamp >= (_lastSwapBackTime + swapBackInterval);\r\n    }\r\n\r\n    function setAutoRebase(bool _flag) external onlyOwner {\r\n        if (_flag) {\r\n            _autoRebase = _flag;\r\n            _lastRebasedTime = block.timestamp;\r\n        } else {\r\n            _autoRebase = _flag;\r\n        }\r\n    }\r\n\r\n    function setAutoSwapBack(bool _flag) external onlyOwner {\r\n        if (_flag) {\r\n            _autoSwapBack = _flag;\r\n            _lastSwapBackTime = block.timestamp;\r\n        } else {\r\n            _autoSwapBack = _flag;\r\n        }\r\n    }\r\n\r\n    function setAutoLiquidityInterval(uint256 _minutes) external onlyOwner {\r\n        require(_minutes > 0, \"invalid time\");\r\n        autoLiquidityInterval = _minutes * 1 minutes;\r\n    }\r\n\r\n    function setSwapBackInterval(uint256 _minutes) external onlyOwner {\r\n        require(_minutes > 0, \"invalid time\");\r\n        swapBackInterval = _minutes * 1 minutes;\r\n    }\r\n\r\n    function setAutoAddLiquidity(bool _flag) external onlyOwner {\r\n        if (_flag) {\r\n            _autoAddLiquidity = _flag;\r\n            _lastAddLiquidityTime = block.timestamp;\r\n        } else {\r\n            _autoAddLiquidity = _flag;\r\n        }\r\n    }\r\n\r\n    function setFeeReceivers(\r\n        address _idoAddress,\r\n        address _autoLiquidityReceiver,\r\n        address _treasuryReceiver,\r\n        address _safuuInsuranceFundReceiver,\r\n        address _freeDaoAddress,\r\n        address _firePit\r\n    ) external onlyOwner {\r\n        idoAddress = _idoAddress;\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        treasuryReceiver = _treasuryReceiver;\r\n        safuuInsuranceFundReceiver = _safuuInsuranceFundReceiver;\r\n        freeDaoAddress = _freeDaoAddress;\r\n        firePit = _firePit;\r\n\r\n        _isFeeExempt[idoAddress] = true;\r\n        _isFeeExempt[autoLiquidityReceiver] = true;\r\n        _isFeeExempt[treasuryReceiver] = true;\r\n        _isFeeExempt[safuuInsuranceFundReceiver] = true;\r\n        _isFeeExempt[freeDaoAddress] = true;\r\n        _isFeeExempt[firePit] = true;\r\n    }\r\n\r\n    function rescueToken(\r\n        address token,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        IERC20(token).transfer(recipient, amount);\r\n    }\r\n\r\n    function allowance(address owner_, address spender)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n    {\r\n        return _allowedFragments[owner_][spender];\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    external\r\n    returns (bool)\r\n    {\r\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\r\n        if (subtractedValue >= oldValue) {\r\n            _allowedFragments[msg.sender][spender] = 0;\r\n        } else {\r\n            _allowedFragments[msg.sender][spender] = oldValue.sub(\r\n                subtractedValue\r\n            );\r\n        }\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n    external\r\n    returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][\r\n        spender\r\n        ].add(addedValue);\r\n        emit Approval(\r\n            msg.sender,\r\n            spender,\r\n            _allowedFragments[msg.sender][spender]\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value)\r\n    external\r\n    override\r\n    returns (bool)\r\n    {\r\n        _allowedFragments[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function checkFeeExempt(address _addr) external view returns (bool) {\r\n        return _isFeeExempt[_addr];\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return\r\n        (TOTAL_GONS.sub(_gonBalances[DEAD]).sub(_gonBalances[ZERO])).div(\r\n            _gonsPerFragment\r\n        );\r\n    }\r\n\r\n    function isNotInSwap() external view returns (bool) {\r\n        return !inSwap;\r\n    }\r\n\r\n    function manualSync() external {\r\n        IPancakeSwapPair(pair).sync();\r\n    }\r\n\r\n    function setWhitelist(address[] memory _addrs) external onlyOwner {\r\n        for (uint256 i = 0; i < _addrs.length; i++) {\r\n            _isFeeExempt[_addrs[i]] = true;\r\n        }\r\n\r\n    }\r\n\r\n    function setBlacklist(address _address, bool _flag) external onlyOwner {\r\n        blacklist[_address] = _flag;\r\n    }\r\n\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address who) public view override returns (uint256) {\r\n        if (who == pair) {\r\n            return pairBalance;\r\n        } else {\r\n            return _gonBalances[who].div(_gonsPerFragment);\r\n        }\r\n    }\r\n\r\n    function addLiquidity() internal swapping {\r\n        uint256 autoLiquidityAmount = _gonBalances[autoLiquidityReceiver].div(\r\n            _gonsPerFragment\r\n        );\r\n        if (treasuryReceiver != address(0) && autoLiquidityAmount > 0) {\r\n            _gonBalances[address(this)] = _gonBalances[address(this)].add(\r\n                _gonBalances[autoLiquidityReceiver]\r\n            );\r\n            _gonBalances[autoLiquidityReceiver] = 0;\r\n            emit Transfer(autoLiquidityReceiver, address(this), autoLiquidityAmount);\r\n\r\n            swapAndLiquify(autoLiquidityAmount);\r\n            _lastAddLiquidityTime = block.timestamp;\r\n        }\r\n\r\n    }\r\n\r\n    function swapAndLiquify(uint256 contractTokenBalance) private {\r\n        uint256 half = contractTokenBalance.div(2);\r\n        uint256 otherHalf = contractTokenBalance.sub(half, \"sub half\");\r\n\r\n        uint256 initialUsdt = usdt.balanceOf(address(this));\r\n        swapTokensForUSDT(half);\r\n        uint256 afterUsdt = usdt.balanceOf(address(this));\r\n        uint256 addUsdt = afterUsdt.sub(initialUsdt);\r\n\r\n        addLiquidityUSDT(otherHalf, addUsdt);\r\n    }\r\n\r\n    function swapTokensForUSDT(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = address(usdt);\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(recv),\r\n            block.timestamp\r\n        );\r\n        recv.withdraw();\r\n    }\r\n\r\n    function addLiquidityUSDT(uint256 tokenAmount, uint256 uAmount) private {\r\n        // approve token transfer to cover all possible scenarios\r\n        router.addLiquidity(\r\n            address(this),\r\n            address(usdt),\r\n            tokenAmount,\r\n            uAmount,\r\n            0,\r\n            0,\r\n            autoLiquidityReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function getEGGToUSD() public view returns (uint256){\r\n        if (pairBalance == 0) {\r\n            return 0;\r\n        }\r\n        return usdt.balanceOf(pair).mul(10 ** decimals()).div(pairBalance);\r\n    }\r\n\r\n\r\n    function getSysInfo() public view returns (uint256[18] memory){\r\n        uint256 price = getEGGToUSD();\r\n        uint256 fireBalance = _gonBalances[DEAD].add(_gonBalances[ZERO]).div(_gonsPerFragment);\r\n        uint256[18] memory d = [\r\n        price, _totalSupply, getCirculatingSupply(), pairBalance, fireBalance, _lastRebasedTime,\r\n        shareMx, shareHolder.length, idoMx, idoTotal, startIdoTime, idoInterval, startTradingTime,\r\n        totalDaoAmount, totalInviteAmount,\r\n        balanceOf(treasuryReceiver), balanceOf(safuuInsuranceFundReceiver), balanceOf(freeDaoAddress)\r\n        ];\r\n        return (d);\r\n    }\r\n\r\n    function getUserInfo(address account) public view returns (address, bool, bool, bool, uint256[7] memory){\r\n        UserInfo storage user = userInfo[account];\r\n        address[] storage inviters = userInviters[account];\r\n        uint256 totalTeam = 0;\r\n        for (uint256 i = 0; i < inviters.length; i++) {\r\n            totalTeam = totalTeam.add(userInfo[inviters[i]].buyAmount);\r\n        }\r\n        uint256 nftAmount = 0;\r\n        if (eggNFTAddress != address(0x0)) {\r\n            nftAmount = EGGNFT(eggNFTAddress).balanceOf(account);\r\n        }\r\n        uint256[7] memory d = [user.referTime, user.referIdoNum, user.idoAmount, user.buyAmount, inviters.length, totalTeam, nftAmount];\r\n        return (user.parent, user.isShare, user.shareRefund, user.idoRefund, d);\r\n    }\r\n\r\n    function getReferSize(address account) public view returns (uint256){\r\n        return userInviters[account].length;\r\n    }\r\n\r\n    function getReferList(address account) public view returns (uint256[] memory, address[] memory, uint256[] memory, uint256[] memory){\r\n        address[] storage inviters = userInviters[account];\r\n        uint256[] memory referTimes = new uint256[](inviters.length);\r\n        address[] memory users = new address[](inviters.length);\r\n        uint256[] memory buyAmounts = new uint256[](inviters.length);\r\n        uint256[] memory idoAmounts = new uint256[](inviters.length);\r\n        for (uint256 i = 0; i < inviters.length; i++) {\r\n            referTimes[i] = userInfo[inviters[i]].referTime;\r\n            users[i] = inviters[i];\r\n            buyAmounts[i] = userInfo[inviters[i]].buyAmount;\r\n            idoAmounts[i] = userInfo[inviters[i]].idoAmount;\r\n        }\r\n        return (referTimes, users, buyAmounts, idoAmounts);\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly {size := extcodesize(addr)}\r\n        return size > 0;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eggNFTAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_idoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safuuInsuranceFundReceiver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"}],\"name\":\"parentInfo\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_UINT256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoSwapBack\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAddLiquidityTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRebasedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastSwapBackTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimIdo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consensusFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eggNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firePit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firePitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeDaoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEGGToUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReferList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReferSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSysInfo\",\"outputs\":[{\"internalType\":\"uint256[18]\",\"name\":\"\",\"type\":\"uint256[18]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256[7]\",\"name\":\"\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"uAmount\",\"type\":\"uint256\"}],\"name\":\"ido\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoMx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"idoTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inviteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNotInSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recv\",\"outputs\":[{\"internalType\":\"contract Recv\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"}],\"name\":\"referParent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safuuInsuranceFundReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoAddLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minutes\",\"type\":\"uint256\"}],\"name\":\"setAutoLiquidityInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_eggNFTAddress\",\"type\":\"address\"}],\"name\":\"setEggNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_idoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safuuInsuranceFundReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_freeDaoAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_firePit\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time2\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_idoPaused\",\"type\":\"bool\"}],\"name\":\"setIdo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setStartTradingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minutes\",\"type\":\"uint256\"}],\"name\":\"setSwapBackInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addrs\",\"type\":\"address[]\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shareMx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startIdoTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBackInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDaoAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInviteAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parent\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isShare\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"referIdoNum\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"shareRefund\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"idoAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"idoRefund\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInviters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EGGPLUS", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000d46a2bf1bbec46818010cc6e4a9279192502ef910000000000000000000000002f6925cacc8810586b6b6ce07f0b552fd14e88c7000000000000000000000000cc9368097609100a72b48883499d9a9a884596c6000000000000000000000000f8630b74d243adac4a9fcc18f68862f08bac89250000000000000000000000006652fef324ccc5a3b8b2eeab600fd69cd8deb60b", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a1f06dc2f5abd9d2e331d6370cf71be5fdafeb74bc7e6fcab4632128ab88ad0a"}