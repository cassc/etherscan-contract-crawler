{"SourceCode": "// KingMaker Beta 2\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.13;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n \r\nabstract contract Ownable{\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastValue = set._values[lastIndex];\r\n                set._values[toDeleteIndex] = lastValue;\r\n                set._indexes[lastValue] = valueIndex;\r\n            }\r\n\r\n            set._values.pop();\r\n\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\ncontract KingMaker is Ownable {\r\n    \r\n    IERC20 public immutable knightToken = IERC20(address(0x16C0e0936E1B38Ff1F9b8a1e75d8ba29aDf87d30));\r\n    IERC20 public immutable nftBoost = IERC20(address(0xf812C8D2433B110d9bec52c3425fA90f1bD76d47));\r\n    IERC20 public immutable knightBnbLPToken = IERC20(address(0x8e53470B95d52A3D83637BF9E42891b17E785Ba4));\r\n\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    EnumerableSet.AddressSet private playerList;\r\n\r\n    mapping (address => uint256) private peasants;\r\n    mapping (address => uint256) private farmers;\r\n    mapping (address => uint256) private knights;\r\n    mapping (address => uint256) private nobles;\r\n    mapping (address => uint256) private kings;\r\n    \r\n    mapping (address => uint256) public startTime;\r\n    mapping (address => uint256) public lastUpdateTime;\r\n    mapping (address => uint256) public highScore;\r\n    \r\n    uint256 public farmerCost = 100;\r\n    uint256 public knightCost = 10000;\r\n    uint256 public nobleCost = 1000000;\r\n    uint256 public kingCost = 100000000;\r\n    uint256 private fakeMultiplier =  2000 * 1e18;\r\n\r\n    bool public isTest;\r\n    \r\n    bool internal updating;\r\n    \r\n    mapping (uint256 => address) private leaderboard;\r\n\r\n    constructor (bool _isTest) {\r\n        isTest = _isTest;\r\n    }\r\n    \r\n    function getHolderKnightBalance(address holder) public view returns (uint256){\r\n        return knightToken.balanceOf(holder);\r\n    }\r\n    \r\n    function getHolderNFTBalance(address holder) public view returns (uint256){\r\n        return nftBoost.balanceOf(holder);\r\n    }\r\n    \r\n    function getHolderKnightLPBalance(address holder) public view returns (uint256){\r\n        return knightBnbLPToken.balanceOf(holder);\r\n    }\r\n    \r\n    function getMultiplier(address holder) public view returns (uint256){\r\n        if(isTest){\r\n            return fakeMultiplier;\r\n        }\r\n        uint256 holderBalance = getHolderKnightBalance(holder);\r\n        uint256 holderNFTBalance = getHolderNFTBalance(holder);\r\n        uint256 holderLPBalance = getHolderKnightLPBalance(holder);\r\n        uint256 multiplier = (holderBalance / 100000)+1e18; // multiplier is +1x for every 100000 KNIGHT held.\r\n        multiplier = multiplier + ((holderNFTBalance * 1e18 / 5)); // multiplier is +1x for every 5 NFTs held.\r\n        multiplier = multiplier + ((holderLPBalance/ 50)); // multiplier is +1x for every 50 Knight-BNB LPs held.\r\n        if(multiplier > 2000 * 1e18){\r\n            return 2000 * 1e18;\r\n        }\r\n        return multiplier;\r\n    }\r\n    \r\n    function getMultiplierFromLP(address holder) public view returns (uint256){\r\n        uint256 holderLPBalance = getHolderNFTBalance(holder);\r\n        return (holderLPBalance / 50); // multiplier is +1x for every 50 Knight-BNB LPs held.\r\n    }\r\n    \r\n    function getMultiplierFromNFT(address holder) public view returns (uint256){\r\n        uint256 holderNFTBalance = getHolderNFTBalance(holder);\r\n        return ((holderNFTBalance * 1e18 / 5)); // multiplier is +1x for every 5 NFTs held.\r\n    }\r\n    \r\n    function getMultiplierFromKnight(address holder) public view returns (uint256){\r\n        uint256 holderBalance = getHolderKnightBalance(holder);\r\n        return (holderBalance / 100000)+1e18; // multiplier is +1x for every 100000 KNIGHT held.\r\n    }\r\n    \r\n    function getLastUpdateTime(address holder) public view returns (uint256){\r\n        return lastUpdateTime[holder];\r\n    }\r\n    \r\n    function getScore(address holder) public view returns (uint256){\r\n        return (getPeasants(holder) + (getFarmers(holder) * farmerCost * 2) + (getKnights(holder) * farmerCost * knightCost * 3) + (getNobles(holder) * farmerCost * knightCost * nobleCost * 4) + (getKings(holder) * farmerCost * knightCost * nobleCost * kingCost * 5));\r\n    }\r\n    \r\n    function startGame() public returns (bool){\r\n        require(startTime[msg.sender] == 0, \"May not restart game with this wallet\");\r\n        if(!isTest){\r\n            require(getHolderKnightBalance(msg.sender) >= 1000 * 1e18, \"Must hold at least 1000 KNIGHT to play\");\r\n        }\r\n        playerList.add(msg.sender);\r\n        startTime[msg.sender] = block.timestamp;\r\n        lastUpdateTime[msg.sender] = block.timestamp;\r\n        \r\n        return true;\r\n    }\r\n\r\n    function getTimePassed(address holder) public view returns (uint256){\r\n        return getLastUpdateTime(holder) <= block.timestamp ? block.timestamp - getLastUpdateTime(holder) : 0;\r\n    }\r\n    \r\n    function getPeasants(address holder) public view returns (uint256){\r\n        if(startTime[holder] == 0){return 0;}\r\n        uint256 amountFromTime = getTimePassed(holder);\r\n        return peasants[holder] + (((amountFromTime)*getMultiplier(holder))/1e18) + (getFarmers(holder)*amountFromTime);\r\n    }\r\n    \r\n    function getFarmers(address holder) public view returns (uint256){\r\n        if(startTime[holder] == 0){return 0;}\r\n        uint256 amountFromTime = getTimePassed(holder);\r\n        return farmers[holder] + (knights[holder]*amountFromTime*getMultiplier(holder))/1e18/10;\r\n    }\r\n    \r\n    function getKnights(address holder) public view returns (uint256){\r\n        if(startTime[holder] == 0){return 0;}\r\n        uint256 amountFromTime = getTimePassed(holder);\r\n        return knights[holder] + (nobles[holder]*amountFromTime*getMultiplier(holder))/1e18/100;\r\n    }\r\n    \r\n    function getNobles(address holder) public view returns (uint256){\r\n        if(startTime[holder] == 0){return 0;}\r\n        uint256 amountFromTime = getTimePassed(holder);\r\n        return nobles[holder] + (kings[holder]*amountFromTime*getMultiplier(holder))/1e18/1000;\r\n    }\r\n    \r\n    function getKings(address holder) public view returns (uint256){\r\n        if(startTime[holder] == 0){return 0;}\r\n        return kings[holder];\r\n    }\r\n    \r\n    function buyFarmers(uint256 number) public {\r\n        require(number * farmerCost <= getPeasants(msg.sender), \"Not enough peasants to buy this many farmers\");\r\n        if(number == 0){return;}\r\n        updateUnits(msg.sender);\r\n        peasants[msg.sender] -= number * farmerCost;\r\n        farmers[msg.sender] += number;\r\n        updateScore(msg.sender);\r\n    }\r\n    \r\n    function buyMaxFarmers() public {\r\n        buyFarmers(getPeasants(msg.sender) / farmerCost);\r\n    }\r\n    \r\n    function buyKnights(uint256 number) public {\r\n        require(number * knightCost <= getFarmers(msg.sender), \"Not enough farmers to buy this many knights\");\r\n        if(number == 0){return;}\r\n        updateUnits(msg.sender);\r\n        farmers[msg.sender] -= number * knightCost;\r\n        knights[msg.sender] += number;\r\n        updateScore(msg.sender);\r\n    }\r\n    \r\n    function buyMaxKnights() public {\r\n        buyKnights(getFarmers(msg.sender) / knightCost);\r\n    }\r\n    \r\n    function buyNobles(uint256 number) public {\r\n        require(number * nobleCost <= getKnights(msg.sender), \"Not enough knights to buy this many nobles\");\r\n        if(number == 0){return;}\r\n        updateUnits(msg.sender);\r\n        knights[msg.sender] -= number * nobleCost;\r\n        nobles[msg.sender] += number;\r\n        updateScore(msg.sender);\r\n    }\r\n    \r\n    function buyMaxNobles() public {\r\n        buyNobles(getKnights(msg.sender) / nobleCost);\r\n    }\r\n    \r\n    function buyKings(uint256 number) public {\r\n        require(number * kingCost <= getNobles(msg.sender), \"Not enough nobles to buy this many kings\");\r\n        if(number == 0){return;}\r\n        updateUnits(msg.sender);\r\n        nobles[msg.sender] -= number * kingCost;\r\n        kings[msg.sender] += number;\r\n        updateScore(msg.sender);\r\n    }\r\n    \r\n    function buyMaxKings() public {\r\n        buyKings(getNobles(msg.sender) / kingCost);\r\n    }\r\n    \r\n    function getAllScores() public view returns (address[] memory, uint256[] memory){\r\n\r\n        address[] memory listOfPlayers = getAllPlayers();\r\n        uint256[] memory scores = new uint256[](listOfPlayers.length);\r\n\r\n        for(uint256 i = 0; i < listOfPlayers.length; i++){\r\n            scores[i] = highScore[listOfPlayers[i]];\r\n        }\r\n\r\n        return (listOfPlayers, scores);\r\n    }\r\n\r\n    function getAccountRank(address wallet) public view returns (uint256, uint256){\r\n        uint256 walletHighScore = highScore[wallet];\r\n        uint256 walletRank = 1;\r\n        uint256 ties = 0;\r\n        (, uint256[] memory scores) = getAllScores();\r\n        for(uint256 i = 0; i < scores.length; i++){\r\n            if(scores[i] > walletHighScore){\r\n                walletRank += 1;\r\n            }\r\n            if(scores[i] == walletHighScore){\r\n                ties += 1;\r\n            }\r\n        }\r\n        return (walletRank, ties);\r\n    }\r\n\r\n    function returnTop3Scores() external view returns (address[] memory, uint256[] memory){\r\n        address[] memory top3Wallets = new address[](3);\r\n        uint256[] memory scores = new uint256[](3);\r\n\r\n        address[] memory listOfPlayers = getAllPlayers();\r\n\r\n        for(uint256 i = 0; i < listOfPlayers.length; i++){\r\n            (uint256 accountRank,) = getAccountRank(listOfPlayers[i]);\r\n            if(accountRank == 1){\r\n                top3Wallets[0] = listOfPlayers[i];\r\n                scores[0] = highScore[listOfPlayers[i]];\r\n            } else if(accountRank == 2) {\r\n                top3Wallets[1] = listOfPlayers[i];\r\n                scores[1] = highScore[listOfPlayers[i]];\r\n            } else if(accountRank == 3) {\r\n                top3Wallets[2] = listOfPlayers[i];\r\n                scores[2] = highScore[listOfPlayers[i]];\r\n            }\r\n        }\r\n        return (top3Wallets, scores);\r\n    }\r\n\r\n    function returnFullyOrderedLeaderboard() external view returns (address[] memory, uint256[] memory){\r\n\r\n\r\n        address[] memory listOfPlayers = getAllPlayers();\r\n        address[] memory wallets = new address[](listOfPlayers.length);\r\n        uint256[] memory scores = new uint256[](listOfPlayers.length);\r\n        uint256 accountRank;\r\n\r\n        for(uint256 i = 0; i < listOfPlayers.length; i++){\r\n            (accountRank,) = getAccountRank(listOfPlayers[i]);\r\n            wallets[accountRank-1] = listOfPlayers[i];\r\n            scores[accountRank-1] = highScore[listOfPlayers[i]];\r\n        }\r\n        return (wallets, scores);\r\n    }\r\n\r\n\r\n\r\n    function getAllPlayers() public view returns (address[] memory listOfPlayers){\r\n        listOfPlayers = playerList.values();\r\n    }\r\n    \r\n    function updateScore(address holder) private {\r\n        if(getScore(holder) > highScore[holder]){ // should be based on high score not current score\r\n            highScore[holder] = getScore(holder);\r\n        }\r\n    }\r\n    \r\n    function updateUnits(address holder) private {\r\n        require(!updating, \"May not re-enter during an update\");\r\n        updating = true;\r\n        \r\n        peasants[holder] = getPeasants(holder);\r\n        farmers[holder] = getFarmers(holder);\r\n        knights[holder] = getKnights(holder);\r\n        nobles[holder] = getNobles(holder);\r\n        kings[holder] = getKings(holder);\r\n        \r\n        lastUpdateTime[holder] = block.timestamp;\r\n        \r\n        updating = false;\r\n    }\r\n    \r\n    function update() external {\r\n        require(startTime[msg.sender] > 0, \"must start game to update units\");\r\n        updateUnits(msg.sender);\r\n        updateScore(msg.sender);\r\n    }\r\n\r\n    function buyMaxAll() external {\r\n        buyMaxFarmers();\r\n        buyMaxKnights();\r\n        buyMaxNobles();\r\n        buyMaxKings();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isTest\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"buyFarmers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"buyKings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"buyKnights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxFarmers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxKings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxKnights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxNobles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"buyNobles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmerCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getAccountRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPlayers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"listOfPlayers\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllScores\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getFarmers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getHolderKnightBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getHolderKnightLPBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getHolderNFTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getKings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getKnights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getLastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getMultiplierFromKnight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getMultiplierFromLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getMultiplierFromNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getNobles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getPeasants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getTimePassed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"highScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kingCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"knightBnbLPToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"knightCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"knightToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftBoost\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nobleCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnFullyOrderedLeaderboard\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnTop3Scores\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startGame\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "KingMaker", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://531fb8c6afdfe4f1d4a827fb040079658a56afac726c7a9e384a63048c0552bb"}