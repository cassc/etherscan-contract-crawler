{"SourceCode": "pragma solidity 0.8.7;\r\n\r\n// @TODO: Formatting\r\nlibrary LibBytes {\r\n  // @TODO: see if we can just set .length = \r\n  function trimToSize(bytes memory b, uint newLen)\r\n    internal\r\n    pure\r\n  {\r\n    require(b.length > newLen, \"BytesLib: only shrinking\");\r\n    assembly {\r\n      mstore(b, newLen)\r\n    }\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |        Read Bytes Functions       |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @dev Reads a bytes32 value from a position in a byte array.\r\n   * @param b Byte array containing a bytes32 value.\r\n   * @param index Index in byte array of bytes32 value.\r\n   * @return result bytes32 value from byte array.\r\n   */\r\n  function readBytes32(\r\n    bytes memory b,\r\n    uint256 index\r\n  )\r\n    internal\r\n    pure\r\n    returns (bytes32 result)\r\n  {\r\n    // Arrays are prefixed by a 256 bit length parameter\r\n    index += 32;\r\n\r\n    require(b.length >= index, \"BytesLib: length\");\r\n\r\n    // Read the bytes32 from array memory\r\n    assembly {\r\n      result := mload(add(b, index))\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n\r\n\r\ninterface IERC1271Wallet {\r\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\nlibrary SignatureValidator {\r\n\tusing LibBytes for bytes;\r\n\r\n\tenum SignatureMode {\r\n\t\tEIP712,\r\n\t\tEthSign,\r\n\t\tSmartWallet,\r\n\t\tSpoof\r\n\t}\r\n\r\n\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\r\n\tbytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\r\n\r\n\tfunction recoverAddr(bytes32 hash, bytes memory sig) internal view returns (address) {\r\n\t\treturn recoverAddrImpl(hash, sig, false);\r\n\t}\r\n\r\n\tfunction recoverAddrImpl(bytes32 hash, bytes memory sig, bool allowSpoofing) internal view returns (address) {\r\n\t\trequire(sig.length >= 1, \"SV_SIGLEN\");\r\n\t\tuint8 modeRaw;\r\n\t\tunchecked { modeRaw = uint8(sig[sig.length - 1]); }\r\n\t\tSignatureMode mode = SignatureMode(modeRaw);\r\n\r\n\t\t// {r}{s}{v}{mode}\r\n\t\tif (mode == SignatureMode.EIP712 || mode == SignatureMode.EthSign) {\r\n\t\t\trequire(sig.length == 66, \"SV_LEN\");\r\n\t\t\tbytes32 r = sig.readBytes32(0);\r\n\t\t\tbytes32 s = sig.readBytes32(32);\r\n\t\t\tuint8 v = uint8(sig[64]);\r\n\t\t\t// Hesitant about this check: seems like this is something that has no business being checked on-chain\r\n\t\t\trequire(v == 27 || v == 28, \"SV_INVALID_V\");\r\n\t\t\tif (mode == SignatureMode.EthSign) hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\t\taddress signer = ecrecover(hash, v, r, s);\r\n\t\t\trequire(signer != address(0), \"SV_ZERO_SIG\");\r\n\t\t\treturn signer;\r\n\t\t// {sig}{verifier}{mode}\r\n\t\t} else if (mode == SignatureMode.SmartWallet) {\r\n\t\t\t// 32 bytes for the addr, 1 byte for the type = 33\r\n\t\t\trequire(sig.length > 33, \"SV_LEN_WALLET\");\r\n\t\t\tuint newLen;\r\n\t\t\tunchecked {\r\n\t\t\t\tnewLen = sig.length - 33;\r\n\t\t\t}\r\n\t\t\tIERC1271Wallet wallet = IERC1271Wallet(address(uint160(uint256(sig.readBytes32(newLen)))));\r\n\t\t\tsig.trimToSize(newLen);\r\n\t\t\trequire(ERC1271_MAGICVALUE_BYTES32 == wallet.isValidSignature(hash, sig), \"SV_WALLET_INVALID\");\r\n\t\t\treturn address(wallet);\r\n\t\t// {address}{mode}; the spoof mode is used when simulating calls\r\n\t\t} else if (mode == SignatureMode.Spoof && allowSpoofing) {\r\n\t\t\trequire(tx.origin == address(1), \"SV_SPOOF_ORIGIN\");\r\n\t\t\trequire(sig.length == 33, \"SV_SPOOF_LEN\");\r\n\t\t\tsig.trimToSize(32);\r\n\t\t\treturn abi.decode(sig, (address));\r\n\t\t} else revert(\"SV_SIGMODE\");\r\n\t}\r\n}\r\n\r\n\r\ncontract Identity {\r\n\tmapping (address => bytes32) public privileges;\r\n\t// The next allowed nonce\r\n\tuint public nonce;\r\n\r\n\t// Events\r\n\tevent LogPrivilegeChanged(address indexed addr, bytes32 priv);\r\n\tevent LogErr(address indexed to, uint value, bytes data, bytes returnData); // only used in tryCatch\r\n\r\n\t// Transaction structure\r\n\t// we handle replay protection separately by requiring (address(this), chainID, nonce) as part of the sig\r\n\tstruct Transaction {\r\n\t\taddress to;\r\n\t\tuint value;\r\n\t\tbytes data;\r\n\t}\r\n\r\n\tconstructor(address[] memory addrs) {\r\n\t\tuint len = addrs.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\t// @TODO should we allow setting to any arb value here?\r\n\t\t\tprivileges[addrs[i]] = bytes32(uint(1));\r\n\t\t\temit LogPrivilegeChanged(addrs[i], bytes32(uint(1)));\r\n\t\t}\r\n\t}\r\n\r\n\t// This contract can accept ETH without calldata\r\n\treceive() external payable {}\r\n\r\n\t// This contract can accept ETH with calldata\r\n\t// However, to support EIP 721 and EIP 1155, we need to respond to those methods with their own method signature\r\n\tfallback() external payable {\r\n\t\tbytes4 method = msg.sig;\r\n\t\tif (\r\n\t\t\tmethod == 0x150b7a02 // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\r\n\t\t\t\t|| method == 0xf23a6e61 // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\r\n\t\t\t\t|| method == 0xbc197c81 // bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))\r\n\t\t) {\r\n\t\t\t// Copy back the method\r\n\t\t\t// solhint-disable-next-line no-inline-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tcalldatacopy(0, 0, 0x04)\r\n\t\t\t\treturn (0, 0x20)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setAddrPrivilege(address addr, bytes32 priv)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\t// Anti-bricking measure: if the privileges slot is used for special data (not 0x01),\r\n\t\t// don't allow to set it to true\r\n\t\tif (uint(privileges[addr]) > 1) require(priv != bytes32(uint(1)), 'UNSETTING_SPECIAL_DATA');\r\n\t\tprivileges[addr] = priv;\r\n\t\temit LogPrivilegeChanged(addr, priv);\r\n\t}\r\n\r\n\tfunction tipMiner(uint amount)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\t// See https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment/#managing-payments-to-coinbaseaddress-when-it-is-a-contract\r\n\t\t// generally this contract is reentrancy proof cause of the nonce\r\n\t\texecuteCall(block.coinbase, amount, new bytes(0));\r\n\t}\r\n\r\n\tfunction tryCatch(address to, uint value, bytes calldata data)\r\n\t\texternal\r\n\t{\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\t(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\r\n\t\tif (!success) emit LogErr(to, value, data, returnData);\r\n\t}\r\n\r\n\r\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\r\n\tfunction execute(Transaction[] calldata txns, bytes calldata signature)\r\n\t\texternal\r\n\t{\r\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\r\n\t\tuint currentNonce = nonce;\r\n\t\t// NOTE: abi.encode is safer than abi.encodePacked in terms of collision safety\r\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, currentNonce, txns));\r\n\t\t// We have to increment before execution cause it protects from reentrancies\r\n\t\tnonce = currentNonce + 1;\r\n\r\n\t\taddress signer = SignatureValidator.recoverAddrImpl(hash, signature, true);\r\n\t\trequire(privileges[signer] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t}\r\n\t\t// The actual anti-bricking mechanism - do not allow a signer to drop their own priviledges\r\n\t\trequire(privileges[signer] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\r\n\t}\r\n\r\n\t// no need for nonce management here cause we're not dealing with sigs\r\n\tfunction executeBySender(Transaction[] calldata txns) external {\r\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\r\n\t\trequire(privileges[msg.sender] != bytes32(0), 'INSUFFICIENT_PRIVILEGE');\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t}\r\n\t\t// again, anti-bricking\r\n\t\trequire(privileges[msg.sender] != bytes32(0), 'PRIVILEGE_NOT_DOWNGRADED');\r\n\t}\r\n\r\n\tfunction executeBySelf(Transaction[] calldata txns) external {\r\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\r\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\r\n\t\tuint len = txns.length;\r\n\t\tfor (uint i=0; i<len; i++) {\r\n\t\t\tTransaction memory txn = txns[i];\r\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\r\n\t\t}\r\n\t}\r\n\r\n\t// we shouldn't use address.call(), cause: https://github.com/ethereum/solidity/issues/2884\r\n\t// copied from https://github.com/uport-project/uport-identity/blob/develop/contracts/Proxy.sol\r\n\t// there's also\r\n\t// https://github.com/gnosis/MultiSigWallet/commit/e1b25e8632ca28e9e9e09c81bd20bf33fdb405ce\r\n\t// https://github.com/austintgriffith/bouncer-proxy/blob/master/BouncerProxy/BouncerProxy.sol\r\n\t// https://github.com/gnosis/safe-contracts/blob/7e2eeb3328bb2ae85c36bc11ea6afc14baeb663c/contracts/base/Executor.sol\r\n\tfunction executeCall(address to, uint256 value, bytes memory data)\r\n\t\tinternal\r\n\t{\r\n\t\tassembly {\r\n\t\t\tlet result := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\r\n\r\n\t\t\tswitch result case 0 {\r\n\t\t\t\tlet size := returndatasize()\r\n\t\t\t\tlet ptr := mload(0x40)\r\n\t\t\t\treturndatacopy(ptr, 0, size)\r\n\t\t\t\trevert(ptr, size)\r\n\t\t\t}\r\n\t\t\tdefault {}\r\n\t\t}\r\n\t\t// A single call consumes around 477 more gas with the pure solidity version, for whatever reason\r\n\t\t// WARNING: do not use this, it corrupts the returnData string (returns it in a slightly different format)\r\n\t\t//(bool success, bytes memory returnData) = to.call{value: value, gas: gasleft()}(data);\r\n\t\t//if (!success) revert(string(data));\r\n\t}\r\n\r\n\t// EIP 1271 implementation\r\n\t// see https://eips.ethereum.org/EIPS/eip-1271\r\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\r\n\t\tif (privileges[SignatureValidator.recoverAddr(hash, signature)] != bytes32(0)) {\r\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n\t\t\treturn 0x1626ba7e;\r\n\t\t} else {\r\n\t\t\treturn 0xffffffff;\r\n\t\t}\r\n\t}\r\n\r\n\t// EIP 1155 implementation\r\n\t// we pretty much only need to signal that we support the interface for 165, but for 1155 we also need the fallback function\r\n\tfunction supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n\t\treturn\r\n\t\t\tinterfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).\r\n\t\t\tinterfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`).\r\n\t}\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract QuickAccManager {\r\n\t// Note: nonces are scoped by identity rather than by accHash - the reason for this is that there's no reason to scope them by accHash,\r\n\t// we merely need them for replay protection\r\n\tmapping (address => uint) public nonces;\r\n\tmapping (bytes32 => uint) public scheduled;\r\n\r\n\tbytes4 constant CANCEL_PREFIX = 0xc47c3100;\r\n\r\n\t// Events\r\n\t// we only need those for timelocked stuff so we can show scheduled txns to the user; the oens that get executed immediately do not need logs\r\n\tevent LogScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint nonce, uint time, Identity.Transaction[] txns);\r\n\tevent LogCancelled(bytes32 indexed txnHash, bytes32 indexed accHash, address indexed signer, uint time);\r\n\tevent LogExecScheduled(bytes32 indexed txnHash, bytes32 indexed accHash, uint time);\r\n\r\n\t// EIP 2612\r\n\t/// @notice Chain Id at this contract's deployment.\r\n\tuint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;\r\n\t/// @notice EIP-712 typehash for this contract's domain at deployment.\r\n\tbytes32 internal immutable _DOMAIN_SEPARATOR;\r\n\r\n\tconstructor() {\r\n\t\tDOMAIN_SEPARATOR_CHAIN_ID = block.chainid;\r\n\t\t_DOMAIN_SEPARATOR = calculateDomainSeparator();\r\n\t}\r\n\r\n\tstruct QuickAccount {\r\n\t\tuint timelock;\r\n\t\taddress one;\r\n\t\taddress two;\r\n\t\t// We decided to not allow certain options here such as ability to skip the second sig for send(), but leaving this a struct rather than a tuple\r\n\t\t// for clarity and to ensure it's future proof\r\n\t}\r\n\tstruct DualSig {\r\n\t\tbool isBothSigned;\r\n\t\tbytes one;\r\n\t\tbytes two;\r\n\t}\r\n\r\n\t// NOTE: a single accHash can control multiple identities, as long as those identities set it's hash in privileges[address(this)]\r\n\t// this is by design\r\n\r\n\t// isBothSigned is hashed in so that we don't allow signatures from two-sig txns to be reused for single sig txns,\r\n\t// ...potentially frontrunning a normal two-sig transaction and making it wait\r\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\r\n\tfunction send(Identity identity, QuickAccount calldata acc, DualSig calldata sigs, Identity.Transaction[] calldata txns) external {\r\n\t\tbytes32 accHash = keccak256(abi.encode(acc));\r\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\r\n\t\tuint initialNonce = nonces[address(identity)]++;\r\n\t\t// Security: we must also hash in the hash of the QuickAccount, otherwise the sig of one key can be reused across multiple accs\r\n\t\tbytes32 hash = keccak256(abi.encode(\r\n\t\t\taddress(this),\r\n\t\t\tblock.chainid,\r\n\t\t\taddress(identity),\r\n\t\t\taccHash,\r\n\t\t\tinitialNonce,\r\n\t\t\ttxns,\r\n\t\t\tsigs.isBothSigned\r\n\t\t));\r\n\t\tif (sigs.isBothSigned) {\r\n\t\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');\r\n\t\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');\r\n\t\t\tidentity.executeBySender(txns);\r\n\t\t} else {\r\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, sigs.one);\r\n\t\t\trequire(acc.one == signer || acc.two == signer, 'SIG');\r\n\t\t\t// no need to check whether `scheduled[hash]` is already set here cause of the incrementing nonce\r\n\t\t\tscheduled[hash] = block.timestamp + acc.timelock;\r\n\t\t\temit LogScheduled(hash, accHash, signer, initialNonce, block.timestamp, txns);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction cancel(Identity identity, QuickAccount calldata acc, uint nonce, bytes calldata sig, Identity.Transaction[] calldata txns) external {\r\n\t\tbytes32 accHash = keccak256(abi.encode(acc));\r\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\r\n\r\n\t\tbytes32 hash = keccak256(abi.encode(CANCEL_PREFIX, address(this), block.chainid, address(identity), accHash, nonce, txns, false));\r\n\t\taddress signer = SignatureValidator.recoverAddr(hash, sig);\r\n\t\trequire(signer == acc.one || signer == acc.two, 'INVALID_SIGNATURE');\r\n\r\n\t\t// @NOTE: should we allow cancelling even when it's matured? probably not, otherwise there's a minor grief\r\n\t\t// opportunity: someone wants to cancel post-maturity, and you front them with execScheduled\r\n\t\tbytes32 hashTx = keccak256(abi.encode(address(this), block.chainid, accHash, nonce, txns, false));\r\n\t\tuint scheduledTime = scheduled[hashTx];\r\n\t\trequire(scheduledTime != 0 && block.timestamp < scheduledTime, 'TOO_LATE');\r\n\t\tdelete scheduled[hashTx];\r\n\r\n\t\temit LogCancelled(hashTx, accHash, signer, block.timestamp);\r\n\t}\r\n\r\n\tfunction execScheduled(Identity identity, bytes32 accHash, uint nonce, Identity.Transaction[] calldata txns) external {\r\n\t\trequire(identity.privileges(address(this)) == accHash, 'WRONG_ACC_OR_NO_PRIV');\r\n\r\n\t\tbytes32 hash = keccak256(abi.encode(address(this), block.chainid, address(identity), accHash, nonce, txns, false));\r\n\t\tuint scheduledTime = scheduled[hash];\r\n\t\trequire(scheduledTime != 0 && block.timestamp >= scheduledTime, 'NOT_TIME');\r\n\r\n\t\tdelete scheduled[hash];\r\n\t\tidentity.executeBySender(txns);\r\n\r\n\t\temit LogExecScheduled(hash, accHash, block.timestamp);\r\n\t}\r\n\r\n\t// EIP 1271 implementation\r\n\t// see https://eips.ethereum.org/EIPS/eip-1271\r\n\t// NOTE: this method is not intended to be called from off-chain eth_calls; technically it's not a clean EIP 1271\r\n\t// ...implementation, because EIP1271 assumes every smart wallet implements that method, while this contract is not a smart wallet\r\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) {\r\n\t\t(uint timelock, bytes memory sig1, bytes memory sig2) = abi.decode(signature, (uint, bytes, bytes));\r\n\t\tbytes32 accHash = keccak256(abi.encode(QuickAccount({\r\n\t\t\ttimelock: timelock,\r\n\t\t\tone: SignatureValidator.recoverAddr(hash, sig1),\r\n\t\t\ttwo: SignatureValidator.recoverAddr(hash, sig2)\r\n\t\t})));\r\n\t\tif (Identity(payable(address(msg.sender))).privileges(address(this)) == accHash) {\r\n\t\t\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n\t\t\treturn 0x1626ba7e;\r\n\t\t} else {\r\n\t\t\treturn 0xffffffff;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// EIP 712 methods\r\n\t// all of the following are 2/2 only\r\n\tstruct DualSigAlwaysBoth {\r\n\t\tbytes one;\r\n\t\tbytes two;\r\n\t}\r\n\r\n\tfunction calculateDomainSeparator() internal view returns (bytes32) {\r\n\t\treturn keccak256(\r\n\t\t\tabi.encode(\r\n\t\t\t\tkeccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n\t\t\t\t// @TODO: maybe we should use a more user friendly name here?\r\n\t\t\t\tkeccak256(bytes('QuickAccManager')),\r\n\t\t\t\tkeccak256(bytes('1')),\r\n\t\t\t\tblock.chainid,\r\n\t\t\t\taddress(this)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t/// @notice EIP-712 typehash for this contract's domain.\r\n\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\r\n\t\treturn block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : calculateDomainSeparator();\r\n\t}\r\n\r\n\tbytes32 private constant TRANSFER_TYPEHASH = keccak256('Transfer(address tokenAddr,address to,uint256 value,uint256 fee,address identity,uint256 nonce)');\r\n\tstruct Transfer { address token; address to; uint amount; uint fee; }\r\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\r\n\tfunction sendTransfer(Identity identity, QuickAccount calldata acc, DualSigAlwaysBoth calldata sigs, Transfer calldata t) external {\r\n\t\trequire(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');\r\n\r\n\t\tbytes32 hash = keccak256(abi.encodePacked(\r\n\t\t\t'\\x19\\x01',\r\n\t\t\tDOMAIN_SEPARATOR(),\r\n\t\t\tkeccak256(abi.encode(TRANSFER_TYPEHASH, t.token, t.to, t.amount, t.fee, address(identity), nonces[address(identity)]++))\r\n\t\t));\r\n\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');\r\n\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');\r\n\t\tIdentity.Transaction[] memory txns = new Identity.Transaction[](2);\r\n\t\ttxns[0].to = t.token;\r\n\t\ttxns[0].data = abi.encodeWithSelector(IERC20.transfer.selector, t.to, t.amount);\r\n\t\ttxns[1].to = t.token;\r\n\t\ttxns[1].data = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, t.fee);\r\n\t\tidentity.executeBySender(txns);\r\n\t}\r\n\r\n\t// Reference for arrays: https://github.com/sportx-bet/smart-contracts/blob/e36965a0c4748bf73ae15ed3cab5660c9cf722e1/contracts/impl/trading/EIP712FillHasher.sol\r\n\t// and https://eips.ethereum.org/EIPS/eip-712\r\n\t// and for signTypedData_v4: https://gist.github.com/danfinlay/750ce1e165a75e1c3387ec38cf452b71\r\n\tstruct Txn { string description; address to; uint value; bytes data; }\r\n\tbytes32 private constant TXNS_TYPEHASH = keccak256('Txn(string description,address to,uint256 value,bytes data)');\r\n\tbytes32 private constant BUNDLE_TYPEHASH = keccak256('Bundle(address identity,uint256 nonce,Txn[] transactions)');\r\n\t// WARNING: if the signature of this is changed, we have to change IdentityFactory\r\n\tfunction sendTxns(Identity identity, QuickAccount calldata acc, DualSigAlwaysBoth calldata sigs, Txn[] calldata txns) external {\r\n\t\trequire(identity.privileges(address(this)) == keccak256(abi.encode(acc)), 'WRONG_ACC_OR_NO_PRIV');\r\n\r\n\t\t// hashing + prepping args\r\n\t\tbytes32[] memory txnBytes = new bytes32[](txns.length);\r\n\t\tIdentity.Transaction[] memory identityTxns = new Identity.Transaction[](txns.length);\r\n\t\tuint txnLen = txns.length;\r\n\t\tfor (uint256 i = 0; i < txnLen; i++) {\r\n\t\t\ttxnBytes[i] = keccak256(abi.encode(TXNS_TYPEHASH, txns[i].description, txns[i].to, txns[i].value, txns[i].data));\r\n\t\t\tidentityTxns[i].to = txns[i].to;\r\n\t\t\tidentityTxns[i].value = txns[i].value;\r\n\t\t\tidentityTxns[i].data = txns[i].data;\r\n\t\t}\r\n\t\tbytes32 txnsHash = keccak256(abi.encodePacked(txnBytes));\r\n\t\tbytes32 hash = keccak256(abi.encodePacked(\r\n\t\t\t'\\x19\\x01',\r\n\t\t\tDOMAIN_SEPARATOR(),\r\n\t\t\tkeccak256(abi.encode(BUNDLE_TYPEHASH, address(identity), nonces[address(identity)]++, txnsHash))\r\n\t\t));\r\n\t\trequire(acc.one == SignatureValidator.recoverAddr(hash, sigs.one), 'SIG_ONE');\r\n\t\trequire(acc.two == SignatureValidator.recoverAddr(hash, sigs.two), 'SIG_TWO');\r\n\t\tidentity.executeBySender(identityTxns);\r\n\t}\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"accHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LogCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"accHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"LogExecScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"txnHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"accHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct Identity.Transaction[]\",\"name\":\"txns\",\"type\":\"tuple[]\"}],\"name\":\"LogScheduled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Identity\",\"name\":\"identity\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"one\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"two\",\"type\":\"address\"}],\"internalType\":\"struct QuickAccManager.QuickAccount\",\"name\":\"acc\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Identity.Transaction[]\",\"name\":\"txns\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Identity\",\"name\":\"identity\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"accHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Identity.Transaction[]\",\"name\":\"txns\",\"type\":\"tuple[]\"}],\"name\":\"execScheduled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"scheduled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Identity\",\"name\":\"identity\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"one\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"two\",\"type\":\"address\"}],\"internalType\":\"struct QuickAccManager.QuickAccount\",\"name\":\"acc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isBothSigned\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"one\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"two\",\"type\":\"bytes\"}],\"internalType\":\"struct QuickAccManager.DualSig\",\"name\":\"sigs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Identity.Transaction[]\",\"name\":\"txns\",\"type\":\"tuple[]\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Identity\",\"name\":\"identity\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"one\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"two\",\"type\":\"address\"}],\"internalType\":\"struct QuickAccManager.QuickAccount\",\"name\":\"acc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"one\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"two\",\"type\":\"bytes\"}],\"internalType\":\"struct QuickAccManager.DualSigAlwaysBoth\",\"name\":\"sigs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct QuickAccManager.Transfer\",\"name\":\"t\",\"type\":\"tuple\"}],\"name\":\"sendTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Identity\",\"name\":\"identity\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"one\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"two\",\"type\":\"address\"}],\"internalType\":\"struct QuickAccManager.QuickAccount\",\"name\":\"acc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"one\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"two\",\"type\":\"bytes\"}],\"internalType\":\"struct QuickAccManager.DualSigAlwaysBoth\",\"name\":\"sigs\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct QuickAccManager.Txn[]\",\"name\":\"txns\",\"type\":\"tuple[]\"}],\"name\":\"sendTxns\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "QuickAccManager", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b48d7a5cd4d13b4a33b8b61fef5b8c3debdb5cf8987fe0f1f68df5d33117f70a"}