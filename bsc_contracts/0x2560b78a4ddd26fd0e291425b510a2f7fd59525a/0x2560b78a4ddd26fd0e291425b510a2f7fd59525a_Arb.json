{"SourceCode": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n\tfunction balanceOf(address account) external view returns (uint);\r\n\tfunction transfer(address recipient, uint amount) external returns (bool);\r\n\tfunction approve(address spender, uint amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function factory() external pure returns (address);\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\n// \u0418\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441 \u0434\u043b\u044f \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441 \u043f\u0430\u0440\u043d\u044b\u043c \u043a\u043e\u043d\u0442\u0440\u0430\u043a\u0442\u043e\u043c Uniswap\r\ninterface IUniswapV2Pair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\n\r\ncontract Arb {\r\n    address _owner;\r\n    constructor(){\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner (){\r\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\t function getAmountOutMin(address router, address _tokenIn, address _tokenOut, uint256 _amount) public view returns (uint256) {\r\n\t\taddress[] memory path;\r\n\t\tpath = new address[](2);\r\n\t\tpath[0] = _tokenIn;\r\n\t\tpath[1] = _tokenOut;\r\n\t\tuint256[] memory amountOutMins = IUniswapV2Router(router).getAmountsOut(_amount, path);\r\n\t\treturn amountOutMins[path.length -1];\r\n\t}\r\n    function estimateDualDexTrade(address _router1, address _router2, address _token1, address _token2, uint256 _amount) external view returns (uint256) {\r\n\t\tuint256 amtBack1 = getAmountOutMin(_router1, _token1, _token2, _amount);\r\n\t\tuint256 amtBack2 = getAmountOutMin(_router2, _token2, _token1, amtBack1);\r\n\t\treturn amtBack2;\r\n\t}\r\n\r\n    function getOutsMins(address _router1, address _router2, address base_token, address[] memory _tokens, uint256 _amount) public view returns (uint256[] memory) {\r\n        uint256[] memory OutsMins = new uint256[](2 *_tokens.length);\r\n\t\t// \u041f\u0440\u044f\u043c\u043e\u0439 \u043e\u0431\u043c\u0435\u043d\r\n        for (uint256 i = 0; i < _tokens.length; i++) {\r\n\t\t\tuint256 amtBack1 = getAmountOutMin(_router1, base_token, _tokens[i], _amount);\r\n\t\t\tuint256 amtBack2 = getAmountOutMin(_router2, _tokens[i], base_token, amtBack1);\r\n\t\t\tOutsMins[i] = amtBack2;\r\n        }\r\n\t\t// \u041e\u0431\u0440\u0430\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d\r\n\t\tfor (uint256 i = 0; i < _tokens.length; i++) {  \r\n\t\t\tuint256 amtBack1 = getAmountOutMin(_router2, base_token, _tokens[i], _amount);\r\n\t\t\tuint256 amtBack2 = getAmountOutMin(_router1, _tokens[i], base_token, amtBack1);\r\n\t\t\tOutsMins[i + _tokens.length] = amtBack2;\r\n        }\r\n        return OutsMins;\r\n    }\r\n\r\n\tfunction getOutsMinsArr(address[] memory  _router1, address[] memory _router2, address[] memory base_token, address[] memory _tokens, uint256 _amount) \r\n\t\tpublic view returns (uint256[] memory)\r\n\t{   uint256 _tokens_length = _tokens.length;\r\n        uint256[] memory OutsMins = new uint256[](2 *_tokens_length);\r\n\t\t// \u041f\u0440\u044f\u043c\u043e\u0439 \u043e\u0431\u043c\u0435\u043d\r\n        for (uint256 i = 0; i < _tokens_length; i++) {\r\n\t\t\tuint256 amtBack1 = getAmountOutMin(_router1[i], base_token[i], _tokens[i], _amount);\r\n\t\t\tuint256 amtBack2 = getAmountOutMin(_router2[i], _tokens[i], base_token[i], amtBack1);\r\n\t\t\tOutsMins[i] = amtBack2;\r\n        }\r\n\t\t// \u041e\u0431\u0440\u0430\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d\r\n\t\tfor (uint256 i = 0; i < _tokens_length; i++) {  \r\n\t\t\tuint256 amtBack1 = getAmountOutMin(_router2[i], base_token[i], _tokens[i], _amount);\r\n\t\t\tuint256 amtBack2 = getAmountOutMin(_router1[i], _tokens[i], base_token[i], amtBack1);\r\n\t\t\tOutsMins[i + _tokens_length] = amtBack2;\r\n        }\r\n        return OutsMins;\r\n    }\r\n    // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043e\u0432 \u0434\u043b\u044f \u043f\u0430\u0440\u044b \u0442\u043e\u043a\u0435\u043d\u043e\u0432\r\n    function getReserves(address tokenA, address tokenB, address pair) public view returns (uint256 reserveA, uint256 reserveB) {    \r\n        IUniswapV2Pair uniswapPair = IUniswapV2Pair(pair);\r\n        (uint256 reserve0, uint256 reserve1,) = uniswapPair.getReserves();\r\n        // \u0423\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u0442\u043e\u043a\u0435\u043d\u043e\u0432, \u0447\u0442\u043e\u0431\u044b \u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0440\u0435\u0437\u0435\u0440\u0432\u044b \u0432 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435\r\n        (reserveA, reserveB) = tokenA < tokenB ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        return (reserveA, reserveB);\r\n    }\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043e\u0432 \u0438 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0445 \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\r\nfunction getOutsMinsArrWithReserv(\r\n    address[] memory _router1,\r\n    address[] memory _router2,\r\n    address[] memory base_token,\r\n    address[] memory _tokens,\r\n    uint256 _amount)\r\n    public\r\n    view\r\n    returns (uint256[] memory OutsMins)\r\n{\r\n    uint256 _tokens_length = _tokens.length;\r\n    OutsMins = new uint256[](2 * _tokens_length);\r\n\r\n    // \u041f\u0440\u044f\u043c\u043e\u0439 \u043e\u0431\u043c\u0435\u043d \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0440\u0435\u0437\u0435\u0440\u0432\u043e\u0432\r\n    for (uint256 i = 0; i < _tokens_length; i++) {\r\n        // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u0430\u043d\u0430\u0447\u0435\u043d\u0438\u044f\r\n        uint256 amtBack1 = getAmountOutMin(_router1[i], base_token[i], _tokens[i], _amount);\r\n        uint256 amtBack2 = getAmountOutMin(_router2[i], _tokens[i], base_token[i], amtBack1);\r\n        OutsMins[i] = amtBack2;\r\n    }\r\n    // \u041e\u0431\u0440\u0430\u0442\u043d\u044b\u0439 \u043e\u0431\u043c\u0435\u043d \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0440\u0435\u0437\u0435\u0440\u0432\u043e\u0432\r\n    for (uint256 i = 0; i < _tokens_length; i++) {\r\n        uint256 amtBack1 = getAmountOutMin(_router2[i], base_token[i], _tokens[i], _amount);\r\n        uint256 amtBack2 = getAmountOutMin(_router1[i], _tokens[i], base_token[i], amtBack1);\r\n        OutsMins[i + _tokens_length] = amtBack2;  \r\n    }\r\n    return OutsMins;\r\n}\r\n\r\nfunction getPairsReserves(\r\n    address[] memory base_token,\r\n    address[] memory _tokens,\r\n    address[] memory _pairs1,\r\n    address[] memory _pairs2)\r\n    public\r\n    view\r\n    returns (uint256[] memory ReservesA1, uint256[] memory ReservesB1, uint256[] memory ReservesA2, uint256[] memory ReservesB2)\r\n{\r\n    uint256 _tokens_length = _tokens.length;\r\n    // \u0414\u043b\u044f \u0440\u0435\u0437\u0435\u0440\u0432\u043e\u0432 \u043d\u0443\u0436\u043d\u043e \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0434\u0432\u0430 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0445 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0434\u043b\u044f token A \u0438 B\r\n    ReservesA1 = new uint256[](_tokens_length);\r\n    ReservesB1 = new uint256[](_tokens_length);\r\n    ReservesA2 = new uint256[](_tokens_length);\r\n    ReservesB2 = new uint256[](_tokens_length);\r\n\r\n    // \u041f\u0440\u044f\u043c\u043e\u0439 \u043e\u0431\u043c\u0435\u043d \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0440\u0435\u0437\u0435\u0440\u0432\u043e\u0432\r\n    for (uint256 i = 0; i < _tokens_length; i++) {\r\n        // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u0430\u043d\u0430\u0447\u0435\u043d\u0438\u044f\r\n            (uint256 reserveA1, uint256 reserveB1) = getReserves(_tokens[i], base_token[i], _pairs1[i]);\r\n            ReservesA1[i] = reserveA1;\r\n            ReservesB1[i] = reserveB1;\r\n    }\r\n    for (uint256 i = 0; i < _tokens_length; i++) {\r\n        // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0435 \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u0430\u043d\u0430\u0447\u0435\u043d\u0438\u044f\r\n            (uint256 reserveA2, uint256 reserveB2) = getReserves(_tokens[i], base_token[i], _pairs2[i]);\r\n            ReservesA2[i] = reserveA2;\r\n            ReservesB2[i] = reserveB2;\r\n    }\r\n    return (ReservesA1, ReservesB1, ReservesA2, ReservesB2);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\tfunction getBalance (address _tokenContractAddress) external view  returns (uint256) {\r\n\t\tuint balance = IERC20(_tokenContractAddress).balanceOf(address(this));\r\n\t\treturn balance;\r\n\t}\t\r\n\tfunction recoverEth() external onlyOwner {\r\n\t\tpayable(msg.sender).transfer(address(this).balance);\r\n\t}\r\n\tfunction recoverTokens(address tokenAddress) external onlyOwner {\r\n\t\tIERC20 token = IERC20(tokenAddress);\r\n\t\ttoken.transfer(msg.sender, token.balanceOf(address(this)));\r\n\t}\r\n\t\r\n\treceive() external payable {}\r\n\r\n    function swap(address router, address _tokenIn, address _tokenOut, uint256 _amount) private {\r\n\t\tIERC20(_tokenIn).approve(router, _amount);\r\n\t\taddress[] memory path;\r\n\t\tpath = new address[](2);\r\n\t\tpath[0] = _tokenIn;\r\n\t\tpath[1] = _tokenOut;\r\n\t\tuint deadline = block.timestamp + 300;\r\n\t\tIUniswapV2Router(router).swapExactTokensForTokens(_amount, 1, path, address(this), deadline);\r\n\t}\r\n\r\n    function dualDexTrade(address _router1, address _router2, address _token1, address _token2, uint256 _amount) external {\r\n        uint startBalance = IERC20(_token1).balanceOf(address(this));\r\n        uint token2InitialBalance = IERC20(_token2).balanceOf(address(this));\r\n\r\n            swap(_router1,_token1, _token2,_amount);\r\n\r\n        uint token2Balance = IERC20(_token2).balanceOf(address(this));\r\n        uint tradeableAmount = token2Balance - token2InitialBalance;\r\n\r\n            swap(_router2,_token2, _token1,tradeableAmount);\r\n\r\n        uint endBalance = IERC20(_token1).balanceOf(address(this));\r\n        require(endBalance > startBalance, \"Trade Reverted, No Profit Made\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"dualDexTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"estimateDualDexTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getAmountOutMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"base_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOutsMins\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_router1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_router2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"base_token\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOutsMinsArr\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_router1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_router2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"base_token\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getOutsMinsArrWithReserv\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"OutsMins\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"base_token\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pairs1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_pairs2\",\"type\":\"address[]\"}],\"name\":\"getPairsReserves\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ReservesA1\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ReservesB1\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ReservesA2\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ReservesB2\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Arb", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://16ecce34f9b4d74435279d981044c14896cc5280ddf241de9e4fcf004977da14"}