{"SourceCode": "{\"library.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev returns the decimal of this ERC20 contract\\n     */\\n    function decimals() external view returns (uint8);\\n    \\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = byte(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\\n\\n// CDF data contact interface\\nabstract contract CDFDataInterface {\\n    mapping (uint =\\u003e uint24[]) public CDF;\\n    uint16[] public Durations;\\n    uint public Amplifier;\\n    function numDurations() external view virtual returns (uint);\\n}\\n\\ninterface IOption is IERC20 {\\n    function resetOption(uint strikePrice_, uint newSupply) external;\\n    function name() external view returns (string memory);\\n    // previous rounds\\n    function getRoundExpiryDate(uint r) external view returns(uint);\\n    function getRoundStrikePrice(uint r) external view returns(uint);\\n    function getRoundSettlePrice(uint r) external view returns(uint);\\n    function getRoundTotalPremiums(uint r) external view returns(uint);\\n    function getRoundAccountPaidPremiums(uint r, address account) external view returns(uint);\\n    function getRoundBalanceOf(uint r, address account) external view returns (uint256);\\n    function getRoundAccPremiumShare(uint r) external view returns(uint);\\n    function setRoundAccPremiumShare(uint r, uint premiumShare) external;\\n    function getUnclaimedProfitsRound(address account) external view returns (uint);\\n    function setUnclaimedProfitsRound(uint r, address account) external;\\n    function getSettledRound(address account) external view returns (uint);\\n    function setSettledRound(uint r, address account) external;\\n\\n    // current round\\n    function addPremium(address account, uint256 amountUSDT) external;\\n    function totalPremiums() external view returns (uint);\\n    function expiryDate() external view returns (uint);\\n    function strikePrice() external view returns (uint);\\n    function getRound() external view returns (uint);\\n    function getDuration() external view returns (uint);\\n    function getPool() external view returns (address);\\n}\\n\\n\\ninterface IPoolerToken is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n    function burn(address account, uint256 amount) external;\\n    function getPool() external view returns (address);\\n}\\n\\ninterface IOptionPool {\\n    function name() external view returns (string memory);\\n    function owner() external view returns (address);\\n    function transferOwnership(address newOwner) external;\\n    function pausePooler() external;\\n    function unpausePooler() external;\\n    function pauseBuyer() external;\\n    function unpauseBuyer() external;\\n    function settlePooler(address account) external;\\n    function settleBuyer(address account) external;\\n    function update() external;\\n    function optionsLeft(IOption optionContract) external view returns (uint256 left, uint round);\\n    function buy(uint amount, IOption optionContract, uint round) external;\\n    function premiumCost(uint amount, IOption optionContract) external view returns(uint);\\n    function listOptions() external view returns (IOption []memory);\\n    function currentUtilizationRate() external view returns (uint256);\\n    function adjustSigma(uint16 newSigma) external;\\n    function NWA() external view returns (uint);\\n    function claimPremium() external;\\n    function claimOPA() external;\\n    function claimProfits() external;\\n    function checkOPA(address account) external view returns(uint256 opa);\\n    function checkPremium(address account) external view returns (uint256 premium);\\n    function checkProfits(address account) external view returns (uint256 profits);\\n    function setUtilizationRate(uint8 rate) external;\\n    function setMaxUtilizationRate(uint8 maxrate) external;\\n    function setRefreshPeriod(uint period) external;\\n    function getNextUpdateTime() external view returns (uint);\\n            \\n    /**\\n     * @dev deposit event\\n     */\\n    event Deposit(address indexed account, uint amount);\\n    \\n    /**\\n     * @dev withdraw event\\n     */\\n    event Withdraw(address indexed account, uint amount);\\n    \\n    /**\\n     * @dev option buy Log\\n     */\\n    event Buy(address indexed account, address indexed optionContract, uint round, uint amount, uint premiumCost);\\n\\n    /**\\n     * @dev Profits Claiming log\\n     */\\n    event ProfitsClaim(address indexed account, uint amount);\\n     \\n    /**\\n     * @dev Profits Settle log\\n     */\\n    event ProfitsSettled(address indexed account, address indexed optionContract, uint round, uint profitsSettled);\\n\\n    /**\\n     * @dev Premium Claiming log\\n     */\\n    event PremiumClaim(address indexed account, uint amount);\\n    \\n    /**\\n     * @dev OPA Claiming log\\n     */\\n    event OPAClaimed(address indexed account, uint amount);\\n     \\n    /**\\n     * @dev Premium Settle log\\n     */\\n    event PremiumSettled(address indexed account, uint accountCollateral, uint premiumSettled);\\n    \\n    /**\\n     * @dev ownership transfer event log\\n     */\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n}\\n\\n\\ninterface IPandaFactory {\\n    function createOption(uint duration_, uint8 decimals_, IOptionPool poolContract) external returns (IOption option);\\n    function createPoolerToken(uint8 decimals_, IOptionPool poolContract) external returns (IPoolerToken poolerToken);\\n    function getCDF() external view returns(address);\\n    function getUSDTContract() external view returns(address);\\n}\\n\\n\\ninterface IVesting {\\n    /**\\n     * @dev pool contract vest some OPA token for an account\\n     */\\n    function vest(address account, uint amount) external;\\n}\"},\"pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"library.sol\\\";\\n\\ncontract PausablePool is Context{\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n    \\n    bool private _poolerPaused;\\n    bool private _buyerPaused;\\n    \\n    /**\\n     * @dev Modifier to make a function callable only when the pooler is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenPoolerNotPaused() {\\n        require(!_poolerPaused, \\\"paused\\\");\\n        _;\\n    }\\n   \\n   /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPoolerPaused() {\\n        require(_poolerPaused, \\\"not paused\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Modifier to make a function callable only when the buyer is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenBuyerNotPaused() {\\n        require(!_buyerPaused, \\\"paused\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenBuyerPaused() {\\n        require(_buyerPaused, \\\"not paused\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Returns true if the pooler is paused, and false otherwise.\\n     */\\n    function poolerPaused() public view returns (bool) {\\n        return _poolerPaused;\\n    }\\n    \\n    /**\\n     * @dev Returns true if the buyer is paused, and false otherwise.\\n     */\\n    function buyerPaused() public view returns (bool) {\\n        return _buyerPaused;\\n    }\\n    \\n   /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The pooler must not be paused.\\n     */\\n    function _pausePooler() internal whenPoolerNotPaused {\\n        _poolerPaused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The pooler must be paused.\\n     */\\n    function _unpausePooler() internal whenPoolerPaused {\\n        _poolerPaused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    \\n   /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The buyer must not be paused.\\n     */\\n    function _pauseBuyer() internal whenBuyerNotPaused {\\n        _buyerPaused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The buyer must be paused.\\n     */\\n    function _unpauseBuyer() internal whenBuyerPaused {\\n        _buyerPaused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\\n/**\\n * @title base contract for option pool\\n */\\nabstract contract PandaBase is IOptionPool, PausablePool{\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IOption;\\n    using SafeMath for uint;\\n    using Address for address payable;\\n    \\n    // initialization once\\n    bool private inited;\\n    \\n    // pool direction enum\\n    enum PoolDirection{ CALL, PUT }\\n    \\n    /// @dev pool direction\\n    PoolDirection public immutable _direction;\\n    \\n    // option durations\\n    uint16 [] private _durations = [300,900,1800,2700,3600];\\n    \\n    /**\\n     * @dev option creation factory, set this based on blockchain,\\n     * constructor will fail if the address is illegal.\\n     */\\n    // BSC\\n    IPandaFactory internal constant pandaFactory = IPandaFactory(0xddE5b0c676d6A94540F5A2A91C7a5b75eaCBBEe0); \\n    \\n    uint256 public collateral; // collaterals in this pool\\n    \\n    uint256 internal constant SHARE_MULTIPLIER = 1e18; // share multiplier to avert division underflow\\n    \\n    uint256 public constant POOLER_FEE = 5e16; // charge 0.05 BNB for each deposit and withdraw\\n\\n    mapping (address =\\u003e uint256) internal _premiumBalance; // tracking pooler\\u0027s claimable premium\\n    mapping (address =\\u003e uint256) internal _opaBalance; // tracking pooler\\u0027s claimable OPA tokens\\n    mapping (address =\\u003e uint256) internal _profitsBalance; // tracking buyer\\u0027s claimable profits\\n\\n    IOption [] internal _options; // all option contracts\\n    address internal _owner; // owner of this contract\\n\\n    IERC20 public USDTContract; // USDT asset contract address\\n    AggregatorV3Interface public priceFeed; // chainlink price feed\\n    uint8 assetDecimal; // asset decimal\\n    CDFDataInterface public cdfDataContract; // cdf data contract;\\n\\n    uint8 public utilizationRate = 50; // utilization rate of the pool in percent\\n    uint8 public maxUtilizationRate = 75; // max utilization rate of the pool in percent\\n    uint16 public sigma = 70; // current sigma\\n    \\n    uint256 private _refreshPeriod = 3600; // sigma refresh period\\n    uint256 private _sigmaSoldOptions;  // sum total options sold in a period\\n    uint256 private _sigmaTotalOptions; // sum total options issued\\n    uint256 private _nextRefresh = block.timestamp + _refreshPeriod; // expected next refreshing time;\\n    \\n    // tracking pooler\\u0027s collateral with\\n    // the token contract of the pooler;\\n    IPoolerToken public poolerTokenContract;\\n    address public poolManager; // platform contract\\n    address payable public updaterAddress = 0x3639e068C9c4BB24292a9F3cB9698E03bD6Ee01A;     // updater address\\n    \\n    IERC20 public OPAToken;  // OPA token contract\\n    address public rewardAccount = 0x38A09Ec80aA2c5fc6E92a65E98a4e43e4dAb53b4; // OPA reward account\\n\\n    /**\\n     * OPA Rewarding\\n     */\\n    /// @dev block reward for this pool\\n    uint256 public OPABlockReward = 0;\\n\\n    /// @dev round index mapping to accumulate share.\\n    mapping (uint =\\u003e uint) private _opaAccShares;\\n    /// @dev mark pooler\\u0027s highest settled OPA round.\\n    mapping (address =\\u003e uint) private _settledOPARounds;\\n    /// @dev a monotonic increasing OPA round index, STARTS FROM 1\\n    uint256 private _currentOPARound = 1;\\n    // @dev last OPA reward block\\n    uint256 private _lastRewardBlock = block.number;\\n    \\n    event OPARewardSet(address account, uint256 blockReward);\\n    \\n    /**\\n     * OPA Vesting\\n     */\\n    IVesting public VestingContract = IVesting(0xe135C31Fc21A4962eA5000AC295885bcfd635293);\\n    \\n    /**\\n     * @dev settlement economy\\n     * we push some entropy to this array for each user operation\\n     * and pop some of the array when update to refund to caller.\\n     */\\n    uint256[] private entropy;\\n\\n    /**\\n     * @dev Modifier to make a function callable only by owner\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == _owner, \\\"restricted\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Modifier to make a function callable only by poolerTokenContract\\n     */\\n    modifier onlyPoolerTokenContract() {\\n        require(msg.sender == address(poolerTokenContract), \\\"restricted\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Modifier to make a function callable only by pool manager\\n     */\\n    modifier onlyPoolManager() {\\n        require(msg.sender == address(poolManager), \\\"restricted\\\");\\n        _;\\n    }\\n    \\n    /**\\n     * @dev Modifier to make a function callable only by options\\n     */\\n    modifier onlyOptions() {\\n        // privilege check\\n        bool isFromOption;\\n        for (uint i = 0; i \\u003c _options.length; i++) {\\n            if (address(_options[i]) == msg.sender) {\\n                isFromOption = true;\\n                break;\\n            }\\n        }\\n        require(isFromOption);\\n        _;\\n    }\\n\\n    /**\\n     * @dev abstract function for current option supply per slot\\n     */\\n    function _slotSupply(uint assetPrice) internal view virtual returns(uint);\\n    \\n    /**\\n     * @dev abstract function to calculate option profits\\n     */\\n    function _calcProfits(uint settlePrice, uint strikePrice, uint optionAmount) internal view virtual returns(uint256);\\n    \\n    /**\\n     * @dev abstract function to send back option profits\\n     */\\n    function _sendProfits(address payable account, uint256 amount) internal virtual;\\n    \\n    /**\\n     * @dev abstract function to get total pledged collateral\\n     */\\n    function _totalPledged() internal view virtual returns (uint);\\n\\n    constructor(AggregatorV3Interface priceFeed_, uint8 assetDecimal_, PoolDirection direction_) public {\\n        _owner = msg.sender;\\n        priceFeed = priceFeed_;\\n        assetDecimal = assetDecimal_;\\n        _direction = direction_;\\n             \\n        // contract references\\n        USDTContract = IERC20(pandaFactory.getUSDTContract());\\n        cdfDataContract = CDFDataInterface(pandaFactory.getCDF());\\n\\n        // set default poolManager\\n        poolManager = msg.sender;\\n    }\\n    \\n    /**\\n     * @dev Option initialization function.\\n     */\\n    function init() public onlyOwner {\\n        require(!inited, \\\"inited\\\");\\n        inited = true;\\n\\n        // creation of options\\n        for (uint i=0;i\\u003c_durations.length;i++) {\\n            _options.push(pandaFactory.createOption(_durations[i], assetDecimal, IOptionPool(this)));\\n        }\\n\\n        // first update;\\n        update();\\n    }\\n\\n    /**\\n     * @dev Returns the owner of this contract\\n     */\\n    function owner() external override view returns (address) {\\n        return _owner;\\n    }\\n    \\n    /**\\n     * @dev transfer ownership\\n     */\\n    function transferOwnership(address newOwner) external override onlyOwner {\\n        require(newOwner != address(0), \\\"zero\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    \\n    /**\\n     *@dev pooler \\u0026 buyer pausing\\n     */\\n    function pausePooler() external override onlyOwner { _pausePooler(); }\\n    function unpausePooler() external override onlyOwner { _unpausePooler(); }\\n    function pauseBuyer() external override onlyOwner { _pauseBuyer(); }\\n    function unpauseBuyer() external override onlyOwner { _unpauseBuyer(); } \\n\\n    /**\\n     * @notice check remaining options for the option contract\\n     */\\n    function optionsLeft(IOption optionContract) external override view returns (uint256 optionsleft, uint round) {\\n        return (optionContract.balanceOf(address(this)), optionContract.getRound());\\n    }\\n\\n    /**\\n     * @notice buy options via USDT, pool receive premium\\n     */\\n    function buy(uint amount, IOption optionContract, uint round) external override whenBuyerNotPaused {\\n        // make sure optionContract is in this pool\\n        bool optionValid;\\n        for (uint i = 0;i\\u003c _options.length;i++) {\\n            if (_options[i] == optionContract) {\\n                optionValid = true;\\n                break;\\n            }\\n        }\\n        require(optionValid,\\\"option invalid\\\");\\n         \\n        // check if option current round is the given round, we cannot buy previous rounds\\n        require (optionContract.getRound() == round, \\\"expired\\\");\\n        // cap amount to remaing options\\n        if (optionContract.balanceOf(address(this)) \\u003c amount) {\\n            amount = optionContract.balanceOf(address(this));\\n        }\\n        \\n        // calculate premium cost\\n        uint premium = premiumCost(amount, optionContract);\\n        \\n        // transfer premium USDTs to this pool\\n        USDTContract.safeTransferFrom(msg.sender, address(this), premium);\\n        \\n        // transfer options to msg.sender\\n        optionContract.safeTransfer(msg.sender, amount);\\n        \\n        // credit premium to option contract\\n        optionContract.addPremium(msg.sender, premium);\\n                \\n        // log\\n        emit Buy(msg.sender, address(optionContract), round, amount, premium);\\n        \\n        // entropy storage to refund to update() caller\\n        entropy.push(block.number);\\n        \\n        // OPTION PARAMETERS MAINTENANCE\\n        // sigma: count sold options\\n        _sigmaSoldOptions = _sigmaSoldOptions.add(amount);\\n        \\n        // other periodical refresh\\n        if (block.timestamp \\u003e _nextRefresh) {\\n            updateSigma();\\n        }\\n         \\n        // open new round, one caller will get refund for an effective update\\n        if (block.timestamp \\u003e getNextUpdateTime()) {\\n            update();\\n        }\\n    }\\n    \\n    /**\\n     * @dev set OPA reward per height\\n     */\\n    function setOPAReward(uint256 reward) external onlyOwner {\\n        // settle previous rewards\\n        updateOPAReward();\\n        // set new block reward\\n        OPABlockReward = reward;\\n        \\n        // log\\n        emit OPARewardSet(msg.sender, reward);\\n    }\\n    \\n    /**\\n     * @dev convert sigma to index, sigma will be rounded to nearest index\\n     */\\n    function _sigmaToIndex() private view returns(uint) {\\n        // sigma to index\\n        require(sigma \\u003e=15 \\u0026\\u0026 sigma \\u003c=145, \\\"[15,145]\\\");\\n        uint sigmaIndex = sigma / 5;\\n        return sigmaIndex;\\n    }\\n\\n    /**\\n     * @notice check option cost for given amount of option\\n     */\\n    function premiumCost(uint amount, IOption optionContract) public override view returns(uint) {\\n        // expiry check\\n        if (block.timestamp \\u003e= optionContract.expiryDate()) {\\n            return 0;\\n        }\\n        \\n        // rounding to nearest duration\\n        uint timediff = optionContract.expiryDate().sub(block.timestamp).add(60);\\n        uint duration = timediff.div(120).mul(120); // round to 2min\\n        \\n        // align duration to [120, 3600]\\n        if (duration \\u003c 120) {\\n            duration = 120;\\n        } else if (duration \\u003e 3600) {\\n            duration = 3600;\\n        }\\n\\n        // notice the CDF is already multiplied by cdfDataContract.Amplifier()\\n        uint cdf = cdfDataContract.CDF(duration, _sigmaToIndex());\\n        \\n        // calculate premium for option\\n        uint currentPrice = getAssetPrice();\\n        uint strikePrice = optionContract.strikePrice();\\n\\n        // calculate USDT profits based on current price\\n        uint realtimeProfits;\\n        if (_direction == PoolDirection.CALL) {\\n            // @dev convert asset profits to USDT at current price\\n            realtimeProfits = _calcProfits(currentPrice, strikePrice, amount)\\n                                .mul(currentPrice)\\n                                .div(10 ** uint(optionContract.decimals()));\\n        } else {\\n            realtimeProfits = _calcProfits(currentPrice, strikePrice, amount);\\n        }\\n        \\n        // price in the realtime profits to avoid arbitrage.\\n        // @dev note the price is for 10 ** option decimals\\n        return realtimeProfits + amount * currentPrice * cdf  / (10 ** uint(optionContract.decimals())) / cdfDataContract.Amplifier();\\n    }\\n\\n    /**\\n     * @notice list all options\\n     */\\n    function listOptions() external override view returns (IOption []memory) {\\n        return _options;\\n    }\\n    \\n    /**\\n     * @notice get current utilization rate\\n     */\\n    function currentUtilizationRate() external override view returns (uint256) {\\n        if (collateral \\u003e 0) {\\n            return _totalPledged().mul(100).div(collateral);\\n        }\\n        return 0;\\n    }\\n    \\n    /**\\n     * @notice get next update time\\n     */\\n    function getNextUpdateTime() public override view returns (uint) {\\n        uint nextUpdateTime = block.timestamp.add(1 days);\\n        \\n        for (uint i = 0;i\\u003c _options.length;i++) {\\n            if (_options[i].expiryDate() \\u003c nextUpdateTime) {\\n                nextUpdateTime = _options[i].expiryDate();\\n            }\\n        }\\n\\n        return nextUpdateTime;\\n    }\\n    \\n    /**\\n     * @notice set refresh period\\n     */\\n    function setRefreshPeriod(uint period) external override {\\n        require(period \\u003e 0, \\\"postive\\\");\\n        _refreshPeriod = period;\\n    }\\n\\n    /**\\n     * @notice update of options, triggered by anyone periodically\\n     */\\n    function update() public override {\\n        uint256 startGas = gasleft();\\n         \\n        // load chainlink price\\n        uint assetPrice = getAssetPrice();\\n\\n        // create a memory copy of array\\n        IOption [] memory options = _options;\\n        \\n        // accumulated manager\\u0027s USDT revenue\\n        uint256 accManagerRevenue;\\n        uint256 accManagerAssetRevenue;\\n\\n        \\n        // settle all options\\n        for (uint i = 0;i\\u003c options.length;i++) {\\n            if (block.timestamp \\u003e= options[i].expiryDate()) { // expired\\n                (uint256 premium, uint256 asset) = _settleOption(options[i], assetPrice);\\n                accManagerRevenue += premium;\\n                accManagerAssetRevenue += asset;\\n            } else { // mark unexpired by clearning 0\\n                options[i] = IOption(0);\\n            }\\n        }\\n        \\n        // calculate supply for a slot after settlement,\\n        // notice we must settle options before option reset, otherwise\\n        // we cannot get a correct slot supply due to COLLATERAL WRITE DOWN\\n        // when multiple options settles at once.\\n        uint slotSupply = _slotSupply(assetPrice);\\n        for (uint i = 0;i \\u003c options.length;i++) {\\n            if (options[i] != IOption(0)) { // we only check expiryDate once, it\\u0027s expensive.\\n                // reset option with new slot supply\\n                options[i].resetOption(assetPrice, slotSupply);\\n\\n                // sigma: count newly issued options\\n                _sigmaTotalOptions = _sigmaTotalOptions.add(slotSupply);\\n            }\\n        }\\n\\n        // transfer manager\\u0027s USDT premium\\n        if (accManagerRevenue \\u003e 0) {\\n            USDTContract.safeTransfer(poolManager, accManagerRevenue);\\n        }\\n        \\n        // transfer manager\\u0027s asset revenue\\n        if (accManagerAssetRevenue \\u003e 0) {\\n            _sendProfits(payable(poolManager), accManagerAssetRevenue);\\n        }\\n        \\n        // compute gas used until now;\\n        // gas usage +STORAGEMOD -STORAGEKILL = -10000\\n        uint needKills = (startGas - gasleft()) / 10000;\\n                \\n        // maximum 50% refund;\\n        needKills = needKills/2 + 1;\\n        \\n        // entropy limit\\n        if (needKills \\u003e entropy.length) {\\n            needKills = entropy.length;\\n        }\\n\\n        // refund gas via STORAGEKILL for any caller\\n        for (uint i = 0;i\\u003cneedKills;i++) {\\n            entropy.pop();\\n        }\\n    }\\n    \\n    /**\\n     * @dev settle option contract\\n     * \\n     * ASSUMPTION:\\n     *  if one pooler\\u0027s token amount keeps unchanged after settlement, then\\n     *  accmulated premiumShare * (pooler token) \\n     *  is the share for one pooler.\\n     */\\n    function _settleOption(IOption option, uint settlePrice) internal returns (uint256 managerRevenue, uint256 managerAssetRevenue) {\\n        uint totalSupply = option.totalSupply();\\n        uint strikePrice = option.strikePrice();\\n        \\n        // count total sold options\\n        uint totalOptionSold = totalSupply.sub(option.balanceOf(address(this)));\\n        \\n        // calculate user\\u0027s total profits, ALREADY MULTIPLIED WITH 99%\\n        uint totalProfits = _calcProfits(settlePrice, strikePrice, totalOptionSold);\\n\\n        // substract collateral\\n        // buyer\\u0027s profits is pooler\\u0027s loss\\n        if (totalProfits \\u003e 0) {\\n            // 1% profits belongs to manager\\n            managerAssetRevenue = totalProfits.div(99);\\n            collateral = collateral.sub(totalProfits).sub(managerAssetRevenue);\\n        }\\n        \\n        // settle preimum dividends\\n        uint poolerTotalSupply = poolerTokenContract.totalSupply();\\n        uint totalPremiums = option.totalPremiums();\\n        uint round = option.getRound();\\n        \\n        // settle premium share\\n        uint roundPremiumShare;\\n        if (poolerTotalSupply \\u003e 0) {\\n            // 1% belongs to platform\\n            managerRevenue = totalPremiums.div(100);\\n\\n            // 99% belongs to all pooler\\n            roundPremiumShare = totalPremiums.sub(managerRevenue)\\n                                .mul(SHARE_MULTIPLIER)      // mul share with SHARE_MULTIPLIER to avert from underflow\\n                                .div(poolerTotalSupply);\\n        }\\n\\n        // set the accumulated premiumShare if round \\u003e 0\\n        if (round \\u003e 0) {\\n            roundPremiumShare = roundPremiumShare.add(option.getRoundAccPremiumShare(round-1));\\n        }\\n        option.setRoundAccPremiumShare(round, roundPremiumShare);\\n    }\\n    \\n    /**\\n     * @dev update accumulated OPA block reward until block\\n     */\\n    function updateOPAReward() internal {\\n        // skip round changing in the same block\\n        if (_lastRewardBlock == block.number) {\\n            return;\\n        }\\n        \\n        uint poolerTotalSupply = poolerTokenContract.totalSupply();\\n\\n        // postpone OPA rewarding if there is none pooler\\n        if (poolerTotalSupply == 0) {\\n            return;\\n        }\\n        \\n        // settle OPA share for [_lastRewardBlock, block.number]\\n        uint blocksToReward = block.number.sub(_lastRewardBlock);\\n        uint mintedOPA = OPABlockReward.mul(blocksToReward);\\n        uint roundOPAShare = mintedOPA.mul(SHARE_MULTIPLIER)\\n                                    .div(poolerTotalSupply);\\n                                \\n        // mark block rewarded;\\n        _lastRewardBlock = block.number;\\n                \\n        // accumulate OPA share\\n        _opaAccShares[_currentOPARound] = roundOPAShare.add(_opaAccShares[_currentOPARound-1]); \\n       \\n        // next round setting                                 \\n        _currentOPARound++;\\n    }\\n\\n    /**\\n     * @dev function to update sigma value periodically\\n     */\\n    function updateSigma() internal {\\n        // sigma: metrics updates hourly\\n        if (_sigmaTotalOptions \\u003e 0) {\\n            uint16 s = sigma;\\n            // update sigma\\n            uint rate = _sigmaSoldOptions.mul(100).div(_sigmaTotalOptions);\\n            \\n            // sigma range [15, 145]\\n            if (rate \\u003e 90 \\u0026\\u0026 s \\u003c 145) {\\n                s += 5;\\n            } else if (rate \\u003c 50 \\u0026\\u0026 s \\u003e 15) {\\n                s -= 5;\\n            }\\n            \\n            sigma = s;\\n        }\\n        \\n        // new metrics\\n        uint sigmaTotalOptions;\\n        uint sigmaSoldOptions;\\n\\n        // create a memory copy of array\\n        IOption [] memory options = _options;\\n        \\n        // rebuild sold/total metrics\\n        for (uint i = 0;i\\u003c options.length;i++) {\\n            // sum all issued options and sold options\\n            uint supply = options[i].totalSupply();\\n            uint sold = supply.sub(options[i].balanceOf(address(this)));\\n            \\n            sigmaTotalOptions = sigmaTotalOptions.add(supply);\\n            sigmaSoldOptions = sigmaSoldOptions.add(sold);\\n        }\\n        \\n        // set back to contract storage\\n        _sigmaTotalOptions = sigmaTotalOptions;\\n        _sigmaSoldOptions = sigmaSoldOptions;\\n        \\n        // set next refresh time to at least one hour later\\n        _nextRefresh += _refreshPeriod;\\n    }\\n    \\n    /**\\n     * @notice adjust sigma manually\\n     */\\n    function adjustSigma(uint16 newSigma) external override onlyOwner {\\n        require (newSigma % 5 == 0, \\\"needs 5*N\\\");\\n        require (newSigma \\u003e= 15 \\u0026\\u0026 newSigma \\u003c= 145, \\\"[15,145]\\\");\\n        \\n        sigma = newSigma;\\n    }\\n\\n    /**\\n     * @notice poolers sum premium USDTs;\\n     */\\n    function checkPremium(address account) external override view returns(uint256 premium) {\\n        uint accountCollateral = poolerTokenContract.balanceOf(account);\\n\\n        premium = _premiumBalance[account];\\n\\n        for (uint i = 0; i \\u003c _options.length; i++) {\\n            IOption option = _options[i];\\n            uint currentRound = option.getRound();\\n            uint lastSettledRound = option.getSettledRound(account);\\n            \\n            uint roundPremium = option.getRoundAccPremiumShare(currentRound-1).sub(option.getRoundAccPremiumShare(lastSettledRound))\\n                                    .mul(accountCollateral)\\n                                    .div(SHARE_MULTIPLIER);  // remember to div by SHARE_MULTIPLIER    \\n            \\n            premium = premium.add(roundPremium);\\n        }\\n        \\n        return (premium);\\n    }\\n    \\n    /**\\n     * @notice poolers claim premium USDTs;\\n     */\\n    function claimPremium() external override whenPoolerNotPaused {\\n        // settle un-distributed premiums in rounds to _premiumBalance;\\n        _settlePooler(msg.sender);\\n\\n        // premium balance modification\\n        uint amountUSDTPremium = _premiumBalance[msg.sender];\\n        delete _premiumBalance[msg.sender]; // zero premium balance\\n        \\n        // transfer premium\\n        USDTContract.safeTransfer(msg.sender, amountUSDTPremium);\\n\\n        // log\\n        emit PremiumClaim(msg.sender, amountUSDTPremium);\\n    }\\n    \\n     /**\\n     * @notice poolers sum unclaimed OPA;\\n     */\\n    function checkOPA(address account) external override view returns(uint256 opa) {\\n        uint poolerTotalSupply = poolerTokenContract.totalSupply();\\n        uint accountCollateral = poolerTokenContract.balanceOf(account);\\n        uint lastSettledOPARound = _settledOPARounds[account];\\n        \\n        // poolers OPA reward = settledOPA + unsettledOPA + newMinedOPA\\n        uint unsettledOPA = _opaAccShares[_currentOPARound-1].sub(_opaAccShares[lastSettledOPARound]);\\n        uint newMinedOPAShare;\\n        if (poolerTotalSupply \\u003e 0) {\\n            uint blocksToReward = block.number.sub(_lastRewardBlock);\\n            uint mintedOPA = OPABlockReward.mul(blocksToReward);\\n    \\n            // OPA share per pooler token\\n            newMinedOPAShare = mintedOPA.mul(SHARE_MULTIPLIER)\\n                                        .div(poolerTotalSupply);\\n        }\\n        \\n        return _opaBalance[account] + (unsettledOPA + newMinedOPAShare).mul(accountCollateral)\\n                                            .div(SHARE_MULTIPLIER);  // remember to div by SHARE_MULTIPLIER;\\n    }\\n    \\n    /**\\n     * @notice claim OPA;\\n     */\\n    function claimOPA() external override whenPoolerNotPaused {\\n        // settle un-distributed OPA in rounds to _opaBalance;\\n        _settlePooler(msg.sender);\\n\\n        // OPA balance modification\\n        uint amountOPA = _opaBalance[msg.sender];\\n        delete _opaBalance[msg.sender]; // zero OPA balance\\n\\n        // transfer OPA to vesting contract\\n        OPAToken.safeTransferFrom(rewardAccount, address(VestingContract), amountOPA);\\n        \\n        // vest the amount for the sender\\n        VestingContract.vest(msg.sender, amountOPA);\\n        \\n        // log\\n        emit OPAClaimed(msg.sender, amountOPA);\\n    }\\n\\n    /**\\n     * @notice settle premium in rounds while pooler token transfers.\\n     */\\n    function settlePooler(address account) external override onlyPoolerTokenContract {\\n        _settlePooler(account);\\n    }\\n\\n    /**\\n     * @notice settle premium in rounds to _premiumBalance, \\n     * settle premium happens before any pooler token exchange such as ERC20-transfer,mint,burn,\\n     * and manually claimPremium;\\n     * \\n     */\\n    function _settlePooler(address account) internal {\\n        uint accountCollateral = poolerTokenContract.balanceOf(account);\\n        \\n        // premium settlement\\n        uint premiumBalance = _premiumBalance[account];\\n        \\n        for (uint i = 0; i \\u003c _options.length; i++) {\\n            IOption option = _options[i];\\n            \\n            uint lastSettledRound = option.getSettledRound(account);\\n            uint newSettledRound = option.getRound() - 1;\\n            \\n            // premium\\n            uint roundPremium = option.getRoundAccPremiumShare(newSettledRound).sub(option.getRoundAccPremiumShare(lastSettledRound))\\n                                        .mul(accountCollateral)\\n                                        .div(SHARE_MULTIPLIER);  // remember to div by SHARE_MULTIPLIER\\n                                        \\n            premiumBalance = premiumBalance.add(roundPremium);\\n\\n            // mark new settled round\\n            option.setSettledRound(newSettledRound, account);\\n        }\\n                        \\n        // log settled premium\\n        emit PremiumSettled(msg.sender, accountCollateral, premiumBalance.sub(_premiumBalance[account]));\\n        // set back balance to storage\\n        _premiumBalance[account] = premiumBalance;\\n        \\n        // OPA settlement for each pooler token balance change\\n        {\\n            // update OPA reward snapshot\\n            updateOPAReward();\\n            \\n            // settle this account\\n            uint lastSettledOPARound = _settledOPARounds[account];\\n            uint newSettledOPARound = _currentOPARound - 1;\\n            \\n            // round OPA\\n            uint roundOPA = _opaAccShares[newSettledOPARound].sub(_opaAccShares[lastSettledOPARound])\\n                                    .mul(accountCollateral)\\n                                    .div(SHARE_MULTIPLIER);  // remember to div by SHARE_MULTIPLIER    \\n            \\n            // update OPA balance\\n            _opaBalance[account] += roundOPA;\\n            // mark new settled OPA round\\n            _settledOPARounds[account] = newSettledOPARound;\\n        }\\n    }\\n    \\n    /**\\n     * @notice net-withdraw amount;\\n     */\\n    function NWA() public view override returns (uint) {\\n        // get minimum collateral\\n        uint minCollateral = _totalPledged() * 100 / maxUtilizationRate;\\n        if (minCollateral \\u003e collateral) {\\n            return 0;\\n        }\\n\\n        // net withdrawable amount\\n        return collateral.sub(minCollateral);\\n    }\\n    \\n    /**\\n     * @notice check claimable buyer\\u0027s profits\\n     */\\n    function checkProfits(address account) external override view returns (uint256 profits) {\\n        // load from profits balance\\n        profits = _profitsBalance[account];\\n        // sum all profits from all options\\n        for (uint i = 0; i \\u003c _options.length; i++) {\\n            profits += checkOptionProfits(_options[i], account);\\n        }\\n        return profits;\\n    }\\n    \\n    /**\\n     * @notice check profits in an option\\n     */\\n    function checkOptionProfits(IOption option, address account) internal view returns (uint256 amount) {\\n        uint unclaimedRound = option.getUnclaimedProfitsRound(account);\\n        if (unclaimedRound == option.getRound()) {\\n            return 0;\\n        }\\n\\n        // accumulate profits in _profitsBalance\\n        uint settlePrice = option.getRoundSettlePrice(unclaimedRound);\\n        uint strikePrice = option.getRoundStrikePrice(unclaimedRound);\\n        uint optionAmount = option.getRoundBalanceOf(unclaimedRound, account);\\n        \\n        return _calcProfits(settlePrice, strikePrice, optionAmount);\\n    }\\n        \\n    /**\\n     * @notice buyers claim option profits\\n     */   \\n    function claimProfits() external override whenBuyerNotPaused {\\n        // settle profits in options\\n        for (uint i = 0; i \\u003c _options.length; i++) {\\n            _settleBuyer(_options[i], msg.sender);\\n        }\\n    \\n        // load and clean profits\\n        uint256 accountProfits = _profitsBalance[msg.sender];\\n        delete _profitsBalance[msg.sender];\\n        \\n        // send profits\\n        _sendProfits(msg.sender, accountProfits);\\n\\n        // log\\n        emit ProfitsClaim(msg.sender, accountProfits);\\n    }\\n    \\n    /**\\n     * @notice settle profits while option token transfers.\\n     */\\n    function settleBuyer(address account) external override onlyOptions {\\n        _settleBuyer(IOption(msg.sender), account);\\n    }\\n\\n    /**\\n     * @notice settle profits in rounds to _profitsBalance, \\n     * settle buyer happens before any option token exchange such as ERC20-transfer,mint,burn,\\n     * and manually claimProfits;\\n     * \\n     */\\n    function _settleBuyer(IOption option, address account) internal {\\n        uint unclaimedRound = option.getUnclaimedProfitsRound(account);\\n        uint currentRound = option.getRound();\\n        \\n        // current round is always unsettled\\n        if (unclaimedRound == currentRound) {\\n            return;\\n        }\\n\\n        // accumulate profits in _profitsBalance\\n        uint settlePrice = option.getRoundSettlePrice(unclaimedRound);\\n        uint strikePrice = option.getRoundStrikePrice(unclaimedRound);\\n        uint256 optionAmount = option.getRoundBalanceOf(unclaimedRound, account);\\n        uint256 profits = _calcProfits(settlePrice, strikePrice, optionAmount);\\n\\n        // add profits to balance;\\n        _profitsBalance[account] += profits;\\n        \\n        // set current round unclaimed\\n        option.setUnclaimedProfitsRound(currentRound, account);\\n\\n        // log settled profits\\n        emit ProfitsSettled(msg.sender, address(option), unclaimedRound, profits);\\n    }\\n\\n    /**\\n     * @notice set pool manager\\n     */\\n    function setPoolManager(address poolManager_) external onlyOwner {\\n        poolManager = poolManager_;\\n    }\\n    \\n    /**\\n     * @notice set updater address\\n     */\\n    function setUpdater(address payable updater_) external onlyOwner {\\n        updaterAddress = updater_;\\n    }\\n    \\n    /**\\n     * @notice set OPA token\\n     */\\n    function setOPAToken(IERC20 OPAToken_) external onlyOwner {\\n        OPAToken = OPAToken_;\\n    }\\n    \\n    /**\\n     * @notice set OPA transfer account\\n     */\\n    function setOPARewardAccount(address rewardAccount_) external onlyOwner {\\n        rewardAccount = rewardAccount_;\\n    }\\n    \\n    /**\\n     * @notice set Vesting contract\\n     */\\n    function setVestingContract(IVesting vestingContract_) external onlyOwner {\\n        VestingContract = vestingContract_;\\n    }\\n    \\n    /**\\n     * @notice set utilization rate by owner\\n     */\\n    function setUtilizationRate(uint8 rate) external override onlyOwner {\\n        require(rate \\u003e=0 \\u0026\\u0026 rate \\u003c= 100, \\\"[0,100]\\\");\\n        utilizationRate = rate;\\n    }\\n    \\n    /**\\n     * @notice set max utilization rate by owner\\n     */\\n    function setMaxUtilizationRate(uint8 maxrate) external override onlyOwner {\\n        require(maxrate \\u003e=0 \\u0026\\u0026 maxrate \\u003c= 100, \\\"[0,100]\\\");\\n        require(maxrate \\u003e utilizationRate, \\\"less than rate\\\");\\n        maxUtilizationRate = maxrate;\\n    }\\n    \\n        \\n    /**\\n     * @dev get the price for asset with regarding to asset decimals\\n     * Example:\\n     *  for ETH price oracle, this function returns the USDT price for 1 ETH\\n     */\\n    function getAssetPrice() public view returns(uint) {\\n        (, int latestPrice, , , ) = priceFeed.latestRoundData();\\n\\n        if (latestPrice \\u003e 0) { // convert to USDT decimal\\n            return uint(latestPrice).mul(10 ** uint256(USDTContract.decimals()))\\n                                    .div(10 ** uint256(priceFeed.decimals()));\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * @title Implementation of Native Call Option Pool\\n * NativeCallOptionPool Call Option Pool use native currency as collateral and bets\\n * on Chainlink Oracle Price Feed.\\n */\\ncontract NativeCallOptionPool is PandaBase {\\n    string private _name;\\n    /**\\n     * @param priceFeed Chainlink contract for asset price\\n     */\\n    constructor(string memory name_, AggregatorV3Interface priceFeed)\\n        PandaBase(priceFeed, 18, PoolDirection.CALL)\\n        public {\\n            _name = name_;\\n            // creation of pooler token\\n            poolerTokenContract = pandaFactory.createPoolerToken(18, IOptionPool(this));\\n        }\\n\\n    /**\\n     * @dev Returns the pool of the contract.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @notice deposit ethers to this pool directly.\\n     */\\n    function deposit() external whenPoolerNotPaused payable {\\n        require(msg.value \\u003e POOLER_FEE, \\\"0 value\\\");\\n        uint256 value = msg.value.sub(POOLER_FEE);\\n        \\n        poolerTokenContract.mint(msg.sender, value);\\n        collateral = collateral.add(value);\\n        \\n        // log\\n        emit Deposit(msg.sender, value);\\n        \\n        // transfer POOLER_FEE to updaterAddress\\n        updaterAddress.sendValue(POOLER_FEE);\\n    }\\n    \\n    /**\\n     * @notice withdraw the pooled ethers;\\n     */\\n    function withdraw(uint amount) external whenPoolerNotPaused payable {\\n        require (amount \\u003c= poolerTokenContract.balanceOf(msg.sender), \\\"balance exceeded\\\");\\n        require (amount \\u003c= NWA(), \\\"collateral exceeded\\\");\\n        require(msg.value \\u003e= POOLER_FEE, \\\"0 fee\\\");\\n\\n        // burn pooler token\\n        poolerTokenContract.burn(msg.sender, amount);\\n        // substract collateral\\n        collateral = collateral.sub(amount);\\n  \\n        // transfer ETH to msg.sender\\n        msg.sender.sendValue(amount);\\n        \\n        // log \\n        emit Withdraw(msg.sender, amount);\\n                \\n        // transfer POOLER_FEE to updaterAddress\\n        updaterAddress.sendValue(msg.value);\\n    }\\n        \\n    /**\\n     * @notice sum total collaterals pledged\\n     */\\n    function _totalPledged() internal view override returns (uint amount) {\\n        for (uint i = 0;i\\u003c _options.length;i++) {\\n            amount += _options[i].totalSupply();\\n        }\\n    }\\n    \\n    /**\\n     * @dev function to calculate option profits\\n     */\\n    function _calcProfits(uint settlePrice, uint strikePrice, uint optionAmount) internal view override returns(uint256 profits) {\\n        // call options get profits due to price rising.\\n        if (settlePrice \\u003e strikePrice \\u0026\\u0026 strikePrice \\u003e 0) { \\n            // calculate ratio\\n            uint ratio = settlePrice.sub(strikePrice)\\n                                        .mul(1e12)              // mul by 1e12 here to avoid underflow\\n                                        .div(strikePrice);\\n            \\n            // calculate ETH profits of this amount\\n            uint holderETHProfit = ratio.mul(optionAmount)\\n                                        .div(1e12);         // remember to div by 1e12 previous mul-ed\\n            \\n            return holderETHProfit.mul(99).div(100);\\n        }\\n    }\\n\\n    /**\\n     * @dev send profits back to sender\\u0027s address\\n     */\\n    function _sendProfits(address payable account, uint256 amount) internal override {\\n        account.sendValue(amount);\\n    }\\n    \\n    /**\\n     * @dev get current new option supply\\n     */\\n    function _slotSupply(uint) internal view override returns(uint) {\\n        return collateral.mul(utilizationRate)\\n                            .div(100)\\n                            .div(_options.length);\\n    }\\n}\\n\\n/**\\n * @title Implementation of ERC20 Asset Call Option Pool\\n * ERC20 Asset Call Option Pool use ERC20 asset as collateral and bets\\n * on Chainlink Oracle Price Feed.\\n */\\ncontract ERC20CallOptionPool is PandaBase {\\n    string private _name;\\n    IERC20 public assetContract;\\n\\n    /**\\n     * @param priceFeed Chainlink contract for asset price\\n     * @param assetContract_ ERC20 asset contract address\\n     */\\n    constructor(string memory name_, IERC20 assetContract_, AggregatorV3Interface priceFeed)\\n        PandaBase(priceFeed, assetContract_.decimals(), PoolDirection.CALL)\\n        public { \\n            _name = name_;\\n            assetContract = assetContract_;\\n            poolerTokenContract = pandaFactory.createPoolerToken(assetContract.decimals(), IOptionPool(this));\\n        }\\n\\n    /**\\n     * @dev Returns the pool of the contract.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n    \\n    /**\\n     * @notice deposit asset to this pool directly.\\n     */\\n    function depositAsset(uint256 amountAsset) external whenPoolerNotPaused payable {\\n        require(amountAsset \\u003e 0, \\\"0 value\\\");\\n        require(msg.value \\u003e= POOLER_FEE, \\\"0 fee\\\");\\n\\n        // transfer POOLER_FEE to updaterAddress\\n        updaterAddress.sendValue(msg.value);\\n        \\n        assetContract.safeTransferFrom(msg.sender, address(this), amountAsset);\\n        poolerTokenContract.mint(msg.sender, amountAsset);\\n        collateral = collateral.add(amountAsset);\\n        \\n        // log\\n        emit Deposit(msg.sender, amountAsset);\\n    }\\n\\n    /**\\n     * @notice withdraw the pooled ethers;\\n     */\\n    function withdrawAsset(uint amountAsset) external whenPoolerNotPaused payable {\\n        require (amountAsset \\u003c= poolerTokenContract.balanceOf(msg.sender), \\\"balance exceeded\\\");\\n        require (amountAsset \\u003c= NWA(), \\\"collateral exceeded\\\");\\n        require(msg.value \\u003e= POOLER_FEE, \\\"0 fee\\\");\\n\\n        // transfer POOLER_FEE to updaterAddress\\n        updaterAddress.sendValue(msg.value);\\n        \\n        // burn pooler token\\n        poolerTokenContract.burn(msg.sender, amountAsset);\\n        // substract collateral\\n        collateral = collateral.sub(amountAsset);\\n\\n        // transfer asset back to msg.sender\\n        assetContract.safeTransfer(msg.sender, amountAsset);\\n        \\n        // log \\n        emit Withdraw(msg.sender, amountAsset);\\n    }\\n        \\n    /**\\n     * @notice sum total collaterals pledged\\n     */\\n    function _totalPledged() internal view override returns (uint amount) {\\n        for (uint i = 0;i\\u003c _options.length;i++) {   \\n            amount += _options[i].totalSupply();\\n        }\\n    }\\n\\n    /**\\n     * @dev send profits back to account\\n     */\\n    function _sendProfits(address payable account, uint256 amount) internal override {\\n        assetContract.safeTransfer(account, amount);\\n    }\\n\\n    /**\\n     * @dev function to calculate option profits\\n     */\\n    function _calcProfits(uint settlePrice, uint strikePrice, uint optionAmount) internal view override returns(uint256 profits) {\\n        // call options get profits due to price rising.\\n        if (settlePrice \\u003e strikePrice \\u0026\\u0026 strikePrice \\u003e 0) { \\n            // calculate ratio\\n            uint ratio = settlePrice.sub(strikePrice)\\n                                    .mul(1e12)          // mul by 1e12 here to avoid from underflow\\n                                    .div(strikePrice);\\n            \\n            // calculate asset profits of this amount\\n            uint holderAssetProfit = ratio.mul(optionAmount)\\n                                    .div(1e12);         // remember to div by 1e12 previous mul-ed\\n            \\n            return holderAssetProfit.mul(99).div(100);\\n        }\\n    }\\n\\n    /**\\n     * @notice get current new option supply\\n     */\\n    function _slotSupply(uint) internal view override returns(uint) {\\n        return collateral.mul(utilizationRate)\\n                            .div(100)\\n                            .div(_options.length);\\n    }\\n}\\n\\n/**\\n * @title Implementation of Put Option Pool\\n * Put Option Pool requires USDT as collateral and \\n * bets on Chainlink Oracle Price Feed of one asset.\\n */\\ncontract PutOptionPool is PandaBase {\\n    string private _name;\\n    uint private immutable assetPriceUnit;\\n    \\n    /**\\n     * @param priceFeed Chainlink contract for asset price\\n     * @param assetDecimal the decimal of the price\\n     */\\n    constructor(string memory name_, uint8 assetDecimal, AggregatorV3Interface priceFeed)\\n        PandaBase(priceFeed, assetDecimal, PoolDirection.PUT)\\n        public { \\n            _name = name_;\\n            assetPriceUnit = 10 ** uint(assetDecimal);\\n            poolerTokenContract = pandaFactory.createPoolerToken(USDTContract.decimals(), IOptionPool(this));\\n        }\\n\\n    /**\\n     * @dev Returns the pool of the contract.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @notice deposit of Tether USDTS, user needs\\n     * to approve() to this contract address first,\\n     * and call with the given amount.\\n     */\\n    function depositUSDT(uint256 amountUSDT) external whenPoolerNotPaused payable {\\n        require(amountUSDT \\u003e 0, \\\"0 value\\\");\\n        require(msg.value \\u003e= POOLER_FEE, \\\"0 fee\\\");\\n\\n        // transfer POOLER_FEE to updaterAddress\\n        updaterAddress.sendValue(msg.value);\\n        \\n        USDTContract.safeTransferFrom(msg.sender, address(this), amountUSDT);\\n        poolerTokenContract.mint(msg.sender, amountUSDT);\\n        collateral = collateral.add(amountUSDT);\\n        \\n        // log\\n        emit Deposit(msg.sender, amountUSDT);\\n    }\\n    \\n    /**\\n     * @notice withdraw the pooled USDT;\\n     */\\n    function withdrawUSDT(uint amountUSDT) external whenPoolerNotPaused payable {\\n        require (amountUSDT \\u003c= poolerTokenContract.balanceOf(msg.sender), \\\"balance exceeded\\\");\\n        require (amountUSDT \\u003c= NWA(), \\\"collateral exceeded\\\");\\n        require (msg.value \\u003e= POOLER_FEE, \\\"0 fee\\\");\\n\\n        // transfer POOLER_FEE to updaterAddress\\n        updaterAddress.sendValue(msg.value);\\n        \\n        // burn pooler token\\n        poolerTokenContract.burn(msg.sender, amountUSDT);\\n        // substract collateral\\n        collateral = collateral.sub(amountUSDT);\\n\\n        // transfer USDT to msg.sender\\n        USDTContract.safeTransfer(msg.sender, amountUSDT);\\n        \\n        // log \\n        emit Withdraw(msg.sender, amountUSDT);\\n    }\\n    \\n    /**\\n     * @notice sum total collaterals pledged\\n     */\\n    function _totalPledged() internal view override returns (uint) {\\n        // sum total collateral in USDT\\n        uint total;\\n        for (uint i = 0;i\\u003c _options.length;i++) {\\n            // derive collaterals at issue time\\n            total = total.add(_options[i].totalSupply() * _options[i].strikePrice());\\n        }\\n        \\n        // @dev remember to div with asset price unit\\n        total /= assetPriceUnit;        \\n        return total;\\n    }\\n\\n    /**\\n     * @dev send profits back to account\\n     */\\n    function _sendProfits(address payable account, uint256 amount) internal override {\\n        USDTContract.safeTransfer(account, amount);\\n    }\\n\\n    /**\\n     * @dev function to calculate option profits\\n     */\\n    function _calcProfits(uint settlePrice, uint strikePrice, uint optionAmount) internal view override returns(uint256 profits) {\\n        if (settlePrice \\u003c strikePrice \\u0026\\u0026 strikePrice \\u003e 0) {  // put option get profits at this round\\n            // calculate ratio\\n            uint ratio = strikePrice.sub(settlePrice)\\n                                    .mul(1e12)                  // mul 1e12 to avoid from underflow\\n                                    .div(strikePrice);\\n\\n            // holder share\\n            uint holderShare = ratio.mul(optionAmount);\\n\\n         \\n            // convert to USDT profits\\n            uint holderUSDTProfit = holderShare.mul(strikePrice)\\n                                    .div(1e12)                  // remember to div 1e12 previous multipied\\n                                    .div(assetPriceUnit);       // remember to div price unit\\n\\n            return holderUSDTProfit.mul(99).div(100);\\n        }\\n    }\\n\\n    /**\\n     * @notice get current new option supply\\n     */\\n    function _slotSupply(uint assetPrice) internal view override returns(uint) {\\n        // Formula : (collateral / numOptions) * utilizationRate / 100 / (assetPrice/ price unit)\\n       return collateral.mul(utilizationRate)\\n                            .mul(assetPriceUnit)\\n                            .div(100)\\n                            .div(_options.length)\\n                            .div(assetPrice);\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"assetDecimal\",\"type\":\"uint8\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"priceFeed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"optionContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premiumCost\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OPAClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockReward\",\"type\":\"uint256\"}],\"name\":\"OPARewardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PremiumClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premiumSettled\",\"type\":\"uint256\"}],\"name\":\"PremiumSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProfitsClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"optionContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitsSettled\",\"type\":\"uint256\"}],\"name\":\"ProfitsSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NWA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPABlockReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPAToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOLER_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VestingContract\",\"outputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_direction\",\"outputs\":[{\"internalType\":\"enum PandaBase.PoolDirection\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"newSigma\",\"type\":\"uint16\"}],\"name\":\"adjustSigma\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IOption\",\"name\":\"optionContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyerPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cdfDataContract\",\"outputs\":[{\"internalType\":\"contract CDFDataInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkOPA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"opa\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkProfits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"profits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOPA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPremium\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimProfits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentUtilizationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"name\":\"depositUSDT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listOptions\",\"outputs\":[{\"internalType\":\"contract IOption[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUtilizationRate\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOption\",\"name\":\"optionContract\",\"type\":\"address\"}],\"name\":\"optionsLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"optionsleft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausePooler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolerPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolerTokenContract\",\"outputs\":[{\"internalType\":\"contract IPoolerToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IOption\",\"name\":\"optionContract\",\"type\":\"address\"}],\"name\":\"premiumCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"maxrate\",\"type\":\"uint8\"}],\"name\":\"setMaxUtilizationRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"setOPAReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardAccount_\",\"type\":\"address\"}],\"name\":\"setOPARewardAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"OPAToken_\",\"type\":\"address\"}],\"name\":\"setOPAToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolManager_\",\"type\":\"address\"}],\"name\":\"setPoolManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setRefreshPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"updater_\",\"type\":\"address\"}],\"name\":\"setUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"rate\",\"type\":\"uint8\"}],\"name\":\"setUtilizationRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVesting\",\"name\":\"vestingContract_\",\"type\":\"address\"}],\"name\":\"setVestingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"settleBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"settlePooler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigma\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpausePooler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updaterAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilizationRate\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"name\":\"withdrawUSDT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "PutOptionPool", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000567f2323251f0aab15c8dfb1967e4e8a7d42aee0000000000000000000000000000000000000000000000000000000000000009424e422f55205055540000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f55f5d0ac872560c97da9db11ccdd03c0952be696968d67b3fcc662231c51293"}