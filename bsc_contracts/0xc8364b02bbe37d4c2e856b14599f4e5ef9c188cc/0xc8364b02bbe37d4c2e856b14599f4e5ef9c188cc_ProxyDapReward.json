{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/VsionSad/ProxyDapReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    function getAddressSlot(\\n        bytes32 slot\\n    ) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\\ncontract ProxyDapReward {\\n    // All functions / variables should be private, forward all calls to fallback\\n    // Ownable\\n    address private _owner;\\n    //ReentrancyGuard\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status;\\n    // -1 for unknown preimage\\n    // 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\n    bytes32 private constant IMPLEMENTATION_SLOT =\\n        bytes32(uint(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1);\\n    // 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n    bytes32 private constant ADMIN_SLOT =\\n        bytes32(uint(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n\\n    constructor() {\\n        _setAdmin(msg.sender);\\n    }\\n\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    function _getAdmin() private view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    function _setAdmin(address _admin) private {\\n        require(_admin != address(0), \\\"admin = zero address\\\");\\n        _owner = _admin;\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = _admin;\\n    }\\n\\n    function _getImplementation() private view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    function _setImplementation(address _implementation) private {\\n        require(\\n            _implementation.code.length > 0,\\n            \\\"implementation is not contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = _implementation;\\n    }\\n\\n    // Admin interface //\\n    function changeAdmin(address _admin) external ifAdmin {\\n        _setAdmin(_admin);\\n    }\\n\\n    // 0x3659cfe6\\n    function upgradeTo(address _implementation) external ifAdmin {\\n        _setImplementation(_implementation);\\n    }\\n\\n    // 0xf851a440\\n    function admin() external ifAdmin returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    // 0x5c60da1b\\n    function implementation() external ifAdmin returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    // User interface //\\n    function _delegate(address _implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n\\n            // calldatacopy(t, f, s) - copy s bytes from calldata at position f to mem at position t\\n            // calldatasize() - size of call data in bytes\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n\\n            // delegatecall(g, a, in, insize, out, outsize) -\\n            // - call contract at address a\\n            // - with input mem[in\u2026(in+insize))\\n            // - providing g gas\\n            // - and output area mem[out\u2026(out+outsize))\\n            // - returning 0 on error (eg. out of gas) and 1 on success\\n            let result := delegatecall(\\n                gas(),\\n                _implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n\\n            // Copy the returned data.\\n            // returndatacopy(t, f, s) - copy s bytes from returndata at position f to mem at position t\\n            // returndatasize() - size of the last returndata\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                // revert(p, s) - end execution, revert state changes, return data mem[p\u2026(p+s))\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                // return(p, s) - end execution, return data mem[p\u2026(p+s))\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function _fallback() private {\\n        _delegate(_getImplementation());\\n    }\\n\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    receive() external payable {\\n        _fallback();\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ProxyDapReward", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}