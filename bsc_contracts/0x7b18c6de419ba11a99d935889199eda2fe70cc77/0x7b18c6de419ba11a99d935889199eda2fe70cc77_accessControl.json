{"SourceCode": "// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/security/Pausable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: QR/AccessControl.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract accessControl is Ownable, Pausable{\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter public _fileIdCounter;\r\n    enum accessType {VIEWER,EDITOR,ADMIN,MANAGER}\r\n    struct User{\r\n        string name;\r\n        accessType typeAcess;\r\n        uint[] directories;\r\n        bool canAccessAll;\r\n    } \r\n    // mapping the user by wallet\r\n    mapping(address=>User) usersList;\r\n    // user sessions registered the last 7 times\r\n    mapping(address=>uint[7]) private UserSessions;\r\n    // user current session index\r\n    mapping(address=>uint) private userCurrentSessionIndex;\r\n    // files Id created by the owner\r\n    uint256[] private _filesId;    \r\n    // users can access all files\r\n    address[] private admins;\r\n    // user => session expires in\r\n    mapping(address=>uint) internal userAccess;\r\n    ////////////////////// EVENTS //////////////////////\r\n    event fileCreated(uint _idFile);\r\n    event userCreated(address wallet,accessType access , uint [] directories, bool canAccessAll);   \r\n    event accessGranted(address _user, uint[] _idFiles);\r\n    event accessRevoked(address _user, uint[] _idFiles);\r\n    event userTemporaryAccess(address _user, uint _expiresIn);\r\n    event sessionCreated(address _user, uint _session);\r\n    event adminAccess(address _user);\r\n    event adminAccessRevoked(address _user);\r\n    event AllAccessRevoked(address _user);\r\n    event revokeSession(address wallet);\r\n\r\n    constructor(){\r\n         usersList[_msgSender()] = User(\"Admin\",accessType.ADMIN,(new uint[](0)),true);\r\n         setUserAdminAccess(_msgSender());\r\n         _fileIdCounter.increment();\r\n         createFile();\r\n    }\r\n\r\n    function existsFile(uint idFile) public view returns(bool _exists){\r\n        for(uint i = 0; i < _filesId.length; i++){\r\n            if(idFile == _filesId[i])\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function userHasAccess(address wallet,uint idFile) private view returns(bool _exists){\r\n        for(uint i = 0; i < usersList[wallet].directories.length; i++){\r\n            if(idFile == usersList[wallet].directories[i])\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createFile() public onlyOwner{\r\n        require(_fileIdCounter.current() <= 50,\"Limit of 50 files per contract\");\r\n        _filesId.push(_fileIdCounter.current());\r\n        for(uint i = 0; i < admins.length; i++){\r\n            usersList[admins[i]].directories.push(_fileIdCounter.current());\r\n        }\r\n        emit fileCreated(_fileIdCounter.current());\r\n        _fileIdCounter.increment();\r\n    }\r\n\r\n    function createUser(address wallet, uint typeUser, uint[] memory files, string memory userName ,bool canAccessAll)public onlyOwner{\r\n        require(bytes(usersList[wallet].name).length < 1, \"user already exists\");\r\n        require(bytes(userName).length > 0, \"username can't be empty\");\r\n        require(typeUser < 4 && typeUser != 2, \"invalid user type\");\r\n        require(files.length > 0, \"No files id provided\");\r\n        for(uint i = 0; i < files.length; i++){\r\n            require(existsFile(files[i]),\"a file doesn't exists\");\r\n        }\r\n        usersList[wallet] = User(userName,accessType(typeUser),files,canAccessAll);\r\n        if(canAccessAll)\r\n            setUserAdminAccess(wallet);   \r\n        emit userCreated(wallet,accessType(typeUser),files,canAccessAll);     \r\n    }\r\n    \r\n    function grantFileAccess(address wallet, uint[] calldata filesId) public onlyOwner{\r\n        require(filesId.length > 0, \"files not provided\");\r\n        require(wallet != address(0), \"can't give null address permissions\");\r\n        for(uint i = 0; i<filesId.length; i++){\r\n            require(existsFile(filesId[i]),\"File doesn't exists\");\r\n            require(!userHasAccess(wallet,filesId[i]),\"User already has access to a selected file\");\r\n            usersList[wallet].directories.push(filesId[i]);\r\n        }\r\n        emit accessGranted(wallet,filesId);\r\n    }\r\n\r\n    function revokeFileAccess(address user, uint[] calldata filesId) public onlyOwner{\r\n        require(filesId.length > 0, \"files not provided\");\r\n        require(user != address(0), \"can't revoke null address permissions\");\r\n        uint len = usersList[user].directories.length;\r\n        require(len > 0, \"User doesn't have access to files\");\r\n        for(uint i = 0; i < filesId.length; i++){\r\n            for(uint j = 0; j < usersList[user].directories.length; j++){\r\n                if(usersList[user].directories[j] == filesId[i]){\r\n                    delete usersList[user].directories[j];\r\n                    len--;\r\n                }\r\n        }\r\n        }\r\n        uint[] memory temp = new uint[](len);\r\n        uint index = 0;\r\n        for(uint i = 0; i < usersList[user].directories.length;i++){\r\n            if(usersList[user].directories[i] != 0){\r\n                temp[index] = usersList[user].directories[i];\r\n                index++;\r\n            }\r\n        }\r\n        usersList[user].directories = temp;\r\n        emit accessRevoked(user, filesId);\r\n    }\r\n\r\n    function getuserFilesAcess(address user) public view returns(uint[] memory filesCanAccess){\r\n        return usersList[user].directories;\r\n    }\r\n\r\n    modifier hasAccess(){\r\n        require(userAccess[_msgSender()] > block.timestamp, \"user doesn't have any access\");\r\n        _;\r\n    }\r\n\r\n    function setUserAccess(address user, uint expiresIn)public onlyOwner{\r\n        require(user != address(0), \"null address provided\");\r\n        require(expiresIn > 0, \"time must be greater than 0\");\r\n        uint _expiresIn =  block.timestamp+(1 days * expiresIn);\r\n        userAccess[user] = _expiresIn;\r\n        emit userTemporaryAccess(user,_expiresIn);\r\n    }\r\n\r\n    function userSession() public hasAccess{\r\n        uint sessionTime = block.timestamp;\r\n        UserSessions[_msgSender()][userCurrentSessionIndex[_msgSender()]] = sessionTime;\r\n        if(userCurrentSessionIndex[_msgSender()] == 6)\r\n            userCurrentSessionIndex[_msgSender()] = 0;\r\n        else\r\n            userCurrentSessionIndex[_msgSender()] += 1;\r\n        emit sessionCreated(_msgSender(),sessionTime);\r\n    }\r\n\r\n    function getUserSessions(address wallet) public view returns(uint[7] memory sessions){\r\n        return UserSessions[wallet];\r\n    }\r\n\r\n    function getUserCurrentSession(address wallet) public view returns(uint _expiresIn){\r\n        return userAccess[wallet];\r\n    }\r\n\r\n    function revokeSessionUser(address wallet) public onlyOwner{\r\n        require(userAccess[wallet] > 0 , \"user doesn't have a session to revoke\");\r\n        delete userAccess[wallet];\r\n        emit revokeSession(wallet);\r\n    }\r\n\r\n    function setUserAdminAccess(address wallet) public onlyOwner{\r\n        require(!existsAdmin(wallet), \"wallet already exists in admin list\");\r\n        admins.push(wallet);\r\n        usersList[wallet].canAccessAll = true;\r\n        setAdminAccess(wallet);\r\n        emit adminAccess(wallet);\r\n    }\r\n\r\n    function existsAdmin(address wallet) internal view returns (bool){\r\n        for(uint i = 0; i < admins.length; i++){\r\n            if(admins[i] == wallet){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function setAdminAccess(address wallet) internal onlyOwner{\r\n        usersList[wallet].directories = _filesId;\r\n    }\r\n\r\n    function revokeAllAccess(address wallet) public onlyOwner{\r\n        delete usersList[wallet].directories;\r\n        if(existsAdmin(wallet)){\r\n            removeAdmin(wallet);\r\n        }\r\n        emit AllAccessRevoked(wallet);\r\n    }\r\n\r\n    function getAdminIndex(address wallet) internal view returns(uint value){\r\n        for(uint i = 0; i < admins.length; i++){\r\n            if(admins[i] == wallet)\r\n                return i;\r\n        }\r\n        return (2 ** 256) - 1;\r\n    }\r\n\r\n    function removeAdmin(address wallet) public onlyOwner{\r\n        uint index = getAdminIndex(wallet);\r\n        require(index < ((2**256) - 1),\"Error searching admin wallet!\");\r\n        admins[index] = admins[admins.length - 1];\r\n        usersList[wallet].canAccessAll = false;\r\n        admins.pop();  \r\n        emit adminAccessRevoked(wallet);\r\n    }\r\n\r\n    function getAdmins() public view returns(address [] memory AdminAccessList){\r\n        return admins;\r\n    }\r\n\r\n    function getUserData(address wallet) public view returns(User memory){\r\n        return usersList[wallet];\r\n    }\r\n\r\n    function transferOwnership(address newOwner) override public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        delete usersList[owner()];\r\n        revokeAllAccess(owner());\r\n        usersList[newOwner] = User(\"Admin\",accessType.ADMIN,(new uint[](0)),true);\r\n        setUserAdminAccess(newOwner);\r\n        setUserAccess(newOwner,1);\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AllAccessRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_idFiles\",\"type\":\"uint256[]\"}],\"name\":\"accessGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_idFiles\",\"type\":\"uint256[]\"}],\"name\":\"accessRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"adminAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"adminAccessRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_idFile\",\"type\":\"uint256\"}],\"name\":\"fileCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"revokeSession\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_session\",\"type\":\"uint256\"}],\"name\":\"sessionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum accessControl.accessType\",\"name\":\"access\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"directories\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canAccessAll\",\"type\":\"bool\"}],\"name\":\"userCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_expiresIn\",\"type\":\"uint256\"}],\"name\":\"userTemporaryAccess\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_fileIdCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createFile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"typeUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"files\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"userName\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"canAccessAll\",\"type\":\"bool\"}],\"name\":\"createUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idFile\",\"type\":\"uint256\"}],\"name\":\"existsFile\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmins\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"AdminAccessList\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getUserCurrentSession\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_expiresIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"enum accessControl.accessType\",\"name\":\"typeAcess\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"directories\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"canAccessAll\",\"type\":\"bool\"}],\"internalType\":\"struct accessControl.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getUserSessions\",\"outputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"sessions\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getuserFilesAcess\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"filesCanAccess\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"filesId\",\"type\":\"uint256[]\"}],\"name\":\"grantFileAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"revokeAllAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"filesId\",\"type\":\"uint256[]\"}],\"name\":\"revokeFileAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"revokeSessionUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiresIn\",\"type\":\"uint256\"}],\"name\":\"setUserAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setUserAdminAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userSession\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "accessControl", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://895886130e801724c3ca466ae9f6aa1dd2a38bdf675bd0cd892bdf096a087820"}