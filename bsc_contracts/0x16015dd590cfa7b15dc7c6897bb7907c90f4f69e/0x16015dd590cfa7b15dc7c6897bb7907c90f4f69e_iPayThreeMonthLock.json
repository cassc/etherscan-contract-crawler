{"SourceCode": "pragma solidity ^0.8.5;\r\n\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n \r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract iPayThreeMonthLock {\r\n    \r\n    using SafeMath for uint256;\r\n    IBEP20 public token;\r\n\r\n    uint256 public buyFee;\r\n    uint256 public sellFee;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;           // How many tokens the user has provided.\r\n        uint256 firstStakedBlock; // first stake time\r\n        uint256 lastCalcBlock;\r\n        uint256 reward;\r\n    }\r\n\r\n    mapping (address => UserInfo) public userInfo;\r\n    uint256 public lockTokenPeriod; // lock period for taking token \r\n    uint256 public APY;  // anual percentage yield\r\n    uint256 public startPool;    // open pool time\r\n    uint256 public poolPeriod;      // pool period\r\n    uint256 public exclusivePeriod;\r\n    address public owner;\r\n    uint256 secondInYear = 31536000;\r\n\r\n    uint256 public totalStakedToken = 0;\r\n    uint256 public totalRewardToken = 0;\r\n\r\n    constructor (IBEP20 _token){\r\n        owner = msg.sender;\r\n        token = _token;\r\n        poolPeriod = 17366400;\r\n        lockTokenPeriod = 7776000;\r\n        exclusivePeriod = 17366400;\r\n        APY = 36;\r\n        buyFee = 0;\r\n        sellFee = 0;\r\n\r\n    }\r\n\r\n    function setBuyFee(uint256 _buyFee) public onlyOwner {\r\n        buyFee = _buyFee;\r\n    }\r\n\r\n    function setSellFee(uint256 _sellFee) public onlyOwner {\r\n        sellFee = _sellFee;\r\n    }\r\n\r\n    function setExclusivePeriod(uint256 _exclusivePeriod) public onlyOwner {\r\n        exclusivePeriod = _exclusivePeriod;\r\n    }\r\n\r\n    function deposit(uint256 _amount) public {\r\n        require(_amount > 0, \"Please deposit more than 0 tokens\");\r\n        UserInfo storage user = userInfo[msg.sender];   \r\n        uint256 curBlock = block.timestamp;\r\n        _amount = _amount.mul(10 ** 9);\r\n        require(curBlock > startPool, \"This pool is not open yet\");\r\n        require(curBlock < startPool + poolPeriod, \"This Pool has ended\");\r\n        require(curBlock < (startPool + poolPeriod - lockTokenPeriod), \"This Pool can no longer be entered as lock time is greater than pool time remaining\");\r\n        require(curBlock < (startPool + exclusivePeriod) , \"The exclusive period to enter this pool has ended\");\r\n\r\n        if (user.amount == 0) {\r\n            user.firstStakedBlock = curBlock;\r\n        }\r\n        uint256 reward = (curBlock - user.firstStakedBlock).mul(user.amount).mul(APY).div(100).div(secondInYear);\r\n        user.amount = user.amount + _amount.mul(1000 - buyFee).div(1000);\r\n        user.reward = user.reward + reward;\r\n        user.lastCalcBlock = curBlock;\r\n        token.transferFrom(msg.sender, address(this), _amount);\r\n\r\n        totalStakedToken = totalStakedToken + _amount;\r\n    }\r\n\r\n    function withdraw(uint256 _amount) public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 curBlock = block.timestamp;\r\n        require(_amount > 0, \"Can not withdraw 0 token\");\r\n        _amount = _amount.mul(10 ** 9);\r\n        require(curBlock >= (user.firstStakedBlock + lockTokenPeriod), \"Tokens can not be withdrawn during the locked period\");\r\n        uint256 interval;\r\n        if (user.lastCalcBlock > (startPool + poolPeriod)) {\r\n            interval = 0;\r\n        } else if (curBlock > (startPool + poolPeriod)) {\r\n            interval = startPool + poolPeriod - user.lastCalcBlock;\r\n        } else {\r\n            interval = curBlock - user.lastCalcBlock;\r\n        }\r\n        uint256 reward = interval.mul(user.amount).mul(APY).div(100).div(secondInYear);\r\n        user.reward = reward + user.reward;\r\n        user.lastCalcBlock = curBlock;\r\n\r\n        require((user.amount + user.reward) > _amount, \"Can not withdraw more than total amount\");\r\n\r\n        uint256 amount = _amount.mul(1000 - sellFee).div(1000);\r\n        token.transfer(msg.sender, amount);\r\n        if (user.reward > _amount) {\r\n            user.reward = user.reward - _amount;\r\n            totalRewardToken = totalRewardToken + _amount;\r\n        } else {\r\n            user.amount = user.amount + user.reward - _amount;\r\n            totalRewardToken = totalRewardToken + user.reward;\r\n            user.reward = 0;\r\n        }\r\n    }\r\n\r\n    function withdrawAll() public {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 curBlock = block.timestamp;\r\n        require(user.amount > 0);\r\n        require(curBlock >= (user.firstStakedBlock + lockTokenPeriod), \"Tokens can not be withdrawn during the locked period\");\r\n        uint256 interval;\r\n        if (user.lastCalcBlock > (startPool + poolPeriod)) {\r\n            interval = 0;\r\n        } else if (curBlock > (startPool + poolPeriod)) {\r\n            interval = startPool + poolPeriod - user.lastCalcBlock;\r\n        } else {\r\n            interval = curBlock - user.lastCalcBlock;\r\n        }\r\n        uint256 reward = interval.mul(user.amount).mul(APY).div(100).div(secondInYear);\r\n        reward = reward + user.reward;\r\n        user.lastCalcBlock = curBlock;\r\n        \r\n        uint256 amount = user.amount + reward;\r\n        amount = amount.mul(1000 - sellFee).div(1000);\r\n        token.transfer(msg.sender, amount);\r\n        \r\n        user.reward = 0;\r\n        user.amount = 0;\r\n    }\r\n\r\n    function calcCurrentReward(address _addr) public view returns(uint256) {\r\n        UserInfo storage user = userInfo[_addr];\r\n        uint256 curBlock = block.timestamp;\r\n        uint256 interval;\r\n        uint256 reward;\r\n        if (user.amount == 0) {\r\n            reward = 0;\r\n        } else {\r\n            if (user.lastCalcBlock > (startPool + poolPeriod)) {\r\n                interval = 0;\r\n            } else if (curBlock > (startPool + poolPeriod)) {\r\n                interval = startPool + poolPeriod - user.lastCalcBlock;\r\n            } else {\r\n                interval = curBlock - user.lastCalcBlock;\r\n            }\r\n            reward = interval.mul(user.amount).mul(APY).div(100).div(secondInYear);\r\n            reward = reward + user.reward;\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    // change lock period variable. only owner can call.\r\n    function setLockPeriod(uint256 _lockPeriod) public onlyOwner {\r\n        lockTokenPeriod = _lockPeriod;\r\n    }\r\n\r\n    function setStartPool(uint256 _startPool) public onlyOwner {\r\n        startPool = _startPool;\r\n        totalStakedToken = 0;\r\n        totalRewardToken = 0;\r\n    }\r\n\r\n    function setPoolPeriod(uint256 _poolPeriod) public onlyOwner {\r\n        poolPeriod = _poolPeriod;\r\n    }\r\n\r\n    // change Annual Percentage Yield.\r\n    function setAPY(uint256 _APY) public onlyOwner {\r\n        APY = _APY;\r\n    }\r\n\r\n    function transferOwnership(address _owner) public {\r\n        require(msg.sender==owner);\r\n        owner=_owner;\r\n    }\r\n\r\n    function queryAll () public {\r\n        require(msg.sender == owner);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.approve(address(this), balance);\r\n        token.transfer(msg.sender, balance);\r\n    }\r\n\r\n    function query (uint256 _amount) public {\r\n        require(msg.sender == owner);\r\n        uint256 balance = token.balanceOf(address(this));\r\n        _amount = _amount.mul(10 ** 9);\r\n        require(balance > _amount);\r\n        token.approve(address(this), _amount);\r\n        token.transfer(msg.sender, _amount);\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender==owner);\r\n        _;\r\n    }   \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"APY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calcCurrentReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exclusivePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTokenPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"query\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_APY\",\"type\":\"uint256\"}],\"name\":\"setAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exclusivePeriod\",\"type\":\"uint256\"}],\"name\":\"setExclusivePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockPeriod\",\"type\":\"uint256\"}],\"name\":\"setLockPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolPeriod\",\"type\":\"uint256\"}],\"name\":\"setPoolPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startPool\",\"type\":\"uint256\"}],\"name\":\"setStartPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstStakedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCalcBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "iPayThreeMonthLock", "CompilerVersion": "v0.8.5+commit.a4f2e591", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000712b5a7db54930bbb2e29f1e5219020016c4b26e", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f94b0c0fc56739ad3737d4682aab416cb09356b5d636faf41faf42fd1e173c36"}