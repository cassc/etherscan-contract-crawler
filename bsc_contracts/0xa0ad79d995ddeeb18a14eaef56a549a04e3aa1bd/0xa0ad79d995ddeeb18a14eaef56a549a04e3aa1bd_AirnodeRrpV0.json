{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/rrp/AirnodeRrpV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./AuthorizationUtilsV0.sol\\\";\\nimport \\\"./TemplateUtilsV0.sol\\\";\\nimport \\\"./WithdrawalUtilsV0.sol\\\";\\nimport \\\"./interfaces/IAirnodeRrpV0.sol\\\";\\n\\n/// @title Contract that implements the Airnode request\u2013response protocol (RRP)\\ncontract AirnodeRrpV0 is\\n    AuthorizationUtilsV0,\\n    TemplateUtilsV0,\\n    WithdrawalUtilsV0,\\n    IAirnodeRrpV0\\n{\\n    using ECDSA for bytes32;\\n\\n    /// @notice Called to get the sponsorship status for a sponsor\u2013requester\\n    /// pair\\n    mapping(address => mapping(address => bool))\\n        public\\n        override sponsorToRequesterToSponsorshipStatus;\\n\\n    /// @notice Called to get the request count of the requester plus one\\n    /// @dev Can be used to calculate the ID of the next request the requester\\n    /// will make\\n    mapping(address => uint256) public override requesterToRequestCountPlusOne;\\n\\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\\n    /// the fulfillment will be done with the correct parameters. This value is\\n    /// also used to check if the fulfillment for the particular request is\\n    /// expected, i.e., if there are recorded fulfillment parameters.\\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\\n\\n    /// @notice Called by the sponsor to set the sponsorship status of a\\n    /// requester, i.e., allow or disallow a requester to make requests that\\n    /// will be fulfilled by the sponsor wallet\\n    /// @dev This is not Airnode-specific, i.e., the sponsor allows the\\n    /// requester's requests to be fulfilled through its sponsor wallets across\\n    /// all Airnodes\\n    /// @param requester Requester address\\n    /// @param sponsorshipStatus Sponsorship status\\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\\n        external\\n        override\\n    {\\n        // Initialize the requester request count for consistent request gas\\n        // cost\\n        if (requesterToRequestCountPlusOne[requester] == 0) {\\n            requesterToRequestCountPlusOne[requester] = 1;\\n        }\\n        sponsorToRequesterToSponsorshipStatus[msg.sender][\\n            requester\\n        ] = sponsorshipStatus;\\n        emit SetSponsorshipStatus(msg.sender, requester, sponsorshipStatus);\\n    }\\n\\n    /// @notice Called by the requester to make a request that refers to a\\n    /// template for the Airnode address, endpoint ID and parameters\\n    /// @dev `fulfillAddress` is not allowed to be the address of this\\n    /// contract. This is not actually needed to protect users that use the\\n    /// protocol as intended, but it is done for good measure.\\n    /// @param templateId Template ID\\n    /// @param sponsor Sponsor address\\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill the\\n    /// request\\n    /// @param fulfillAddress Address that will be called to fulfill\\n    /// @param fulfillFunctionId Signature of the function that will be called\\n    /// to fulfill\\n    /// @param parameters Parameters provided by the requester in addition to\\n    /// the parameters in the template\\n    /// @return requestId Request ID\\n    function makeTemplateRequest(\\n        bytes32 templateId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata parameters\\n    ) external override returns (bytes32 requestId) {\\n        address airnode = templates[templateId].airnode;\\n        // If the Airnode address of the template is zero the template does not\\n        // exist because template creation does not allow zero Airnode address\\n        require(airnode != address(0), \\\"Template does not exist\\\");\\n        require(fulfillAddress != address(this), \\\"Fulfill address AirnodeRrp\\\");\\n        require(\\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\\n            \\\"Requester not sponsored\\\"\\n        );\\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\\n            msg.sender\\n        ];\\n        requestId = keccak256(\\n            abi.encodePacked(\\n                block.chainid,\\n                address(this),\\n                msg.sender,\\n                requesterRequestCount,\\n                templateId,\\n                sponsor,\\n                sponsorWallet,\\n                fulfillAddress,\\n                fulfillFunctionId,\\n                parameters\\n            )\\n        );\\n        requestIdToFulfillmentParameters[requestId] = keccak256(\\n            abi.encodePacked(\\n                airnode,\\n                sponsorWallet,\\n                fulfillAddress,\\n                fulfillFunctionId\\n            )\\n        );\\n        requesterToRequestCountPlusOne[msg.sender]++;\\n        emit MadeTemplateRequest(\\n            airnode,\\n            requestId,\\n            requesterRequestCount,\\n            block.chainid,\\n            msg.sender,\\n            templateId,\\n            sponsor,\\n            sponsorWallet,\\n            fulfillAddress,\\n            fulfillFunctionId,\\n            parameters\\n        );\\n    }\\n\\n    /// @notice Called by the requester to make a full request, which provides\\n    /// all of its parameters as arguments and does not refer to a template\\n    /// @dev `fulfillAddress` is not allowed to be the address of this\\n    /// contract. This is not actually needed to protect users that use the\\n    /// protocol as intended, but it is done for good measure.\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\\n    /// @param sponsor Sponsor address\\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\\n    /// the request\\n    /// @param fulfillAddress Address that will be called to fulfill\\n    /// @param fulfillFunctionId Signature of the function that will be called\\n    /// to fulfill\\n    /// @param parameters All request parameters\\n    /// @return requestId Request ID\\n    function makeFullRequest(\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata parameters\\n    ) external override returns (bytes32 requestId) {\\n        require(airnode != address(0), \\\"Airnode address zero\\\");\\n        require(fulfillAddress != address(this), \\\"Fulfill address AirnodeRrp\\\");\\n        require(\\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\\n            \\\"Requester not sponsored\\\"\\n        );\\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\\n            msg.sender\\n        ];\\n        requestId = keccak256(\\n            abi.encodePacked(\\n                block.chainid,\\n                address(this),\\n                msg.sender,\\n                requesterRequestCount,\\n                airnode,\\n                endpointId,\\n                sponsor,\\n                sponsorWallet,\\n                fulfillAddress,\\n                fulfillFunctionId,\\n                parameters\\n            )\\n        );\\n        requestIdToFulfillmentParameters[requestId] = keccak256(\\n            abi.encodePacked(\\n                airnode,\\n                sponsorWallet,\\n                fulfillAddress,\\n                fulfillFunctionId\\n            )\\n        );\\n        requesterToRequestCountPlusOne[msg.sender]++;\\n        emit MadeFullRequest(\\n            airnode,\\n            requestId,\\n            requesterRequestCount,\\n            block.chainid,\\n            msg.sender,\\n            endpointId,\\n            sponsor,\\n            sponsorWallet,\\n            fulfillAddress,\\n            fulfillFunctionId,\\n            parameters\\n        );\\n    }\\n\\n    /// @notice Called by Airnode to fulfill the request (template or full)\\n    /// @dev The data is ABI-encoded as a `bytes` type, with its format\\n    /// depending on the request specifications.\\n    /// This will not revert depending on the external call. However, it will\\n    /// return `false` if the external call reverts or if there is no function\\n    /// with a matching signature at `fulfillAddress`. On the other hand, it\\n    /// will return `true` if the external call returns successfully or if\\n    /// there is no contract deployed at `fulfillAddress`.\\n    /// If `callSuccess` is `false`, `callData` can be decoded to retrieve the\\n    /// revert string.\\n    /// This function emits its event after an untrusted low-level call,\\n    /// meaning that the order of these events within the transaction should\\n    /// not be taken seriously, yet the content will be sound.\\n    /// @param requestId Request ID\\n    /// @param airnode Airnode address\\n    /// @param data Fulfillment data\\n    /// @param fulfillAddress Address that will be called to fulfill\\n    /// @param fulfillFunctionId Signature of the function that will be called\\n    /// to fulfill\\n    /// @return callSuccess If the fulfillment call succeeded\\n    /// @return callData Data returned by the fulfillment call (if there is\\n    /// any)\\n    function fulfill(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external override returns (bool callSuccess, bytes memory callData) {\\n        require(\\n            keccak256(\\n                abi.encodePacked(\\n                    airnode,\\n                    msg.sender,\\n                    fulfillAddress,\\n                    fulfillFunctionId\\n                )\\n            ) == requestIdToFulfillmentParameters[requestId],\\n            \\\"Invalid request fulfillment\\\"\\n        );\\n        require(\\n            (\\n                keccak256(abi.encodePacked(requestId, data))\\n                    .toEthSignedMessageHash()\\n            ).recover(signature) == airnode,\\n            \\\"Invalid signature\\\"\\n        );\\n        delete requestIdToFulfillmentParameters[requestId];\\n        (callSuccess, callData) = fulfillAddress.call( // solhint-disable-line avoid-low-level-calls\\n            abi.encodeWithSelector(fulfillFunctionId, requestId, data)\\n        );\\n        if (callSuccess) {\\n            emit FulfilledRequest(airnode, requestId, data);\\n        } else {\\n            // We do not bubble up the revert string from `callData`\\n            emit FailedRequest(\\n                airnode,\\n                requestId,\\n                \\\"Fulfillment failed unexpectedly\\\"\\n            );\\n        }\\n    }\\n\\n    /// @notice Called by Airnode if the request cannot be fulfilled\\n    /// @dev Airnode should fall back to this if a request cannot be fulfilled\\n    /// because static call to `fulfill()` returns `false` for `callSuccess`\\n    /// @param requestId Request ID\\n    /// @param airnode Airnode address\\n    /// @param fulfillAddress Address that will be called to fulfill\\n    /// @param fulfillFunctionId Signature of the function that will be called\\n    /// to fulfill\\n    /// @param errorMessage A message that explains why the request has failed\\n    function fail(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        string calldata errorMessage\\n    ) external override {\\n        require(\\n            keccak256(\\n                abi.encodePacked(\\n                    airnode,\\n                    msg.sender,\\n                    fulfillAddress,\\n                    fulfillFunctionId\\n                )\\n            ) == requestIdToFulfillmentParameters[requestId],\\n            \\\"Invalid request fulfillment\\\"\\n        );\\n        delete requestIdToFulfillmentParameters[requestId];\\n        emit FailedRequest(airnode, requestId, errorMessage);\\n    }\\n\\n    /// @notice Called to check if the request with the ID is made but not\\n    /// fulfilled/failed yet\\n    /// @dev If a requester has made a request, received a request ID but did\\n    /// not hear back, it can call this method to check if the Airnode has\\n    /// called back `fail()` instead.\\n    /// @param requestId Request ID\\n    /// @return isAwaitingFulfillment If the request is awaiting fulfillment\\n    /// (i.e., `true` if `fulfill()` or `fail()` is not called back yet,\\n    /// `false` otherwise)\\n    function requestIsAwaitingFulfillment(bytes32 requestId)\\n        external\\n        view\\n        override\\n        returns (bool isAwaitingFulfillment)\\n    {\\n        isAwaitingFulfillment =\\n            requestIdToFulfillmentParameters[requestId] != bytes32(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/AuthorizationUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IAuthorizationUtilsV0.sol\\\";\\nimport \\\"../authorizers/interfaces/IAuthorizerV0.sol\\\";\\n\\n/// @title Contract that implements authorization checks\\ncontract AuthorizationUtilsV0 is IAuthorizationUtilsV0 {\\n    /// @notice Uses the authorizer contracts of an Airnode to decide if a\\n    /// request is authorized. Once an Airnode receives a request, it calls\\n    /// this method to determine if it should respond. Similarly, third parties\\n    /// can use this method to determine if a particular request would be\\n    /// authorized.\\n    /// @dev This method is meant to be called off-chain, statically by the\\n    /// Airnode to decide if it should respond to a request. The requester can\\n    /// also call it, yet this function returning true should not be taken as a\\n    /// guarantee of the subsequent request being fulfilled.\\n    /// It is enough for only one of the authorizer contracts to return true\\n    /// for the request to be authorized.\\n    /// @param authorizers Authorizer contract addresses\\n    /// @param airnode Airnode address\\n    /// @param requestId Request ID\\n    /// @param endpointId Endpoint ID\\n    /// @param sponsor Sponsor address\\n    /// @param requester Requester address\\n    /// @return status Authorization status of the request\\n    function checkAuthorizationStatus(\\n        address[] calldata authorizers,\\n        address airnode,\\n        bytes32 requestId,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address requester\\n    ) public view override returns (bool status) {\\n        for (uint256 ind = 0; ind < authorizers.length; ind++) {\\n            IAuthorizerV0 authorizer = IAuthorizerV0(authorizers[ind]);\\n            if (\\n                authorizer.isAuthorizedV0(\\n                    requestId,\\n                    airnode,\\n                    endpointId,\\n                    sponsor,\\n                    requester\\n                )\\n            ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @notice A convenience function to make multiple authorization status\\n    /// checks with a single call\\n    /// @param authorizers Authorizer contract addresses\\n    /// @param airnode Airnode address\\n    /// @param requestIds Request IDs\\n    /// @param endpointIds Endpoint IDs\\n    /// @param sponsors Sponsor addresses\\n    /// @param requesters Requester addresses\\n    /// @return statuses Authorization statuses of the request\\n    function checkAuthorizationStatuses(\\n        address[] calldata authorizers,\\n        address airnode,\\n        bytes32[] calldata requestIds,\\n        bytes32[] calldata endpointIds,\\n        address[] calldata sponsors,\\n        address[] calldata requesters\\n    ) external view override returns (bool[] memory statuses) {\\n        require(\\n            requestIds.length == endpointIds.length &&\\n                requestIds.length == sponsors.length &&\\n                requestIds.length == requesters.length,\\n            \\\"Unequal parameter lengths\\\"\\n        );\\n        statuses = new bool[](requestIds.length);\\n        for (uint256 ind = 0; ind < requestIds.length; ind++) {\\n            statuses[ind] = checkAuthorizationStatus(\\n                authorizers,\\n                airnode,\\n                requestIds[ind],\\n                endpointIds[ind],\\n                sponsors[ind],\\n                requesters[ind]\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/TemplateUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/ITemplateUtilsV0.sol\\\";\\n\\n/// @title Contract that implements request templates\\ncontract TemplateUtilsV0 is ITemplateUtilsV0 {\\n    struct Template {\\n        address airnode;\\n        bytes32 endpointId;\\n        bytes parameters;\\n    }\\n\\n    /// @notice Called to get a template\\n    mapping(bytes32 => Template) public override templates;\\n\\n    /// @notice Creates a request template with the given parameters,\\n    /// addressable by the ID it returns\\n    /// @dev A specific set of request parameters will always have the same\\n    /// template ID. This means a few things: (1) You can compute the expected\\n    /// ID of a template before creating it, (2) Creating a new template with\\n    /// the same parameters will overwrite the old one and return the same ID,\\n    /// (3) After you query a template with its ID, you can verify its\\n    /// integrity by applying the hash and comparing the result with the ID.\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\\n    /// @param parameters Static request parameters (i.e., parameters that will\\n    /// not change between requests, unlike the dynamic parameters determined\\n    /// at request-time)\\n    /// @return templateId Request template ID\\n    function createTemplate(\\n        address airnode,\\n        bytes32 endpointId,\\n        bytes calldata parameters\\n    ) external override returns (bytes32 templateId) {\\n        require(airnode != address(0), \\\"Airnode address zero\\\");\\n        templateId = keccak256(\\n            abi.encodePacked(airnode, endpointId, parameters)\\n        );\\n        templates[templateId] = Template({\\n            airnode: airnode,\\n            endpointId: endpointId,\\n            parameters: parameters\\n        });\\n        emit CreatedTemplate(templateId, airnode, endpointId, parameters);\\n    }\\n\\n    /// @notice A convenience method to retrieve multiple templates with a\\n    /// single call\\n    /// @dev Does not revert if the templates being indexed do not exist\\n    /// @param templateIds Request template IDs\\n    /// @return airnodes Array of Airnode addresses\\n    /// @return endpointIds Array of endpoint IDs\\n    /// @return parameters Array of request parameters\\n    function getTemplates(bytes32[] calldata templateIds)\\n        external\\n        view\\n        override\\n        returns (\\n            address[] memory airnodes,\\n            bytes32[] memory endpointIds,\\n            bytes[] memory parameters\\n        )\\n    {\\n        airnodes = new address[](templateIds.length);\\n        endpointIds = new bytes32[](templateIds.length);\\n        parameters = new bytes[](templateIds.length);\\n        for (uint256 ind = 0; ind < templateIds.length; ind++) {\\n            Template storage template = templates[templateIds[ind]];\\n            airnodes[ind] = template.airnode;\\n            endpointIds[ind] = template.endpointId;\\n            parameters[ind] = template.parameters;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/WithdrawalUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IWithdrawalUtilsV0.sol\\\";\\n\\n/// @title Contract that implements logic for withdrawals from sponsor wallets\\ncontract WithdrawalUtilsV0 is IWithdrawalUtilsV0 {\\n    /// @notice Called to get the withdrawal request count of the sponsor\\n    /// @dev Can be used to calculate the ID of the next withdrawal request the\\n    /// sponsor will make\\n    mapping(address => uint256) public override sponsorToWithdrawalRequestCount;\\n\\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\\n    /// the fulfillment will be done with the correct parameters\\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\\n\\n    /// @notice Called by a sponsor to create a request for the Airnode to send\\n    /// the funds kept in the respective sponsor wallet to the sponsor\\n    /// @dev We do not need to use the withdrawal request parameters in the\\n    /// request ID hash to validate them at the node-side because all of the\\n    /// parameters are used during fulfillment and will get validated on-chain.\\n    /// The first withdrawal request a sponsor will make will cost slightly\\n    /// higher gas than the rest due to how the request counter is implemented.\\n    /// @param airnode Airnode address\\n    /// @param sponsorWallet Sponsor wallet that the withdrawal is requested\\n    /// from\\n    function requestWithdrawal(address airnode, address sponsorWallet)\\n        external\\n        override\\n    {\\n        bytes32 withdrawalRequestId = keccak256(\\n            abi.encodePacked(\\n                block.chainid,\\n                address(this),\\n                msg.sender,\\n                ++sponsorToWithdrawalRequestCount[msg.sender]\\n            )\\n        );\\n        withdrawalRequestIdToParameters[withdrawalRequestId] = keccak256(\\n            abi.encodePacked(airnode, msg.sender, sponsorWallet)\\n        );\\n        emit RequestedWithdrawal(\\n            airnode,\\n            msg.sender,\\n            withdrawalRequestId,\\n            sponsorWallet\\n        );\\n    }\\n\\n    /// @notice Called by the Airnode using the sponsor wallet to fulfill the\\n    /// withdrawal request made by the sponsor\\n    /// @dev The Airnode sends the funds to the sponsor through this method\\n    /// to emit an event that indicates that the withdrawal request has been\\n    /// fulfilled\\n    /// @param withdrawalRequestId Withdrawal request ID\\n    /// @param airnode Airnode address\\n    /// @param sponsor Sponsor address\\n    function fulfillWithdrawal(\\n        bytes32 withdrawalRequestId,\\n        address airnode,\\n        address sponsor\\n    ) external payable override {\\n        require(\\n            withdrawalRequestIdToParameters[withdrawalRequestId] ==\\n                keccak256(abi.encodePacked(airnode, sponsor, msg.sender)),\\n            \\\"Invalid withdrawal fulfillment\\\"\\n        );\\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\\n        emit FulfilledWithdrawal(\\n            airnode,\\n            sponsor,\\n            withdrawalRequestId,\\n            msg.sender,\\n            msg.value\\n        );\\n        (bool success, ) = sponsor.call{value: msg.value}(\\\"\\\"); // solhint-disable-line avoid-low-level-calls\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/interfaces/IAirnodeRrpV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAuthorizationUtilsV0.sol\\\";\\nimport \\\"./ITemplateUtilsV0.sol\\\";\\nimport \\\"./IWithdrawalUtilsV0.sol\\\";\\n\\ninterface IAirnodeRrpV0 is\\n    IAuthorizationUtilsV0,\\n    ITemplateUtilsV0,\\n    IWithdrawalUtilsV0\\n{\\n    event SetSponsorshipStatus(\\n        address indexed sponsor,\\n        address indexed requester,\\n        bool sponsorshipStatus\\n    );\\n\\n    event MadeTemplateRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        uint256 requesterRequestCount,\\n        uint256 chainId,\\n        address requester,\\n        bytes32 templateId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes parameters\\n    );\\n\\n    event MadeFullRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        uint256 requesterRequestCount,\\n        uint256 chainId,\\n        address requester,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes parameters\\n    );\\n\\n    event FulfilledRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        bytes data\\n    );\\n\\n    event FailedRequest(\\n        address indexed airnode,\\n        bytes32 indexed requestId,\\n        string errorMessage\\n    );\\n\\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\\n        external;\\n\\n    function makeTemplateRequest(\\n        bytes32 templateId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata parameters\\n    ) external returns (bytes32 requestId);\\n\\n    function makeFullRequest(\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address sponsorWallet,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata parameters\\n    ) external returns (bytes32 requestId);\\n\\n    function fulfill(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        bytes calldata data,\\n        bytes calldata signature\\n    ) external returns (bool callSuccess, bytes memory callData);\\n\\n    function fail(\\n        bytes32 requestId,\\n        address airnode,\\n        address fulfillAddress,\\n        bytes4 fulfillFunctionId,\\n        string calldata errorMessage\\n    ) external;\\n\\n    function sponsorToRequesterToSponsorshipStatus(\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool sponsorshipStatus);\\n\\n    function requesterToRequestCountPlusOne(address requester)\\n        external\\n        view\\n        returns (uint256 requestCountPlusOne);\\n\\n    function requestIsAwaitingFulfillment(bytes32 requestId)\\n        external\\n        view\\n        returns (bool isAwaitingFulfillment);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/interfaces/IAuthorizationUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorizationUtilsV0 {\\n    function checkAuthorizationStatus(\\n        address[] calldata authorizers,\\n        address airnode,\\n        bytes32 requestId,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool status);\\n\\n    function checkAuthorizationStatuses(\\n        address[] calldata authorizers,\\n        address airnode,\\n        bytes32[] calldata requestIds,\\n        bytes32[] calldata endpointIds,\\n        address[] calldata sponsors,\\n        address[] calldata requesters\\n    ) external view returns (bool[] memory statuses);\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IAuthorizerV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorizerV0 {\\n    function isAuthorizedV0(\\n        bytes32 requestId,\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/interfaces/ITemplateUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITemplateUtilsV0 {\\n    event CreatedTemplate(\\n        bytes32 indexed templateId,\\n        address airnode,\\n        bytes32 endpointId,\\n        bytes parameters\\n    );\\n\\n    function createTemplate(\\n        address airnode,\\n        bytes32 endpointId,\\n        bytes calldata parameters\\n    ) external returns (bytes32 templateId);\\n\\n    function getTemplates(bytes32[] calldata templateIds)\\n        external\\n        view\\n        returns (\\n            address[] memory airnodes,\\n            bytes32[] memory endpointIds,\\n            bytes[] memory parameters\\n        );\\n\\n    function templates(bytes32 templateId)\\n        external\\n        view\\n        returns (\\n            address airnode,\\n            bytes32 endpointId,\\n            bytes memory parameters\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/rrp/interfaces/IWithdrawalUtilsV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWithdrawalUtilsV0 {\\n    event RequestedWithdrawal(\\n        address indexed airnode,\\n        address indexed sponsor,\\n        bytes32 indexed withdrawalRequestId,\\n        address sponsorWallet\\n    );\\n\\n    event FulfilledWithdrawal(\\n        address indexed airnode,\\n        address indexed sponsor,\\n        bytes32 indexed withdrawalRequestId,\\n        address sponsorWallet,\\n        uint256 amount\\n    );\\n\\n    function requestWithdrawal(address airnode, address sponsorWallet) external;\\n\\n    function fulfillWithdrawal(\\n        bytes32 withdrawalRequestId,\\n        address airnode,\\n        address sponsor\\n    ) external payable;\\n\\n    function sponsorToWithdrawalRequestCount(address sponsor)\\n        external\\n        view\\n        returns (uint256 withdrawalRequestCount);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"CreatedTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"errorMessage\",\"type\":\"string\"}],\"name\":\"FailedRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"FulfilledRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FulfilledWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requesterRequestCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"MadeFullRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requesterRequestCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"MadeTemplateRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"withdrawalRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"}],\"name\":\"RequestedWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sponsorshipStatus\",\"type\":\"bool\"}],\"name\":\"SetSponsorshipStatus\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"authorizers\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"checkAuthorizationStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"authorizers\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"requestIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"endpointIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"sponsors\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"requesters\",\"type\":\"address[]\"}],\"name\":\"checkAuthorizationStatuses\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"createTemplate\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"string\",\"name\":\"errorMessage\",\"type\":\"string\"}],\"name\":\"fail\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"fulfill\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"callSuccess\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"withdrawalRequestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"fulfillWithdrawal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"templateIds\",\"type\":\"bytes32[]\"}],\"name\":\"getTemplates\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"airnodes\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"endpointIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"parameters\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"makeFullRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fulfillAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"fulfillFunctionId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"name\":\"makeTemplateRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"requestIsAwaitingFulfillment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isAwaitingFulfillment\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsorWallet\",\"type\":\"address\"}],\"name\":\"requestWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requesterToRequestCountPlusOne\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"sponsorshipStatus\",\"type\":\"bool\"}],\"name\":\"setSponsorshipStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sponsorToRequesterToSponsorshipStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sponsorToWithdrawalRequestCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"templates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"parameters\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AirnodeRrpV0", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}