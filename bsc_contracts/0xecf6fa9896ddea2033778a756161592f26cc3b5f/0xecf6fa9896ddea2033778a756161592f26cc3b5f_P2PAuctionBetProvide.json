{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/p2pbet/bets/auction/P2PAuctionBetProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../../processing/TokenProcessing.sol\\\";\\nimport \\\"./AuctionDTOs.sol\\\";\\nimport \\\"./AuctionProcessor.sol\\\";\\n\\ncontract P2PAuctionBetProvider is TokenProcessing, AuctionProcessor {\\n    mapping(uint => AuctionDTOs.AuctionBet) private auctionBets;\\n    mapping(uint => AuctionDTOs.AuctionMatchingInfo) private matchingInfo;\\n    mapping(address => mapping(uint => AuctionDTOs.JoinAuctionBetClientList)) private clientInfo;\\n    mapping(address => uint[]) private clientBets;\\n    mapping(address => uint) public clientBetsLength;\\n    uint public auctionBetIdCounter;\\n    bool public cancelEnabled = false;\\n\\n    constructor(address mainToken, address[] memory owners) TokenProcessing(mainToken) {\\n        for (uint i = 0; i < owners.length; i++) {\\n            addOwner(owners[i]);\\n        }\\n    }\\n\\n    function setCancelEnabled(bool enable) public onlyOwner {\\n        cancelEnabled = enable;\\n    }\\n\\n    function getClientBets(address client, uint offset, uint size) external view returns (uint[] memory) {\\n        uint resultSize = size;\\n        for (uint i = offset; i < offset + size; i++) {\\n            if (clientBets[client].length <= i) {\\n                resultSize = i - offset;\\n                break;\\n            }\\n        }\\n        uint[] memory result = new uint[](resultSize);\\n        for (uint i = offset; i < offset + resultSize; i++) {\\n            result[i - offset] = clientBets[client][i];\\n        }\\n        return result;\\n    }\\n\\n    function getAuctionBet(uint betId) external view returns (AuctionDTOs.AuctionBet memory, uint) {\\n        return (auctionBets[betId], matchingInfo[betId].totalAmount);\\n    }\\n\\n    function getAuctionClientJoins(address client, uint betId) external view returns (AuctionDTOs.JoinAuctionBetClient[] memory) {\\n        AuctionDTOs.JoinAuctionBetClient[] memory clientList = new AuctionDTOs.JoinAuctionBetClient[](clientInfo[client][betId].length);\\n        for (uint i = 0; i < clientInfo[client][betId].length; i++) {\\n            clientList[i] = matchingInfo[betId].joins[clientInfo[client][betId].joinListRefs[i]];\\n        }\\n        return clientList;\\n    }\\n\\n    function refundAuctionBet(uint betId, address client) public {\\n        AuctionDTOs.AuctionBet storage auctionBet = auctionBets[betId];\\n        require(keccak256(abi.encodePacked(auctionBet.finalValue)) == keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PAuctionBetProvider: refund - auction haven't to be open\\\");\\n        require(auctionBet.expirationTime + getTimestampExpirationDelay() < block.timestamp, \\\"P2PAuctionBetProvider: refund - expiration error\\\");\\n\\n        uint mainTokenToRefund = processRefundingAuctionBet(matchingInfo[betId], clientInfo[client][betId]);\\n        require(mainTokenToRefund > 0, \\\"P2PAuctionBetProvider: refund - nothing\\\");\\n        withdrawalMainToken(client, mainTokenToRefund);\\n\\n        emit AuctionBetRefunded(\\n            betId,\\n            client,\\n            mainTokenToRefund\\n        );\\n    }\\n\\n    function takeAuctionPrize(uint betId, address client, bool useAlterFee) public {\\n        AuctionDTOs.AuctionBet storage auctionBet = auctionBets[betId];\\n        AuctionDTOs.AuctionMatchingInfo storage info = matchingInfo[betId];\\n        require(keccak256(abi.encodePacked(auctionBet.finalValue)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PAuctionBetProvider: take prize - auction bet wasn't closed\\\");\\n\\n        uint wonAmount = matchingInfo[betId].wonAmount[client];\\n\\n        require(wonAmount > 0, \\\"P2PAuctionBetProvider: take prize - nothing\\\");\\n\\n        uint wonAmountAfterFee = takeFeeFromAmount(msg.sender, wonAmount, useAlterFee);\\n\\n        info.wonAmount[client] = 0;\\n        withdrawalMainToken(client, wonAmountAfterFee);\\n\\n        emit AuctionPrizeTaken(\\n            betId,\\n            client,\\n            wonAmountAfterFee,\\n            useAlterFee\\n        );\\n    }\\n\\n    function getAuctionWonAmount(uint betId, address client) public view returns (uint) {\\n        AuctionDTOs.AuctionBet storage auctionBet = auctionBets[betId];\\n        if (keccak256(abi.encodePacked(auctionBet.finalValue)) == keccak256(abi.encodePacked(\\\"\\\"))) {\\n            return 0;\\n        }\\n\\n        return matchingInfo[betId].wonAmount[client];\\n    }\\n\\n    function closeAuctionBet(uint betId, string calldata finalValue, uint[] calldata joinIdsWon) external onlyCompany {\\n        require(keccak256(abi.encodePacked(finalValue)) != keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PAuctionBetProvider: close error - auction bet can't be closed with empty final value\\\");\\n        AuctionDTOs.AuctionBet storage auctionBet = auctionBets[betId];\\n        require(auctionBet.expirationTime < block.timestamp, \\\"P2PAuctionBetProvider: close error - expiration error\\\");\\n        require(auctionBet.expirationTime + getTimestampExpirationDelay() > block.timestamp, \\\"P2PAuctionBetProvider: close error - expiration error\\\");\\n        require(keccak256(abi.encodePacked(auctionBet.finalValue)) == keccak256(abi.encodePacked(\\\"\\\")), \\\"P2PAuctionBetProvider: close error - bet already closed\\\");\\n\\n        auctionBet.finalValue = finalValue;\\n        AuctionDTOs.AuctionMatchingInfo storage info = matchingInfo[betId];\\n        for (uint i = 0; i < joinIdsWon.length; ++i) {\\n            AuctionDTOs.JoinAuctionBetClient storage bet = info.joins[joinIdsWon[i]];\\n            info.wonAmount[bet.client] += info.totalAmount / joinIdsWon.length;\\n        }\\n\\n        emit AuctionBetClosed(\\n            betId,\\n            finalValue,\\n            joinIdsWon\\n        );\\n    }\\n\\n    function cancelAuctionJoin(uint betId, uint joinRefId) external {\\n        require(cancelEnabled, \\\"P2PAuctionBetProvider: cancel disabled\\\");\\n\\n        AuctionDTOs.JoinAuctionBetClient storage clientJoin = matchingInfo[betId].joins[clientInfo[msg.sender][betId].joinListRefs[joinRefId]];\\n\\n        require(clientJoin.amount != 0, \\\"P2PAuctionBetProvider: cancel - free amount empty\\\");\\n        require(auctionBets[betId].lockTime >= block.timestamp, \\\"P2PAuctionBetProvider: cancel - lock time\\\");\\n\\n        uint mainTokenToRefund = cancelAuctionBet(matchingInfo[betId], clientJoin);\\n        withdrawalMainToken(msg.sender, mainTokenToRefund);\\n\\n        emit AuctionBetCancelled(\\n            betId,\\n            msg.sender,\\n            joinRefId,\\n            mainTokenToRefund\\n        );\\n    }\\n\\n    function createPrivateAuctionBet(AuctionDTOs.CreateAuctionRequest calldata createRequest) external returns (uint) {\\n        return executeCreateAuctionBet(createRequest, true);\\n    }\\n\\n    function createAuctionBet(AuctionDTOs.CreateAuctionRequest calldata createRequest) external onlyCompany returns (uint) {\\n        return executeCreateAuctionBet(createRequest, false);\\n    }\\n\\n    function executeCreateAuctionBet(AuctionDTOs.CreateAuctionRequest calldata createRequest, bool hidden) private returns (uint) {\\n        // lock - 60 * 3\\n        // expiration - 60 * 3\\n        require(createRequest.lockTime >= block.timestamp + 3 * 60, \\\"P2PAuctionBetProvider: create - lock time\\\");\\n        require(createRequest.expirationTime >= createRequest.lockTime + 3 * 60, \\\"P2PAuctionBetProvider: create - expirationTime time\\\");\\n\\n        uint betId = auctionBetIdCounter++;\\n        auctionBets[betId] = AuctionDTOs.AuctionBet(\\n            betId,\\n            hidden,\\n            createRequest.eventId,\\n            createRequest.requestAmount,\\n            createRequest.lockTime,\\n            createRequest.expirationTime,\\n            \\\"\\\"\\n        );\\n\\n        emit AuctionBetCreated(\\n            betId,\\n            hidden,\\n            createRequest.eventId,\\n            createRequest.lockTime,\\n            createRequest.expirationTime,\\n            msg.sender,\\n            createRequest.requestAmount\\n        );\\n\\n        return betId;\\n    }\\n\\n    function massJoinAuctionBet(AuctionDTOs.MassJoinAuctionRequest calldata massJoinRequest) public {\\n        require(auctionBets[massJoinRequest.betId].lockTime >= block.timestamp, \\\"P2PAuctionBetProvider: mass join - lock time\\\");\\n\\n        // deposit amounts\\n        DepositedValue memory depositedValue = deposit(msg.sender, auctionBets[massJoinRequest.betId].requestAmount * massJoinRequest.targetValues.length);\\n\\n        // Only mainAmount takes part in the auction bet\\n        uint mainAmount = depositedValue.mainAmount / massJoinRequest.targetValues.length;\\n\\n        for (uint i = 0; i < massJoinRequest.targetValues.length; ++i) {\\n            executeInternalJoinAuctionBet(\\n                massJoinRequest.betId,\\n                massJoinRequest.targetValues[i],\\n                    mainAmount\\n            );\\n        }\\n    }\\n\\n    function joinAuctionBet(AuctionDTOs.JoinAuctionRequest calldata joinRequest) public {\\n        require(auctionBets[joinRequest.betId].lockTime >= block.timestamp, \\\"P2PAuctionBetProvider: join - lock time\\\");\\n\\n        // deposit amounts\\n        DepositedValue memory depositedValue = deposit(msg.sender, auctionBets[joinRequest.betId].requestAmount);\\n\\n\\n        executeInternalJoinAuctionBet(\\n            joinRequest.betId,\\n            joinRequest.targetValue,\\n                depositedValue.mainAmount\\n        );\\n    }\\n\\n    function executeInternalJoinAuctionBet(\\n        uint betId,\\n        string calldata targetValue,\\n        uint mainAmount\\n    ) private {\\n        clientBets[msg.sender].push(betId);\\n        clientBetsLength[msg.sender]++;\\n\\n\\n        AuctionDTOs.JoinAuctionBetClientList storage clientBetList = clientInfo[msg.sender][betId];\\n\\n\\n        AuctionDTOs.AuctionMatchingInfo storage info = matchingInfo[betId];\\n        uint joinId = info.joinsLength++;\\n\\n        AuctionDTOs.JoinAuctionBetClient memory joinBetClient = AuctionDTOs.JoinAuctionBetClient(\\n            joinId,\\n            msg.sender,\\n            mainAmount,\\n            targetValue,\\n            clientBetList.length\\n        );\\n\\n\\n        // Custom bet enrichment with matching\\n        joinAuctionBet(info, joinBetClient);\\n\\n        // Add to client info sidePointer\\n        clientBetList.joinListRefs[clientBetList.length++] = joinId;\\n\\n        emit AuctionBetJoined(\\n            msg.sender,\\n            betId,\\n            joinBetClient.id,\\n            clientBetList.length - 1,\\n            targetValue\\n        );\\n    }\\n\\n    event AuctionBetCreated(\\n        uint id,\\n        bool hidden,\\n        string eventId,\\n        uint lockTime,\\n        uint expirationTime,\\n        address indexed creator,\\n        uint requestAmount\\n    );\\n\\n    event AuctionBetJoined(\\n        address indexed client,\\n        uint betId,\\n        uint joinId,\\n        uint joinRefId,\\n        string targetValue\\n    );\\n\\n    event AuctionBetCancelled(\\n        uint betId,\\n        address indexed client,\\n        uint joinIdRef,\\n        uint mainTokenRefunded\\n    );\\n\\n    event AuctionBetClosed(\\n        uint betId,\\n        string finalValue,\\n        uint[] joinIdsWon\\n    );\\n\\n    event AuctionPrizeTaken(\\n        uint betId,\\n        address indexed client,\\n        uint amount,\\n        bool useAlterFee\\n    );\\n\\n    event AuctionBetRefunded(\\n        uint betId,\\n        address indexed client,\\n        uint mainTokenRefunded\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/p2pbet/processing/TokenProcessing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Ownable.sol\\\";\\nimport \\\"./CompanyVault.sol\\\";\\nimport \\\"./AlternativeTokenHelper.sol\\\";\\nimport \\\"./FeeConfiguration.sol\\\";\\n\\nabstract contract TokenProcessing is CompanyVault, AlternativeTokenHelper, FeeConfiguration {\\n    event FeeTaken(uint amount, address indexed targetAddress, bool isAlternative);\\n\\n    struct DepositedValue {\\n        uint mainAmount;\\n    }\\n\\n    constructor(address mainToken) CompanyVault(mainToken) {}\\n\\n    // Deposit amount from sender\\n    function deposit(address sender, uint amount) internal returns (DepositedValue memory) {\\n        require(amount > 0, \\\"TokenProcessing - deposit zero amount\\\");\\n        depositToken(getMainIERC20Token(), sender, amount);\\n        return DepositedValue(amount);\\n    }\\n\\n    // Withdrawal main tokens to user\\n    // Used only in take prize and bet cancellation\\n    function withdrawalMainToken(address recipient, uint amount) internal {\\n        bool result = getMainIERC20Token().transfer(recipient, amount);\\n        require(result, \\\"TokenProcessing: withdrawal token failed\\\");\\n    }\\n\\n\\n    // Evaluate fee from amount and take it. Return the rest of it.\\n    function takeFeeFromAmount(address winner, uint amount, bool useAlternativeFee) internal returns (uint) {\\n        if (useAlternativeFee) {\\n            require(isAlternativeTokenEnabled(), \\\"TokenProcessing: alternative token disabled\\\");\\n            uint alternativeFeePart = applyAlternativeFee(amount);\\n            uint feeInAlternativeToken = evaluateAlternativeAmount(alternativeFeePart, address(getMainIERC20Token()), address(getAlternativeIERC20Token()));\\n            depositToken(getAlternativeIERC20Token(), winner, feeInAlternativeToken);\\n            increaseFee(feeInAlternativeToken, address(getAlternativeIERC20Token()));\\n            return amount;\\n        } else {\\n            uint feePart = applyCompanyFee(amount);\\n            increaseFee(feePart, address(getMainIERC20Token()));\\n            return amount - feePart;\\n        }\\n    }\\n\\n\\n    // Deposit amount of tokens from sender to this contract\\n    function depositToken(IERC20 token, address sender, uint amount) internal {\\n        require(token.allowance(sender, address(this)) >= amount, \\\"TokenProcessing: depositMainToken, not enough funds to deposit token\\\");\\n\\n        bool result = token.transferFrom(sender, address(this), amount);\\n        require(result, \\\"TokenProcessing: depositMainToken, transfer from failed\\\");\\n    }\\n\\n    // Start take company fee from main token company balance\\n    function takeFeeStart(uint amount, address targetAddress, bool isAlternative) external onlyOwner {\\n        if (isAlternative) {\\n            require(amount <= getCompanyFeeBalance(address(getAlternativeIERC20Token())), \\\"CompanyVault: take fee amount exeeds alter token balance\\\");\\n        } else {\\n            require(amount <= getCompanyFeeBalance(address(getMainIERC20Token())), \\\"CompanyVault: take fee amount exeeds token balance\\\");\\n        }\\n\\n        uint votingCode = startVoting(\\\"TAKE_FEE\\\");\\n        takeFeeVoting = SecurityDTOs.TakeFee(\\n            amount,\\n            targetAddress,\\n            isAlternative,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireTakeFee() external onlyOwner {\\n        pass(takeFeeVoting.votingCode);\\n\\n        IERC20 token;\\n        if (takeFeeVoting.isAlternative) {\\n            token = getAlternativeIERC20Token();\\n            decreaseFee(takeFeeVoting.amount, address(getAlternativeIERC20Token()));\\n        } else {\\n            token = getMainIERC20Token();\\n            decreaseFee(takeFeeVoting.amount, address(getMainIERC20Token()));\\n        }\\n\\n        bool result = token.transfer(takeFeeVoting.targetAddress, takeFeeVoting.amount);\\n        require(result, \\\"TokenProcessing: take fee transfer failed\\\");\\n        emit FeeTaken(takeFeeVoting.amount, takeFeeVoting.targetAddress, takeFeeVoting.isAlternative);\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/bets/auction/AuctionDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nlibrary AuctionDTOs {\\n    struct AuctionBet {\\n        uint id;\\n        bool hidden;\\n        string eventId;\\n        uint requestAmount;\\n        uint lockTime;\\n        uint expirationTime;\\n\\n        string finalValue;\\n    }\\n\\n    struct AuctionMatchingInfo {\\n        mapping(uint => JoinAuctionBetClient) joins;\\n        uint joinsLength;\\n\\n        mapping(address => uint) wonAmount;\\n        uint totalAmount;\\n    }\\n\\n    struct JoinAuctionBetClientList {\\n        mapping(uint => uint) joinListRefs;\\n        uint length;\\n    }\\n\\n    struct JoinAuctionBetClient {\\n        uint id;\\n        address client;\\n        uint amount;\\n        string targetValue;\\n        uint joinIdRef;\\n    }\\n\\n    struct CreateAuctionRequest {\\n        string eventId;\\n        uint lockTime;\\n        uint expirationTime;\\n        uint requestAmount;\\n    }\\n\\n    struct MassJoinAuctionRequest {\\n        uint betId;\\n        bool useAlterFee;\\n        string[] targetValues;\\n    }\\n\\n    struct JoinAuctionRequest {\\n        uint betId;\\n        string targetValue;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/p2pbet/bets/auction/AuctionProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./AuctionDTOs.sol\\\";\\n\\nabstract contract AuctionProcessor {\\n    // Refund main token and alter token(if pay alter fee)\\n    // Only after expiration + expirationDelay call without bet closed action\\n    function processRefundingAuctionBet(AuctionDTOs.AuctionMatchingInfo storage info, AuctionDTOs.JoinAuctionBetClientList storage clientList) internal returns (uint) {\\n        uint resultAmount;\\n        for (uint i = 0; i < clientList.length; ++i) {\\n            AuctionDTOs.JoinAuctionBetClient storage joinClient = info.joins[clientList.joinListRefs[i]];\\n            resultAmount += joinClient.amount;\\n\\n            joinClient.amount = 0;\\n        }\\n\\n        return resultAmount;\\n    }\\n\\n    // Evaluate mainToken  for refunding\\n    // returns (mainToken amount)\\n    function cancelAuctionBet(AuctionDTOs.AuctionMatchingInfo storage info, AuctionDTOs.JoinAuctionBetClient storage joinClient) internal returns (uint) {\\n        uint amount = joinClient.amount;\\n\\n        info.totalAmount -= amount;\\n\\n        joinClient.amount = 0;\\n\\n        return amount;\\n    }\\n\\n    function joinAuctionBet(AuctionDTOs.AuctionMatchingInfo storage info, AuctionDTOs.JoinAuctionBetClient memory joinAuctionRequestBet) internal {\\n        info.joins[joinAuctionRequestBet.id] = joinAuctionRequestBet;\\n        info.totalAmount += joinAuctionRequestBet.amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/p2pbet/security/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"./SecurityDTOs.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    mapping(address => bool) public owners;\\n    address private _company;\\n    uint public totalOwners;\\n\\n    event CompanyTransferred(address indexed previousCompany, address indexed newCompany);\\n\\n    event AddOwner(address indexed newOwner);\\n    event RemoveOwner(address indexed ownerToRemove);\\n\\n    modifier onlyOwner() {\\n        require(owners[_msgSender()], \\\"Security: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function removeOwner(address ownerToRemove) internal {\\n        require(owners[ownerToRemove], \\\"Security: now owner\\\");\\n\\n        owners[ownerToRemove] = false;\\n        totalOwners--;\\n        emit RemoveOwner(ownerToRemove);\\n    }\\n\\n    function addOwner(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Security: new owner is the zero address\\\");\\n        require(!owners[newOwner], \\\"Security: already owner\\\");\\n\\n        owners[newOwner] = true;\\n        totalOwners++;\\n        emit AddOwner(newOwner);\\n    }\\n\\n\\n\\n    /**\\n     * @dev Returns the address of the current company.\\n     */\\n    function company() public view virtual returns (address) {\\n        return _company;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the company.\\n     */\\n    modifier onlyCompany() {\\n        require(company() == _msgSender(), \\\"Security: caller is not the company\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers company rights of the contract to a new account (`newCompany`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferCompany(address newCompany) internal {\\n        require(newCompany != address(0), \\\"Security: new company is the zero address\\\");\\n\\n        emit CompanyTransferred(_company, newCompany);\\n        _company = newCompany;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/p2pbet/processing/CompanyVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Security.sol\\\";\\nimport \\\"../utils/IERC20.sol\\\";\\n\\nabstract contract CompanyVault is Security {\\n    SecurityDTOs.ChangeAlterToken public changeAlterToken;\\n    IERC20 internal _IERC20token;\\n    IERC20 internal _AlternativeIERC20token;\\n    mapping(address => uint) private feeBalance;\\n    bool private _alternativeTokenEnabled;\\n    uint private _timestampExpirationDelay;\\n\\n    event ChangeAlterToken(address indexed newAlterToken);\\n    event ChangeTimestampDelay(uint timestampExpirationDelay);\\n\\n    constructor (address mainToken) {\\n        _IERC20token = IERC20(mainToken);\\n        _timestampExpirationDelay = 2 * 60 * 60;\\n    }\\n\\n    // Set expiration delay\\n    function setTimestampExpirationDelay(uint timestampExpirationDelay) external onlyOwner {\\n        _timestampExpirationDelay = timestampExpirationDelay;\\n        emit ChangeTimestampDelay(timestampExpirationDelay);\\n    }\\n\\n    // Change alter token start voting\\n    function changeAlternativeTokenStart(address alternativeToken) external onlyOwner {\\n        require(address(getMainIERC20Token()) != alternativeToken, \\\"CompanyVault: main token and alter token can't be the same\\\");\\n        uint votingCode = startVoting(\\\"CHANGE_ALTER_TOKEN\\\");\\n        changeAlterToken = SecurityDTOs.ChangeAlterToken(\\n            alternativeToken,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    // Acquire alter token start voting\\n    function acquireNewAlternativeToken() external onlyOwner {\\n        pass(changeAlterToken.votingCode);\\n        _AlternativeIERC20token = IERC20(changeAlterToken.newAlterToken);\\n        emit ChangeAlterToken(changeAlterToken.newAlterToken);\\n    }\\n\\n    // Get expiration delay to refund\\n    function getTimestampExpirationDelay() public view returns (uint) {\\n        return _timestampExpirationDelay;\\n    }\\n\\n    // Enable/disable alternative token usage\\n    function enableAlternativeToken(bool enable) external onlyOwner {\\n        _alternativeTokenEnabled = enable;\\n    }\\n\\n    // Status of alternative token\\n    function isAlternativeTokenEnabled() public view returns (bool) {\\n        return _alternativeTokenEnabled;\\n    }\\n\\n    // Get main IERC20 interface\\n    function getMainIERC20Token() public view returns (IERC20) {\\n        return _IERC20token;\\n    }\\n\\n    // Get alternative IERC20 interface\\n    function getAlternativeIERC20Token() public view returns (IERC20) {\\n        return _AlternativeIERC20token;\\n    }\\n\\n    // Get fee company balance\\n    function getCompanyFeeBalance(address token) public view returns (uint) {\\n        return feeBalance[token];\\n    }\\n\\n    // Increase main or alter token fee. Calls only from take prize.\\n    function increaseFee(uint amount, address token) internal {\\n        feeBalance[token] += amount;\\n    }\\n\\n    // Decrease main or alter token fee. Calls only from take fee.\\n    function decreaseFee(uint amount, address token) internal {\\n        feeBalance[token] -= amount;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/processing/AlternativeTokenHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Security.sol\\\";\\nimport \\\"../utils/IPancakeRouter01.sol\\\";\\n\\nabstract contract AlternativeTokenHelper is Security {\\n    SwapRouter public swapRouter;\\n\\n    event SetRouter(address indexed newSwapRouter);\\n\\n    function setRouter(address router) onlyOwner external {\\n        swapRouter = SwapRouter(router);\\n        emit SetRouter(router);\\n    }\\n\\n    function evaluateAlternativeAmount(uint mainAmount, address mainToken, address alternativeToken) internal view returns (uint) {\\n        address[] memory path = new address[](2);\\n        path[0] = mainToken;\\n        path[1] = alternativeToken;\\n        return swapRouter.getAmountsOut(mainAmount, path)[0];\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/processing/FeeConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"../security/Security.sol\\\";\\n\\nabstract contract FeeConfiguration is Security {\\n    //DECIMALS 6 for 100%\\n    uint private _companyFee;\\n    //DECIMALS 6 for 100%\\n    uint private _alternativeFee;\\n\\n    event CompanyFeeChanged(uint previousCompanyFee, uint newCompanyFee);\\n    event CompanyAlterFeeChanged(uint previousAlternativeFee, uint newAlternativeFee);\\n\\n    // Set company fee for all bets with main token fee\\n    function setCompanyFee(uint companyFee) external onlyOwner {\\n        require(companyFee <= 2 * 10 ** 5);\\n        emit CompanyFeeChanged(_companyFee, companyFee);\\n        _companyFee = companyFee;\\n    }\\n\\n    // Set company fee for all bets with alternative token fee\\n    function setAlternativeFeeFee(uint alternativeFee) external onlyOwner {\\n        require(alternativeFee <= 2 * 10 ** 5);\\n        emit CompanyAlterFeeChanged(_alternativeFee, alternativeFee);\\n        _alternativeFee = alternativeFee;\\n    }\\n\\n    // Get company fee(main token)\\n    function getCompanyFee() external view returns (uint) {\\n        return _companyFee;\\n    }\\n\\n    // Get alternative company fee(alternative token)\\n    function getAlternativeFee() external view returns (uint) {\\n        return _alternativeFee;\\n    }\\n\\n    // Apply company fee and return company fee part\\n    function applyCompanyFee(uint amount) internal view returns (uint) {\\n        return (amount * _companyFee) / 10 ** 6;\\n    }\\n\\n    // Apply alternative company fee and return alternative fee part\\n    function applyAlternativeFee(uint amount) internal view returns (uint) {\\n        return (amount * _alternativeFee) / 10 ** 6;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.2;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/security/SecurityDTOs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nlibrary SecurityDTOs {\\n    struct ChangeAlterToken {\\n        address newAlterToken;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct AddOwner {\\n        address newOwner;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct RemoveOwner {\\n        address ownerToRemove;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct TransferCompany {\\n        address newCompanyAddress;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct TakeFee {\\n        uint amount;\\n        address targetAddress;\\n        bool isAlternative;\\n        uint createdDate;\\n        uint votingCode;\\n    }\\n\\n    struct VotingInfo {\\n        address initiator;\\n        uint currentNumberOfVotesPositive;\\n        uint currentNumberOfVotesNegative;\\n        uint startedDate;\\n        string votingCode;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/security/Security.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./Voting.sol\\\";\\n\\nabstract contract Security is Voting {\\n    SecurityDTOs.AddOwner public addOwnerVoting;\\n    SecurityDTOs.TransferCompany public transferCompanyVoting;\\n    SecurityDTOs.RemoveOwner public removeOwnerVoting;\\n    SecurityDTOs.TakeFee public takeFeeVoting;\\n\\n\\n    // Start voting for add owner\\n    function ownerAddStart(address newOwner) external onlyOwner {\\n        require(!owners[newOwner], \\\"Security: already owner\\\");\\n\\n        uint votingCode = startVoting(\\\"ADD_OWNER\\\");\\n        addOwnerVoting = SecurityDTOs.AddOwner(\\n            newOwner,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireNewOwner() external onlyOwner {\\n        pass(addOwnerVoting.votingCode);\\n        addOwner(addOwnerVoting.newOwner);\\n    }\\n\\n    function transferCompanyStart(address newCompany) public virtual onlyOwner {\\n        require(newCompany != address(0), \\\"Security: new company is the zero address\\\");\\n\\n        uint votingCode = startVoting(\\\"TRANSFER_COMPANY\\\");\\n        transferCompanyVoting = SecurityDTOs.TransferCompany(\\n            newCompany,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireTransferCompany() external onlyOwner {\\n        pass(transferCompanyVoting.votingCode);\\n        transferCompany(transferCompanyVoting.newCompanyAddress);\\n    }\\n\\n    // Start voting removing owner\\n    function ownerToRemoveStart(address ownerToRemove) external onlyOwner {\\n        require(owners[ownerToRemove], \\\"Security: is not owner\\\");\\n\\n        uint votingCode = startVoting(\\\"REMOVE_OWNER\\\");\\n        removeOwnerVoting = SecurityDTOs.RemoveOwner(\\n            ownerToRemove,\\n            block.timestamp,\\n            votingCode\\n        );\\n    }\\n\\n    function acquireOwnerToRemove() external onlyOwner {\\n        pass(removeOwnerVoting.votingCode);\\n        removeOwner(removeOwnerVoting.ownerToRemove);\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/utils/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/p2pbet/security/Voting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\nabstract contract Voting is Ownable {\\n    event VotingStarted(string code, uint votingNumber, address indexed initiator);\\n    event VotingResult(string code, uint votingNumber, bool passed);\\n\\n    bool public votingActive;\\n    SecurityDTOs.VotingInfo public votingInfo;\\n    uint private votingNumber;\\n    mapping(uint => mapping(address => bool)) public voted;\\n\\n\\n    function startVoting(string memory votingCode) internal returns (uint) {\\n        require(!votingActive, \\\"Voting: there is active voting already\\\");\\n        require(totalOwners >= 3, \\\"Voting: not enough owners for starting new vote\\\");\\n        votingInfo = SecurityDTOs.VotingInfo(\\n            _msgSender(),\\n            0,\\n            0,\\n            block.timestamp,\\n            votingCode\\n        );\\n        votingActive = true;\\n        votingNumber++;\\n\\n        votePositive();\\n        emit VotingStarted(\\n            votingCode,\\n            votingNumber,\\n            _msgSender()\\n        );\\n\\n        return votingNumber;\\n    }\\n\\n    // End voting with success\\n    function pass(uint toCheckVotingNumber) internal {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(toCheckVotingNumber == votingNumber, \\\"Voting: old voting found\\\");\\n        require(votingInfo.currentNumberOfVotesPositive > totalOwners / 2, \\\"Voting: not enough positive votes\\\");\\n        require(votingInfo.startedDate + 60 * 60 * 72 < block.timestamp || votingInfo.currentNumberOfVotesPositive == totalOwners, \\\"Voting: 72 hours have not yet passed\\\");\\n\\n        votingActive = false;\\n        emit VotingResult(\\n            votingInfo.votingCode,\\n            votingNumber,\\n            true\\n        );\\n    }\\n\\n\\n    // Close voting\\n    function close() external onlyOwner {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(votingInfo.startedDate + 144 * 60 * 60 < block.timestamp || votingInfo.currentNumberOfVotesNegative > totalOwners / 2, \\\"Voting: condition close error\\\");\\n        votingActive = false;\\n        emit VotingResult(\\n            votingInfo.votingCode,\\n            votingNumber,\\n            false\\n        );\\n    }\\n\\n    function votePositive() public onlyOwner {\\n        vote();\\n        votingInfo.currentNumberOfVotesPositive++;\\n    }\\n\\n    function voteNegative() external onlyOwner {\\n        vote();\\n        votingInfo.currentNumberOfVotesNegative++;\\n    }\\n\\n    function vote() private {\\n        require(votingActive, \\\"Voting: there is no active voting\\\");\\n        require(!voted[votingNumber][_msgSender()], \\\"Voting: already voted\\\");\\n        voted[votingNumber][_msgSender()] = true;\\n    }\\n}\"\r\n    },\r\n    \"contracts/p2pbet/utils/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line\\npragma solidity 0.8.2;\\n\\ninterface SwapRouter {\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mainToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"AddOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"joinIdRef\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mainTokenRefunded\",\"type\":\"uint256\"}],\"name\":\"AuctionBetCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"joinIdsWon\",\"type\":\"uint256[]\"}],\"name\":\"AuctionBetClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"hidden\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"}],\"name\":\"AuctionBetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"joinId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"joinRefId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"targetValue\",\"type\":\"string\"}],\"name\":\"AuctionBetJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mainTokenRefunded\",\"type\":\"uint256\"}],\"name\":\"AuctionBetRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useAlterFee\",\"type\":\"bool\"}],\"name\":\"AuctionPrizeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAlterToken\",\"type\":\"address\"}],\"name\":\"ChangeAlterToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestampExpirationDelay\",\"type\":\"uint256\"}],\"name\":\"ChangeTimestampDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAlternativeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAlternativeFee\",\"type\":\"uint256\"}],\"name\":\"CompanyAlterFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousCompanyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCompanyFee\",\"type\":\"uint256\"}],\"name\":\"CompanyFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousCompany\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newCompany\",\"type\":\"address\"}],\"name\":\"CompanyTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAlternative\",\"type\":\"bool\"}],\"name\":\"FeeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"}],\"name\":\"RemoveOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSwapRouter\",\"type\":\"address\"}],\"name\":\"SetRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"passed\",\"type\":\"bool\"}],\"name\":\"VotingResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votingNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"VotingStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acquireNewAlternativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireOwnerToRemove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireTakeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acquireTransferCompany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addOwnerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionBetIdCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinRefId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionJoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changeAlterToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAlterToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"alternativeToken\",\"type\":\"address\"}],\"name\":\"changeAlternativeTokenStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clientBetsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"joinIdsWon\",\"type\":\"uint256[]\"}],\"name\":\"closeAuctionBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"company\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct AuctionDTOs.CreateAuctionRequest\",\"name\":\"createRequest\",\"type\":\"tuple\"}],\"name\":\"createAuctionBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct AuctionDTOs.CreateAuctionRequest\",\"name\":\"createRequest\",\"type\":\"tuple\"}],\"name\":\"createPrivateAuctionBet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableAlternativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlternativeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAlternativeIERC20Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getAuctionBet\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hidden\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"eventId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"finalValue\",\"type\":\"string\"}],\"internalType\":\"struct AuctionDTOs.AuctionBet\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"getAuctionClientJoins\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"targetValue\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"joinIdRef\",\"type\":\"uint256\"}],\"internalType\":\"struct AuctionDTOs.JoinAuctionBetClient[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"getAuctionWonAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getClientBets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCompanyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getCompanyFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMainIERC20Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimestampExpirationDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAlternativeTokenEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"targetValue\",\"type\":\"string\"}],\"internalType\":\"struct AuctionDTOs.JoinAuctionRequest\",\"name\":\"joinRequest\",\"type\":\"tuple\"}],\"name\":\"joinAuctionBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"useAlterFee\",\"type\":\"bool\"},{\"internalType\":\"string[]\",\"name\":\"targetValues\",\"type\":\"string[]\"}],\"internalType\":\"struct AuctionDTOs.MassJoinAuctionRequest\",\"name\":\"massJoinRequest\",\"type\":\"tuple\"}],\"name\":\"massJoinAuctionBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerAddStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"}],\"name\":\"ownerToRemoveStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"}],\"name\":\"refundAuctionBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeOwnerVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerToRemove\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"alternativeFee\",\"type\":\"uint256\"}],\"name\":\"setAlternativeFeeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setCancelEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"companyFee\",\"type\":\"uint256\"}],\"name\":\"setCompanyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestampExpirationDelay\",\"type\":\"uint256\"}],\"name\":\"setTimestampExpirationDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract SwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useAlterFee\",\"type\":\"bool\"}],\"name\":\"takeAuctionPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAlternative\",\"type\":\"bool\"}],\"name\":\"takeFeeStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeFeeVoting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAlternative\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalOwners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCompany\",\"type\":\"address\"}],\"name\":\"transferCompanyStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferCompanyVoting\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newCompanyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingCode\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteNegative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votePositive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentNumberOfVotesPositive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentNumberOfVotesNegative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startedDate\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"votingCode\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "P2PAuctionBetProvider", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000800000000000000000000000056279d7d92d11381a1b6fb84678b69640c324551000000000000000000000000ff0c626d969cc8359ff213057d467f607dd3882f000000000000000000000000829ae661c7c5dc3fc38eea1035edc85c288d0b90000000000000000000000000e1a8f12fc65c9c9dd1071d6a120ecb44ecfb153c0000000000000000000000005f7d70ff357920efc801b8f54b81f9bbe78e13e0000000000000000000000000726d39f0f9ef36c3dcbc71cc39ff1d3981fe0f950000000000000000000000000853ac2e9a241e5876ef89b47c2639405403b1110000000000000000000000009f9e88112da06c7a42513298a5415cc208b36b99", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}