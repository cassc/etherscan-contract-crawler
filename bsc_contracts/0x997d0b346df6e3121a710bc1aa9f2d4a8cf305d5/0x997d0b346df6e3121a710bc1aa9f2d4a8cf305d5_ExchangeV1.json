{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/ExchangeV1.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public;\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public;\\n\\n    function approve(address to, uint256 tokenId) public;\\n\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public;\\n}\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() internal {}\\n\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping(address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\\ncontract OperatorRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event OperatorAdded(address indexed account);\\n    event OperatorRemoved(address indexed account);\\n\\n    Roles.Role private _operators;\\n\\n    constructor() internal {}\\n\\n    modifier onlyOperator() {\\n        require(\\n            isOperator(_msgSender()),\\n            \\\"OperatorRole: caller does not have the Operator role\\\"\\n        );\\n        _;\\n    }\\n\\n    function isOperator(address account) public view returns (bool) {\\n        return _operators.has(account);\\n    }\\n\\n    function _addOperator(address account) internal {\\n        _operators.add(account);\\n        emit OperatorAdded(account);\\n    }\\n\\n    function _removeOperator(address account) internal {\\n        _operators.remove(account);\\n        emit OperatorRemoved(account);\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract OwnableOperatorRole is Ownable, OperatorRole {\\n    function addOperator(address account) external onlyOwner {\\n        _addOperator(account);\\n    }\\n\\n    function removeOperator(address account) external onlyOwner {\\n        _removeOperator(account);\\n    }\\n}\\n\\n/**\\n    @title ERC-1155 Multi Token Standard\\n    @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md\\n    Note: The ERC-165 identifier for this interface is 0xd9b67a26.\\n */\\ncontract IERC1155 is IERC165 {\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be msg.sender.\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_id` argument MUST be the token type being transferred.\\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferSingle(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _id,\\n        uint256 _value\\n    );\\n\\n    /**\\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        The `_operator` argument MUST be msg.sender.\\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\\n        The `_ids` argument MUST be the list of tokens being transferred.\\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).\\n    */\\n    event TransferBatch(\\n        address indexed _operator,\\n        address indexed _from,\\n        address indexed _to,\\n        uint256[] _ids,\\n        uint256[] _values\\n    );\\n\\n    /**\\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absense of an event assumes disabled).\\n    */\\n    event ApprovalForAll(\\n        address indexed _owner,\\n        address indexed _operator,\\n        bool _approved\\n    );\\n\\n    /**\\n        @dev MUST emit when the URI is updated for a token ID.\\n        URIs are defined in RFC 3986.\\n        The URI MUST point a JSON file that conforms to the \\\"ERC-1155 Metadata URI JSON Schema\\\".\\n    */\\n    event URI(string _value, uint256 indexed _id);\\n\\n    /**\\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\\n        MUST revert on any other error.\\n        MUST emit the `TransferSingle` event to reflect the balance change (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _id      ID of the token type\\n        @param _value   Transfer amount\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\\n    */\\n    function safeTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if length of `_ids` is not the same as length of `_values`.\\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\\n        MUST revert on any other error.\\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _ids     IDs of each token type (order and length must match _values array)\\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\\n    */\\n    function safeBatchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] calldata _ids,\\n        uint256[] calldata _values,\\n        bytes calldata _data\\n    ) external;\\n\\n    /**\\n        @notice Get the balance of an account's Tokens.\\n        @param _owner  The address of the token holder\\n        @param _id     ID of the Token\\n        @return        The _owner's balance of the Token type requested\\n     */\\n    function balanceOf(address _owner, uint256 _id)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n        @notice Get the balance of multiple account/token pairs\\n        @param _owners The addresses of the token holders\\n        @param _ids    ID of the Tokens\\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n     */\\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n        @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of the caller's tokens.\\n        @dev MUST emit the ApprovalForAll event on success.\\n        @param _operator  Address to add to the set of authorized operators\\n        @param _approved  True if the operator is approved, false to revoke approval\\n    */\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /**\\n        @notice Queries the approval status of an operator for a given owner.\\n        @param _owner     The owner of the Tokens\\n        @param _operator  Address of authorized operator\\n        @return           True if the operator is approved, false if not\\n    */\\n    function isApprovedForAll(address _owner, address _operator)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\ncontract TransferProxy is OwnableOperatorRole {\\n    function erc721safeTransferFrom(\\n        IERC721 token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external onlyOperator {\\n        token.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function erc1155safeTransferFrom(\\n        IERC1155 token,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external onlyOperator {\\n        token.safeTransferFrom(from, to, id, value, data);\\n    }\\n}\\n\\ncontract TransferProxyForDeprecated is OwnableOperatorRole {\\n    function erc721TransferFrom(\\n        IERC721 token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external onlyOperator {\\n        token.transferFrom(from, to, tokenId);\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\ncontract ERC20TransferProxy is OwnableOperatorRole {\\n    function erc20safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external onlyOperator {\\n        require(\\n            token.transferFrom(from, to, value),\\n            \\\"failure while transferring\\\"\\n        );\\n    }\\n}\\n\\nlibrary UintLibrary {\\n    using SafeMath for uint256;\\n\\n    function toString(uint256 i) internal pure returns (string memory) {\\n        if (i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (i != 0) {\\n            bstr[k--] = byte(uint8(48 + (i % 10)));\\n            i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    function bp(uint256 value, uint256 bpValue)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return value.mul(bpValue).div(10000);\\n    }\\n}\\n\\nlibrary StringLibrary {\\n    using UintLibrary for uint256;\\n\\n    function append(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory ba = bytes(a);\\n        bytes memory bb = bytes(b);\\n        bytes memory bab = new bytes(ba.length + bb.length);\\n        uint256 k = 0;\\n        for (uint256 i = 0; i < ba.length; i++) bab[k++] = ba[i];\\n        for (uint256 i = 0; i < bb.length; i++) bab[k++] = bb[i];\\n        return string(bab);\\n    }\\n\\n    function append(\\n        string memory a,\\n        string memory b,\\n        string memory c\\n    ) internal pure returns (string memory) {\\n        bytes memory ba = bytes(a);\\n        bytes memory bb = bytes(b);\\n        bytes memory bc = bytes(c);\\n        bytes memory bbb = new bytes(ba.length + bb.length + bc.length);\\n        uint256 k = 0;\\n        for (uint256 i = 0; i < ba.length; i++) bbb[k++] = ba[i];\\n        for (uint256 i = 0; i < bb.length; i++) bbb[k++] = bb[i];\\n        for (uint256 i = 0; i < bc.length; i++) bbb[k++] = bc[i];\\n        return string(bbb);\\n    }\\n\\n    function recover(\\n        string memory message,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        bytes memory msgBytes = bytes(message);\\n        bytes memory fullMessage =\\n            concat(\\n                bytes(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\"),\\n                bytes(msgBytes.length.toString()),\\n                msgBytes,\\n                new bytes(0),\\n                new bytes(0),\\n                new bytes(0),\\n                new bytes(0)\\n            );\\n        return ecrecover(keccak256(fullMessage), v, r, s);\\n    }\\n\\n    function concat(\\n        bytes memory ba,\\n        bytes memory bb,\\n        bytes memory bc,\\n        bytes memory bd,\\n        bytes memory be,\\n        bytes memory bf,\\n        bytes memory bg\\n    ) internal pure returns (bytes memory) {\\n        bytes memory resultBytes =\\n            new bytes(\\n                ba.length +\\n                    bb.length +\\n                    bc.length +\\n                    bd.length +\\n                    be.length +\\n                    bf.length +\\n                    bg.length\\n            );\\n        uint256 k = 0;\\n        for (uint256 i = 0; i < ba.length; i++) resultBytes[k++] = ba[i];\\n        for (uint256 i = 0; i < bb.length; i++) resultBytes[k++] = bb[i];\\n        for (uint256 i = 0; i < bc.length; i++) resultBytes[k++] = bc[i];\\n        for (uint256 i = 0; i < bd.length; i++) resultBytes[k++] = bd[i];\\n        for (uint256 i = 0; i < be.length; i++) resultBytes[k++] = be[i];\\n        for (uint256 i = 0; i < bf.length; i++) resultBytes[k++] = bf[i];\\n        for (uint256 i = 0; i < bg.length; i++) resultBytes[k++] = bg[i];\\n        return resultBytes;\\n    }\\n}\\n\\nlibrary BytesLibrary {\\n    function toString(bytes32 value) internal pure returns (string memory) {\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n        bytes memory str = new bytes(64);\\n        for (uint256 i = 0; i < 32; i++) {\\n            str[i * 2] = alphabet[uint8(value[i] >> 4)];\\n            str[1 + i * 2] = alphabet[uint8(value[i] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\\n\\ncontract ExchangeDomainV1 {\\n    enum AssetType {ETH, ERC20, ERC1155, ERC721, ERC721Deprecated}\\n\\n    struct Asset {\\n        address token;\\n        uint256 tokenId;\\n        AssetType assetType;\\n    }\\n\\n    struct OrderKey {\\n        /* who signed the order */\\n        address owner;\\n        /* random number */\\n        uint256 salt;\\n        /* what has owner */\\n        Asset sellAsset;\\n        /* what wants owner */\\n        Asset buyAsset;\\n    }\\n\\n    struct Order {\\n        OrderKey key;\\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint256 selling;\\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint256 buying;\\n        /* fee for selling */\\n        uint256 sellerFee;\\n    }\\n\\n    /* An ECDSA signature. */\\n    struct Sig {\\n        /* v parameter */\\n        uint8 v;\\n        /* r parameter */\\n        bytes32 r;\\n        /* s parameter */\\n        bytes32 s;\\n    }\\n}\\n\\ncontract ExchangeStateV1 is OwnableOperatorRole {\\n    // keccak256(OrderKey) => completed\\n    mapping(bytes32 => uint256) public completed;\\n\\n    function getCompleted(ExchangeDomainV1.OrderKey calldata key)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return completed[getCompletedKey(key)];\\n    }\\n\\n    function setCompleted(\\n        ExchangeDomainV1.OrderKey calldata key,\\n        uint256 newCompleted\\n    ) external onlyOperator {\\n        completed[getCompletedKey(key)] = newCompleted;\\n    }\\n\\n    function getCompletedKey(ExchangeDomainV1.OrderKey memory key)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    key.owner,\\n                    key.sellAsset.token,\\n                    key.sellAsset.tokenId,\\n                    key.buyAsset.token,\\n                    key.buyAsset.tokenId,\\n                    key.salt\\n                )\\n            );\\n    }\\n}\\n\\ncontract ExchangeOrdersHolderV1 {\\n    mapping(bytes32 => OrderParams) internal orders;\\n\\n    struct OrderParams {\\n        /* how much has owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint256 selling;\\n        /* how much wants owner (in wei, or UINT256_MAX if ERC-721) */\\n        uint256 buying;\\n        /* fee for selling */\\n        uint256 sellerFee;\\n    }\\n\\n    function add(ExchangeDomainV1.Order calldata order) external {\\n        require(\\n            msg.sender == order.key.owner,\\n            \\\"order could be added by owner only\\\"\\n        );\\n        bytes32 key = prepareKey(order);\\n        orders[key] = OrderParams(order.selling, order.buying, order.sellerFee);\\n    }\\n\\n    function exists(ExchangeDomainV1.Order calldata order)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        bytes32 key = prepareKey(order);\\n        OrderParams memory params = orders[key];\\n        return\\n            params.buying == order.buying &&\\n            params.selling == order.selling &&\\n            params.sellerFee == order.sellerFee;\\n    }\\n\\n    function prepareKey(ExchangeDomainV1.Order memory order)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    order.key.sellAsset.token,\\n                    order.key.sellAsset.tokenId,\\n                    order.key.owner,\\n                    order.key.buyAsset.token,\\n                    order.key.buyAsset.tokenId,\\n                    order.key.salt\\n                )\\n            );\\n    }\\n}\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor() internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\\ncontract HasSecondarySaleFees is ERC165 {\\n    event SecondarySaleFees(\\n        uint256 tokenId,\\n        address[] recipients,\\n        uint256[] bps\\n    );\\n\\n    /*\\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *\\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\\n     */\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n\\n    constructor() public {\\n        _registerInterface(_INTERFACE_ID_FEES);\\n    }\\n\\n    function getFeeRecipients(uint256 id)\\n        external\\n        view\\n        returns (address payable[] memory);\\n\\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\\ncontract ExchangeV1 is Ownable, ExchangeDomainV1 {\\n    using SafeMath for uint256;\\n    using UintLibrary for uint256;\\n    using StringLibrary for string;\\n    using BytesLibrary for bytes32;\\n\\n    enum FeeSide {NONE, SELL, BUY}\\n\\n    event Buy(\\n        address indexed sellToken,\\n        uint256 indexed sellTokenId,\\n        uint256 sellValue,\\n        address owner,\\n        address buyToken,\\n        uint256 buyTokenId,\\n        uint256 buyValue,\\n        address buyer,\\n        uint256 amount,\\n        uint256 salt\\n    );\\n\\n    event Cancel(\\n        address indexed sellToken,\\n        uint256 indexed sellTokenId,\\n        address owner,\\n        address buyToken,\\n        uint256 buyTokenId,\\n        uint256 salt\\n    );\\n\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    uint256 private constant UINT256_MAX = 2**256 - 1;\\n\\n    address payable public beneficiary;\\n    address public buyerFeeSigner;\\n\\n    TransferProxy public transferProxy;\\n    TransferProxyForDeprecated public transferProxyForDeprecated;\\n    ERC20TransferProxy public erc20TransferProxy;\\n    ExchangeStateV1 public state;\\n    ExchangeOrdersHolderV1 public ordersHolder;\\n\\n    constructor(\\n        TransferProxy _transferProxy,\\n        TransferProxyForDeprecated _transferProxyForDeprecated,\\n        ERC20TransferProxy _erc20TransferProxy,\\n        ExchangeStateV1 _state,\\n        ExchangeOrdersHolderV1 _ordersHolder,\\n        address payable _beneficiary,\\n        address _buyerFeeSigner\\n    ) public {\\n        transferProxy = _transferProxy;\\n        transferProxyForDeprecated = _transferProxyForDeprecated;\\n        erc20TransferProxy = _erc20TransferProxy;\\n        state = _state;\\n        ordersHolder = _ordersHolder;\\n        beneficiary = _beneficiary;\\n        buyerFeeSigner = _buyerFeeSigner;\\n    }\\n\\n    function setBeneficiary(address payable newBeneficiary) external onlyOwner {\\n        beneficiary = newBeneficiary;\\n    }\\n\\n    function setBuyerFeeSigner(address newBuyerFeeSigner) external onlyOwner {\\n        buyerFeeSigner = newBuyerFeeSigner;\\n    }\\n\\n    function exchange(\\n        Order calldata order,\\n        Sig calldata sig,\\n        uint256 buyerFee,\\n        Sig calldata buyerFeeSig,\\n        uint256 amount,\\n        address buyer\\n    ) external payable {\\n        validateOrderSig(order, sig);\\n        validateBuyerFeeSig(order, buyerFee, buyerFeeSig);\\n        uint256 paying = order.buying.mul(amount).div(order.selling);\\n        verifyOpenAndModifyOrderState(order.key, order.selling, amount);\\n        require(\\n            order.key.sellAsset.assetType != AssetType.ETH,\\n            \\\"ETH is not supported on sell side\\\"\\n        );\\n        if (order.key.buyAsset.assetType == AssetType.ETH) {\\n            validateEthTransfer(paying, buyerFee);\\n        }\\n        FeeSide feeSide =\\n            getFeeSide(\\n                order.key.sellAsset.assetType,\\n                order.key.buyAsset.assetType\\n            );\\n        if (buyer == address(0x0)) {\\n            buyer = msg.sender;\\n        }\\n        transferWithFeesPossibility(\\n            order.key.sellAsset,\\n            amount,\\n            order.key.owner,\\n            buyer,\\n            feeSide == FeeSide.SELL,\\n            buyerFee,\\n            order.sellerFee,\\n            order.key.buyAsset\\n        );\\n        transferWithFeesPossibility(\\n            order.key.buyAsset,\\n            paying,\\n            msg.sender,\\n            order.key.owner,\\n            feeSide == FeeSide.BUY,\\n            order.sellerFee,\\n            buyerFee,\\n            order.key.sellAsset\\n        );\\n        emitBuy(order, amount, buyer);\\n    }\\n\\n    function validateEthTransfer(uint256 value, uint256 buyerFee)\\n        internal\\n        view\\n    {\\n        uint256 buyerFeeValue = value.bp(buyerFee);\\n        require(msg.value == value + buyerFeeValue, \\\"msg.value is incorrect\\\");\\n    }\\n\\n    function cancel(OrderKey calldata key) external {\\n        require(key.owner == msg.sender, \\\"not an owner\\\");\\n        state.setCompleted(key, UINT256_MAX);\\n        emit Cancel(\\n            key.sellAsset.token,\\n            key.sellAsset.tokenId,\\n            msg.sender,\\n            key.buyAsset.token,\\n            key.buyAsset.tokenId,\\n            key.salt\\n        );\\n    }\\n\\n    function validateOrderSig(Order memory order, Sig memory sig)\\n        internal\\n        view\\n    {\\n        if (sig.v == 0 && sig.r == bytes32(0x0) && sig.s == bytes32(0x0)) {\\n            require(ordersHolder.exists(order), \\\"incorrect signature\\\");\\n        } else {\\n            require(\\n                prepareMessage(order).recover(sig.v, sig.r, sig.s) ==\\n                    order.key.owner,\\n                \\\"incorrect signature\\\"\\n            );\\n        }\\n    }\\n\\n    function validateBuyerFeeSig(\\n        Order memory order,\\n        uint256 buyerFee,\\n        Sig memory sig\\n    ) internal view {\\n        require(\\n            prepareBuyerFeeMessage(order, buyerFee).recover(\\n                sig.v,\\n                sig.r,\\n                sig.s\\n            ) == buyerFeeSigner,\\n            \\\"incorrect buyer fee signature\\\"\\n        );\\n    }\\n\\n    function prepareBuyerFeeMessage(Order memory order, uint256 fee)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return keccak256(abi.encode(order, fee)).toString();\\n    }\\n\\n    function prepareMessage(Order memory order)\\n        public\\n        pure\\n        returns (string memory)\\n    {\\n        return keccak256(abi.encode(order)).toString();\\n    }\\n\\n    function transferWithFeesPossibility(\\n        Asset memory firstType,\\n        uint256 value,\\n        address from,\\n        address to,\\n        bool hasFee,\\n        uint256 sellerFee,\\n        uint256 buyerFee,\\n        Asset memory secondType\\n    ) internal {\\n        if (!hasFee) {\\n            transfer(firstType, value, from, to);\\n        } else {\\n            transferWithFees(\\n                firstType,\\n                value,\\n                from,\\n                to,\\n                sellerFee,\\n                buyerFee,\\n                secondType\\n            );\\n        }\\n    }\\n\\n    function transfer(\\n        Asset memory asset,\\n        uint256 value,\\n        address from,\\n        address to\\n    ) internal {\\n        if (asset.assetType == AssetType.ETH) {\\n            address payable toPayable = address(uint160(to));\\n            toPayable.transfer(value);\\n        } else if (asset.assetType == AssetType.ERC20) {\\n            require(asset.tokenId == 0, \\\"tokenId should be 0\\\");\\n            erc20TransferProxy.erc20safeTransferFrom(\\n                IERC20(asset.token),\\n                from,\\n                to,\\n                value\\n            );\\n        } else if (asset.assetType == AssetType.ERC721) {\\n            require(value == 1, \\\"value should be 1 for ERC-721\\\");\\n            transferProxy.erc721safeTransferFrom(\\n                IERC721(asset.token),\\n                from,\\n                to,\\n                asset.tokenId\\n            );\\n        } else if (asset.assetType == AssetType.ERC721Deprecated) {\\n            require(value == 1, \\\"value should be 1 for ERC-721\\\");\\n            transferProxyForDeprecated.erc721TransferFrom(\\n                IERC721(asset.token),\\n                from,\\n                to,\\n                asset.tokenId\\n            );\\n        } else {\\n            transferProxy.erc1155safeTransferFrom(\\n                IERC1155(asset.token),\\n                from,\\n                to,\\n                asset.tokenId,\\n                value,\\n                \\\"\\\"\\n            );\\n        }\\n    }\\n\\n    function transferWithFees(\\n        Asset memory firstType,\\n        uint256 value,\\n        address from,\\n        address to,\\n        uint256 sellerFee,\\n        uint256 buyerFee,\\n        Asset memory secondType\\n    ) internal {\\n        uint256 restValue =\\n            transferFeeToBeneficiary(\\n                firstType,\\n                from,\\n                value,\\n                sellerFee,\\n                buyerFee\\n            );\\n        if (\\n            (secondType.assetType == AssetType.ERC1155 &&\\n                IERC1155(secondType.token).supportsInterface(\\n                    _INTERFACE_ID_FEES\\n                )) ||\\n            ((secondType.assetType == AssetType.ERC721 ||\\n                secondType.assetType == AssetType.ERC721Deprecated) &&\\n                IERC721(secondType.token).supportsInterface(_INTERFACE_ID_FEES))\\n        ) {\\n            HasSecondarySaleFees withFees =\\n                HasSecondarySaleFees(secondType.token);\\n            address payable[] memory recipients =\\n                withFees.getFeeRecipients(secondType.tokenId);\\n            uint256[] memory fees = withFees.getFeeBps(secondType.tokenId);\\n            require(fees.length == recipients.length);\\n            for (uint256 i = 0; i < fees.length; i++) {\\n                (uint256 newRestValue, uint256 current) =\\n                    subFeeInBp(restValue, value, fees[i]);\\n                restValue = newRestValue;\\n                transfer(firstType, current, from, recipients[i]);\\n            }\\n        }\\n        address payable toPayable = address(uint160(to));\\n        transfer(firstType, restValue, from, toPayable);\\n    }\\n\\n    function transferFeeToBeneficiary(\\n        Asset memory asset,\\n        address from,\\n        uint256 total,\\n        uint256 sellerFee,\\n        uint256 buyerFee\\n    ) internal returns (uint256) {\\n        (uint256 restValue, uint256 sellerFeeValue) =\\n            subFeeInBp(total, total, sellerFee);\\n        uint256 buyerFeeValue = total.bp(buyerFee);\\n        uint256 beneficiaryFee = buyerFeeValue.add(sellerFeeValue);\\n        if (beneficiaryFee > 0) {\\n            transfer(asset, beneficiaryFee, from, beneficiary);\\n        }\\n        return restValue;\\n    }\\n\\n    function emitBuy(\\n        Order memory order,\\n        uint256 amount,\\n        address buyer\\n    ) internal {\\n        emit Buy(\\n            order.key.sellAsset.token,\\n            order.key.sellAsset.tokenId,\\n            order.selling,\\n            order.key.owner,\\n            order.key.buyAsset.token,\\n            order.key.buyAsset.tokenId,\\n            order.buying,\\n            buyer,\\n            amount,\\n            order.key.salt\\n        );\\n    }\\n\\n    function subFeeInBp(\\n        uint256 value,\\n        uint256 total,\\n        uint256 feeInBp\\n    ) internal pure returns (uint256 newValue, uint256 realFee) {\\n        return subFee(value, total.bp(feeInBp));\\n    }\\n\\n    function subFee(uint256 value, uint256 fee)\\n        internal\\n        pure\\n        returns (uint256 newValue, uint256 realFee)\\n    {\\n        if (value > fee) {\\n            newValue = value - fee;\\n            realFee = fee;\\n        } else {\\n            newValue = 0;\\n            realFee = value;\\n        }\\n    }\\n\\n    function verifyOpenAndModifyOrderState(\\n        OrderKey memory key,\\n        uint256 selling,\\n        uint256 amount\\n    ) internal {\\n        uint256 completed = state.getCompleted(key);\\n        uint256 newCompleted = completed.add(amount);\\n        require(\\n            newCompleted <= selling,\\n            \\\"not enough stock of order for buying\\\"\\n        );\\n        state.setCompleted(key, newCompleted);\\n    }\\n\\n    function getFeeSide(AssetType sellType, AssetType buyType)\\n        internal\\n        pure\\n        returns (FeeSide)\\n    {\\n        if (\\n            (sellType == AssetType.ERC721 ||\\n                sellType == AssetType.ERC721Deprecated) &&\\n            (buyType == AssetType.ERC721 ||\\n                buyType == AssetType.ERC721Deprecated)\\n        ) {\\n            return FeeSide.NONE;\\n        }\\n        if (uint256(sellType) > uint256(buyType)) {\\n            return FeeSide.BUY;\\n        }\\n        return FeeSide.SELL;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"_transferProxy\",\"type\":\"address\"},{\"internalType\":\"contract TransferProxyForDeprecated\",\"name\":\"_transferProxyForDeprecated\",\"type\":\"address\"},{\"internalType\":\"contract ERC20TransferProxy\",\"name\":\"_erc20TransferProxy\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeStateV1\",\"name\":\"_state\",\"type\":\"address\"},{\"internalType\":\"contract ExchangeOrdersHolderV1\",\"name\":\"_ordersHolder\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyerFeeSigner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyerFeeSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20TransferProxy\",\"outputs\":[{\"internalType\":\"contract ERC20TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomainV1.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ExchangeDomainV1.Sig\",\"name\":\"sig\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct ExchangeDomainV1.Sig\",\"name\":\"buyerFeeSig\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ordersHolder\",\"outputs\":[{\"internalType\":\"contract ExchangeOrdersHolderV1\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomainV1.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"prepareBuyerFeeMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum ExchangeDomainV1.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"}],\"internalType\":\"struct ExchangeDomainV1.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"}],\"internalType\":\"struct ExchangeDomainV1.OrderKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"selling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"internalType\":\"struct ExchangeDomainV1.Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"prepareMessage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBuyerFeeSigner\",\"type\":\"address\"}],\"name\":\"setBuyerFeeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"contract ExchangeStateV1\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferProxyForDeprecated\",\"outputs\":[{\"internalType\":\"contract TransferProxyForDeprecated\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ExchangeV1", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000062f88bb8149c254998df582c5799bed152e68d6000000000000000000000000c790c72bd811b7041abf094f89532ce13a17cc8c0000000000000000000000002ac16f0db41f7b08f018f1f558a52d9601549cb2000000000000000000000000a162e215c87534322d0785bdf10d68037b52d0d200000000000000000000000042c98233cf1a7d881bd5aee8622d7f52a1951f7c000000000000000000000000dc67b57872c18da14efa617018f668db4d08903b000000000000000000000000bd8d213224b594798b31f7a1062476bc401f14c6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}