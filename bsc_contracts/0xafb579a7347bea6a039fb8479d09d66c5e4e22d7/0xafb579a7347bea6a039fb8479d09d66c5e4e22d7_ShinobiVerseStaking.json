{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.14;\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}('');\r\n        require(success, 'Address: unable to send value, recipient may have reverted');\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, 'Address: low-level call failed');\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), 'Address: call to non-contract');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    \r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            'SafeBEP20: approve from non-zero to non-zero allowance'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, 'SafeBEP20: low-level call failed');\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');\r\n        }\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor() {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract ShinobiVerseStaking is Ownable, ReentrancyGuard {\r\n    using SafeBEP20 for IBEP20;\r\n    using Address for address;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;  \r\n        uint256 lastDepositTime;\r\n    }\r\n\r\n    struct PoolInfo{\r\n        uint256 APR;  \r\n        uint256 startEpoch;\r\n        uint256 lockPeriod;\r\n        uint256 depositFee;\r\n        uint256 withdrawFee;\r\n        uint256 emergencyWithdrawFee;\r\n        bool isOpen;\r\n    }\r\n\r\n    IBEP20 SHINO;\r\n\r\n    PoolInfo[] public poolInfo;\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    uint256 public minAmount = 100_000 * (10 ** 9);\r\n    uint256 public maxAmount = 900_000_000 * (10 ** 9);\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n    event DepositFee(address indexed user, uint256 amount);\r\n    event WithdrawFee(address indexed user, uint256 amount);\r\n    event EmergencyWithdrawFee(address indexed user, uint256 amount);\r\n\r\n    constructor(IBEP20 _SHINO) {\r\n        SHINO = _SHINO;\r\n    }\r\n\r\n    function addPool(PoolInfo memory pool) external onlyOwner{\r\n        poolInfo.push(pool);\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function pendingReward(uint256 _pid,address _user) public view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        \r\n        uint256 lockedTime = block.timestamp > user.lastDepositTime + pool.lockPeriod ? pool.lockPeriod : block.timestamp - user.lastDepositTime;\r\n        uint256 reward = (((user.amount * pool.APR) / 10_000) * lockedTime) / pool.lockPeriod;\r\n        return reward;\r\n    }\r\n\r\n    function deposit(uint256 _pid,uint256 _amount) public nonReentrant{\r\n        require (_amount > 0, 'amount 0');\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        require(pool.isOpen,'pool is closed');\r\n        require(pool.startEpoch < block.timestamp,'pool has not started yet');\r\n        require(user.amount == 0,\"cannot restake\");\r\n        require(_amount >= minAmount && _amount <= maxAmount,'amount out of limits');\r\n        \r\n        SHINO.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\r\n        if(pool.depositFee>0){\r\n            emit DepositFee(address(msg.sender),(_amount * pool.depositFee) / 10_000);\r\n            _amount -= (_amount * pool.depositFee) / 10_000;\r\n            \r\n        }\r\n        user.amount = user.amount + _amount;\r\n        user.lastDepositTime = block.timestamp;\r\n\r\n        emit Deposit(msg.sender, _amount);\r\n    }\r\n\r\n    function canWithdraw(uint256 _pid, address _user) public view returns (bool) {\r\n        return (withdrawCountdown(_pid,_user)==0);\r\n    }\r\n\r\n    function withdrawCountdown(uint256 _pid, address _user) public view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        \r\n        if ((block.timestamp < user.lastDepositTime + pool.lockPeriod)){\r\n            return user.lastDepositTime + pool.lockPeriod -  block.timestamp;\r\n        }else{\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _pid) public nonReentrant{\r\n        require(canWithdraw(_pid,msg.sender),'cannot withdraw yet');\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        uint256  _amount = user.amount;\r\n        require (_amount > 0, 'amount 0');\r\n\r\n        if(pool.withdrawFee>0){\r\n            emit WithdrawFee(address(msg.sender), (_amount * pool.withdrawFee) / 10_000);\r\n            _amount -= (_amount * pool.withdrawFee) / 10_000;\r\n        }\r\n\r\n        _amount += pendingReward(_pid, msg.sender);\r\n        user.amount=0;\r\n        SHINO.safeTransfer(address(msg.sender), _amount);\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function emergencyWithdraw(uint256 _pid) public nonReentrant{\r\n        require(!canWithdraw(_pid,msg.sender),'Use normal withdraw instead');\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        require(user.amount > 0,'amount 0');\r\n\r\n        uint256 _amount=user.amount;\r\n        user.amount = 0;\r\n        if(pool.emergencyWithdrawFee>0){\r\n            emit  EmergencyWithdrawFee(address(msg.sender), (_amount * pool.emergencyWithdrawFee) / 10_000);  \r\n            _amount -= (_amount * pool.emergencyWithdrawFee) / 10_000; \r\n        }\r\n        SHINO.safeTransfer(address(msg.sender), _amount);\r\n        emit EmergencyWithdraw(msg.sender, _amount);\r\n    }\r\n\r\n    function setFees(uint256 _pid,uint depFee,uint emFee,uint wFee) external onlyOwner {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        require(depFee <= 500, \"DeposiFee should be < 5\");\r\n        require(wFee <= 500, \"WithdrawFee should be < 5\");\r\n        require(emFee <= 3000, \"EmergencyWithdrawFee should be <= 30\");\r\n        pool.depositFee = depFee;\r\n        pool.withdrawFee = wFee;\r\n        pool.emergencyWithdrawFee = emFee;\r\n    }\r\n\r\n    function poolStatus(uint256 _pid,bool _isOpen) external onlyOwner{\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        pool.isOpen = _isOpen;\r\n    }\r\n\r\n    function setMinAndMaxStakeAmounts(uint256 _min, uint256 _max) external onlyOwner {\r\n        minAmount = _min;\r\n        maxAmount = _max;\r\n    }\r\n\r\n    function recoverTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\r\n        IBEP20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount); \r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"_SHINO\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFee\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"APR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyWithdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"internalType\":\"struct ShinobiVerseStaking.PoolInfo\",\"name\":\"pool\",\"type\":\"tuple\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"APR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyWithdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"poolStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMinAndMaxStakeAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"withdrawCountdown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ShinobiVerseStaking", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001532c74250de406a83fec3acc8030da4159e4cbb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://17792d1b20e024a486370bcb414c7f69b7b65d0ff30d8909a27cc6aac39c9fcb"}