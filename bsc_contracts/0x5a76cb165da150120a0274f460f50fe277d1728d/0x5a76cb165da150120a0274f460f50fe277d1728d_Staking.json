{"SourceCode": "/** \r\n *  SourceUnit: /home/abc/Documents/ObortechStaking/contracts/Staking.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/abc/Documents/ObortechStaking/contracts/Staking.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n////import \"../utils/Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/abc/Documents/ObortechStaking/contracts/Staking.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * ////IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/abc/Documents/ObortechStaking/contracts/Staking.sol\r\n*/\r\n\r\n////// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n////import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n////import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract Staking is Ownable {\r\n    /// @title Staking pool creator and a Staking contract.\r\n    /// @notice You can use this contract for making staking pools,staking tokens and getting rewards while unstaking them\r\n\r\n    struct stakingPoolInfo {\r\n        uint256 poolId;\r\n        uint256 totalAmountStaked;\r\n        uint256 duration;\r\n        uint256 creationTime;\r\n        uint256 rewardRate;\r\n        bool isStakingAllowed;\r\n    }\r\n\r\n    struct stake {\r\n        uint256 amount;\r\n        uint256 lastInteractedTime;\r\n        uint256 stakeStartTime;\r\n        uint256 stakeEndTime;\r\n        address stakingWallet;\r\n        uint256 poolId;\r\n    }\r\n    //Staking pools\r\n    stakingPoolInfo[] public stakingPools;\r\n\r\n    //user address to staking pool(poolId) to stake data\r\n    //sender => stakingPoolId => stakeDetails\r\n    mapping(address => mapping(uint256 => stake)) public stakes;\r\n\r\n    //Staking and Reward Token\r\n    IERC20 public Token;\r\n\r\n    //User address to staking pool(poolId) to reward data\r\n    //sender => stakingPoolId(poolId) => rewardDetails\r\n    mapping(address => mapping(uint256 => uint256)) internal rewards;\r\n\r\n    //Collected rewards of a user for a specific pool\r\n    //sender => stakingPoolId(poolId) => collected rewards\r\n    mapping(address => mapping(uint256 => uint256)) public collectedRewards;\r\n\r\n    constructor(address _tokenAddress) {\r\n        Token = IERC20(_tokenAddress);\r\n    }\r\n\r\n    /// @notice Returns the accumulated reward for a particaular stake\r\n    /// @param _poolId Id of the pool of which rewards amount is requested\r\n    /// @return The exact reward accumulated till now for the partucular stake passed in\r\n    function viewReward(uint256 _poolId) external view returns (uint256) {\r\n        stake memory currentStake = stakes[msg.sender][_poolId];\r\n        if (currentStake.stakingWallet != address(0)) {\r\n            stakingPoolInfo memory currentStakingPool = stakingPools[\r\n                currentStake.poolId\r\n            ];\r\n            uint256 currentStakeTime;\r\n\r\n            if (block.timestamp > currentStake.stakeEndTime) {\r\n                currentStakeTime =\r\n                    currentStake.stakeEndTime -\r\n                    currentStake.lastInteractedTime;\r\n            } else {\r\n                currentStakeTime =\r\n                    block.timestamp -\r\n                    currentStake.lastInteractedTime;\r\n            }\r\n\r\n            uint256 _rewards = (currentStake.amount *\r\n                currentStakeTime *\r\n                currentStakingPool.rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            _rewards += rewards[currentStake.stakingWallet][\r\n                currentStake.poolId\r\n            ];\r\n            return _rewards;\r\n        } else return 0;\r\n    }\r\n\r\n    function _calculateReward(stake memory currentStake)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        stakingPoolInfo memory currentStakingPool = stakingPools[\r\n            currentStake.poolId\r\n        ];\r\n        uint256 currentStakeTime;\r\n\r\n        if (block.timestamp > currentStake.stakeEndTime) {\r\n            currentStakeTime =\r\n                currentStake.stakeEndTime -\r\n                currentStake.lastInteractedTime;\r\n        } else {\r\n            currentStakeTime =\r\n                block.timestamp -\r\n                currentStake.lastInteractedTime;\r\n        }\r\n\r\n        uint256 _rewards = (currentStake.amount *\r\n            currentStakeTime *\r\n            currentStakingPool.rewardRate *\r\n            1e18) /\r\n            (10000 * 31536000) /\r\n            1e18;\r\n        return rewards[msg.sender][currentStake.poolId] += _rewards;\r\n    }\r\n\r\n    /// @notice To stake tokens\r\n    /// @param _poolId The Id of the pool in which you want to stake\r\n    /// @param _amount The amount of tokens that you want to stake\r\n    /// @return True if successfully staked\r\n    function stakeToken(uint256 _poolId, uint256 _amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        //approve the token the user want to stake to address(this)\r\n        stakingPoolInfo memory currentStakingPool = stakingPools[_poolId];\r\n        stake memory currentStake = stakes[msg.sender][_poolId];\r\n        require(currentStakingPool.isStakingAllowed, \"Staking paused\");\r\n        if (currentStake.stakingWallet == address(0)) {\r\n            uint256 currentReward = (_amount *\r\n                currentStakingPool.duration *\r\n                currentStakingPool.rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            require(\r\n                Token.balanceOf(address(this)) >\r\n                    totalSupply() + totalRewardslocked() + currentReward,\r\n                \"All rewards are allotted\"\r\n            );\r\n            stake memory newStake = stake({\r\n                amount: _amount,\r\n                lastInteractedTime: block.timestamp,\r\n                stakeStartTime: block.timestamp,\r\n                stakeEndTime: block.timestamp + currentStakingPool.duration,\r\n                stakingWallet: msg.sender,\r\n                poolId: _poolId\r\n            });\r\n            stakes[msg.sender][_poolId] = newStake;\r\n        } else {\r\n            require(\r\n                currentStake.stakeEndTime > block.timestamp,\r\n                \"Time completed , claim rewards\"\r\n            );\r\n            uint256 currentReward = (_amount *\r\n                (currentStake.stakeEndTime - block.timestamp) *\r\n                currentStakingPool.rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            require(\r\n                Token.balanceOf(address(this)) >\r\n                    totalSupply() + totalRewardslocked() + currentReward,\r\n                \"All rewards are allotted\"\r\n            );\r\n            _calculateReward(currentStake);\r\n            stakes[msg.sender][_poolId].amount = currentStake.amount + _amount;\r\n            stakes[msg.sender][_poolId].lastInteractedTime = block.timestamp;\r\n            // stakes[msg.sender][_poolId].isUnstaked = false;\r\n        }\r\n        stakingPools[_poolId].totalAmountStaked += _amount;\r\n        Token.transferFrom(msg.sender, address(this), _amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice To unstake tokens\r\n    /// @param _poolId The Id of the pool from which you want to unstake\r\n    /// @return True if successfully unstaked\r\n    function unstakeToken(uint256 _poolId) external returns (bool) {\r\n        stake memory currentStake = stakes[msg.sender][_poolId];\r\n        require(\r\n            currentStake.stakingWallet != address(0),\r\n            \"Tokens already unstaked\"\r\n        );\r\n        stakingPools[_poolId].totalAmountStaked -= currentStake.amount;\r\n        stakes[msg.sender][_poolId].amount = 0;\r\n        stakes[msg.sender][_poolId].lastInteractedTime = 0;\r\n        stakes[msg.sender][_poolId].stakingWallet = address(0);\r\n        if (block.timestamp < currentStake.stakeEndTime)\r\n            rewards[msg.sender][_poolId] = 0;\r\n        else claimReward(_poolId, currentStake);\r\n        Token.transfer(msg.sender, currentStake.amount);\r\n        return true;\r\n    }\r\n\r\n    function claimReward(uint256 _poolId, stake memory currentStake)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        uint256 currentReward = _calculateReward(currentStake);\r\n        rewards[msg.sender][_poolId] = 0;\r\n        collectedRewards[msg.sender][_poolId] += currentReward;\r\n        Token.transfer(msg.sender, currentReward);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Only for the owner\r\n    /// @notice To make a new staking pool\r\n    /// @param _duration The duration for which the staking pool should be live\r\n    /// @param _rewardRate The reward rate in multiple of 100(e.g. for 12% input 1200 , for 36% input 3600) of the new staking pool that you want to make\r\n    /// @return It returns poolId of the pool that was just made\r\n    function makeStakingPool(uint256 _duration, uint256 _rewardRate)\r\n        external\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        stakingPoolInfo memory currentStakingPool = stakingPoolInfo({\r\n            poolId: stakingPools.length,\r\n            totalAmountStaked: 0,\r\n            duration: _duration,\r\n            creationTime: block.timestamp,\r\n            rewardRate: _rewardRate,\r\n            isStakingAllowed: true\r\n        });\r\n        stakingPools.push(currentStakingPool);\r\n        return stakingPools.length - 1;\r\n    }\r\n\r\n    /// @notice Only for the owner\r\n    /// @notice To pause staking in a staking pool\r\n    /// @param _poolId The Id of the pool that you want to pause or unpause\r\n    /// @param _isAllowed To allow staking ,so input true to unpause staking and false to pause staking\r\n    /// @return True if a pool is paused or unpaused successfully\r\n    function pauseStaking(uint256 _poolId, bool _isAllowed)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        stakingPools[_poolId].isStakingAllowed = _isAllowed;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Total staked tokens, every pool is included\r\n    /// @return Total amount of staked tokens in every pool\r\n    function totalSupply() public view returns (uint256) {\r\n        uint256 _totalSupply;\r\n        for (uint256 i = 0; i < stakingPools.length; i++)\r\n            _totalSupply += stakingPools[i].totalAmountStaked;\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @notice Only for the owner\r\n    /// @notice To transfer remaining reward tokens that are stuck in the contract back to the owner\r\n    /// @param _recipient The address at which the remaining reward tokens should be transferred\r\n    /// @param _amount The amount of the unused reward tokens to be transferred from Staking contract address(address(this)) to owner\r\n    function removeRewardTokens(address _recipient, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _amount <= checkReleasableTokens(),\r\n            \"Amount exceeds releasable tokens\"\r\n        );\r\n        Token.transfer(_recipient, _amount);\r\n    }\r\n\r\n    /// @notice Returns how much rewards tokens can be taken out without including the tokens staked by users\r\n    /// @return The amount of tokens that can be taken out without including the tokens staked by users\r\n    function checkReleasableTokens() public view returns (uint256) {\r\n        require(\r\n            Token.balanceOf(address(this)) -\r\n                (totalSupply() + totalRewardslocked()) >=\r\n                0,\r\n            \"0 releasable, add rewards\"\r\n        );\r\n        return\r\n            Token.balanceOf(address(this)) -\r\n            (totalSupply() + totalRewardslocked());\r\n    }\r\n\r\n    /// @notice Use this function to view details of every pool\r\n    /// @return Returns the details of every pool\r\n    function viewAllPools() external view returns (stakingPoolInfo[] memory) {\r\n        return stakingPools;\r\n    }\r\n\r\n    /// @notice Use this function to view the total number of rewards that are locked\r\n    /// @return totalRewardsLocked - Returns the total number of rewards that are locked\r\n    function totalRewardslocked()\r\n        public\r\n        view\r\n        returns (uint256 totalRewardsLocked)\r\n    {\r\n        stakingPoolInfo[] memory _stakingPools = stakingPools;\r\n        for (uint256 i = 0; i < _stakingPools.length; i++) {\r\n            uint256 amount = _stakingPools[i].totalAmountStaked;\r\n            uint256 reward = (amount *\r\n                _stakingPools[i].duration *\r\n                _stakingPools[i].rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            totalRewardsLocked += reward;\r\n        }\r\n        return totalRewardsLocked;\r\n    }\r\n\r\n    /// @notice Use this function to view the number of rewards that are locked for a particular pool\r\n    /// @param _poolId is the Id of the pool whose locked reward is to be found\r\n    /// @return totalRewardsLocked - Returns the number of rewards that are locked for a particular pool\r\n    function rewardLockedForSinglePool(uint256 _poolId)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        stakingPoolInfo memory _stakingPools = stakingPools[_poolId];\r\n        uint256 amount = _stakingPools.totalAmountStaked;\r\n        uint256 reward = (amount *\r\n            _stakingPools.duration *\r\n            _stakingPools.rewardRate *\r\n            1e18) /\r\n            (10000 * 31536000) /\r\n            1e18;\r\n        return reward;\r\n    }\r\n\r\n    /// @notice Use this function to view the total number of rewards currently inside of the contract\r\n    /// @return totalRewards - Returns the total number of rewards that are locked\r\n    function totalRewards() external view returns (uint256) {\r\n        return Token.balanceOf(address(this)) - totalSupply();\r\n    }\r\n\r\n    /// @notice Use this function to check if a stake of certain amount can be made or not\r\n    /// A stake cannot be made if enough rewards are not already there in the pool\r\n    /// @param _amount the amount that the user want to stake\r\n    /// @param _poolId Id of the pool\r\n    /// @return true - if stake can be made , false - if stake cannot be made\r\n    function isStakable(uint256 _amount, uint256 _poolId)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        stakingPoolInfo memory currentStakingPool = stakingPools[_poolId];\r\n        stake memory currentStake = stakes[msg.sender][_poolId];\r\n        if (currentStake.stakingWallet == address(0)) {\r\n            uint256 currentReward = (_amount *\r\n                currentStakingPool.duration *\r\n                currentStakingPool.rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            if (\r\n                Token.balanceOf(address(this)) >\r\n                totalSupply() + totalRewardslocked() + currentReward\r\n            ) return true;\r\n            else return false;\r\n        } else {\r\n            uint256 currentReward = (_amount *\r\n                (currentStake.stakeEndTime - block.timestamp) *\r\n                currentStakingPool.rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            if (\r\n                Token.balanceOf(address(this)) >\r\n                totalSupply() + totalRewardslocked() + currentReward\r\n            ) return true;\r\n            else return false;\r\n        }\r\n    }\r\n\r\n    /// @notice Use this function to get the total rewards of a particular user for a particular pool\r\n    /// that will be claimed after the staking time ends\r\n    /// @param _poolId Id of the pool\r\n    function getTotalRewardForSinglePool(uint256 _poolId)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        stake memory currentStake = stakes[msg.sender][_poolId];\r\n        stakingPoolInfo memory currentStakingPool = stakingPools[\r\n            currentStake.poolId\r\n        ];\r\n        if (currentStake.stakingWallet != address(0)) {\r\n            uint256 currentStakeTime;\r\n\r\n            currentStakeTime =\r\n                currentStake.stakeEndTime -\r\n                currentStake.lastInteractedTime;\r\n\r\n            uint256 _rewards = (currentStake.amount *\r\n                currentStakeTime *\r\n                currentStakingPool.rewardRate *\r\n                1e18) /\r\n                (10000 * 31536000) /\r\n                1e18;\r\n            _rewards += rewards[currentStake.stakingWallet][\r\n                currentStake.poolId\r\n            ];\r\n            return _rewards;\r\n        } else return 0;\r\n    }\r\n\r\n    /// @notice Use this function to get the details of every pool\r\n    function getAllStakingPools()\r\n        external\r\n        view\r\n        returns (stakingPoolInfo[] memory)\r\n    {\r\n        return stakingPools;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkReleasableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collectedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllStakingPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStakingAllowed\",\"type\":\"bool\"}],\"internalType\":\"struct Staking.stakingPoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"getTotalRewardForSinglePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"isStakable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"}],\"name\":\"makeStakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"pauseStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeRewardTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"rewardLockedForSinglePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastInteractedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeEndTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakingWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStakingAllowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardslocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRewardsLocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"unstakeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAllPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStakingAllowed\",\"type\":\"bool\"}],\"internalType\":\"struct Staking.stakingPoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolId\",\"type\":\"uint256\"}],\"name\":\"viewReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b5be8d87fce6ce87a24b90abdb019458a8ec31f9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://717bb570800a9582678b09a6a4e230190c1f249d9365cce3450b7b004c13c1e2"}