{"SourceCode": "//mmmmmmm..CakeBakery\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\nabstract contract ERC20 {\r\n    function totalSupply() public view virtual returns (uint);\r\n    function balanceOf(address tokenOwner) public view virtual returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\r\n    function transfer(address to, uint tokens) public virtual returns (bool success);\r\n    function approve(address spender, uint tokens) public virtual returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\ncontract CakeBakery {\r\n    using SafeMath for uint256;\r\n    address cakes = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\r\n    //uint256 CAKE_TO_MAKE_BAKERS=1;\r\n    uint256 public CAKE_TO_MAKE_BAKERS=2592000;//for final version should be seconds in a day\r\n    uint256 PSN=10000;\r\n    uint256 PSNH=5000;\r\n    bool public initialized=false;\r\n    address public bakeryAddress;\r\n    address public bakeryAddress2;\r\n    mapping (address => uint256) public bakeryBakers;\r\n    mapping (address => uint256) public claimedCakes;\r\n    mapping (address => uint256) public lastBake;\r\n    mapping (address => address) public referrals;\r\n    uint256 public marketCakes;\r\n    constructor() {\r\n        bakeryAddress=msg.sender;\r\n        bakeryAddress2=address(0xd36c3d2fe5d184d4a6e7F74853817029acC1fB18);\r\n    }\r\n    function bakeCakes(address ref) public{\r\n        require(initialized);\r\n        if(ref == msg.sender) {\r\n            ref = address(0);\r\n        }\r\n        if(referrals[msg.sender]==address(0) && referrals[msg.sender]!=msg.sender){\r\n            referrals[msg.sender]=ref;\r\n        }\r\n        uint256 cakesUsed=getMyCakes();\r\n        uint256 newBakers=SafeMath.div(cakesUsed,CAKE_TO_MAKE_BAKERS);\r\n        bakeryBakers[msg.sender]=SafeMath.add(bakeryBakers[msg.sender],newBakers);\r\n        claimedCakes[msg.sender]=0;\r\n        lastBake[msg.sender]=block.timestamp;\r\n        \r\n        //send referral cakes\r\n        claimedCakes[referrals[msg.sender]]=SafeMath.add(claimedCakes[referrals[msg.sender]],SafeMath.div(cakesUsed,10));\r\n        \r\n        //boost market to nerf miners hoarding\r\n        marketCakes=SafeMath.add(marketCakes,SafeMath.div(cakesUsed,5));\r\n    }\r\n    function sellCakes() public{\r\n        require(initialized);\r\n        uint256 hasCakes=getMyCakes();\r\n        uint256 cakeValue=calculateCakeSell(hasCakes);\r\n        uint256 fee=bakeryFee(cakeValue);\r\n        uint256 fee2=fee/2;\r\n        claimedCakes[msg.sender]=0;\r\n        lastBake[msg.sender]=block.timestamp;\r\n        marketCakes=SafeMath.add(marketCakes,hasCakes);\r\n        ERC20(cakes).transfer(bakeryAddress, fee2);\r\n        ERC20(cakes).transfer(bakeryAddress2, fee-fee2);\r\n        ERC20(cakes).transfer(address(msg.sender), SafeMath.sub(cakeValue,fee));\r\n    }\r\n    function buyCakes(address ref, uint256 amount) public{\r\n        require(initialized);\r\n        ERC20(cakes).transferFrom(address(msg.sender), address(this), amount);\r\n        uint256 balance = ERC20(cakes).balanceOf(address(this));\t\r\n        uint256 cakeBought=calculateCakeBuy(amount,SafeMath.sub(balance,amount));\r\n        cakeBought=SafeMath.sub(cakeBought,bakeryFee(cakeBought));\r\n        uint256 fee=bakeryFee(amount);\r\n        uint256 fee2=fee/2;\r\n        ERC20(cakes).transfer(bakeryAddress, fee2);\r\n        ERC20(cakes).transfer(bakeryAddress2, fee-fee2);\r\n        claimedCakes[msg.sender]=SafeMath.add(claimedCakes[msg.sender],cakeBought);\r\n        bakeCakes(ref);\r\n    }\r\n    //magic trade balancing algorithm\r\n    function calculateTrade(uint256 rt,uint256 rs, uint256 bs) public view returns(uint256){\r\n        //(PSN*bs)/(PSNH+((PSN*rs+PSNH*rt)/rt));\r\n        return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt)));\r\n    }\r\n    function calculateCakeSell(uint256 cake) public view returns(uint256) {\r\n        return calculateTrade(cake,marketCakes,ERC20(cakes).balanceOf(address(this)));\r\n    }\r\n    function calculateCakeBuy(uint256 eth,uint256 contractBalance) public view returns(uint256){\r\n        return calculateTrade(eth,contractBalance,marketCakes);\r\n    }\r\n    function calculateCakeBuySimple(uint256 eth) public view returns(uint256){\r\n        return calculateCakeBuy(eth,ERC20(cakes).balanceOf(address(this)));\r\n    }\r\n    function bakeryFee(uint256 amount) public pure returns(uint256){\r\n        return SafeMath.div(SafeMath.mul(amount,5),100);\r\n    }\r\n    function seedMarket(uint256 amount) public{\r\n        ERC20(cakes).transferFrom(address(msg.sender), address(this), amount);\r\n        require(marketCakes==0);\r\n        initialized=true;\r\n        marketCakes=259200000000;\r\n    }\r\n    function getBalance() public view returns(uint256){\r\n        return ERC20(cakes).balanceOf(address(this));\r\n    }\r\n    function getMyBakers() public view returns(uint256){\r\n        return bakeryBakers[msg.sender];\r\n    }\r\n    function getMyCakes() public view returns(uint256){\r\n        return SafeMath.add(claimedCakes[msg.sender],getCakesSinceLastBake(msg.sender));\r\n    }\r\n    function getCakesSinceLastBake(address adr) public view returns(uint256){\r\n        uint256 secondsPassed=min(CAKE_TO_MAKE_BAKERS,SafeMath.sub(block.timestamp,lastBake[adr]));\r\n        return SafeMath.mul(secondsPassed,bakeryBakers[adr]);\r\n    }\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CAKE_TO_MAKE_BAKERS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"bakeCakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bakeryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bakeryAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bakeryBakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bakeryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyCakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"calculateCakeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"calculateCakeBuySimple\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cake\",\"type\":\"uint256\"}],\"name\":\"calculateCakeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bs\",\"type\":\"uint256\"}],\"name\":\"calculateTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedCakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getCakesSinceLastBake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMyBakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMyCakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketCakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"seedMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellCakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CakeBakery", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dd07f749f2f6d99d295608b23329fc0cb7cf0a34dda16105abeee6ad11cde374"}