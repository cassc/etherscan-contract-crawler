{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/DollarFort.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ncontract DollarFort {\\n    IERC20 public _usdtToken;\\n    uint256 minInvestment = sqn(100);\\n    address _system;\\n    uint256[] public rewards = [3000, 9000, 27000, 81000, 243000, 729000];\\n    uint256 rewardPercentage = 10; // 10% of the achieved business volume\\n    uint256 roiIterations = 365; // for 1 year until 180% for non working & 3x for working ids\\n    uint256 roiPercentage = 5; // 0.5% daily\\n    uint256 directLevelOpenedPerReferral = 1;\\n    uint256 generationLevelOpenedPerReferral = 3;\\n    uint256[] directIncomePercentages = [15, 5, 5, 5, 5, 5, 5, 5, 5, 5]; // 1.5% for 1st level & 0.5% for 2nd to 10th level\\n\\n    // Level 1 to 10 = 3%; Level 11 to 20 = 6%; Level 21 to 30 = 9%;\\n    uint256[] generationIncomePercentages = [\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        30,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        60,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90,\\n        90\\n    ];\\n\\n    address[] public usersList;\\n    address tenPercentOfInvestmentAddress;\\n    address sixPercentOfWithdrawalAddress;\\n\\n    enum ZeroPinMode {\\n        NONE,\\n        RETOPUP_REQUIRED,\\n        FULL\\n    }\\n\\n    event UserRegistered(\\n        address indexed user,\\n        address indexed sponsor,\\n        uint256 investment,\\n        uint256 timestamp\\n    );\\n\\n    struct IncomeTransaction {\\n        address relatedUser;\\n        uint256 relatedInvestmentId;\\n        string class;\\n        uint256 amount;\\n        string description;\\n        uint256 timestamp;\\n    }\\n\\n    struct UserInvestment {\\n        uint256 id;\\n        uint256 amount;\\n        uint256 iterationsLeft;\\n        uint256 timestamp;\\n        uint256 endedTimestamp;\\n        bool hasEnded;\\n        bool isZeroPin;\\n    }\\n\\n    struct UserWithdrawal {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct AchievedReward {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct User {\\n        address addr;\\n        address sponsor;\\n        uint256 rewardCarryForwardAmount;\\n        uint256 balance;\\n        uint registrationTimestamp;\\n        address[] referrals;\\n        uint256 directLevelsOpened;\\n        uint256 generationLevelsOpened;\\n        bool isActive;\\n        ZeroPinMode zeroPinType;\\n    }\\n\\n    struct AdminTransactions {\\n        address user;\\n        uint256 amount;\\n        string desc;\\n        uint256 timestamp;\\n    }\\n\\n    AdminTransactions[] public adminTransactions;\\n\\n    uint256 _investmentIndex = 1;\\n\\n    mapping(address => User) public users;\\n    mapping(address => IncomeTransaction[]) public incomeTransactions;\\n    mapping(address => UserInvestment[]) public userInvestments;\\n    mapping(address => UserWithdrawal[]) public userWithdrawals;\\n    mapping(address => AchievedReward[]) public achievedRewards;\\n\\n    constructor(\\n        address usdtAddress,\\n        address _tenPercentOfInvestmentAddress,\\n        address _sixPercentOfWithdrawalAddress\\n    ) {\\n        _system = msg.sender;\\n        _usdtToken = IERC20(usdtAddress);\\n        tenPercentOfInvestmentAddress = _tenPercentOfInvestmentAddress;\\n        sixPercentOfWithdrawalAddress = _sixPercentOfWithdrawalAddress;\\n\\n        uint256 _systemInvestment = sqn(1000);\\n         users[_system] = User({\\n            addr: _system,\\n            sponsor: address(0),\\n            rewardCarryForwardAmount: 0,\\n            balance: 0,\\n            referrals: new address[](0),\\n            registrationTimestamp: block.timestamp,\\n            directLevelsOpened: 10,\\n            generationLevelsOpened: 30,\\n            isActive: true,\\n            zeroPinType: ZeroPinMode.FULL\\n        });\\n        usersList.push(_system);\\n        userInvestments[_system].push(\\n            UserInvestment({\\n                id: _investmentIndex++,\\n                amount: _systemInvestment,\\n                timestamp: block.timestamp,\\n                endedTimestamp: 0,\\n                iterationsLeft: roiIterations,\\n                hasEnded: false,\\n                isZeroPin: true\\n            })\\n        );\\n       \\n    }\\n\\n    modifier onlySystem() {\\n        require(msg.sender == _system, \\\"Only system can call this function\\\");\\n        _;\\n    }\\n\\n    function sqn(uint256 _n) public pure returns (uint256) {\\n        return _n * 10 ** 18;\\n    }\\n\\n    function nqs(uint256 _n) public pure returns (uint256) {\\n        return _n / 10 ** 18;\\n    }\\n\\n    function _getAdminTransactions()\\n        public\\n        view\\n        onlySystem\\n        returns (AdminTransactions[] memory)\\n    {\\n        return adminTransactions;\\n    }\\n\\n    function _getUsersDetails(\\n        address _addr\\n    ) external view returns (User memory) {\\n        return users[_addr];\\n    }\\n\\n    function _getUsersList() external view returns (address[] memory) {\\n        return usersList;\\n    }\\n\\n    function _getUserIncomeTransactions(\\n        address _address\\n    ) external view returns (IncomeTransaction[] memory) {\\n        return incomeTransactions[_address];\\n    }\\n\\n    function _getUserInvestments(\\n        address _address\\n    ) external view returns (UserInvestment[] memory) {\\n        return userInvestments[_address];\\n    }\\n\\n    function _getUserWithdrawals(\\n        address _address\\n    ) external view returns (UserWithdrawal[] memory) {\\n        return userWithdrawals[_address];\\n    }\\n\\n    function _getAchievedRewards(\\n        address _address\\n    ) external view returns (AchievedReward[] memory) {\\n        return achievedRewards[_address];\\n    }\\n\\n    function userExists(address _address) public view returns (bool) {\\n        return users[_address].addr != address(0);\\n    }\\n\\n    function transferUSDT(address _to, uint256 _amount) external {\\n        require(\\n            _usdtToken.transferFrom(msg.sender, _to, _amount),\\n            \\\"Transfer failed\\\"\\n        );\\n    }\\n\\n    function inCaseOfCalculationError(address _addr) external onlySystem {\\n        _usdtToken.transfer(_addr, getUSDTBalance());\\n    }\\n\\n    function getUSDTBalance() public view onlySystem returns (uint256) {\\n        return _usdtToken.balanceOf(address(this));\\n    }\\n\\n    function _getUserOldestInvestmentWhichHasNotEnded(\\n        address _addr\\n    ) public view returns (UserInvestment memory) {\\n        UserInvestment[] memory investments = userInvestments[_addr];\\n        UserInvestment memory _oldestInvestment;\\n        for (uint256 i = 0; i < investments.length; i++) {\\n            if (investments[i].hasEnded) {\\n                continue;\\n            }\\n\\n            if (_oldestInvestment.timestamp == 0) {\\n                _oldestInvestment = investments[i];\\n            } else {\\n                if (investments[i].timestamp < _oldestInvestment.timestamp) {\\n                    _oldestInvestment = investments[i];\\n                }\\n            }\\n        }\\n\\n        return _oldestInvestment;\\n    }\\n\\n    function _getUserTotalActiveInvestmentAmount(\\n        address _addr\\n    ) public view returns (uint256) {\\n        UserInvestment[] memory investments = userInvestments[_addr];\\n        uint256 _totalActiveInvestmentAmount = 0;\\n        for (uint256 i = 0; i < investments.length; i++) {\\n            if (investments[i].hasEnded) {\\n                continue;\\n            }\\n\\n            _totalActiveInvestmentAmount += investments[i].amount;\\n        }\\n\\n        return _totalActiveInvestmentAmount;\\n    }\\n\\n    function _getUserActiveInvestments(\\n        address _addr\\n    ) public view returns (UserInvestment[] memory) {\\n        UserInvestment[] memory investments = userInvestments[_addr];\\n        UserInvestment[] memory _activeInvestments = new UserInvestment[](\\n            investments.length\\n        );\\n        uint256 _index = 0;\\n\\n        for (uint256 i = 0; i < investments.length; i++) {\\n            if (investments[i].hasEnded) {\\n                continue;\\n            }\\n\\n            _activeInvestments[_index] = investments[i];\\n            _index++;\\n        }\\n\\n        return _activeInvestments;\\n    }\\n\\n\\n    function hasAchievedMaxIncome(User memory user) public view returns (bool) {\\n        uint256 maxRoiPercentage = user.referrals.length == 0 ? 1825 : 3000;\\n        uint256 _totalInvestment = _getUserTotalActiveInvestmentAmount(\\n            user.addr\\n        );\\n        uint256 _maxIncome = (_totalInvestment * maxRoiPercentage) / 1000;\\n        uint256 _totalIncome = 0;\\n\\n        UserInvestment\\n            memory oldestActiveInvestment = _getUserOldestInvestmentWhichHasNotEnded(\\n                user.addr\\n            );\\n\\n        for (uint256 i = 0; i < incomeTransactions[user.addr].length; i++) {\\n            if (\\n                incomeTransactions[user.addr][i].timestamp <\\n                oldestActiveInvestment.timestamp\\n            ) {\\n                continue;\\n            }\\n\\n            _totalIncome += incomeTransactions[user.addr][i].amount;\\n        }\\n\\n        return _totalIncome >= _maxIncome;\\n    }\\n\\n    function disableUsersWhoNeedRetopup() public onlySystem {\\n        for (uint256 i = 0; i < usersList.length; i++) {\\n            User storage _user = users[usersList[i]];\\n\\n            if (_user.zeroPinType == ZeroPinMode.FULL) {\\n                continue;\\n            }\\n\\n            if (_user.isActive && (hasAchievedMaxIncome(_user))) {\\n                _user.isActive = false;\\n\\n                for (\\n                    uint256 j = 0;\\n                    j < userInvestments[_user.addr].length;\\n                    j++\\n                ) {\\n                    if (userInvestments[_user.addr][j].hasEnded) {\\n                        continue;\\n                    }\\n\\n                    userInvestments[_user.addr][j].hasEnded = true;\\n                    userInvestments[_user.addr][j].endedTimestamp = block\\n                        .timestamp;\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getUserLatestActiveInvestment(\\n        address _addr\\n    ) public view returns (UserInvestment memory) {\\n        UserInvestment[] memory investments = userInvestments[_addr];\\n\\n        return investments[investments.length - 1];\\n    }\\n\\n    function userHasBeenRegisteredForLessThan24Hours(\\n        address _addr,\\n        uint256 _predefined\\n    ) public view returns (bool) {\\n        if (_predefined == 0) {\\n            return\\n                block.timestamp -\\n                    _getUserLatestActiveInvestment(_addr).timestamp <\\n                86400;\\n        } else if (_predefined == 1) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function distributeDividend(uint256 _predefined) external onlySystem {\\n        // remember, each user first, then their upline generation\\n        for (uint256 i = 0; i < usersList.length; i++) {\\n            User storage _user = users[usersList[i]];\\n\\n            if (\\n                !_user.isActive ||\\n                userHasBeenRegisteredForLessThan24Hours(_user.addr, _predefined)\\n            ) {\\n                continue;\\n            }\\n\\n            for (uint256 j = 0; j < userInvestments[_user.addr].length; j++) {\\n                if (\\n                    userInvestments[_user.addr][j].hasEnded ||\\n                    userInvestments[_user.addr][j].iterationsLeft == 0\\n                ) {\\n                    continue;\\n                }\\n\\n                uint256 _dividendX = ((userInvestments[_user.addr][j].amount *\\n                    (roiPercentage)) / 1000);\\n\\n                uint256 _dividendForThisInvestment = 0;\\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\\n                    _user.addr\\n                ) * (_user.referrals.length > 0 ? 3000 : 1825)) / 1000;\\n\\n                if (_dividendX > (_maxIncome - _user.balance)) {\\n                    _dividendForThisInvestment = _maxIncome - _user.balance;\\n                } else {\\n                    _dividendForThisInvestment = _dividendX;\\n                }\\n\\n                if (!userInvestments[_user.addr][j].isZeroPin) {\\n                    userInvestments[_user.addr][j].iterationsLeft -= 1;\\n                    userInvestments[_user.addr][j].hasEnded =\\n                        userInvestments[_user.addr][j].iterationsLeft == 0;\\n\\n                    if (userInvestments[_user.addr][j].hasEnded) {\\n                        userInvestments[_user.addr][j].endedTimestamp = block\\n                            .timestamp;\\n                    }\\n\\n                    incomeTransactions[usersList[i]].push(\\n                        IncomeTransaction({\\n                            relatedUser: address(0),\\n                            relatedInvestmentId: userInvestments[_user.addr][j]\\n                                .id,\\n                            class: \\\"self_roi\\\",\\n                            amount: _dividendForThisInvestment,\\n                            description: \\\"Daily Dividend\\\",\\n                            timestamp: block.timestamp\\n                        })\\n                    );\\n\\n                    _user.balance += _dividendForThisInvestment;\\n                }\\n\\n                distributeGenerationIncome(\\n                    usersList[i],\\n                    userInvestments[_user.addr][j].id,\\n                    _dividendForThisInvestment,\\n                    _predefined\\n                );\\n            }\\n        }\\n    }\\n\\n    function distributeGenerationIncome(\\n        address _currentUser,\\n        uint256 _investmentId,\\n        uint256 _dividend,\\n        uint256 _predefined\\n    ) internal onlySystem {\\n        address _sponsorAddress = users[_currentUser].sponsor;\\n        for (uint256 i = 0; i < generationIncomePercentages.length; i++) {\\n            User storage _sponsorUser = users[_sponsorAddress];\\n\\n            if (\\n                _sponsorUser.generationLevelsOpened > i &&\\n                _sponsorUser.isActive &&\\n                !userHasBeenRegisteredForLessThan24Hours(\\n                    _sponsorUser.addr,\\n                    _predefined\\n                )\\n            ) {\\n                uint256 _generationIncomeX = (_dividend *\\n                    generationIncomePercentages[i]) / 1000;\\n\\n                uint256 _generationIncome = 0;\\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\\n                    _sponsorUser.addr\\n                ) * (_sponsorUser.referrals.length > 0 ? 3000 : 1825)) / 1000;\\n\\n                if (_generationIncomeX > (_maxIncome - _sponsorUser.balance)) {\\n                    _generationIncome = _maxIncome - _sponsorUser.balance;\\n                } else {\\n                    _generationIncome = _generationIncomeX;\\n                }\\n\\n                _sponsorUser.balance += _generationIncome;\\n                incomeTransactions[_sponsorUser.addr].push(\\n                    IncomeTransaction({\\n                        relatedInvestmentId: _investmentId,\\n                        class: \\\"generation_roi\\\",\\n                        relatedUser: _currentUser,\\n                        amount: _generationIncome,\\n                        description: \\\"Generation Income\\\",\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n            }\\n\\n            _sponsorAddress = users[_sponsorAddress].sponsor;\\n\\n            if (_sponsorAddress == address(0)) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _getUserTotalBusiness(\\n        address _address\\n    ) public view returns (uint256) {\\n        uint256 _business = 0;\\n        address[] memory stack = new address[](\\n            users[_address].referrals.length\\n        );\\n        uint256 stackSize = users[_address].referrals.length;\\n\\n        for (uint256 i = 0; i < stackSize; i++) {\\n            if (i < stackSize) {\\n                stack[i] = users[_address].referrals[i];\\n            }\\n        }\\n\\n        while (stackSize > 0) {\\n            address currentAddress = stack[stackSize - 1];\\n            stackSize--;\\n\\n            User memory _referral = users[currentAddress];\\n            _business += _getUserTotalActiveInvestmentAmount(_referral.addr);\\n\\n            for (uint256 i = 0; i < _referral.referrals.length; i++) {\\n                if (stackSize < stack.length) {\\n                    stack[stackSize] = _referral.referrals[i];\\n                    stackSize++;\\n                }\\n            }\\n        }\\n\\n        return _business;\\n    }\\n\\n    function _getLegBusiness(address _address) public view returns (uint256) {\\n        User memory user = users[_address];\\n\\n        uint256 _business = _getUserTotalBusiness(_address);\\n\\n        return _business + _getUserTotalActiveInvestmentAmount(user.addr);\\n    }\\n\\n    function checkForReward(address _user) public onlySystem {\\n        User storage _currentUser = users[_user];\\n\\n        if (!_currentUser.isActive) {\\n            return;\\n        }\\n\\n        for (uint256 i = 0; i < rewards.length; i++) {\\n            uint256 rewardAmount = sqn(rewards[i]);\\n            bool hasAchievedReward = false;\\n\\n            for (uint256 j = 0; j < achievedRewards[_user].length; j++) {\\n                if (achievedRewards[_user][j].amount == rewardAmount) {\\n                    hasAchievedReward = true;\\n                    break;\\n                }\\n            }\\n\\n            if (hasAchievedReward) {\\n                continue;\\n            }\\n\\n            uint256 _maxBusinessFromEachLeg = (30 * rewardAmount) / 100;\\n            uint256 _totalBusiness = 0;\\n            uint256 _totalPendingBusiness = 0;\\n\\n            for (uint256 j = 0; j < _currentUser.referrals.length; j++) {\\n                User memory _referral = users[_currentUser.referrals[j]];\\n                uint256 _referralBusiness = _getLegBusiness(_referral.addr);\\n                if (_referralBusiness > _maxBusinessFromEachLeg) {\\n                    _totalBusiness += _maxBusinessFromEachLeg;\\n                    uint256 _pendingBusiness = _referralBusiness -\\n                        _maxBusinessFromEachLeg;\\n                    _totalPendingBusiness += _pendingBusiness > 0\\n                        ? _pendingBusiness\\n                        : 0;\\n                } else {\\n                    _totalBusiness += _referralBusiness;\\n                }\\n            }\\n\\n            uint256 _usedRewardCarryForwardAmount = 0;\\n\\n            if (_totalBusiness < rewardAmount) {\\n                _usedRewardCarryForwardAmount = rewardAmount - _totalBusiness;\\n\\n                if (\\n                    _currentUser.rewardCarryForwardAmount >=\\n                    _usedRewardCarryForwardAmount\\n                ) {\\n                    _currentUser\\n                        .rewardCarryForwardAmount -= _usedRewardCarryForwardAmount;\\n                    _totalBusiness += _usedRewardCarryForwardAmount;\\n                }\\n            }\\n\\n            if (_totalBusiness >= rewardAmount) {\\n                achievedRewards[_user].push(\\n                    AchievedReward({\\n                        amount: rewardAmount,\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n\\n                uint256 _reward = rewardAmount * (rewardPercentage / 100);\\n\\n                _currentUser.rewardCarryForwardAmount += _totalPendingBusiness;\\n\\n                adminTransactions.push(\\n                    AdminTransactions({\\n                        user: _user,\\n                        amount: nqs(_reward),\\n                        desc: \\\"Reward\\\",\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n                _usdtToken.transfer(_currentUser.addr, (_reward));\\n            }\\n        }\\n    }\\n\\n    function withdraw(uint256 _amount) external {\\n        // _amount = _amount / 10**18;\\n        User storage _user = users[msg.sender];\\n\\n        require(_user.isActive, \\\"User is inactive\\\");\\n        require(_amount > 0, \\\"Invalid amount\\\");\\n        require(_amount >= sqn(12), \\\"Min withdrawal limit is $12\\\");\\n        require(_amount <= sqn(600), \\\"Max withdrawal limit is $600\\\");\\n        require(_amount <= users[msg.sender].balance, \\\"Insufficient balance\\\");\\n\\n        uint256 withdrawalAmountInLast24Hours = 0;\\n\\n        if (userWithdrawals[_user.addr].length > 0) {\\n            for (uint256 i = 0; i < userWithdrawals[msg.sender].length; i++) {\\n                if (\\n                    userWithdrawals[msg.sender][i].timestamp >=\\n                    block.timestamp - 86400\\n                ) {\\n                    withdrawalAmountInLast24Hours += userWithdrawals[\\n                        msg.sender\\n                    ][i].amount;\\n                }\\n            }\\n        }\\n\\n        require(\\n            withdrawalAmountInLast24Hours + _amount <= sqn(600),\\n            \\\"Max withdrawal limit is $600 in 24 hrs\\\"\\n        );\\n\\n        uint256 _deduction = (_amount * 6) / 100;\\n        uint256 _finalAmount = _amount - _deduction;\\n\\n        userWithdrawals[_user.addr].push(\\n            UserWithdrawal({amount: _amount, timestamp: block.timestamp})\\n        );\\n\\n        _user.balance -= _amount;\\n\\n        // transfer 6% to admin\\n\\n        _usdtToken.transfer(_user.addr, (_finalAmount));\\n        _usdtToken.transfer(sixPercentOfWithdrawalAddress, (_deduction));\\n\\n        adminTransactions.push(\\n            AdminTransactions({\\n                user: _user.addr,\\n                amount: nqs(_finalAmount),\\n                desc: \\\"Withdrawal\\\",\\n                timestamp: block.timestamp\\n            })\\n        );\\n\\n        adminTransactions.push(\\n            AdminTransactions({\\n                user: _user.addr,\\n                amount: nqs(_deduction),\\n                desc: \\\"Withdrawal Deduction\\\",\\n                timestamp: block.timestamp\\n            })\\n        );\\n    }\\n\\n    function retopup(uint256 _investment) external {\\n        address _userAddress = msg.sender;\\n        require(userExists(_userAddress), \\\"User does not exist\\\");\\n        require(_investment >= minInvestment, \\\"Invalid investment amount\\\");\\n\\n        require(\\n            _usdtToken.transferFrom(msg.sender, address(this), (_investment)),\\n            \\\"Transfer failed\\\"\\n        );\\n\\n        User storage _user = users[msg.sender];\\n\\n        userInvestments[_userAddress].push(\\n            UserInvestment({\\n                id: _investmentIndex++,\\n                iterationsLeft: roiIterations,\\n                amount: _investment,\\n                endedTimestamp: 0,\\n                timestamp: block.timestamp,\\n                hasEnded: false,\\n                isZeroPin: false\\n            })\\n        );\\n        _user.isActive = true;\\n\\n        address _sponsorAddress = _user.sponsor;\\n\\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\\n            User storage _currentSponsorUser = users[_sponsorAddress];\\n            uint256 _directIncomeX = (_investment *\\n                directIncomePercentages[i]) / 1000;\\n\\n            if (\\n                _currentSponsorUser.directLevelsOpened > i &&\\n                _currentSponsorUser.isActive\\n            ) {\\n                uint256 _directIncome = 0;\\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\\n                    _currentSponsorUser.addr\\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\\n                    1000;\\n\\n                if (\\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\\n                ) {\\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\\n                } else {\\n                    _directIncome = _directIncomeX;\\n                }\\n                _currentSponsorUser.balance += _directIncome;\\n                incomeTransactions[_currentSponsorUser.addr].push(\\n                    IncomeTransaction({\\n                        relatedInvestmentId: 0,\\n                        class: \\\"direct_income\\\",\\n                        relatedUser: msg.sender,\\n                        amount: _directIncome,\\n                        description: \\\"Direct Income\\\",\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n            }\\n\\n            _sponsorAddress = _currentSponsorUser.sponsor;\\n\\n            if (_sponsorAddress == address(0)) {\\n                break;\\n            }\\n        }\\n\\n        uint256 adminAmount = ((10 * (_investment)) / 100);\\n        _usdtToken.transfer(tenPercentOfInvestmentAddress, adminAmount);\\n\\n        adminTransactions.push(\\n            AdminTransactions({\\n                user: _user.addr,\\n                amount: adminAmount,\\n                desc: \\\"Reward\\\",\\n                timestamp: block.timestamp\\n            })\\n        );\\n    }\\n\\n    function upgrade(uint256 _investment) external {\\n        address _userAddress = msg.sender;\\n        require(userExists(_userAddress), \\\"User does not exist\\\");\\n        require(users[_userAddress].isActive, \\\"User is inactive\\\");\\n        require(_investment >= minInvestment, \\\"Invalid investment amount\\\");\\n\\n        require(\\n            _usdtToken.transferFrom(msg.sender, address(this), (_investment)),\\n            \\\"Transfer failed\\\"\\n        );\\n\\n        User storage _user = users[msg.sender];\\n\\n        userInvestments[_userAddress].push(\\n            UserInvestment({\\n                id: _investmentIndex++,\\n                iterationsLeft: roiIterations,\\n                amount: _investment,\\n                endedTimestamp: 0,\\n                timestamp: block.timestamp,\\n                hasEnded: false,\\n                isZeroPin: false\\n            })\\n        );\\n\\n        address _sponsorAddress = _user.sponsor;\\n\\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\\n            User storage _currentSponsorUser = users[_sponsorAddress];\\n            uint256 _directIncomeX = (_investment *\\n                directIncomePercentages[i]) / 1000;\\n\\n            if (\\n                _currentSponsorUser.directLevelsOpened > i &&\\n                _currentSponsorUser.isActive\\n            ) {\\n                uint256 _directIncome = 0;\\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\\n                    _currentSponsorUser.addr\\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\\n                    1000;\\n\\n                if (\\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\\n                ) {\\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\\n                } else {\\n                    _directIncome = _directIncomeX;\\n                }\\n                _currentSponsorUser.balance += _directIncome;\\n                incomeTransactions[_currentSponsorUser.addr].push(\\n                    IncomeTransaction({\\n                        relatedInvestmentId: 0,\\n                        class: \\\"direct_income\\\",\\n                        relatedUser: msg.sender,\\n                        amount: _directIncome,\\n                        description: \\\"Direct Income\\\",\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n            }\\n\\n            _sponsorAddress = _currentSponsorUser.sponsor;\\n\\n            if (_sponsorAddress == address(0)) {\\n                break;\\n            }\\n        }\\n\\n        uint256 adminAmount = ((10 * (_investment)) / 100);\\n        _usdtToken.transfer(tenPercentOfInvestmentAddress, adminAmount);\\n\\n        adminTransactions.push(\\n            AdminTransactions({\\n                user: _user.addr,\\n                amount: adminAmount,\\n                desc: \\\"Upgrade\\\",\\n                timestamp: block.timestamp\\n            })\\n        );\\n    }\\n\\n    function registerUser(address _sponsor, uint256 _investment) external {\\n        require(_sponsor != address(0), \\\"Invalid sponsor address\\\");\\n        require(_investment >= minInvestment, \\\"Invalid investment amount\\\");\\n\\n        require(\\n            _usdtToken.transferFrom(msg.sender, address(this), (_investment)),\\n            \\\"Transfer failed\\\"\\n        );\\n\\n        users[msg.sender] = User({\\n            addr: msg.sender,\\n            sponsor: _sponsor,\\n            rewardCarryForwardAmount: 0,\\n            balance: 0,\\n            registrationTimestamp: block.timestamp,\\n            referrals: new address[](0),\\n            directLevelsOpened: 0,\\n            generationLevelsOpened: 0,\\n            isActive: true,\\n            zeroPinType: ZeroPinMode.NONE\\n        });\\n\\n        usersList.push(msg.sender);\\n\\n        userInvestments[msg.sender].push(\\n            UserInvestment({\\n                id: _investmentIndex++,\\n                amount: _investment,\\n                endedTimestamp: 0,\\n                hasEnded: false,\\n                timestamp: block.timestamp,\\n                iterationsLeft: roiIterations,\\n                isZeroPin: false\\n            })\\n        );\\n\\n        address _sponsorAddress = _sponsor;\\n        User storage _sponsorUser = users[_sponsorAddress];\\n        _sponsorUser.referrals.push(msg.sender);\\n        _sponsorUser.directLevelsOpened += directLevelOpenedPerReferral;\\n        _sponsorUser.generationLevelsOpened += generationLevelOpenedPerReferral;\\n\\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\\n            User storage _currentSponsorUser = users[_sponsorAddress];\\n            uint256 _directIncomeX = (_investment *\\n                directIncomePercentages[i]) / 1000;\\n\\n            if (\\n                _currentSponsorUser.directLevelsOpened > i &&\\n                _currentSponsorUser.isActive\\n            ) {\\n                uint256 _directIncome = 0;\\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\\n                    _currentSponsorUser.addr\\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\\n                    1000;\\n\\n                if (\\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\\n                ) {\\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\\n                } else {\\n                    _directIncome = _directIncomeX;\\n                }\\n\\n                _currentSponsorUser.balance += _directIncome;\\n                incomeTransactions[_currentSponsorUser.addr].push(\\n                    IncomeTransaction({\\n                        relatedInvestmentId: 0,\\n                        class: \\\"direct_income\\\",\\n                        relatedUser: msg.sender,\\n                        amount: _directIncome,\\n                        description: \\\"Direct Income\\\",\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n            }\\n\\n            _sponsorAddress = _currentSponsorUser.sponsor;\\n\\n            if (_sponsorAddress == address(0)) {\\n                break;\\n            }\\n        }\\n\\n        uint256 _finalUSDTToAdmin = ((10 * (_investment)) / 100);\\n        _usdtToken.transfer(tenPercentOfInvestmentAddress, _finalUSDTToAdmin);\\n\\n        adminTransactions.push(\\n            AdminTransactions({\\n                user: msg.sender,\\n                amount: _finalUSDTToAdmin,\\n                desc: \\\"Registration\\\",\\n                timestamp: block.timestamp\\n            })\\n        );\\n\\n        emit UserRegistered(msg.sender, _sponsor, _investment, block.timestamp);\\n    }\\n\\n    function registerZeroPinUser(\\n        address _addr,\\n        address _sponsor,\\n        uint256 _investment,\\n        ZeroPinMode _type\\n    ) external onlySystem {\\n        // require(_sponsor != address(0), \\\"Invalid sponsor address\\\");\\n        require(_investment >= minInvestment, \\\"Invalid investment amount\\\");\\n\\n        users[_addr] = User({\\n            addr: _addr,\\n            sponsor: _sponsor,\\n            rewardCarryForwardAmount: 0,\\n            balance: 0,\\n            registrationTimestamp: block.timestamp,\\n            referrals: new address[](0),\\n            directLevelsOpened: _type == ZeroPinMode.FULL ? 10 : 0,\\n            generationLevelsOpened: _type == ZeroPinMode.FULL ? 30 : 0,\\n            isActive: true,\\n            zeroPinType: _type\\n        });\\n\\n        usersList.push(_addr);\\n\\n        userInvestments[_addr].push(\\n            UserInvestment({\\n                id: _investmentIndex++,\\n                amount: _investment,\\n                endedTimestamp: 0,\\n                hasEnded: false,\\n                timestamp: block.timestamp,\\n                iterationsLeft: roiIterations,\\n                isZeroPin: true\\n            })\\n        );\\n\\n        address _sponsorAddress = _sponsor;\\n        User storage _sponsorUser = users[_sponsorAddress];\\n        _sponsorUser.referrals.push(_addr);\\n        _sponsorUser.directLevelsOpened += directLevelOpenedPerReferral;\\n        _sponsorUser.generationLevelsOpened += generationLevelOpenedPerReferral;\\n\\n        for (uint256 i = 0; i < directIncomePercentages.length; i++) {\\n            User storage _currentSponsorUser = users[_sponsorAddress];\\n            uint256 _directIncomeX = (_investment *\\n                directIncomePercentages[i]) / 1000;\\n\\n            if (\\n                _currentSponsorUser.directLevelsOpened > i &&\\n                _currentSponsorUser.isActive\\n            ) {\\n                uint256 _directIncome = 0;\\n                uint256 _maxIncome = (_getUserTotalActiveInvestmentAmount(\\n                    _currentSponsorUser.addr\\n                ) * (_currentSponsorUser.referrals.length > 0 ? 3000 : 1825)) /\\n                    1000;\\n\\n                if (\\n                    _directIncomeX > (_maxIncome - _currentSponsorUser.balance)\\n                ) {\\n                    _directIncome = _maxIncome - _currentSponsorUser.balance;\\n                } else {\\n                    _directIncome = _directIncomeX;\\n                }\\n\\n                _currentSponsorUser.balance += _directIncome;\\n                incomeTransactions[_currentSponsorUser.addr].push(\\n                    IncomeTransaction({\\n                        relatedInvestmentId: 0,\\n                        class: \\\"direct_income\\\",\\n                        relatedUser: _addr,\\n                        amount: _directIncome,\\n                        description: \\\"Direct Income\\\",\\n                        timestamp: block.timestamp\\n                    })\\n                );\\n            }\\n\\n            _sponsorAddress = _currentSponsorUser.sponsor;\\n\\n            if (_sponsorAddress == address(0)) {\\n                break;\\n            }\\n        }\\n\\n        emit UserRegistered(_addr, _sponsor, _investment, block.timestamp);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdtAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tenPercentOfInvestmentAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sixPercentOfWithdrawalAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getAchievedRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.AchievedReward[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAdminTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.AdminTransactions[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getLegBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserActiveInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserIncomeTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"relatedUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relatedInvestmentId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.IncomeTransaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserLatestActiveInvestment\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserOldestInvestmentWhichHasNotEnded\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"internalType\":\"struct DollarFort.UserInvestment\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUserTotalActiveInvestmentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserTotalBusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_getUserWithdrawals\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct DollarFort.UserWithdrawal[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_getUsersDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"zeroPinType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFort.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getUsersList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"achievedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkForReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableUsersWhoNeedRetopup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_predefined\",\"type\":\"uint256\"}],\"name\":\"distributeDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUSDTBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"directLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"zeroPinType\",\"type\":\"uint8\"}],\"internalType\":\"struct DollarFort.User\",\"name\":\"user\",\"type\":\"tuple\"}],\"name\":\"hasAchievedMaxIncome\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"inCaseOfCalculationError\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"incomeTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"relatedUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relatedInvestmentId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"class\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"nqs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"}],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"registerZeroPinUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"}],\"name\":\"retopup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"sqn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investment\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"userExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_predefined\",\"type\":\"uint256\"}],\"name\":\"userHasBeenRegisteredForLessThan24Hours\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInvestments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterationsLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasEnded\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isZeroPin\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardCarryForwardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationLevelsOpened\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"enum DollarFort.ZeroPinMode\",\"name\":\"zeroPinType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usersList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DollarFort", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000006b6b83cea7088734cfe8265ef90a48c956848d26000000000000000000000000ea9761466a71c320adc665e32ed244b2edbb9c29", "EVMVersion": "berlin", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}