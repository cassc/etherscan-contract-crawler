{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-07-17\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2023-06-19\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract ICO {\r\n    IERC20 public token;\r\n\r\n    IERC20 public fiat;\r\n\r\n    address payable owner;\r\n\r\n    //ICO should have an enum with four rounds\r\n    enum Stages {\r\n        FF,\r\n        PRIVATE1,\r\n        PRIVATE2,\r\n        PUBLIC\r\n    }\r\n\r\n    enum Planets {\r\n        Mercury,\r\n        Venus,\r\n        Mars,\r\n        Earth,\r\n        Jupiter,\r\n        Saturn,\r\n        Uranus,\r\n        Neptune\r\n    }\r\n\r\n    uint256 public endTime;\r\n\r\n    uint8 public current_round = 0;\r\n    uint8 public vestingPeriods = 18;\r\n    uint8 public vestingPercent = 50;\r\n\r\n    struct Buyer {\r\n        address buyer;\r\n        // uint256 amountFunded;\r\n        // uint256 amountDue;\r\n        // uint256 amountClaimed;\r\n        //uint8 timesClaimed;\r\n        Package[] packages;\r\n        uint256 nextClaim;\r\n    }\r\n\r\n    struct Package {\r\n        uint256 amountFunded;\r\n        uint256 amountDue;\r\n        uint256 amountClaimed;\r\n        uint8 timesClaimed;\r\n        uint8 round;\r\n    }\r\n\r\n    struct Referrer {\r\n        address referrer;\r\n        uint256 referralsMade;\r\n        uint256 amountEarned;\r\n    }\r\n\r\n    mapping(Planets => uint256) public prices;\r\n    mapping(Planets => uint256) public discounts;\r\n    mapping(address => Buyer) public contributions;\r\n    mapping(uint256 => address) public referrers;\r\n    mapping(uint256 => address) public addressByRefCode;\r\n    mapping(address => uint256) public refByAddress;\r\n    mapping(address => Referrer) public referrals;\r\n\r\n    uint256 public sold;\r\n    uint256 public tokenPrice = .008 ether;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _token,\r\n        address _fiat,\r\n        address payable _owner\r\n    ) {\r\n        token = IERC20(_token);\r\n        fiat = IERC20(_fiat);\r\n        owner = _owner;\r\n\r\n        discounts[Planets.Mercury] = 0;\r\n        discounts[Planets.Venus] = 0;\r\n        discounts[Planets.Mars] = 0;\r\n        discounts[Planets.Earth] = 3;\r\n        discounts[Planets.Jupiter] = 12;\r\n        discounts[Planets.Saturn] = 9;\r\n        discounts[Planets.Uranus] = 7;\r\n        discounts[Planets.Neptune] = 5;\r\n\r\n        prices[Planets.Mercury] = 200;\r\n        prices[Planets.Venus] = 1100;\r\n        prices[Planets.Mars] = 500;\r\n        prices[Planets.Earth] = 2300;\r\n        prices[Planets.Jupiter] = 48000;\r\n        prices[Planets.Saturn] = 23000;\r\n        prices[Planets.Uranus] = 11000;\r\n        prices[Planets.Neptune] = 5000;\r\n    }\r\n\r\n    //create random referral code\r\n    function random(address _addr) private view returns (uint256) {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(block.prevrandao, block.timestamp, _addr)\r\n                )\r\n            ) % 10000000000;\r\n    }\r\n\r\n    function addReferralAddress(address _addr) public {\r\n        uint256 _referralCode = random(_addr);\r\n        referrers[_referralCode] = _addr;\r\n        refByAddress[_addr] = _referralCode;\r\n        addressByRefCode[_referralCode] = _addr;\r\n\r\n        referrals[_addr] = Referrer(_addr, 0, 0);\r\n    }\r\n\r\n    function getAddrByRefCode(uint256 _code) public view returns (address) {\r\n        return addressByRefCode[_code];\r\n    }\r\n\r\n    function getRefByAddress(address _addr) public view returns (uint256) {\r\n        return refByAddress[_addr];\r\n    }\r\n\r\n    function getTotalRefRevenue(address _addr) public view returns (uint256) {\r\n        return referrals[_addr].amountEarned;\r\n    }\r\n\r\n    //Added getclaim period function to let people know they can claim their next batch\r\n    function getClaimPeriod(address _addr) public view returns (uint256) {\r\n        return contributions[_addr].nextClaim;\r\n    }\r\n\r\n    function getAmountDue(address _addr) public view returns (uint256){\r\n        uint256 amountDue = amountDuePackages(_addr);\r\n        return amountDue;\r\n    }\r\n\r\n    function getAmountClaim(address _addr) public view returns (uint256){\r\n        uint256 amountClaim = amountToClaimPackages(_addr);\r\n        return amountClaim;\r\n    }\r\n\r\n    function getAmountClaimed(address _addr) public view returns (uint256){\r\n        uint256 amountClaimed = amountClaimedPackages(_addr);\r\n        return amountClaimed;\r\n    }\r\n\r\n    function getContributionsPackages(address _addr) public view returns(Package[] memory) {\r\n        return contributions[_addr].packages;\r\n    }\r\n\r\n    function buyTokens(Planets _package, uint256 refCode) external {\r\n       \r\n        require(\r\n            fiat.balanceOf(msg.sender) >=\r\n                prices[_package] * 10**fiat.decimals(), \r\n            \"Insufficient balance\"\r\n        );\r\n        uint256 amountSent = prices[_package] * 10**fiat.decimals();\r\n        uint256 convertedToken = (prices[_package] * 10**token.decimals()) /\r\n            tokenPrice;\r\n        uint256 amountReceived;\r\n        uint256 tgeAmount;\r\n\r\n        /*require(\r\n            token.balanceOf(address(this)) >= amountReceived,\r\n            \"Insufficient balance of InfinityBee held in contract to complete order\"\r\n        );*/\r\n        require(referrers[refCode] != msg.sender, \"Can't refer yourself\");\r\n        if (referrers[refCode] != address(0)) {\r\n            address refAddr = getAddrByRefCode(refCode);\r\n            uint256 commission = (amountSent * 5) / 100;\r\n            uint256 discount = (amountSent * 5)/ 100;\r\n\r\n            amountSent = amountSent - commission - discount;\r\n            referrals[refAddr].referralsMade++;\r\n            referrals[refAddr].amountEarned += commission;\r\n\r\n            fiat.transferFrom(msg.sender, refAddr, commission);\r\n        }\r\n\r\n        if (current_round > uint8(Stages.FF)) {\r\n            //logic for timed crowdsale\r\n            require(\r\n                block.timestamp < endTime,\r\n                \"Current round has already ended!\"\r\n            );\r\n        }\r\n\r\n        if (current_round == uint8(Stages.FF)) {\r\n            amountReceived = convertedToken;\r\n\r\n            tgeAmount = (amountReceived * 10) / 100;\r\n\r\n            contributions[msg.sender].buyer = msg.sender;\r\n\r\n             Package memory pack = Package({\r\n                amountFunded: amountSent / 10 ** fiat.decimals(),\r\n                amountDue: amountReceived,\r\n                amountClaimed: tgeAmount,\r\n                timesClaimed: 0,\r\n                round: current_round\r\n            });\r\n            contributions[msg.sender].packages.push(pack);\r\n            \r\n            contributions[msg.sender].nextClaim = block.timestamp + 2592000; //2592000;\r\n\r\n            token.transfer(msg.sender, tgeAmount * 10 ** token.decimals());\r\n\r\n            fiat.transferFrom(msg.sender, address(this), amountSent);\r\n        } else {            \r\n\r\n            if (_package < Planets.Earth) {\r\n                //Packages under Earth do not receive a bonus, so amountReceived = convertedToken\r\n                amountReceived = convertedToken; \r\n\r\n                contributions[msg.sender].buyer = msg.sender;\r\n\r\n                Package memory pack = Package({\r\n                    amountFunded: amountSent / 10 ** fiat.decimals(),\r\n                    amountDue: amountReceived,\r\n                    amountClaimed: amountReceived,\r\n                    timesClaimed: vestingPeriods,\r\n                    round: current_round\r\n                });\r\n                contributions[msg.sender].packages.push(pack);\r\n\r\n                if (contributions[msg.sender].packages.length > 1)\r\n                contributions[msg.sender].nextClaim = block.timestamp + 2592000; //2592000\r\n\r\n                token.transfer(msg.sender, amountReceived * 10 ** token.decimals());\r\n\r\n                fiat.transferFrom(msg.sender, address(this), amountSent);\r\n            } else {\r\n                amountReceived =\r\n                    convertedToken +\r\n                    ((convertedToken * discounts[_package]) / 100);\r\n                tgeAmount = (amountReceived * 10) / 100;\r\n                \r\n\r\n                contributions[msg.sender].buyer = msg.sender;\r\n\r\n                Package memory pack = Package({\r\n                    amountFunded: amountSent / 10 ** fiat.decimals(),\r\n                    amountDue: amountReceived,\r\n                    amountClaimed: tgeAmount,\r\n                    timesClaimed: 0,\r\n                    round: current_round\r\n                });\r\n                contributions[msg.sender].packages.push(pack);\r\n\r\n                contributions[msg.sender].nextClaim = block.timestamp + 2592000; //2592000;\r\n\r\n                token.transfer(msg.sender, tgeAmount * 10 ** token.decimals());\r\n\r\n                fiat.transferFrom(msg.sender, address(this), amountSent);\r\n            }\r\n        }\r\n\r\n        sold += amountReceived;\r\n    }\r\n\r\n    function claim() external {\r\n        require(\r\n            msg.sender == contributions[msg.sender].buyer,\r\n            \"No contributions found!\"\r\n        );\r\n        require(\r\n            block.timestamp > contributions[msg.sender].nextClaim,\r\n            \"Not time for next vesting\"\r\n        );\r\n\r\n        require(\r\n            amountDuePackages(msg.sender) > 0,\r\n            \"No contributions found!\"\r\n        );\r\n\r\n        require(\r\n            remainderClaimPackages() > 0,\r\n            \"You are not due to collect anymore. You were likely fully vested upon purchase.\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < contributions[msg.sender].packages.length; i++) {\r\n            contributions[msg.sender].packages[i] = claimPackage(contributions[msg.sender].packages[i]);\r\n        }\r\n\r\n        if (remainderClaimPackages() > 0)\r\n            contributions[msg.sender].nextClaim = block.timestamp + 2592000; //2592000;\r\n    }\r\n\r\n    function claimPackage(Package memory pak) private returns (Package memory){\r\n\r\n        if (pak.timesClaimed >= vestingPeriods)\r\n            return pak;\r\n\r\n        if (pak.timesClaimed == (vestingPeriods - 1)) {\r\n            uint256 remainder = pak.amountDue - pak.amountClaimed;\r\n            require(\r\n                token.balanceOf(address(this)) >= remainder,\r\n                \"Insufficient balance of InfinityBee held in contract to complete order\"\r\n            );\r\n\r\n            token.transfer(msg.sender, remainder * 10 ** token.decimals());\r\n\r\n            pak.amountClaimed += remainder;\r\n            pak.timesClaimed++;\r\n        } else if ((pak.amountDue - pak.amountClaimed) < (pak.amountDue * vestingPercent)/1000) {\r\n            uint256 remainder = pak.amountDue - pak.amountClaimed;\r\n             require(\r\n                token.balanceOf(address(this)) >= remainder,\r\n                \"Insufficient balance of InfinityBee held in contract to complete order\"\r\n            );\r\n\r\n            token.transfer(msg.sender, remainder * 10 ** token.decimals());\r\n\r\n            pak.amountClaimed += remainder;\r\n            pak.timesClaimed++;\r\n        }  \r\n        else {\r\n            uint256 amountReceived = (pak.amountDue * vestingPercent) / 1000;\r\n            require(\r\n                token.balanceOf(address(this)) >= amountReceived * 10 ** token.decimals(),\r\n                \"Insufficient balance of InfinityBee held in contract to complete order\"\r\n            );\r\n\r\n            token.transfer(msg.sender, amountReceived * 10 ** token.decimals());\r\n\r\n            pak.amountClaimed += amountReceived;\r\n            pak.timesClaimed++;\r\n        }\r\n\r\n        return pak;\r\n    }\r\n\r\n    function amountDuePackages(address _addr) private view returns (uint256){\r\n        uint256 amountDue = 0;\r\n\r\n        for (uint256 i = 0; i < contributions[_addr].packages.length; i++) {\r\n            amountDue += contributions[_addr].packages[i].amountDue;\r\n        }\r\n\r\n        return amountDue;\r\n    }\r\n\r\n    function amountClaimedPackages(address _addr) private view returns (uint256){\r\n        uint256 amountClaimed = 0;\r\n\r\n        for (uint256 i = 0; i < contributions[_addr].packages.length; i++) {\r\n            amountClaimed += contributions[_addr].packages[i].amountClaimed;\r\n        }\r\n\r\n        return amountClaimed;\r\n    }\r\n\r\n    function amountToClaimPackages(address _addr) private view returns (uint256){\r\n\r\n        uint256 amountClaim = 0;\r\n\r\n        for (uint256 i = 0; i < contributions[_addr].packages.length; i++) {\r\n            \r\n            Package memory pak = contributions[_addr].packages[i];\r\n\r\n            if (pak.timesClaimed >= vestingPeriods)\r\n                continue;\r\n\r\n            if (pak.timesClaimed == (vestingPeriods - 1)) {\r\n                amountClaim += pak.amountDue - pak.amountClaimed;\r\n\r\n            } else if ((pak.amountDue - pak.amountClaimed) < (pak.amountDue * vestingPercent)/1000) {\r\n                amountClaim += pak.amountDue - pak.amountClaimed;\r\n            }  \r\n            else {\r\n                amountClaim += (pak.amountDue * vestingPercent) / 1000;\r\n            }\r\n        }\r\n\r\n        return amountClaim;\r\n    }\r\n\r\n    function remainderClaimPackages() private view returns (uint256){\r\n        uint256 remainder = 0;\r\n\r\n        for (uint256 i = 0; i < contributions[msg.sender].packages.length; i++) {\r\n            if (contributions[msg.sender].packages[i].timesClaimed < vestingPeriods)\r\n                remainder += contributions[msg.sender].packages[i].amountDue - \r\n                    contributions[msg.sender].packages[i].amountClaimed;\r\n        }\r\n\r\n        return remainder;\r\n    }\r\n\r\n    function nextRound(uint256 _endTime) external onlyOwner {\r\n        if (current_round >= 3) {\r\n            revert(\"No more rounds!\");\r\n        } else {\r\n            ++current_round;\r\n            endTime = _endTime;\r\n            if (current_round == 1) {\r\n                tokenPrice = .01 ether;\r\n            } else if (current_round == 2) {\r\n                tokenPrice = .015 ether;\r\n            } else {\r\n                tokenPrice = .02 ether;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getDecimals() public view returns (uint256, uint256) {\r\n        return (token.decimals(), fiat.decimals());\r\n    }\r\n\r\n    function setVesting(uint8 _newPeriod, uint8 _newPercent) external onlyOwner\r\n    {\r\n        vestingPeriods = _newPeriod;\r\n        vestingPercent = _newPercent;\r\n    }\r\n\r\n    function setTokenPrice(uint256 _newPrice) external onlyOwner {\r\n        tokenPrice = _newPrice;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function withdrawTokens() external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(msg.sender, balance);\r\n    }\r\n\r\n    function withdrawFiat() external onlyOwner {\r\n        uint256 balance = fiat.balanceOf(address(this));\r\n        fiat.transfer(msg.sender, balance);\r\n    }\r\n\r\n    function changeVesting(uint256 _newTime) external onlyOwner {\r\n\t    endTime = _newTime;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fiat\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addReferralAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressByRefCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ICO.Planets\",\"name\":\"_package\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"refCode\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"changeVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nextClaim\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"current_round\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ICO.Planets\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"discounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fiat\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"}],\"name\":\"getAddrByRefCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAmountClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAmountClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAmountDue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getClaimPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getContributionsPackages\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountFunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"timesClaimed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"internalType\":\"struct ICO.Package[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getRefByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getTotalRefRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"nextRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ICO.Planets\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"refByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralsMade\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newPeriod\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_newPercent\",\"type\":\"uint8\"}],\"name\":\"setVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPeriods\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFiat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ICO", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0b29d045c5f711035f45989736d2993c394bd9c00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000d3fd430a8c189b262faba4d9e895658aaac62ea0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://616d60de1d072f698120d410f2392ea28c1967ac32056d6a9be87f4e0d8b3223"}