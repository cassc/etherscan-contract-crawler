{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev collections of functions ralted to the address type\\n */\\nlibrary Address {\\n    \\n    /**\\n     * @dev returns true if `account` is a contract\\n     */\\n    function isContract(address account) internal view returns(bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly{\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n    \\n    /**\\n     * @dev replacement for solidity\\u0027s `transfer`: sends `amount` wei to `recipient`,\\n     * forwarding all available gas and reverting on errors;\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance.\\\");\\n        \\n        (bool success,) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted.\\\");\\n    }\\n    \\n    /**\\n     * @dev performs a solidity function call using a low level `call`. A plain `call` is an\\n     * unsafe replacement for a function call: use this function instead.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns(bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed.\\\");\\n    }\\n    \\n    function functionCall(address target, bytes memory data, string memory errMsg) internal returns(bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errMsg);\\n    }\\n    \\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n    \\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n    \\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errMsg) private returns(bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract.\\\");\\n        \\n        (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errMsg);\\n            }\\n        }\\n    }\\n    \\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns(address payable) {\\n        return payable(msg.sender);\\n    }\\n    \\n    function _msgData() internal view virtual returns(bytes memory){\\n        this;   // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"DividendPayingToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\nimport \\\"./IDividendPayingToken.sol\\\";\\r\\nimport \\\"./IDividendPayingTokenOptional.sol\\\";\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SafeMathUint.sol\\\";\\r\\nimport \\\"./SafeMathInt.sol\\\";\\r\\nimport \\\"./IterableMapping.sol\\\";\\r\\n\\r\\n/*\\r\\n@title Dividend-Paying Token\\r\\n@author Roger Wu (https://github.com/roger-wu)\\r\\n@dev A mintable ERC20 token that allows anyone to pay and distribute ether\\r\\nto token holders as dividends and allows token holders to withdraw their dividends.\\r\\nReference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\\r\\n*/\\r\\ncontract DividendPayingToken is ERC20, IDividendPayingToken, IDividendPayingTokenOptional {\\r\\n  using SafeMath for uint256;\\r\\n  using SafeMathUint for uint256;\\r\\n  using SafeMathInt for int256;\\r\\n\\r\\n\\r\\n  // With `magnitude`, we can properly distribute dividends even if the amount of received ether is small.\\r\\n  // For more discussion about choosing the value of `magnitude`,\\r\\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\\r\\n  uint256 constant internal magnitude = 2**128;\\r\\n\\r\\n  uint256 internal magnifiedDividendPerShare;\\r\\n  uint256 internal lastAmount;\\r\\n  \\r\\n  address public dividendToken = 0x55d398326f99059fF775485246999027B3197955;\\r\\n\\r\\n  // About dividendCorrection:\\r\\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\\r\\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\\r\\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\\r\\n  //   `dividendOf(_user)` should not be changed,\\r\\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\\r\\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\\r\\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\\r\\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\\r\\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\\r\\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\\r\\n  mapping(address =\\u003e int256) internal magnifiedDividendCorrections;\\r\\n\\r\\n  mapping(address =\\u003e uint256) internal withdrawnDividends;\\r\\n\\r\\n  uint256 public totalDividendsDistributed;\\r\\n\\r\\n  \\r\\n  uint256 public _dividendLimitUsd = 3 * 10 ** 18;\\r\\n\\r\\n  constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) public {\\r\\n\\r\\n  }\\r\\n\\r\\n  receive() external payable { }\\r\\n\\r\\n  function distributeDividends() public override payable {\\r\\n    require(totalSupply() \\u003e 0);\\r\\n\\r\\n    if (msg.value \\u003e 0) {\\r\\n      magnifiedDividendPerShare = magnifiedDividendPerShare.add(\\r\\n        (msg.value).mul(magnitude) / totalSupply()\\r\\n      );\\r\\n      emit DividendsDistributed(msg.sender, msg.value);\\r\\n\\r\\n      totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\\r\\n    }\\r\\n  }\\r\\n  \\r\\n\\r\\n  function distributeDividends(uint256 amount) public {\\r\\n    require(totalSupply() \\u003e 0);\\r\\n\\r\\n    if (amount \\u003e 0) {\\r\\n      magnifiedDividendPerShare = magnifiedDividendPerShare.add(\\r\\n        (amount).mul(magnitude) / totalSupply()\\r\\n      );\\r\\n      emit DividendsDistributed(msg.sender, amount);\\r\\n\\r\\n      totalDividendsDistributed = totalDividendsDistributed.add(amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraws the ether distributed to the sender.\\r\\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\\r\\n  function withdrawDividend() public virtual override {\\r\\n    _withdrawDividendOfUser(payable(msg.sender));\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraws the ether distributed to the sender.\\r\\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\\r\\n  function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\\r\\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\\r\\n    \\r\\n    if (_withdrawableDividend \\u003e _dividendLimitUsd) {\\r\\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\\r\\n      emit DividendWithdrawn(user, _withdrawableDividend);\\r\\n      bool success = IERC20(dividendToken).transfer(user, _withdrawableDividend);\\r\\n\\r\\n      if(!success) {\\r\\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\\r\\n        return 0;\\r\\n      }\\r\\n\\r\\n      return _withdrawableDividend;\\r\\n    }\\r\\n\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\r\\n  function dividendOf(address _owner) public view override returns(uint256) {\\r\\n    return withdrawableDividendOf(_owner);\\r\\n  }\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\r\\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\\r\\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\\r\\n  }\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\\r\\n  function withdrawnDividendOf(address _owner) public view override returns(uint256) {\\r\\n    return withdrawnDividends[_owner];\\r\\n  }\\r\\n\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address has earned in total.\\r\\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\\r\\n  /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\\r\\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\\r\\n      return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\\r\\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\\r\\n    \\r\\n  }\\r\\n\\r\\n  /// @dev Internal function that transfer tokens from one address to another.\\r\\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\\r\\n  /// @param from The address to transfer from.\\r\\n  /// @param to The address to transfer to.\\r\\n  /// @param value The amount to be transferred.\\r\\n  function _transfer(address from, address to, uint256 value) internal virtual override {\\r\\n    require(false);\\r\\n\\r\\n    int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\\r\\n    magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\\r\\n    magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\\r\\n  }\\r\\n\\r\\n  /// @dev Internal function that mints tokens to an account.\\r\\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\\r\\n  /// @param account The account that will receive the created tokens.\\r\\n  /// @param value The amount that will be created.\\r\\n  function _mint(address account, uint256 value) internal override {\\r\\n    super._mint(account, value);\\r\\n\\r\\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\r\\n    .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\r\\n    \\r\\n  }\\r\\n\\r\\n  /// @dev Internal function that burns an amount of the token of a given account.\\r\\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\\r\\n  /// @param account The account whose tokens will be burnt.\\r\\n  /// @param value The amount that will be burnt.\\r\\n  function _burn(address account, uint256 value) internal override {\\r\\n    super._burn(account, value);\\r\\n\\r\\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\r\\n    .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\r\\n  }\\r\\n\\r\\n  function _setBalance(address account, uint256 newBalance) internal {\\r\\n    uint256 currentBalance = balanceOf(account);\\r\\n\\r\\n    if(newBalance \\u003e currentBalance) {\\r\\n      uint256 mintAmount = newBalance.sub(currentBalance);\\r\\n      _mint(account, mintAmount);\\r\\n    } else if(newBalance \\u003c currentBalance) {\\r\\n      uint256 burnAmount = currentBalance.sub(newBalance);\\r\\n      _burn(account, burnAmount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\"},\"DividendTracker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./DividendPayingToken.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IterableMapping.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\n\\r\\ncontract DividendTracker is DividendPayingToken, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMathInt for int256;\\r\\n    using IterableMapping for IterableMapping.Map;\\r\\n\\r\\n\\r\\n    IterableMapping.Map private tokenHoldersMap;\\r\\n    uint256 public lastProcessedIndex;\\r\\n\\r\\n    mapping (address =\\u003e bool) public excludedFromDividends;\\r\\n\\r\\n    mapping (address =\\u003e uint256) public lastClaimTimes;\\r\\n\\r\\n    uint256 public claimWait;\\r\\n    uint256 public immutable minimumTokenBalanceForDividends;\\r\\n\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n\\r\\n    event ExcludeFromDividends(address indexed account);\\r\\n    event UnExcludeFromDividends(address indexed account);\\r\\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\r\\n\\r\\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\\r\\n    \\r\\n    event SendDividends(uint256 tokensSwapped,uint256 amount);\\r\\n\\r\\n    constructor() DividendPayingToken(\\\"METADAO_Dividend\\\", \\\"METADAO_Dividend\\\") public {\\r\\n    \\tclaimWait = 30 * 60;\\r\\n        minimumTokenBalanceForDividends = 0 * (10**19);\\r\\n        uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n    }\\r\\n\\r\\n    function _transfer(address, address, uint256)  internal override {\\r\\n        require(false, \\\"METADAO_Dividend: No transfers allowed\\\");\\r\\n    }\\r\\n\\r\\n    function withdrawDividend() public override {\\r\\n        require(false, \\\"METADAO_Dividend: withdrawDividend disabled.\\\");\\r\\n    }\\r\\n\\r\\n    function excludeFromDividends(address account) external onlyOwner {\\r\\n    \\trequire(!excludedFromDividends[account]);\\r\\n    \\texcludedFromDividends[account] = true;\\r\\n\\r\\n    \\t_setBalance(account, 0);\\r\\n    \\ttokenHoldersMap.remove(account);\\r\\n\\r\\n    \\temit ExcludeFromDividends(account);\\r\\n    }\\r\\n\\r\\n    function unexcludeFromDividends(address account) external onlyOwner {\\r\\n    \\trequire(excludedFromDividends[account]);\\r\\n    \\texcludedFromDividends[account] = false;\\r\\n\\r\\n    \\temit UnExcludeFromDividends(account);\\r\\n    }\\r\\n\\r\\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\\r\\n        require(newClaimWait \\u003e= 300 \\u0026\\u0026 newClaimWait \\u003c= 86400, \\\"METADAO_Dividend: claimWait must be updated to between 5 mins and 24 hours\\\");\\r\\n        require(newClaimWait != claimWait, \\\"METADAO_Dividend: Cannot update claimWait to same value\\\");\\r\\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\\r\\n        claimWait = newClaimWait;\\r\\n    }\\r\\n\\r\\n    function getLastProcessedIndex() external view returns(uint256) {\\r\\n    \\treturn lastProcessedIndex;\\r\\n    }\\r\\n\\r\\n    function getNumberOfTokenHolders() external view returns(uint256) {\\r\\n        return tokenHoldersMap.keys.length;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getAccount(address _account)\\r\\n        public view returns (\\r\\n            address account,\\r\\n            int256 index,\\r\\n            int256 iterationsUntilProcessed,\\r\\n            uint256 withdrawableDividends,\\r\\n            uint256 totalDividends,\\r\\n            uint256 lastClaimTime,\\r\\n            uint256 nextClaimTime,\\r\\n            uint256 secondsUntilAutoClaimAvailable) {\\r\\n        account = _account;\\r\\n\\r\\n        index = tokenHoldersMap.getIndexOfKey(account);\\r\\n\\r\\n        iterationsUntilProcessed = -1;\\r\\n\\r\\n        if(index \\u003e= 0) {\\r\\n            if(uint256(index) \\u003e lastProcessedIndex) {\\r\\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\\r\\n            }\\r\\n            else {\\r\\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length \\u003e lastProcessedIndex ?\\r\\n                                                        tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\\r\\n                                                        0;\\r\\n\\r\\n\\r\\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\\r\\n            }\\r\\n        }\\r\\n\\r\\n\\r\\n        withdrawableDividends = withdrawableDividendOf(account);\\r\\n        totalDividends = accumulativeDividendOf(account);\\r\\n\\r\\n        lastClaimTime = lastClaimTimes[account];\\r\\n\\r\\n        nextClaimTime = lastClaimTime \\u003e 0 ?\\r\\n                                    lastClaimTime.add(claimWait) :\\r\\n                                    0;\\r\\n\\r\\n        secondsUntilAutoClaimAvailable = nextClaimTime \\u003e block.timestamp ?\\r\\n                                                    nextClaimTime.sub(block.timestamp) :\\r\\n                                                    0;\\r\\n    }\\r\\n\\r\\n    function getAccountAtIndex(uint256 index)\\r\\n        public view returns (\\r\\n            address,\\r\\n            int256,\\r\\n            int256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256) {\\r\\n    \\tif(index \\u003e= tokenHoldersMap.size()) {\\r\\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\\r\\n        }\\r\\n\\r\\n        address account = tokenHoldersMap.getKeyAtIndex(index);\\r\\n\\r\\n        return getAccount(account);\\r\\n    }\\r\\n\\r\\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\r\\n    \\tif(lastClaimTime \\u003e block.timestamp)  {\\r\\n    \\t\\treturn false;\\r\\n    \\t}\\r\\n\\r\\n    \\treturn block.timestamp.sub(lastClaimTime) \\u003e= claimWait;\\r\\n    }\\r\\n\\r\\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\\r\\n    \\tif(excludedFromDividends[account]) {\\r\\n    \\t\\treturn;\\r\\n    \\t}\\r\\n    \\tif(newBalance \\u003e= minimumTokenBalanceForDividends) {\\r\\n            _setBalance(account, newBalance);\\r\\n    \\t\\ttokenHoldersMap.set(account, newBalance);\\r\\n    \\t}\\r\\n    \\telse {\\r\\n            _setBalance(account, 0);\\r\\n    \\t\\ttokenHoldersMap.remove(account);\\r\\n    \\t}\\r\\n        \\r\\n        processAccount(account, true);\\r\\n        \\r\\n    }\\r\\n\\r\\n\\r\\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\\r\\n    \\tuint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\\r\\n\\r\\n    \\tif(numberOfTokenHolders == 0) {\\r\\n    \\t\\treturn (0, 0, lastProcessedIndex);\\r\\n    \\t}\\r\\n\\r\\n    \\tuint256 _lastProcessedIndex = lastProcessedIndex;\\r\\n\\r\\n    \\tuint256 gasUsed = 0;\\r\\n\\r\\n    \\tuint256 gasLeft = gasleft();\\r\\n\\r\\n    \\tuint256 iterations = 0;\\r\\n    \\tuint256 claims = 0;\\r\\n\\r\\n    \\twhile(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c numberOfTokenHolders) {\\r\\n    \\t\\t_lastProcessedIndex++;\\r\\n\\r\\n    \\t\\tif(_lastProcessedIndex \\u003e= tokenHoldersMap.keys.length) {\\r\\n    \\t\\t\\t_lastProcessedIndex = 0;\\r\\n    \\t\\t}\\r\\n\\r\\n    \\t\\taddress account = tokenHoldersMap.keys[_lastProcessedIndex];\\r\\n\\r\\n    \\t\\tif(canAutoClaim(lastClaimTimes[account])) {\\r\\n    \\t\\t\\tif(processAccount(payable(account), true)) {\\r\\n    \\t\\t\\t\\tclaims++;\\r\\n    \\t\\t\\t}\\r\\n    \\t\\t}\\r\\n\\r\\n    \\t\\titerations++;\\r\\n\\r\\n    \\t\\tuint256 newGasLeft = gasleft();\\r\\n\\r\\n    \\t\\tif(gasLeft \\u003e newGasLeft) {\\r\\n    \\t\\t\\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\r\\n    \\t\\t}\\r\\n\\r\\n    \\t\\tgasLeft = newGasLeft;\\r\\n    \\t}\\r\\n\\r\\n    \\tlastProcessedIndex = _lastProcessedIndex;\\r\\n\\r\\n    \\treturn (iterations, claims, lastProcessedIndex);\\r\\n    }\\r\\n\\r\\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\\r\\n        uint256 amount = _withdrawDividendOfUser(account);\\r\\n\\r\\n    \\tif(amount \\u003e 0) {\\r\\n    \\t\\tlastClaimTimes[account] = block.timestamp;\\r\\n            emit Claim(account, amount, automatic);\\r\\n    \\t\\treturn true;\\r\\n    \\t}\\r\\n\\r\\n    \\treturn false;\\r\\n    }\\r\\n\\r\\n    function getExcludedFromDividends(address account) public view returns(bool) {\\r\\n        return excludedFromDividends[account];\\r\\n    }\\r\\n\\r\\n    function setDividendLimit(uint256 limit) public onlyOwner {\\r\\n        _dividendLimitUsd = limit;\\r\\n    }\\r\\n\\r\\n    function setDividendTokenAddress(address newToken) public onlyOwner {\\r\\n        require(newToken != address(0), \\\"new address is zero address.\\\");\\r\\n        dividendToken = newToken;\\r\\n    }\\r\\n\\r\\n    function getWithdrawableDividendOf(address account) public view returns(uint256) {\\r\\n        return withdrawableDividendOf(account);\\r\\n    }\\r\\n\\r\\n    function swapAndDistributeDividends(address token) public onlyOwner {\\r\\n        uint256 usdt_before = IERC20(dividendToken).balanceOf(address(this));\\r\\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this));\\r\\n        _swapTokensForUsdt(token, tokenAmount);\\r\\n        uint256 usdt_after = IERC20(dividendToken).balanceOf(address(this));\\r\\n        uint256 dividends = usdt_after.sub(usdt_before);\\r\\n        distributeDividends(dividends);\\r\\n        emit SendDividends(tokenAmount, dividends);\\r\\n    }\\r\\n\\r\\n    function _swapTokensForUsdt(address token, uint256 tokenAmount) private {\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = token;\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        path[2] = dividendToken;\\r\\n\\r\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            now.add(180)\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n    \\n    constructor(string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n    \\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n    \\n    function symbol() public view virtual returns(string memory) {\\n        return _symbol;\\n    }\\n    \\n    function decimals() public view virtual returns(uint8) {\\n        return _decimals;\\n    }\\n    \\n    function totalSupply() public view virtual override returns(uint256) {\\n        return _totalSupply;\\n    }\\n    \\n    function balanceOf(address account) public view virtual override returns(uint256) {\\n        return _balances[account];\\n    }\\n    \\n    function transfer(address recipient, uint256 amount) public virtual override returns(bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n    \\n    function allowance(address owner, address spender) public view virtual override returns(uint256) {\\n       return _allowances[owner][spender];\\n    }\\n    \\n    function approve(address spender, uint256 amount) public virtual override returns(bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n    \\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns(bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance.\\\"));\\n        return true;\\n    }\\n    \\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns(bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n    \\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns(bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decrease allowance bellow zero.\\\"));\\n        return true;\\n    }\\n    \\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address.\\\");\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance.\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /**\\n     * @dev creates `amount` tokens and assign them to `account`, increasing the total supply.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to zero address.\\\");\\n        \\n        _beforeTokenTransfer(address(0), account, amount);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n    \\n    /**\\n     * @dev destroys `amount` tokens from `account`, reducing the total supply.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address.\\\");\\n        \\n        _beforeTokenTransfer(account, address(0), amount);\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance.\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n    \\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address.\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address.\\\");\\n        \\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n    \\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n    \\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes minting and burning.\\n     */\\n    function _beforeTokenTransfer(address sender, address recipient, uint256 amount) internal virtual { }\\n    \\n}\"},\"IDividendPayingToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\n/*\\r\\n@title Dividend-Paying Token Interface\\r\\n@author Roger Wu (https://github.com/roger-wu)\\r\\n@dev An interface for a dividend-paying token contract.\\r\\n*/\\r\\ninterface IDividendPayingToken {\\r\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\r\\n  function dividendOf(address _owner) external view returns(uint256);\\r\\n\\r\\n  /// @notice Distributes ether to token holders as dividends.\\r\\n  /// @dev SHOULD distribute the paid ether to token holders as dividends.\\r\\n  ///  SHOULD NOT directly transfer ether to token holders in this function.\\r\\n  ///  MUST emit a `DividendsDistributed` event when the amount of distributed ether is greater than 0.\\r\\n  function distributeDividends() external payable;\\r\\n\\r\\n  /// @notice Withdraws the ether distributed to the sender.\\r\\n  /// @dev SHOULD transfer `dividendOf(msg.sender)` wei to `msg.sender`, and `dividendOf(msg.sender)` SHOULD be 0 after the transfer.\\r\\n  ///  MUST emit a `DividendWithdrawn` event if the amount of ether transferred is greater than 0.\\r\\n  function withdrawDividend() external;\\r\\n\\r\\n  /// @dev This event MUST emit when ether is distributed to token holders.\\r\\n  /// @param from The address which sends ether to this contract.\\r\\n  /// @param weiAmount The amount of distributed ether in wei.\\r\\n  event DividendsDistributed(\\r\\n    address indexed from,\\r\\n    uint256 weiAmount\\r\\n  );\\r\\n\\r\\n  /// @dev This event MUST emit when an address withdraws their dividend.\\r\\n  /// @param to The address which withdraws ether from this contract.\\r\\n  /// @param weiAmount The amount of withdrawn ether in wei.\\r\\n  event DividendWithdrawn(\\r\\n    address indexed to,\\r\\n    uint256 weiAmount\\r\\n  );\\r\\n}\"},\"IDividendPayingTokenOptional.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\n/*\\r\\n@title Dividend-Paying Token Optional Interface\\r\\n@author Roger Wu (https://github.com/roger-wu)\\r\\n@dev OPTIONAL functions for a dividend-paying token contract.\\r\\n*/\\r\\ninterface IDividendPayingTokenOptional {\\r\\n  /// @notice View the amount of dividend in wei that an address can withdraw.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\\r\\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\\r\\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address has earned in total.\\r\\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\\r\\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC20 {\\n    \\n    /**\\n     * @dev returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns(uint256);\\n    \\n    /**\\n     * @dev returns the amount of tokens owned by account \\n     */\\n    function balanceOf(address account) external view returns(uint256);\\n    \\n    /**\\n     * @dev moves amount tokens from the call\\u0027s account to recipient.\\n     * returns a bool value indicating whether the operation successed.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns(bool);\\n    \\n    /**\\n     * @dev returns the remaining number of tokens that spender will be allowed to spend \\n     * on behalf of owner through {transferFrom}. this is zero by default.\\n     * \\n     * his value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns(uint256);\\n    \\n    /**\\n     * @dev sets amount as the allowance of spender over the caller\\u0027s tokens. \\n     * returns a bool value indicating whether the operation is successed.\\n     * \\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns(bool);\\n    \\n    /**\\n     * @dev moves amount tokens from sender to recipient using the allowance mechanism.\\n     * amount is then deducted from the caller\\u0027s allowance.\\n     * \\n     * returns a boolean value indicating whether the operation successed.\\n     * \\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    \\n}\"},\"IterableMapping.sol\":{\"content\":\"// SPDX-License-Identifier: MIT License\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nlibrary IterableMapping {\\r\\n    // Iterable mapping from address to uint;\\r\\n    struct Map {\\r\\n        address[] keys;\\r\\n        mapping(address =\\u003e uint) values;\\r\\n        mapping(address =\\u003e uint) indexOf;\\r\\n        mapping(address =\\u003e bool) inserted;\\r\\n    }\\r\\n\\r\\n    function get(Map storage map, address key) public view returns (uint) {\\r\\n        return map.values[key];\\r\\n    }\\r\\n\\r\\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\\r\\n        if(!map.inserted[key]) {\\r\\n            return -1;\\r\\n        }\\r\\n        return int(map.indexOf[key]);\\r\\n    }\\r\\n\\r\\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\r\\n        return map.keys[index];\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function size(Map storage map) public view returns (uint) {\\r\\n        return map.keys.length;\\r\\n    }\\r\\n\\r\\n    function set(Map storage map, address key, uint val) public {\\r\\n        if (map.inserted[key]) {\\r\\n            map.values[key] = val;\\r\\n        } else {\\r\\n            map.inserted[key] = true;\\r\\n            map.values[key] = val;\\r\\n            map.indexOf[key] = map.keys.length;\\r\\n            map.keys.push(key);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function remove(Map storage map, address key) public {\\r\\n        if (!map.inserted[key]) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        delete map.inserted[key];\\r\\n        delete map.values[key];\\r\\n\\r\\n        uint index = map.indexOf[key];\\r\\n        uint lastIndex = map.keys.length - 1;\\r\\n        address lastKey = map.keys[lastIndex];\\r\\n\\r\\n        map.indexOf[lastKey] = index;\\r\\n        delete map.indexOf[key];\\r\\n\\r\\n        map.keys[index] = lastKey;\\r\\n        map.keys.pop();\\r\\n    }\\r\\n}\\r\\n\"},\"IUniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"},\"IUniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external view returns (address);\\r\\n    function WETH() external view returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\n\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// a library for performing various math operations\\r\\n\\r\\nlibrary Math {\\r\\n    function min(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = x \\u003c y ? x : y;\\r\\n    }\\r\\n\\r\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y \\u003e 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x \\u003c z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n}\"},\"MetaverseDao.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./DividendTracker.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\n\\r\\n\\r\\ncontract MetaverseDao is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    bool private inSwap = false;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n    mapping(address =\\u003e bool) private _isExcludedFromFee;\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n    address private _owner;\\r\\n    address public pdcWbnbPair;\\r\\n    address public usdtWbnbPair;\\r\\n\\r\\n    string public _name = \\\"Metaverse-DAO\\\";\\r\\n    string public _symbol = \\\"METADAO\\\";\\r\\n    address public router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n    address public usdt = 0x55d398326f99059fF775485246999027B3197955;\\r\\n    address public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\r\\n    \\r\\n    uint256 public _maxTotal = 35 * 10 ** 7 * 10 ** 18 ;\\r\\n    uint256 public _total = 0;\\r\\n    uint256 private _maxSell = 1 * 10 ** 5 * 10 ** 18;\\r\\n    uint256 public minimumAmountToSwap = 30 * 10 ** 18;\\r\\n    uint8 private _decimals = 18;\\r\\n    uint256 public gasForProcessing = 300000;\\r\\n    uint256 public highestSellTaxRate = 45;\\r\\n    bool public enableFee = true;\\r\\n    bool public isAutoDividend = true;\\r\\n    uint256 constant internal priceMagnitude = 2 ** 64;\\r\\n    uint256 public basePrice;\\r\\n    uint256 public basePriceTimeInterval = 4320;\\r\\n    uint256 public basePricePreMin = 180;\\r\\n    uint256 public lastBasePriceTimestamp;\\r\\n    uint256 public startTimestamp;\\r\\n    uint256 public sellRateUpper = 100;\\r\\n    uint256 public sellRateBelow = 200;\\r\\n    uint256 public fixSellSlippage = 0;\\r\\n    uint256 public currentSellRate = 0;\\r\\n\\r\\n    address public _divReceiver;\\r\\n    address public _developReceiver = 0x47d5866c21226848db6c5ae73C263F070EFe1F5b;\\r\\n    address public _consultantReceiver = 0x7DA66c7DC804D6E44f570Ca7054D2460f150c88c;\\r\\n    address public _operateReceiver = 0x2434F7B2B5B042a050F31C3E2D891EB1Dfe478dB;\\r\\n    address public _raiseReceiver = 0x0F3F2660e0357f9C4170ae02DDCBB157908c87eF;\\r\\n\\r\\n    DividendTracker public dividendTracker;\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n\\r\\n    constructor() ERC20(\\\"Metaverse-DAO\\\", \\\"METADAO\\\") public {\\r\\n\\r\\n        address _blackhole = 0x000000000000000000000000000000000000dEaD;\\r\\n        _owner = msg.sender;\\r\\n        dividendTracker = new DividendTracker();\\r\\n        _divReceiver = address(dividendTracker);\\r\\n        _allowances[address(this)][router] = uint256(2 ** 256 -1);\\r\\n        WBNB = IUniswapV2Router02(router).WETH();\\r\\n        startTimestamp = block.timestamp;\\r\\n        uniswapV2Router = IUniswapV2Router02(router);\\r\\n\\r\\n        _mint(_owner, _maxTotal);\\r\\n\\r\\n        uint256 raiseAmount = _maxTotal.mul(10).div(100);\\r\\n        _transferStandard(_owner, _raiseReceiver, raiseAmount.mul(20).div(100));\\r\\n\\r\\n        uint256 operateAmount = _maxTotal.mul(8).div(100);\\r\\n        _transferStandard(_owner, _operateReceiver, operateAmount.mul(20).div(100));\\r\\n\\r\\n        uint256 consultantAmount = _maxTotal.mul(2).div(100);\\r\\n        _transferStandard(_owner, _consultantReceiver, consultantAmount.mul(20).div(100));\\r\\n\\r\\n        dividendTracker.excludeFromDividends(_blackhole);\\r\\n        dividendTracker.excludeFromDividends(address(this));\\r\\n        dividendTracker.excludeFromDividends(owner());\\r\\n        dividendTracker.excludeFromDividends(_divReceiver);\\r\\n        dividendTracker.excludeFromDividends(router);\\r\\n\\r\\n        _isExcludedFromFee[_divReceiver] = true;\\r\\n        _isExcludedFromFee[address(this)] = true;\\r\\n        _isExcludedFromFee[_blackhole] = true;\\r\\n        _isExcludedFromFee[router] = true;\\r\\n        _isExcludedFromFee[owner()] = true;\\r\\n\\r\\n        try dividendTracker.setBalance(payable(_consultantReceiver), balanceOf(_consultantReceiver)) {}  catch {}\\r\\n        try dividendTracker.setBalance(payable(_operateReceiver), balanceOf(_operateReceiver)) {}  catch {}\\r\\n        try dividendTracker.setBalance(payable(_raiseReceiver), balanceOf(_raiseReceiver)) {}  catch {}\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal override {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address.\\\");\\r\\n        require(_total.add(amount) \\u003c= _maxTotal, \\\"reach maximum.\\\");\\r\\n\\r\\n        _total = _total.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    //to recieve ETH from uniswapV2Router when swaping\\r\\n    receive() external payable {}\\r\\n    \\r\\n    function transfer(address recipient, uint256 amount) public override returns(bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns(bool){\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance.\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _transfer(address from, address to, uint256 amount) internal override {\\r\\n        \\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(from != to, \\\"Sender and reciever must be different\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n\\r\\n        if(to == pdcWbnbPair \\u0026\\u0026 enableFee \\u0026\\u0026 from != _divReceiver \\u0026\\u0026 from != _owner) {\\r\\n            require(amount \\u003c= _maxSell, \\\"sell amount reach maximum.\\\");\\r\\n        }\\r\\n        \\r\\n        checkLps();\\r\\n        \\r\\n        if((from == pdcWbnbPair || to == pdcWbnbPair) \\u0026\\u0026 enableFee) { \\r\\n            _updateBasePrice();\\r\\n            currentSellRate = _getSellTaxRate();\\r\\n        }\\r\\n\\r\\n        if(to == pdcWbnbPair){\\r\\n            if(!inSwap \\u0026\\u0026 enableFee){\\r\\n                inSwap = true;\\r\\n                if(from != _divReceiver \\u0026\\u0026 isAutoDividend){\\r\\n                    _swapDividend();\\r\\n                }\\r\\n                inSwap = false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to] || !enableFee) {\\r\\n            _transferWithoutFee(from, to, amount);\\r\\n        } else {\\r\\n            if (from == pdcWbnbPair) {\\r\\n                _transferBuyStandard(from, to, amount);\\r\\n            } else if (to == pdcWbnbPair) {\\r\\n                _transferSellStandard(from, to, amount);\\r\\n            } else {\\r\\n                _transferStandard(from, to, amount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        \\r\\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\r\\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {}  catch {}\\r\\n        \\r\\n        if((from == pdcWbnbPair || to == pdcWbnbPair) \\u0026\\u0026 !inSwap \\u0026\\u0026 isAutoDividend) {\\r\\n    \\t    uint256 gas = gasForProcessing;\\r\\n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\\r\\n        \\t\\temit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\\r\\n        \\t} catch {}\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 amount) internal override {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _transferBuyStandard(address sender, address recipient, uint256 amount) private {\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _transferSellStandard(address from, address to, uint256 amount) private {\\r\\n        uint256 totalFee = _distributeSellFees(from, amount);\\r\\n\\r\\n        uint256 transferAmount = amount.sub(totalFee);\\r\\n        _balances[from] = _balances[from].sub(amount);\\r\\n        _balances[to] = _balances[to].add(transferAmount);\\r\\n\\r\\n        emit Transfer(from, to, transferAmount);\\r\\n    }\\r\\n\\r\\n    function _distributeSellFees(address from, uint256 amount) private returns (uint256 totalFee) {\\r\\n        uint256 divFee = _getSellFees(amount);\\r\\n\\r\\n        _balances[_divReceiver] = _balances[_divReceiver].add(divFee);\\r\\n        emit Transfer(from, _divReceiver, divFee);\\r\\n\\r\\n        return divFee;\\r\\n    }\\r\\n\\r\\n    function _getSellFees(uint256 amount) private view returns (uint256 divFee) {\\r\\n        uint256 amountOutWbnb = _getAmountOutWbnb(amount);\\r\\n        uint256 amountOutWbnbAfterFee = amountOutWbnb.sub(amountOutWbnb.mul(currentSellRate).div(10000));\\r\\n        uint256 amountInPd = _getAmountInPd(amountOutWbnbAfterFee);\\r\\n        uint256 fee = amount.sub(amountInPd);\\r\\n        divFee = fee;\\r\\n    }\\r\\n\\r\\n    function _getSellTaxRate() public view returns (uint256) {\\r\\n        if(fixSellSlippage \\u003e 0){\\r\\n            return _convertToSellSlippage(fixSellSlippage);\\r\\n        }\\r\\n\\r\\n        uint256 rate = _getBasePriceRate();\\r\\n        if (rate == 0 || rate == 1000) {\\r\\n            return _convertToSellSlippage(100);\\r\\n        }\\r\\n        uint256 diff;\\r\\n        uint256 rateToReturn;\\r\\n        if (rate \\u003e 1000) {\\r\\n            diff = rate.sub(1000);\\r\\n            rateToReturn = diff.mul(sellRateUpper).div(100).add(100);\\r\\n            if (rateToReturn \\u003e highestSellTaxRate.mul(10)) {\\r\\n                return _convertToSellSlippage(highestSellTaxRate.mul(10));\\r\\n            } else {\\r\\n                return _convertToSellSlippage(rateToReturn);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        diff = uint256(1000).sub(rate);\\r\\n        rateToReturn = diff.mul(sellRateBelow).div(100).add(100);\\r\\n        if (rateToReturn \\u003e highestSellTaxRate.mul(10)) {\\r\\n            return _convertToSellSlippage(highestSellTaxRate.mul(10));\\r\\n        } else {\\r\\n            return _convertToSellSlippage(rateToReturn);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function getSellTaxRate() public view returns (uint256) {\\r\\n        if(fixSellSlippage \\u003e 0){\\r\\n            return (fixSellSlippage);\\r\\n        }\\r\\n\\r\\n        uint256 rate = _getBasePriceRate();\\r\\n        if (rate == 0 || rate == 1000) {\\r\\n            return (100);\\r\\n        }\\r\\n        uint256 diff;\\r\\n        uint256 rateToReturn;\\r\\n        if (rate \\u003e 1000) {\\r\\n            diff = rate.sub(1000);\\r\\n            rateToReturn = diff.mul(sellRateUpper).div(100).add(100);\\r\\n            if (rateToReturn \\u003e highestSellTaxRate.mul(10)) {\\r\\n                return (highestSellTaxRate.mul(10));\\r\\n            } else {\\r\\n                return (rateToReturn);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        diff = uint256(1000).sub(rate);\\r\\n        rateToReturn = diff.mul(sellRateBelow).div(100).add(100);\\r\\n        if (rateToReturn \\u003e highestSellTaxRate.mul(10)) {\\r\\n            return (highestSellTaxRate.mul(10));\\r\\n        } else {\\r\\n            return (rateToReturn);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _convertToSellSlippage(uint256 taxRate) private pure returns(uint256) {\\r\\n        return uint256(10000).sub(uint256(10000000).div(uint256(1000).add(taxRate)));\\r\\n    }\\r\\n\\r\\n    function _transferStandard(address from, address to, uint256 amount) private {\\r\\n        _balances[from] = _balances[from].sub(amount);\\r\\n        _balances[to] = _balances[to].add(amount);\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _transferWithoutFee(address sender, address recipient, uint256 amount) private {\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    \\r\\n    function checkLps() private {\\r\\n        //create a uniswap pair for this new token\\r\\n        address _pdcWbnbPair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), WBNB);\\r\\n        if (pdcWbnbPair != _pdcWbnbPair) {\\r\\n            pdcWbnbPair = _pdcWbnbPair;\\r\\n            dividendTracker.excludeFromDividends(address(_pdcWbnbPair));\\r\\n        }\\r\\n        \\r\\n        address _usdtWbnbPair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(usdt), WBNB);\\r\\n        if (usdtWbnbPair != _usdtWbnbPair) {\\r\\n             usdtWbnbPair = _usdtWbnbPair;\\r\\n             dividendTracker.excludeFromDividends(address(_usdtWbnbPair));\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _updateBasePrice() private {\\r\\n        (uint256 _pdcReserve, uint256 _wbnbReserve) = _getPdcWbnbReserves();\\r\\n        if(_pdcReserve \\u003c= 0 || _wbnbReserve \\u003c= 0) return;\\r\\n\\r\\n        uint256 currentPrice = getLpPriceNow();\\r\\n        if(lastBasePriceTimestamp == 0) {\\r\\n            lastBasePriceTimestamp = block.timestamp;\\r\\n            basePrice = currentPrice;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 lastTimeMin = lastBasePriceTimestamp.div(60);\\r\\n        uint256 currentTimeMin = block.timestamp.div(60);\\r\\n        if(lastTimeMin == currentTimeMin) return;\\r\\n\\r\\n        uint256 startMin = startTimestamp.div(60);\\r\\n        uint256 minSinceBegin = currentTimeMin.sub(startMin).add(1);\\r\\n        uint256 timeInterval = basePriceTimeInterval;\\r\\n        \\r\\n        if (currentTimeMin \\u003e lastTimeMin) {\\r\\n            uint256 minSinceLast = currentTimeMin.sub(lastTimeMin);\\r\\n            if (minSinceBegin \\u003e timeInterval) {\\r\\n                if (minSinceLast \\u003e timeInterval) {\\r\\n                    basePrice = currentPrice;\\r\\n                } else {\\r\\n                    basePrice = basePrice.mul(timeInterval.sub(minSinceLast)).div(timeInterval).add(currentPrice.mul(minSinceLast).div(timeInterval));\\r\\n                }\\r\\n            } else {\\r\\n                uint256 denominator = minSinceBegin.add(basePricePreMin);\\r\\n                basePrice = basePrice.mul(denominator.sub(minSinceLast)).div(denominator).add(currentPrice.mul(minSinceLast).div(denominator));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        lastBasePriceTimestamp = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function getLpPriceNow() public view returns(uint256) {\\r\\n        (uint112 pwreserve0, uint112 pwreserve1, ) = IUniswapV2Pair(pdcWbnbPair).getReserves();\\r\\n        if(pwreserve0 == 0 || pwreserve1 == 0){\\r\\n            return 0;\\r\\n        }\\r\\n        address pwtoken0 = IUniswapV2Pair(pdcWbnbPair).token0();\\r\\n        uint256 pdPriceInWbnb;\\r\\n        if(pwtoken0 == address(this)){\\r\\n            pdPriceInWbnb = uint256(pwreserve1).mul(priceMagnitude).div(uint256(pwreserve0));\\r\\n        } else {\\r\\n            pdPriceInWbnb = uint256(pwreserve0).mul(priceMagnitude).div(uint256(pwreserve1));\\r\\n        }\\r\\n\\r\\n        (uint112 uwreserve0, uint112 uwreserve1, ) = IUniswapV2Pair(usdtWbnbPair).getReserves();\\r\\n        if(uwreserve0 == 0 || uwreserve1 == 0){\\r\\n            return 0;\\r\\n        }\\r\\n        address uwtoken0 = IUniswapV2Pair(usdtWbnbPair).token0();\\r\\n        uint256 wbnbPriceInUsdt;\\r\\n        if(uwtoken0 == WBNB){\\r\\n            wbnbPriceInUsdt = uint256(uwreserve1).mul(priceMagnitude).div(uint256(uwreserve0));\\r\\n        } else {\\r\\n            wbnbPriceInUsdt = uint256(uwreserve0).mul(priceMagnitude).div(uint256(uwreserve1));\\r\\n        }\\r\\n\\r\\n        return pdPriceInWbnb.mul(wbnbPriceInUsdt).div(priceMagnitude);\\r\\n    }\\r\\n\\r\\n    function _getBasePriceRate() public view returns (uint256) {\\r\\n        uint256 basePriceNow = getBasePriceNow();\\r\\n        if (basePriceNow == 0) return 0;\\r\\n        uint256 lpPrice = getLpPriceNow();\\r\\n        if (lpPrice == 0) return 0;\\r\\n        return lpPrice.mul(1000).div(basePriceNow);\\r\\n    }\\r\\n\\r\\n    function getBasePriceNow() public view returns(uint256) {\\r\\n        uint256 _currentLpPrice = getLpPriceNow();\\r\\n        if (basePrice == 0) return _currentLpPrice;\\r\\n        uint256 lastTimeMin = lastBasePriceTimestamp.div(60);\\r\\n        uint256 currentTimeMin = block.timestamp.div(60);\\r\\n        uint256 timeInterval = basePriceTimeInterval;\\r\\n        if (currentTimeMin == lastTimeMin) {\\r\\n            return basePrice;\\r\\n        } else {\\r\\n            uint256 startMin = uint256(startTimestamp).div(60);\\r\\n            uint256 minSinceBegin = currentTimeMin.sub(startMin).add(1);\\r\\n            uint256 minSinceLast = currentTimeMin.sub(lastTimeMin);\\r\\n            if (minSinceBegin \\u003e timeInterval) {\\r\\n                if(minSinceLast \\u003e timeInterval) {\\r\\n                    return _currentLpPrice;\\r\\n                } else {\\r\\n                    return basePrice.mul(timeInterval.sub(minSinceLast)).div(timeInterval).add(_currentLpPrice.mul(minSinceLast).div(timeInterval));\\r\\n                }\\r\\n            } else {\\r\\n                uint256 denominator = minSinceBegin.add(basePricePreMin);\\r\\n                return basePrice.mul(denominator.sub(minSinceLast)).div(denominator).add(_currentLpPrice.mul(minSinceLast).div(denominator));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function _getPdcWbnbReserves() private view returns(uint256 _pdcReserve, uint256 _wbnbReserve) {\\r\\n        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pdcWbnbPair).getReserves();\\r\\n        address token0 = IUniswapV2Pair(pdcWbnbPair).token0();\\r\\n        if(token0 == address(this)){\\r\\n            _pdcReserve = uint256(reserve0);\\r\\n            _wbnbReserve = uint256(reserve1);\\r\\n        } else {\\r\\n            _pdcReserve = uint256(reserve1);\\r\\n            _wbnbReserve = uint256(reserve0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getWbnbUsdtReserves() private view returns(uint256 _wbnbReserve, uint256 _usdtReserve) {\\r\\n        (uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(usdtWbnbPair).getReserves();\\r\\n        address token0 = IUniswapV2Pair(usdtWbnbPair).token0();\\r\\n        if (token0 == WBNB) {\\r\\n            _wbnbReserve = uint256(reserve0);\\r\\n            _usdtReserve = uint256(reserve1);\\r\\n        } else {\\r\\n            _wbnbReserve = uint256(reserve1);\\r\\n            _usdtReserve = uint256(reserve0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getAmountInUsdt(uint256 tokenAmount) public view returns (uint256) {\\r\\n        if (tokenAmount \\u003c= 0) return 0;\\r\\n        (uint256 _pdcReserve, uint256 _wbnbReserve) = _getPdcWbnbReserves();\\r\\n        if (_wbnbReserve \\u003c= 0) return 0;\\r\\n        if (_pdcReserve \\u003c= 0) return 0;\\r\\n        uint256 wbnbIn = uint256(getAmountIn(tokenAmount, _wbnbReserve, _pdcReserve));\\r\\n        \\r\\n        (uint256 _wbnbReserve1, uint256 _usdtReserve) = _getWbnbUsdtReserves();\\r\\n        if (_wbnbReserve1 \\u003c= 0) return 0;\\r\\n        if (_usdtReserve \\u003c= 0) return 0;\\r\\n        return uint256(getAmountIn(wbnbIn, _usdtReserve, _wbnbReserve1));\\r\\n    }\\r\\n\\r\\n    function _getAmountOutUsdt(uint256 tokenAmount) public view returns (uint256) {\\r\\n        if (tokenAmount \\u003c= 0) return 0;\\r\\n        (uint256 _pdcReserve, uint256 _wbnbReserve) = _getPdcWbnbReserves();\\r\\n        if (_wbnbReserve \\u003c= 0 || _pdcReserve \\u003c= 0) return 0;\\r\\n        uint256 wbnbOut = uint256(getAmountOut(tokenAmount, _pdcReserve, _wbnbReserve));\\r\\n        \\r\\n        (uint256 _wbnbReserve1, uint256 _usdtReserve) = _getWbnbUsdtReserves();\\r\\n        if (_wbnbReserve1 \\u003c= 0 || _usdtReserve \\u003c= 0) return 0;\\r\\n        return uint256(getAmountOut(wbnbOut, _wbnbReserve1, _usdtReserve)); \\r\\n    }\\r\\n\\r\\n    function _getAmountOutWbnb(uint256 tokenAmount) public view returns (uint256) {\\r\\n        if (tokenAmount \\u003c= 0) return 0;\\r\\n        (uint256 _pdcReserve, uint256 _wbnbReserve) = _getPdcWbnbReserves();\\r\\n        if (_wbnbReserve \\u003c= 0 || _pdcReserve \\u003c= 0) return 0;\\r\\n        return uint256(getAmountOut(tokenAmount, _pdcReserve, _wbnbReserve));\\r\\n    }\\r\\n\\r\\n    function _getAmountInPd(uint256 amountOut) private view returns(uint256){\\r\\n        (uint256 _pdcReserve, uint256 _wbnbReserve) = _getPdcWbnbReserves();\\r\\n        if (_wbnbReserve \\u003c= 0 || _pdcReserve \\u003c= 0) return 0;\\r\\n        return uint256(getAmountIn(amountOut, _pdcReserve, _wbnbReserve));\\r\\n    }\\r\\n\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\r\\n        if (amountOut \\u003c= 0) return 0;\\r\\n        if (reserveIn \\u003c= 0) return 0;\\r\\n        if (reserveOut \\u003c= 0) return 0;\\r\\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\\r\\n        uint denominator = reserveOut.sub(amountOut).mul(9975);\\r\\n        amountIn = (numerator / denominator).add(1);\\r\\n    }\\r\\n\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\r\\n        if (amountIn \\u003c= 0) return 0;\\r\\n        if (reserveIn \\u003c= 0) return 0;\\r\\n        if (reserveOut \\u003c= 0) return 0;\\r\\n        uint amountInWithFee = amountIn.mul(9975);\\r\\n        uint numerator = amountInWithFee.mul(reserveOut);\\r\\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\\r\\n        amountOut = numerator / denominator;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function _swapDividend() internal {\\r\\n        uint256 divBal = balanceOf(_divReceiver);\\r\\n        uint256 divBalInUsdt = _getAmountOutUsdt(divBal);\\r\\n        if (divBalInUsdt \\u003e= minimumAmountToSwap) {\\r\\n            _approve(address(dividendTracker), address(uniswapV2Router), divBal + 10000);\\r\\n            dividendTracker.swapAndDistributeDividends(address(this));\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function name() public view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _total;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function switchOwner (address _newOwner) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        require(_newOwner != address(0), \\\"new owner is zero address.\\\");\\r\\n        _owner = _newOwner;\\r\\n    }\\r\\n    \\r\\n    function setBasePriceTimeInterval(uint256 _basePriceTimeInterval) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        basePriceTimeInterval = _basePriceTimeInterval;\\r\\n    }\\r\\n    \\r\\n    function setHighestSellTaxRate (uint256 _highestSellTaxRate) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        highestSellTaxRate = _highestSellTaxRate;\\r\\n    }\\r\\n    \\r\\n    function setWBNB(address _wbnb) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        require(_wbnb != address(0), \\\"new address is zero address.\\\");\\r\\n        WBNB = _wbnb;\\r\\n    }\\r\\n    \\r\\n    function setMinimumAmountToSwap(uint256 _minimumAmountToSwap) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        minimumAmountToSwap = _minimumAmountToSwap;\\r\\n    }\\r\\n    \\r\\n    function setMaxSell(uint256 __maxSell) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        _maxSell = __maxSell;\\r\\n    }\\r\\n    \\r\\n    function setIsAutoDividend(bool _isAutoDividend) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        isAutoDividend = _isAutoDividend;\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        require(_isExcludedFromFee[account] != excluded, \\\"Account is already the value of \\u0027excluded\\u0027\\\");\\r\\n        _isExcludedFromFee[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n\\r\\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\\r\\n        require(newValue \\u003e= 200000 \\u0026\\u0026 newValue \\u003c= 500000, \\\"gasForProcessing must be between 200,000 and 500,000\\\");\\r\\n        require(newValue != gasForProcessing, \\\"Cannot update gasForProcessing to same value\\\");\\r\\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\\r\\n        gasForProcessing = newValue;\\r\\n    }\\r\\n\\r\\n    function setEnableFee(bool _enableFee) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        enableFee = _enableFee;\\r\\n    }\\r\\n\\r\\n    function getExcludeFromFee(address addr) public view returns(bool) {\\r\\n        return _isExcludedFromFee[addr];\\r\\n    }\\r\\n\\r\\n    function updateFixSellSlippage(uint256 _fixSellSlippage) public onlyOwner{\\r\\n        fixSellSlippage = _fixSellSlippage;\\r\\n    }\\r\\n\\r\\n    function dividendTokenBalanceOf(address account) public view returns (uint256) {\\r\\n\\t\\treturn dividendTracker.balanceOf(account);\\r\\n\\t}\\r\\n\\r\\n    function getExcludedFromDividends(address account) public view returns (bool){\\r\\n        return dividendTracker.getExcludedFromDividends(account);\\r\\n    }\\r\\n\\r\\n    function setDividendLimit(uint256 limit) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        dividendTracker.setDividendLimit(limit);\\r\\n    }\\r\\n\\r\\n    function setDividendToken(address newToken) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        dividendTracker.setDividendTokenAddress(newToken);\\r\\n    }\\r\\n\\r\\n    function updateClaimWait(uint256 claim) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        dividendTracker.updateClaimWait(claim);\\r\\n    }\\r\\n\\r\\n    function getWithdrawableDividendOf(address account) public view returns(uint256) {\\r\\n        return dividendTracker.withdrawableDividendOf(account);\\r\\n    }\\r\\n\\r\\n    function excludeFromDividends(address addr) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        dividendTracker.excludeFromDividends(addr);\\r\\n    }\\r\\n\\r\\n    function unexcludeFromDividends(address addr) public {\\r\\n        require(_msgSender() == owner(), \\\"permission denied.\\\");\\r\\n        dividendTracker.unexcludeFromDividends(addr);\\r\\n    }\\r\\n\\r\\n    function withdrawableDividendOf(address addr) public view returns(uint256) {\\r\\n        return dividendTracker.withdrawableDividendOf(addr);\\r\\n    }\\r\\n\\r\\n    function withdrawnDividendOf(address addr) public view returns(uint256) {\\r\\n        return dividendTracker.withdrawnDividendOf(addr);\\r\\n    }\\r\\n\\r\\n    function setSellRateUpper(uint256 newTax) public onlyOwner{\\r\\n        sellRateUpper = newTax;\\r\\n    }\\r\\n\\r\\n    function setSellRateBelow(uint256 newTax) public onlyOwner{\\r\\n        sellRateBelow = newTax;\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n    event ProcessedDividendTracker(\\r\\n        uint256 iterations,\\r\\n        uint256 claims,\\r\\n        uint256 lastProcessedIndex,\\r\\n        bool indexed automatic,\\r\\n        uint256 gas,\\r\\n        address indexed processor\\r\\n    );\\r\\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n    \\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./Context.sol\\\";\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n    \\n    event OwnershipTransferred(address indexed _previousOwner, address indexed newOwner);\\n    \\n    constructor() public {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n    \\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns(address) {\\n        return _owner;\\n    }\\n    \\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner.\\\");\\n        _;\\n    }\\n    \\n    /**\\n    * @dev Leaves the contract without owner. It will not be possible to call\\n    * `onlyOwner` functions anymore. Can only be called by the current owner.\\n    */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n    \\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnerShip(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is zero address.\\\");\\n        \\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    \\n    function getUnlockTime() public view returns(uint256) {\\n        return _lockTime;\\n    }\\n    \\n    function lock(uint256 time) public virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _owner = address(0);\\n        _lockTime = block.timestamp + time;\\n        emit OwnershipTransferred(_previousOwner, address(0));\\n    }\\n    \\n    function unlock() public virtual {\\n        require(_previousOwner == msg.sender, \\\"You don\\u0027t have permission to unlock the token contract\\\");\\n        require(block.timestamp \\u003e _lockTime, \\\"Unlock time has not come\\\");\\n        \\n        emit OwnershipTransferred(_owner, _previousOwner);\\n        _owner = _previousOwner;\\n        _previousOwner = address(0);\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    \\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow.\\\");\\n        return c;\\n    }\\n    \\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow.\\\");\\n    }\\n    \\n    function sub(uint256 a, uint256 b, string memory errMsg) internal pure returns(uint256) {\\n        require(b \\u003c= a, errMsg);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    \\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\\n        if(a == 0){\\n            return 0;\\n        }\\n        \\n        uint256 c = a * b;\\n        require(c/a == b, \\\"SafeMath: mutiplication overflow.\\\");\\n        return c;\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero.\\\");\\n    }\\n    \\n    function div(uint256 a, uint256 b, string memory errMsg) internal pure returns(uint256) {\\n        require(b \\u003e 0, errMsg);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n    \\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero.\\\");\\n    }\\n    \\n    function mod(uint256 a, uint256 b, string memory errMsg) internal pure returns(uint256) {\\n        require(b != 0, errMsg);\\n        return a % b;\\n    }\\n    \\n}\"},\"SafeMathInt.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SafeMathInt {\\n    function add(int256 a, int256 b) internal pure returns(int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n        return c;\\n    }\\n    \\n    function sub(int256 a, int256 b) internal pure returns(int256) {\\n        require((b \\u003e= 0 \\u0026\\u0026 a - b \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 a - b \\u003e a));\\n        return a - b;\\n    }\\n    \\n    function mul(int256 a, int256 b) internal pure returns(int256) {\\n        require(!(a == -2**255 \\u0026\\u0026 b == -1) \\u0026\\u0026 !(b == -2**255 \\u0026\\u0026 a == -1));\\n         int256 c = a * b;\\n         require((b == 0) || (c/b == a));\\n         return c;\\n    }\\n    \\n    function div(int256 a, int256 b) internal pure returns(int256){\\n        require(!(a == -2**255 \\u0026\\u0026 b == -1) \\u0026\\u0026 (b \\u003e 0));\\n        return a/b;\\n    }\\n    \\n    function toUint256Safe(int256 a) internal pure returns(uint256) {\\n        require(a \\u003e= 0);\\n        return uint256(a);\\n    }\\n}\"},\"SafeMathUint.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SafeMathUint {\\n    function toInt256Safe(uint256 a) internal pure returns(int256){\\n        int256 b = int256(a);\\n        require(b \\u003e= 0, \\\"need \\u003e= 0\\\");\\n        return b;\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_consultantReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_developReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_divReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_getAmountInUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_getAmountOutUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"_getAmountOutWbnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getBasePriceRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getSellTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_operateReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_raiseReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePricePreMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePriceTimeInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSellRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixSellSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBasePriceNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getExcludeFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getExcludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpPriceNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getWithdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"highestSellTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAutoDividend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBasePriceTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAmountToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pdcWbnbPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellRateBelow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellRateUpper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_basePriceTimeInterval\",\"type\":\"uint256\"}],\"name\":\"setBasePriceTimeInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setDividendLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setDividendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enableFee\",\"type\":\"bool\"}],\"name\":\"setEnableFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_highestSellTaxRate\",\"type\":\"uint256\"}],\"name\":\"setHighestSellTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isAutoDividend\",\"type\":\"bool\"}],\"name\":\"setIsAutoDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"__maxSell\",\"type\":\"uint256\"}],\"name\":\"setMaxSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumAmountToSwap\",\"type\":\"uint256\"}],\"name\":\"setMinimumAmountToSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"setSellRateBelow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTax\",\"type\":\"uint256\"}],\"name\":\"setSellRateUpper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"}],\"name\":\"setWBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"switchOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnerShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"unexcludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fixSellSlippage\",\"type\":\"uint256\"}],\"name\":\"updateFixSellSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtWbnbPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawnDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MetaverseDao", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "IterableMapping:a04a9ae711058f4660bd2c5ef54e837ea77cd819", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1f7f13e6952c10a40793c1c4dbbf63c91bc58096d8976cd62c0d5ba894c25ca2"}