{"SourceCode": "// File: contracts/Axie/contracts/erc/erc721/IERC721Base.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x6466353c\r\ninterface IERC721Base /* is IERC165  */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param _data Additional data with no specified format, sent in call to `_to`\r\n    // solium-disable-next-line arg-overflow\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to []\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all your asset.\r\n    /// @dev Emits the ApprovalForAll event\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operators is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n// File: contracts/Axie/contracts/openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Axie/contracts/openzeppelin-solidity/contracts/ownership/HasNoEther.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2\u03c0.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  function HasNoEther() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by settings a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    // solium-disable-next-line security/no-send\r\n    assert(owner.send(address(this).balance));\r\n  }\r\n}\r\n\r\n// File: contracts/Axie/contracts/openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/Axie/contracts/marketplace/AxieClockAuction.sol\r\n\r\npragma solidity ^0.4.19;\r\n\r\n\r\n\r\n\r\n\r\n/// @title Clock auction for non-fungible tokens.\r\ncontract AxieClockAuction is HasNoEther, Pausable {\r\n\r\n    address private apenft_addr;\r\n\r\n    function getAPENFTAddress() public view returns (address) {\r\n        return apenft_addr;\r\n    }\r\n\r\n    function setAPENFTAddress(address addr) public onlyOwner {\r\n        apenft_addr = addr;\r\n    }\r\n\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    mapping(address => mapping(uint256 => Auction)) public auctions;\r\n\r\n    event AuctionCreated(\r\n        address indexed _nftAddress,\r\n        uint256 indexed _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    );\r\n\r\n    event AuctionSuccessful(\r\n        address indexed _nftAddress,\r\n        uint256 indexed _tokenId,\r\n        uint256 _totalPrice,\r\n        address _winner,\r\n        address _seller\r\n    );\r\n\r\n    event AuctionCancelled(\r\n        address indexed _nftAddress,\r\n        uint256 indexed _tokenId\r\n    );\r\n\r\n    /// @dev Constructor creates a reference to the NFT ownership contract\r\n    ///  and verifies the owner cut is in the valid range.\r\n    /// @param _ownerCut - percent cut the owner takes on each auction, must be\r\n    ///  between 0-10,000.\r\n    function AxieClockAuction(uint256 _ownerCut) public {\r\n        require(_ownerCut <= 10000);\r\n        ownerCut = _ownerCut;\r\n    }\r\n\r\n    /// @dev DON'T give me your money.\r\n    function() external {}\r\n\r\n    // Modifiers to check that inputs can be safely stored with a certain\r\n    // number of bits. We use constants and multiple modifiers to save gas.\r\n    modifier canBeStoredWith64Bits(uint256 _value) {\r\n        require(_value <= 18446744073709551615);\r\n        _;\r\n    }\r\n\r\n    modifier canBeStoredWith128Bits(uint256 _value) {\r\n        require(_value < 340282366920938463463374607431768211455);\r\n        _;\r\n    }\r\n\r\n    /// @dev Returns auction info for an NFT on auction.\r\n    /// @param _nftAddress - Address of the NFT.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    view\r\n    returns (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt\r\n    )\r\n    {\r\n        Auction storage _auction = auctions[_nftAddress][_tokenId];\r\n        require(_isOnAuction(_auction));\r\n        return (\r\n        _auction.seller,\r\n        _auction.startingPrice,\r\n        _auction.endingPrice,\r\n        _auction.duration,\r\n        _auction.startedAt\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of an auction.\r\n    /// @param _nftAddress - Address of the NFT.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getCurrentPrice(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Auction storage _auction = auctions[_nftAddress][_tokenId];\r\n        require(_isOnAuction(_auction));\r\n        return _getCurrentPrice(_auction);\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _nftAddress - address of a deployed contract implementing\r\n    ///  the Nonfungible Interface.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    function createAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration\r\n    )\r\n    external\r\n    whenNotPaused\r\n    canBeStoredWith128Bits(_startingPrice)\r\n    canBeStoredWith128Bits(_endingPrice)\r\n    canBeStoredWith64Bits(_duration)\r\n    {\r\n        address _seller = msg.sender;\r\n        require(_owns(_nftAddress, _seller, _tokenId));\r\n        _escrow(_nftAddress, _seller, _tokenId);\r\n        Auction memory _auction = Auction(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(\r\n            _nftAddress,\r\n            _tokenId,\r\n            _auction,\r\n            _seller\r\n        );\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Ether is supplied.\r\n    /// @param _nftAddress - address of a deployed contract implementing\r\n    ///  the Nonfungible Interface.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_nftAddress, _tokenId, msg.value);\r\n        _transfer(_nftAddress, msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _nftAddress - Address of the NFT.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(address _nftAddress, uint256 _tokenId) external {\r\n        Auction storage _auction = auctions[_nftAddress][_tokenId];\r\n        require(_isOnAuction(_auction));\r\n        require(msg.sender == _auction.seller);\r\n        _cancelAuction(_nftAddress, _tokenId, _auction.seller);\r\n    }\r\n\r\n    /// @dev Cancels an auction when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _nftAddress - Address of the NFT.\r\n    /// @param _tokenId - ID of the NFT on auction to cancel.\r\n    function cancelAuctionWhenPaused(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n    external\r\n    whenPaused\r\n    onlyOwner\r\n    {\r\n        Auction storage _auction = auctions[_nftAddress][_tokenId];\r\n        require(_isOnAuction(_auction));\r\n        _cancelAuction(_nftAddress, _tokenId, _auction.seller);\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on auction.\r\n    /// @param _auction - Auction to check.\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Gets the NFT object from an address, validating that implementsERC721 is true.\r\n    /// @param _nftAddress - Address of the NFT.\r\n    function _getNftContract(address _nftAddress) internal pure returns (IERC721Base) {\r\n        IERC721Base candidateContract = IERC721Base(_nftAddress);\r\n        // require(candidateContract.implementsERC721());\r\n        return candidateContract;\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction. Broken into two\r\n    ///  functions (this one, that computes the duration from the auction\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _getCurrentPrice(\r\n        Auction storage _auction\r\n    )\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 _secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarantees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            _secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            _secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function external and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our external functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addAuction())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 _totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and _totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 _currentPriceChange = _totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // _currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 _currentPrice = int256(_startingPrice) + _currentPriceChange;\r\n\r\n            return uint256(_currentPrice);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _nftAddress - The address of the NFT.\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _nftAddress, address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        IERC721Base _nftContract = _getNftContract(_nftAddress);\r\n        return (_nftContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /// @dev Adds an auction to the list of open auctions. Also fires the\r\n    ///  AuctionCreated event.\r\n    /// @param _tokenId The ID of the token to be put on auction.\r\n    /// @param _auction Auction to add.\r\n    function _addAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        Auction _auction,\r\n        address _seller\r\n    )\r\n    internal\r\n    {\r\n        // Require that all auctions have a duration of\r\n        // at least one minute. (Keeps our math from getting hairy!)\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        auctions[_nftAddress][_tokenId] = _auction;\r\n\r\n        AuctionCreated(\r\n            _nftAddress,\r\n            _tokenId,\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration),\r\n            _seller\r\n        );\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(address _nftAddress, uint256 _tokenId) internal {\r\n        delete auctions[_nftAddress][_tokenId];\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(address _nftAddress, uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_nftAddress, _tokenId);\r\n        _transfer(_nftAddress, _seller, _tokenId);\r\n        AuctionCancelled(_nftAddress, _tokenId);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _nftAddress - The address of the NFT.\r\n    /// @param _owner - Current owner address of token to escrow.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _nftAddress, address _owner, uint256 _tokenId) internal {\r\n        IERC721Base _nftContract = _getNftContract(_nftAddress);\r\n\r\n        // It will throw if transfer fails\r\n        _nftContract.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _nftAddress - The address of the NFT.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _nftAddress, address _receiver, uint256 _tokenId) internal {\r\n        IERC721Base _nftContract = _getNftContract(_nftAddress);\r\n\r\n        // It will throw if transfer fails\r\n        _nftContract.transferFrom(this, _receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n        return _price * ownerCut / 10000;\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _bidAmount\r\n    )\r\n    internal\r\n    returns (uint256)\r\n    {\r\n        // Get a reference to the auction struct\r\n        Auction storage _auction = auctions[_nftAddress][_tokenId];\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(_auction));\r\n\r\n        // Check that the incoming bid is higher than the current\r\n        // price\r\n        uint256 _price = _getCurrentPrice(_auction);\r\n        require(_bidAmount >= _price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address _seller = _auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_nftAddress, _tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (_price > 0) {\r\n            //  Calculate the auctioneer's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            //  value <= price, so this subtraction can't go negative.)\r\n            uint256 _auctioneerCut = _computeCut(_price);\r\n            uint256 _sellerProceeds = _price - _auctioneerCut;\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            _seller.transfer(_sellerProceeds);\r\n        }\r\n\r\n        if (_bidAmount > _price) {\r\n            // Calculate any excess funds included with the bid. If the excess\r\n            // is anything worth worrying about, transfer it back to bidder.\r\n            // NOTE: We checked above that the bid amount is greater than or\r\n            // equal to the price so this cannot underflow.\r\n            uint256 _bidExcess = _bidAmount - _price;\r\n\r\n            // Return the funds. Similar to the previous transfer, this is\r\n            // not susceptible to a re-entry attack because the auction is\r\n            // removed before any transfers occur.\r\n            msg.sender.transfer(_bidExcess);\r\n        }\r\n\r\n        // Tell the world!\r\n        AuctionSuccessful(\r\n            _nftAddress,\r\n            _tokenId,\r\n            _price,\r\n            msg.sender,\r\n            _seller\r\n        );\r\n\r\n        return _price;\r\n    }\r\n\r\n    function setOwnerCut(uint256 _ownerCut) onlyOwner returns (uint256){\r\n        require(_ownerCut <= 10000);\r\n        ownerCut = _ownerCut;\r\n        return ownerCut;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint128\"},{\"name\":\"endingPrice\",\"type\":\"uint128\"},{\"name\":\"duration\",\"type\":\"uint64\"},{\"name\":\"startedAt\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerCut\",\"type\":\"uint256\"}],\"name\":\"setOwnerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAPENFTAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAPENFTAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerCut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_nftAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "AxieClockAuction", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001a9", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a8ca58b0073813cc0c0ef4c409b6fa0aad96b78fb6f5abc057c3a549a1ce8da0"}