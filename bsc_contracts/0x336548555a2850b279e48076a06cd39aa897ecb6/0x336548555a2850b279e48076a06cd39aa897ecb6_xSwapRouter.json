{"SourceCode": "{\"IERC20.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    \\r\\n    function symbol() external view returns(string memory);\\r\\n    \\r\\n    function name() external view returns(string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the number of decimal places\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"IXSurge.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n/**\\r\\n    XSurge Interface\\r\\n        Supports xSwap Protocol\\r\\n */\\r\\ninterface IXSurge is IERC20{\\r\\n\\r\\n    function exchange(address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) external;\\r\\n    function burn(uint256 amount) external;\\r\\n    function mintWithNative(address recipient, uint256 minOut) external payable returns (uint256);\\r\\n    function mintWithBacking(address backingToken, uint256 numTokens, address recipient) external returns (uint256);\\r\\n    function requestPromiseTokens(address stable, uint256 amount) external returns (uint256);\\r\\n    function sell(uint256 tokenAmount) external returns (address, uint256);\\r\\n    function calculatePrice() external view returns (uint256);\\r\\n    function getValueOfHoldings(address holder) external view returns(uint256);\\r\\n    function isUnderlyingAsset(address token) external view returns (bool);\\r\\n    function getUnderlyingAssets() external view returns(address[] memory);\\r\\n    function requestFlashLoan(address stable, address stableToRepay, uint256 amount) external returns (bool);\\r\\n    function resourceCollector() external view returns (address);\\r\\n}\"},\"xSwap.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./IXSurge.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ninterface IStableSwapRouter {\\r\\n\\r\\n    /**\\r\\n        Calculates Amount To Be Received From Stable Coin Swap\\r\\n     */\\r\\n    function expectedOut(address sender, uint256 amount) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n        Expected Fee To Be Taken From Swap Amount\\r\\n     */\\r\\n    function getFeeOut(uint256 amount) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n        Swap TokenIn For TokenOut, sends tokenOut to destination\\r\\n     */\\r\\n    function exchange(address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) external;\\r\\n\\r\\n    /**\\r\\n        Swap `TokenIn` For `TokenOut` using `source` contract as means of exchange, sends `tokenOut` to `destination`\\r\\n     */\\r\\n    function exchange(address source, address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) external;    \\r\\n}\\r\\n\\r\\n/**\\r\\n    xSwap Protocol Will Call SurgeV2 Tokens\\u0027 exchange() function\\r\\n    And Take Necessary Fees To Ensure Profitability For XSurge V2 Tokens\\r\\n */\\r\\ncontract xSwapRouter is IStableSwapRouter {\\r\\n\\r\\n    // xToken Data\\r\\n    struct xToken {\\r\\n        bool isApproved;\\r\\n        uint256 index;\\r\\n        uint256 totalFeesGenerated;\\r\\n    }\\r\\n    address[] public allXTokens;\\r\\n\\r\\n    // XSurge Token -\\u003e Data\\r\\n    mapping (address =\\u003e xToken) public xTokens;\\r\\n\\r\\n    // Sender -\\u003e Fee Rank\\r\\n    mapping ( address =\\u003e uint256 ) public feeRank;\\r\\n\\r\\n    // Tokens Banned From Swap\\r\\n    mapping (address =\\u003e bool) public tokenDeniedFromSwap;\\r\\n\\r\\n    // rates\\r\\n    uint256 public baseRate   = 50;\\r\\n    uint256 public middleRate = 25;\\r\\n    uint256 public bottomRate = 0;\\r\\n    uint256 public maximumFee = 1000 * 10**18;\\r\\n    uint256 public constant maximumRate = 200;\\r\\n    uint256 public constant feeDenominator = 10**5;\\r\\n\\r\\n    // operator\\r\\n    address public operator;\\r\\n    modifier onlyOperator() {\\r\\n        require(msg.sender == operator, \\u0027Only Operator\\u0027);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Events\\r\\n    event ChangedOperator(address newOperator);\\r\\n    event SetRates(uint256 baseRate,uint256 middleRate,uint256 bottomRate,uint256 maximumFee);\\r\\n    event AddXToken(address xToken);\\r\\n    event RemoveXToken(address xToken);\\r\\n    event SwapTokenPermissionChanged(address token, bool canSwap);\\r\\n    event Swap(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);\\r\\n    event SetFeeRank(address Contract, uint256 newRank);\\r\\n\\r\\n    constructor() {\\r\\n        operator = msg.sender;\\r\\n    }\\r\\n\\r\\n    function changeOperator( address newOperator ) external onlyOperator {\\r\\n        operator = newOperator;\\r\\n        emit ChangedOperator(newOperator);\\r\\n    }\\r\\n\\r\\n    function withdraw(address token) external onlyOperator {\\r\\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\\r\\n    }\\r\\n    function setRates(\\r\\n        uint256 baseRate_,\\r\\n        uint256 middleRate_,\\r\\n        uint256 bottomRate_,\\r\\n        uint256 maximumFee_\\r\\n    ) external onlyOperator {\\r\\n        // require rates are in bounds\\r\\n        require(\\r\\n            baseRate_ \\u003c= maximumRate \\u0026\\u0026\\r\\n            middleRate_ \\u003c= maximumRate \\u0026\\u0026\\r\\n            bottomRate_ \\u003c= maximumRate,\\r\\n            \\\"Rates Capped At 0.2%\\\"\\r\\n        );\\r\\n        \\r\\n        // set state\\r\\n        baseRate = baseRate_;\\r\\n        middleRate = middleRate_;\\r\\n        bottomRate = bottomRate_;\\r\\n        maximumFee = maximumFee_;\\r\\n        emit SetRates(baseRate,middleRate,bottomRate,maximumFee);\\r\\n    }\\r\\n\\r\\n    function addXToken(\\r\\n            address xtoken\\r\\n    ) external onlyOperator {\\r\\n        // require addresses are valid\\r\\n        require(\\r\\n            xtoken != address(0),\\r\\n            \\\"Zero Provided\\\"\\r\\n        );\\r\\n        require(\\r\\n            !xTokens[xtoken].isApproved,\\r\\n            \\u0027Token Already Approved\\u0027\\r\\n        );\\r\\n\\r\\n        // set state\\r\\n        xTokens[xtoken].isApproved = true;\\r\\n        xTokens[xtoken].index = allXTokens.length;\\r\\n\\r\\n        allXTokens.push(xtoken);\\r\\n        emit AddXToken(xtoken);\\r\\n    }\\r\\n\\r\\n    function setFeeRank(address Contract, uint256 newRank) external onlyOperator {\\r\\n        require(newRank \\u003c= 2, \\\"Invalid Rank\\\");\\r\\n\\r\\n        feeRank[Contract] = newRank;\\r\\n        emit SetFeeRank(Contract, newRank);\\r\\n    }\\r\\n\\r\\n    function removeXToken(address xtoken) external onlyOperator {\\r\\n        require(\\r\\n            xTokens[xtoken].isApproved,\\r\\n            \\u0027Token Not Approved\\u0027\\r\\n        );\\r\\n\\r\\n        xTokens[\\r\\n            allXTokens[allXTokens.length - 1]\\r\\n        ].index = xTokens[xtoken].index;\\r\\n\\r\\n        allXTokens[\\r\\n            xTokens[xtoken].index\\r\\n        ] = allXTokens[allXTokens.length - 1];\\r\\n        allXTokens.pop();\\r\\n\\r\\n        delete xTokens[xtoken];\\r\\n        emit RemoveXToken(xtoken);\\r\\n    }\\r\\n\\r\\n    function restrictTokenAccess(address token) external onlyOperator {\\r\\n        tokenDeniedFromSwap[token] = true;\\r\\n        emit SwapTokenPermissionChanged(token, false);\\r\\n    }\\r\\n\\r\\n    function unRestrictTokenAccess(address token) external onlyOperator {\\r\\n        delete tokenDeniedFromSwap[token];\\r\\n        emit SwapTokenPermissionChanged(token, true);\\r\\n    }\\r\\n\\r\\n    function exchange(address tokenIn, address tokenOut, uint256 amountTokenIn) external {\\r\\n        _exchange(allXTokens[0], tokenIn, tokenOut, amountTokenIn, msg.sender);\\r\\n    }\\r\\n\\r\\n    function exchange(address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) external override {\\r\\n        _exchange(allXTokens[0], tokenIn, tokenOut, amountTokenIn, destination);\\r\\n    }\\r\\n\\r\\n    function exchange(address source, address tokenIn, address tokenOut, uint256 amountTokenIn) external {\\r\\n        _exchange(source, tokenIn, tokenOut, amountTokenIn, msg.sender);\\r\\n    }\\r\\n\\r\\n    function exchange(address source, address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) external override {\\r\\n        _exchange(source, tokenIn, tokenOut, amountTokenIn, destination);\\r\\n    }\\r\\n\\r\\n    function expectedOut(address sender, uint256 amount) external view override returns (uint256) {\\r\\n        return amount - _getFee(sender, amount);\\r\\n    }\\r\\n\\r\\n    function getFeeOut(uint256 amount) public view override returns (uint256) {\\r\\n        return _getFee(address(this), amount);\\r\\n    }\\r\\n\\r\\n    function _exchange(address source, address tokenIn, address tokenOut, uint256 amountTokenIn, address destination) internal {\\r\\n\\r\\n        require(\\r\\n            xTokens[source].isApproved,\\r\\n            \\\"Not Approved Source\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            !tokenDeniedFromSwap[tokenIn] \\u0026\\u0026\\r\\n            !tokenDeniedFromSwap[tokenOut],\\r\\n            \\\"Restricted Asset\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            IXSurge(source).isUnderlyingAsset(tokenIn) \\u0026\\u0026\\r\\n            IXSurge(source).isUnderlyingAsset(tokenOut),\\r\\n            \\\"Not Approved Assets\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            IERC20(tokenOut).balanceOf(source) \\u003e= amountTokenIn,\\r\\n            \\\"Invalid In Amount\\\"\\r\\n        );\\r\\n\\r\\n        // transfer in tokens\\r\\n        uint256 before = IERC20(tokenIn).balanceOf(address(this));\\r\\n        require(\\r\\n            IERC20(tokenIn).transferFrom(msg.sender, address(this), amountTokenIn),\\r\\n            \\\"Failed TransferFrom\\\"\\r\\n        );\\r\\n        uint256 received = IERC20(tokenIn).balanceOf(address(this)) - before;\\r\\n\\r\\n        // fetch fee for received amount\\r\\n        uint256 fee = _getFee(msg.sender, received);\\r\\n        // calculate amount to send\\r\\n        uint256 sendAmount = received - fee;\\r\\n\\r\\n        // Sanity Check\\r\\n        require(\\r\\n            sendAmount \\u003e 0 \\u0026\\u0026 sendAmount \\u003c= amountTokenIn,\\r\\n            \\\"Failed To Receive\\\"\\r\\n        );\\r\\n\\r\\n        // distribute the fee\\r\\n        address collector = IXSurge(source).resourceCollector();\\r\\n        if (fee \\u003e 0 \\u0026\\u0026 collector != address(0)) {\\r\\n            uint rFee = fee / 2;\\r\\n            uint bFee = fee - rFee;\\r\\n            IERC20(tokenIn).transfer(collector, rFee);\\r\\n            IERC20(tokenIn).transfer(source, bFee);\\r\\n            xTokens[source].totalFeesGenerated += fee;\\r\\n        }\\r\\n        \\r\\n        // Approve Source For Amount\\r\\n        IERC20(tokenIn).approve(source, sendAmount);\\r\\n\\r\\n        // Transfers In tokenIn in exchange for tokenOut 1:1\\r\\n        IXSurge(source).exchange(tokenIn, tokenOut, sendAmount, destination);\\r\\n        emit Swap(tokenIn, tokenOut, amountTokenIn, sendAmount);\\r\\n    }\\r\\n\\r\\n    function _getFee(address sender, uint256 amount) internal view returns (uint256) {\\r\\n\\r\\n        uint256 fee = 0;\\r\\n\\r\\n        if (feeRank[sender] \\u003e= 2) {\\r\\n            fee = ( ( amount * bottomRate) / feeDenominator );\\r\\n        } else if (feeRank[sender] == 1) {\\r\\n            fee = ( ( amount * middleRate) / feeDenominator );\\r\\n        } else {\\r\\n            fee = ( ( amount * baseRate) / feeDenominator );\\r\\n        }\\r\\n\\r\\n        return fee \\u003e maximumFee ? maximumFee : fee;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"xToken\",\"type\":\"address\"}],\"name\":\"AddXToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"ChangedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"xToken\",\"type\":\"address\"}],\"name\":\"RemoveXToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"SetFeeRank\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"middleRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bottomRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumFee\",\"type\":\"uint256\"}],\"name\":\"SetRates\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"canSwap\",\"type\":\"bool\"}],\"name\":\"SwapTokenPermissionChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xtoken\",\"type\":\"address\"}],\"name\":\"addXToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allXTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bottomRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenIn\",\"type\":\"uint256\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenIn\",\"type\":\"uint256\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"expectedOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getFeeOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"middleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"xtoken\",\"type\":\"address\"}],\"name\":\"removeXToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"restrictTokenAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"setFeeRank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"middleRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bottomRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumFee_\",\"type\":\"uint256\"}],\"name\":\"setRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenDeniedFromSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unRestrictTokenAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"xTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFeesGenerated\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "xSwapRouter", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2d5cd1791006626a41be94825ed06d3bca4f1ff8cc435ec8b6b0ee0667f3d36c"}