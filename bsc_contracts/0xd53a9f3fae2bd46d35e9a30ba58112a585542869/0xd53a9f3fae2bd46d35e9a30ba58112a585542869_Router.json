{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@maverick/contracts/contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IPool.sol\\\";\\nimport \\\"../interfaces/IPosition.sol\\\";\\ninterface IFactory {\\n    event PoolCreated(address poolAddress, uint256 fee, uint256 tickSpacing, int32 activeTick, int256 lookback, uint64 protocolFeeRatio, IERC20 tokenA, IERC20 tokenB);\\n    event SetFactoryProtocolFeeRatio(uint64 protocolFeeRatio);\\n    event SetFactoryOwner(address owner);\\n    /// @notice creates new pool\\n    /// @param _fee is a rate in prbmath 60x18 decimal format\\n    /// @param _tickSpacing  1.0001^tickSpacing is the bin width\\n    /// @param _activeTick initial activeTick of the pool\\n    /// @param _lookback TWAP lookback in whole seconds\\n    /// @param _tokenA ERC20 token\\n    /// @param _tokenB ERC20 token\\n    function create(\\n        uint256 _fee,\\n        uint256 _tickSpacing,\\n        int256 _lookback,\\n        int32 _activeTick,\\n        IERC20 _tokenA,\\n        IERC20 _tokenB\\n    ) external returns (IPool);\\n    function lookup(\\n        uint256 fee,\\n        uint256 tickSpacing,\\n        int256 lookback,\\n        IERC20 tokenA,\\n        IERC20 tokenB\\n    ) external view returns (IPool);\\n    function owner() external view returns (address);\\n    function position() external view returns (IPosition);\\n    /// @notice protocolFeeRatio ratio of the swap fee that is kept for the\\n    //protocol\\n    function protocolFeeRatio() external view returns (uint64);\\n    /// @notice lookup table for whether a pool is owned by the factory\\n    function isFactoryPool(IPool pool) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@maverick/contracts/contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IFactory.sol\\\";\\ninterface IPool {\\n    event Swap(address sender, address recipient, bool tokenAIn, bool exactOutput, uint256 amountIn, uint256 amountOut, int32 activeTick);\\n    event AddLiquidity(address indexed sender, uint256 indexed tokenId, BinDelta[] binDeltas);\\n    event MigrateBinsUpStack(address indexed sender, uint128 binId, uint32 maxRecursion);\\n    event TransferLiquidity(uint256 fromTokenId, uint256 toTokenId, RemoveLiquidityParams[] params);\\n    event RemoveLiquidity(address indexed sender, address indexed recipient, uint256 indexed tokenId, BinDelta[] binDeltas);\\n    event BinMerged(uint128 indexed binId, uint128 reserveA, uint128 reserveB, uint128 mergeId);\\n    event BinMoved(uint128 indexed binId, int128 previousTick, int128 newTick);\\n    event ProtocolFeeCollected(uint256 protocolFee, bool isTokenA);\\n    event SetProtocolFeeRatio(uint256 protocolFee);\\n    /// @notice return parameters for Add/Remove liquidity\\n    /// @param binId of the bin that changed\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param isActive bool to indicate whether the bin is still active\\n    /// @param lowerTick is the lower price tick of the bin in its current state\\n    /// @param deltaA amount of A token that has been added or removed\\n    /// @param deltaB amount of B token that has been added or removed\\n    /// @param deltaLpToken amount of LP balance that has increase (add) or decreased (remove)\\n    struct BinDelta {\\n        uint128 deltaA;\\n        uint128 deltaB;\\n        uint256 deltaLpBalance;\\n        uint128 binId;\\n        uint8 kind;\\n        int32 lowerTick;\\n        bool isActive;\\n    }\\n    /// @notice time weighted average state\\n    /// @param twa the twa at the last update instant\\n    /// @param value the new value that was passed in at the last update\\n    /// @param lastTimestamp timestamp of the last update in seconds\\n    /// @param lookback time in seconds\\n    struct TwaState {\\n        int96 twa;\\n        int96 value;\\n        uint64 lastTimestamp;\\n    }\\n    /// @notice bin state parameters\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param lowerTick is the lower price tick of the bin in its current state\\n    /// @param mergeId binId of the bin that this bin has merged in to\\n    /// @param reserveA amount of A token in bin\\n    /// @param reserveB amount of B token in bin\\n    /// @param totalSupply total amount of LP tokens in this bin\\n    /// @param mergeBinBalance LP token balance that this bin posseses of the merge bin\\n    struct BinState {\\n        uint128 reserveA;\\n        uint128 reserveB;\\n        uint128 mergeBinBalance;\\n        uint128 mergeId;\\n        uint128 totalSupply;\\n        uint8 kind;\\n        int32 lowerTick;\\n    }\\n    /// @notice Parameters for each bin that will get new liquidity\\n    /// @param kind one of the 4 Kinds (0=static, 1=right, 2=left, 3=both)\\n    /// @param pos bin position\\n    /// @param isDelta bool that indicates whether the bin position is relative\\n    //to the current bin or an absolute position\\n    /// @param deltaA amount of A token to add\\n    /// @param deltaB amount of B token to add\\n    struct AddLiquidityParams {\\n        uint8 kind;\\n        int32 pos;\\n        bool isDelta;\\n        uint128 deltaA;\\n        uint128 deltaB;\\n    }\\n    /// @notice Parameters for each bin that will have liquidity removed\\n    /// @param binId index of the bin losing liquidity\\n    /// @param amount LP balance amount to remove\\n    struct RemoveLiquidityParams {\\n        uint128 binId;\\n        uint128 amount;\\n    }\\n    /// @notice State of the pool\\n    /// @param activeTick  current bin position that contains the active bins\\n    /// @param status pool status.  e.g. locked or unlocked; status values\\n    //defined in Pool.sol\\n    /// @param binCounter index of the last bin created\\n    /// @param protocolFeeRatio ratio of the swap fee that is kept for the\\n    //protocol\\n    struct State {\\n        int32 activeTick;\\n        uint8 status;\\n        uint128 binCounter;\\n        uint64 protocolFeeRatio;\\n    }\\n    /// @notice fee for pool in 18 decimal format\\n    function fee() external view returns (uint256);\\n    /// @notice tickSpacing of pool where 1.0001^tickSpacing is the bin width\\n    function tickSpacing() external view returns (uint256);\\n    /// @notice address of token A\\n    function tokenA() external view returns (IERC20);\\n    /// @notice address of token B\\n    function tokenB() external view returns (IERC20);\\n    /// @notice address of Factory\\n    function factory() external view returns (IFactory);\\n    /// @notice bitmap of active bins\\n    function binMap(int32 tick) external view returns (uint256);\\n    /// @notice mapping of tick/kind to binId\\n    function binPositions(int32 tick, uint256 kind) external view returns (uint128);\\n    /// @notice internal accounting of the sum tokenA balance across bins\\n    function binBalanceA() external view returns (uint128);\\n    /// @notice internal accounting of the sum tokenB balance across bins\\n    function binBalanceB() external view returns (uint128);\\n    /// @notice Twa state values\\n    function getTwa() external view returns (TwaState memory);\\n    /// @notice log base binWidth of the time weighted average price\\n    function getCurrentTwa() external view returns (int256);\\n    /// @notice pool state\\n    function getState() external view returns (State memory);\\n    /// @notice Add liquidity to a pool.\\n    /// @param tokenId NFT token ID that will hold the position\\n    /// @param params array of AddLiquidityParams that specify the mode and\\n    //position of the liquidity\\n    /// @param data callback function that addLiquidity will call so that the\\n    //caller can transfer tokens\\n    function addLiquidity(\\n        uint256 tokenId,\\n        AddLiquidityParams[] calldata params,\\n        bytes calldata data\\n    )\\n        external\\n        returns (\\n            uint256 tokenAAmount,\\n            uint256 tokenBAmount,\\n            BinDelta[] memory binDeltas\\n        );\\n    /// @notice Transfer liquidity in an array of bins from one nft tokenId\\n    //to another\\n    /// @param fromTokenId NFT token ID that holds the position being transferred\\n    /// @param toTokenId NFT token ID that is receiving liquidity\\n    /// @param params array of binIds and amounts to transfer\\n    function transferLiquidity(\\n        uint256 fromTokenId,\\n        uint256 toTokenId,\\n        RemoveLiquidityParams[] calldata params\\n    ) external;\\n    /// @notice Remove liquidity from a pool.\\n    /// @param recipient address that will receive the removed tokens\\n    /// @param tokenId NFT token ID that holds the position being removed\\n    /// @param params array of RemoveLiquidityParams that specify the bins,\\n    //and amounts\\n    function removeLiquidity(\\n        address recipient,\\n        uint256 tokenId,\\n        RemoveLiquidityParams[] calldata params\\n    )\\n        external\\n        returns (\\n            uint256 tokenAOut,\\n            uint256 tokenBOut,\\n            BinDelta[] memory binDeltas\\n        );\\n    /// @notice Migrate bins up the linked list of merged bins so that its\\n    //mergeId is the currrent active bin.\\n    /// @param binId is an array of the binIds to be migrated\\n    /// @param maxRecursion is the maximum recursion depth of the migration. set to\\n    //zero to recurse until the active bin is found.\\n    function migrateBinUpStack(uint128 binId, uint32 maxRecursion) external;\\n    /// @notice swap tokens\\n    /// @param recipient address that will receive the output tokens\\n    /// @param amount amount of token that is either the input if exactOutput\\n    //is false or the output if exactOutput is true\\n    /// @param tokenAIn bool indicating whether tokenA is the input\\n    /// @param exactOutput bool indicating whether the amount specified is the\\n    //exact output amount (true)\\n    /// @param sqrtPriceLimit limiting sqrt price of the swap.  A value of 0\\n    //indicates no limit.  Limit is only engaged for exactOutput=false.  If the\\n    //limit is reached only part of the input amount will be swapped and the\\n    //callback will only require that amount of the swap to be paid.\\n    /// @param data callback function that swap will call so that the\\n    //caller can transfer tokens\\n    function swap(\\n        address recipient,\\n        uint256 amount,\\n        bool tokenAIn,\\n        bool exactOutput,\\n        uint256 sqrtPriceLimit,\\n        bytes calldata data\\n    ) external returns (uint256 amountIn, uint256 amountOut);\\n    /// @notice bin information for a given binId\\n    function getBin(uint128 binId) external view returns (BinState memory bin);\\n    /// @notice LP token balance for a given tokenId at a given binId\\n    function balanceOf(uint256 tokenId, uint128 binId) external view returns (uint256 lpToken);\\n    /// @notice tokenA scale value\\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\\n    //functions to convert from token amounts to D18 scale internal pool\\n    //accounting.\\n    function tokenAScale() external view returns (uint256);\\n    /// @notice tokenB scale value\\n    /// @dev msb is a flag to indicate whether tokenA has more or less than 18\\n    //decimals.  Scale is used in conjuction with Math.toScale/Math.fromScale\\n    //functions to convert from token amounts to D18 scale internal pool\\n    //accounting.\\n    function tokenBScale() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@maverick/contracts/contracts/interfaces/IPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"../interfaces/IPositionMetadata.sol\\\";\\ninterface IPosition is IERC721Enumerable {\\n    event SetMetadata(IPositionMetadata metadata);\\n    /// @notice mint new position NFT\\n    function mint(address to) external returns (uint256 tokenId);\\n    /// @notice mint new position NFT\\n    function tokenOfOwnerByIndexExists(address owner, uint256 index) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@maverick/contracts/contracts/interfaces/IPositionMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\ninterface IPositionMetadata {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@maverick/contracts/contracts/interfaces/ISwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\ninterface ISwapCallback {\\n    function swapCallback(\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IERC20PermitAllowed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Interface for permit\\n/// @notice Interface used by DAI/CHAI for permit\\ninterface IERC20PermitAllowed {\\n    /// @notice Approve the spender to spend some tokens via the holder signature\\n    /// @dev This is the permit interface used by DAI and CHAI\\n    /// @param holder The address of the token holder, the token owner\\n    /// @param spender The address of the token spender\\n    /// @param nonce The holder's nonce, increases at each call to permit\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n/// @title Multicall interface\\n/// @notice Enables calling multiple methods in a single call to the contract\\ninterface IMulticall {\\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\\n    /// @param data The encoded function data for each of the calls to make to this contract\\n    /// @return results The results from each of the calls passed in via data\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IFactory.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IPool.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IPosition.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/ISwapCallback.sol\\\";\\nimport \\\"./external/IWETH9.sol\\\";\\nimport \\\"./ISlimRouter.sol\\\";\\ninterface IRouter is ISlimRouter {\\n    /// @return Returns the address of the factory\\n    function factory() external view returns (IFactory);\\n    /// @return Returns the address of the Position NFT\\n    function position() external view returns (IPosition);\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n    /// @notice Swaps `amountIn` of one token for as much as possible of\\n    //another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded\\n    //as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n    /// @notice Swaps as little as possible of one token for `amountOut` of\\n    //another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded\\n    //as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n    struct PoolParams {\\n        uint256 fee;\\n        uint256 tickSpacing;\\n        int256 lookback;\\n        int32 activeTick;\\n        IERC20 tokenA;\\n        IERC20 tokenB;\\n    }\\n    /// @notice create a pool and add liquidity to it\\n    /// @param poolParams paramters of a pool\\n    /// @param tokenId nft id of token that will hold lp balance, use 0 to mint a new token\\n    /// @param addParams paramters of liquidity addition\\n    /// @param minTokenAAmount minimum amount of token A to add, revert if not met\\n    /// @param minTokenBAmount minimum amount of token B to add, revert if not met\\n    /// @param deadline epoch timestamp in seconds\\n    function getOrCreatePoolAndAddLiquidity(\\n        PoolParams calldata poolParams,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata addParams,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        uint256 deadline\\n    ) external payable returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas);\\n    /// @notice add liquidity to a pool\\n    /// @param pool pool to add liquidity to\\n    /// @param tokenId nft id of token that will hold lp balance, use 0 to mint a new token\\n    /// @param params paramters of liquidity addition\\n    /// @param minTokenAAmount minimum amount of token A to add, revert if not met\\n    /// @param minTokenBAmount minimum amount of token B to add, revert if not met\\n    /// @param deadline epoch timestamp in seconds\\n    function addLiquidityToPool(\\n        IPool pool,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        uint256 deadline\\n    ) external payable returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas);\\n    /// @notice add liquidity to a pool with active tick limits\\n    /// @param pool pool to add liquidity to\\n    /// @param tokenId nft id of token that will hold lp balance, use 0 to mint a new token\\n    /// @param params paramters of liquidity addition\\n    /// @param minTokenAAmount minimum amount of token A to add, revert if not met\\n    /// @param minTokenBAmount minimum amount of token B to add, revert if not met\\n    /// @param minActiveTick lowest activeTick (inclusive) of pool that will permit transaction to pass\\n    /// @param maxActiveTick highest activeTick (inclusive) of pool that will permit transaction to pass\\n    /// @param deadline epoch timestamp in seconds\\n    function addLiquidityWTickLimits(\\n        IPool pool,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        int32 minActiveTick,\\n        int32 maxActiveTick,\\n        uint256 deadline\\n    ) external payable returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas);\\n    /// @notice moves the head of input merged bins to the active bin\\n    /// @param pool to remove from\\n    /// @param binIds array of bin Ids to migrate\\n    /// @param maxRecursion maximum recursion depth before returning; 0=no max\\n    /// @param deadline epoch timestamp in seconds\\n    function migrateBinsUpStack(IPool pool, uint128[] calldata binIds, uint32 maxRecursion, uint256 deadline) external;\\n    /// @notice remove liquidity from pool and receive WETH if one of the tokens is WETH\\n    /// @dev router must be approved for the withdrawing tokenId: Position.approve(router, tokenId)\\n    /// @param pool pool to remove from\\n    /// @param recipient address where proceeds are sent; use zero or router address to leave tokens in router\\n    /// @param tokenId ID of position NFT that holds liquidity\\n    /// @param params paramters of liquidity removal\\n    /// @param minTokenAAmount minimum amount of token A to receive, revert if not met\\n    /// @param minTokenBAmount minimum amount of token B to receive, revert if not met\\n    /// @param deadline epoch timestamp in seconds\\n    function removeLiquidity(\\n        IPool pool,\\n        address recipient,\\n        uint256 tokenId,\\n        IPool.RemoveLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        uint256 deadline\\n    ) external returns (uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISelfPermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\n/// @title Self Permit\\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\\ninterface ISelfPermit {\\n    /// @notice Permits this contract to spend a given token from `msg.sender`\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\\n    /// @param token The address of the token spent\\n    /// @param value The amount that can be spent of token\\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;\\n    /// @notice Permits this contract to spend a given token from `msg.sender`\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\\n    /// @param token The address of the token spent\\n    /// @param value The amount that can be spent of token\\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermitIfNecessary(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable;\\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\\n    /// @param token The address of the token spent\\n    /// @param nonce The current nonce of the owner\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermitAllowed(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external payable;\\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\\n    /// @param token The address of the token spent\\n    /// @param nonce The current nonce of the owner\\n    /// @param expiry The timestamp at which the permit is no longer valid\\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\\n    function selfPermitAllowedIfNecessary(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISlimRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IPool.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/ISwapCallback.sol\\\";\\nimport \\\"./external/IWETH9.sol\\\";\\ninterface ISlimRouter is ISwapCallback {\\n    /// @return Returns the address of WETH9\\n    function WETH9() external view returns (IWETH9);\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        IPool pool;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint256 sqrtPriceLimitD18;\\n    }\\n    /// @notice Swaps `amountIn` of one token for as much as possible of\\n    //another token\\n    /// @param params The parameters necessary for the swap, encoded as\\n    //`ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        IPool pool;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n    /// @notice Swaps as little as possible of one token for `amountOut` of\\n    //another token\\n    /// @param params The parameters necessary for the swap, encoded as\\n    //`ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\\n    /// @param recipient The address receiving ETH\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\\n    /// that use ether for the input amount\\n    function refundETH() external payable;\\n    /// @notice Transfers the full amount of a token held by this contract to recipient\\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\\n    /// @param token The contract address of the token which will be transferred to `recipient`\\n    /// @param amountMinimum The minimum amount of token required for a transfer\\n    /// @param recipient The destination address of the token\\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity ^0.8.0;\\nlibrary BytesLib {\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n        bytes memory tempBytes;\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n                mstore(tempBytes, _length)\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n        return tempBytes;\\n    }\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n        return tempAddress;\\n    }\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3, \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n        return tempUint;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Deadline.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\nabstract contract Deadline {\\n    modifier checkDeadline(uint256 deadline) {\\n        require(block.timestamp <= deadline, \\\"Transaction too old\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\nimport \\\"../interfaces/IMulticall.sol\\\";\\n/// @title Multicall\\n/// @notice Enables calling multiple methods in a single call to the contract\\nabstract contract Multicall is IMulticall {\\n    /// @inheritdoc IMulticall\\n    function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n            results[i] = result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Path.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IPool.sol\\\";\\nimport \\\"./BytesLib.sol\\\";\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary Path {\\n    using BytesLib for bytes;\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The offset of a single token address and pool address\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + ADDR_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n    /// @notice Returns true iff the path contains two or more pools\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more pools, otherwise false\\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n    }\\n    /// @notice Returns the number of pools in the path\\n    /// @param path The encoded swap path\\n    /// @return The number of pools in the path\\n    function numPools(bytes memory path) internal pure returns (uint256) {\\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\\n    }\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenIn The input in a path\\n    /// @return tokenOut The output in a path\\n    /// @return pool The pool\\n    function decodeFirstPool(bytes memory path) internal pure returns (IERC20 tokenIn, IERC20 tokenOut, IPool pool) {\\n        tokenIn = IERC20(path.toAddress(0));\\n        pool = IPool(path.toAddress(ADDR_SIZE));\\n        tokenOut = IERC20(path.toAddress(NEXT_OFFSET));\\n    }\\n    /// @notice Gets the segment corresponding to the first pool in the path\\n    /// @param path The bytes encoded swap path\\n    /// @return The segment containing all data necessary to target the first pool in the path\\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(0, POP_OFFSET);\\n    }\\n    /// @notice Skips a token + pool element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + pool elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SelfPermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../interfaces/ISelfPermit.sol\\\";\\nimport \\\"../interfaces/external/IERC20PermitAllowed.sol\\\";\\n/// @title Self Permit\\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\\n/// that requires an approval in a single transaction.\\nabstract contract SelfPermit is ISelfPermit {\\n    /// @inheritdoc ISelfPermit\\n    function selfPermit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public payable override {\\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    }\\n    /// @inheritdoc ISelfPermit\\n    function selfPermitIfNecessary(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external payable override {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);\\n    }\\n    /// @inheritdoc ISelfPermit\\n    function selfPermitAllowed(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) public payable override {\\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\\n    }\\n    /// @inheritdoc ISelfPermit\\n    function selfPermitAllowedIfNecessary(address token, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external payable override {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max) selfPermitAllowed(token, nonce, expiry, v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"STF\\\");\\n    }\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(address token, address to, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"ST\\\");\\n    }\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(address token, address to, uint256 value) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"SA\\\");\\n    }\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"STE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IPool.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IFactory.sol\\\";\\nimport \\\"@maverick/contracts/contracts/interfaces/IPosition.sol\\\";\\nimport \\\"./interfaces/IRouter.sol\\\";\\nimport \\\"./interfaces/external/IWETH9.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./libraries/Path.sol\\\";\\nimport \\\"./libraries/Deadline.sol\\\";\\nimport \\\"./libraries/Multicall.sol\\\";\\nimport \\\"./libraries/SelfPermit.sol\\\";\\ncontract Router is IRouter, Multicall, SelfPermit, Deadline {\\n    using Path for bytes;\\n    /// @dev Used as the placeholder value for amountInCached, because the\\n    //computed amount in for an exact output swap / can never actually be this\\n    //value\\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    struct AddLiquidityCallbackData {\\n        IERC20 tokenA;\\n        IERC20 tokenB;\\n        IPool pool;\\n        address payer;\\n    }\\n    struct SwapCallbackData {\\n        bytes path;\\n        address payer;\\n        bool exactOutput;\\n    }\\n    /// @inheritdoc IRouter\\n    IFactory public immutable factory;\\n    /// @inheritdoc IRouter\\n    IPosition public immutable position;\\n    /// @inheritdoc ISlimRouter\\n    IWETH9 public immutable WETH9;\\n    constructor(IFactory _factory, IWETH9 _WETH9) {\\n        factory = _factory;\\n        position = _factory.position();\\n        WETH9 = _WETH9;\\n    }\\n    receive() external payable {\\n        require(IWETH9(msg.sender) == WETH9, \\\"Not WETH9\\\");\\n    }\\n    /// @inheritdoc ISlimRouter\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {\\n        uint256 balanceWETH9 = WETH9.balanceOf(address(this));\\n        require(balanceWETH9 >= amountMinimum, \\\"Insufficient WETH9\\\");\\n        if (balanceWETH9 > 0) {\\n            WETH9.withdraw(balanceWETH9);\\n            TransferHelper.safeTransferETH(recipient, balanceWETH9);\\n        }\\n    }\\n    /// @inheritdoc ISlimRouter\\n    function sweepToken(IERC20 token, uint256 amountMinimum, address recipient) public payable {\\n        uint256 balanceToken = token.balanceOf(address(this));\\n        require(balanceToken >= amountMinimum, \\\"Insufficient token\\\");\\n        if (balanceToken > 0) {\\n            TransferHelper.safeTransfer(address(token), recipient, balanceToken);\\n        }\\n    }\\n    /// @inheritdoc ISlimRouter\\n    function refundETH() external payable override {\\n        if (address(this).balance > 0) TransferHelper.safeTransferETH(msg.sender, address(this).balance);\\n    }\\n    /// @param token The token to pay\\n    /// @param payer The entity that must pay\\n    /// @param recipient The entity that will receive payment\\n    /// @param value The amount to pay\\n    function pay(IERC20 token, address payer, address recipient, uint256 value) internal {\\n        if (IWETH9(address(token)) == WETH9 && address(this).balance >= value) {\\n            WETH9.deposit{value: value}();\\n            WETH9.transfer(recipient, value);\\n        } else if (payer == address(this)) {\\n            TransferHelper.safeTransfer(address(token), recipient, value);\\n        } else {\\n            TransferHelper.safeTransferFrom(address(token), payer, recipient, value);\\n        }\\n    }\\n    function swapCallback(uint256 amountToPay, uint256 amountOut, bytes calldata _data) external {\\n        require(amountToPay > 0 && amountOut > 0, \\\"In or Out Amount is Zero\\\");\\n        require(factory.isFactoryPool(IPool(msg.sender)), \\\"Must call from a Factory Pool\\\");\\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\\n        (IERC20 tokenIn, IERC20 tokenOut, IPool pool) = data.path.decodeFirstPool();\\n        require(msg.sender == address(pool));\\n        if (data.exactOutput) {\\n            if (data.path.hasMultiplePools()) {\\n                data.path = data.path.skipToken();\\n                exactOutputInternal(amountToPay, msg.sender, data);\\n            } else {\\n                amountInCached = amountToPay;\\n                pay(tokenOut, data.payer, msg.sender, amountToPay);\\n            }\\n        } else {\\n            pay(tokenIn, data.payer, msg.sender, amountToPay);\\n        }\\n    }\\n    function exactInputInternal(uint256 amountIn, address recipient, uint256 sqrtPriceLimitD18, SwapCallbackData memory data) private returns (uint256 amountOut) {\\n        if (recipient == address(0)) recipient = address(this);\\n        (IERC20 tokenIn, IERC20 tokenOut, IPool pool) = data.path.decodeFirstPool();\\n        bool tokenAIn = tokenIn < tokenOut;\\n        (, amountOut) = pool.swap(recipient, amountIn, tokenAIn, false, sqrtPriceLimitD18, abi.encode(data));\\n    }\\n    /// @inheritdoc ISlimRouter\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\\n        bool tokenAIn = params.tokenIn < params.tokenOut;\\n        (, amountOut) = params.pool.swap(\\n            (params.recipient == address(0)) ? address(this) : params.recipient,\\n            params.amountIn,\\n            tokenAIn,\\n            false,\\n            params.sqrtPriceLimitD18,\\n            abi.encode(SwapCallbackData({path: abi.encodePacked(params.tokenIn, params.pool, params.tokenOut), payer: msg.sender, exactOutput: false}))\\n        );\\n        require(amountOut >= params.amountOutMinimum, \\\"Too little received\\\");\\n    }\\n    /// @inheritdoc IRouter\\n    function exactInput(ExactInputParams memory params) external payable override checkDeadline(params.deadline) returns (uint256 amountOut) {\\n        address payer = msg.sender;\\n        while (true) {\\n            bool stillMultiPoolSwap = params.path.hasMultiplePools();\\n            params.amountIn = exactInputInternal(\\n                params.amountIn,\\n                stillMultiPoolSwap ? address(this) : params.recipient,\\n                0,\\n                SwapCallbackData({path: params.path.getFirstPool(), payer: payer, exactOutput: false})\\n            );\\n            if (stillMultiPoolSwap) {\\n                payer = address(this);\\n                params.path = params.path.skipToken();\\n            } else {\\n                amountOut = params.amountIn;\\n                break;\\n            }\\n        }\\n        require(amountOut >= params.amountOutMinimum, \\\"Too little received\\\");\\n    }\\n    /// @dev Performs a single exact output swap\\n    function exactOutputInternal(uint256 amountOut, address recipient, SwapCallbackData memory data) private returns (uint256 amountIn) {\\n        if (recipient == address(0)) recipient = address(this);\\n        (IERC20 tokenOut, IERC20 tokenIn, IPool pool) = data.path.decodeFirstPool();\\n        bool tokenAIn = tokenIn < tokenOut;\\n        uint256 amountOutReceived;\\n        (amountIn, amountOutReceived) = pool.swap(recipient, amountOut, tokenAIn, true, 0, abi.encode(data));\\n        require(amountOutReceived == amountOut, \\\"Requested amount not available\\\");\\n    }\\n    /// @inheritdoc ISlimRouter\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\\n        bool tokenAIn = params.tokenIn < params.tokenOut;\\n        uint256 amountOutReceived;\\n        (amountIn, amountOutReceived) = params.pool.swap(\\n            (params.recipient == address(0)) ? address(this) : params.recipient,\\n            params.amountOut,\\n            tokenAIn,\\n            true,\\n            0,\\n            abi.encode(SwapCallbackData({path: abi.encodePacked(params.tokenOut, params.pool, params.tokenIn), payer: msg.sender, exactOutput: true}))\\n        );\\n        require(amountOutReceived == params.amountOut, \\\"Requested amount not available\\\");\\n        require(amountIn <= params.amountInMaximum, \\\"Too much requested\\\");\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n    /// @inheritdoc IRouter\\n    function exactOutput(ExactOutputParams calldata params) external payable override checkDeadline(params.deadline) returns (uint256 amountIn) {\\n        exactOutputInternal(params.amountOut, params.recipient, SwapCallbackData({path: params.path, payer: msg.sender, exactOutput: true}));\\n        amountIn = amountInCached;\\n        require(amountIn <= params.amountInMaximum, \\\"Too much requested\\\");\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n    // Liqudity\\n    function addLiquidityCallback(uint256 amountA, uint256 amountB, bytes calldata _data) external {\\n        AddLiquidityCallbackData memory data = abi.decode(_data, (AddLiquidityCallbackData));\\n        require(factory.isFactoryPool(IPool(msg.sender)));\\n        require(msg.sender == address(data.pool));\\n        if (amountA != 0) {\\n            pay(data.tokenA, data.payer, msg.sender, amountA);\\n        }\\n        if (amountB != 0) {\\n            pay(data.tokenB, data.payer, msg.sender, amountB);\\n        }\\n    }\\n    function addLiquidity(\\n        IPool pool,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount\\n    ) private returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas) {\\n        if (tokenId == 0) {\\n            if (IPosition(position).tokenOfOwnerByIndexExists(msg.sender, 0)) {\\n                tokenId = IPosition(position).tokenOfOwnerByIndex(msg.sender, 0);\\n            } else {\\n                tokenId = IPosition(position).mint(msg.sender);\\n            }\\n        }\\n        receivingTokenId = tokenId;\\n        AddLiquidityCallbackData memory data = AddLiquidityCallbackData({tokenA: pool.tokenA(), tokenB: pool.tokenB(), pool: pool, payer: msg.sender});\\n        (tokenAAmount, tokenBAmount, binDeltas) = pool.addLiquidity(tokenId, params, abi.encode(data));\\n        require(tokenAAmount >= minTokenAAmount && tokenBAmount >= minTokenBAmount, \\\"Too little added\\\");\\n    }\\n    /// @inheritdoc IRouter\\n    function addLiquidityToPool(\\n        IPool pool,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas) {\\n        return addLiquidity(pool, tokenId, params, minTokenAAmount, minTokenBAmount);\\n    }\\n    /// @inheritdoc IRouter\\n    function addLiquidityWTickLimits(\\n        IPool pool,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        int32 minActiveTick,\\n        int32 maxActiveTick,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas) {\\n        int32 activeTick = pool.getState().activeTick;\\n        require(activeTick >= minActiveTick && activeTick <= maxActiveTick, \\\"activeTick not in range\\\");\\n        return addLiquidity(pool, tokenId, params, minTokenAAmount, minTokenBAmount);\\n    }\\n    function getOrCreatePool(PoolParams calldata poolParams) private returns (IPool pool) {\\n        {\\n            pool = IFactory(factory).lookup(poolParams.fee, poolParams.tickSpacing, poolParams.lookback, poolParams.tokenA, poolParams.tokenB);\\n        }\\n        if (address(pool) == address(0)) {\\n            pool = IFactory(factory).create(poolParams.fee, poolParams.tickSpacing, poolParams.lookback, poolParams.activeTick, poolParams.tokenA, poolParams.tokenB);\\n        }\\n    }\\n    /// @inheritdoc IRouter\\n    function getOrCreatePoolAndAddLiquidity(\\n        PoolParams calldata poolParams,\\n        uint256 tokenId,\\n        IPool.AddLiquidityParams[] calldata addParams,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        uint256 deadline\\n    ) external payable checkDeadline(deadline) returns (uint256 receivingTokenId, uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas) {\\n        IPool pool = getOrCreatePool(poolParams);\\n        return addLiquidity(pool, tokenId, addParams, minTokenAAmount, minTokenBAmount);\\n    }\\n    /// @inheritdoc IRouter\\n    function migrateBinsUpStack(IPool pool, uint128[] calldata binIds, uint32 maxRecursion, uint256 deadline) external checkDeadline(deadline) {\\n        for (uint256 i = 0; i < binIds.length; i++) {\\n            pool.migrateBinUpStack(binIds[i], maxRecursion);\\n        }\\n    }\\n    /// @inheritdoc IRouter\\n    function removeLiquidity(\\n        IPool pool,\\n        address recipient,\\n        uint256 tokenId,\\n        IPool.RemoveLiquidityParams[] calldata params,\\n        uint256 minTokenAAmount,\\n        uint256 minTokenBAmount,\\n        uint256 deadline\\n    ) external checkDeadline(deadline) returns (uint256 tokenAAmount, uint256 tokenBAmount, IPool.BinDelta[] memory binDeltas) {\\n        require(msg.sender == position.ownerOf(tokenId), \\\"P\\\");\\n        if (recipient == address(0)) recipient = address(this);\\n        (tokenAAmount, tokenBAmount, binDeltas) = pool.removeLiquidity(recipient, tokenId, params);\\n        require(tokenAAmount >= minTokenAAmount && tokenBAmount >= minTokenBAmount, \\\"Too little removed\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"contract IWETH9\",\"name\":\"_WETH9\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH9\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addLiquidityCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"pos\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isDelta\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"}],\"internalType\":\"struct IPool.AddLiquidityParams[]\",\"name\":\"params\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityToPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivingTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deltaLpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"binId\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"lowerTick\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct IPool.BinDelta[]\",\"name\":\"binDeltas\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"pos\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isDelta\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"}],\"internalType\":\"struct IPool.AddLiquidityParams[]\",\"name\":\"params\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"int32\",\"name\":\"minActiveTick\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"maxActiveTick\",\"type\":\"int32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityWTickLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivingTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deltaLpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"binId\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"lowerTick\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct IPool.BinDelta[]\",\"name\":\"binDeltas\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct IRouter.ExactInputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sqrtPriceLimitD18\",\"type\":\"uint256\"}],\"internalType\":\"struct ISlimRouter.ExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"internalType\":\"struct IRouter.ExactOutputParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISlimRouter.ExactOutputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tickSpacing\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"lookback\",\"type\":\"int256\"},{\"internalType\":\"int32\",\"name\":\"activeTick\",\"type\":\"int32\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenB\",\"type\":\"address\"}],\"internalType\":\"struct IRouter.PoolParams\",\"name\":\"poolParams\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"pos\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isDelta\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"}],\"internalType\":\"struct IPool.AddLiquidityParams[]\",\"name\":\"addParams\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"getOrCreatePoolAndAddLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"receivingTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deltaLpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"binId\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"lowerTick\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct IPool.BinDelta[]\",\"name\":\"binDeltas\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint128[]\",\"name\":\"binIds\",\"type\":\"uint128[]\"},{\"internalType\":\"uint32\",\"name\":\"maxRecursion\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"migrateBinsUpStack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"position\",\"outputs\":[{\"internalType\":\"contract IPosition\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"binId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IPool.RemoveLiquidityParams[]\",\"name\":\"params\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"minTokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokenBAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"deltaA\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"deltaB\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deltaLpBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"binId\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"int32\",\"name\":\"lowerTick\",\"type\":\"int32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"internalType\":\"struct IPool.BinDelta[]\",\"name\":\"binDeltas\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitAllowed\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitAllowedIfNecessary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitIfNecessary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"swapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrapWETH9\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000076311728ff86054ad4ac52d2e9ca005bc702f589000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xd53a9f3fae2bd46d35e9a30ba58112a585542869", "SwarmSource": ""}