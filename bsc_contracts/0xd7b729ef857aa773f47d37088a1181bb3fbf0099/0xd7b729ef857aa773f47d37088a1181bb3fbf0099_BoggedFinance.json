{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.4;\r\n\r\n/**\r\n * $$$$$$$\\                                                $$\\ \r\n * $$  __$$\\                                               $$ |\r\n * $$ |  $$ | $$$$$$\\   $$$$$$\\   $$$$$$\\   $$$$$$\\   $$$$$$$ |\r\n * $$$$$$$\\ |$$  __$$\\ $$  __$$\\ $$  __$$\\ $$  __$$\\ $$  __$$ |\r\n * $$  __$$\\ $$ /  $$ |$$ /  $$ |$$ /  $$ |$$$$$$$$ |$$ /  $$ |\r\n * $$ |  $$ |$$ |  $$ |$$ |  $$ |$$ |  $$ |$$   ____|$$ |  $$ |\r\n * $$$$$$$  |\\$$$$$$  |\\$$$$$$$ |\\$$$$$$$ |\\$$$$$$$\\ \\$$$$$$$ |\r\n * \\_______/  \\______/  \\____$$ | \\____$$ | \\_______| \\_______|\r\n *                     $$\\   $$ |$$\\   $$ |                    \r\n *                     \\$$$$$$  |\\$$$$$$  |      \r\n * $$$$$$$$\\ $$\\        \\______/  \\______/                        \r\n * $$  _____|\\__|                                                  \r\n * $$ |      $$\\ $$$$$$$\\   $$$$$$\\  $$$$$$$\\   $$$$$$$\\  $$$$$$\\  \r\n * $$$$$\\    $$ |$$  __$$\\  \\____$$\\ $$  __$$\\ $$  _____|$$  __$$\\ \r\n * $$  __|   $$ |$$ |  $$ | $$$$$$$ |$$ |  $$ |$$ /      $$$$$$$$ |\r\n * $$ |      $$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$ |      $$   ____|\r\n * $$ |      $$ |$$ |  $$ |\\$$$$$$$ |$$ |  $$ |\\$$$$$$$\\ \\$$$$$$$\\ \r\n * \\__|      \\__|\\__|  \\__| \\_______|\\__|  \\__| \\_______| \\_______|\r\n * \r\n * Bogged Finance\r\n * Website: https://bogged.finance/\r\n * Telegram: https://t.me/boggedfinance\r\n * \r\n * Tokenomics at Launch:\r\n *  - Supply capped at 2,500,000\r\n *  - 1% of every transaction burnt\r\n *  - 4% transaction fee is distributed proportionally between BOG-BNB LP token stakers.\r\n * The fees are variable and when enough holders exist we will move to a governance model where the community can vote to change these\r\n * \r\n * More coming to the ecosystem soon, keep an eye out for announcements on the website & telegram\r\n */\r\n\r\n/**\r\n * @dev Interface of the BOG20 standard\r\n */\r\ninterface IBOG20 {\r\n    function quickRundown(address account) external view returns (uint256);\r\n    function heBought(address account, uint256 amount) external;\r\n    function heSold(address account, uint256 amount) external;\r\n    function fundsAreSafu() external pure returns (bool);\r\n}\r\n\r\n/**\r\n * Can I have a quick rundown?\r\n */\r\n\r\n/* > Rothschilds bow to Bogdanoffs */\r\n/* > Bogdanoffs purposedly dumped Elon's bags to begin alt season and pump bogcoin */\r\n/* > The twins are about 7 decades old, from the space-time reference point of the base human currently accepted by our society */\r\n\r\n/**\r\n * Standard SafeMath, stripped down to just add/sub/mul/div\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/* > Control coinbase with an iron but fair fist */\r\n/* > Possess psychic-like abilities */\r\n/* > Encodes messages to the Federal Reserve */\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/* > Possess recursively self-improving abilities */\r\n/* > In reality, they are timeless beings existing in all points of time and space from the big bang to the end of the universe. \r\n     We don\u2019t know their ultimate plans yet. We hope they\u2019re benevolent beings. */\r\n/* > Nation states entrust their gold reserves with the twins. There\u2019s no gold in Ft. Knox, only Ft. Bogdanoff */\r\n\r\n/**\r\n * Implement the basic BEP20 functions\r\n */\r\nabstract contract BEP20 is IBEP20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal _balances;\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n\r\n    uint256 internal _totalSupply = 0;\r\n    \r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8 internal _decimals = 18;\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    \r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n/* > The big red phone in the Kremlin is a direct line to the Bogdanoff manor */\r\n/* > Direct fork of the ancient Blinded Cash codebase */\r\n/* > Will bankroll the first bogchains on Mars (bogged.finance will be be the first mainnet) */\r\n\r\n/**\r\n * Store contract creation block & timestamp. \r\n * Useful for APY calculations\r\n */\r\nabstract contract RecordsCreation {\r\n    uint256 public creationBlock;\r\n    uint256 public creationTimestamp;\r\n    \r\n    constructor(){\r\n        creationBlock = block.number;\r\n        creationTimestamp = block.timestamp;\r\n    }\r\n}\r\n\r\n/* > Ancient Indian scriptures tell of two angels who will descend upon Earth and will bring an era of enlightenment and unprecedented technological progress with them */\r\n/* > Governs 99% of software development companies on Earth */\r\n/* > Satoshi forked $BOG */\r\n\r\n/**\r\n * Provides ownable context \r\n */\r\nabstract contract Ownable {\r\n    constructor() { _owner = msg.sender; }\r\n    address payable _owner;\r\n    \r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == _owner;\r\n    }\r\n    \r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier owned() {\r\n        require(isOwner(msg.sender)); _;\r\n    }\r\n    \r\n    /**\r\n     * Transfer ownership to the zero address. Caller must be owner.\r\n     */\r\n    function renounceOwnership() public owned() {\r\n        transferOwnership(address(0));\r\n    }\r\n    \r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner.\r\n     */\r\n    function transferOwnership(address payable adr) public owned() {\r\n        _owner = adr;\r\n    }\r\n}\r\n\r\n/* > First dApps will in all likelihood be governed by $BOG tokens */\r\n/* > Bogchain said to have a hashrate of 215+ YH/s, such computational throughput on Earth has only existed deep in DARPA black sites */\r\n/* > Both brothers said to have 215+ IQ, such intelligence on Earth has only existed deep in Tibetan monasteries & Area 51 */\r\n\r\n/**\r\n * Bogdabot interface for accepting transfer hooks\r\n */\r\ninterface IBogdabot {\r\n    function txHook(address caller, address sender, address receiver, uint256 amount) external;\r\n}\r\n\r\n/* > Ancient Usenet scriptures tell of two angels who will descend upon Pancakeswap and will bring an era of green candles and unprecedented pumps with them */\r\n/* > First designer babies will in all likelihood be Bogdanoff babies */\r\n/* > Used in token generators around the world */\r\n\r\n/**\r\n * Allow external contracts (Bogdabots) to hook into BOG transactions\r\n */\r\nabstract contract BogdabotController is Ownable {\r\n    struct BogdabotInfo {\r\n        bool bot;\r\n        uint256 adrIndex;\r\n    }\r\n    \r\n    mapping (address => BogdabotInfo) _botsInfo;\r\n    address[] _bogdabots;\r\n    uint256 _bogdabotsCount;\r\n    \r\n    /**\r\n     * Returns array of bogdabots\r\n     */\r\n    function getBots() public view returns (address[] memory) {\r\n        return _bogdabots;\r\n    }\r\n    \r\n    /**\r\n     * Returns bogdabot count\r\n     */\r\n    function getBotCount() public view returns (uint256) {\r\n        return _bogdabotsCount;\r\n    }\r\n    \r\n    /**\r\n     * Check if address is registered as bogdabot\r\n     */\r\n    function isBot(address account) public view returns (bool) {\r\n        return _botsInfo[account].bot;\r\n    }\r\n    \r\n    /**\r\n     * Add contract to list\r\n     */\r\n    function addBogdabot(address bot) external owned {\r\n        require(isContract(bot));\r\n        _botsInfo[bot].bot = true;\r\n        _botsInfo[bot].adrIndex = _bogdabots.length;\r\n        _bogdabots.push(bot);\r\n        _bogdabotsCount++;\r\n    }\r\n    \r\n    /**\r\n     * Remove bot from list\r\n     */\r\n    function removeBogdabot(address bot) external owned {\r\n        require(isBot(bot));\r\n        _botsInfo[bot].bot = false;\r\n        _bogdabotsCount--; \r\n        \r\n        uint256 i = _botsInfo[bot].adrIndex; // gas savings\r\n        \r\n        // swap in removed bot with last holder and then pop from end\r\n        _bogdabots[i] = _bogdabots[_bogdabots.length-1];\r\n        _botsInfo[_bogdabots[i]].adrIndex = i;\r\n        _bogdabots.pop();\r\n    }\r\n    \r\n    /**\r\n     * Call all bogdabot hooks\r\n     */\r\n    function bogdabotTxHook(address sender, address receiver, uint256 amount) internal {\r\n        if(getBotCount() == 0){ return; }\r\n        for(uint256 i=0; i<_bogdabots.length; i++){ \r\n            /* \r\n             * Using try-catch ensures that any errors / fails in one of the bogdabot contracts will not cancel the overall transaction\r\n             */\r\n            try IBogdabot(_bogdabots[i]).txHook(msg.sender, sender, receiver, amount) {} catch {}\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Check if address is contract.\r\n     * Credit to OpenZeppelin\r\n     */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    \r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(addr)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\n/* > Own 99% of DNA editing research facilities on Earth */\r\n/* > Your computer is likely already a $BOG node */\r\n/* > Will bankroll the first cities on Mars (Bogdangrad will be be the first city) */\r\n\r\n/**\r\n * Keeps a record of all holders.\r\n * Allows all holder data to be used on-chain by other contracts. ;)\r\n */\r\nabstract contract TracksHolders is Ownable {\r\n    \r\n    /**\r\n     * Struct for storing holdings data\r\n     */\r\n    struct Holding {\r\n        bool holding; // whether address is currently holding\r\n        uint256 adrIndex; // index of address in holders array\r\n    }\r\n    \r\n    mapping (address => Holding) _holdings;\r\n    address[] _holders;\r\n    uint256 _holdersCount;\r\n    \r\n    /**\r\n     * Returns array of holders\r\n     */\r\n    function getHolders() public view returns (address[] memory) {\r\n        return _holders;\r\n    }\r\n    \r\n    /**\r\n     * Returns holders count\r\n     */\r\n    function getHoldersCount() public view returns (uint256) {\r\n        return _holdersCount;\r\n    }\r\n    \r\n    /**\r\n     * Returns whether address is currently holder\r\n     */\r\n    function isHolder(address holder) public view returns (bool) {\r\n        return _holdings[holder].holding;\r\n    }\r\n    \r\n    /**\r\n     * Add address to holders list\r\n     */\r\n    function addHolder(address account) internal {\r\n        _holdings[account].holding = true;\r\n        _holdings[account].adrIndex = _holders.length;\r\n        _holders.push(account);\r\n        _holdersCount++;\r\n    }\r\n    \r\n    /**\r\n     * Remove address from holders list\r\n     */\r\n    function removeHolder(address account) internal {\r\n        _holdings[account].holding = false;\r\n        \r\n        // saves gas\r\n        uint256 i = _holdings[account].adrIndex;\r\n        \r\n        // remove holder from array by swapping in end holder\r\n        _holders[i] = _holders[_holders.length-1];\r\n        _holders.pop();\r\n        \r\n        // update end holder index\r\n        _holdings[_holders[i]].adrIndex = i;\r\n        \r\n        _holdersCount--;\r\n    }\r\n}\r\n\r\n/* > The development team are in regular communication with the founders Satoshi and Nakamoto, forwarding the consensus of $BOG to Bitcoin Core. Who do you think set up the meeting between Schiff & the Bitcoin lead maintainers (First meeting between the two organisations in over 10 years) */\r\n/* > Direct descendants of the ancient royal blood line */\r\n/* > Nation states entrust their gold reserves with $BOG. There's no gold in Ft. Knox, only BSCscan. */\r\n\r\ninterface IBogDistributive {\r\n    function getTotalStaked() external view returns (uint256);\r\n    function getTotalFees() external view returns (uint256);\r\n    \r\n    function getStake(address staker) external view returns (uint256);\r\n    function getEarnings(address staker) external view returns (uint256);\r\n    \r\n    function stake(uint256 amount) external;\r\n    function unstake(uint256 amount) external;\r\n    \r\n    function getPairAddress() external view returns (address);\r\n    function forceUnstakeAll() external;\r\n    \r\n    event Staked(address account, uint256 amount);\r\n    event Unstaked(address account, uint256 amount);\r\n    \r\n    event FeesDistributed(address account, uint256 amount);\r\n}\r\n\r\n/* > Own castles & banks globally */\r\n/* > $BOG is about 7 days old from the Unix epoch reference point of the base human currently accepted by developers. */\r\n/* > Control france with an iron but fair fist */\r\n\r\n/**\r\n * This is where the fun happens :)\r\n */\r\nabstract contract BogDistributive is IBogDistributive, BEP20, Ownable, TracksHolders {\r\n    using SafeMath for uint256;\r\n    \r\n    IBEP20 _pair;\r\n    bool _pairInitialized;\r\n    \r\n    /**\r\n     * Struct for holding record of account stakes.\r\n     */\r\n    struct Stake {\r\n        uint256 LP; // Amount of LP tokens staked\r\n        uint256 excludedAmt; // Amount of staking rewards to exclude from returns (if claimed or staked after)\r\n        uint256 realised; // realised rewards\r\n    }\r\n    \r\n    mapping (address => Stake) _stakes;\r\n    \r\n    uint256 _totalLP;\r\n    uint256 _totalFees;\r\n    uint256 _totalRealised;\r\n    \r\n    /**\r\n     * Total LP tokens staked\r\n     */\r\n    function getTotalStaked() external override view returns (uint256) {\r\n        return _totalLP;\r\n    }\r\n    \r\n    /**\r\n     * Total amount of transaction fees reflected to stakers\r\n     */\r\n    function getTotalFees() external override view returns (uint256) {\r\n        return _totalFees;\r\n    }\r\n    \r\n    /**\r\n     * Returns amount of LP that address has staked\r\n     */\r\n    function getStake(address account) public override view returns (uint256) {\r\n        return _stakes[account].LP;\r\n    }\r\n    \r\n    /**\r\n     * Returns total earnings (realised + unrealised)\r\n     */\r\n    function getEarnings(address staker) external override view returns (uint256) {\r\n        return _stakes[staker].realised.add(earnt(staker)); // realised gains plus outstanding earnings\r\n    }\r\n    \r\n    /**\r\n     * Returns unrealised earnings\r\n     */\r\n    function getUnrealisedEarnings(address staker) external view returns (uint256) {\r\n        return earnt(staker);\r\n    }\r\n    \r\n    /**\r\n     * Stake LP tokens to earn a share of the 4% tx fee\r\n     */\r\n    function stake(uint256 amount) external override pairInitialized {\r\n        _stake(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Unstake LP tokens\r\n     */\r\n    function unstake(uint256 amount) external override pairInitialized {\r\n        _unstake(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Return Cake-LP pair address\r\n     */\r\n    function getPairAddress() external view override returns (address) {\r\n        return address(_pair);\r\n    }\r\n    \r\n    /**\r\n     * Return stakes to all holders\r\n     */\r\n    function forceUnstakeAll() external override owned {\r\n        for(uint256 i=0; i<_holders.length; i++){\r\n            uint256 amt = getStake(_holders[i]); // saves gas\r\n            if(amt > 0){ _unstake(_holders[i], amt); }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Add outstanding staking rewards to balance\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account].add(earnt(account));\r\n    }\r\n    \r\n    /**\r\n     * Convert unrealised staking gains into actual balance\r\n     */\r\n    function realise() public {\r\n        _realise(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * Realises outstanding staking rewards into balance\r\n     */\r\n    function _realise(address account) internal {\r\n        if(getStake(account) != 0){\r\n            uint256 amount = earnt(account);\r\n            _balances[account] = _balances[account].add(amount);\r\n            _stakes[account].realised = _stakes[account].realised.add(amount);\r\n            _totalRealised = _totalRealised.add(amount);\r\n        }\r\n        _stakes[account].excludedAmt = _totalFees;\r\n    }\r\n    \r\n    /**\r\n     * Calculate current outstanding staking gains\r\n     */\r\n    function earnt(address account) internal view returns (uint256) {\r\n        if(_stakes[account].excludedAmt == _totalFees || _stakes[account].LP == 0){ return 0; }\r\n        uint256 availableFees = _totalFees.sub(_stakes[account].excludedAmt);\r\n        uint256 share = availableFees.mul(_stakes[account].LP).div(_totalLP); // won't overflow as even totalsupply^2 is less than uint256 max\r\n        return share;\r\n    }\r\n    \r\n    /**\r\n     * Stake amount LP from account\r\n     */\r\n    function _stake(address account, uint256 amount) internal {\r\n        _pair.transferFrom(account, address(this), amount); // transfer LP tokens from account\r\n        \r\n        // realise staking gains now (also works to set excluded amt to current total rewards)\r\n        _realise(account); \r\n        \r\n        // add to current address' stake\r\n        _stakes[account].LP = _stakes[account].LP.add(amount);\r\n        _totalLP = _totalLP.add(amount);\r\n        \r\n        // ensure staker is recorded as holder\r\n        updateHoldersStaked(account);\r\n        \r\n        emit Staked(account, amount);\r\n    }\r\n    \r\n    /**\r\n     * Unstake amount for account\r\n     */\r\n    function _unstake(address account, uint256 amount) internal {\r\n        require(_stakes[account].LP >= amount); // ensure sender has staked more than or equal to requested amount\r\n        \r\n        _realise(account); // realise staking gains\r\n        \r\n        // remove stake\r\n        _stakes[account].LP = _stakes[account].LP.sub(amount);\r\n        _totalLP = _totalLP.sub(amount);\r\n        \r\n        // send LP tokens back\r\n        _pair.transfer(account, amount);\r\n        \r\n        // check if sender is no longer a holder\r\n        updateHoldersUnstaked(account);\r\n        \r\n        emit Unstaked(account, amount);\r\n    }\r\n    \r\n    /**\r\n     * Distribute amount to stakers.\r\n     */\r\n    function distribute(uint256 amount) external {\r\n        _realise(msg.sender);\r\n        require(_balances[msg.sender] >= amount);\r\n        \r\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n        _distribute(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Distribute amount from account as transaction fee\r\n     */\r\n    function _distribute(address account, uint256 amount) internal {\r\n        _totalFees = _totalFees.add(amount);\r\n        emit FeesDistributed(account, amount);\r\n    }\r\n    \r\n    /**\r\n     * Check if account is holding in context of transaction sender\r\n     */\r\n    function updateHoldersTransferSender(address account) internal {\r\n        if(!isStillHolding(account)){ removeHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account is still holding in context of transaction recipient\r\n     */\r\n    function updateHoldersTransferRecipient(address account) internal {\r\n        if(!isHolder(account)){ addHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account is holding in context of staking tokens\r\n     */\r\n    function updateHoldersStaked(address account) internal {\r\n        if(!isHolder(account)){ addHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account is still holding in context of unstaking tokens\r\n     */\r\n    function updateHoldersUnstaked(address account) internal {\r\n        if(!isStillHolding(account)){ removeHolder(account); }\r\n    }\r\n    \r\n    /**\r\n     * Check if account has a balance or a stake\r\n     */\r\n    function isStillHolding(address account) internal view returns (bool) {\r\n        return balanceOf(account) > 0 || getStake(account) > 0;\r\n    }\r\n    \r\n    /**\r\n     * Require pair address to be set\r\n     */\r\n    modifier pairInitialized() { require(_pairInitialized); _; }\r\n    \r\n    /**\r\n     * Set the pair address.\r\n     * Don't allow changing whilst LP is staked (as this would prevent stakers getting their LP back)\r\n     */\r\n    function setPairAddress(address pair) external owned {\r\n        require(_totalLP == 0, \"Cannot change pair whilst there is LP staked\");\r\n        _pair = IBEP20(pair);\r\n        _pairInitialized = true;\r\n    }\r\n}\r\n\r\n/* > In contact with aliens */\r\n/* > They own Nanobot R&D labs around the world */\r\n/* > BOG governs exchanges & pools globally */\r\n\r\n/**\r\n * This contract burns tokens on transactions\r\n */\r\nabstract contract Burnable is BogDistributive {\r\n    using SafeMath for uint256;\r\n    \r\n    uint256 _burnRate = 50; // 5.0% of tx's to  be split between burn/distribute\r\n    uint256 _distributeRatio = 5; // 1:5 ratio of burn:distribute\r\n    uint256 _totalBurnt;\r\n    \r\n    /**\r\n     * Total amount of tokens burnt\r\n     */\r\n    function getTotalBurnt() external view returns (uint256) {\r\n        return _totalBurnt;\r\n    }\r\n    \r\n    /**\r\n     * Current burn rate\r\n     */\r\n    function getBurnRate() public view returns (uint256) {\r\n        return _burnRate;\r\n    }\r\n    \r\n    /**\r\n     * Current distribution ratio\r\n     */\r\n     function getDistributionRatio() public view returns (uint256) {\r\n         return _distributeRatio;\r\n     }\r\n    \r\n    /**\r\n     * Change to a new burn rate\r\n     */\r\n    function setBurnRate(uint256 newRate) external owned {\r\n        require(newRate < 100);\r\n        _burnRate = newRate;\r\n    }\r\n    \r\n    /**\r\n     * Change the burn:stakers distribution ratio\r\n     */\r\n    function setDistributionRatio(uint256 newRatio) external owned {\r\n        require(newRatio >= 1);\r\n        _distributeRatio = newRatio;\r\n    }\r\n    \r\n    /**\r\n     * Burns transaction amount as per burn rate & returns remaining transfer amount. \r\n     */\r\n    function _txBurn(address account, uint256 txAmount) internal returns (uint256) {\r\n        uint256 toBurn = txAmount.mul(_burnRate).div(1000); // calculate amount to burn\r\n        \r\n        _distribute(account, toBurn.mul(_distributeRatio-1).div(_distributeRatio));\r\n        _burn(account, toBurn.div(_distributeRatio));\r\n        \r\n        return txAmount.sub(toBurn); // return amount left after burn\r\n    }\r\n    \r\n    /**\r\n     * Burn amount tokens from sender\r\n     */\r\n    function burn(uint256 amount) public {\r\n        require(_balances[msg.sender] >= amount);\r\n        _burn(msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Burns amount of tokens from account\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        if(amount == 0){ return; }\r\n        \r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _totalBurnt = _totalBurnt.add(amount);\r\n        _balances[account] = _balances[account].sub(amount);\r\n        \r\n        emit Burn(account, amount);\r\n    }\r\n    \r\n    event Burn(address account, uint256 amount);\r\n}\r\n\r\n/* > They learned fluent French in under a week */\r\n/* > In reality, BOG is subject to the observer effect, existing in all blocks of every cryptocurrency ever created. */\r\n/* > You likely have Bogdabots inside you right now */\r\n\r\n/**\r\n * Implements high level functions\r\n */\r\nabstract contract BOG20 is IBOG20, Burnable, BogdabotController {\r\n    using SafeMath for uint256;\r\n    \r\n    uint32 _maxTxPercent = 50; // max size as % of supply as percentage to 1d.p, eg 50 = 5.0%\r\n    bool _firstTx = true; // flag for first tx (as this will be to provide liquidity so don't want limit)\r\n    \r\n    /**\r\n     * Mint tx sender with initial supply\r\n     */\r\n    constructor(uint256 supply) {\r\n        uint256 amount = supply * (10 ** _decimals);\r\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        updateHoldersTransferRecipient(msg.sender); // ensure receiver is set as sender\r\n        emit Transfer(address(0), msg.sender, amount);\r\n    }\r\n    \r\n    /**\r\n     * >Can I get a quick rundown?\r\n     */\r\n    function quickRundown(address account) external view override returns (uint256) {\r\n        return balanceOf(account);    \r\n    }\r\n    \r\n    /**\r\n     * funds are safu?\r\n     */\r\n    function fundsAreSafu() external pure override returns (bool) {\r\n        return true; // always ;)\r\n    }\r\n    \r\n    /**\r\n     * Return owner address as per BEP20 standard\r\n     */\r\n    function getOwner() external view override returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n     * Ensure tx size is within allowed % of supply\r\n     */\r\n    function checkTxAmount(uint256 amount) internal {\r\n        if(_firstTx){ _firstTx = amount == 0 ? true : false; return; } // skip first tx as this will be providing 100% as liquidity\r\n        require(amount <= _totalSupply.mul(_maxTxPercent).div(1000), \"Tx size exceeds limit\");\r\n    }\r\n    \r\n    /**\r\n     * Change the max tx size percent. Required to be from 1% to 100%\r\n     */\r\n    function setMaxTxPercent(uint32 amount) external owned {\r\n        require(amount > 10 && amount < 1000, \"Invalid max tx size\"); // ensure > 1% & < 100%\r\n        _maxTxPercent = amount;\r\n    }\r\n    \r\n    /**\r\n     * The transfer function. \r\n     * Normal transfer is also called through this and a sender==msg.sender check is used to determine whether to use allowance\r\n     */\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"Can't transfer from zero\");\r\n        require(recipient != address(0), \"Can't transfer to zero\");\r\n        \r\n        // ensure tx size is below limit\r\n        checkTxAmount(amount); \r\n        \r\n        // realise staked gains & then check if enough balance to cover\r\n        _realise(sender);\r\n        require(_balances[sender] >= amount, \"Not enough balance\");\r\n        \r\n        // require allowance if sender is not transaction creator\r\n        if(sender != msg.sender){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Not enough allowance\");\r\n        }\r\n        \r\n        // burn & distribute\r\n        uint256 sendAmt = _txBurn(sender, amount); \r\n        \r\n        // transfer\r\n        _balances[sender] = _balances[sender].sub(sendAmt);\r\n        _balances[recipient] = _balances[recipient].add(sendAmt);\r\n        \r\n        // update holders\r\n        updateHoldersTransferSender(sender);\r\n        updateHoldersTransferRecipient(recipient);\r\n        \r\n        // call any hooks\r\n        bogdabotTxHook(sender, recipient, amount);\r\n        \r\n        emit Transfer(sender, recipient, sendAmt);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Approve spender to spend amount from msg.sender\r\n     */\r\n    function _approve(address spender, uint256 amount) internal returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        return true;\r\n    }\r\n    \r\n    function heBought(address account, uint256 amount) external override { /* just for the IBOG20 meme */}\r\n    function heSold(address account, uint256 amount) external override { /* just for the IBOG20 meme */ }\r\n    \r\n    \r\n    /**\r\n     * Approve spender to spend amount from msg.sender\r\n     */\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        return _approve(spender, amount);\r\n    }\r\n    \r\n    /**\r\n     * Transfer from msg.sender to recipient for amount\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n         return _transferFrom(msg.sender, recipient, amount);\r\n     }\r\n\r\n    /**\r\n     * Transfer amount from sender to recipient so long as msg.sender has at least amount allowance\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n    \r\n    /**\r\n     * Bulk execute transfers\r\n     */\r\n    function multiTransfer(address[] memory accounts, uint256[] memory amounts) external {\r\n        require(accounts.length == amounts.length, \"Accounts & amounts must be same length\");\r\n        for(uint256 i=0; i<accounts.length; i++){\r\n            _transferFrom(msg.sender, accounts[i], amounts[i]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Will you take the Bogpill?\r\n */\r\ncontract BoggedFinance is BOG20, RecordsCreation {\r\n    using SafeMath for uint256;\r\n    \r\n    constructor() BOG20(2500000) {\r\n        _name = \"Bogged Finance\";\r\n        _symbol = \"BOG\";\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"}],\"name\":\"addBogdabot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceUnstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsAreSafu\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBotCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBots\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributionRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHolders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHoldersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUnrealisedEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"heBought\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"heSold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"isHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"quickRundown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"realise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"}],\"name\":\"removeBogdabot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setBurnRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRatio\",\"type\":\"uint256\"}],\"name\":\"setDistributionRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"amount\",\"type\":\"uint32\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BoggedFinance", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://21090a7080e27c6e0415bd6ff4122ed57b15d2e306e411ebe1cf44898cb0385a"}