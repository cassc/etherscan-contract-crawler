{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint256);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _owner = address(0x9A5968F5aFdF74937E9D0546ea587868F0336e0c);\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenDistributor {\r\n    address public _owner;\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n    function claimToken(address token, address to, uint256 amount) external {\r\n        require(msg.sender == _owner);\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n}\r\n\r\ninterface ISwapPair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\ncontract KCAL is IERC20, Ownable {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    address public fundAddress = address(0xA014cE43aDF8cfaDbbA18Da4c5f8454107428Cf2);\r\n\r\n    string private _name = \"KCAL\";\r\n    string private _symbol = \"KCAL\";\r\n    uint256 private _decimals = 18;\r\n\r\n\r\n    mapping(address => bool) public _feeWhiteList;\r\n\r\n    uint256 private _tTotal = 100_000_000 *10**_decimals;\r\n    uint256 public mineRate = 60;\r\n    address public routerAddress = address(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    ISwapRouter public _swapRouter;\r\n    address public BETH = address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n\r\n    address public deadAddress = address(0x000000000000000000000000000000000000dEaD);\r\n    mapping(address => bool) public _swapPairList;\r\n\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    TokenDistributor public mineRewardDistributor;\r\n    \r\n    uint256 public _buyFundFee = 100;\r\n    uint256 public sell_burnFee = 200;\r\n    uint256 public addLiquidityFee = 250;\r\n    uint256 public removeLiquidityFee = 250;\r\n\r\n    mapping(address => address) public _inviter;\r\n    mapping(address => address[]) public _binders;\r\n    mapping(address => mapping(address => bool)) public _maybeInvitor;\r\n\r\n\r\n    uint256 public startTradeTime;\r\n\r\n    mapping(address => uint256) public _userLPAmount;\r\n    address public _lastMaybeAddLPAddress;\r\n    uint256 public _lastMaybeAddLPAmount;\r\n\r\n    address[] public lpProviders;\r\n    mapping(address => uint256) public lpProviderIndex;\r\n    mapping(address => bool) public excludeLpProvider;\r\n\r\n    mapping(address => uint256) public mineReward;\r\n    mapping(address => uint256) public invitorReward;\r\n\r\n\r\n\r\n    uint256 public oneLPNum = 20*10**_decimals;\r\n    uint256 public twoLPNum = 40*10**_decimals;\r\n    uint256 public threeLPNum = 100*10**_decimals;\r\n    uint256 public fourLPNum = 200*10**_decimals;\r\n    uint256 public fiveLPNum = 600*10**_decimals;\r\n\r\n\r\n    uint256 public oneInvitorReward = 500 *10**_decimals;\r\n    uint256 public twoInvitorReward = 1000 *10**_decimals;\r\n    uint256 public threeInvitorReward = 2000 *10**_decimals;\r\n    uint256 public fourInvitorReward = 4000 *10**_decimals;\r\n\r\n    uint256 public _currentMineLPIndex;\r\n    uint256 public _progressMineLPBlock;\r\n    uint256 public _progressMineLPBlockDebt = 5;\r\n    mapping(address => uint256) public _lastMineLPRewardTimes;\r\n\r\n    uint256 public _mineTimeDebt = 7 days;\r\n    bool public isMining = true;\r\n\r\n    uint256 public lastCycleTimestamp;\r\n    uint256 public cycleTimeDebt = 90 days;\r\n    uint256 public cycleAmount;\r\n    uint256 public cycleMineAmount;\r\n    uint256 public cycleInvitorAmount;\r\n\r\n    uint256 public lastEachTimestamp;\r\n    uint256 public eachMineAmount;\r\n    uint256 public eachInvitorAmount;\r\n    uint256 public eachInvitorMin = 10**_decimals;\r\n    uint256 public MinerMin = 10**_decimals;\r\n\r\n    address public _mainPair;\r\n    address[] public rewardPath;\r\n    bool private inSwap;\r\n\r\n    modifier lockTheSwap() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n    constructor() {\r\n\r\n        rewardPath = [address(this), BETH];\r\n        _swapRouter = ISwapRouter(routerAddress);\r\n        IERC20(BETH).approve(address(_swapRouter), MAX);\r\n\r\n        _allowances[address(this)][address(_swapRouter)] = MAX;\r\n\r\n        ISwapFactory swapFactory = ISwapFactory(_swapRouter.factory());\r\n        _mainPair = swapFactory.createPair(address(this), BETH);\r\n\r\n        _swapPairList[_mainPair] = true;\r\n\r\n        mineRewardDistributor = new TokenDistributor();\r\n\r\n\r\n        uint256 _mineTotal = _tTotal * mineRate / 100;\r\n        _balances[address(mineRewardDistributor)] = _mineTotal;\r\n        emit Transfer(address(0), address(mineRewardDistributor), _mineTotal);\r\n\r\n        uint256 ReceiveAddress1Amount = 5_190_000 *10**_decimals;\r\n        address ReceiveAddress1 = address(0xde58d48Ebc6b388dF87F4cAeFf85561e91D0888e);\r\n        _balances[ReceiveAddress1] = ReceiveAddress1Amount;\r\n        emit Transfer(address(0), ReceiveAddress1, ReceiveAddress1Amount);\r\n        uint256 liquidityTotal = _tTotal - _mineTotal - ReceiveAddress1Amount;\r\n        address ReceiveAddress2 = address(0x503F5ED458925c13676051F5aC0e3975FcA780A3);\r\n        _balances[ReceiveAddress2] = liquidityTotal;\r\n        emit Transfer(address(0), ReceiveAddress2, liquidityTotal);\r\n\r\n        _feeWhiteList[ReceiveAddress1] = true;\r\n        _feeWhiteList[ReceiveAddress2] = true;\r\n        _feeWhiteList[address(this)] = true;\r\n        // _feeWhiteList[address(_swapRouter)] = true;\r\n        _feeWhiteList[msg.sender] = true;\r\n        _feeWhiteList[address(0x000000000000000000000000000000000000dEaD)] = true;\r\n        _feeWhiteList[address(0)] = true;\r\n        _feeWhiteList[address(mineRewardDistributor)] = true;        \r\n\r\n        excludeLpProvider[address(0)] = true;\r\n        excludeLpProvider[address(0x000000000000000000000000000000000000dEaD)] = true;\r\n        _addLpProvider(fundAddress);\r\n\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function decimals() external view override returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public override returns (bool)  {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        if (_allowances[sender][msg.sender] != MAX) {\r\n            _allowances[sender][msg.sender] =\r\n                _allowances[sender][msg.sender] -\r\n                amount;\r\n            \r\n        }\r\n        return true;\r\n        \r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n     function _isAddLiquidity() internal view returns (bool isAdd) {\r\n        ISwapPair mainPair = ISwapPair(_mainPair);\r\n        (uint r0, uint256 r1, ) = mainPair.getReserves();\r\n\r\n        address tokenOther = BETH;\r\n        uint256 r;\r\n        if (tokenOther < address(this)) {\r\n            r = r0;\r\n        } else {\r\n            r = r1;\r\n        }\r\n\r\n        uint bal = IERC20(tokenOther).balanceOf(address(mainPair));\r\n        isAdd = bal > r;\r\n    }\r\n\r\n    function _isRemoveLiquidity() internal view returns (bool isRemove) {\r\n        ISwapPair mainPair = ISwapPair(_mainPair);\r\n        (uint r0, uint256 r1, ) = mainPair.getReserves();\r\n\r\n        address tokenOther = BETH;\r\n        uint256 r;\r\n        if (tokenOther < address(this)) {\r\n            r = r0;\r\n        } else {\r\n            r = r1;\r\n        }\r\n\r\n        uint bal = IERC20(tokenOther).balanceOf(address(mainPair));\r\n        isRemove = r >= bal;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(balanceOf(from) >= amount);\r\n        address lastMaybeAddLPAddress = _lastMaybeAddLPAddress;\r\n        if (lastMaybeAddLPAddress != address(0)) {\r\n            _lastMaybeAddLPAddress = address(0);\r\n            uint256 lpBalance = IERC20(_mainPair).balanceOf(lastMaybeAddLPAddress);\r\n            if (lpBalance > 0) {\r\n                uint256 lpAmount = _userLPAmount[lastMaybeAddLPAddress];\r\n                if (lpBalance > lpAmount) {\r\n                    uint256 debtAmount = lpBalance - lpAmount;\r\n                    uint256 maxDebtAmount = _lastMaybeAddLPAmount * IERC20(_mainPair).totalSupply() / _balances[_mainPair];\r\n                    if (debtAmount > maxDebtAmount) {\r\n                        excludeLpProvider[lastMaybeAddLPAddress] = true;\r\n                    } else {\r\n                        _addLpProvider(lastMaybeAddLPAddress);\r\n                        _userLPAmount[lastMaybeAddLPAddress] = lpBalance;\r\n                        if (_lastMineLPRewardTimes[lastMaybeAddLPAddress] == 0) {\r\n                            _lastMineLPRewardTimes[lastMaybeAddLPAddress] = block.timestamp;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        bool takeFee;\r\n        bool isSell;\r\n        bool isRemove;\r\n        bool isAdd;\r\n\r\n\r\n        if (_swapPairList[from] || _swapPairList[to]) {\r\n            if (_swapPairList[to]) {\r\n            isAdd = _isAddLiquidity();\r\n            isSell = true;\r\n\r\n            }\r\n            if (_swapPairList[from]) {\r\n                isRemove = _isRemoveLiquidity();\r\n\r\n            }\r\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\r\n                require(block.timestamp > startTradeTime || isAdd);\r\n                if (_swapPairList[to]) {\r\n                    if (!inSwap && !isAdd) {\r\n                        uint256 contractTokenBalance = balanceOf(address(this));\r\n                        if (contractTokenBalance > 0) {\r\n                            uint256 numTokensSellToFund = (amount * _buyFundFee) /\r\n                                5000;\r\n                            if (numTokensSellToFund > contractTokenBalance) {\r\n                                numTokensSellToFund = contractTokenBalance;\r\n                            }\r\n                            swapTokenForFund(numTokensSellToFund);\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                if (!isAdd && !isRemove) takeFee = true; // just swap fee\r\n            }\r\n        }else {\r\n            if (_inviter[to] == address(0) && amount > 0 && from != to) {\r\n                _maybeInvitor[to][from] = true;\r\n            }\r\n            if (_inviter[from] == address(0) && amount > 0 && from != to) {\r\n                if (_maybeInvitor[from][to] && _binders[from].length == 0) {\r\n                    _bindInvitor(from, to);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isRemove) {\r\n            if (!_feeWhiteList[to] && isMining) {\r\n                // takeFee = true;\r\n                uint256 liquidity = (amount * ISwapPair(_mainPair).totalSupply() + 1) / (balanceOf(_mainPair) - 1);\r\n                // if (from != address(_swapRouter)) {\r\n                //     liquidity = (amount * ISwapPair(_mainPair).totalSupply() + 1) / (balanceOf(_mainPair) - amount - 1);\r\n                // } \r\n                require(_userLPAmount[to] >= liquidity);\r\n                _userLPAmount[to] -= liquidity;\r\n            }\r\n        }\r\n\r\n\r\n        _tokenTransfer(\r\n            from,\r\n            to,\r\n            amount,\r\n            takeFee,\r\n            isSell,\r\n            isRemove,\r\n            isAdd\r\n        );\r\n\r\n        if (from != address(this) && isMining) {\r\n            if (isSell) {\r\n                _lastMaybeAddLPAddress = from;\r\n                _lastMaybeAddLPAmount = amount;\r\n            }\r\n            if (!_feeWhiteList[from] && !isAdd ) {\r\n                updateMineCycle();\r\n                processMineLP(500000);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount,\r\n        bool takeFee,\r\n        bool isSell,\r\n        bool isRemove,\r\n        bool isAdd\r\n    ) private {\r\n        _balances[sender] = _balances[sender] - tAmount;\r\n        uint256 feeAmount;\r\n\r\n        if (takeFee) {\r\n            if (isSell) {\r\n                uint256 sellBurnAmount = tAmount * sell_burnFee /10000;\r\n                feeAmount += sellBurnAmount;\r\n                _takeTransfer(sender, deadAddress, sellBurnAmount);\r\n\r\n            } else {\r\n                uint256 buyFundAmount = tAmount * _buyFundFee/10000; \r\n                feeAmount += buyFundAmount;\r\n                _takeTransfer(sender, address(this), buyFundAmount);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        if (isRemove && !_feeWhiteList[recipient]) {\r\n            uint256 removeLiquidityFeeAmount;\r\n            removeLiquidityFeeAmount = (tAmount * removeLiquidityFee) / 10000;\r\n\r\n            \r\n            feeAmount += removeLiquidityFeeAmount;\r\n            _takeTransfer(sender, address(fundAddress), removeLiquidityFeeAmount);\r\n            \r\n        }\r\n        if (isAdd && !_feeWhiteList[sender]) {\r\n            uint256 addLiquidityFeeAmount;\r\n            addLiquidityFeeAmount = (tAmount * addLiquidityFee) / 10000;\r\n\r\n            feeAmount += addLiquidityFeeAmount;\r\n            _takeTransfer(sender, address(fundAddress), addLiquidityFeeAmount);\r\n\r\n        }\r\n\r\n        _takeTransfer(sender, recipient, tAmount - feeAmount);\r\n    }\r\n\r\n    function _takeTransfer(\r\n        address sender,\r\n        address to,\r\n        uint256 tAmount\r\n    ) private {\r\n        _balances[to] = _balances[to] + tAmount;\r\n        emit Transfer(sender, to, tAmount);\r\n    }\r\n\r\n    event Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 value\r\n    );\r\n    \r\n    function swapTokenForFund(\r\n        uint256 tokenAmount\r\n    ) private lockTheSwap {\r\n\r\n\r\n        try\r\n                _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                    tokenAmount,\r\n                    0,\r\n                    rewardPath,\r\n                    fundAddress,\r\n                    block.timestamp\r\n                )\r\n            {} catch {\r\n                emit Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens(1);\r\n            }\r\n        \r\n    }\r\n\r\n    function _bindInvitor(address account, address invitor) private  returns(bool) {\r\n        if (invitor != address(0) && invitor != account && _inviter[account] == address(0)) {\r\n            uint256 size;\r\n            assembly {size := extcodesize(invitor)}\r\n            if (size > 0) {\r\n                return false ;\r\n            }else{\r\n                _inviter[account] = invitor;\r\n                _binders[invitor].push(account);\r\n                \r\n                return true;\r\n            }\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getBinderLength(address account) external view returns (uint256){\r\n        return _binders[account].length;\r\n    }\r\n\r\n    function setLaunchTime(uint256 launchTime) external onlyOwner {\r\n        require(0 == startTradeTime);\r\n        startTradeTime = launchTime;\r\n    }\r\n\r\n\r\n    \r\n    event Received(address sender, uint256 amount);\r\n    event Sended(address sender, address to,uint256 amount);\r\n    receive() external payable {\r\n        uint256 receivedAmount = msg.value;\r\n        emit Received(msg.sender, receivedAmount);\r\n    }\r\n\r\n\r\n\r\n    function setFundAddress(address addr) external onlyOwner {\r\n        fundAddress = addr;\r\n        _feeWhiteList[addr] = true;\r\n        _addLpProvider(addr);\r\n    }\r\n\r\n\r\n    function setFeeWhiteList(\r\n        address[] calldata addr,\r\n        bool enable\r\n    ) public onlyOwner {\r\n        for (uint256 i = 0; i < addr.length; i++) {\r\n            _feeWhiteList[addr[i]] = enable;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function setSwapPairList(address addr, bool enable) external onlyOwner {\r\n        _swapPairList[addr] = enable;\r\n    }\r\n\r\n    function claimBalance() external onlyOwner {\r\n        payable(fundAddress).transfer(address(this).balance);\r\n    }\r\n\r\n    function claimToken(\r\n        address token,\r\n        uint256 amount,\r\n        address to\r\n    ) external  {\r\n        require(fundAddress == msg.sender);\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n\r\n    function claimContractToken(address contractAddress, address token, uint256 amount) external {\r\n        require(fundAddress == msg.sender);\r\n        TokenDistributor(contractAddress).claimToken(token, fundAddress, amount);\r\n    }\r\n\r\n\r\n    function getLPProviderLength() public view returns (uint256){\r\n        return lpProviders.length;\r\n    }\r\n\r\n    function _addLpProvider(address adr) private {\r\n        if (0 == lpProviderIndex[adr]) {\r\n            if (0 == lpProviders.length || lpProviders[0] != adr) {\r\n                uint256 size;\r\n                assembly {size := extcodesize(adr)}\r\n                if (size > 0) {\r\n                    return;\r\n                }\r\n                lpProviderIndex[adr] = lpProviders.length;\r\n                lpProviders.push(adr);\r\n            }\r\n        }\r\n    }\r\n    function checkLowerCount(address account) view private returns(uint256 lowerHoldCount,uint256 lowerLPCount ){\r\n        uint256 lowerCount =  _binders[account].length;\r\n        for (uint256 i; i < lowerCount; ++i) {\r\n            address lowAddress = _binders[account][i];\r\n            uint256 pairBalance = IERC20(_mainPair).balanceOf(lowAddress);\r\n            if(_balances[lowAddress] >= 100*10**_decimals){\r\n                lowerHoldCount +=1;\r\n                if(pairBalance >= 10**15){\r\n                    lowerLPCount +=1;\r\n                }\r\n\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    function checkMineLv(address account) public view returns(uint8){\r\n        uint256 accLPBalance = IERC20(_mainPair).balanceOf(account);\r\n        (uint256 lowerHoldCount,uint256 lowerLPCount) = checkLowerCount(account);\r\n        if(accLPBalance >= fiveLPNum && lowerHoldCount>=6 && lowerLPCount>= 5){\r\n            return 5;\r\n\r\n        }\r\n        else if(accLPBalance >= fourLPNum && lowerHoldCount>=5 && lowerLPCount>= 4){\r\n            return 4;\r\n\r\n        }\r\n        else if(accLPBalance >= threeLPNum && lowerHoldCount>=4 && lowerLPCount>= 3){\r\n            return 3;\r\n\r\n        }\r\n        else if(accLPBalance >= twoLPNum && lowerHoldCount>=3 && lowerLPCount>= 2){\r\n            return 2;\r\n\r\n        }\r\n        else if(accLPBalance >= oneLPNum && lowerHoldCount>=2 && lowerLPCount>= 1){\r\n            return 1;\r\n\r\n        }else{\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function processMineLP(uint256 gas) private {\r\n\r\n        if (_progressMineLPBlock + _progressMineLPBlockDebt > block.number) {\r\n            return;\r\n        }\r\n\r\n\r\n        uint totalPair = IERC20(_mainPair).totalSupply();\r\n        if (0 == totalPair) {\r\n            return;\r\n        }\r\n        address sender = address(mineRewardDistributor);\r\n\r\n        if (_balances[sender] < MinerMin) { \r\n            return;\r\n        }\r\n\r\n        address shareHolder;\r\n        uint256 pairBalance;\r\n        uint256 lpAmount;\r\n        uint256 amount;\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 iterations = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n\r\n        while (gasUsed < gas && iterations < lpProviders.length) {\r\n            if (_currentMineLPIndex >= lpProviders.length) {\r\n                _currentMineLPIndex = 0;\r\n            }\r\n            shareHolder = lpProviders[_currentMineLPIndex];\r\n            if (!excludeLpProvider[shareHolder]) {\r\n                pairBalance = IERC20(_mainPair).balanceOf(shareHolder);\r\n                lpAmount = _userLPAmount[shareHolder];\r\n                if (lpAmount < pairBalance) {\r\n                    pairBalance = lpAmount;\r\n                }\r\n\r\n                if (block.timestamp > _lastMineLPRewardTimes[shareHolder] + _mineTimeDebt) {\r\n                    amount = eachMineAmount * pairBalance / totalPair;\r\n                    \r\n                    if (amount > 0) {\r\n                        mineReward[shareHolder] += amount;\r\n                        procesInvitorReward(shareHolder,amount);\r\n                        _lastMineLPRewardTimes[shareHolder] = block.timestamp;\r\n                    }\r\n                    \r\n\r\n                }\r\n            }\r\n\r\n            gasUsed = gasUsed + (gasLeft - gasleft());\r\n            gasLeft = gasleft();\r\n            _currentMineLPIndex++;\r\n            iterations++;\r\n        }\r\n        \r\n        _progressMineLPBlock = block.number;\r\n        \r\n    }\r\n\r\n    function updateMineCycle() private {\r\n\r\n        if(block.timestamp > lastCycleTimestamp + cycleTimeDebt ){\r\n            cycleAmount = _balances[address(mineRewardDistributor)] / 10;\r\n            cycleMineAmount = cycleAmount * 6 /10;\r\n            cycleInvitorAmount = cycleAmount - cycleMineAmount;\r\n            lastCycleTimestamp = block.timestamp;\r\n        }\r\n\r\n        if(block.timestamp > lastEachTimestamp + _mineTimeDebt ){\r\n            eachMineAmount = cycleMineAmount /13;\r\n            eachInvitorAmount = cycleInvitorAmount/13;\r\n            lastEachTimestamp = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function manuallyUpdateCycle() external {\r\n        require(fundAddress == msg.sender);\r\n        cycleAmount = _balances[address(mineRewardDistributor)]  / 10;\r\n        cycleMineAmount = cycleAmount * 6 /10;\r\n        cycleInvitorAmount = cycleAmount - cycleMineAmount;\r\n        lastCycleTimestamp = block.timestamp;\r\n    }\r\n    function manuallyUpdateEach() external {\r\n        require(fundAddress == msg.sender);\r\n        eachMineAmount = cycleMineAmount /13;\r\n        eachInvitorAmount = cycleInvitorAmount/13;\r\n        lastEachTimestamp = block.timestamp;\r\n    }\r\n    function setEachInvitorAmount(uint256 eachAmount) external  {\r\n        require(fundAddress == msg.sender);\r\n        eachInvitorAmount = eachAmount;\r\n    }\r\n    function setMining(bool enable) external  {\r\n        require(fundAddress == msg.sender);\r\n        isMining = enable;\r\n    }\r\n    function procesInvitorReward(address current, uint256 reward) private {\r\n\r\n        for (uint256 i; i < 5;i++) {\r\n            address invitor = _inviter[current];\r\n            uint256 invitorAmount;\r\n            uint8 invitorLv = checkMineLv(invitor);\r\n            if (address(0) == invitor || deadAddress == invitor || eachInvitorAmount < eachInvitorMin) {\r\n                break;\r\n            }\r\n\r\n            if (i ==0){\r\n                if (invitorLv > 0){\r\n                    invitorAmount = reward * 20 / 100;\r\n                    \r\n                }else{\r\n                    invitorAmount = 0;\r\n                }\r\n            }else if(i ==1){\r\n                if (invitorLv > 1){\r\n                    invitorAmount = reward * 10 / 100;\r\n                }else{\r\n                    invitorAmount = 0;\r\n                }        \r\n            }else if(i ==2){\r\n                if (invitorLv > 2){\r\n                    invitorAmount = reward * 5 / 100;\r\n                }else{\r\n                    invitorAmount = 0;\r\n                }\r\n\r\n            \r\n            }else if(i ==3){\r\n                if (invitorLv > 3){\r\n                    invitorAmount = reward * 2 / 100;\r\n                }else{\r\n                    invitorAmount = 0;\r\n                }\r\n\r\n            }else {\r\n                if (invitorLv > 4){\r\n                    invitorAmount = reward * 1 / 100;\r\n                }else{\r\n                    invitorAmount = 0;\r\n                }\r\n            }\r\n\r\n\r\n            if(invitorAmount >0){\r\n\r\n                if(eachInvitorAmount - invitorAmount>0){\r\n                    invitorReward[invitor] += invitorAmount;\r\n                    eachInvitorAmount -= invitorAmount;\r\n                    procesUpInvitorReward(invitor,invitorAmount);\r\n\r\n                    \r\n                }else{\r\n                    break;\r\n                }\r\n\r\n\r\n            }\r\n\r\n            current = invitor;\r\n\r\n        }\r\n\r\n    }\r\n    function procesUpInvitorReward(address current, uint256 reward) private {\r\n        address invitor;\r\n        uint256 invitorAmount;\r\n\r\n        for (uint256 i; i < 5;i++) {\r\n            invitor = _inviter[current];\r\n            uint8 invitorLv = checkMineLv(invitor);\r\n            \r\n            if (address(0) == invitor || deadAddress == invitor || eachInvitorAmount < eachInvitorMin ||invitorLv ==0) {\r\n                break;\r\n            }\r\n            \r\n            if(invitorLv == 1){\r\n                invitorAmount = reward * 5 / 100;\r\n\r\n            }\r\n            else if(invitorLv == 2){\r\n                invitorAmount = reward * 10 / 100;\r\n\r\n            }\r\n            else if(invitorLv == 3){\r\n                invitorAmount = reward * 15 / 100;\r\n\r\n            }\r\n            else if(invitorLv == 4){\r\n                invitorAmount = reward * 20 / 100;\r\n\r\n            }else{\r\n                invitorAmount = reward * 30 / 100;\r\n            }\r\n            \r\n            if(eachInvitorAmount - invitorAmount > 0){\r\n                invitorReward[invitor] += invitorAmount;\r\n                eachInvitorAmount -= invitorAmount;\r\n                reward = invitorAmount;\r\n                current = invitor;\r\n\r\n            }else{\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function getMineReward()external{\r\n        uint256 totalMineReward = mineReward[msg.sender];\r\n        require(totalMineReward > 0);\r\n        address sender = address(mineRewardDistributor);\r\n        uint256 techAmount = totalMineReward * 3/100;\r\n        mineReward[msg.sender] = 0;\r\n        TokenDistributor(sender).claimToken(address(this), fundAddress, techAmount);\r\n        TokenDistributor(sender).claimToken(address(this), msg.sender, totalMineReward - techAmount);\r\n        \r\n    }\r\n    function getInvitorReward()external{\r\n        uint256 totalInvitorReward = invitorReward[msg.sender];\r\n        uint256 availableInvitorReward;\r\n        require(totalInvitorReward > 0);\r\n        address sender = address(mineRewardDistributor);\r\n        uint8 accountrLv = checkMineLv(msg.sender);\r\n        if(accountrLv == 0){\r\n            availableInvitorReward = 0;\r\n            invitorReward[msg.sender] = 0;\r\n        }\r\n        else if(accountrLv == 1){\r\n            if(totalInvitorReward > oneInvitorReward){\r\n                availableInvitorReward = oneInvitorReward;\r\n            }else{\r\n                availableInvitorReward = totalInvitorReward;\r\n            }\r\n\r\n        }\r\n        else if(accountrLv == 2){\r\n            if(totalInvitorReward > twoInvitorReward){\r\n                availableInvitorReward = twoInvitorReward;\r\n            }else{\r\n                availableInvitorReward = totalInvitorReward;\r\n            }\r\n\r\n        }\r\n        else if(accountrLv == 3){\r\n            if(totalInvitorReward > threeInvitorReward){\r\n                availableInvitorReward = threeInvitorReward;\r\n            }else{\r\n                availableInvitorReward = totalInvitorReward;\r\n            }\r\n        }else if(accountrLv == 4){\r\n            if(totalInvitorReward > fourInvitorReward){\r\n                availableInvitorReward = fourInvitorReward;\r\n            }else{\r\n                availableInvitorReward = totalInvitorReward;\r\n            }\r\n\r\n        }else{\r\n            availableInvitorReward = totalInvitorReward;\r\n            \r\n        }\r\n\r\n        if(availableInvitorReward >0){\r\n            uint256 techAmount = availableInvitorReward * 10 / 100;\r\n            invitorReward[msg.sender] = 0;\r\n            TokenDistributor(sender).claimToken(address(this), deadAddress, techAmount);\r\n            TokenDistributor(sender).claimToken(address(this), msg.sender, availableInvitorReward - techAmount);\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    function setExcludeLPProvider(address addr, bool enable) external  {\r\n        require(fundAddress == msg.sender);\r\n        excludeLpProvider[addr] = enable;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MinerMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_binders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_currentMineLPIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastMaybeAddLPAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastMaybeAddLPAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lastMineLPRewardTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_maybeInvitor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mineTimeDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_progressMineLPBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_progressMineLPBlockDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userLPAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"checkMineLv\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleInvitorAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleMineAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleTimeDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eachInvitorAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eachInvitorMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eachMineAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludeLpProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fiveLPNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fourInvitorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fourLPNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBinderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInvitorReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPProviderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMineReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"invitorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMining\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCycleTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEachTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpProviderIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manuallyUpdateCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manuallyUpdateEach\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mineRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mineReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mineRewardDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneInvitorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneLPNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPath\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eachAmount\",\"type\":\"uint256\"}],\"name\":\"setEachInvitorAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setExcludeLPProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"launchTime\",\"type\":\"uint256\"}],\"name\":\"setLaunchTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setMining\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threeInvitorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threeLPNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoInvitorReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoLPNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KCAL", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b7a44b2853b6b50a910ada0b99414d5fc4a85351bd19a2f9427ff4cd57c24916"}