{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-0.8/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-0.8/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-0.8/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-0.8/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GaugeVoting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport '@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts-0.8/token/ERC20/extensions/IERC20Metadata.sol';\\nimport \\\"@openzeppelin/contracts-0.8/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts-0.8/security/Pausable.sol\\\";\\n\\nimport \\\"./libraries/SafeCast.sol\\\";\\n\\ninterface VotingEscrow {\\n    function userInfo(address user) external view returns (\\n        address, // cakePoolProxy\\n        uint128, // cakeAmount\\n        uint48, // lockEndTime\\n        uint48, // migrationTime\\n        uint16, // cakePoolType\\n        uint16  // withdrawFlag\\n    );\\n\\n    function locks(address addr) external view returns (int128, uint256);\\n\\n    function totalSupplyAtTime(uint256 _timestamp) external view returns (uint256);\\n}\\n\\ncontract GaugeVoting is Ownable, Pausable {\\n\\n    address public immutable votingEscrow; // Voting escrow\\n\\n    /// @dev 7 * 86400 seconds - all future times are rounded by week\\n    uint256 constant WEEK = 604800;\\n    /// @dev Period for the maximum lock\\n    uint256 constant MAX_LOCK_TIME = 126403199;\\n    /// @dev Add 2 weeks time to calculate actual 2 weeks epoch\\n    uint256 constant TWOWEEK = WEEK*2;\\n    /// @dev Cannot change weight votes more often than once in 10 days\\n    uint256 public WEIGHT_VOTE_DELAY;\\n    /// @dev Period for admin adjusting only\\n    uint256 public ADMIN_VOTE_PERIOD;\\n\\n    struct GaugeInfo {\\n        uint256 pid;\\n        address masterChef;\\n        uint256 chainId;\\n        address pairAddress;\\n        uint256 boostMultiplier;\\n        uint256 maxVoteCap;\\n    }\\n\\n    struct Point {\\n        uint256 bias;\\n        uint256 slope;\\n    }\\n\\n    struct VotedSlope {\\n        uint256 slope;\\n        uint256 power;\\n        uint256 end;\\n    }\\n\\n    uint256 constant MULTIPLIER = 10**18;\\n\\n    uint256 constant BOOST_PRECISION = 100;\\n    uint256 constant CAP_PRECISION = 10000;\\n\\n    /// @notice Gauge parameters\\n    /// @dev All numbers are \\\"fixed point\\\" on the bias of 1e18\\n    uint256 public gaugeTypes;\\n    uint256 public gaugeCount;\\n    mapping(uint256 => string) public gaugeTypeNames;\\n\\n    /// @notice Needed for enumeration\\n    GaugeInfo[1000000000] public gauges;\\n    mapping(bytes32 => uint256) public gaugeIndex_;\\n    /// @dev we increment values by 1 prior to storing them here so we can rely on a value\\n    /// of zero as meaning the gauge has not been set\\n    mapping(bytes32 => uint256) public gaugeTypes_;\\n    /// @dev record gauge is available for voting or not\\n    mapping(bytes32 => bool) public gaugeIsKilled_;\\n\\n    /// @dev user -> gauge_hash -> VotedSlope\\n    mapping(address => mapping(bytes32 => VotedSlope)) public voteUserSlopes;\\n    /// @dev Total vote power used by user\\n    mapping(address => uint256) public voteUserPower;\\n    /// @dev Last user vote's timestamp for each gauge hash\\n    mapping(address => mapping(bytes32 => uint256)) public lastUserVote;\\n\\n    /// @dev Admin total slope time -> Point\\n    mapping(uint256 => uint256) public adminSlopes;\\n\\n    /// @dev Admin vote total / division\\n    uint256 public adminAllocation;\\n\\n    /// @notice Past and scheduled points for gauge weight, sum of weights per type, total weight\\n    /// Point is for bias+slope\\n    /// changes_* are for changes in slope\\n    /// time_* are for the last change timestamp\\n    /// timestamps are rounded to whole weeks\\n\\n    /// @dev gauge_hash -> time -> Point\\n    mapping(bytes32 => mapping(uint256 => Point)) public gaugePointsWeight;\\n    /// @dev gauge_hash -> time -> slope\\n    mapping(bytes32 => mapping(uint256 => uint256)) public gaugeChangesWeight;\\n    /// @dev gauge_hash -> last scheduled time (next 2 weeks)\\n    mapping(bytes32 => uint256) public gaugeLastScheduled;\\n\\n    /// @dev type_id -> time -> Point\\n    mapping(uint256 => mapping(uint256 => Point)) public gaugeTypePointsSum;\\n    /// @dev type_id -> time -> slope\\n    mapping(uint256 => mapping(uint256 => uint256)) public gaugeTypeChangesSum;\\n    /// @dev type_id -> last scheduled time (next 2 weeks)\\n    uint256[1000000000] public gaugeTypeSumLastScheduled;\\n\\n    /// @dev time -> total weight\\n    mapping(uint256 => uint256) public gaugePointsTotal;\\n    /// @dev last scheduled time\\n    uint256 public totalLastScheduled;\\n\\n    /// @dev type_id -> time -> type weight\\n    mapping(uint256 => mapping(uint256 => uint256)) public gaugeTypePointsWeight;\\n    /// @dev type_id -> last scheduled time (next 2 weeks)\\n    uint256[1000000000] public gaugeTypeLastScheduled;\\n\\n    event AdminAllocationChanged(address indexed sender, uint256 allocation);\\n    event WeightVoteDelayChanged(address indexed sender, uint256 delay);\\n    event AddType(string name, uint256 type_id);\\n    event NewGauge(bytes32 hash, uint256 gauge_type, uint256 weight, uint256 pid, address masterChef, uint256 chainId, uint256 boostMultiplier, uint256 maxVoteCap);\\n    event UpdateGaugeInfo(bytes32 hash, uint256 pid, address masterChef, uint256 chainId, uint256 boostMultiplier, uint256 maxVoteCap);\\n    event NewTypeWeight(uint256 type_id, uint256 time, uint256 weight, uint256 total_weight);\\n    event NewGaugeWeight(bytes32 hash, uint256 time, uint256 weight, uint256 total_weight);\\n    event VoteForGauge(uint256 time, address user, bytes32 hash, uint256 weight);\\n    event VoteForGaugeFromAdmin(uint256 time, address user, bytes32 hash, uint256 weight);\\n    event GaugeKilled(address indexed sender, address indexed gauage_addr, uint256 chainId, bytes32 hash);\\n    event GaugeUnKilled(address indexed sender, address indexed gauage_addr, uint256 chainId, bytes32 hash);\\n    event AdminOnlyPeriodUpdated(address indexed sender, uint256 period);\\n\\n    /// @notice Contract constructor\\n    /// @param _votingEscrow `VotingEscrow` contract address\\n    constructor(address _votingEscrow) {\\n        require(_votingEscrow != address(0), \\\"Invalid voting escrow address\\\");\\n        votingEscrow = _votingEscrow;\\n        totalLastScheduled = block.timestamp / WEEK * WEEK;\\n\\n        adminAllocation = 20;\\n\\n        WEIGHT_VOTE_DELAY = 10 * 86400;\\n        ADMIN_VOTE_PERIOD = 1 * 86400;\\n    }\\n\\n    /// @notice Change admin allocation by total / division\\n    /// @param _numerator The numerator for calculate allocation of admin\\n    function changeAdminAllocation(uint256 _numerator) external onlyOwner {\\n        require(_numerator > 0 && _numerator <= 100, \\\"division should not exceed 100\\\");\\n\\n        adminAllocation = _numerator;\\n\\n        emit AdminAllocationChanged(msg.sender, _numerator);\\n    }\\n\\n    /// @notice Change admin weight of user vote delay\\n    /// @param _delay New delay numer\\n    function changeWeightVoteDelay(uint256 _delay) external onlyOwner {\\n        require(_delay > WEEK, \\\"delay should exceed WEEK\\\");\\n        require(_delay < MAX_LOCK_TIME, \\\"delay should not exceed MAX_LOCK_TIME\\\");\\n\\n        WEIGHT_VOTE_DELAY = _delay;\\n\\n        emit WeightVoteDelayChanged(msg.sender, _delay);\\n    }\\n\\n    /// @notice Add gauge type with name `_name` and weight `weight`\\n    /// @param _name Name of gauge type\\n    /// @param _weight Weight of gauge type\\n    function addType(string memory _name, uint256 _weight) external onlyOwner {\\n        uint256 typeId = gaugeTypes;\\n        gaugeTypeNames[typeId] = _name;\\n        gaugeTypes = typeId + 1;\\n        if (_weight != 0) {\\n            _changeTypeWeight(typeId, _weight);\\n        }\\n\\n        emit AddType(_name, typeId);\\n    }\\n\\n    /// @notice Change gauge type `type_id` weight to `weight`\\n    /// @param type_id Gauge type id\\n    /// @param weight New Gauge weight\\n    function changeTypeWeight(uint256 type_id, uint256 weight) external onlyOwner {\\n        _changeTypeWeight(type_id, weight);\\n    }\\n\\n    /// @notice Add gauge `gauge_addr` of type `gauge_type` with weight `weight`\\n    /// @param gauge_addr Gauge address\\n    /// @param gauge_type Gauge type\\n    /// @param _weight Gauge weight\\n    /// @param _pid Their upper MasterChef\\n    /// @param _masterChef Their MasterChef address\\n    /// @param _chainId the gauge's chainId\\n    /// @param _boostMultiplier The boost for weight\\n    /// @param _maxVoteCap The cap for weight\\n    function addGauge(address gauge_addr, uint256 gauge_type, uint256 _weight, uint256 _pid, address _masterChef, uint256 _chainId, uint256 _boostMultiplier, uint256 _maxVoteCap) external onlyOwner {\\n        require(gauge_type < gaugeTypes, \\\"Invalid gauge type\\\");\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n        require(gaugeTypes_[gauge_hash] == 0, \\\"Gauge already added\\\"); // dev: cannot add the same twice\\n        require(_masterChef != address(0), \\\"masterChef address is empty\\\");\\n        require(_boostMultiplier <= 500);\\n        require(_maxVoteCap <= 10000);\\n\\n        uint256 n = gaugeCount;\\n        gaugeCount = n + 1;\\n        gauges[uint256(n)] = GaugeInfo({\\n            pairAddress: gauge_addr,\\n            pid: _pid,\\n            masterChef: _masterChef,\\n            chainId: _chainId,\\n            boostMultiplier: _boostMultiplier,\\n            maxVoteCap: _maxVoteCap\\n        });\\n\\n        gaugeIndex_[gauge_hash] = n + 1;\\n        gaugeTypes_[gauge_hash] = gauge_type + 1;\\n\\n        uint256 nextTime = _getNextTime();\\n\\n        if (_weight > 0) {\\n            uint256 typeWeight = _getTypeWeight(gauge_type);\\n            uint256 oldTypeSum = _getTypeSum(gauge_type);\\n            uint256 oldTotal = _getTotal();\\n\\n            gaugeTypePointsSum[gauge_type][nextTime].bias = _weight*_boostMultiplier/BOOST_PRECISION + oldTypeSum;\\n            gaugeTypeSumLastScheduled[gauge_type] = nextTime;\\n            gaugePointsTotal[nextTime] = oldTotal + typeWeight*_weight*_boostMultiplier/BOOST_PRECISION;\\n            totalLastScheduled = nextTime;\\n\\n            gaugePointsWeight[gauge_hash][nextTime].bias = _weight*_boostMultiplier/BOOST_PRECISION;\\n        }\\n\\n        if (gaugeTypeSumLastScheduled[gauge_type] == 0) {\\n            gaugeTypeSumLastScheduled[gauge_type] = nextTime;\\n        }\\n        gaugeLastScheduled[gauge_hash] = nextTime;\\n\\n        emit NewGauge(gauge_hash, gauge_type, _weight, _pid, _masterChef, _chainId, _boostMultiplier, _maxVoteCap);\\n    }\\n\\n    /// @notice Update info of gauge `gauge_addr` and `_chainId` to GaugeInfo\\n    /// @param gauge_addr `GaugeController` contract address\\n    /// @param _pid Their upper MasterChef\\n    /// @param _masterChef Their MasterChef address\\n    /// @param _chainId the gauge's chainId\\n    /// @param _boostMultiplier The boost for weight\\n    /// @param _maxVoteCap The cap for weight\\n    function updateGaugeInfo(address gauge_addr, uint256 _pid, address _masterChef, uint256 _chainId, uint256 _boostMultiplier, uint256 _maxVoteCap) external onlyOwner {\\n        require(_masterChef != address(0), \\\"masterChef address is empty\\\");\\n        require(_boostMultiplier <= 500);\\n        require(_maxVoteCap <= 10000);\\n\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        uint256 nextTime = _getNextTime();\\n\\n        uint256 _weight = gaugePointsWeight[gauge_hash][nextTime].bias;\\n        uint256 _type = gaugeTypes_[gauge_hash] - 1;\\n\\n        if (_weight > 0) {\\n            uint256 typeWeight = _getTypeWeight(_type);\\n            uint256 oldWeight = getGaugeWeight(gauge_addr, _chainId, false);\\n            uint256 oldTypeSum = _getTypeSum(_type);\\n            uint256 oldTotal = _getTotal();\\n\\n            gaugeTypePointsSum[_type][nextTime].bias = oldTypeSum + _weight - oldWeight;\\n            gaugeTypeSumLastScheduled[_type] = nextTime;\\n            gaugePointsTotal[nextTime] = oldTotal + typeWeight * _weight - typeWeight * oldWeight;\\n            totalLastScheduled = nextTime;\\n        }\\n\\n        if (gaugeTypeSumLastScheduled[_type] == 0) {\\n            gaugeTypeSumLastScheduled[_type] = nextTime;\\n        }\\n\\n        gauges[idx-1] = GaugeInfo({\\n            pairAddress: gauge_addr,\\n            pid: _pid,\\n            masterChef: _masterChef,\\n            chainId: _chainId,\\n            boostMultiplier: _boostMultiplier,\\n            maxVoteCap: _maxVoteCap\\n        });\\n\\n        emit UpdateGaugeInfo(gauge_hash, _pid, _masterChef, _chainId, _boostMultiplier, _maxVoteCap);\\n    }\\n\\n    /// @notice Change weight of gauge `gauge_addr` and `_chainId` to `weight`\\n    /// @param gauge_addr `GaugeController` contract address\\n    /// @param weight New Gauge weight\\n    /// @param _chainId the gauge's chainId\\n    function changeGaugeWeight(address gauge_addr, uint256 weight, uint256 _chainId) external onlyOwner {\\n        _changeGaugeWeight(gauge_addr, weight, _chainId);\\n    }\\n\\n    /// @notice Checkpoint to fill data common for all gauges\\n    function checkpoint() external {\\n        _getTotal();\\n    }\\n\\n    /// @notice Checkpoint to fill data for both a specific gauge and common for all gauges\\n    /// @param gauge_addr Gauge address\\n    /// @param _chainId the gauge's chainId\\n    function checkpointGauge(address gauge_addr, uint256 _chainId) external {\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        _getWeight(gauge_hash);\\n        _getTotal();\\n    }\\n\\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\\n    /// (e.g. 1.0 == 1e18). Inflation which will be received by it is\\n    /// inflation_rate * inflation_weight / 1e18\\n    /// @param gauge_addr Gauge address\\n    /// @param time Relative weight at the specified timestamp in the past or present\\n    /// @param _chainId the gauge's chainId\\n    /// @return Value of relative weight normalized to 1e18\\n    function gaugeRelativeWeight(address gauge_addr, uint256 time, uint256 _chainId) external view returns (uint256) {\\n        return _gaugeRelativeWeight(gauge_addr, time, _chainId);\\n    }\\n\\n    /// @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\\n    /// values for type and gauge records\\n    /// @dev Any address can call, however nothing is recorded if the values are filled already\\n    /// @param gauge_addr Gauge address\\n    /// @param time Relative weight at the specified timestamp in the past or present\\n    /// @param _chainId the gauge's chainId\\n    /// @return Value of relative weight normalized to 1e18\\n    function gaugeRelativeWeight_write(address gauge_addr, uint256 time, uint256 _chainId) external returns (uint256) {\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        _getWeight(gauge_hash);\\n        _getTotal(); // Also calculates get_sum\\n\\n        return _gaugeRelativeWeight(gauge_addr, time, _chainId);\\n    }\\n\\n    function voteForGaugeWeightsBulk(address[] calldata _gauge_addrs, uint256[] calldata _user_weights, uint256[] calldata _chainIds, bool _skipNative, bool _skipProxy) external {\\n        uint256 len = _gauge_addrs.length;\\n        require(len == _user_weights.length, \\\"length is not same\\\");\\n        require(len == _chainIds.length, \\\"length is not same\\\");\\n\\n        for (uint256 i = 0; i < len; i++) {\\n            voteForGaugeWeights(_gauge_addrs[i], _user_weights[i], _chainIds[i], _skipNative, _skipProxy);\\n        }\\n    }\\n\\n    /// @notice Allocate voting power for changing pool weights\\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\\n    /// @param _user_weight Weight for a gauge in bps (uints of 0.01%). Minimal is 0.01%. Ignored if 0\\n    /// @param _chainId the gauge's chainId\\n    /// @param _skipNative flag if we skip to check EOA address\\n    /// @param _skipProxy flag if we skip to check proxy address\\n    function voteForGaugeWeights(address _gauge_addr, uint256 _user_weight, uint256 _chainId, bool _skipNative, bool _skipProxy) public {\\n        // get the \\\"actual\\\" next time (next voting end time) which should be even weeks Thursday\\n        uint256 actualNextTime = (block.timestamp + TWOWEEK) / TWOWEEK * TWOWEEK;\\n\\n        // block user voting if it is within ADMIN_VOTE_PERIOD before actual next time\\n        require(block.timestamp < actualNextTime - ADMIN_VOTE_PERIOD, \\\"Currently in admin only period\\\");\\n\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(_gauge_addr, _chainId));\\n\\n        uint256 powerUsed = voteUserPower[msg.sender];\\n\\n        if (gaugeIsKilled_[gauge_hash] && powerUsed >= 10000) {\\n            _user_weight = 0;\\n        }\\n\\n        require(!gaugeIsKilled_[gauge_hash] || _user_weight == 0, \\\"gauge killed\\\");\\n\\n        require(_user_weight <= 10000, \\\"You used all your voting power\\\");\\n\\n        address escrow = votingEscrow;\\n\\n        uint256 nextTime = _getNextTime();\\n\\n        if (!_skipNative) {\\n            (int128 amount, uint256 lockEnd) = VotingEscrow(escrow).locks(msg.sender);\\n            uint256 slopeUint256 = SafeCast.toUint256(amount) / MAX_LOCK_TIME;\\n            if (slopeUint256 > 0 && lockEnd > nextTime && block.timestamp >= lastUserVote[msg.sender][gauge_hash] + WEIGHT_VOTE_DELAY) {\\n                _voteFromUser(gauge_hash, msg.sender, _user_weight, slopeUint256, lockEnd);\\n            }\\n        }\\n\\n        (address cakePoolProxy, , , , , ) = VotingEscrow(escrow).userInfo(msg.sender);\\n\\n        if (!_skipProxy && cakePoolProxy != address(0)) {\\n            (int128 amount1, uint256 lockEnd1) = VotingEscrow(escrow).locks(cakePoolProxy);\\n            uint256 slope1Uint256 = SafeCast.toUint256(amount1) / MAX_LOCK_TIME;\\n            if (slope1Uint256 > 0 && lockEnd1 > nextTime && block.timestamp >= lastUserVote[cakePoolProxy][gauge_hash] + WEIGHT_VOTE_DELAY) {\\n                _voteFromUser(gauge_hash, cakePoolProxy, _user_weight, slope1Uint256, lockEnd1);\\n            }\\n        }\\n    }\\n\\n    function voteFromAdminBulk(address[] calldata _gauge_addrs, uint256[] calldata _admin_weights, uint256[] calldata _ends, uint256[] calldata _chainIds) external onlyOwner {\\n        uint256 len = _gauge_addrs.length;\\n        require(len == _admin_weights.length, \\\"length is not same\\\");\\n        require(len == _ends.length, \\\"length is not same\\\");\\n        require(len == _chainIds.length, \\\"length is not same\\\");\\n\\n        for (uint256 i = 0; i < len; i++) {\\n            _voteFromAdmin(_gauge_addrs[i], _admin_weights[i], _ends[i], _chainIds[i]);\\n        }\\n    }\\n\\n    /// @notice Vote from admin for changing pool weights\\n    /// @param _gauge_addr Gauge which `msg.sender` votes for\\n    /// @param _admin_weight Weight for a gauge in bps (uints of 0.01%). Minimal is 0.01%. Ignored if 0\\n    /// @param _end the timestamp that admin vote effect ends\\n    /// @param _chainId the gauge's chainId\\n    function voteFromAdmin(address _gauge_addr, uint256 _admin_weight, uint256 _end, uint256 _chainId) external onlyOwner {\\n        _voteFromAdmin(_gauge_addr, _admin_weight, _end, _chainId);\\n    }\\n\\n    /// @notice Get current gauge weight\\n    /// @param gauge_addr Gauge address\\n    /// @param _chainId the gauge's chainId\\n    /// @return Gauge weight\\n    function getGaugeWeight(address gauge_addr, uint256 _chainId, bool inCap) public view returns (uint256) {\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n        GaugeInfo memory info = gauges[idx-1];\\n\\n        uint256 bias = gaugePointsWeight[gauge_hash][gaugeLastScheduled[gauge_hash]].bias;\\n\\n        if (inCap) {\\n            if (info.maxVoteCap >= 100 && bias > 0) {\\n                uint256 totalBias = 0;\\n                for (uint256 i = 0; i < gaugeCount; i++) {\\n                    GaugeInfo memory info1 = gauges[i];\\n                    bytes32 gauge_hash1 = keccak256(abi.encodePacked(info1.pairAddress, info1.chainId));\\n                    uint256 rate1 = gaugePointsWeight[gauge_hash1][gaugeLastScheduled[gauge_hash1]].bias * BOOST_PRECISION * CAP_PRECISION / gaugePointsTotal[totalLastScheduled];\\n\\n                    if (info1.maxVoteCap > 0 && rate1 > info1.maxVoteCap) {\\n                        rate1 = info1.maxVoteCap * BOOST_PRECISION;\\n                    }\\n\\n                    totalBias = totalBias + rate1;\\n                }\\n\\n                bias = info.maxVoteCap * totalBias * gaugePointsTotal[totalLastScheduled] / BOOST_PRECISION / BOOST_PRECISION / BOOST_PRECISION / CAP_PRECISION;\\n            }\\n        }\\n\\n        return bias;\\n    }\\n\\n    /// @notice Get current type and chainId weight\\n    /// @param _typeId Type id\\n    /// @param _chainId the gauge's chainId\\n    /// @return Type weight\\n    function getTypeAndChainIdWeightCapped(uint256 _typeId, uint256 _chainId) external view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < gaugeCount; i++) {\\n            GaugeInfo memory info1 = gauges[i];\\n            bytes32 gauge_hash1 = keccak256(abi.encodePacked(info1.pairAddress, info1.chainId));\\n            uint256 type1 = gaugeTypes_[gauge_hash1] - 1;\\n            if (type1 == _typeId && info1.chainId == _chainId) {\\n                uint256 weight = getGaugeWeight(info1.pairAddress, info1.chainId, true);\\n                total += weight;\\n            }\\n        }\\n        return total;\\n    }\\n\\n    /// @notice Get current total (type-weighted) weight\\n    /// @return Total weight\\n    function getTotalWeight(bool inCap) public view returns (uint256) {\\n        if (inCap) {\\n            uint256 total = 0;\\n            for (uint256 i = 0; i < gaugeCount; i++) {\\n                GaugeInfo memory info1 = gauges[i];\\n                uint256 weight = getGaugeWeight(info1.pairAddress, info1.chainId, true);\\n                total += weight;\\n            }\\n\\n            return total;\\n        }\\n        return gaugePointsTotal[totalLastScheduled];\\n    }\\n\\n    /// @notice Get sum of gauge weights per type\\n    /// @param _typeId Type id\\n    /// @return Sum of gauge weights\\n    function getWeightsSumPerType(uint256 _typeId) external view returns (uint256) {\\n        return gaugeTypePointsSum[_typeId][gaugeTypeSumLastScheduled[_typeId]].bias;\\n    }\\n\\n    /// @notice Kill a gauge for disable user voting\\n    /// @param _gauge_addr Gauge address\\n    /// @param _chainId the gauge's chainId\\n    function killGauge(address _gauge_addr, uint256 _chainId) external onlyOwner {\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(_gauge_addr, _chainId));\\n        gaugeIsKilled_[gauge_hash] = true;\\n        emit GaugeKilled(msg.sender, _gauge_addr, _chainId, gauge_hash);\\n    }\\n\\n    /// @notice UnKill a gauge for enable user voting\\n    /// @param _gauge_addr Gauge address\\n    /// @param _chainId the gauge's chainId\\n    function unkillGauge(address _gauge_addr, uint256 _chainId) external onlyOwner {\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(_gauge_addr, _chainId));\\n        gaugeIsKilled_[gauge_hash] = false;\\n        emit GaugeUnKilled(msg.sender, _gauge_addr, _chainId, gauge_hash);\\n    }\\n\\n    function updateAdminOnlyPeriod(uint256 _newAdminOnlyPeriod) external onlyOwner {\\n        // avoid setting this to too long\\n        require(_newAdminOnlyPeriod < WEEK, \\\"admin period too long\\\");\\n\\n        ADMIN_VOTE_PERIOD = _newAdminOnlyPeriod;\\n\\n        emit AdminOnlyPeriodUpdated(msg.sender, _newAdminOnlyPeriod);\\n    }\\n\\n    //////////////////// INSIDE FUNCTIONS //////////////////////////////\\n\\n    function _getNextTime() internal view returns (uint256 nextTime) {\\n        nextTime = (block.timestamp + WEEK) / WEEK * WEEK;\\n    }\\n\\n    /// @notice Change type weight\\n    /// @param _typeId Type id\\n    /// @param _weight New type weight\\n    function _changeTypeWeight(uint256 _typeId, uint256 _weight) internal {\\n        require(_typeId < gaugeTypes, \\\"Invalid gauge type\\\");\\n        uint256 oldTypeWeight = _getTypeWeight(_typeId);\\n        uint256 oldSum = _getTypeSum(_typeId);\\n        uint256 totalWeight = _getTotal();\\n        uint256 nextTime = _getNextTime();\\n\\n        totalWeight = totalWeight + oldSum * _weight - oldSum * oldTypeWeight;\\n        gaugePointsTotal[nextTime] = totalWeight;\\n        gaugeTypePointsWeight[_typeId][nextTime] = _weight;\\n        totalLastScheduled = nextTime;\\n        gaugeTypeLastScheduled[_typeId] = nextTime;\\n\\n        emit NewTypeWeight(_typeId, nextTime, _weight, totalWeight);\\n    }\\n\\n    /// @notice Change gauge weight\\n    /// @dev Only need when testing in reality\\n    function _changeGaugeWeight(address gauge_addr, uint256 _weight, uint256 _chainId) internal {\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n        uint256 gauge_type = gaugeTypes_[gauge_hash] - 1;\\n\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        GaugeInfo memory info = gauges[idx-1];\\n\\n        uint256 oldGaugeWeight = _getWeight(gauge_hash);\\n        uint256 typeWeight = _getTypeWeight(gauge_type);\\n        uint256 oldSum = _getTypeSum(gauge_type);\\n        uint256 totalWeight = _getTotal();\\n        uint256 nextTime = _getNextTime();\\n\\n        gaugePointsWeight[gauge_hash][nextTime].bias = _weight*info.boostMultiplier/BOOST_PRECISION;\\n        gaugeLastScheduled[gauge_hash] = nextTime;\\n\\n        uint256 newSum = oldSum + _weight*info.boostMultiplier/BOOST_PRECISION - oldGaugeWeight;\\n        gaugeTypePointsSum[gauge_type][nextTime].bias = newSum;\\n        gaugeTypeSumLastScheduled[gauge_type] = nextTime;\\n\\n        totalWeight = totalWeight + newSum * typeWeight - oldSum * typeWeight;\\n        gaugePointsTotal[nextTime] = totalWeight;\\n        totalLastScheduled = nextTime;\\n\\n        emit NewGaugeWeight(gauge_hash, block.timestamp, _weight, totalWeight);\\n    }\\n\\n    /// @notice Fill historic type weights week-over-week for missed checkins\\n    /// and return the type weight for the future week\\n    /// @param _type Gauge type id\\n    /// @return Type weight\\n    function _getTypeWeight(uint256 _type) internal returns (uint256) {\\n        uint256 t = gaugeTypeLastScheduled[_type];\\n        if (t > 0) {\\n            uint256 weight = gaugeTypePointsWeight[_type][t];\\n            for (uint256 i = 0; i < 500; i++) {\\n                if (t > block.timestamp) {\\n                    break;\\n                }\\n                t += WEEK;\\n                gaugeTypePointsWeight[_type][t] = weight;\\n                if (t > block.timestamp) {\\n                    gaugeTypeLastScheduled[_type] = t;\\n                }\\n            }\\n            return weight;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Fill historic gauge weights week-over-week for missed checkins\\n    /// and return the total for the future week\\n    /// @param gauge_hash bytes32 of the gauge address and chainId\\n    /// @return Gauge weight\\n    function _getWeight(bytes32 gauge_hash) internal returns (uint256) {\\n        uint256 t = gaugeLastScheduled[gauge_hash];\\n        if (t > 0) {\\n            Point memory pt = gaugePointsWeight[gauge_hash][t];\\n            for (uint256 i = 0; i < 500; i++) {\\n                if (t > block.timestamp) {\\n                    break;\\n                }\\n                t += WEEK;\\n                uint256 d_bias = pt.slope * WEEK;\\n                if (pt.bias > d_bias) {\\n                    pt.bias -= d_bias;\\n                    uint256 d_slope = gaugeChangesWeight[gauge_hash][t];\\n                    pt.slope -= d_slope;\\n                } else {\\n                    pt.bias = 0;\\n                    pt.slope = 0;\\n                }\\n                gaugePointsWeight[gauge_hash][t] = pt;\\n                if (t > block.timestamp) {\\n                    gaugeLastScheduled[gauge_hash] = t;\\n                }\\n            }\\n            return pt.bias;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Fill sum of gauge weights for the same type week-over-week for\\n    /// missed checkins and return the sum for the future week\\n    /// @param _type Gauge type id\\n    /// @return Sum of weights\\n    function _getTypeSum(uint256 _type) internal returns (uint256) {\\n        uint256 t = gaugeTypeSumLastScheduled[_type];\\n        if (t > 0) {\\n            Point memory pt = gaugeTypePointsSum[_type][t];\\n            for (uint256 i = 0; i < 500; i++) {\\n                if (t > block.timestamp) {\\n                    break;\\n                }\\n                t += WEEK;\\n                uint256 d_bias = pt.slope * WEEK;\\n                if (pt.bias > d_bias) {\\n                    pt.bias -= d_bias;\\n                    uint256 d_slope = gaugeTypeChangesSum[_type][t];\\n                    pt.slope -= d_slope;\\n                } else {\\n                    pt.bias = 0;\\n                    pt.slope = 0;\\n                }\\n                gaugeTypePointsSum[_type][t] = pt;\\n\\n                if (t > block.timestamp) {\\n                    gaugeTypeSumLastScheduled[_type] = t;\\n                }\\n            }\\n            return pt.bias;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Fill historic total weights week-over-week for missed checkins\\n    /// and return the total for the future week\\n    /// @return Total weight\\n    function _getTotal() internal returns (uint256) {\\n        uint256 t = totalLastScheduled;\\n        uint256 n = gaugeTypes;\\n        if (t > block.timestamp) {\\n            // If we have already checkpointed - still need to change the value\\n            t -= WEEK;\\n        }\\n        uint256 pt = gaugePointsTotal[t];\\n\\n        for (uint256 _type = 0; _type < 100; _type++) {\\n            if (_type == n) {\\n                break;\\n            }\\n            _getTypeSum(_type);\\n            _getTypeWeight(_type);\\n        }\\n\\n        for (uint256 i = 0; i < 500; i++) {\\n            if (t > block.timestamp) {\\n                break;\\n            }\\n            t += WEEK;\\n            pt = 0;\\n            // Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\\n            for (uint256 _type = 0; _type < 100; _type++) {\\n                if (_type == n) {\\n                    break;\\n                }\\n                uint256 typeSum = gaugeTypePointsSum[_type][t].bias;\\n                uint256 typeWeight = gaugeTypePointsWeight[_type][t];\\n                pt += typeSum * typeWeight;\\n            }\\n            gaugePointsTotal[t] = pt;\\n            if (t > block.timestamp) {\\n                totalLastScheduled = t;\\n            }\\n        }\\n        return pt;\\n    }\\n\\n    /// @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\\n    /// (e.g. 1.0 == 1e18). Inflation which will be received by it is\\n    /// inflation_rate * inflation_weight / 1e18\\n    /// @param gauge_addr Gauge address\\n    /// @param _time Relative weight at the specified timestamp in the past or present\\n    /// @param _chainId the gauge's chainId\\n    /// @return Value of relative weight normalized to 1e18\\n    function _gaugeRelativeWeight(address gauge_addr, uint256 _time, uint256 _chainId) internal view returns (uint256) {\\n        uint256 t = _time / WEEK * WEEK;\\n        uint256 totalWeight = gaugePointsTotal[t];\\n\\n        if (totalWeight > 0) {\\n            bytes32 gauge_hash = keccak256(abi.encodePacked(gauge_addr, _chainId));\\n            uint256 gauge_type = gaugeTypes_[gauge_hash] - 1;\\n            uint256 typeWeight = gaugeTypePointsWeight[gauge_type][t];\\n            uint256 gaugeWeight = gaugePointsWeight[gauge_hash][t].bias;\\n            return MULTIPLIER * typeWeight * gaugeWeight / totalWeight;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Allocate voting power for changing pool weights\\n    function _voteFromUser(bytes32 gauge_hash, address user, uint256 _user_weight, uint256 slope, uint256 lockEnd) internal {\\n        uint256 nextTime = _getNextTime();\\n        bytes32 hash = gauge_hash;\\n        address msg_sender = user;\\n\\n        // Prepare slopes and biases in memory\\n        VotedSlope memory old_slope = voteUserSlopes[msg_sender][gauge_hash];\\n        uint256 old_dt = 0;\\n        if (old_slope.end > nextTime) {\\n            old_dt = old_slope.end - nextTime;\\n        }\\n        uint256 old_bias = old_slope.slope * old_dt;\\n\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        GaugeInfo memory info = gauges[idx-1];\\n        uint256 _user_weight2 = _user_weight;\\n\\n        VotedSlope memory new_slope = VotedSlope({\\n            slope: slope * _user_weight2 / 10000,\\n            end: lockEnd,\\n            power: _user_weight2\\n        });\\n\\n        uint256 new_dt = lockEnd - nextTime; // dev: raises when expired\\n        uint256 new_bias = new_slope.slope * new_dt;\\n\\n        // Check and update powers (weights) used\\n        uint256 powerUsed = voteUserPower[msg_sender];\\n        powerUsed = powerUsed + new_slope.power - old_slope.power;\\n        voteUserPower[msg_sender] = powerUsed;\\n        require(powerUsed <= 10000, \\\"Used too much power\\\");\\n\\n        if (old_slope.end > nextTime) {\\n            _vote1(hash, old_slope, new_slope, old_bias*info.boostMultiplier/BOOST_PRECISION, new_bias*info.boostMultiplier/BOOST_PRECISION);\\n        } else {\\n            _vote2(hash, new_slope, old_bias*info.boostMultiplier/BOOST_PRECISION, new_bias*info.boostMultiplier/BOOST_PRECISION);\\n        }\\n        if (old_slope.end > block.timestamp) {\\n            _vote3(hash, old_slope, old_bias*info.boostMultiplier/BOOST_PRECISION, new_bias*info.boostMultiplier/BOOST_PRECISION);\\n        }\\n\\n        uint256 gauge_type = gaugeTypes_[hash] - 1;\\n\\n        // Add slope changes for new slopes\\n        gaugeChangesWeight[hash][new_slope.end] += new_slope.slope;\\n        gaugeTypeChangesSum[gauge_type][new_slope.end] += new_slope.slope;\\n\\n        _getTotal();\\n\\n        voteUserSlopes[msg_sender][hash] = new_slope;\\n        lastUserVote[msg_sender][hash] = block.timestamp;\\n\\n        emit VoteForGauge(block.timestamp, msg_sender, hash, new_slope.power);\\n    }\\n\\n    /// @notice Allocate voting power for changing pool weights\\n    function _voteFromAdmin(address _gauge_addr, uint256 _admin_weight, uint256 _end, uint256 _chainId) internal {\\n        uint256 nextTime = _getNextTime();\\n        require(_end > nextTime || _end == 0, \\\"Your end timestamp expires too soon\\\");\\n        require(_admin_weight <= 10000, \\\"admin weight is overflow\\\");\\n\\n        // Update admin total admin slopes\\n        uint256 totalSupply = VotingEscrow(votingEscrow).totalSupplyAtTime(nextTime);\\n        adminSlopes[nextTime] = totalSupply * adminAllocation / 100 / MAX_LOCK_TIME;\\n\\n        bytes32 gauge_hash = keccak256(abi.encodePacked(_gauge_addr, _chainId));\\n        uint256 gauge_type = gaugeTypes_[gauge_hash] - 1;\\n\\n        // Prepare slopes and biases in memory\\n        VotedSlope memory old_slope = voteUserSlopes[address(0)][gauge_hash];\\n        uint256 old_bias = old_slope.slope * MAX_LOCK_TIME;\\n\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        GaugeInfo memory info = gauges[idx-1];\\n        uint256 _admin_weight2 = _admin_weight;\\n\\n        if (_end == 0) {\\n            _end = block.timestamp + MAX_LOCK_TIME;\\n        }\\n        _end = (_end + WEEK) / WEEK * WEEK;\\n\\n        VotedSlope memory new_slope = VotedSlope({\\n            slope: adminSlopes[nextTime] * _admin_weight2 / 10000,\\n            end: _end,\\n            power: _admin_weight2\\n        });\\n\\n        uint256 new_dt = _end - nextTime;\\n        uint256 new_bias = new_slope.slope * new_dt;\\n\\n        if (old_slope.end > nextTime) {\\n            _vote1(gauge_hash, old_slope, new_slope, old_bias*info.boostMultiplier/BOOST_PRECISION, new_bias*info.boostMultiplier/BOOST_PRECISION);\\n        } else {\\n            _vote2(gauge_hash, new_slope, old_bias*info.boostMultiplier/BOOST_PRECISION, new_bias*info.boostMultiplier/BOOST_PRECISION);\\n        }\\n        if (old_slope.end > block.timestamp) {\\n            _vote3(gauge_hash, old_slope, old_bias*info.boostMultiplier/BOOST_PRECISION, new_bias*info.boostMultiplier/BOOST_PRECISION);\\n        }\\n        // Add slope changes for new slopes\\n        gaugeChangesWeight[gauge_hash][new_slope.end] += new_slope.slope;\\n        gaugeTypeChangesSum[gauge_type][new_slope.end] += new_slope.slope;\\n\\n        _getTotal();\\n\\n        voteUserSlopes[address(0)][gauge_hash] = new_slope;\\n        lastUserVote[address(0)][gauge_hash] = block.timestamp;\\n\\n        emit VoteForGaugeFromAdmin(block.timestamp, msg.sender, gauge_hash, new_slope.power);\\n    }\\n\\n    /// @notice Allocate voting power for changing pool weights\\n    function _vote1(bytes32 gauge_hash, VotedSlope memory old_slope, VotedSlope memory new_slope, uint256 old_bias, uint256 new_bias) internal {\\n        uint256 next_time = _getNextTime();\\n        uint256 gauge_type = gaugeTypes_[gauge_hash] - 1;\\n\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        GaugeInfo memory info = gauges[idx-1];\\n\\n        // Remove old and schedule new slope changes\\n        // Remove slope changes for old slopes\\n        // Schedule recording of initial slope for next_time\\n        uint256 old_weight_bias = _getWeight(gauge_hash);\\n        uint256 old_weight_slope = gaugePointsWeight[gauge_hash][next_time].slope;\\n        uint256 old_sum_bias = _getTypeSum(gauge_type);\\n        uint256 old_sum_slope = gaugeTypePointsSum[gauge_type][next_time].slope;\\n\\n        gaugePointsWeight[gauge_hash][next_time].bias = (old_weight_bias + new_bias > old_bias ? old_weight_bias + new_bias : old_bias) - old_bias;\\n        gaugeTypePointsSum[gauge_type][next_time].bias = (old_sum_bias + new_bias > old_bias ? old_sum_bias + new_bias : old_bias) - old_bias;\\n        gaugePointsWeight[gauge_hash][next_time].slope = (old_weight_slope + new_slope.slope > old_slope.slope ? old_weight_slope + new_slope.slope : old_slope.slope) - old_slope.slope;\\n        gaugeTypePointsSum[gauge_type][next_time].slope = (old_sum_slope + new_slope.slope > old_slope.slope ? old_sum_slope + new_slope.slope : old_slope.slope) - old_slope.slope;\\n    }\\n\\n    /// @notice Allocate voting power for changing pool weights\\n    function _vote2(bytes32 gauge_hash, VotedSlope memory new_slope, uint256 old_bias, uint256 new_bias) internal {\\n        uint256 next_time = _getNextTime();\\n        uint256 gauge_type = gaugeTypes_[gauge_hash] - 1;\\n\\n        uint256 idx = gaugeIndex_[gauge_hash];\\n        require(idx > 0, \\\"Gauge not added\\\");\\n\\n        GaugeInfo memory info = gauges[idx-1];\\n\\n        // Remove old and schedule new slope changes\\n        // Remove slope changes for old slopes\\n        // Schedule recording of initial slope for next_time\\n        uint256 old_weight_bias = _getWeight(gauge_hash);\\n        uint256 old_sum_bias = _getTypeSum(gauge_type);\\n\\n        gaugePointsWeight[gauge_hash][next_time].bias = (old_weight_bias + new_bias > old_bias ? old_weight_bias + new_bias : old_bias) - old_bias;\\n        gaugeTypePointsSum[gauge_type][next_time].bias = (old_sum_bias + new_bias > old_bias ? old_sum_bias + new_bias : old_bias) - old_bias;\\n        gaugePointsWeight[gauge_hash][next_time].slope += new_slope.slope;\\n        gaugeTypePointsSum[gauge_type][next_time].slope += new_slope.slope;\\n    }\\n\\n    /// @notice Allocate voting power for changing pool weights\\n    function _vote3(bytes32 gauge_hash, VotedSlope memory old_slope, uint256 old_bias, uint256 new_bias) internal {\\n        uint256 gauge_type = gaugeTypes_[gauge_hash] - 1;\\n\\n        gaugeChangesWeight[gauge_hash][old_slope.end] -= old_slope.slope;\\n        gaugeTypeChangesSum[gauge_type][old_slope.end] -= old_slope.slope;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Converts a signed int128 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_votingEscrow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_id\",\"type\":\"uint256\"}],\"name\":\"AddType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"AdminAllocationChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"AdminOnlyPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauage_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"GaugeKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauage_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"GaugeUnKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gauge_type\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterChef\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxVoteCap\",\"type\":\"uint256\"}],\"name\":\"NewGauge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_weight\",\"type\":\"uint256\"}],\"name\":\"NewGaugeWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_weight\",\"type\":\"uint256\"}],\"name\":\"NewTypeWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterChef\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boostMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxVoteCap\",\"type\":\"uint256\"}],\"name\":\"UpdateGaugeInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"VoteForGauge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"VoteForGaugeFromAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"WeightVoteDelayChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_VOTE_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WEIGHT_VOTE_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gauge_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_masterChef\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_boostMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxVoteCap\",\"type\":\"uint256\"}],\"name\":\"addGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"addType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminSlopes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"}],\"name\":\"changeAdminAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"changeGaugeWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"type_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"changeTypeWeight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"changeWeightVoteDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"checkpointGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeChangesWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"gaugeIndex_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"gaugeIsKilled_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"gaugeLastScheduled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugePointsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugePointsWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"gaugeRelativeWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"gaugeRelativeWeight_write\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeTypeChangesSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeTypeLastScheduled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeTypeNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeTypePointsSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeTypePointsWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gaugeTypeSumLastScheduled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"gaugeTypes_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"masterChef\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boostMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxVoteCap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"inCap\",\"type\":\"bool\"}],\"name\":\"getGaugeWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"inCap\",\"type\":\"bool\"}],\"name\":\"getTotalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getTypeAndChainIdWeightCapped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_typeId\",\"type\":\"uint256\"}],\"name\":\"getWeightsSumPerType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"killGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lastUserVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLastScheduled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"unkillGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newAdminOnlyPeriod\",\"type\":\"uint256\"}],\"name\":\"updateAdminOnlyPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_masterChef\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_boostMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxVoteCap\",\"type\":\"uint256\"}],\"name\":\"updateGaugeInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_user_weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_skipNative\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_skipProxy\",\"type\":\"bool\"}],\"name\":\"voteForGaugeWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauge_addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_user_weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_chainIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_skipNative\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_skipProxy\",\"type\":\"bool\"}],\"name\":\"voteForGaugeWeightsBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_admin_weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"voteFromAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauge_addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_admin_weights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ends\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_chainIds\",\"type\":\"uint256[]\"}],\"name\":\"voteFromAdminBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteUserPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"voteUserSlopes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingEscrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GaugeVoting", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005692db8177a81a6c6afc8084c2976c9933ec1bab", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}