{"SourceCode": "// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.9.0pragma solidity ^0.8.0;\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/IFarmEvent.sol\r\n\r\ninterface IFarmEvent {\r\n    event DepositLiquidity(\r\n        address indexed strategyContract,\r\n        address indexed userAddress,\r\n        uint256 indexed liquidityNftId,\r\n        bool isBNB,\r\n        address inputToken,\r\n        uint256 inputAmount,\r\n        uint256 increasedShare,\r\n        uint256 userShareAfterDeposit,\r\n        uint256 increasedToken0Amount,\r\n        uint256 increasedToken1Amount,\r\n        uint256 sendBackToken0Amount,\r\n        uint256 sendBackToken1Amount\r\n    );\r\n\r\n    event WithdrawLiquidity(\r\n        address indexed strategyContract,\r\n        address indexed userAddress,\r\n        uint256 indexed liquidityNftId,\r\n        uint256 decreasedShare,\r\n        uint256 userShareAfterWithdraw,\r\n        uint256 userReceivedToken0Amount,\r\n        uint256 userReceivedToken1Amount\r\n    );\r\n\r\n    event ClaimReward(\r\n        address indexed strategyContract,\r\n        address indexed userAddress,\r\n        uint256 indexed liquidityNftId,\r\n        uint256 claimedRewardAmount\r\n    );\r\n}\r\n\r\n// File contracts/interfaces/IStrategy.sol\r\n\r\ninterface IStrategy {\r\n    function depositLiquidity(\r\n        bool isBNB,\r\n        address userAddress,\r\n        address inputToken,\r\n        uint256 inputAmount,\r\n        uint256 swapInAmount,\r\n        uint256 minimumSwapOutAmount\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 increasedToken0Amount,\r\n            uint256 increasedToken1Amount,\r\n            uint256 sendBackToken0Amount,\r\n            uint256 sendBackToken1Amount\r\n        );\r\n\r\n    function withdrawLiquidity(\r\n        address userAddress,\r\n        uint256 withdrawShares\r\n    )\r\n        external\r\n        returns (\r\n            uint256 userReceivedToken0Amount,\r\n            uint256 userReceivedToken1Amount\r\n        );\r\n\r\n    function collectRewards() external;\r\n\r\n    function earnPreparation(\r\n        uint256 minimumToken0SwapOutAmount,\r\n        uint256 minimumToken1SwapOutAmount,\r\n        uint256 minimumCakeSwapOutAmount,\r\n        uint256 minimumBuybackSwapOutAmount\r\n    ) external;\r\n\r\n    function earn() external;\r\n\r\n    function claimReward(address userAddress) external;\r\n\r\n    function rescale() external;\r\n\r\n    function depositDustToken(\r\n        bool depositDustToken0\r\n    )\r\n        external\r\n        returns (uint256 increasedToken0Amount, uint256 increasedToken1Amount);\r\n}\r\n\r\n// File contracts/interfaces/IStrategyInfo.sol\r\n\r\ninterface IStrategyInfo {\r\n    /// @dev Pancakeswap-Transaction-related Variable\r\n    function transactionDeadlineDuration() external view returns (uint256);\r\n\r\n    /// @dev get Liquidity-NFT-related Variable\r\n    function liquidityNftId() external view returns (uint256);\r\n\r\n    function tickSpreadUpper() external view returns (int24);\r\n\r\n    function tickSpreadLower() external view returns (int24);\r\n\r\n    function tickSpacing() external view returns (int24);\r\n\r\n    /// @dev get Pool-related Variable\r\n    function poolAddress() external view returns (address);\r\n\r\n    function poolFee() external view returns (uint24);\r\n\r\n    function token0Address() external view returns (address);\r\n\r\n    function token1Address() external view returns (address);\r\n\r\n    /// @dev get Tracker-Token-related Variable\r\n    function trackerTokenAddress() external view returns (address);\r\n\r\n    /// @dev get User-Management-related Variable\r\n    function isInUserList(address userAddress) external view returns (bool);\r\n\r\n    function userIndex(address userAddress) external view returns (uint256);\r\n\r\n    function getAllUsersInUserList() external view returns (address[] memory);\r\n\r\n    /// @dev get User-Share-Management-related Variable\r\n    function userShare(address userAddress) external view returns (uint256);\r\n\r\n    function totalUserShare() external view returns (uint256);\r\n\r\n    /// @dev get Reward-Management-related Variable\r\n    function rewardToken0Amount() external view returns (uint256);\r\n\r\n    function rewardToken1Amount() external view returns (uint256);\r\n\r\n    function rewardCakeAmount() external view returns (uint256);\r\n\r\n    function rewardUsdtAmount() external view returns (uint256);\r\n\r\n    /// @dev get User-Reward-Management-related Variable\r\n    function userUsdtReward(\r\n        address userAddress\r\n    ) external view returns (uint256);\r\n\r\n    function totalUserUsdtReward() external view returns (uint256);\r\n\r\n    /// @dev get Buyback-related Variable\r\n    function buyBackToken() external view returns (address);\r\n\r\n    function buyBackNumerator() external view returns (uint24);\r\n\r\n    function getUsdtToBuyBackTokenPath()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /// @dev get Fund-Manager-related Variable\r\n    struct FundManagerVault {\r\n        address fundManagerVaultAddress;\r\n        uint256 fundManagerProfitVaultNumerator;\r\n    }\r\n\r\n    function getAllFundManagerVaults()\r\n        external\r\n        view\r\n        returns (FundManagerVault[3] memory);\r\n\r\n    /// @dev get Earn-Loop-Control-related Variable\r\n    function earnLoopSegmentSize() external view returns (uint256);\r\n\r\n    function earnLoopDistributedAmount() external view returns (uint256);\r\n\r\n    function earnLoopStartIndex() external view returns (uint256);\r\n\r\n    function isEarning() external view returns (bool);\r\n\r\n    /// @dev get Rescale-related Variable\r\n    function dustToken0Amount() external view returns (uint256);\r\n\r\n    function dustToken1Amount() external view returns (uint256);\r\n\r\n    /// @dev get Stake-Control-related Variable\r\n    function stakeNext() external view returns (bool);\r\n\r\n    function isStaking() external view returns (bool);\r\n\r\n    /// @dev get Constant Variable\r\n    function getBuyBackDenominator() external pure returns (uint24);\r\n\r\n    function getFundManagerProfitVaultDenominator()\r\n        external\r\n        pure\r\n        returns (uint24);\r\n\r\n    function getFarmAddress() external pure returns (address);\r\n\r\n    function getControllerAddress() external pure returns (address);\r\n\r\n    function getSwapAmountCalculatorAddress() external pure returns (address);\r\n\r\n    function getZapAddress() external pure returns (address);\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/INonfungiblePositionManager.sol\r\n\r\npragma abicoder v2;\r\n\r\ninterface INonfungiblePositionManager {\r\n    /// @notice Returns the position information associated with a given token ID.\r\n    /// @dev Throws if the token ID is not valid.\r\n    /// @param tokenId The ID of the token that represents the position\r\n    /// @return nonce The nonce for permits\r\n    /// @return operator The address that is approved for spending\r\n    /// @return token0 The address of the token0 for a specific pool\r\n    /// @return token1 The address of the token1 for a specific pool\r\n    /// @return fee The fee associated with the pool\r\n    /// @return tickLower The lower end of the tick range for the position\r\n    /// @return tickUpper The higher end of the tick range for the position\r\n    /// @return liquidity The liquidity of the position\r\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\r\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\r\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\r\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\r\n    function positions(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Creates a new position wrapped in a NFT\r\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\r\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\r\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\r\n    /// @return tokenId The ID of the token that represents the minted position\r\n    /// @return liquidity The amount of liquidity for this position\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function mint(\r\n        MintParams calldata params\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 tokenId,\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\r\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\r\n    /// amount0Desired The desired amount of token0 to be spent,\r\n    /// amount1Desired The desired amount of token1 to be spent,\r\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\r\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\r\n    /// deadline The time by which the transaction must be included to effect the change\r\n    /// @return liquidity The new liquidity amount as a result of the increase\r\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\r\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\r\n    function increaseLiquidity(\r\n        IncreaseLiquidityParams calldata params\r\n    )\r\n        external\r\n        payable\r\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1);\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\r\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\r\n    /// amount The amount by which liquidity will be decreased,\r\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\r\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\r\n    /// deadline The time by which the transaction must be included to effect the change\r\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\r\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\r\n    function decreaseLiquidity(\r\n        DecreaseLiquidityParams calldata params\r\n    ) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\r\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\r\n    /// recipient The account that should receive the tokens,\r\n    /// amount0Max The maximum amount of token0 to collect,\r\n    /// amount1Max The maximum amount of token1 to collect\r\n    /// @return amount0 The amount of fees collected in token0\r\n    /// @return amount1 The amount of fees collected in token1\r\n    function collect(\r\n        CollectParams calldata params\r\n    ) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\r\n    /// must be collected first.\r\n    /// @param tokenId The ID of the token that is being burned\r\n    function burn(uint256 tokenId) external payable;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\r\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\r\n    /// that use ether for the input amount. And in PancakeSwap Router, this would be called\r\n    /// at the very end of swap\r\n    function refundETH() external payable;\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/IPancakeV3Pool.sol\r\n\r\n/// @title The interface for a PancakeSwap V3 Pool\r\n/// @notice A PancakeSwap pool facilitates swapping and automated market making between any two assets that strictly conform\r\n/// to the ERC20 specification\r\n/// @dev The pool interface is broken up into many smaller pieces\r\ninterface IPancakeV3Pool {\r\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n    /// when accessed externally.\r\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n    /// boundary.\r\n    /// observationIndex The index of the last oracle observation that was written,\r\n    /// observationCardinality The current maximum number of observations stored in the pool,\r\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n    /// feeProtocol The protocol fee for both tokens of the pool.\r\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n    /// unlocked Whether the pool is currently locked to reentrancy\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint32 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    /// @notice The first of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token0() external view returns (address);\r\n\r\n    /// @notice The second of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token1() external view returns (address);\r\n\r\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\r\n    /// @return The fee\r\n    function fee() external view returns (uint24);\r\n\r\n    /// @notice The pool tick spacing\r\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\r\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\r\n    /// This value is an int24 to avoid casting even though it is always positive.\r\n    /// @return The tick spacing\r\n    function tickSpacing() external view returns (int24);\r\n}\r\n\r\n// File contracts/libraries/constants/Constants.sol\r\n\r\nlibrary Constants {\r\n    /// @dev mainnet pancakeswap V3\r\n    address public constant PANCAKE_V3_FACTORY_ADDRESS =\r\n        address(0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865);\r\n    address public constant MASTER_CHEF_V3_ADDRESS =\r\n        address(0x556B9306565093C855AEA9AE92A594704c2Cd59e);\r\n    address public constant NONFUNGIBLE_POSITION_MANAGER_ADDRESS =\r\n        address(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);\r\n    address public constant SMART_ROUTER_ADDRESS =\r\n        address(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);\r\n\r\n    /// @dev testnet pancakeswap V3\r\n    address public constant TESTNET_PANCAKE_V3_FACTORY_ADDRESS =\r\n        address(0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865);\r\n    address public constant TESTNET_MASTER_CHEF_V3_ADDRESS =\r\n        address(0x4c650FB471fe4e0f476fD3437C3411B1122c4e3B);\r\n    address public constant TESTNET_NONFUNGIBLE_POSITION_MANAGER_ADDRESS =\r\n        address(0x427bF5b37357632377eCbEC9de3626C71A5396c1);\r\n    address public constant TESTNET_SMART_ROUTER_ADDRESS =\r\n        address(0x9a489505a00cE272eAa5e07Dba6491314CaE3796);\r\n\r\n    /// @dev mainnet token address\r\n    address public constant WBNB_ADDRESS =\r\n        address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    address public constant USDT_ADDRESS =\r\n        address(0x55d398326f99059fF775485246999027B3197955);\r\n    address public constant USDC_ADDRESS =\r\n        address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\r\n    address public constant BTCB_ADDRESS =\r\n        address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n    address public constant BUSD_ADDRESS =\r\n        address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    address public constant CAKE_ADDRESS =\r\n        address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\r\n    address public constant ETH_ADDRESS =\r\n        address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n    address public constant XRP_ADDRESS =\r\n        address(0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE);\r\n    address public constant ADA_ADDRESS =\r\n        address(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\r\n    address public constant DOT_ADDRESS =\r\n        address(0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402);\r\n    address public constant RXD_ADDRESS =\r\n        address(0x92cb26ca653a51bBf916E6c3d58599CDB12e3a9F);\r\n\r\n    /// @dev testnet token address\r\n    address public constant TESTNET_WBNB_ADDRESS =\r\n        address(0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd);\r\n    address public constant TESTNET_USDT_ADDRESS =\r\n        address(0x0fB5D7c73FA349A90392f873a4FA1eCf6a3d0a96);\r\n    address public constant TESTNET_BUSD_ADDRESS =\r\n        address(0xaB1a4d4f1D656d2450692D237fdD6C7f9146e814);\r\n    address public constant TESTNET_CAKE_ADDRESS =\r\n        address(0x8d008B313C1d6C7fE2982F62d32Da7507cF43551);\r\n    address public constant TESTNET_RXD_ADDRESS =\r\n        address(0x3f83fCC8eFC9EBB56362222dD7844226870a12Ea);\r\n\r\n    /// @dev black hole address\r\n    address public constant BLACK_HOLE_ADDRESS =\r\n        address(0x000000000000000000000000000000000000dEaD);\r\n}\r\n\r\n// File contracts/libraries/pancakeswapV3/FixedPoint96.sol\r\n\r\n/// @title FixedPoint96\r\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\r\n/// @dev Used in SqrtPriceMath.sol\r\nlibrary FixedPoint96 {\r\n    uint8 internal constant RESOLUTION = 96;\r\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\r\n}\r\n\r\n// File contracts/libraries/pancakeswapV3/FullMath.sol\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a?b\u7e69denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = a * b\r\n        // Compute the product mod 2**256 and mod 2**256 - 1\r\n        // then use the Chinese Remainder Theorem to reconstruct\r\n        // the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2**256 + prod0\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(a, b, not(0))\r\n            prod0 := mul(a, b)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division\r\n        if (prod1 == 0) {\r\n            require(denominator > 0);\r\n            assembly {\r\n                result := div(prod0, denominator)\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2**256.\r\n        // Also prevents denominator == 0\r\n        require(denominator > prod1);\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0]\r\n        // Compute remainder using mulmod\r\n        uint256 remainder;\r\n        assembly {\r\n            remainder := mulmod(a, b, denominator)\r\n        }\r\n        // Subtract 256 bit number from 512 bit number\r\n        assembly {\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator\r\n        // Compute largest power of two divisor of denominator.\r\n        // Always >= 1.\r\n        uint256 twos = (~denominator) + 1;\r\n        // Divide denominator by power of two\r\n        assembly {\r\n            denominator := div(denominator, twos)\r\n        }\r\n\r\n        // Divide [prod1 prod0] by the factors of two\r\n        assembly {\r\n            prod0 := div(prod0, twos)\r\n        }\r\n        // Shift in bits from prod1 into prod0. For this we need\r\n        // to flip `twos` such that it is 2**256 / twos.\r\n        // If twos is zero, then it becomes one\r\n        assembly {\r\n            twos := add(div(sub(0, twos), twos), 1)\r\n        }\r\n        prod0 |= prod1 * twos;\r\n\r\n        // Invert denominator mod 2**256\r\n        // Now that denominator is an odd number, it has an inverse\r\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n        // Compute the inverse by starting with a seed that is correct\r\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n        uint256 inv = (3 * denominator) ^ 2;\r\n        // Now use Newton-Raphson iteration to improve the precision.\r\n        // Thanks to Hensel's lifting lemma, this also works in modular\r\n        // arithmetic, doubling the correct bits in each step.\r\n        inv *= 2 - denominator * inv; // inverse mod 2**8\r\n        inv *= 2 - denominator * inv; // inverse mod 2**16\r\n        inv *= 2 - denominator * inv; // inverse mod 2**32\r\n        inv *= 2 - denominator * inv; // inverse mod 2**64\r\n        inv *= 2 - denominator * inv; // inverse mod 2**128\r\n        inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n        // Because the division is now exact we can divide by multiplying\r\n        // with the modular inverse of denominator. This will give us the\r\n        // correct result modulo 2**256. Since the precoditions guarantee\r\n        // that the outcome is less than 2**256, this is the final result.\r\n        // We don't need to compute the high bits of the result and prod1\r\n        // is no longer required.\r\n        result = prod0 * inv;\r\n        return result;\r\n    }\r\n\r\n    /// @notice Calculates ceil(a?b\u7e69denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        result = mulDiv(a, b, denominator);\r\n        if (mulmod(a, b, denominator) > 0) {\r\n            require(result < type(uint256).max);\r\n            result++;\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/libraries/pancakeswapV3/LiquidityAmounts.sol\r\n\r\n/// @title Liquidity amount functions\r\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\r\nlibrary LiquidityAmounts {\r\n    /// @notice Downcasts uint256 to uint128\r\n    /// @param x The uint258 to be downcasted\r\n    /// @return y The passed value, downcasted to uint128\r\n    function toUint128(uint256 x) private pure returns (uint128 y) {\r\n        require((y = uint128(x)) == x);\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\r\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount0 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount0(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        uint256 intermediate = FullMath.mulDiv(\r\n            sqrtRatioAX96,\r\n            sqrtRatioBX96,\r\n            FixedPoint96.Q96\r\n        );\r\n        return\r\n            toUint128(\r\n                FullMath.mulDiv(\r\n                    amount0,\r\n                    intermediate,\r\n                    sqrtRatioBX96 - sqrtRatioAX96\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\r\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount1 The amount1 being sent in\r\n    /// @return liquidity The amount of returned liquidity\r\n    function getLiquidityForAmount1(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n        return\r\n            toUint128(\r\n                FullMath.mulDiv(\r\n                    amount1,\r\n                    FixedPoint96.Q96,\r\n                    sqrtRatioBX96 - sqrtRatioAX96\r\n                )\r\n            );\r\n    }\r\n\r\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param amount0 The amount of token0 being sent in\r\n    /// @param amount1 The amount of token1 being sent in\r\n    /// @return liquidity The maximum amount of liquidity received\r\n    function getLiquidityForAmounts(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint256 amount0,\r\n        uint256 amount1\r\n    ) internal pure returns (uint128 liquidity) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            liquidity = getLiquidityForAmount0(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                amount0\r\n            );\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            uint128 liquidity0 = getLiquidityForAmount0(\r\n                sqrtRatioX96,\r\n                sqrtRatioBX96,\r\n                amount0\r\n            );\r\n            uint128 liquidity1 = getLiquidityForAmount1(\r\n                sqrtRatioAX96,\r\n                sqrtRatioX96,\r\n                amount1\r\n            );\r\n\r\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\r\n        } else {\r\n            liquidity = getLiquidityForAmount1(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                amount1\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    function getAmount0ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        uint256 originalResult = FullMath.mulDiv(\r\n            uint256(liquidity) << FixedPoint96.RESOLUTION,\r\n            sqrtRatioBX96 - sqrtRatioAX96,\r\n            sqrtRatioBX96\r\n        ) / sqrtRatioAX96;\r\n\r\n        /// @dev handle overflow issue\r\n        if (originalResult != 0) {\r\n            return originalResult;\r\n        } else {\r\n            return\r\n                FullMath.mulDiv(\r\n                    (uint256(liquidity) << FixedPoint96.RESOLUTION) /\r\n                        sqrtRatioAX96,\r\n                    sqrtRatioBX96 - sqrtRatioAX96,\r\n                    sqrtRatioBX96\r\n                );\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount1 The amount of token1\r\n    function getAmount1ForLiquidity(\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        return\r\n            FullMath.mulDiv(\r\n                liquidity,\r\n                sqrtRatioBX96 - sqrtRatioAX96,\r\n                FixedPoint96.Q96\r\n            );\r\n    }\r\n\r\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\r\n    /// pool prices and the prices at the tick boundaries\r\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\r\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\r\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\r\n    /// @param liquidity The liquidity being valued\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function getAmountsForLiquidity(\r\n        uint160 sqrtRatioX96,\r\n        uint160 sqrtRatioAX96,\r\n        uint160 sqrtRatioBX96,\r\n        uint128 liquidity\r\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\r\n        if (sqrtRatioAX96 > sqrtRatioBX96)\r\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\r\n\r\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\r\n            amount0 = getAmount0ForLiquidity(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                liquidity\r\n            );\r\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\r\n            amount0 = getAmount0ForLiquidity(\r\n                sqrtRatioX96,\r\n                sqrtRatioBX96,\r\n                liquidity\r\n            );\r\n            amount1 = getAmount1ForLiquidity(\r\n                sqrtRatioAX96,\r\n                sqrtRatioX96,\r\n                liquidity\r\n            );\r\n        } else {\r\n            amount1 = getAmount1ForLiquidity(\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                liquidity\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/libraries/pancakeswapV3/TickMath.sol\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO =\r\n        1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(\r\n        int24 tick\r\n    ) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0\r\n            ? uint256(-int256(tick))\r\n            : uint256(int256(tick));\r\n        require(absTick <= uint256(int256(MAX_TICK)), \"T\");\r\n\r\n        uint256 ratio = absTick & 0x1 != 0\r\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\r\n            : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0)\r\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0)\r\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0)\r\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0)\r\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0)\r\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0)\r\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0)\r\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0)\r\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0)\r\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0)\r\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0)\r\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0)\r\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0)\r\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0)\r\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0)\r\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0)\r\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0)\r\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0)\r\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0)\r\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160(\r\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\r\n        );\r\n    }\r\n}\r\n\r\n// File contracts/Farm.sol\r\n\r\n/// @dev verified, public contract\r\ncontract Farm is IFarmEvent {\r\n    using SafeMath for uint256;\r\n    address public NONFUNGIBLE_POSITION_MANAGER_ADDRESS;\r\n\r\n    constructor(bool isTestnet) {\r\n        if (isTestnet) {\r\n            NONFUNGIBLE_POSITION_MANAGER_ADDRESS = Constants\r\n                .TESTNET_NONFUNGIBLE_POSITION_MANAGER_ADDRESS;\r\n        } else {\r\n            NONFUNGIBLE_POSITION_MANAGER_ADDRESS = Constants\r\n                .NONFUNGIBLE_POSITION_MANAGER_ADDRESS;\r\n        }\r\n    }\r\n\r\n    /// @dev deposit liquidity with one of the pair token\r\n    /// @notice if isBNB == true, user needs to transfer BNB to farm contract\r\n    /// @notice if isBNB == false, user needs to approve token to strategy contract\r\n    function depositLiquidity(\r\n        address _strategyContract,\r\n        bool _isBNB,\r\n        address _inputToken,\r\n        uint256 _inputAmount,\r\n        uint256 _swapInAmount,\r\n        uint256 _minimumSwapOutAmount\r\n    ) public payable {\r\n        uint256 shareBeforeDeposit = IStrategyInfo(_strategyContract).userShare(\r\n            msg.sender\r\n        );\r\n\r\n        uint256 increasedToken0Amount;\r\n        uint256 increasedToken1Amount;\r\n        uint256 sendBackToken0Amount;\r\n        uint256 sendBackToken1Amount;\r\n        if (_isBNB) {\r\n            require(msg.value == _inputAmount, \"msg.value != _inputAmount\");\r\n            (\r\n                increasedToken0Amount,\r\n                increasedToken1Amount,\r\n                sendBackToken0Amount,\r\n                sendBackToken1Amount\r\n            ) = IStrategy(_strategyContract).depositLiquidity{\r\n                value: _inputAmount\r\n            }(\r\n                _isBNB,\r\n                msg.sender,\r\n                _inputToken,\r\n                _inputAmount,\r\n                _swapInAmount,\r\n                _minimumSwapOutAmount\r\n            );\r\n        } else {\r\n            (\r\n                increasedToken0Amount,\r\n                increasedToken1Amount,\r\n                sendBackToken0Amount,\r\n                sendBackToken1Amount\r\n            ) = IStrategy(_strategyContract).depositLiquidity(\r\n                _isBNB,\r\n                msg.sender,\r\n                _inputToken,\r\n                _inputAmount,\r\n                _swapInAmount,\r\n                _minimumSwapOutAmount\r\n            );\r\n        }\r\n        uint256 shareAfterDeposit = IStrategyInfo(_strategyContract).userShare(\r\n            msg.sender\r\n        );\r\n\r\n        emit DepositLiquidity(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            _isBNB,\r\n            _inputToken,\r\n            _inputAmount,\r\n            shareAfterDeposit.sub(shareBeforeDeposit),\r\n            shareAfterDeposit,\r\n            increasedToken0Amount,\r\n            increasedToken1Amount,\r\n            sendBackToken0Amount,\r\n            sendBackToken1Amount\r\n        );\r\n    }\r\n\r\n    /// @dev withdraw liquidity\r\n    /// @notice user needs to approve tracker token to strategy contract in withdrawShares amount\r\n    function withdrawLiquidity(\r\n        address _strategyContract,\r\n        uint256 _withdrawShares\r\n    ) public {\r\n        (\r\n            uint256 userReceivedToken0Amount,\r\n            uint256 userReceivedToken1Amount\r\n        ) = IStrategy(_strategyContract).withdrawLiquidity(\r\n                msg.sender,\r\n                _withdrawShares\r\n            );\r\n\r\n        emit WithdrawLiquidity(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            _withdrawShares,\r\n            IStrategyInfo(_strategyContract).userShare(msg.sender),\r\n            userReceivedToken0Amount,\r\n            userReceivedToken1Amount\r\n        );\r\n    }\r\n\r\n    /// @dev claim usdt reward\r\n    function claimReward(address _strategyContract) public {\r\n        uint256 claimedRewardAmount = IStrategyInfo(_strategyContract)\r\n            .userUsdtReward(msg.sender);\r\n        IStrategy(_strategyContract).claimReward(msg.sender);\r\n\r\n        emit ClaimReward(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            claimedRewardAmount\r\n        );\r\n    }\r\n\r\n    /// @dev get estimate deposit used amount\r\n    function getEstimatedUsedDepositToken(\r\n        address _strategyContract,\r\n        uint256 _depositAmount0,\r\n        uint256 _depositAmount1\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 estimatedUsedAmount0, uint256 estimatedUsedAmount1)\r\n    {\r\n        // get tick, tickUpper, tickLower sprt price\r\n        (\r\n            uint160 sqrtPriceX96,\r\n            uint160 sqrtRatioAX96,\r\n            uint160 sqrtRatioBX96\r\n        ) = getSqrtPriceInfo(_strategyContract);\r\n\r\n        uint128 estimatedLiquidity = LiquidityAmounts.getLiquidityForAmounts(\r\n            sqrtPriceX96,\r\n            sqrtRatioAX96,\r\n            sqrtRatioBX96,\r\n            _depositAmount0,\r\n            _depositAmount1\r\n        );\r\n\r\n        (estimatedUsedAmount0, estimatedUsedAmount1) = LiquidityAmounts\r\n            .getAmountsForLiquidity(\r\n                sqrtPriceX96,\r\n                sqrtRatioAX96,\r\n                sqrtRatioBX96,\r\n                estimatedLiquidity\r\n            );\r\n    }\r\n\r\n    function getSqrtPriceInfo(\r\n        address _strategyContract\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            uint160 sqrtRatioAX96,\r\n            uint160 sqrtRatioBX96\r\n        )\r\n    {\r\n        // get poolAddress\r\n        address poolAddress = IStrategyInfo(_strategyContract).poolAddress();\r\n\r\n        // get tick\r\n        (, int24 tick, , , , , ) = IPancakeV3Pool(poolAddress).slot0();\r\n\r\n        // get tickUpper & tickLower\r\n        uint256 liquidityNftId = IStrategyInfo(_strategyContract)\r\n            .liquidityNftId();\r\n\r\n        require(\r\n            liquidityNftId != 0,\r\n            \"not allow calling when liquidityNftId is 0\"\r\n        );\r\n\r\n        (\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS)\r\n                .positions(liquidityNftId);\r\n\r\n        // calculate sqrtPrice\r\n        sqrtPriceX96 = TickMath.getSqrtRatioAtTick(tick);\r\n        sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\r\n        sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\r\n    }\r\n\r\n    function getUserShare(\r\n        address _strategyContract,\r\n        address _userAddress\r\n    ) public view returns (uint256 userShare) {\r\n        return IStrategyInfo(_strategyContract).userShare(_userAddress);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isTestnet\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedRewardAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBNB\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasedShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userShareAfterDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasedToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasedToken1Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendBackToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sendBackToken1Amount\",\"type\":\"uint256\"}],\"name\":\"DepositLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"decreasedShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userShareAfterWithdraw\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userReceivedToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userReceivedToken1Amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawLiquidity\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NONFUNGIBLE_POSITION_MANAGER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBNB\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumSwapOutAmount\",\"type\":\"uint256\"}],\"name\":\"depositLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositAmount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositAmount1\",\"type\":\"uint256\"}],\"name\":\"getEstimatedUsedDepositToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"estimatedUsedAmount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estimatedUsedAmount1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawShares\",\"type\":\"uint256\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Farm", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3174795df5c57ba063949aabeb896c957862d00890756fb61870633a93e37a5b"}