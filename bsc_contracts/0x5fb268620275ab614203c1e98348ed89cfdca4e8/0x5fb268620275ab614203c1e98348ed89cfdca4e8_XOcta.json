{"SourceCode": "// File: contracts/interfaces/IBEP20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/interfaces/IPancakeV2.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IUniRouter {\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function getPair(IBEP20 tokenA, IBEP20 tokenB)\r\n        external\r\n        view\r\n        returns (IUniswapV2Exchange pair);\r\n}\r\n\r\ninterface IUniswapV2Exchange {\r\n    //event Approval(address indexed owner, address indexed spender, uint value);\r\n    //event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    //function name() external pure returns (string memory);\r\n    //function symbol() external pure returns (string memory);\r\n    //function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 _reserve0,\r\n            uint112 _reserve1,\r\n            uint32 _blockTimestampLast\r\n        );\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    //function allowance(address owner, address spender) external view returns (uint);\r\n    //function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    //function transferFrom(address from, address to, uint value) external returns (bool);\r\n    //function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    //function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    //function nonces(address owner) external view returns (uint);\r\n\r\n    //function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    //event Mint(address indexed sender, uint amount0, uint amount1);\r\n    //event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    /*event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n\r\nfunction getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n    */\r\n}\r\n\r\n// File: contracts/interfaces/IMDEX.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IMDEXFactory {\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut,\r\n        address token0,\r\n        address token1\r\n    ) external view returns (uint256 amountOut);\r\n\r\n    function getPairFees(address pair) external view returns (uint256 fee);\r\n}\r\n\r\n// File: contracts/utils/PancakeV2Lib.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ncontract UniswapUtils {\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB)\r\n        internal\r\n        pure\r\n        returns (address token0, address token1)\r\n    {\r\n        //require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        //require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n}\r\n\r\nlibrary UniswapV2ExchangeLib {\r\n    address private constant MDEX_FACTORY =\r\n        0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8;\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function getReturn(\r\n        IUniswapV2Exchange exchange,\r\n        IBEP20 fromToken,\r\n        IBEP20 destToken,\r\n        uint256 amountIn,\r\n        uint256 feeAmount,\r\n        uint256 feeDenominator\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 result,\r\n            bool needSync,\r\n            bool needSkim\r\n        )\r\n    {\r\n        uint256 reserveIn = fromToken.balanceOf(address(exchange));\r\n        uint256 reserveOut = destToken.balanceOf(address(exchange));\r\n        (uint112 reserve0, uint112 reserve1, ) = exchange.getReserves();\r\n        if (fromToken > destToken) {\r\n            (reserve0, reserve1) = (reserve1, reserve0);\r\n        }\r\n        needSync = (reserveIn < reserve0 || reserveOut < reserve1);\r\n        needSkim = !needSync && (reserveIn > reserve0 || reserveOut > reserve1);\r\n\r\n        uint256 amountInWithFee = amountIn * feeAmount;\r\n        uint256 numerator = amountInWithFee * min(reserveOut, reserve1);\r\n        uint256 denominator = min(reserveIn, reserve0) * feeDenominator + amountInWithFee;\r\n        result = (denominator == 0) ? 0 : numerator / denominator;\r\n    }\r\n\r\n    function getReturnMDEX(\r\n        IUniswapV2Exchange exchange,\r\n        IBEP20 fromToken,\r\n        IBEP20 destToken,\r\n        uint256 amountIn\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 result,\r\n            bool needSync,\r\n            bool needSkim\r\n        )\r\n    {\r\n        uint256 reserveIn = fromToken.balanceOf(address(exchange));\r\n        uint256 reserveOut = destToken.balanceOf(address(exchange));\r\n        (uint112 reserve0, uint112 reserve1, ) = exchange.getReserves();\r\n        if (fromToken > destToken) {\r\n            (reserve0, reserve1) = (reserve1, reserve0);\r\n        }\r\n        needSync = (reserveIn < reserve0 || reserveOut < reserve1);\r\n        needSkim = !needSync && (reserveIn > reserve0 || reserveOut > reserve1);\r\n\r\n        IMDEXFactory mdex = IMDEXFactory(MDEX_FACTORY);\r\n        uint256 fee = mdex.getPairFees(address(exchange));\r\n\r\n        uint256 amountInWithFee = amountIn * (1e4 - fee);\r\n        uint256 numerator = amountInWithFee * min(reserveOut, reserve1);\r\n        uint256 denominator = min(reserveIn, reserve0) * 1e4 + amountInWithFee;\r\n        result = (denominator == 0) ? 0 : numerator / denominator;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ICurve.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ICurveFiCurve {\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external virtual;\r\n\r\n    function exchange_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 min_dy\r\n    ) external virtual;\r\n\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view virtual returns (uint256 out);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx\r\n    ) external view virtual returns (uint256 out);\r\n\r\n    function calculateSwap(\r\n        uint8 i,\r\n        uint8 j,\r\n        uint256 dx\r\n    ) external view virtual returns (uint256 out);\r\n\r\n    function swap(\r\n        uint8 i,\r\n        uint8 j,\r\n        uint256 dx,\r\n        uint256 min_dy,\r\n        uint256 deadline\r\n    ) external virtual;\r\n\r\n    function A() external view virtual returns (uint256);\r\n\r\n    function balances(uint256 arg0) external view virtual returns (uint256);\r\n\r\n    function balances(int128 arg0) external view virtual returns (uint256);\r\n\r\n    function getTokenBalance(uint8 arg0)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    function fee() external view virtual returns (uint256);\r\n}\r\n\r\n// File: contracts/utils/CurvedBSC.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev reverse-engineered utils to help Curve amount calculations\r\n */\r\ncontract CurveUtils {\r\n    // Old Belt\r\n    //address internal constant BELT_FACTORY =\r\n    //    0xF16D312d119c13dD27fD0dC814b0bCdcaAa62dfD;\r\n    // New Belt\r\n    //address internal constant BELT_FACTORY =\r\n    //    0xAEA4f7dcd172997947809CE6F12018a6D5c1E8b6;\r\n    address internal constant ACRYPTOS_FACTORY =\r\n        0xb3F0C9ea1F05e312093Fdb031E789A756659B0AC;\r\n    address internal constant VPEGSWAP_FACTORY =\r\n        0x7569f9adabC99780B7A91B16666Bb985177D1DCa;\r\n\r\n    address internal constant NERVE_FACTORY =\r\n        0x1B3771a66ee31180906972580adE9b81AFc5fCDc;\r\n\r\n    address internal constant ELLIPSIS_FACTORY =\r\n        0x8D7408C2b3154F9f97fc6dd24cd36143908d1E52; //TUSD\r\n\r\n    address internal constant ELLIPSIS_BASE_FACTORY =\r\n        0x160CAed03795365F3A589f10C379FfA7d75d4E76; //3EPS\r\n\r\n    address internal constant DAI_ADDRESS =\r\n        0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;\r\n    address internal constant USDC_ADDRESS =\r\n        0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\r\n    address internal constant USDT_ADDRESS =\r\n        0x55d398326f99059fF775485246999027B3197955;\r\n    address internal constant BUSD_ADDRESS =\r\n        0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address internal constant TUSD_ADDRESS =\r\n        0x14016E85a25aeb13065688cAFB43044C2ef86784;\r\n\r\n    mapping(address => mapping(address => int8)) internal curveIndex;\r\n    mapping(address => mapping(int8 => address)) internal reverseCurveIndex;\r\n\r\n    /**\r\n     * @dev get index of a token in Curve pool contract\r\n     */\r\n    function getCurveIndex(address curve, address token)\r\n        internal\r\n        view\r\n        returns (int8)\r\n    {\r\n        // to avoid 'stack too deep' compiler issue\r\n        return curveIndex[curve][token] - 1;\r\n    }\r\n\r\n    /**\r\n     * @dev init internal variables at creation\r\n     */\r\n    function init() public virtual {\r\n        /*\r\n        curveIndex[BELT_FACTORY][DAI_ADDRESS] = 1; // actual index is 1 less\r\n        curveIndex[BELT_FACTORY][USDC_ADDRESS] = 2;\r\n        curveIndex[BELT_FACTORY][USDT_ADDRESS] = 3;\r\n        curveIndex[BELT_FACTORY][BUSD_ADDRESS] = 4;\r\n        reverseCurveIndex[BELT_FACTORY][0] = DAI_ADDRESS;\r\n        reverseCurveIndex[BELT_FACTORY][1] = USDC_ADDRESS;\r\n        reverseCurveIndex[BELT_FACTORY][2] = USDT_ADDRESS;\r\n        reverseCurveIndex[BELT_FACTORY][3] = BUSD_ADDRESS;\r\n        */\r\n\r\n        curveIndex[ACRYPTOS_FACTORY][BUSD_ADDRESS] = 1; // actual index is 1 less\r\n        curveIndex[ACRYPTOS_FACTORY][USDT_ADDRESS] = 2;\r\n        curveIndex[ACRYPTOS_FACTORY][DAI_ADDRESS] = 3;\r\n        curveIndex[ACRYPTOS_FACTORY][USDC_ADDRESS] = 4;\r\n        reverseCurveIndex[ACRYPTOS_FACTORY][0] = BUSD_ADDRESS;\r\n        reverseCurveIndex[ACRYPTOS_FACTORY][1] = USDT_ADDRESS;\r\n        reverseCurveIndex[ACRYPTOS_FACTORY][2] = DAI_ADDRESS;\r\n        reverseCurveIndex[ACRYPTOS_FACTORY][3] = USDC_ADDRESS;\r\n\r\n        curveIndex[VPEGSWAP_FACTORY][DAI_ADDRESS] = 1; // actual index is 1 less\r\n        curveIndex[VPEGSWAP_FACTORY][USDC_ADDRESS] = 2;\r\n        curveIndex[VPEGSWAP_FACTORY][USDT_ADDRESS] = 3;\r\n        curveIndex[VPEGSWAP_FACTORY][BUSD_ADDRESS] = 4;\r\n        reverseCurveIndex[VPEGSWAP_FACTORY][0] = DAI_ADDRESS;\r\n        reverseCurveIndex[VPEGSWAP_FACTORY][1] = USDC_ADDRESS;\r\n        reverseCurveIndex[VPEGSWAP_FACTORY][2] = USDT_ADDRESS;\r\n        reverseCurveIndex[VPEGSWAP_FACTORY][3] = BUSD_ADDRESS;\r\n\r\n        curveIndex[ELLIPSIS_BASE_FACTORY][BUSD_ADDRESS] = 1; // actual index is 1 less\r\n        curveIndex[ELLIPSIS_BASE_FACTORY][USDC_ADDRESS] = 2;\r\n        curveIndex[ELLIPSIS_BASE_FACTORY][USDT_ADDRESS] = 3;\r\n        reverseCurveIndex[ELLIPSIS_BASE_FACTORY][0] = BUSD_ADDRESS;\r\n        reverseCurveIndex[ELLIPSIS_BASE_FACTORY][1] = USDC_ADDRESS;\r\n        reverseCurveIndex[ELLIPSIS_BASE_FACTORY][2] = USDT_ADDRESS;\r\n\r\n        curveIndex[ELLIPSIS_FACTORY][TUSD_ADDRESS] = 1; // actual index is 1 less\r\n        curveIndex[ELLIPSIS_FACTORY][BUSD_ADDRESS] = 2; // actual index is 1 less\r\n        curveIndex[ELLIPSIS_FACTORY][USDC_ADDRESS] = 3;\r\n        curveIndex[ELLIPSIS_FACTORY][USDT_ADDRESS] = 4;\r\n        reverseCurveIndex[ELLIPSIS_FACTORY][0] = TUSD_ADDRESS;\r\n        reverseCurveIndex[ELLIPSIS_FACTORY][1] = BUSD_ADDRESS;\r\n        reverseCurveIndex[ELLIPSIS_FACTORY][2] = USDC_ADDRESS;\r\n        reverseCurveIndex[ELLIPSIS_FACTORY][3] = USDT_ADDRESS;\r\n\r\n        curveIndex[NERVE_FACTORY][BUSD_ADDRESS] = 1; // actual index is 1 less\r\n        curveIndex[NERVE_FACTORY][USDT_ADDRESS] = 2;\r\n        curveIndex[NERVE_FACTORY][USDC_ADDRESS] = 3;\r\n        reverseCurveIndex[NERVE_FACTORY][0] = BUSD_ADDRESS;\r\n        reverseCurveIndex[NERVE_FACTORY][1] = USDT_ADDRESS;\r\n        reverseCurveIndex[NERVE_FACTORY][2] = USDC_ADDRESS;\r\n    }\r\n}\r\n\r\n// File: contracts/access/Context.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function initialize() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IWETH.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: contracts/XOcta.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title XHepta exchanger contract\r\n * @dev this is an implementation of a split exchange that takes the input amount and proposes a better price\r\n * given the liquidity obtained from multiple AMM DEX exchanges considering their liquidity at the moment\r\n * might also help mitigating a flashloan attack\r\n */\r\ncontract XOcta is Ownable, CurveUtils, UniswapUtils {\r\n    //using Address for address;\r\n    using UniswapV2ExchangeLib for IUniswapV2Exchange;\r\n\r\n    IBEP20 private constant ZERO_ADDRESS =\r\n        IBEP20(0x0000000000000000000000000000000000000000);\r\n    IBEP20 private constant ETH_ADDRESS =\r\n        IBEP20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    IBEP20 private constant WBNB_ADDRESS =\r\n        IBEP20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n\r\n    //address public constant TUSD_ADDRESS = 0x14016E85a25aeb13065688cAFB43044C2ef86784;\r\n    //address public constant DAI_ADDRESS = 0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3;\r\n    //address public constant USDC_ADDRESS = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;\r\n    //address public constant USDT_ADDRESS = 0x55d398326f99059fF775485246999027B3197955;\r\n    //address public constant BUSD_ADDRESS = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n\r\n    address private constant PANCAKE_FACTORY =\r\n        0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\r\n\r\n    // OLD ONE IS 0xBCfCcbde45cE874adCB698cC183deBcF17952812\r\n    // NEW ONE IS 0xca143ce32fe78f1f7019d7d551a6402fc5350c73\r\n\r\n    address private constant WAULTSWAP_FACTORY =\r\n        0xB42E3FE71b7E0673335b3331B3e1053BD9822570;\r\n\r\n    address private constant MDEX_FACTORY =\r\n        0x3CD1C46068dAEa5Ebb0d3f55F6915B10648062B8;\r\n\r\n    address private constant BONUS_ADDRESS =\r\n        0x8c545be506a335e24145EdD6e01D2754296ff018;\r\n    IWETH internal constant wbnb = IWETH(address(WBNB_ADDRESS));\r\n\r\n    uint256 private constant PC_DENOMINATOR = 1e5;\r\n    address[] private exchanges = [\r\n        PANCAKE_FACTORY,\r\n        WAULTSWAP_FACTORY,\r\n        MDEX_FACTORY,\r\n        ACRYPTOS_FACTORY,\r\n        VPEGSWAP_FACTORY,\r\n        NERVE_FACTORY,\r\n        ELLIPSIS_FACTORY\r\n    ];\r\n    uint256 private constant ex_count = 7;\r\n    uint256 public slippageFee; //1000 = 1% slippage\r\n    uint256 public minPc;\r\n\r\n    bool private initialized;\r\n\r\n    /** @dev helper to identify if we work with BNB\r\n     */\r\n    function isBNB(IBEP20 token) internal pure returns (bool) {\r\n        return (address(token) == address(ZERO_ADDRESS) ||\r\n            address(token) == address(ETH_ADDRESS));\r\n    }\r\n\r\n    /** @dev helper to identify if we work with WBNB\r\n     */\r\n    function isWBNB(IBEP20 token) internal pure returns (bool) {\r\n        return (address(token) == address(WBNB_ADDRESS));\r\n    }\r\n\r\n    /** @dev helper to identify if we work with BNB or WBNB\r\n     */\r\n    function isofBNB(IBEP20 token) internal pure returns (bool) {\r\n        return (address(token) == address(ZERO_ADDRESS) ||\r\n            address(token) == address(ETH_ADDRESS) ||\r\n            address(token) == address(WBNB_ADDRESS));\r\n    }\r\n\r\n    /**\r\n     * @dev initializer method instead of a constructor - though we don't normally use proxy here we still might want to\r\n     */\r\n    function init() public virtual override {\r\n        require(!initialized, \"Initialized\");\r\n        initialized = true;\r\n        Ownable.initialize(); // Do not forget this call!\r\n        _init();\r\n    }\r\n\r\n    /**\r\n     * @dev internal variable initialization\r\n     */\r\n    function _init() internal virtual {\r\n        slippageFee = 1000; //1%\r\n        minPc = 15000; // 10%\r\n        CurveUtils.init();\r\n    }\r\n\r\n    /**\r\n     * @dev re-initializer might be helpful for the cases where proxy's storage is corrupted by an old contact, but we cannot run init as we have the owner address already.\r\n     * This method might help fixing the storage state.\r\n     */\r\n    function reInit() public virtual onlyOwner {\r\n        _init();\r\n    }\r\n\r\n    /**\r\n     * @dev set the slippage %%\r\n     */\r\n    function setMinPc(uint256 _minPC) external onlyOwner {\r\n        minPc = _minPC;\r\n    }\r\n\r\n    /**\r\n     * @dev set the slippage %%\r\n     */\r\n    function setSlippageFee(uint256 _slippageFee) external onlyOwner {\r\n        slippageFee = _slippageFee;\r\n    }\r\n\r\n    /**\r\n     * @dev universal method to get the given AMM address reserves\r\n     */\r\n    function getReserves(\r\n        IBEP20 fromToken,\r\n        IBEP20 toToken,\r\n        address factory\r\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\r\n        IBEP20 _from = isBNB(fromToken) ? WBNB_ADDRESS : fromToken;\r\n        IBEP20 _to = isBNB(toToken) ? WBNB_ADDRESS : toToken;\r\n\r\n        address fromAddress = address(_from);\r\n        address toAddress = address(_to);\r\n\r\n        if (\r\n            factory == PANCAKE_FACTORY ||\r\n            factory == WAULTSWAP_FACTORY ||\r\n            factory == MDEX_FACTORY\r\n        ) {\r\n            //CAKE or WAULT\r\n            IUniswapV2Factory uniFactory = IUniswapV2Factory(factory);\r\n            IUniswapV2Exchange pair = uniFactory.getPair(_from, _to);\r\n\r\n            if (address(pair) != address(0)) {\r\n                (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n\r\n                (address token0, ) = sortTokens(fromAddress, toAddress);\r\n                (reserveA, reserveB) = fromAddress == token0\r\n                    ? (reserve0, reserve1)\r\n                    : (reserve1, reserve0);\r\n            }\r\n        } else {\r\n            // CURVE\r\n            int8 fromIndex = curveIndex[factory][fromAddress];\r\n            int8 toIndex = curveIndex[factory][toAddress];\r\n            ICurveFiCurve curve = ICurveFiCurve(factory);\r\n\r\n            reserveA = 0;\r\n            reserveB = 0;\r\n            if (fromIndex > 0 && toIndex > 0) {\r\n                if (factory == VPEGSWAP_FACTORY || factory == NERVE_FACTORY) {\r\n                    //uint8 index\r\n                    reserveA = curve.getTokenBalance(\r\n                        uint8(getCurveIndex(factory, fromAddress))\r\n                    );\r\n                    reserveB = curve.getTokenBalance(\r\n                        uint8(getCurveIndex(factory, toAddress))\r\n                    );\r\n                } else if (factory == ACRYPTOS_FACTORY) {\r\n                    reserveA = curve.balances(\r\n                        uint256(uint8(getCurveIndex(factory, fromAddress)))\r\n                    );\r\n                    reserveB = curve.balances(\r\n                        uint256(uint8(getCurveIndex(factory, toAddress)))\r\n                    );\r\n                } else if (factory == ELLIPSIS_FACTORY) {\r\n                    if (fromIndex > 1) {\r\n                        //Ellipsis TUSD - change index and factory to base\r\n                        reserveA = ICurveFiCurve(ELLIPSIS_BASE_FACTORY)\r\n                            .balances(\r\n                                uint256(\r\n                                    uint8(\r\n                                        getCurveIndex(\r\n                                            ELLIPSIS_BASE_FACTORY,\r\n                                            fromAddress\r\n                                        )\r\n                                    )\r\n                                )\r\n                            );\r\n                    } else {\r\n                        reserveA = curve.balances(\r\n                            uint256(uint8(getCurveIndex(factory, fromAddress)))\r\n                        );\r\n                    }\r\n\r\n                    if (toIndex > 1) {\r\n                        //Ellipsis TUSD - change index and factory to base\r\n                        reserveB = ICurveFiCurve(ELLIPSIS_BASE_FACTORY)\r\n                            .balances(\r\n                                uint256(\r\n                                    uint8(\r\n                                        getCurveIndex(\r\n                                            ELLIPSIS_BASE_FACTORY,\r\n                                            toAddress\r\n                                        )\r\n                                    )\r\n                                )\r\n                            );\r\n                    } else {\r\n                        reserveB = curve.balances(\r\n                            uint256(uint8(getCurveIndex(factory, toAddress)))\r\n                        );\r\n                    }\r\n                } else {\r\n                    //BELT is int128\r\n                    reserveA = curve.balances(\r\n                        int128(getCurveIndex(factory, fromAddress))\r\n                    );\r\n                    reserveB = curve.balances(\r\n                        int128(getCurveIndex(factory, toAddress))\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Method to get the full reserves for the 2 token to be exchanged plus the proposed distribution to obtain the best price\r\n     */\r\n\r\n    function getFullReserves(IBEP20 fromToken, IBEP20 toToken)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 fromTotal,\r\n            uint256 destTotal,\r\n            uint256[ex_count] memory dist,\r\n            uint256[2][ex_count] memory res\r\n        )\r\n    {\r\n        for (uint256 i = 0; i < ex_count; i++) {\r\n            (uint256 balance0, uint256 balance1) = getReserves(\r\n                fromToken,\r\n                toToken,\r\n                exchanges[i]\r\n            );\r\n            fromTotal += balance0;\r\n            destTotal += balance1; //balance1 is toToken and the bigger it is  the juicier for us\r\n\r\n            (res[i][0], res[i][1]) = (balance0, balance1);\r\n        }\r\n\r\n        if (destTotal > 0) {\r\n            for (uint256 i = 0; i < ex_count; i++) {\r\n                dist[i] = (res[i][1] * PC_DENOMINATOR) / destTotal;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Standard Uniswap V2 way to calculate the output amount given the input amount\r\n     */\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) internal pure returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * 998; // Pancake is cheaper\r\n        uint256 numerator = amountInWithFee * reserveOut;\r\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    /**\r\n     * @dev Method to get a direct quote between the given tokens - might not be always available\r\n     * as there might not be any direct liquidity between them\r\n     */\r\n    function quoteDirect(\r\n        IBEP20 fromToken,\r\n        IBEP20 toToken,\r\n        uint256 amount\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 returnAmount, uint256[ex_count] memory swapAmounts)\r\n    {\r\n        (\r\n            ,\r\n            ,\r\n            uint256[ex_count] memory distribution,\r\n            uint256[2][ex_count] memory reserves\r\n        ) = getFullReserves(fromToken, toToken);\r\n\r\n        uint256 addDistribution;\r\n        uint256 eligible;\r\n        uint256 lastNonZeroIndex;\r\n\r\n        for (uint256 i = 0; i < ex_count; i++) {\r\n            if (distribution[i] > minPc) {\r\n                lastNonZeroIndex = i;\r\n                eligible++;\r\n            } else {\r\n                addDistribution += distribution[i];\r\n                distribution[i] = 0;\r\n            }\r\n        }\r\n\r\n        uint256 remainingAmount = amount;\r\n        address fromAddress = address(fromToken);\r\n        address toAddress = address(toToken);\r\n\r\n        for (uint256 i = 0; i <= lastNonZeroIndex; i++) {\r\n            if (distribution[i] > 0) {\r\n                if (addDistribution > 0) {\r\n                    distribution[i] += addDistribution / eligible;\r\n                }\r\n\r\n                if (i == lastNonZeroIndex) {\r\n                    swapAmounts[i] = remainingAmount;\r\n                } else {\r\n                    swapAmounts[i] =\r\n                        (amount * distribution[i]) /\r\n                        PC_DENOMINATOR;\r\n                }\r\n\r\n                if (\r\n                    exchanges[i] == PANCAKE_FACTORY ||\r\n                    exchanges[i] == WAULTSWAP_FACTORY\r\n                ) {\r\n                    returnAmount += getAmountOut(\r\n                        swapAmounts[i],\r\n                        reserves[i][0],\r\n                        reserves[i][1]\r\n                    );\r\n                } else if (exchanges[i] == MDEX_FACTORY) {\r\n                    IMDEXFactory mdex = IMDEXFactory(MDEX_FACTORY);\r\n                    try\r\n                        mdex.getAmountOut(\r\n                            swapAmounts[i],\r\n                            reserves[i][0],\r\n                            reserves[i][1],\r\n                            fromAddress,\r\n                            toAddress\r\n                        )\r\n                    returns (uint256 _returnAmount) {\r\n                        returnAmount += _returnAmount;\r\n                    } catch {}\r\n                } else {\r\n                    ICurveFiCurve curve = ICurveFiCurve(exchanges[i]);\r\n\r\n                    if (\r\n                        exchanges[i] == ACRYPTOS_FACTORY ||\r\n                        exchanges[i] == ELLIPSIS_FACTORY\r\n                    ) {\r\n                        returnAmount += curve.get_dy_underlying(\r\n                            int128(getCurveIndex(exchanges[i], fromAddress)),\r\n                            int128(getCurveIndex(exchanges[i], toAddress)),\r\n                            swapAmounts[i]\r\n                        );\r\n                    } else {\r\n                        returnAmount += curve.calculateSwap(\r\n                            uint8(getCurveIndex(exchanges[i], fromAddress)),\r\n                            uint8(getCurveIndex(exchanges[i], toAddress)),\r\n                            swapAmounts[i]\r\n                        );\r\n                    }\r\n                }\r\n                remainingAmount -= swapAmounts[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Method to get a best quote between the direct and through the WETH -\r\n     * as there is more liquidity between token/ETH than token0/token1\r\n     */\r\n    function quote(\r\n        IBEP20 fromToken,\r\n        IBEP20 toToken,\r\n        uint256 amount\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 returnAmount,\r\n            uint256[ex_count] memory swapAmountsIn,\r\n            uint256[ex_count] memory swapAmountsOut,\r\n            bool swapVia\r\n        )\r\n    {\r\n        if (fromToken == toToken) {\r\n            returnAmount = amount;\r\n        } else {\r\n            ///TODO: quoteDirect gives revert\r\n            (\r\n                uint256 returnAmountDirect,\r\n                uint256[ex_count] memory swapAmounts1\r\n            ) = quoteDirect(fromToken, toToken, amount);\r\n            returnAmount = returnAmountDirect;\r\n            swapAmountsIn = swapAmounts1;\r\n\r\n            uint256 returnAmountVia;\r\n            uint256[ex_count] memory swapAmounts2;\r\n            uint256[ex_count] memory swapAmounts3;\r\n\r\n            if (!isofBNB(toToken) && !isofBNB(fromToken)) {\r\n                (returnAmountVia, swapAmounts2, swapAmounts3) = getReturnVia(\r\n                    fromToken,\r\n                    toToken,\r\n                    amount,\r\n                    WBNB_ADDRESS\r\n                );\r\n\r\n                if (returnAmountVia > returnAmountDirect) {\r\n                    returnAmount = returnAmountVia;\r\n                    swapAmountsIn = swapAmounts2;\r\n                    swapAmountsOut = swapAmounts3;\r\n                    swapVia = true;\r\n                }\r\n            }\r\n\r\n            /*\r\n            if (\r\n                toToken != IBEP20(BUSD_ADDRESS) &&\r\n                fromToken != IBEP20(BUSD_ADDRESS)\r\n            ) {\r\n                (returnAmountVia, swapAmounts2, swapAmounts3) = getReturnVia(\r\n                    fromToken,\r\n                    toToken,\r\n                    amount,\r\n                    IBEP20(BUSD_ADDRESS)\r\n                );\r\n\r\n                if (returnAmountVia > returnAmountDirect) {\r\n                    returnAmount = returnAmountVia;\r\n                    swapAmountsIn = swapAmounts2;\r\n                    swapAmountsOut = swapAmounts3;\r\n                    swapVia = true;\r\n                }\r\n            }*/\r\n        }\r\n    }\r\n\r\n    function getReturnVia(\r\n        IBEP20 fromToken,\r\n        IBEP20 toToken,\r\n        uint256 amount,\r\n        IBEP20 viaToken\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256[ex_count] memory,\r\n            uint256[ex_count] memory\r\n        )\r\n    {\r\n        (\r\n            uint256 returnAmountETH,\r\n            uint256[ex_count] memory swapAmounts2\r\n        ) = quoteDirect(fromToken, viaToken, amount);\r\n        (\r\n            uint256 returnAmountVia,\r\n            uint256[ex_count] memory swapAmounts3\r\n        ) = quoteDirect(viaToken, toToken, returnAmountETH);\r\n\r\n        return (returnAmountVia, swapAmounts2, swapAmounts3);\r\n    }\r\n\r\n    /**\r\n     * @dev run a swap across multiple exchanges given the splitted amounts\r\n     * @param swapAmounts - array of splitted amounts\r\n     */\r\n    function executeSwap(\r\n        IBEP20 fromToken,\r\n        IBEP20 toToken,\r\n        uint256[ex_count] memory swapAmounts\r\n    ) internal returns (uint256 returnAmount) {\r\n        for (uint256 i = 0; i < swapAmounts.length; i++) {\r\n            if (swapAmounts[i] > 0) {\r\n                uint256 thisBalance = fromToken.balanceOf(address(this));\r\n                uint256 swapAmount = min(thisBalance, swapAmounts[i]);\r\n\r\n                if (\r\n                    exchanges[i] == PANCAKE_FACTORY ||\r\n                    exchanges[i] == WAULTSWAP_FACTORY ||\r\n                    exchanges[i] == MDEX_FACTORY\r\n                ) {\r\n                    returnAmount += _swapOnUniswapV2Internal(\r\n                        fromToken,\r\n                        toToken,\r\n                        swapAmount,\r\n                        exchanges[i]\r\n                    );\r\n                } else {\r\n                    returnAmount += _swapOnCurve(\r\n                        fromToken,\r\n                        toToken,\r\n                        swapAmount,\r\n                        exchanges[i]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Main function to run a swap\r\n     * @param slipProtect - enable/disable slip protection\r\n     */\r\n    function swap(\r\n        IBEP20 fromToken,\r\n        IBEP20 toToken,\r\n        uint256 amount,\r\n        bool slipProtect\r\n    ) public payable virtual returns (uint256 returnAmount) {\r\n        if (fromToken == toToken) {\r\n            return amount;\r\n        }\r\n\r\n        if (isBNB(fromToken)) {\r\n            amount = msg.value;\r\n            wbnb.deposit{value: amount}();\r\n            fromToken = WBNB_ADDRESS;\r\n        } else {\r\n            fromToken.transferFrom(msg.sender, address(this), amount);\r\n        }\r\n\r\n        amount = min(fromToken.balanceOf(address(this)), amount);\r\n\r\n        (\r\n            uint256 returnQuoteAmount,\r\n            uint256[ex_count] memory swapAmountsIn,\r\n            uint256[ex_count] memory swapAmountsOut,\r\n            bool swapVia\r\n        ) = quote(fromToken, toToken, amount);\r\n\r\n        uint256 minAmount;\r\n        if (slipProtect) {\r\n            uint256 feeSlippage = (returnQuoteAmount * slippageFee) /\r\n                PC_DENOMINATOR;\r\n            minAmount = returnQuoteAmount - feeSlippage;\r\n        }\r\n\r\n        if (swapVia) {\r\n            executeSwap(fromToken, WBNB_ADDRESS, swapAmountsIn);\r\n            returnAmount = executeSwap(WBNB_ADDRESS, toToken, swapAmountsOut);\r\n        } else {\r\n            returnAmount = executeSwap(fromToken, toToken, swapAmountsIn);\r\n        }\r\n        require(returnAmount >= minAmount, \"Slippage is too high\");\r\n\r\n        //FIX For WBNB below vvv\r\n        if (isBNB(toToken)) {\r\n            wbnb.withdraw(IBEP20(WBNB_ADDRESS).balanceOf(address(this)));\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        } else {\r\n            toToken.transfer(msg.sender, returnAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev fallback function to withdraw tokens from contract\r\n     * - not normally needed\r\n     */\r\n    function transferTokenBack(address TokenAddress)\r\n        external\r\n        onlyOwner\r\n        returns (uint256 returnBalance)\r\n    {\r\n        IBEP20 Token = IBEP20(TokenAddress);\r\n        returnBalance = Token.balanceOf(address(this));\r\n        if (returnBalance > 0) {\r\n            Token.transfer(msg.sender, returnBalance);\r\n        }\r\n    }\r\n\r\n    function _swapOnCurve(\r\n        IBEP20 fromToken,\r\n        IBEP20 destToken,\r\n        uint256 amount,\r\n        address exchange\r\n    ) internal returns (uint256 returnAmount) {\r\n        //using curve\r\n        ICurveFiCurve curve = ICurveFiCurve(exchange);\r\n        if (fromToken.allowance(address(this), exchange) < amount) {\r\n            fromToken.approve(exchange, 0);\r\n            fromToken.approve(exchange, type(uint256).max);\r\n        }\r\n\r\n        uint256 startBalance = destToken.balanceOf(address(this));\r\n\r\n        // actual index is -1\r\n        if (exchange == VPEGSWAP_FACTORY || exchange == NERVE_FACTORY) {\r\n            curve.swap(\r\n                uint8(getCurveIndex(exchange, address(fromToken))),\r\n                uint8(getCurveIndex(exchange, address(destToken))),\r\n                amount,\r\n                0,\r\n                type(uint256).max\r\n            );\r\n        } else if (exchange == ELLIPSIS_FACTORY) {\r\n            curve.exchange_underlying(\r\n                int128(getCurveIndex(exchange, address(fromToken))),\r\n                int128(getCurveIndex(exchange, address(destToken))),\r\n                amount,\r\n                0\r\n            );\r\n        } else {\r\n            curve.exchange(\r\n                int128(getCurveIndex(exchange, address(fromToken))),\r\n                int128(getCurveIndex(exchange, address(destToken))),\r\n                amount,\r\n                0\r\n            );\r\n        }\r\n\r\n        return destToken.balanceOf(address(this)) - startBalance;\r\n    }\r\n\r\n    function _swapOnUniswapV2Internal(\r\n        IBEP20 fromToken,\r\n        IBEP20 destToken,\r\n        uint256 amount,\r\n        address factory\r\n    ) internal returns (uint256 returnAmount) {\r\n        destToken = isBNB(destToken) ? WBNB_ADDRESS : destToken;\r\n        IUniswapV2Factory uniFactory = IUniswapV2Factory(factory);\r\n        IUniswapV2Exchange exchange = uniFactory.getPair(fromToken, destToken);\r\n        bool needSync;\r\n        bool needSkim;\r\n\r\n        if (factory == MDEX_FACTORY) {\r\n            (returnAmount, needSync, needSkim) = exchange.getReturnMDEX(\r\n                fromToken,\r\n                destToken,\r\n                amount\r\n            );\r\n        } else if (factory == PANCAKE_FACTORY) {\r\n            (returnAmount, needSync, needSkim) = exchange.getReturn(\r\n                fromToken,\r\n                destToken,\r\n                amount,\r\n                9975,\r\n                10000\r\n            );\r\n        } else {\r\n            (returnAmount, needSync, needSkim) = exchange.getReturn(\r\n                fromToken,\r\n                destToken,\r\n                amount,\r\n                998,\r\n                1000\r\n            );\r\n        }\r\n\r\n        if (needSync) {\r\n            exchange.sync();\r\n        } else if (needSkim) {\r\n            exchange.skim(BONUS_ADDRESS);\r\n        }\r\n\r\n        fromToken.transfer(address(exchange), amount);\r\n        if (uint160(address(fromToken)) < uint160(address(destToken))) {\r\n            exchange.swap(0, returnAmount, address(this), \"\");\r\n        } else {\r\n            exchange.swap(returnAmount, 0, address(this), \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev payable fallback to allow for WBNB withdrawal\r\n     */\r\n    receive() external payable {}\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"getFullReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256[7]\",\"name\":\"dist\",\"type\":\"uint256[7]\"},{\"internalType\":\"uint256[2][7]\",\"name\":\"res\",\"type\":\"uint256[2][7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[7]\",\"name\":\"swapAmountsIn\",\"type\":\"uint256[7]\"},{\"internalType\":\"uint256[7]\",\"name\":\"swapAmountsOut\",\"type\":\"uint256[7]\"},{\"internalType\":\"bool\",\"name\":\"swapVia\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"quoteDirect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[7]\",\"name\":\"swapAmounts\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPC\",\"type\":\"uint256\"}],\"name\":\"setMinPc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippageFee\",\"type\":\"uint256\"}],\"name\":\"setSlippageFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"contract IBEP20\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"slipProtect\",\"type\":\"bool\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"}],\"name\":\"transferTokenBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "XOcta", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c27cd37bd5ffb2a0039f7365ffa5d4f756f812caf3b2d88f1edf05553fff08e4"}