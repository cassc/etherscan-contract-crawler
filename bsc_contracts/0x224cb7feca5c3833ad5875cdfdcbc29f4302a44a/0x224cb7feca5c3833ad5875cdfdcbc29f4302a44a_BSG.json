{"SourceCode": "{\"BSG.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\r\\n\\r\\n/**\\r\\n  888888b.                           .d8888b.           888 d8b 888          .d8888b.                                  \\r\\n  888  \\\"88b                         d88P  Y88b          888 Y8P 888         d88P  Y88b                                 \\r\\n  888  .88P                         Y88b.               888     888         888    888                                 \\r\\n  8888888K.  .d8888b   .d8888b       \\\"Y888b.   88888b.  888 888 888888      888         8888b.  88888b.d88b.   .d88b.  \\r\\n  888  \\\"Y88b 88K      d88P\\\"             \\\"Y88b. 888 \\\"88b 888 888 888         888  88888     \\\"88b 888 \\\"888 \\\"88b d8P  Y8b \\r\\n  888    888 \\\"Y8888b. 888                 \\\"888 888  888 888 888 888         888    888 .d888888 888  888  888 88888888 \\r\\n  888   d88P      X88 Y88b.         Y88b  d88P 888 d88P 888 888 Y88b.       Y88b  d88P 888  888 888  888  888 Y8b.     \\r\\n  8888888P\\\"   88888P\\u0027  \\\"Y8888P       \\\"Y8888P\\\"  88888P\\\"  888 888  \\\"Y888       \\\"Y8888P88 \\\"Y888888 888  888  888  \\\"Y8888  \\r\\n                                               888                                                                     \\r\\n                                               888                                                                     \\r\\n                                               888              \\r\\n**/\\r\\n\\r\\npragma solidity ^0.8.18;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract BSG {\\r\\n    using SafeMath for uint256; \\r\\n    uint256 private constant timeStep = 1 days;\\r\\n    uint256 private constant dayPerCycle = 10 days; \\r\\n    uint256 private constant maxAddFreeze = 30 days;\\r\\n    uint256 private constant predictDuration = 30 minutes;\\r\\n    uint256 private constant initDayNewbies = 5;\\r\\n    uint256 private constant incInterval = 2;\\r\\n    uint256 private constant incNumber = 1;\\r\\n    uint256 private constant unlimitDay = 365;\\r\\n    uint256 private constant predictFee = 1e18;\\r\\n    uint256 private constant dayPredictLimit = 10;\\r\\n    uint256 private constant maxSearchDepth = 3000;\\r\\n    uint256 private constant baseDividend = 10000;\\r\\n    uint256 private constant incomeFeePercents = 500;\\r\\n    uint256 private constant bonusPercents = 500;\\r\\n    uint256 private constant splitPercents = 3000;\\r\\n    uint256 private constant transferFeePercents = 1000;\\r\\n    uint256 private constant dayRewardPercents = 150;\\r\\n    uint256 private constant predictPoolPercents = 300;\\r\\n    uint256 private constant unfreezeWithoutIncomePercents = 15000;\\r\\n    uint256 private constant unfreezeWithIncomePercents = 20000;\\r\\n    uint256[5] private levelTeam = [0, 0, 0, 50, 200];\\r\\n    uint256[5] private levelInvite = [0, 0, 0, 10000e18, 20000e18];\\r\\n    uint256[5] private levelDeposit = [50e18, 500e18, 1000e18, 2000e18, 3000e18];\\r\\n    uint256[5] private balReached = [50e22, 100e22, 200e22, 500e22, 1000e22];\\r\\n    uint256[5] private balFreeze = [35e22, 70e22, 100e22, 300e22, 500e22];\\r\\n    uint256[5] private balUnfreeze = [80e22, 150e22, 200e22, 500e22, 1000e22];\\r\\n    uint256[20] private invitePercents = [500, 100, 200, 300, 200, 100, 100, 100, 50, 50, 50, 50, 30, 30, 30, 30, 30, 30, 30, 30];\\r\\n    uint256[20] private predictWinnerPercents = [3000, 2000, 1000, 500, 500, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200];\\r\\n\\r\\n    IERC20 private usdt;\\r\\n    address private feeReceiver;\\r\\n    address private defaultRefer;\\r\\n    uint256 private startTime;\\r\\n    uint256 private lastDistribute;\\r\\n    uint256 private totalUsers;\\r\\n    uint256 private totalDeposit;\\r\\n    uint256 private freezedTimes;\\r\\n    uint256 private predictPool;\\r\\n    uint256 private totalPredictPool;\\r\\n    uint256 private totalWinners;\\r\\n    bool private isFreezing;\\r\\n    address[] private depositors;\\r\\n    mapping(uint256=\\u003ebool) private balStatus;\\r\\n    mapping(uint256=\\u003eaddress[]) private dayNewbies;\\r\\n    mapping(uint256=\\u003euint256) private freezeTime;\\r\\n    mapping(uint256=\\u003euint256) private unfreezeTime;\\r\\n    mapping(uint256=\\u003euint256) private dayPredictPool;\\r\\n    mapping(uint256=\\u003euint256) private dayDeposits;\\r\\n    mapping(address=\\u003emapping(uint256=\\u003ebool)) private isUnfreezedReward;\\r\\n    mapping(uint256=\\u003emapping(uint256=\\u003eaddress[])) private dayPredictors;\\r\\n    mapping(uint256=\\u003emapping(address=\\u003ePredictInfo[])) private userPredicts;\\r\\n    \\r\\n    struct UserInfo {\\r\\n        address referrer;\\r\\n        uint256 level;\\r\\n        uint256 maxDeposit;\\r\\n        uint256 maxDepositable;\\r\\n        uint256 teamNum;\\r\\n        uint256 teamTotalDeposit;\\r\\n        uint256 totalFreezed;\\r\\n        uint256 totalRevenue;\\r\\n        uint256 unfreezeIndex;\\r\\n        uint256 startTime;\\r\\n        bool isMaxFreezing;\\r\\n    }\\r\\n    struct RewardInfo{\\r\\n        uint256 capitals;\\r\\n        uint256 statics;\\r\\n        uint256 invited;\\r\\n        uint256 bonusFreezed;\\r\\n        uint256 bonusReleased;\\r\\n        uint256 l5Freezed;\\r\\n        uint256 l5Released;\\r\\n        uint256 predictWin;\\r\\n        uint256 split;\\r\\n        uint256 lastWithdaw;\\r\\n    }\\r\\n    struct OrderInfo {\\r\\n        uint256 amount;\\r\\n        uint256 start;\\r\\n        uint256 unfreeze;\\r\\n        bool isUnfreezed;\\r\\n    }\\r\\n    struct PredictInfo {\\r\\n        uint256 time;\\r\\n        uint256 number;\\r\\n    }\\r\\n    mapping(address=\\u003eUserInfo) private userInfo;\\r\\n    mapping(address=\\u003eRewardInfo) private rewardInfo;\\r\\n    mapping(address=\\u003eOrderInfo[]) private orderInfos;\\r\\n    mapping(address=\\u003emapping(uint256=\\u003euint256)) private userCycleMax;\\r\\n    mapping(address=\\u003emapping(uint256=\\u003eaddress[])) private teamUsers;\\r\\n\\r\\n    event Register(address user, address referral);\\r\\n    event Deposit(address user, uint256 types, uint256 amount, bool isFreezing);\\r\\n    event TransferBySplit(address user, uint256 subBal, address receiver, uint256 amount);\\r\\n    event Withdraw(address user, uint256 incomeFee, uint256 poolFee, uint256 split, uint256 withdraw);\\r\\n    event Predict(uint256 time, address user, uint256 amount);\\r\\n    event DistributePredictPool(uint256 day, uint256 reward, uint256 pool, uint256 time);\\r\\n\\r\\n    constructor(address _usdtAddr, address _defaultRefer, address _feeReceiver, uint256 _startTime) {\\r\\n        usdt = IERC20(_usdtAddr);\\r\\n        defaultRefer = _defaultRefer;\\r\\n        feeReceiver = _feeReceiver;\\r\\n        startTime = _startTime;\\r\\n        lastDistribute = _startTime;\\r\\n    }\\r\\n\\r\\n    function register(address _referral) external {\\r\\n        require(userInfo[_referral].maxDeposit \\u003e 0 || _referral == defaultRefer, \\\"invalid refer\\\");\\r\\n        require(userInfo[msg.sender].referrer == address(0), \\\"referrer bonded\\\");\\r\\n        userInfo[msg.sender].referrer = _referral;\\r\\n        emit Register(msg.sender, _referral);\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 _amount) external {\\r\\n        _deposit(msg.sender, _amount, 0);\\r\\n    }\\r\\n\\r\\n    function depositBySplit(uint256 _amount) public {\\r\\n        _deposit(msg.sender, _amount, 1);\\r\\n\\r\\n    }\\r\\n\\r\\n    function redeposit() public {\\r\\n        _deposit(msg.sender, 0, 2);\\r\\n    }\\r\\n\\r\\n    function _deposit(address _userAddr, uint256 _amount, uint256 _types) private {\\r\\n        require(block.timestamp \\u003e= startTime, \\\"not start\\\");\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        require(user.referrer != address(0), \\\"not register\\\");\\r\\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\\r\\n        if(_types == 0){\\r\\n            usdt.transferFrom(_userAddr, address(this), _amount);\\r\\n            _balActived();\\r\\n        }else if(_types == 1){\\r\\n            require(user.level == 0, \\\"actived\\\");\\r\\n            require(userRewards.split \\u003e= _amount, \\\"insufficient\\\");\\r\\n            require(_amount.mod(levelDeposit[0].mul(2)) == 0, \\\"amount err\\\");\\r\\n            userRewards.split = userRewards.split.sub(_amount);\\r\\n        }else{\\r\\n            require(user.level \\u003e 0, \\\"newbie\\\");\\r\\n            _amount = orderInfos[_userAddr][user.unfreezeIndex].amount;\\r\\n        }\\r\\n\\r\\n        uint256 curCycle = getCurCycle();\\r\\n        (uint256 userCurMin, uint256 userCurMax) = getUserCycleDepositable(_userAddr, curCycle);\\r\\n        require(_amount \\u003e= userCurMin \\u0026\\u0026 _amount \\u003c= userCurMax \\u0026\\u0026 _amount.mod(levelDeposit[0]) == 0, \\\"amount err\\\");\\r\\n        if(isFreezing \\u0026\\u0026 !isUnfreezedReward[_userAddr][freezedTimes]) isUnfreezedReward[_userAddr][freezedTimes] = true;\\r\\n        \\r\\n        uint256 curDay = getCurDay();\\r\\n        dayDeposits[curDay] = dayDeposits[curDay].add(_amount);\\r\\n        totalDeposit = totalDeposit.add(_amount);\\r\\n        depositors.push(_userAddr);\\r\\n\\r\\n        if(user.level == 0){\\r\\n            if(curDay \\u003c unlimitDay) require(dayNewbies[curDay].length \\u003c getMaxDayNewbies(curDay), \\\"reach max\\\");\\r\\n            dayNewbies[curDay].push(_userAddr);\\r\\n            totalUsers = totalUsers + 1;\\r\\n            user.startTime = block.timestamp;\\r\\n            if(_types == 0) {\\r\\n                userRewards.bonusFreezed = _amount.mul(bonusPercents).div(baseDividend);\\r\\n                user.totalRevenue = user.totalRevenue.add(userRewards.bonusFreezed);\\r\\n            }\\r\\n        }\\r\\n        _updateUplineReward(_userAddr, _amount);\\r\\n        _unfreezeCapitalOrReward(_userAddr, _amount, _types);\\r\\n        bool isMaxFreezing = _addNewOrder(_userAddr, _amount, _types, user.startTime, user.isMaxFreezing);\\r\\n        user.isMaxFreezing = isMaxFreezing;\\r\\n        _updateUserMax(_userAddr, _amount, userCurMax, curCycle);\\r\\n        _updateLevel(_userAddr);\\r\\n        if(isFreezing) _setFreezeReward();\\r\\n        emit Deposit(_userAddr, _types, _amount, isFreezing);\\r\\n    }\\r\\n\\r\\n    function _updateUplineReward(address _userAddr, uint256 _amount) private {\\r\\n        address upline = userInfo[_userAddr].referrer;\\r\\n        for(uint256 i = 0; i \\u003c invitePercents.length; i++){\\r\\n            if(upline != address(0)){\\r\\n                if(!isFreezing || isUnfreezedReward[upline][freezedTimes]){\\r\\n                    OrderInfo[] storage upOrders = orderInfos[upline];\\r\\n                    if(upOrders.length \\u003e 0){\\r\\n                        uint256 latestUnFreezeTime = getOrderUnfreezeTime(upline, upOrders.length - 1);\\r\\n                        uint256 maxFreezing = latestUnFreezeTime \\u003e block.timestamp ? upOrders[upOrders.length - 1].amount : 0;\\r\\n                        uint256 newAmount = maxFreezing \\u003c _amount ? maxFreezing : _amount;\\r\\n                        if(newAmount \\u003e 0){\\r\\n                            RewardInfo storage upRewards = rewardInfo[upline];\\r\\n                            uint256 reward = newAmount.mul(invitePercents[i]).div(baseDividend);\\r\\n                            if(i == 0 || (i \\u003c 4 \\u0026\\u0026 userInfo[upline].level \\u003e= 4)){\\r\\n                                upRewards.invited = upRewards.invited.add(reward);\\r\\n                                userInfo[upline].totalRevenue = userInfo[upline].totalRevenue.add(reward);\\r\\n                            }else if(userInfo[upline].level \\u003e= 5){\\r\\n                                upRewards.l5Freezed = upRewards.l5Freezed.add(reward);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                if(upline == defaultRefer) break;\\r\\n                upline = userInfo[upline].referrer;\\r\\n            }else{\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _unfreezeCapitalOrReward(address _userAddr, uint256 _amount, uint256 _types) private {\\r\\n        (uint256 unfreezed, uint256 rewards) = _unfreezeOrder(_userAddr, _amount);\\r\\n        if(_types == 0){\\r\\n            require(_amount \\u003e unfreezed, \\\"redeposit only\\\");\\r\\n        }else if(_types \\u003e= 2){\\r\\n            require(_amount == unfreezed, \\\"redeposit err\\\");\\r\\n        }\\r\\n\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        RewardInfo storage userRewards = rewardInfo[_userAddr];\\r\\n        if(unfreezed \\u003e 0){\\r\\n            user.unfreezeIndex = user.unfreezeIndex + 1;\\r\\n            if(userRewards.bonusFreezed \\u003e 0){\\r\\n                userRewards.bonusReleased = userRewards.bonusFreezed;\\r\\n                userRewards.bonusFreezed = 0;\\r\\n            }\\r\\n\\r\\n            if(rewards \\u003e 0) userRewards.statics = userRewards.statics.add(rewards);\\r\\n            if(_types \\u003c 2) userRewards.capitals = userRewards.capitals.add(unfreezed);\\r\\n        }else{\\r\\n            uint256 l5Freezed = userRewards.l5Freezed;\\r\\n            if(l5Freezed \\u003e 0){\\r\\n                rewards = _amount \\u003c= l5Freezed ? _amount : l5Freezed;\\r\\n                userRewards.l5Freezed = l5Freezed.sub(rewards);\\r\\n                userRewards.l5Released = userRewards.l5Released.add(rewards);\\r\\n            }\\r\\n        }\\r\\n        user.totalRevenue = user.totalRevenue.add(rewards);\\r\\n        _updateFreezeAndTeamDeposit(_userAddr, _amount, unfreezed);\\r\\n    }\\r\\n\\r\\n    function _unfreezeOrder(address _userAddr, uint256 _amount) private returns(uint256 unfreezed, uint256 rewards){\\r\\n        if(orderInfos[_userAddr].length \\u003e 0){\\r\\n            UserInfo storage user = userInfo[_userAddr];\\r\\n            OrderInfo storage order = orderInfos[_userAddr][user.unfreezeIndex];\\r\\n            uint256 orderUnfreezeTime = getOrderUnfreezeTime(_userAddr, user.unfreezeIndex);\\r\\n            // below lv5, deposit once per cycle\\r\\n            if(user.level \\u003e 0 \\u0026\\u0026 user.level \\u003c 5) require(block.timestamp \\u003e= orderUnfreezeTime, \\\"freezing\\\");\\r\\n            if(order.isUnfreezed == false \\u0026\\u0026 block.timestamp \\u003e= orderUnfreezeTime \\u0026\\u0026 _amount \\u003e= order.amount){\\r\\n                order.isUnfreezed = true;\\r\\n                unfreezed = order.amount;\\r\\n                rewards = order.amount.mul(dayRewardPercents).mul(dayPerCycle).div(timeStep).div(baseDividend);\\r\\n                if(isFreezing){\\r\\n                    if(user.totalFreezed \\u003e user.totalRevenue){\\r\\n                        uint256 leftCapital = user.totalFreezed.sub(user.totalRevenue);\\r\\n                        if(rewards \\u003e leftCapital){\\r\\n                            rewards = leftCapital;\\r\\n                        }\\r\\n                    }else{\\r\\n                        rewards = 0;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _updateFreezeAndTeamDeposit(address _userAddr, uint256 _amount, uint256 _unfreezed) private {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        if(_amount \\u003e _unfreezed){\\r\\n            uint256 incAmount = _amount.sub(_unfreezed);\\r\\n            user.totalFreezed = user.totalFreezed.add(incAmount);\\r\\n            address upline = user.referrer;\\r\\n            for(uint256 i = 0; i \\u003c invitePercents.length; i++){\\r\\n                if(upline != address(0)){\\r\\n                    UserInfo storage upUser = userInfo[upline];\\r\\n                    if(user.level == 0 \\u0026\\u0026 _userAddr != upline){\\r\\n                        upUser.teamNum = upUser.teamNum + 1;\\r\\n                        teamUsers[upline][i].push(_userAddr);\\r\\n                    }\\r\\n                    upUser.teamTotalDeposit = upUser.teamTotalDeposit.add(incAmount);\\r\\n                    if(upline == defaultRefer) break;\\r\\n                    upline = upUser.referrer;\\r\\n                }else{\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _addNewOrder(address _userAddr, uint256 _amount, uint256 _types, uint256 _startTime, bool _isMaxFreezing) private returns(bool isMaxFreezing){\\r\\n        uint256 addFreeze;\\r\\n        OrderInfo[] storage orders = orderInfos[_userAddr];\\r\\n        if(_isMaxFreezing){\\r\\n            isMaxFreezing = true;\\r\\n        }else{\\r\\n            if((freezedTimes \\u003e 0 \\u0026\\u0026 _types == 1) || (!isFreezing \\u0026\\u0026 _startTime \\u003c freezeTime[freezedTimes])){\\r\\n                isMaxFreezing = true;\\r\\n            }else{\\r\\n                addFreeze = (orders.length).mul(timeStep);\\r\\n                if(addFreeze \\u003e maxAddFreeze) isMaxFreezing = true;\\r\\n            }\\r\\n        }\\r\\n        uint256 unfreeze = isMaxFreezing ? block.timestamp.add(dayPerCycle).add(maxAddFreeze) : block.timestamp.add(dayPerCycle).add(addFreeze);\\r\\n        orders.push(OrderInfo(_amount, block.timestamp, unfreeze, false));\\r\\n    }\\r\\n\\r\\n    function _updateUserMax(address _userAddr, uint256 _amount, uint256 _userCurMax, uint256 _curCycle) internal {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        if(_amount \\u003e user.maxDeposit) user.maxDeposit = _amount;\\r\\n        userCycleMax[_userAddr][_curCycle] = _userCurMax;\\r\\n        uint256 nextMaxDepositable;\\r\\n        if(_amount == _userCurMax){\\r\\n            uint256 curMaxDepositable = getCurMaxDepositable();\\r\\n            if(_userCurMax \\u003e= curMaxDepositable){\\r\\n                nextMaxDepositable = curMaxDepositable;\\r\\n            }else{\\r\\n                if(_userCurMax \\u003c levelDeposit[3]){\\r\\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[1]);\\r\\n                }else{\\r\\n                    nextMaxDepositable = _userCurMax.add(levelDeposit[2]);\\r\\n                }\\r\\n            }\\r\\n        }else{\\r\\n            nextMaxDepositable = _userCurMax;\\r\\n        }\\r\\n        userCycleMax[_userAddr][_curCycle + 1] = nextMaxDepositable;\\r\\n        user.maxDepositable = nextMaxDepositable;\\r\\n    }\\r\\n\\r\\n    function _updateLevel(address _userAddr) private {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        for(uint256 i = user.level; i \\u003c levelDeposit.length; i++){\\r\\n            if(user.maxDeposit \\u003e= levelDeposit[i]){\\r\\n                if(i \\u003c 3){\\r\\n                    user.level = i + 1;\\r\\n                }else{\\r\\n                    (uint256 maxTeam, uint256 otherTeam, ) = getTeamDeposit(_userAddr);\\r\\n                    if(maxTeam \\u003e= levelInvite[i] \\u0026\\u0026 otherTeam \\u003e= levelInvite[i] \\u0026\\u0026 user.teamNum \\u003e= levelTeam[i]){\\r\\n                        user.level = i + 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdraw() external {\\r\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\r\\n        uint256 rewardsStatic = userRewards.statics.add(userRewards.invited).add(userRewards.bonusReleased).add(userRewards.predictWin);\\r\\n        uint256 incomeFee = rewardsStatic.mul(incomeFeePercents).div(baseDividend);\\r\\n        usdt.transfer(feeReceiver, incomeFee);\\r\\n        uint256 predictPoolFee = rewardsStatic.mul(predictPoolPercents).div(baseDividend);\\r\\n        predictPool = predictPool.add(predictPoolFee);\\r\\n        totalPredictPool = totalPredictPool.add(predictPoolFee);\\r\\n        uint256 leftReward = rewardsStatic.add(userRewards.l5Released).sub(incomeFee).sub(predictPoolFee);\\r\\n        uint256 split = leftReward.mul(splitPercents).div(baseDividend);\\r\\n        uint256 withdrawable = leftReward.sub(split);\\r\\n        uint256 capitals = userRewards.capitals;\\r\\n        userRewards.capitals = 0;\\r\\n        userRewards.statics = 0;\\r\\n        userRewards.invited = 0;\\r\\n        userRewards.bonusReleased = 0;\\r\\n        userRewards.l5Released = 0;\\r\\n        userRewards.predictWin = 0;\\r\\n        userRewards.split = userRewards.split.add(split);\\r\\n        userRewards.lastWithdaw = block.timestamp;\\r\\n        withdrawable = withdrawable.add(capitals);\\r\\n        usdt.transfer(msg.sender, withdrawable);\\r\\n        if(!isFreezing) _setFreezeReward();\\r\\n        emit Withdraw(msg.sender, incomeFee, predictPoolFee, split, withdrawable);\\r\\n    }\\r\\n\\r\\n    function predict(uint256 _amount) external {\\r\\n        require(userInfo[msg.sender].referrer != address(0), \\\"not register\\\");\\r\\n        require(_amount.mod(levelDeposit[0]) == 0, \\\"amount err\\\");\\r\\n        uint256 curDay = getCurDay();\\r\\n        require(userPredicts[curDay][msg.sender].length \\u003c dayPredictLimit, \\\"reached day limit\\\");\\r\\n        uint256 predictEnd = startTime.add(curDay.mul(timeStep)).add(predictDuration);\\r\\n        require(block.timestamp \\u003c predictEnd, \\\"today is over\\\");\\r\\n        usdt.transferFrom(msg.sender, address(this), predictFee);\\r\\n        dayPredictors[curDay][_amount].push(msg.sender);\\r\\n        userPredicts[curDay][msg.sender].push(PredictInfo(block.timestamp, _amount));\\r\\n        if(isFreezing) _setFreezeReward();\\r\\n        emit Predict(block.timestamp, msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function transferBySplit(address _receiver, uint256 _amount) external {\\r\\n        uint256 minTransfer = levelDeposit[0].mul(2);\\r\\n        require(_amount \\u003e= minTransfer \\u0026\\u0026 _amount.mod(minTransfer) == 0, \\\"amount err\\\");\\r\\n        uint256 subBal = _amount.add(_amount.mul(transferFeePercents).div(baseDividend));\\r\\n        RewardInfo storage userRewards = rewardInfo[msg.sender];\\r\\n        require(userRewards.split \\u003e= subBal, \\\"insufficient split\\\");\\r\\n        userRewards.split = userRewards.split.sub(subBal);\\r\\n        rewardInfo[_receiver].split = rewardInfo[_receiver].split.add(_amount);\\r\\n        emit TransferBySplit(msg.sender, subBal, _receiver, _amount);\\r\\n    }\\r\\n\\r\\n    function distributePredictPool() external {\\r\\n        if(block.timestamp \\u003e= lastDistribute.add(timeStep)){\\r\\n            uint256 curDay = getCurDay();\\r\\n            uint256 lastDay = curDay - 1;\\r\\n            uint256 totalReward;\\r\\n            if(predictPool \\u003e 0){\\r\\n                address[] memory winners = getPredictWinners(lastDay);\\r\\n                for(uint256 i = 0; i \\u003c winners.length; i++){\\r\\n                    if(winners[i] != address(0)){\\r\\n                        uint256 reward = predictPool.mul(predictWinnerPercents[i]).div(baseDividend);\\r\\n                        totalReward = totalReward.add(reward);\\r\\n                        rewardInfo[winners[i]].predictWin = rewardInfo[winners[i]].predictWin.add(reward);\\r\\n                        userInfo[winners[i]].totalRevenue = userInfo[winners[i]].totalRevenue.add(reward);\\r\\n                        totalWinners++;\\r\\n                    }else{\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                dayPredictPool[lastDay] = predictPool;\\r\\n                predictPool = predictPool \\u003e totalReward ? predictPool.sub(totalReward) : 0;\\r\\n            }\\r\\n            lastDistribute = startTime.add(curDay.mul(timeStep));\\r\\n            emit DistributePredictPool(lastDay, totalReward, predictPool, lastDistribute);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _balActived() private {\\r\\n        uint256 bal = usdt.balanceOf(address(this));\\r\\n        for(uint256 i = balReached.length; i \\u003e 0; i--){\\r\\n            if(bal \\u003e= balReached[i - 1]){\\r\\n                balStatus[balReached[i - 1]] = true;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setFreezeReward() private {\\r\\n        uint256 bal = usdt.balanceOf(address(this));\\r\\n        for(uint256 i = balReached.length; i \\u003e 0; i--){\\r\\n            if(balStatus[balReached[i - 1]]){\\r\\n                if(!isFreezing){\\r\\n                    if(bal \\u003c balFreeze[i - 1]){\\r\\n                        isFreezing = true;\\r\\n                        freezedTimes = freezedTimes + 1;\\r\\n                        freezeTime[freezedTimes] = block.timestamp;\\r\\n                    }\\r\\n                }else{\\r\\n                    if(bal \\u003e= balUnfreeze[i - 1]){\\r\\n                        isFreezing = false;\\r\\n                        unfreezeTime[freezedTimes] = block.timestamp;\\r\\n                    }\\r\\n                }\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getOrderUnfreezeTime(address _userAddr, uint256 _index) public view returns(uint256 orderUnfreezeTime) {\\r\\n        OrderInfo storage order = orderInfos[_userAddr][_index];\\r\\n        orderUnfreezeTime = order.unfreeze;\\r\\n        if(!isFreezing \\u0026\\u0026 !order.isUnfreezed \\u0026\\u0026 userInfo[_userAddr].startTime \\u003c freezeTime[freezedTimes]){\\r\\n            orderUnfreezeTime =  order.start.add(dayPerCycle).add(maxAddFreeze);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUserCycleDepositable(address _userAddr, uint256 _cycle) public view returns(uint256 cycleMin, uint256 cycleMax) {\\r\\n        UserInfo storage user = userInfo[_userAddr];\\r\\n        if(user.maxDeposit \\u003e 0){\\r\\n            cycleMin = user.maxDeposit;\\r\\n            cycleMax = userCycleMax[_userAddr][_cycle];\\r\\n            if(cycleMax == 0) cycleMax = user.maxDepositable;\\r\\n            uint256 curMaxDepositable = getCurMaxDepositable();\\r\\n            if(isFreezing){\\r\\n                if(user.startTime \\u003c freezeTime[freezedTimes] \\u0026\\u0026 !isUnfreezedReward[_userAddr][freezedTimes]){\\r\\n                    cycleMin = user.totalFreezed \\u003e user.totalRevenue ? cycleMin.mul(unfreezeWithoutIncomePercents).div(baseDividend) : cycleMin.mul(unfreezeWithIncomePercents).div(baseDividend);\\r\\n                    cycleMax = curMaxDepositable;\\r\\n                }\\r\\n            }else{\\r\\n                if(user.startTime \\u003c freezeTime[freezedTimes]) cycleMax = curMaxDepositable;\\r\\n            }\\r\\n        }else{\\r\\n            cycleMin = levelDeposit[0];\\r\\n            cycleMax = levelDeposit[1];\\r\\n        }\\r\\n\\r\\n        if(cycleMin \\u003e cycleMax) cycleMin = cycleMax;\\r\\n    }\\r\\n\\r\\n    function getPredictWinners(uint256 _day) public view returns(address[] memory winners) {\\r\\n        uint256 steps = dayDeposits[_day].div(levelDeposit[0]);\\r\\n        uint256 maxWinners = predictWinnerPercents.length;\\r\\n        winners = new address[](maxWinners);\\r\\n        uint256 counter;\\r\\n        for(uint256 i = steps; i \\u003e= 0; i--){\\r\\n            uint256 winAmount = i.mul(levelDeposit[0]);\\r\\n            for(uint256 j = 0; j \\u003c dayPredictors[_day][winAmount].length; j++){\\r\\n                address predictUser = dayPredictors[_day][winAmount][j];\\r\\n                if(predictUser != address(0)){\\r\\n                    winners[counter] = predictUser;\\r\\n                    counter++;\\r\\n                    if(counter \\u003e= maxWinners) break;\\r\\n                }\\r\\n            }\\r\\n            if(counter \\u003e= maxWinners || i == 0 || steps.sub(i) \\u003e= maxSearchDepth) break;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTeamDeposit(address _userAddr) public view returns(uint256 maxTeam, uint256 otherTeam, uint256 totalTeam){\\r\\n        address[] memory directTeamUsers = teamUsers[_userAddr][0];\\r\\n        for(uint256 i = 0; i \\u003c directTeamUsers.length; i++){\\r\\n            UserInfo storage user = userInfo[directTeamUsers[i]];\\r\\n            uint256 userTotalTeam = user.teamTotalDeposit.add(user.totalFreezed);\\r\\n            totalTeam = totalTeam.add(userTotalTeam);\\r\\n            if(userTotalTeam \\u003e maxTeam) maxTeam = userTotalTeam;\\r\\n            if(i \\u003e= maxSearchDepth) break;\\r\\n        }\\r\\n        otherTeam = totalTeam.sub(maxTeam);\\r\\n    }\\r\\n\\r\\n    function getCurDay() public view returns(uint256) {\\r\\n        return (block.timestamp.sub(startTime)).div(timeStep);\\r\\n    }\\r\\n\\r\\n    function getCurCycle() public view returns(uint256) {\\r\\n        return (block.timestamp.sub(startTime)).div(dayPerCycle);\\r\\n    }\\r\\n\\r\\n    function getCurMaxDepositable() public view returns(uint256) {\\r\\n        return levelDeposit[4].mul(2**freezedTimes);\\r\\n    }\\r\\n\\r\\n    function getMaxDayNewbies(uint256 _day) public pure returns(uint256) {\\r\\n        return initDayNewbies + _day.mul(incNumber).div(incInterval);\\r\\n    }\\r\\n\\r\\n    function getOrderLength(address _userAddr) public view returns(uint256) {\\r\\n        return orderInfos[_userAddr].length;\\r\\n    }\\r\\n\\r\\n    function getLatestDepositors(uint256 _length) public view returns(address[] memory latestDepositors) {\\r\\n        uint256 totalCount = depositors.length;\\r\\n        if(_length \\u003e totalCount) _length = totalCount;\\r\\n        latestDepositors = new address[](_length);\\r\\n        for(uint256 i = totalCount; i \\u003e totalCount - _length; i--){\\r\\n            latestDepositors[totalCount - i] = depositors[i - 1];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTeamUsers(address _userAddr, uint256 _layer) public view returns(address[] memory) {\\r\\n        return teamUsers[_userAddr][_layer];\\r\\n    }\\r\\n\\r\\n    function getUserDayPredicts(address _userAddr, uint256 _day) public view returns(PredictInfo[] memory) {\\r\\n        return userPredicts[_day][_userAddr];\\r\\n    }\\r\\n\\r\\n    function getDayPredictors(uint256 _day, uint256 _number) external view returns(address[] memory) {\\r\\n        return dayPredictors[_day][_number];\\r\\n    }\\r\\n\\r\\n    function getDayInfos(uint256 _day) external view returns(address[] memory newbies, uint256 deposits, uint256 pool){\\r\\n        return (dayNewbies[_day], dayDeposits[_day], dayPredictPool[_day]);\\r\\n    }\\r\\n\\r\\n    function getBalStatus(uint256 _bal) external view returns(bool) {\\r\\n        return balStatus[_bal];\\r\\n    }\\r\\n\\r\\n    function getUserCycleMax(address _userAddr, uint256 _cycle) external view returns(uint256){\\r\\n        return userCycleMax[_userAddr][_cycle];\\r\\n    }\\r\\n\\r\\n    function getUserInfos(address _userAddr) external view returns(UserInfo memory user, RewardInfo memory reward, OrderInfo[] memory orders, bool unfreeze) {\\r\\n        user = userInfo[_userAddr];\\r\\n        reward = rewardInfo[_userAddr];\\r\\n        orders = orderInfos[_userAddr];\\r\\n        unfreeze = isUnfreezedReward[_userAddr][freezedTimes];\\r\\n    }\\r\\n\\r\\n    function getContractInfos() external view returns(address[3] memory infos0, uint256[10] memory infos1, bool freezing) {\\r\\n        infos0[0] = address(usdt);\\r\\n        infos0[1] = feeReceiver;\\r\\n        infos0[2] = defaultRefer;\\r\\n        infos1[0] = startTime;\\r\\n        infos1[1] = lastDistribute;\\r\\n        infos1[2] = totalUsers;\\r\\n        infos1[3] = totalDeposit;\\r\\n        infos1[4] = predictPool;\\r\\n        infos1[5] = totalPredictPool;\\r\\n        infos1[6] = totalWinners;\\r\\n        infos1[7] = freezedTimes;\\r\\n        infos1[8] = freezeTime[freezedTimes];\\r\\n        infos1[9] = unfreezeTime[freezedTimes];\\r\\n        freezing = isFreezing;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"types\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFreezing\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DistributePredictPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Predict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subBal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferBySplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributePredictPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"getBalStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractInfos\",\"outputs\":[{\"internalType\":\"address[3]\",\"name\":\"infos0\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[10]\",\"name\":\"infos1\",\"type\":\"uint256[10]\"},{\"internalType\":\"bool\",\"name\":\"freezing\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurMaxDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getDayInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"newbies\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getDayPredictors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"getLatestDepositors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"latestDepositors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getMaxDayNewbies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getOrderUnfreezeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderUnfreezeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getPredictWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleDepositable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleMax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"getUserCycleMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getUserDayPredicts\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"internalType\":\"struct BSG.PredictInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRevenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreezeIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMaxFreezing\",\"type\":\"bool\"}],\"internalType\":\"struct BSG.UserInfo\",\"name\":\"user\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"capitals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"statics\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusFreezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Freezed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l5Released\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"predictWin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"split\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdaw\",\"type\":\"uint256\"}],\"internalType\":\"struct BSG.RewardInfo\",\"name\":\"reward\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unfreeze\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnfreezed\",\"type\":\"bool\"}],\"internalType\":\"struct BSG.OrderInfo[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"unfreeze\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"predict\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferBySplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BSG", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000029630f40de1b95bb137806f72e94a5b32e634a700000000000000000000000010e07dee16e46d9e4e811b85f4f1a271e43c63fa000000000000000000000000000000000000000000000000000000006496f6e0", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://36bb19022bd2a2f839e40e3499ac8ec0465f39846ec643ed8501f608843f79ca"}