{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/hamachi/Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {ABaseDiamond} from \\\"@lib-diamond/src/diamond/ABaseDiamond.sol\\\";\\nimport {LibDiamond} from \\\"@lib-diamond/src/diamond/LibDiamond.sol\\\";\\nimport {DiamondStorage} from \\\"@lib-diamond/src/diamond/DiamondStorage.sol\\\";\\nimport {IDiamondCut} from \\\"@lib-diamond/src/diamond/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"@lib-diamond/src/diamond/IDiamondLoupe.sol\\\";\\nimport {FacetCut, FacetCutAction} from \\\"@lib-diamond/src/diamond/Facet.sol\\\";\\nimport {DiamondCutAndLoupeFacet} from \\\"./facets/DiamondCutAndLoupeFacet.sol\\\";\\n\\nimport {AccessControlEnumerableStorage} from \\\"@lib-diamond/src/access/access-control/AccessControlEnumerableStorage.sol\\\";\\nimport {DEFAULT_ADMIN_ROLE} from \\\"@lib-diamond/src/access/access-control/Roles.sol\\\";\\nimport {LibAccessControlEnumerable} from \\\"@lib-diamond/src/access/access-control/LibAccessControlEnumerable.sol\\\";\\nimport {WithRoles} from \\\"@lib-diamond/src/access/access-control/WithRoles.sol\\\";\\nimport {IAccessControl} from \\\"@lib-diamond/src/access/access-control/IAccessControl.sol\\\";\\nimport {IAccessControlEnumerable} from \\\"@lib-diamond/src/access/access-control/IAccessControlEnumerable.sol\\\";\\nimport {AccessControlEnumerableFacet} from \\\"@lib-diamond/src/access/access-control/AccessControlEnumerableFacet.sol\\\";\\n\\nimport {ERC165Facet} from \\\"@lib-diamond/src/utils/introspection/erc165/ERC165Facet.sol\\\";\\n\\nimport {LibHamachi} from \\\"./libraries/LibHamachi.sol\\\";\\nimport {HamachiStorage} from \\\"./types/hamachi/HamachiStorage.sol\\\";\\nimport {LibReward} from \\\"./libraries/LibReward.sol\\\";\\nimport {RewardStorage} from \\\"./types/reward/RewardStorage.sol\\\";\\nimport {LibUniswap} from \\\"./libraries/LibUniswap.sol\\\";\\nimport {UniswapStorage} from \\\"./types/uniswap/UniswapStorage.sol\\\";\\n\\n\\nimport {IUniswapV2Router02} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\n\\nimport {Proxy} from \\\"@lib-diamond/src/proxy-etherscan/Proxy.sol\\\";\\n\\ncontract Diamond is ABaseDiamond, WithRoles, Proxy {\\n  constructor(\\n    address liquidityWallet,\\n    address defaultRouter,\\n    address defaultPair,\\n    address contractAdmin,\\n    address diamondCutAndLoupeFacet_,\\n    address accessControlEnumerableFacet_,\\n    address erc165Facet_,\\n    address methodsExposureFacetAddress_\\n  ) payable {\\n    LibAccessControlEnumerable.grantRole(DEFAULT_ADMIN_ROLE, contractAdmin);\\n\\n    HamachiStorage storage hs = LibHamachi.DS();\\n    RewardStorage storage rs = LibReward.DS();\\n    UniswapStorage storage us = LibUniswap.DS();\\n\\n    hs.fee.liquidityBuyFee = 100;\\n    hs.fee.rewardBuyFee = 600;\\n\\n    hs.fee.liquiditySellFee = 100;\\n    hs.fee.rewardSellFee = 600;\\n\\n    hs.numTokensToSwap = 10_000_000 * 10 ** 18;\\n    hs.maxTokenPerWallet = 250_000_000 * 10 ** 18; // Max holding limit, 0.25% of supply\\n    hs.swapRouters[defaultRouter] = true;\\n\\n    us.defaultRouter = defaultRouter;\\n    us.liquidityWallet = liquidityWallet;\\n\\n    hs.processingGas = 750_000;\\n    hs.processingFees = false;\\n    hs.processRewards = true;\\n\\n    rs.minRewardBalance = 1000 * 10 ** 18;\\n    rs.claimTimeout = 3600;\\n\\n    _setImplementation(methodsExposureFacetAddress_);\\n\\n    rs.rewardToken.token = address(0xB64E280e9D1B5DbEc4AcceDb2257A87b400DB149);\\n    rs.rewardToken.router = defaultRouter;\\n    rs.rewardToken.path = [defaultPair, address(this)];\\n\\n    rs.goHam.token = address(this);\\n    rs.goHam.router = defaultRouter;\\n    rs.goHam.path = [defaultPair, address(this)];\\n\\n    IUniswapV2Router02 router = IUniswapV2Router02(defaultRouter);\\n    address swapPair = IUniswapV2Factory(router.factory()).createPair(address(this), defaultPair);\\n    hs.lpPools[address(swapPair)] = true;\\n\\n    // Add the diamondCut external function from the diamondCutFacet\\n    FacetCut[] memory cut;\\n    bytes4[] memory functionSelectors;\\n\\n    // Add the diamondLoupe external functions from the diamondLoupeFacet\\n    cut = new FacetCut[](1);\\n    functionSelectors = new bytes4[](5);\\n    functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n    functionSelectors[1] = IDiamondLoupe.facets.selector;\\n    functionSelectors[2] = IDiamondLoupe.facetFunctionSelectors.selector;\\n    functionSelectors[3] = IDiamondLoupe.facetAddresses.selector;\\n    functionSelectors[4] = IDiamondLoupe.facetAddress.selector;\\n    cut[0] = FacetCut({\\n      facetAddress: diamondCutAndLoupeFacet_,\\n      action: FacetCutAction.Add,\\n      functionSelectors: functionSelectors\\n    });\\n    LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n\\n    // Add the access control external functions from the AccessControlEnumerableFacet\\n    cut = new FacetCut[](1);\\n    functionSelectors = new bytes4[](8);\\n    functionSelectors[0] = IAccessControl.hasRole.selector;\\n    functionSelectors[1] = IAccessControl.getRoleAdmin.selector;\\n    functionSelectors[2] = IAccessControl.grantRole.selector;\\n    functionSelectors[3] = IAccessControl.revokeRole.selector;\\n    functionSelectors[4] = IAccessControl.renounceRole.selector;\\n    functionSelectors[5] = AccessControlEnumerableFacet.getRoleMember.selector;\\n    functionSelectors[6] = AccessControlEnumerableFacet.getRoleMemberCount.selector;\\n    functionSelectors[7] = AccessControlEnumerableFacet.getRoleMembers.selector;\\n    cut[0] = FacetCut({\\n      facetAddress: accessControlEnumerableFacet_,\\n      action: FacetCutAction.Add,\\n      functionSelectors: functionSelectors\\n    });\\n    LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n\\n    // Add the ERC165 external functions from the erc165Facet\\n    cut = new FacetCut[](1);\\n    functionSelectors = new bytes4[](1);\\n    functionSelectors[0] = ERC165Facet.supportsInterface.selector;\\n    cut[0] = FacetCut({\\n      facetAddress: erc165Facet_,\\n      action: FacetCutAction.Add,\\n      functionSelectors: functionSelectors\\n    });\\n    LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/ABaseDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"./LibDiamond.sol\\\";\\nimport {DiamondStorage} from \\\"./DiamondStorage.sol\\\";\\nimport {IDiamondCut} from \\\"./IDiamondCut.sol\\\";\\nimport {FacetCut, FacetCutAction} from \\\"./Facet.sol\\\";\\n\\ncontract ABaseDiamond {\\n  // When no function exists for function called\\n  error FunctionNotFound(bytes4 functionSignature);\\n\\n  // Find facet for function that is called and execute the\\n  // function if a facet is found and return any value.\\n  fallback() external payable virtual {\\n    DiamondStorage storage ds;\\n    // get diamond storage\\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n    // get facet from function selector\\n    address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n    if (facet == address(0)) revert FunctionNotFound(msg.sig);\\n    // Execute external function from facet using delegatecall and return any value.\\n    assembly {\\n      // copy function selector and any arguments\\n      calldatacopy(0, 0, calldatasize())\\n      // execute function call using the facet\\n      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n      // get any return value\\n      returndatacopy(0, 0, returndatasize())\\n      // return any return value or error back to the caller\\n      switch result\\n      case 0 {\\n        revert(0, returndatasize())\\n      }\\n      default {\\n        return(0, returndatasize())\\n      }\\n    }\\n  }\\n\\n  receive() external payable virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"./IDiamondCut.sol\\\";\\nimport {FacetCut, FacetCutAction} from \\\"./Facet.sol\\\";\\nimport {DiamondStorage} from \\\"./DiamondStorage.sol\\\";\\n\\nlibrary LibDiamond {\\n  error InValidFacetCutAction();\\n  error NoSelectorsInFacet();\\n  error NoZeroAddress();\\n  error SelectorExists(bytes4 selector);\\n  error SameSelectorReplacement(bytes4 selector);\\n  error MustBeZeroAddress();\\n  error NoCode();\\n  error NonExistentSelector(bytes4 selector);\\n  error ImmutableFunction(bytes4 selector);\\n  error NonEmptyCalldata();\\n  error EmptyCalldata();\\n  error InitCallFailed();\\n\\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n  function DS() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    uint256 diamondCutLength = _diamondCut.length;\\n    for (uint256 facetIndex; facetIndex < diamondCutLength; ) {\\n      FacetCutAction action = _diamondCut[facetIndex].action;\\n      if (action == FacetCutAction.Add) {\\n        addFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == FacetCutAction.Replace) {\\n        replaceFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == FacetCutAction.Remove) {\\n        removeFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else {\\n        revert InValidFacetCutAction();\\n      }\\n\\n      unchecked {\\n        ++facetIndex;\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    if (_functionSelectors.length <= 0) revert NoSelectorsInFacet();\\n    DiamondStorage storage ds = DS();\\n    if (_facetAddress == address(0)) revert NoZeroAddress();\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) addFacet(ds, _facetAddress);\\n\\n    uint256 selectorCount = _functionSelectors.length;\\n    for (uint256 selectorIndex; selectorIndex < selectorCount; ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      if (oldFacetAddress != address(0)) revert SelectorExists(selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n\\n      unchecked {\\n        ++selectorPosition; // u96 max unreachable\\n        ++selectorIndex;\\n      }\\n    }\\n  }\\n\\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    if (_functionSelectors.length <= 0) revert NoSelectorsInFacet();\\n    DiamondStorage storage ds = DS();\\n    if (_facetAddress == address(0)) revert NoZeroAddress();\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) addFacet(ds, _facetAddress);\\n\\n    uint256 selectorCount = _functionSelectors.length;\\n    for (uint256 selectorIndex; selectorIndex < selectorCount; ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      if (oldFacetAddress == _facetAddress) revert SameSelectorReplacement(selector);\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n\\n      unchecked {\\n        ++selectorPosition; // u96 max unreachable\\n        ++selectorIndex;\\n      }\\n    }\\n  }\\n\\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    if (_functionSelectors.length <= 0) revert NoSelectorsInFacet();\\n    DiamondStorage storage ds = DS();\\n    // if function does not exist then do nothing and return\\n    if (_facetAddress != address(0)) revert MustBeZeroAddress();\\n    uint256 selectorCount = _functionSelectors.length;\\n    for (uint256 selectorIndex; selectorIndex < selectorCount; ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n\\n      unchecked {\\n        ++selectorIndex;\\n      }\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(_facetAddress);\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    if (_facetAddress == address(0)) revert NonExistentSelector(_selector);\\n    // an immutable function is a function defined directly in a diamond\\n    if (_facetAddress == address(this)) revert ImmutableFunction(_selector);\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds\\n      .facetFunctionSelectors[_facetAddress]\\n      .functionSelectors\\n      .length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n        lastSelectorPosition\\n      ];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(\\n        selectorPosition\\n      );\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      if (_calldata.length > 0) revert NonEmptyCalldata();\\n    } else {\\n      if (_calldata.length == 0) revert EmptyCalldata();\\n      if (_init != address(this)) enforceHasContractCode(_init);\\n\\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n      if (!success) {\\n        if (error.length > 0) revert(string(error));\\n        else revert InitCallFailed();\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    if (contractSize <= 0) revert NoCode();\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/DiamondStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {FacetAddressAndPosition, FacetFunctionSelectors} from \\\"./Facet.sol\\\";\\n\\nstruct DiamondStorage {\\n  // maps function selector to the facet address and\\n  // the position of the selector in the facetFunctionSelectors.selectors array\\n  mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n  // maps facet addresses to function selectors\\n  mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n  // facet addresses\\n  address[] facetAddresses;\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {FacetCut} from \\\"./Facet.sol\\\";\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Facet} from \\\"./Facet.sol\\\";\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n  /// These functions are expected to be called frequently\\n  /// by tools.\\n\\n  /// @notice Gets all facet addresses and their four byte function selectors.\\n  /// @return facets_ Facet\\n  function facets() external view returns (Facet[] memory facets_);\\n\\n  /// @notice Gets all the function selectors supported by a specific facet.\\n  /// @param _facet The facet address.\\n  /// @return facetFunctionSelectors_\\n  function facetFunctionSelectors(\\n    address _facet\\n  ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n  /// @notice Get all the facet addresses used by a diamond.\\n  /// @return facetAddresses_\\n  function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n  /// @notice Gets the facet that supports the given selector.\\n  /// @dev If facet is not found return address(0).\\n  /// @param _functionSelector The function selector.\\n  /// @return facetAddress_ The facet address.\\n  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Facet {\\n  address facetAddress;\\n  bytes4[] functionSelectors;\\n}\\n\\nstruct FacetCut {\\n  address facetAddress;\\n  FacetCutAction action;\\n  bytes4[] functionSelectors;\\n}\\n\\nenum FacetCutAction {\\n  // Add=0, Replace=1, Remove=2\\n  Add,\\n  Replace,\\n  Remove\\n}\\n\\nstruct FacetAddressAndPosition {\\n  address facetAddress;\\n  uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n}\\n\\nstruct FacetFunctionSelectors {\\n  bytes4[] functionSelectors;\\n  uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n}\\n\"\r\n    },\r\n    \"src/hamachi/facets/DiamondCutAndLoupeFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {IDiamondCut} from \\\"@lib-diamond/src/diamond/IDiamondCut.sol\\\";\\nimport {LibDiamond} from \\\"@lib-diamond/src/diamond/LibDiamond.sol\\\";\\nimport {FacetCut, Facet} from \\\"@lib-diamond/src/diamond/Facet.sol\\\";\\nimport {DiamondStorage} from \\\"@lib-diamond/src/diamond/DiamondStorage.sol\\\";\\nimport {DiamondLoupeFacet} from \\\"@lib-diamond/src/diamond/DiamondLoupeFacet.sol\\\";\\n\\nimport {WithRoles} from \\\"@lib-diamond/src/access/access-control/WithRoles.sol\\\";\\nimport {DEFAULT_ADMIN_ROLE} from \\\"@lib-diamond/src/access/access-control/Roles.sol\\\";\\n\\ncontract DiamondCutAndLoupeFacet is DiamondLoupeFacet, IDiamondCut, WithRoles {\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external override onlyRole(DEFAULT_ADMIN_ROLE) {\\n    LibDiamond.diamondCut(_diamondCut, _init, _calldata);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/AccessControlEnumerableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct RoleData {\\n  mapping(address => bool) members;\\n  bytes32 adminRole;\\n  address[] membersList;\\n}\\n\\nstruct AccessControlEnumerableStorage {\\n  mapping(bytes32 => RoleData) roles;\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/Roles.sol\": {\r\n      \"content\": \"bytes32 constant DEFAULT_ADMIN_ROLE = 0x00;\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/LibAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {AccessControlEnumerableStorage} from \\\"./AccessControlEnumerableStorage.sol\\\";\\nimport {DEFAULT_ADMIN_ROLE} from \\\"./Roles.sol\\\";\\nimport {AddressArrayLibUtils} from \\\"../../utils/ArrayLibUtils.sol\\\";\\n\\nlibrary LibAccessControlEnumerable {\\n  using AddressArrayLibUtils for address[];\\n\\n  error Unauthorized(bytes32 role);\\n  error AlreadyHasRole(bytes32 role);\\n  error RoleNotSet(bytes32 role);\\n  error RenounceAccountNotMsgSender(address account);\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {AccessControl-_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  bytes32 internal constant ACCESS_CONTROL_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.accesscontrol.storage\\\");\\n\\n  function DS() internal pure returns (AccessControlEnumerableStorage storage ds) {\\n    bytes32 position = ACCESS_CONTROL_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function hasRole(bytes32 role, address account) internal view returns (bool) {\\n    return DS().roles[role].members[account];\\n  }\\n\\n  function checkRole(bytes32 role, address account) internal view {\\n    if (!hasRole(role, account)) revert Unauthorized(role);\\n  }\\n\\n  function checkRole(bytes32 role) internal view {\\n    checkRole(role, msg.sender);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\\n    return DS().roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) internal {\\n    if (!hasRole(role, account)) {\\n      DS().roles[role].members[account] = true;\\n      DS().roles[role].membersList.push(account);\\n      emit RoleGranted(role, account, msg.sender);\\n    } else revert AlreadyHasRole(role);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) internal {\\n    if (hasRole(role, account)) {\\n      DS().roles[role].members[account] = false;\\n      DS().roles[role].membersList.swapOut(account);\\n      emit RoleRevoked(role, account, msg.sender);\\n    } else revert RoleNotSet(role);\\n  }\\n\\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n    DS().roles[role].adminRole = adminRole;\\n  }\\n\\n  function renounceRole(bytes32 role, address account) internal {\\n    if (account != msg.sender) revert RenounceAccountNotMsgSender(account);\\n    revokeRole(role, account);\\n  }\\n\\n  function getRoleMember(bytes32 _role, uint256 _index) internal view returns (address) {\\n    AccessControlEnumerableStorage storage ds = DS();\\n    return ds.roles[_role].membersList[_index];\\n  }\\n\\n  function getRoleMemberCount(bytes32 _role) internal view returns (uint256) {\\n    AccessControlEnumerableStorage storage ds = DS();\\n    return ds.roles[_role].membersList.length;\\n  }\\n\\n  function getRoleMembers(bytes32 _role) internal view returns (address[] memory) {\\n    AccessControlEnumerableStorage storage ds = DS();\\n    return ds.roles[_role].membersList;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/WithRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {LibAccessControl} from \\\"./LibAccessControl.sol\\\";\\n\\ncontract WithRoles {\\n  modifier onlyRole(bytes32 role) {\\n    LibAccessControl.checkRole(role);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {AccessControl-_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Returns `true` if `account` has been granted `role`.\\n   */\\n  function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n  /**\\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\\n   * {revokeRole}.\\n   *\\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n   */\\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n  /**\\n   * @dev Grants `role` to `account`.\\n   *\\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function grantRole(bytes32 role, address account) external;\\n\\n  /**\\n   * @dev Revokes `role` from `account`.\\n   *\\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have ``role``'s admin role.\\n   */\\n  function revokeRole(bytes32 role, address account) external;\\n\\n  /**\\n   * @dev Revokes `role` from the calling account.\\n   *\\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n   * purpose is to provide a mechanism for accounts to lose their privileges\\n   * if they are compromised (such as when a trusted device is misplaced).\\n   *\\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\\n   * event.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must be `account`.\\n   */\\n  function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n  /**\\n   * @dev Returns one of the accounts that have `role`. `index` must be a\\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\\n   *\\n   * Role bearers are not sorted in any particular way, and their ordering may\\n   * change at any point.\\n   *\\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n   * you perform all queries on the same block. See the following\\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n   * for more information.\\n   */\\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n  /**\\n   * @dev Returns the number of accounts that have `role`. Can be used\\n   * together with {getRoleMember} to enumerate all bearers of a role.\\n   */\\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/AccessControlEnumerableFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {AccessControlFacet} from \\\"./AccessControlFacet.sol\\\";\\nimport {IAccessControlEnumerable} from \\\"./IAccessControlEnumerable.sol\\\";\\nimport {WithRoles} from \\\"./WithRoles.sol\\\";\\nimport {DEFAULT_ADMIN_ROLE} from \\\"./Roles.sol\\\";\\nimport {LibAccessControlEnumerable} from \\\"./LibAccessControlEnumerable.sol\\\";\\nimport {AccessControlEnumerableStorage} from \\\"./AccessControlEnumerableStorage.sol\\\";\\n\\ncontract AccessControlEnumerableFacet is AccessControlFacet, IAccessControlEnumerable {\\n  function getRoleMember(bytes32 _role, uint256 _index) external view override returns (address) {\\n    return LibAccessControlEnumerable.getRoleMember(_role, _index);\\n  }\\n\\n  function getRoleMemberCount(bytes32 _role) external view override returns (uint256) {\\n    return LibAccessControlEnumerable.getRoleMemberCount(_role);\\n  }\\n\\n  function getRoleMembers(bytes32 _role) external view returns (address[] memory) {\\n    return LibAccessControlEnumerable.getRoleMembers(_role);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/utils/introspection/erc165/ERC165Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {LibERC165} from \\\"./LibERC165.sol\\\";\\nimport {ERC165Storage} from \\\"./ERC165Storage.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\ncontract ERC165Facet is IERC165 {\\n  // This implements ERC-165.\\n  function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\\n    ERC165Storage storage ds = LibERC165.DS();\\n    return ds.supportedInterfaces[_interfaceId];\\n  }\\n}\\n\"\r\n    },\r\n    \"src/hamachi/libraries/LibHamachi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {LibAccessControlEnumerable} from \\\"@lib-diamond/src/access/access-control/LibAccessControlEnumerable.sol\\\";\\n\\nimport {EXCLUDED_FROM_FEE_ROLE} from \\\"../types/hamachi/HamachiRoles.sol\\\";\\n\\nimport {HamachiStorage} from \\\"../types/hamachi/HamachiStorage.sol\\\";\\nimport {LibHamachi20} from \\\"./LibHamachi20.sol\\\";\\nimport {LibReward} from \\\"./LibReward.sol\\\";\\n\\nimport {LibUniswap} from \\\"./LibUniswap.sol\\\";\\n\\nlibrary LibHamachi {\\n  modifier lockTheSwap() {\\n    LibHamachi.DS().processingFees = true;\\n    _;\\n    LibHamachi.DS().processingFees = false;\\n  }\\n\\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.hamachi.storage\\\");\\n\\n  function DS() internal pure returns (HamachiStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function buyFees() internal view returns (uint256, uint256) {\\n    return (LibHamachi.DS().fee.liquidityBuyFee, LibHamachi.DS().fee.rewardBuyFee);\\n  }\\n\\n  function totalBuyFees() internal view returns (uint32) {\\n    return LibHamachi.DS().fee.rewardBuyFee + LibHamachi.DS().fee.liquidityBuyFee;\\n  }\\n\\n  function totalSellFees() internal view returns (uint32) {\\n    return LibHamachi.DS().fee.rewardSellFee + LibHamachi.DS().fee.liquiditySellFee;\\n  }\\n\\n  function isExcludedFromFee(address account) internal view returns (bool) {\\n    return LibAccessControlEnumerable.hasRole(EXCLUDED_FROM_FEE_ROLE, account);\\n  }\\n\\n  function determineFee(address from, address to) internal view returns (uint32, bool) {\\n    if (LibHamachi.DS().lpPools[to] && !isExcludedFromFee(from) && !isExcludedFromFee(to)) {\\n      return (totalSellFees(), true);\\n    } else if (\\n      LibHamachi.DS().lpPools[from] && !isExcludedFromFee(to) && !LibHamachi.DS().swapRouters[to]\\n    ) {\\n      return (totalBuyFees(), false);\\n    }\\n\\n    return (0, false);\\n  }\\n\\n  function calculateLiquidifyAmounts(\\n    uint256 tokenAmount\\n  ) internal lockTheSwap returns (uint256, uint256) {\\n    (uint256 liquidityBuyFee, uint256 rewardBuyFee) = buyFees();\\n    uint256 totalTax = liquidityBuyFee + rewardBuyFee;\\n    uint256 liquidityAmount = (tokenAmount * liquidityBuyFee) / totalTax;\\n    uint256 liquidityTokens = liquidityAmount / 2;\\n    uint256 rewardAmount = (tokenAmount * rewardBuyFee) / totalTax;\\n    uint256 sellIntoETH = (liquidityAmount + rewardAmount) - liquidityTokens;\\n\\n    return (sellIntoETH, liquidityTokens);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/hamachi/types/hamachi/HamachiStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Fee} from \\\"../fee/Fee.sol\\\";\\n\\nstruct HamachiStorage {\\n  uint256 numTokensToSwap;\\n  uint256 maxTokenPerWallet;\\n  mapping(address => bool) lpPools;\\n  mapping(address => bool) swapRouters;\\n  uint32 processingGas;\\n  bool processingFees;\\n  Fee fee;\\n  bool processRewards;\\n  address vestingContract;\\n}\\n\\nuint32 constant PERCENTAGE_DENOMINATOR = 10000;\\naddress constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n\"\r\n    },\r\n    \"src/hamachi/libraries/LibReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {LibDiamond} from \\\"@lib-diamond/src/diamond/LibDiamond.sol\\\";\\nimport {LibAccessControlEnumerable} from \\\"@lib-diamond/src/access/access-control/LibAccessControlEnumerable.sol\\\";\\n\\nimport {EXCLUDED_FROM_REWARD_ROLE} from \\\"../types/hamachi/HamachiRoles.sol\\\";\\n\\nimport {RewardStorage, RewardToken, Map, MAGNITUDE} from \\\"../types/reward/RewardStorage.sol\\\";\\nimport {LibUniswap} from \\\"./LibUniswap.sol\\\";\\nimport {LibHamachi} from \\\"./LibHamachi.sol\\\";\\nimport {IVestingSchedule} from \\\"../interfaces/IVestingSchedule.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nerror InvalidClaimTime();\\nerror NoSupply();\\nerror NullAddress();\\n\\nlibrary LibReward {\\n  event UpdateRewardToken(address token);\\n  event RewardProcessed(address indexed owner, uint256 value, address indexed token);\\n\\n  bytes32 internal constant REWARD_STORAGE_POSITION = keccak256(\\\"diamond.standard.reward.storage\\\");\\n\\n  function DS() internal pure returns (RewardStorage storage rs) {\\n    bytes32 position = REWARD_STORAGE_POSITION;\\n    assembly {\\n      rs.slot := position\\n    }\\n  }\\n\\n  // ==================== DividendPayingToken ==================== //\\n\\n  /// @return dividends The amount of rewards that `_owner` has withdrawn\\n  function withdrawnDividendOf(address _owner) internal view returns (uint256 dividends) {\\n    return LibReward.DS().withdrawnReward[_owner];\\n  }\\n\\n  /// @return accumulated The total accumulated rewards for a address\\n  function accumulativeDividendOf(address _owner) internal view returns (uint256 accumulated) {\\n    return\\n      SafeCast.toUint256(\\n        SafeCast.toInt256(LibReward.DS().magnifiedRewardPerShare * rewardBalanceOf(_owner)) +\\n          LibReward.DS().magnifiedReward[_owner]\\n      ) / MAGNITUDE;\\n  }\\n\\n  /// @return withdrawable The total withdrawable rewards for a address\\n  function withdrawableDividendOf(address _owner) internal view returns (uint256 withdrawable) {\\n    return accumulativeDividendOf(_owner) - LibReward.DS().withdrawnReward[_owner];\\n  }\\n\\n  // ==================== Views ==================== //\\n\\n  function rewardBalanceOf(address account) internal view returns (uint256) {\\n    return LibReward.DS().rewardBalances[account];\\n  }\\n\\n  function getIndexOfKey(address key) internal view returns (int256 index) {\\n    return\\n      LibReward.DS().rewardHolders.inserted[key]\\n        ? int256(LibReward.DS().rewardHolders.indexOf[key])\\n        : -1;\\n  }\\n\\n  // ==================== Management ==================== //\\n\\n  /// @notice Adds incoming funds to the rewards per share\\n  function accrueReward(uint256 amount) internal {\\n    uint256 rewardSupply = LibReward.DS().totalRewardSupply;\\n    if (rewardSupply <= 0) revert NoSupply();\\n\\n    if (amount > 0) {\\n      LibReward.DS().magnifiedRewardPerShare += (amount * MAGNITUDE) / rewardSupply;\\n      LibReward.DS().totalAccruedReward += amount;\\n    }\\n  }\\n\\n  function setRewardToken(\\n    address token,\\n    address router,\\n    address[] memory path,\\n    bool _useV3,\\n    bytes memory pathV3\\n  ) internal {\\n    if (token == address(0)) revert NullAddress();\\n    RewardToken storage rewardToken = DS().rewardToken;\\n\\n    rewardToken.token = token;\\n    rewardToken.router = router;\\n    rewardToken.path = path;\\n    rewardToken.useV3 = _useV3;\\n    rewardToken.pathV3 = pathV3;\\n\\n    emit UpdateRewardToken(token);\\n  }\\n\\n  function setGoHamToken(\\n    address token,\\n    address router\\n  ) internal {\\n    if (token == address(0)) revert NullAddress();\\n    RewardToken storage hamiToken = DS().goHam;\\n\\n    hamiToken.token = token;\\n    hamiToken.router = router;\\n  }\\n\\n  // This function uses a set amount of gas to process rewards for as many wallets as it can\\n  function processRewards() internal {\\n    uint256 gas = LibHamachi.DS().processingGas;\\n    if (gas == 0) return;\\n\\n    uint256 numHolders = LibReward.DS().rewardHolders.keys.length;\\n    uint256 _lastProcessedIndex = LibReward.DS().lastProcessedIndex;\\n    uint256 gasUsed = 0;\\n    uint256 gasLeft = gasleft();\\n    uint256 iterations = 0;\\n\\n    while (gasUsed < gas && iterations < numHolders) {\\n      ++iterations;\\n      if (++_lastProcessedIndex >= LibReward.DS().rewardHolders.keys.length) {\\n        _lastProcessedIndex = 0;\\n      }\\n      address account = LibReward.DS().rewardHolders.keys[_lastProcessedIndex];\\n\\n      if (LibReward.DS().manualClaim[account]) continue;\\n\\n      if (!_canAutoClaim(LibReward.DS().claimTimes[account])) continue;\\n      _processAccount(account, false, 0);\\n\\n      uint256 newGasLeft = gasleft();\\n      if (gasLeft > newGasLeft) {\\n        gasUsed += gasLeft - newGasLeft;\\n      }\\n      gasLeft = newGasLeft;\\n    }\\n    LibReward.DS().lastProcessedIndex = _lastProcessedIndex;\\n  }\\n\\n  /// @param newBalance The new balance to set for the account.\\n  function setRewardBalance(address account, uint256 newBalance) internal {\\n    if (LibAccessControlEnumerable.hasRole(EXCLUDED_FROM_REWARD_ROLE, account)) return;\\n\\n    if (LibHamachi.DS().vestingContract != address(0)) {\\n      (, , , , , , uint256 amountTotal, uint256 released) = IVestingSchedule(\\n        LibHamachi.DS().vestingContract\\n      ).getVestingSchedule(account);\\n      if (amountTotal > 0) {\\n        newBalance += amountTotal - released;\\n      }\\n    }\\n\\n    if (newBalance >= LibReward.DS().minRewardBalance) {\\n      _setBalance(account, newBalance);\\n      _set(account, newBalance);\\n    } else {\\n      _setBalance(account, 0);\\n      _remove(account);\\n      _processAccount(account, false, 0);\\n    }\\n  }\\n\\n  function _canAutoClaim(uint256 lastClaimTime) internal view returns (bool) {\\n    return\\n      lastClaimTime > block.timestamp\\n        ? false\\n        : block.timestamp - lastClaimTime >= LibReward.DS().claimTimeout;\\n  }\\n\\n  function _processAccount(address _owner, bool _goHami, uint256 _expectedOutput) internal {\\n    uint256 _withdrawableReward = withdrawableDividendOf(_owner);\\n    if (_withdrawableReward <= 0) return;\\n\\n    LibReward.DS().withdrawnReward[_owner] += _withdrawableReward;\\n    LibReward.DS().claimTimes[_owner] = block.timestamp;\\n\\n    RewardToken memory rewardToken = _goHami ? LibReward.DS().goHam : LibReward.DS().rewardToken;\\n\\n    bool success = false;\\n    if (rewardToken.useV3 && !_goHami) {\\n      success = LibUniswap.swapUsingV3(rewardToken, _withdrawableReward, _owner, _expectedOutput);\\n    } else {\\n      success = LibUniswap.swapUsingV2(rewardToken, _withdrawableReward, _owner, _expectedOutput);\\n    }\\n    if (success) {\\n      emit RewardProcessed(_owner, _withdrawableReward, rewardToken.token);\\n    } else {\\n      LibReward.DS().withdrawnReward[_owner] -= _withdrawableReward;\\n    }\\n  }\\n\\n  function _setBalance(address _owner, uint256 _newBalance) internal {\\n    uint256 currentBalance = rewardBalanceOf(_owner);\\n    LibReward.DS().totalRewardSupply =\\n      LibReward.DS().totalRewardSupply +\\n      _newBalance -\\n      currentBalance;\\n\\n    if (_newBalance > currentBalance) {\\n      _add(_owner, _newBalance - currentBalance);\\n    } else if (_newBalance < currentBalance) {\\n      _subtract(_owner, currentBalance - _newBalance);\\n    } else {\\n      return;\\n    }\\n  }\\n\\n  function _set(address key, uint256 val) internal {\\n    Map storage rewardHolders = LibReward.DS().rewardHolders;\\n    if (rewardHolders.inserted[key]) {\\n      rewardHolders.values[key] = val;\\n    } else {\\n      rewardHolders.inserted[key] = true;\\n      rewardHolders.values[key] = val;\\n      rewardHolders.indexOf[key] = rewardHolders.keys.length;\\n      rewardHolders.keys.push(key);\\n    }\\n  }\\n\\n  function _remove(address key) internal {\\n    Map storage rewardHolders = LibReward.DS().rewardHolders;\\n    if (!rewardHolders.inserted[key]) {\\n      return;\\n    }\\n\\n    delete rewardHolders.inserted[key];\\n    delete rewardHolders.values[key];\\n\\n    uint256 index = rewardHolders.indexOf[key];\\n    uint256 lastIndex = rewardHolders.keys.length - 1;\\n    address lastKey = rewardHolders.keys[lastIndex];\\n\\n    rewardHolders.indexOf[lastKey] = index;\\n    delete rewardHolders.indexOf[key];\\n\\n    rewardHolders.keys[index] = lastKey;\\n    rewardHolders.keys.pop();\\n  }\\n\\n  function _add(address _owner, uint256 value) internal {\\n    LibReward.DS().magnifiedReward[_owner] -= SafeCast.toInt256(\\n      LibReward.DS().magnifiedRewardPerShare * value\\n    );\\n    LibReward.DS().rewardBalances[_owner] += value;\\n  }\\n\\n  function _subtract(address _owner, uint256 value) internal {\\n    LibReward.DS().magnifiedReward[_owner] += SafeCast.toInt256(\\n      LibReward.DS().magnifiedRewardPerShare * value\\n    );\\n    LibReward.DS().rewardBalances[_owner] -= value;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/hamachi/types/reward/RewardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nuint256 constant MAGNITUDE = 2 ** 128;\\n\\nstruct RewardToken {\\n  address token;\\n  address router;\\n  address[] path;\\n  bool useV3;\\n  bytes pathV3;\\n}\\n\\nstruct Map {\\n  address[] keys;\\n  mapping(address => uint256) values;\\n  mapping(address => uint256) indexOf;\\n  mapping(address => bool) inserted;\\n}\\n\\nstruct RewardStorage {\\n  mapping(address => int256) magnifiedReward;\\n  mapping(address => uint256) withdrawnReward;\\n  mapping(address => uint256) claimTimes;\\n  mapping(address => bool) manualClaim;\\n  mapping(address => uint256) rewardBalances;\\n  uint256 totalRewardSupply;\\n  RewardToken rewardToken;\\n  RewardToken goHam;\\n  Map rewardHolders;\\n  uint256 magnifiedRewardPerShare;\\n  uint256 minRewardBalance;\\n  uint256 totalAccruedReward;\\n  uint256 lastProcessedIndex;\\n  uint32 claimTimeout;\\n}\\n\"\r\n    },\r\n    \"src/hamachi/libraries/LibUniswap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {LibHamachi20} from \\\"./LibHamachi20.sol\\\";\\n\\nimport {RewardToken} from \\\"@contracts/hamachi/types/reward/RewardStorage.sol\\\";\\nimport {UniswapStorage} from \\\"../types/uniswap/UniswapStorage.sol\\\";\\n\\nimport {IUniswapV2Router02} from \\\"@contracts/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol\\\";\\nimport {ISwapRouter} from \\\"../interfaces/ISwapRouter.sol\\\";\\n\\nlibrary LibUniswap {\\n  event AddLiquidity(uint256 tokenAmount, uint256 ethAmount);\\n\\n  bytes32 internal constant DIAMOND_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.uniswap.storage\\\");\\n\\n  function DS() internal pure returns (UniswapStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function swapTokensForEth(uint256 tokenAmount) internal {\\n    address router = DS().defaultRouter;\\n    LibHamachi20.approve(address(this), address(router), tokenAmount);\\n\\n    // generate the swap pair path of token -> weth\\n    address[] memory path = new address[](2);\\n    path[0] = address(this);\\n    path[1] = IUniswapV2Router02(router).WETH();\\n\\n    // make the swap\\n    IUniswapV2Router02(router).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n      tokenAmount,\\n      0,\\n      path,\\n      address(this),\\n      block.timestamp\\n    );\\n  }\\n\\n  function addLiquidity(uint256 tokenAmount, uint256 _value) internal {\\n    address router = DS().defaultRouter;\\n    LibHamachi20.approve(address(this), address(router), tokenAmount);\\n    IUniswapV2Router02(router).addLiquidityETH{value: _value}(\\n      address(this),\\n      tokenAmount,\\n      0,\\n      0,\\n      DS().liquidityWallet,\\n      block.timestamp\\n    );\\n    emit AddLiquidity(tokenAmount, _value);\\n  }\\n\\n  function swapUsingV2(\\n    RewardToken memory rewardToken,\\n    uint256 _value,\\n    address _owner,\\n    uint256 _expectedOutput\\n  ) internal returns (bool) {\\n    try\\n      IUniswapV2Router02(rewardToken.router).swapExactETHForTokensSupportingFeeOnTransferTokens{\\n        value: _value\\n      }(_expectedOutput, rewardToken.path, _owner, block.timestamp)\\n    {\\n      return true;\\n    } catch {\\n      return false;\\n    }\\n  }\\n\\n  function swapUsingV3(\\n    RewardToken memory rewardToken,\\n    uint256 _value,\\n    address _owner,\\n    uint256 _expectedOutput\\n  ) internal returns (bool) {\\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\\n      path: rewardToken.pathV3,\\n      recipient: address(_owner),\\n      deadline: block.timestamp,\\n      amountIn: _value,\\n      amountOutMinimum: _expectedOutput\\n    });\\n\\n    try ISwapRouter(rewardToken.router).exactInput{value: _value}(params) {\\n      return true;\\n    } catch {\\n      return false;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/hamachi/types/uniswap/UniswapStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport {Fee} from \\\"../fee/Fee.sol\\\";\\n\\nstruct UniswapStorage {\\n  address liquidityWallet;\\n  address defaultRouter;\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/proxy-etherscan/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"../diamond/LibDiamond.sol\\\";\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\n\\nabstract contract Proxy {\\n  bytes32 internal constant IMPLEMENTATION_SLOT =\\n    bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1);\\n  event Upgraded(address indexed implementation);\\n\\n  function implementation() public view returns (address) {\\n    return _getImplementation();\\n  }\\n\\n  /**\\n   * @dev Returns the current implementation address.\\n   */\\n  function _getImplementation() internal view returns (address) {\\n    return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n  }\\n\\n  /**\\n   * @dev Stores a new address in the EIP1967 implementation slot.\\n   */\\n  function _setImplementation(address newImplementation) internal {\\n    LibDiamond.enforceHasContractCode(newImplementation);\\n    StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    emit Upgraded(newImplementation);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/diamond/DiamondLoupeFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"./LibDiamond.sol\\\";\\nimport {DiamondStorage} from \\\"./DiamondStorage.sol\\\";\\nimport {IDiamondLoupe} from \\\"./IDiamondLoupe.sol\\\";\\n\\nimport {Facet} from \\\"./Facet.sol\\\";\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe {\\n  // Diamond Loupe Functions\\n  ////////////////////////////////////////////////////////////////////\\n  /// These functions are expected to be called frequently by tools.\\n  //\\n  // struct Facet {\\n  //     address facetAddress;\\n  //     bytes4[] functionSelectors;\\n  // }\\n\\n  /// @notice Gets all facets and their selectors.\\n  /// @return facets_ Facet\\n  function facets() external view override returns (Facet[] memory facets_) {\\n    DiamondStorage storage ds = LibDiamond.DS();\\n    uint256 numFacets = ds.facetAddresses.length;\\n    facets_ = new Facet[](numFacets);\\n    for (uint256 i = 0; i < numFacets; ) {\\n      address facetAddress_ = ds.facetAddresses[i];\\n      facets_[i].facetAddress = facetAddress_;\\n      facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Gets all the function selectors provided by a facet.\\n  /// @param _facet The facet address.\\n  /// @return facetFunctionSelectors_\\n  function facetFunctionSelectors(\\n    address _facet\\n  ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\\n    DiamondStorage storage ds = LibDiamond.DS();\\n    facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\\n  }\\n\\n  /// @notice Get all the facet addresses used by a diamond.\\n  /// @return facetAddresses_\\n  function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n    DiamondStorage storage ds = LibDiamond.DS();\\n    facetAddresses_ = ds.facetAddresses;\\n  }\\n\\n  /// @notice Gets the facet that supports the given selector.\\n  /// @dev If facet is not found return address(0).\\n  /// @param _functionSelector The function selector.\\n  /// @return facetAddress_ The facet address.\\n  function facetAddress(\\n    bytes4 _functionSelector\\n  ) external view override returns (address facetAddress_) {\\n    DiamondStorage storage ds = LibDiamond.DS();\\n    facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/utils/ArrayLibUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Bytes4ArrayLibUtils {\\n  function indexOf(bytes4[] memory array, bytes4 value) internal pure returns (uint256) {\\n    uint256 length = array.length;\\n    for (uint256 i = 0; i < length; ) {\\n      if (array[i] == value) return i;\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return type(uint256).max;\\n  }\\n\\n  function filterOut(bytes4[] memory array, bytes4 value) internal pure returns (bytes4[] memory) {\\n    uint256 index = indexOf(array, value);\\n    if (index == type(uint256).max) return array;\\n\\n    bytes4[] memory newArray = new bytes4[](array.length - 1);\\n    for (uint256 i = 0; i < index; ) {\\n      newArray[i] = array[i];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    uint256 length = newArray.length;\\n    for (uint256 i = index; i < length; ) {\\n      newArray[i] = array[i + 1];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return newArray;\\n  }\\n}\\n\\nlibrary AddressArrayLibUtils {\\n  function indexOf(address[] memory array, address value) internal pure returns (uint256) {\\n    for (uint256 i = 0; i < array.length; ) {\\n      if (array[i] == value) return i;\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return type(uint256).max;\\n  }\\n\\n  function filterOut(\\n    address[] memory array,\\n    address value\\n  ) internal pure returns (address[] memory) {\\n    uint256 index = indexOf(array, value);\\n    if (index == type(uint256).max) return array;\\n\\n    address[] memory newArray = new address[](array.length - 1);\\n    for (uint256 i = 0; i < index; ) {\\n      newArray[i] = array[i];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    uint256 length = newArray.length;\\n    for (uint256 i = index; i < length; ) {\\n      newArray[i] = array[i + 1];\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return newArray;\\n  }\\n\\n  function swapOut(address[] storage array, address value) internal {\\n    uint256 index = indexOf(array, value);\\n    address last = array[array.length - 1];\\n    array[index] = last;\\n    array.pop();\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/LibAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {AccessControlStorage} from \\\"./AccessControlStorage.sol\\\";\\nimport {DEFAULT_ADMIN_ROLE} from \\\"./Roles.sol\\\";\\nimport {AddressArrayLibUtils} from \\\"../../utils/ArrayLibUtils.sol\\\";\\n\\nlibrary LibAccessControl {\\n  using AddressArrayLibUtils for address[];\\n\\n  error Unauthorized(bytes32 role);\\n  error AlreadyHasRole(bytes32 role);\\n  error RoleNotSet(bytes32 role);\\n  error RenounceAccountNotMsgSender(address account);\\n\\n  /**\\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n   *\\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n   * {RoleAdminChanged} not being emitted signaling this.\\n   *\\n   * _Available since v3.1._\\n   */\\n  event RoleAdminChanged(\\n    bytes32 indexed role,\\n    bytes32 indexed previousAdminRole,\\n    bytes32 indexed newAdminRole\\n  );\\n\\n  /**\\n   * @dev Emitted when `account` is granted `role`.\\n   *\\n   * `sender` is the account that originated the contract call, an admin role\\n   * bearer except when using {AccessControl-_setupRole}.\\n   */\\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  /**\\n   * @dev Emitted when `account` is revoked `role`.\\n   *\\n   * `sender` is the account that originated the contract call:\\n   *   - if using `revokeRole`, it is the admin role bearer\\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n   */\\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n  bytes32 internal constant ACCESS_CONTROL_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.accesscontrol.storage\\\");\\n\\n  function DS() internal pure returns (AccessControlStorage storage ds) {\\n    bytes32 position = ACCESS_CONTROL_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function hasRole(bytes32 role, address account) internal view returns (bool) {\\n    return DS().roles[role].members[account];\\n  }\\n\\n  function checkRole(bytes32 role, address account) internal view {\\n    if (!hasRole(role, account)) revert Unauthorized(role);\\n  }\\n\\n  function checkRole(bytes32 role) internal view {\\n    checkRole(role, msg.sender);\\n  }\\n\\n  function getRoleAdmin(bytes32 role) internal view returns (bytes32) {\\n    return DS().roles[role].adminRole;\\n  }\\n\\n  function grantRole(bytes32 role, address account) internal {\\n    if (!hasRole(role, account)) {\\n      DS().roles[role].members[account] = true;\\n      emit RoleGranted(role, account, msg.sender);\\n    } else revert AlreadyHasRole(role);\\n  }\\n\\n  function revokeRole(bytes32 role, address account) internal {\\n    if (hasRole(role, account)) {\\n      DS().roles[role].members[account] = false;\\n      emit RoleRevoked(role, account, msg.sender);\\n    } else revert RoleNotSet(role);\\n  }\\n\\n  function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n    emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n    DS().roles[role].adminRole = adminRole;\\n  }\\n\\n  function renounceRole(bytes32 role, address account) internal {\\n    if (account != msg.sender) revert RenounceAccountNotMsgSender(account);\\n    revokeRole(role, account);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/AccessControlFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {IAccessControlEnumerable} from \\\"./IAccessControlEnumerable.sol\\\";\\nimport {WithRoles} from \\\"./WithRoles.sol\\\";\\nimport {LibAccessControl} from \\\"./LibAccessControl.sol\\\";\\nimport {AccessControlStorage} from \\\"./AccessControlStorage.sol\\\";\\nimport {DEFAULT_ADMIN_ROLE} from \\\"./Roles.sol\\\";\\n\\ncontract AccessControlFacet is IAccessControl, WithRoles {\\n  function hasRole(bytes32 _role, address _account) external view override returns (bool) {\\n    AccessControlStorage storage ds = LibAccessControl.DS();\\n    return ds.roles[_role].members[_account];\\n  }\\n\\n  function getRoleAdmin(bytes32 _role) external view override returns (bytes32) {\\n    AccessControlStorage storage ds = LibAccessControl.DS();\\n    return ds.roles[_role].adminRole;\\n  }\\n\\n  function grantRole(\\n    bytes32 _role,\\n    address _account\\n  ) external override onlyRole(LibAccessControl.getRoleAdmin(_role)) {\\n    LibAccessControl.grantRole(_role, _account);\\n  }\\n\\n  function revokeRole(\\n    bytes32 _role,\\n    address _account\\n  ) external override onlyRole(LibAccessControl.getRoleAdmin(_role)) {\\n    LibAccessControl.revokeRole(_role, _account);\\n  }\\n\\n  function renounceRole(bytes32 _role, address _account) external override {\\n    LibAccessControl.renounceRole(_role, _account);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/utils/introspection/erc165/LibERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ERC165Storage} from \\\"./ERC165Storage.sol\\\";\\n\\nlibrary LibERC165 {\\n  bytes32 internal constant ERC165_STORAGE_POSITION = keccak256(\\\"diamond.standard.erc165.storage\\\");\\n\\n  function DS() internal pure returns (ERC165Storage storage ds) {\\n    bytes32 position = ERC165_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  function addSupportedInterfaces(bytes4[] memory _interfaces) internal {\\n    ERC165Storage storage ds = DS();\\n    uint256 length = _interfaces.length;\\n    for (uint256 i; i < length; ) {\\n      ds.supportedInterfaces[_interfaces[i]] = true;\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function addSupportedInterface(bytes4 _interface) internal {\\n    ERC165Storage storage ds = DS();\\n    ds.supportedInterfaces[_interface] = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/utils/introspection/erc165/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct ERC165Storage {\\n  // Used to query if a contract implements an interface.\\n  // Used to implement ERC-165.\\n  mapping(bytes4 => bool) supportedInterfaces;\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/utils/introspection/erc165/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n  /// @notice Query if a contract implements an interface\\n  /// @param interfaceId The interface identifier, as specified in ERC-165\\n  /// @dev Interface identification is specified in ERC-165. This function\\n  ///  uses less than 30,000 gas.\\n  /// @return `true` if the contract implements `interfaceID` and\\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/hamachi/types/hamachi/HamachiRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nbytes32 constant EXCLUDED_FROM_FEE_ROLE = keccak256(\\\"EXCLUDED_FROM_FEE_ROLE\\\");\\nbytes32 constant EXCLUDED_FROM_MAX_WALLET_ROLE = keccak256(\\\"EXCLUDED_FROM_MAX_WALLET_ROLE\\\");\\nbytes32 constant EXCLUDED_FROM_REWARD_ROLE = keccak256(\\\"EXCLUDED_FROM_REWARD_ROLE\\\");\\nbytes32 constant PROCESS_FEE_ROLE = keccak256(\\\"PROCESS_FEE_ROLE\\\");\\nbytes32 constant VESTING_ROLE = keccak256(\\\"VESTING_ROLE\\\");\\n\"\r\n    },\r\n    \"src/hamachi/libraries/LibHamachi20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Hamachi20Storage} from \\\"../types/hamachi/Hamachi20Storage.sol\\\";\\n\\nimport {LibAccessControlEnumerable} from \\\"@lib-diamond/src/access/access-control/LibAccessControlEnumerable.sol\\\";\\n\\nimport {LibHamachi} from \\\"../libraries/LibHamachi.sol\\\";\\nimport {PERCENTAGE_DENOMINATOR} from \\\"../types/hamachi/HamachiStorage.sol\\\";\\nimport {LibReward} from \\\"../libraries/LibReward.sol\\\";\\n\\nimport {EXCLUDED_FROM_MAX_WALLET_ROLE} from \\\"../types/hamachi/HamachiRoles.sol\\\";\\n\\nerror ExceedsMaxWallet(address recipient, uint256 amount);\\nerror TransferFromZeroAddress();\\nerror TransferToZeroAddress();\\nerror TransferAmountExceedsBalance(uint256 amount, uint256 balance);\\nerror MintToZeroAddress();\\nerror BurnFromZeroAddress();\\nerror BurnAmountExceedsBalance(uint256 amount, uint256 balance);\\nerror InsufficientAllowance(uint256 amount, uint256 allowance);\\n\\nerror InvalidPermit(address recovered, address owner);\\nerror PermitExpired(uint256 deadline);\\n\\nlibrary LibHamachi20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function _checkMaxWallet(address recipient, uint256 amount) internal view {\\n    if (\\n      !LibAccessControlEnumerable.hasRole(EXCLUDED_FROM_MAX_WALLET_ROLE, recipient) &&\\n      LibHamachi20.balanceOf(recipient) + amount > LibHamachi.DS().maxTokenPerWallet\\n    ) revert ExceedsMaxWallet(recipient, amount);\\n  }\\n\\n  bytes32 internal constant ERC20_STORAGE_POSITION =\\n    keccak256(\\\"diamond.standard.erc20permit.storage\\\");\\n\\n  bytes32 internal constant PERMIT_TYPEHASH =\\n    keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH =\\n    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n\\n  function DS() internal pure returns (Hamachi20Storage storage ds) {\\n    bytes32 position = ERC20_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  // This implements ERC-20.\\n  function totalSupply() internal view returns (uint256) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    return ds.totalSupply;\\n  }\\n\\n  // This implements ERC-20.\\n  function balanceOf(address _owner) internal view returns (uint256) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    return ds.balances[_owner];\\n  }\\n\\n  // This implements ERC-20.\\n  function transfer(address to, uint256 amount) internal returns (bool) {\\n    _transfer(msg.sender, to, amount);\\n    return true;\\n  }\\n\\n  // This implements ERC-20.\\n  function allowance(address _owner, address _spender) internal view returns (uint256) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    return ds.allowances[_owner][_spender];\\n  }\\n\\n  // This implements ERC-20.\\n  function approve(address _owner, address _spender, uint256 _value) internal returns (bool) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    ds.allowances[_owner][_spender] = _value;\\n    emit Approval(_owner, _spender, _value);\\n    return true;\\n  }\\n\\n  // This implements ERC-20.\\n  function transferFrom(address from, address to, uint256 amount) internal returns (bool) {\\n    _spendAllowance(from, msg.sender, amount);\\n    _transfer(from, to, amount);\\n    return true;\\n  }\\n\\n  // This implements ERC-20.\\n  function _transfer(address from, address to, uint256 amount) internal returns (bool) {\\n    _checkMaxWallet(to, amount);\\n\\n    bool processingFees = LibHamachi.DS().processingFees;\\n    (uint256 taxFee, bool isSell) = LibHamachi.determineFee(from, to);\\n    if (taxFee > 0) {\\n      uint256 taxAmount = amount / (PERCENTAGE_DENOMINATOR + taxFee);\\n      taxAmount = amount - (taxAmount * PERCENTAGE_DENOMINATOR);\\n\\n      if (taxAmount > 0) _transferInternal(from, address(this), taxAmount);\\n\\n      uint256 sendAmount = amount - taxAmount;\\n      if (sendAmount > 0) _transferInternal(from, to, sendAmount);\\n    } else {\\n      _transferInternal(from, to, amount);\\n    }\\n\\n    LibReward.setRewardBalance(from, balanceOf(from));\\n    LibReward.setRewardBalance(to, balanceOf(to));\\n\\n    if (isSell && !processingFees && LibHamachi.DS().processRewards) LibReward.processRewards();\\n    return true;\\n  }\\n\\n  function _transferInternal(address from, address to, uint256 amount) internal {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    if (from == address(0)) revert TransferFromZeroAddress();\\n    if (to == address(0)) revert TransferToZeroAddress();\\n\\n    uint256 fromBalance = ds.balances[from];\\n    if (fromBalance < amount) revert TransferAmountExceedsBalance(amount, fromBalance);\\n    unchecked {\\n      ds.balances[from] = fromBalance - amount;\\n      // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n      // decrementing then incrementing.\\n      ds.balances[to] += amount;\\n    }\\n\\n    emit Transfer(from, to, amount);\\n  }\\n\\n  function mint(address _account, uint256 _amount) internal {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    if (_account == address(0)) revert MintToZeroAddress();\\n    unchecked {\\n      ds.totalSupply += _amount;\\n      ds.balances[_account] += _amount;\\n    }\\n    emit Transfer(address(0), _account, _amount);\\n  }\\n\\n  function burn(address _account, uint256 _amount) internal {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    if (_account == address(0)) revert BurnFromZeroAddress();\\n    uint256 accountBalance = ds.balances[_account];\\n    if (accountBalance < _amount) revert BurnAmountExceedsBalance(_amount, accountBalance);\\n    unchecked {\\n      ds.totalSupply -= _amount; // we already checked for balance above\\n      ds.balances[_account] = accountBalance - _amount;\\n    }\\n    emit Transfer(_account, address(0), _amount);\\n  }\\n\\n  function increaseAllowance(\\n    address _owner,\\n    address _spender,\\n    uint256 _addedValue\\n  ) internal returns (bool) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    ds.allowances[_owner][_spender] += _addedValue;\\n    emit Approval(_owner, _spender, ds.allowances[_owner][_spender]);\\n    return true;\\n  }\\n\\n  function decreaseAllowance(\\n    address _owner,\\n    address _spender,\\n    uint256 _subtractedValue\\n  ) internal returns (bool) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    uint256 oldValue = ds.allowances[_owner][_spender];\\n    if (_subtractedValue >= oldValue) {\\n      ds.allowances[_owner][_spender] = 0;\\n    } else {\\n      unchecked {\\n        ds.allowances[_owner][_spender] -= _subtractedValue;\\n      }\\n    }\\n\\n    emit Approval(_owner, _spender, ds.allowances[_owner][_spender]);\\n    return true;\\n  }\\n\\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\\n    uint256 currentAllowance = allowance(owner, spender);\\n    if (currentAllowance != type(uint256).max) {\\n      if (currentAllowance < amount) revert InsufficientAllowance(amount, currentAllowance);\\n      unchecked {\\n        approve(owner, spender, currentAllowance - amount);\\n      }\\n    }\\n  }\\n\\n  /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 LOGIC\\n  //////////////////////////////////////////////////////////////*/\\n\\n  function computeDomainSeparator(string memory version) internal view returns (bytes32) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    return\\n      keccak256(\\n        abi.encode(\\n          DOMAIN_SEPARATOR_TYPEHASH,\\n          keccak256(bytes(ds.name)),\\n          keccak256(bytes(version)),\\n          block.chainid,\\n          address(this)\\n        )\\n      );\\n  }\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s,\\n    bytes32 domainSeparator\\n  ) internal {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    if (deadline < block.timestamp) revert PermitExpired(deadline);\\n\\n    bytes32 structHash = keccak256(\\n      abi.encode(PERMIT_TYPEHASH, owner, spender, value, ds.nonces[owner]++, deadline)\\n    );\\n\\n    bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n    if (recoveredAddress == address(0) || recoveredAddress != owner)\\n      revert InvalidPermit(recoveredAddress, owner);\\n\\n    approve(owner, spender, value);\\n  }\\n\\n  function nonces(address owner) internal view returns (uint256) {\\n    Hamachi20Storage storage ds = LibHamachi20.DS();\\n    return ds.nonces[owner];\\n  }\\n}\\n\"\r\n    },\r\n    \"src/hamachi/types/fee/Fee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nstruct Fee {\\n  uint32 liquidityBuyFee;\\n  uint32 rewardBuyFee;\\n  uint32 liquiditySellFee;\\n  uint32 rewardSellFee;\\n}\\n\"\r\n    },\r\n    \"src/hamachi/interfaces/IVestingSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IVestingSchedule {\\n  function getVestingSchedule(\\n    address _beneficiary\\n  )\\n    external\\n    view\\n    returns (\\n      bool initialized,\\n      address beneficiary,\\n      uint256 cliff,\\n      uint256 start,\\n      uint256 duration,\\n      uint256 slicePeriodSeconds,\\n      uint256 amountTotal,\\n      uint256 released\\n    );\\n\\n  function computeReleasableAmount(address _beneficiary) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/uniswap/v2-periphery/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/hamachi/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport \\\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n  struct ExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function exactInputSingle(\\n    ExactInputSingleParams calldata params\\n  ) external payable returns (uint256 amountOut);\\n\\n  struct ExactInputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountIn;\\n    uint256 amountOutMinimum;\\n  }\\n\\n  /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n  /// @return amountOut The amount of the received token\\n  function exactInput(\\n    ExactInputParams calldata params\\n  ) external payable returns (uint256 amountOut);\\n\\n  struct ExactOutputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint24 fee;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 amountInMaximum;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n  /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function exactOutputSingle(\\n    ExactOutputSingleParams calldata params\\n  ) external payable returns (uint256 amountIn);\\n\\n  struct ExactOutputParams {\\n    bytes path;\\n    address recipient;\\n    uint256 deadline;\\n    uint256 amountOut;\\n    uint256 amountInMaximum;\\n  }\\n\\n  /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n  /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n  /// @return amountIn The amount of the input token\\n  function exactOutput(\\n    ExactOutputParams calldata params\\n  ) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/proxy-etherscan/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n */\\nlibrary StorageSlot {\\n  struct AddressSlot {\\n    address value;\\n  }\\n\\n  struct BooleanSlot {\\n    bool value;\\n  }\\n\\n  struct Bytes32Slot {\\n    bytes32 value;\\n  }\\n\\n  struct Uint256Slot {\\n    uint256 value;\\n  }\\n\\n  /**\\n   * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n   */\\n  function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n    assembly {\\n      r.slot := slot\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n   */\\n  function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n    assembly {\\n      r.slot := slot\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n   */\\n  function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n    assembly {\\n      r.slot := slot\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n   */\\n  function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n    assembly {\\n      r.slot := slot\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/lib-diamond/src/access/access-control/AccessControlStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct RoleData {\\n  mapping(address => bool) members;\\n  bytes32 adminRole;\\n}\\n\\nstruct AccessControlStorage {\\n  mapping(bytes32 => RoleData) roles;\\n}\\n\"\r\n    },\r\n    \"src/hamachi/types/hamachi/Hamachi20Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Hamachi20Storage {\\n  mapping(address => uint256) balances;\\n  mapping(address => mapping(address => uint256)) allowances;\\n  uint256 totalSupply;\\n  string name;\\n  string symbol;\\n  mapping(address => uint256) nonces;\\n}\\n\"\r\n    },\r\n    \"src/uniswap/v2-periphery/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountOut);\\n\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountIn);\\n\\n  function getAmountsOut(\\n    uint amountIn,\\n    address[] calldata path\\n  ) external view returns (uint[] memory amounts);\\n\\n  function getAmountsIn(\\n    uint amountOut,\\n    address[] calldata path\\n  ) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"lib/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@contracts/=src/\",\r\n      \"@forge-std/=lib/forge-std/\",\r\n      \"@lib-diamond/=lib/lib-diamond/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@solmate/=lib/solmate/\",\r\n      \"@src/=src/\",\r\n      \"@test/=test/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"@uniswap/v2-periphery/=lib/v2-periphery/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"lib-diamond/=lib/lib-diamond/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/v3-core/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidityWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"diamondCutAndLoupeFacet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessControlEnumerableFacet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc165Facet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"methodsExposureFacetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"AlreadyHasRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyCalldata\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"functionSignature\",\"type\":\"bytes4\"}],\"name\":\"FunctionNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"ImmutableFunction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InValidFacetCutAction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSelectorsInFacet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonEmptyCalldata\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"NonExistentSelector\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"SameSelectorReplacement\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"SelectorExists\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "000000000000000000000000c6a47ca3ca531780902bad39ec0c91d497d1f99b00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c0000000000000000000000005fdc879d4414b449efaaa372e25e61eef25c0d9000000000000000000000000043bc2f2e1166c4d4b2b95c10b26083ec0438db3e00000000000000000000000029dc75ee3ab6e81c4eb32ea5a102f2a74683c0730000000000000000000000007edef9818ff64e77b73f415a0df95ef68cc4c9a4000000000000000000000000edacd277695146f45ebe84f0f02309bf3f418821", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xedacd277695146f45ebe84f0f02309bf3f418821", "SwarmSource": ""}