{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-05-10\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2022-05-09\r\n*/\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n    \r\n    function symbol() external view returns (string memory);\r\n    \r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function transfer(address dst, uint256 amount) external returns (bool success);\r\n\r\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool success);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n}\r\n\r\n\r\ninterface TenFiFarm {\r\n\r\n    function poolInfo(uint256 pid) external view returns(address want,uint256 allocPoint ,uint256 lastRewardBlock ,uint256 accTENFIPerShare ,address strat);\r\n\r\n    function stakedWantTokens(uint256 pid,address user) external view returns(uint256);\r\n}\r\n\r\n\r\ninterface BiswapFarm {\r\n\r\n    function poolInfo(uint256 pid) external view returns(address lpToken,uint256 allocPoint,uint256 lastRewardBlock,uint256 accBSWPerShare);\r\n\r\n    function userInfo(uint256 pid,address user) external view returns(uint256 amount,uint256 rewardDebt);\r\n}\r\n\r\n\r\ninterface BeefyFarm {\r\n\r\n    function balanceOf(address user) external view returns(uint256);\r\n\r\n    function balance() external view returns(uint256);\r\n\r\n    function totalSupply() external view returns(uint256);\r\n\r\n    function want() external view returns(address);\r\n\r\n}\r\n\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract Airdrop is Ownable,ReentrancyGuard {\r\n\r\n    \r\n   /**\r\n    * @notice \r\n    * NOT_ENTERD = USER HAS NOT REGISTERED FOR AIRDROP\r\n    * INSIDE = USER IS PRESENT IN AIRDROP\r\n    * FINISHED = USER GET ALL 4 ROUND REWARDS IN 360 DAYS DURATION\r\n    * EXPELLED = USER'S TENFI BALANCE IS LESS THAN THE TENFI HE HAS AT TIME OF AIRDROP REGISTRATION \r\n    */\r\n    enum Status {\r\n        NOT_ENTERED,\r\n        INSIDE,\r\n        FINISHED,\r\n        EXPELLED\r\n    }\r\n\r\n\r\n   /**\r\n    * @notice Container for user round data information\r\n    * @member isClaim = user has got airdrop rewards for this round or not\r\n    * @member claimAmount = how much airdrop rewards for this round user got\r\n    */\r\n    struct UserRoundData {\r\n        bool isClaim;\r\n        uint256 claimAmount;\r\n    }\r\n\r\n   /**\r\n    * @notice addressof tenfi token\r\n    */\r\n    address public constant TENFI_ADDRESS = 0xd15C444F1199Ae72795eba15E8C1db44E47abF62;\r\n\r\n   /**\r\n    * @notice address which has right to transfer and register the register for airdrop\r\n    */\r\n    address public transferrer;\r\n\r\n\r\n   /**\r\n    * @notice address of farms\r\n    */\r\n    address public constant TENFI_FARM  = 0x264A1b3F6db28De4D3dD4eD23Ab31A468B0C1A96;\r\n    address public constant BISWAP_FARM = 0xDbc1A13490deeF9c3C12b44FE77b503c1B061739;\r\n    address[] public beefyFarms = [0x0Ce6FeC7521b7d054b5B0a5F43D49120f9d6CFbc,0x00F204F524a433f45a6278c2C0E10F5292b3C5B9];\r\n\r\n   /**\r\n    * @notice EIP20Interface type of lend token Address\r\n    */\r\n    IERC20 public _lendAddress;\r\n\r\n   /**\r\n    * @notice multiplier for getting airdrop rewards for his tenfi amount at registration time   \r\n    */\r\n    uint256 public constant AIRDROP_REWARDS_INCREASE_FACTOR = 2e18;\r\n\r\n   /**\r\n    * @notice this is rewards duration for each round in 360 days   \r\n    */\r\n    uint256 public constant REWARDS_DURATION = 7776000;\r\n\r\n   /**\r\n    * @notice this is min qualify amount to register in airdrop   \r\n    */\r\n    uint256 public constant MIN_QUALIFY_AMOUNT = 10000e18;\r\n\r\n   /**\r\n    * @notice timstamp at which airdrop will start for all registered users\r\n    */\r\n    uint256 public airdropStartTime;\r\n\r\n   /**\r\n    * @notice timstamp at which airdrop registration will end\r\n    */\r\n    uint256 public registrationEndTime;\r\n\r\n   /**\r\n    * @notice total LEND alloted to users who have registered succesfully before first airdrop\r\n    */\r\n    uint256 public totalLendAllotedToUsers;\r\n\r\n   /**\r\n    * @notice total amount of LEND airdrpped till now\r\n    */\r\n    uint256 public totalLendAirdropped;\r\n\r\n   /**\r\n    * @notice mapping to check whether user is eligible for airdrop \r\n    */\r\n    mapping (address => Status) public isUserInAirdrop;\r\n\r\n   /**\r\n    * @notice mapping to check whether user is eligible for airdrop \r\n    */\r\n    mapping (address => uint256) public userLastClaimRound;\r\n\r\n   /**\r\n    * @notice mapping to get user's claimed balance in each 90 days interval\r\n    */\r\n    mapping (address => mapping(uint256 => UserRoundData)) public userClaimDetails;\r\n\r\n   /**\r\n    * @notice update this mapping once user has successfully registered for airdrop\r\n    */\r\n    mapping (address => uint256) public tenfiAtWhichUserIsRegistered;\r\n    \r\n   /**\r\n    * @notice update this mapping once user has successfully registered for airdrop\r\n    */\r\n    mapping (address => uint256) public totalLendAlloted;\r\n\r\n   /**\r\n    * @notice update this mapping once user has successfully registered for airdrop\r\n    * its value will be totalLendAlloted to this address divide by 4\r\n    */\r\n    mapping (address => uint256) public lendToGivenEvery90Days;\r\n    \r\n   /**\r\n    * @notice store user addresses who registered for airdrop\r\n    */\r\n    address[] public registeredUsers;\r\n\r\n   /**\r\n    * @notice store user addresses who are expelled\r\n    */\r\n    address[] public expelledUsers;\r\n\r\n   /**\r\n    * @notice store vault poolId's to count user balance in it\r\n    */\r\n    uint[] public registeredTenfiFarmVaultsId = [14,61,95];\r\n\r\n   /**\r\n    * @notice store vault poolId's to count user balance in it\r\n    */\r\n    uint[] public registeredBiswapFarmVaultsId = [59,113];\r\n    \r\n    /**\r\n    * @notice total amount of tokens to be distributed\r\n    */\r\n    uint256 public totalTokenToBeDistributed = 100000000e18; // 100 million Tokens to be distributed\r\n\r\n    /**\r\n    * @notice total amount of tokens left to be distributed\r\n    */\r\n    uint256 public totalTokenLeftToBeDistributed = totalTokenToBeDistributed;\r\n\r\n   /**\r\n    * @notice store index of user address in registeredUsers array\r\n    */\r\n    mapping(address => uint256) public userIndexInRegistered;\r\n    \r\n    \r\n    event TransferrerSet(address oldTransferrer, address newTransferrer);\r\n\r\n    event TransferrerRemoved(address oldTransferrer);\r\n    \r\n    event lendTransfered(address user,uint256 round,uint256 amount);\r\n\r\n    event lendWithdrawn(uint256);\r\n\r\n    constructor (IERC20 lendAddress,uint _registrationEndTime,uint _airdropStartTime) {\r\n        _lendAddress = lendAddress;\r\n        registrationEndTime = _registrationEndTime;\r\n        airdropStartTime = _airdropStartTime;\r\n        registeredUsers.push(address(0));\r\n    }\r\n\r\n    modifier OnlyTransferrer() {\r\n        require(msg.sender == transferrer, \"only transferrer can call\");\r\n        _;\r\n    }\r\n\r\n    function endDate() external view returns(uint) {\r\n        return airdropStartTime + (4 * REWARDS_DURATION);\r\n    }\r\n\r\n    function editTotalTokenToBeDistributed(uint256 amount) external onlyOwner {\r\n        totalTokenToBeDistributed = amount;\r\n        totalTokenLeftToBeDistributed = totalTokenToBeDistributed;\r\n    }\r\n\r\n    function changeAirdropStartTime(uint new_time) external onlyOwner{\r\n        airdropStartTime = new_time;\r\n    }\r\n\r\n    function changeRegistrationEndTime(uint new_time) external onlyOwner{\r\n        registrationEndTime = new_time;\r\n    }\r\n\r\n   /**\r\n    * @notice Owner can withdraw the lend tokens at any time\r\n    * @param amount The amount of the LEND tokens owner wants to withdraw \r\n    * @return success (bool) boolean value whether transaction is successful or not.\r\n    */\r\n    function withdrawLend(uint256 amount) external onlyOwner returns(bool success){\r\n        success = _lendAddress.transfer(owner(), amount); \r\n        require(success,\"withdraw failed\"); \r\n        emit lendWithdrawn(amount);\r\n    }\r\n\r\n\r\n   /**\r\n    * @notice User can register for airdrop \r\n    *\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - current time should be less than starting time of airdrop.\r\n    * - at time of registration user's tenfi balance should greater\r\n    *   than or equal to minimum qualifying amount.\r\n    * - user cannot register again for the airdrop.\r\n    */\r\n    function register() external nonReentrant {\r\n\r\n        require(block.timestamp < registrationEndTime && totalTokenLeftToBeDistributed > 0,\"Registration time already ended or Lend Distributed\");\r\n\r\n        address user = _msgSender();\r\n\r\n        uint256 tenfi_amount = getUserTenfiBalance(user);\r\n\r\n        require(tenfi_amount >= MIN_QUALIFY_AMOUNT,\"Insufficient tenfi balance to qualify\");\r\n\r\n        uint256 alloted = (tenfi_amount * AIRDROP_REWARDS_INCREASE_FACTOR) / 1e18;\r\n        \r\n\r\n        /**\r\n         * @notice first reduce the tokens alotted to the \r\n         * user and add it to Lend available to be distributed\r\n         * then checking if the contract have the required \r\n         * amount of Lend left, if not the remaining \r\n         * amount of Lend will be alloted to user\r\n        */\r\n        totalLendAllotedToUsers -= totalLendAlloted[user];\r\n        totalTokenLeftToBeDistributed += totalLendAlloted[user];\r\n        alloted = (totalTokenLeftToBeDistributed < alloted) ? totalTokenLeftToBeDistributed : alloted;\r\n\r\n        totalLendAlloted[user] = alloted;\r\n        totalTokenLeftToBeDistributed -= alloted;\r\n        totalLendAllotedToUsers += alloted;\r\n        lendToGivenEvery90Days[user] = alloted / 4;\r\n        tenfiAtWhichUserIsRegistered[user] = tenfi_amount;\r\n\r\n        if(userIndexInRegistered[user] == 0) {\r\n            isUserInAirdrop[user] = Status.INSIDE;\r\n            registeredUsers.push(user);\r\n            userIndexInRegistered[user] = registeredUsers.length - 1;\r\n        }\r\n\r\n    }\r\n\r\n   /**\r\n    * @notice Transferrer can Expell a user from airdrop\r\n    * @param user address of user transferrer want to expell\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - Given user should present in the airdrop at time of expelling.\r\n    */\r\n    function changeStatusToExpelled(address user) external OnlyTransferrer {\r\n\r\n        require(isUserInAirdrop[user] == Status.INSIDE,\"User Already Finished or Expelled or Not Entered\");\r\n\r\n        isUserInAirdrop[user] = Status.EXPELLED;\r\n\r\n        address user_on_last_index = registeredUsers[registeredUsers.length - 1];\r\n\r\n        if(user_on_last_index != user){\r\n            uint256 index_of_user = userIndexInRegistered[user];\r\n            registeredUsers[index_of_user] = user_on_last_index;\r\n            userIndexInRegistered[user_on_last_index] = index_of_user;\r\n        }\r\n\r\n        uint lastRound = userLastClaimRound[user];\r\n        uint factor = 4 - lastRound;\r\n        uint subValue = factor * lendToGivenEvery90Days[user];\r\n        totalLendAllotedToUsers -= subValue;\r\n            \r\n        registeredUsers.pop();\r\n        expelledUsers.push(user);\r\n        delete userIndexInRegistered[user];\r\n        return;\r\n    }\r\n\r\n   /**\r\n    * @notice Transfer user his pending airdrop rewards\r\n    *\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - User current tenfi balance should be greater than the tenfi \r\n    *   balance at the time of registration.\r\n    * - User does not come early for airdrop. \r\n    */\r\n    function transferLEND() external nonReentrant {\r\n\r\n       /*\r\n        *if user status is INSIDE it means that the user is \r\n        * getting airdrop for 1st round\r\n        * getting airdrop for other rounds except 1st means previous rounds are successfull\r\n        */\r\n\r\n        address user = _msgSender();\r\n\r\n        bool flag = canWeTransferLend(user);// check user has sufficient tenfi balance\r\n        \r\n        require(flag == true,\"User not have sufficient tenfi or not inside the airdrop\");\r\n\r\n        uint256 amount = lendToGivenEvery90Days[user];\r\n\r\n        uint256 last_round = userLastClaimRound[user];\r\n\r\n        uint256 current_round = last_round + 1;\r\n\r\n        uint256 calculated_timestamp = airdropStartTime + (current_round * REWARDS_DURATION);\r\n\r\n        require(calculated_timestamp < block.timestamp ,\"!!Too Early\");\r\n\r\n        uint amountToBeTransferred;\r\n\r\n        while(calculated_timestamp < block.timestamp){\r\n\r\n            UserRoundData storage round_details = userClaimDetails[user][current_round];\r\n\r\n            round_details.isClaim = true;\r\n            round_details.claimAmount = amount;\r\n\r\n            if(current_round == 4) {\r\n                \r\n                isUserInAirdrop[user] = Status.FINISHED;\r\n\r\n                address user_on_last_index = registeredUsers[registeredUsers.length - 1];\r\n\r\n                if(user_on_last_index != user){\r\n                    uint256 index_of_user = userIndexInRegistered[user];\r\n                    registeredUsers[index_of_user] = user_on_last_index;\r\n                    userIndexInRegistered[user_on_last_index] = index_of_user;\r\n                }\r\n            \r\n                registeredUsers.pop();\r\n                delete userIndexInRegistered[user];\r\n            }\r\n\r\n            userLastClaimRound[user] = current_round;\r\n\r\n            amountToBeTransferred += amount;\r\n\r\n            totalLendAirdropped += amount;\r\n        \r\n            emit lendTransfered(user,current_round,amount);\r\n\r\n            if(current_round != 4) {\r\n                current_round = current_round + 1;\r\n                calculated_timestamp = airdropStartTime + (current_round * REWARDS_DURATION);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n        _lendAddress.transfer(user, amountToBeTransferred);\r\n\r\n    }\r\n    \r\n   /**\r\n    * @notice It will the transferrer address\r\n    *\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - only owner can call this function. \r\n    */\r\n    function setTransferrer(address _transferrer) external onlyOwner {\r\n        address oldTransferrer = transferrer;\r\n        transferrer = _transferrer;\r\n        emit TransferrerSet(oldTransferrer, _transferrer);\r\n    }\r\n    \r\n   /**\r\n    * @notice It will remove the transferrer address\r\n    *\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - only owner can call this function. \r\n    */\r\n    function removeTransferrer() external onlyOwner {\r\n        address oldTransferrer = transferrer;\r\n        transferrer = address(0);\r\n        emit TransferrerRemoved(oldTransferrer);\r\n    }\r\n\r\n   /**\r\n    * @notice Get pending LEND token balance of given user\r\n    * @dev This is used by frontend to display pending LEND user has to claim.\r\n    * @param user Address of the account to get pending LEND\r\n    * @return (uint256) pending lend balance\r\n    */\r\n    function getPendingLendOfUser(address user) external view returns(uint256) {\r\n        \r\n        if(isUserInAirdrop[user] == Status.INSIDE){\r\n            \r\n            uint256 amount;\r\n\r\n            uint256 last_round = userLastClaimRound[user];\r\n\r\n            uint256 current_round = last_round + 1;\r\n\r\n            uint256 calculated_timestamp = airdropStartTime + (current_round * REWARDS_DURATION);\r\n\r\n            uint256 flag = 0;\r\n\r\n            while(calculated_timestamp < block.timestamp) {\r\n\r\n                flag = flag + 1;\r\n                current_round = current_round + 1;\r\n\r\n                if(current_round == 5)\r\n                break;\r\n\r\n                calculated_timestamp = airdropStartTime + (current_round * REWARDS_DURATION);\r\n\r\n            }\r\n\r\n            amount = flag * lendToGivenEvery90Days[user];\r\n            return amount;\r\n\r\n        }\r\n        return 0;\r\n    }\r\n\r\n   /**\r\n    * @notice number of users who are still in airdrop process.\r\n    * @dev This is used by backend to tracking and expelling process.\r\n    * @return (uint256) number of users who are still in airdrop process.\r\n    */    \r\n    function getRegisteredUsersLength() external view  returns(uint256) {\r\n        return registeredUsers.length - 1;\r\n    }\r\n\r\n   /**\r\n    * @notice Get array of those users who are still in airdrop process.\r\n    * @dev This is used by backend to tracking and expelling process.\r\n    * @return (uint256[]) users who are still in airdrop process.\r\n    */     \r\n    function getRegisteredUsers() external view returns(address[] memory) {\r\n        \r\n        address[] memory arr = new address[](registeredUsers.length - 1);\r\n        for(uint256 i = 1 ; i < registeredUsers.length ; i++) {\r\n            address user = registeredUsers[i];\r\n            arr[i-1] = user;\r\n        }\r\n        return arr;\r\n    }\r\n\r\n   /**\r\n    * @notice number of users who are expelled in airdrop process.\r\n    * @dev This is used by frontend to show how many users are expelled.\r\n    * @return (uint256) number of users who are expelled in airdrop process.\r\n    */ \r\n    function getExpelledUsersLength() external view returns(uint256) {\r\n        return expelledUsers.length;\r\n    }\r\n\r\n   /**\r\n    * @notice Get array of those users who are expelled in airdrop process.\r\n    * @dev This is used by frontend to show users who are expelled.\r\n    * @return (uint256[]) users who are expelled in airdrop process.\r\n    */  \r\n    function getExpelledUsers() external view returns(address[] memory) {\r\n        \r\n        address[] memory arr = new address[](expelledUsers.length);\r\n        for(uint256 i = 0 ; i < expelledUsers.length ; i++) {\r\n            address user = expelledUsers[i];\r\n            arr[i] = user;\r\n        }\r\n        return arr;\r\n    }\r\n\r\n   /**\r\n    * @notice Get amount of TENFI token present in given amount of LP\r\n    *         in given LP token address.\r\n    * @param lp Address of the LP token in which we have to check tenfi bal.\r\n    * @param amount amount of the LP token for which we have to check tenfi bal.\r\n    * @return result (uint256) amount of TENFI.\r\n    */ \r\n    function getTenfiInThisLp(address lp,uint256 amount) public view returns(uint result) {\r\n        \r\n        uint256 totalSupply = IPancakePair(lp).totalSupply();\r\n\r\n\r\n        address token0 = IPancakePair(lp).token0();\r\n\r\n        uint112 reserves;\r\n        (uint112 reserve0, uint112 reserve1, ) = IPancakePair(lp).getReserves();\r\n        \r\n        if(token0 == TENFI_ADDRESS)\r\n        reserves = reserve0;\r\n        else\r\n        reserves = reserve1;\r\n\r\n        result = (amount * reserves) / totalSupply;\r\n    }\r\n\r\n   /**\r\n    * @notice return user tenfi balance he have in wallet or in farm vaults.\r\n    * @param user Address of the user for which we have to check tenfi balance.\r\n    * @return tenfi_bal (uint256) amount of TENFI.\r\n    */ \r\n    function getUserTenfiBalance(address user) public view returns(uint tenfi_bal) {\r\n        \r\n\r\n        address _tenfiAddress = TENFI_ADDRESS; //gas-savings\r\n        //User wallet tenfi balance\r\n        tenfi_bal += IERC20(_tenfiAddress).balanceOf(user);\r\n\r\n        uint256 tenfi_farm_length = registeredTenfiFarmVaultsId.length;\r\n\r\n        //User Tenfi balance in tenfi pools\r\n        for(uint256 i = 0 ; i < tenfi_farm_length ; i++) {\r\n            uint256 id = registeredTenfiFarmVaultsId[i];\r\n            uint256 staked = TenFiFarm(TENFI_FARM).stakedWantTokens(id,user);\r\n            if(staked != 0){\r\n                (address pool_lp,,,,) = TenFiFarm(TENFI_FARM).poolInfo(id); \r\n                if(pool_lp != _tenfiAddress)\r\n                tenfi_bal += getTenfiInThisLp(pool_lp,staked);\r\n                else\r\n                tenfi_bal += staked;\r\n            }\r\n        }\r\n\r\n        uint256 biswap_farm_length = registeredBiswapFarmVaultsId.length;\r\n\r\n        //User Tenfi balance in biswap pools\r\n        for(uint256 i = 0 ; i < biswap_farm_length ; i++) {\r\n            uint256 id = registeredBiswapFarmVaultsId[i];\r\n            (uint256 staked,) = BiswapFarm(BISWAP_FARM).userInfo(id,user);\r\n            if(staked != 0) {\r\n                (address pool_lp,,,) = BiswapFarm(BISWAP_FARM).poolInfo(id);\r\n                tenfi_bal += getTenfiInThisLp(pool_lp,staked);\r\n            }\r\n\r\n        }\r\n\r\n         uint256 beefy_farms_length = beefyFarms.length;\r\n\r\n        //User Tenfi balance in biswap pools\r\n        for(uint256 i = 0 ; i < beefy_farms_length ; i++) {\r\n\r\n            (uint256 _balanceOf) = BeefyFarm(beefyFarms[i]).balanceOf(user);\r\n            (uint256 _balance) = BeefyFarm(beefyFarms[i]).balance();\r\n            (uint256 _totalSupply) = BeefyFarm(beefyFarms[i]).totalSupply();\r\n            uint256 staked = (_balanceOf * _balance) / _totalSupply;\r\n            if(staked != 0) {\r\n                (address pool_lp) = BeefyFarm(beefyFarms[i]).want();\r\n                tenfi_bal += getTenfiInThisLp(pool_lp,staked);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n   /**\r\n    * @notice return true or false whether we can transfer LEND to user.\r\n    * @param user Address of the user for which we have to check.\r\n    * @return flag (bool) true or false.\r\n    */ \r\n    function canWeTransferLend(address user) public view returns(bool flag) {\r\n\r\n        if(isUserInAirdrop[user] != Status.INSIDE) {\r\n            \r\n            flag = false;\r\n\r\n        }\r\n        else {\r\n\r\n            uint256 tenfi_amount = getUserTenfiBalance(user);\r\n\r\n            if(tenfi_amount < tenfiAtWhichUserIsRegistered[user]) {\r\n                flag = false;\r\n            }\r\n            else {\r\n                flag = true;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lendAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_registrationEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_airdropStartTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTransferrer\",\"type\":\"address\"}],\"name\":\"TransferrerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTransferrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTransferrer\",\"type\":\"address\"}],\"name\":\"TransferrerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lendTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lendWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AIRDROP_REWARDS_INCREASE_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BISWAP_FARM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_QUALIFY_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TENFI_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TENFI_FARM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lendAddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beefyFarms\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canWeTransferLend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_time\",\"type\":\"uint256\"}],\"name\":\"changeAirdropStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_time\",\"type\":\"uint256\"}],\"name\":\"changeRegistrationEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"changeStatusToExpelled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"editTotalTokenToBeDistributed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"expelledUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpelledUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExpelledUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingLendOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredUsers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTenfiInThisLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserTenfiBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tenfi_bal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUserInAirdrop\",\"outputs\":[{\"internalType\":\"enum Airdrop.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lendToGivenEvery90Days\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredBiswapFarmVaultsId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredTenfiFarmVaultsId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeTransferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transferrer\",\"type\":\"address\"}],\"name\":\"setTransferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tenfiAtWhichUserIsRegistered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLendAirdropped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLendAlloted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLendAllotedToUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenLeftToBeDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenToBeDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferLEND\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userClaimDetails\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isClaim\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIndexInRegistered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLastClaimRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawLend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Airdrop", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "000000000000000000000000e4d242194757584423338d4678e7d1d2558d59f00000000000000000000000000000000000000000000000000000000062a2fa000000000000000000000000000000000000000000000000000000000062f36580", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a95a722c2df5c652d6cf313ebcaa02c4253c0546ff5373f018d1a74fcf39125e"}