{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.15;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"new is 0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract TokenDistributor {\r\n    constructor (address token) {\r\n        IERC20(token).approve(msg.sender, uint(~uint256(0)));\r\n    }\r\n}\r\n\r\ninterface IBtcNFT {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function addReward(address account, uint256 reward) external;\r\n\r\n    function addInviteReward(address invitor, uint256 reward) external;\r\n}\r\n\r\ninterface IEthNFT {\r\n    function activeSupply() external view returns (uint256);\r\n\r\n    function initIdInfo(uint256 initId) external view returns (uint256 lastId, bool isActive, address nftOwner);\r\n\r\n    function addReward(address account, uint256 reward) external;\r\n\r\n    function addInviteReward(address invitor, uint256 reward) external;\r\n}\r\n\r\nabstract contract AbsToken is IERC20, Ownable {\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    address public fundAddress;\r\n    address public defaultInvitor;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    uint256 public _buyInviteFee = 3;\r\n    uint256 public _buyDestroyFee = 2;\r\n\r\n    uint256 public _sellLPFee = 2;\r\n    uint256 public _sellFundFee = 2;\r\n    uint256 public _sellEthNFTFee = 3;\r\n    uint256 public _sellBtcNFTFee = 8;\r\n\r\n    uint256 public _transferFee = 5;\r\n\r\n    uint256 public startTradeBlock;\r\n\r\n    mapping(address => bool) public _feeWhiteList;\r\n    mapping(address => bool) public _excludeRewardList;\r\n\r\n    mapping(address => uint256) public _rOwned;\r\n    mapping(address => uint256) public _tOwned;\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _tTotal;\r\n    uint256 public _rTotal;\r\n\r\n    mapping(address => bool) public _swapPairList;\r\n\r\n    uint256  public apr15Minutes = 20630;\r\n    uint256 private constant AprDivBase = 100000000;\r\n    uint256 public _lastRewardTime;\r\n    bool public _autoApy;\r\n    uint256 private _invitorHoldCondition;\r\n    uint256 private _invitorHoldCondition2;\r\n\r\n    bool private inSwap;\r\n\r\n    address public _usdt;\r\n    address public _usdtPair;\r\n    ISwapRouter public _swapRouter;\r\n\r\n    address public _ethNFTAddress;\r\n    address public _btcNFTAddress;\r\n\r\n    TokenDistributor public _tokenDistributor;\r\n    TokenDistributor public _ethNFTTokenDistributor;\r\n    TokenDistributor public _btcNFTTokenDistributor;\r\n\r\n    mapping(address => uint256) public _teamAmount;\r\n    //\r\n    mapping(address => uint256) public _statisticsAmount;\r\n\r\n    constructor (address RouteAddress, address USDTAddress,\r\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,\r\n        address ReceivedAddress, address FundAddress,\r\n        address EthNFTAddress, address BtcNFTAddress, address NFTDefaultInvitor, address DefaultInvitor\r\n    ){\r\n        _name = Name;\r\n        _symbol = Symbol;\r\n        _decimals = Decimals;\r\n\r\n        ISwapRouter swapRouter = ISwapRouter(RouteAddress);\r\n        _swapRouter = swapRouter;\r\n        _allowances[address(this)][address(swapRouter)] = MAX;\r\n        IERC20(USDTAddress).approve(address(swapRouter), MAX);\r\n\r\n        _usdt = USDTAddress;\r\n        address swapPair = ISwapFactory(swapRouter.factory()).createPair(address(this), USDTAddress);\r\n        _swapPairList[swapPair] = true;\r\n        _excludeRewardList[swapPair] = true;\r\n        _usdtPair = swapPair;\r\n\r\n        uint256 tTotal = Supply * 10 ** Decimals;\r\n        uint256 base = AprDivBase * 100;\r\n        uint256 rTotal = MAX / base - (MAX / base % tTotal);\r\n        _rOwned[ReceivedAddress] = rTotal;\r\n        _tOwned[ReceivedAddress] = tTotal;\r\n        emit Transfer(address(0), ReceivedAddress, tTotal);\r\n        _rTotal = rTotal;\r\n        _tTotal = tTotal;\r\n        _addHolder(ReceivedAddress);\r\n\r\n        fundAddress = FundAddress;\r\n        _ethNFTAddress = EthNFTAddress;\r\n        _btcNFTAddress = BtcNFTAddress;\r\n        _nftDefaultInvitor = NFTDefaultInvitor;\r\n        defaultInvitor = DefaultInvitor;\r\n\r\n        _feeWhiteList[DefaultInvitor] = true;\r\n        _feeWhiteList[NFTDefaultInvitor] = true;\r\n        _feeWhiteList[FundAddress] = true;\r\n        _feeWhiteList[ReceivedAddress] = true;\r\n        _feeWhiteList[address(this)] = true;\r\n        _feeWhiteList[msg.sender] = true;\r\n        _feeWhiteList[address(swapRouter)] = true;\r\n\r\n        _inProject[msg.sender] = true;\r\n\r\n        _tokenDistributor = new TokenDistributor(USDTAddress);\r\n        _ethNFTTokenDistributor = new TokenDistributor(USDTAddress);\r\n        _btcNFTTokenDistributor = new TokenDistributor(USDTAddress);\r\n\r\n        _invitorHoldCondition = 30 * 10 ** Decimals;\r\n        _invitorHoldCondition2 = 50 * 10 ** Decimals;\r\n\r\n        //BTCNFT\r\n        btcNftRewardCondition = 300 * 10 ** IERC20(USDTAddress).decimals();\r\n        _btcNftHolderCondition = 200 * 10 ** Decimals;\r\n        excludeBtcNFTHolder[address(0)] = true;\r\n        excludeBtcNFTHolder[address(0x000000000000000000000000000000000000dEaD)] = true;\r\n\r\n        //ETHNFT\r\n        ethNftRewardCondition = 300 * 10 ** IERC20(USDTAddress).decimals();\r\n        excludeEthNFTHolder[address(0)] = true;\r\n        excludeEthNFTHolder[address(0x000000000000000000000000000000000000dEaD)] = true;\r\n    }\r\n\r\n    uint256 public  calApyTimes;\r\n\r\n    function calApy() public {\r\n        if (!_autoApy) {\r\n            return;\r\n        }\r\n        uint256 total = _tTotal;\r\n        uint256 maxTotal = _rTotal;\r\n        if (total == maxTotal) {\r\n            return;\r\n        }\r\n        uint256 blockTime = block.timestamp;\r\n        uint256 lastRewardTime = _lastRewardTime;\r\n        if (blockTime < lastRewardTime + 15 minutes) {\r\n            return;\r\n        }\r\n        uint256 deltaTime = blockTime - lastRewardTime;\r\n        uint256 times = deltaTime / 15 minutes;\r\n\r\n        for (uint256 i; i < times;) {\r\n            total = total * (AprDivBase + apr15Minutes) / AprDivBase;\r\n            if (total > maxTotal) {\r\n                total = maxTotal;\r\n                break;\r\n            }\r\n        unchecked{\r\n            ++i;\r\n            if (1042 != apr15Minutes) {\r\n                calApyTimes++;\r\n                if (calApyTimes == 1920) {\r\n                    calApyTimes = 0;\r\n                    apr15Minutes = apr15Minutes / 2;\r\n                    if (apr15Minutes < 5157) {\r\n                        apr15Minutes = 1042;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        }\r\n        _tTotal = total;\r\n        _lastRewardTime = lastRewardTime + times * 15 minutes;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function decimals() external view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_excludeRewardList[account]) {\r\n            return _tOwned[account];\r\n        }\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        if (_allowances[sender][msg.sender] != MAX) {\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256){\r\n        uint256 currentRate = _getRate();\r\n        return rAmount / currentRate;\r\n    }\r\n\r\n    function _getRate() public view returns (uint256) {\r\n        if (_rTotal < _tTotal) {\r\n            return 1;\r\n        }\r\n        return _rTotal / _tTotal;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        calApy();\r\n\r\n        uint256 balance = balanceOf(from);\r\n        require(balance >= amount, \"balanceNotEnough\");\r\n\r\n        if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\r\n            uint256 maxSellAmount = balance * 99999 / 100000;\r\n            if (amount > maxSellAmount) {\r\n                amount = maxSellAmount;\r\n            }\r\n        }\r\n\r\n        if (_swapPairList[from] || _swapPairList[to]) {\r\n            if (0 == startTradeBlock) {\r\n                if (_feeWhiteList[from] && _swapPairList[to] && IERC20(to).totalSupply() == 0) {\r\n                    startTradeBlock = block.number;\r\n                    _startAutoApy();\r\n                }\r\n            }\r\n\r\n            if (!_feeWhiteList[from] && !_feeWhiteList[to]) {\r\n                require(0 < startTradeBlock, \"!trade\");\r\n                if (block.number < startTradeBlock + 4) {\r\n                    _fundTransfer(from, to, amount, 90);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        _tokenTransfer(from, to, amount);\r\n\r\n        if (from != address(this)) {\r\n            processBtcNFT(500000);\r\n            if (progressBtcNFTBlock != block.number) {\r\n                processEthNFT(500000);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {\r\n        if (_feeWhiteList[sender] || _feeWhiteList[recipient]) {\r\n            _fundTransfer(sender, recipient, tAmount, 0);\r\n            return;\r\n        }\r\n\r\n        uint256 currentRate = _getRate();\r\n        _subToken(sender, tAmount, currentRate);\r\n\r\n        uint256 feeAmount;\r\n        if (_swapPairList[sender]) {//Buy\r\n            uint256 totalInviteAmount = tAmount * _buyInviteFee / 100;\r\n            feeAmount += totalInviteAmount;\r\n            uint256 fundAmount = totalInviteAmount;\r\n            if (totalInviteAmount > 0) {\r\n                address current = recipient;\r\n                address invitor;\r\n                uint256 inviterAmount;\r\n                uint256 perInviteAmount = totalInviteAmount / 3;\r\n                uint256 invitorHoldCondition;\r\n                for (uint256 i; i < 2;) {\r\n                    invitor = _inviter[current];\r\n                    if (address(0) == invitor) {\r\n                        break;\r\n                    }\r\n                    if (0 == i) {\r\n                        inviterAmount = perInviteAmount * 2;\r\n                        invitorHoldCondition = _invitorHoldCondition;\r\n                    } else {\r\n                        inviterAmount = perInviteAmount;\r\n                        invitorHoldCondition = _invitorHoldCondition2;\r\n                    }\r\n                    if (0 == invitorHoldCondition || balanceOf(invitor) >= invitorHoldCondition) {\r\n                        fundAmount -= inviterAmount;\r\n                        _addToken(sender, invitor, inviterAmount, currentRate);\r\n                    }\r\n                    current = invitor;\r\n                unchecked{\r\n                    ++i;\r\n                }\r\n                }\r\n            }\r\n            if (fundAmount > 1000) {\r\n                _addToken(sender, defaultInvitor, fundAmount, currentRate);\r\n            }\r\n            uint256 destroyAmount = tAmount * _buyDestroyFee / 100;\r\n            if (destroyAmount > 0) {\r\n                feeAmount += destroyAmount;\r\n                _addToken(sender, address(0x000000000000000000000000000000000000dEaD), destroyAmount, currentRate);\r\n            }\r\n        } else if (_swapPairList[recipient]) {//Sell\r\n            uint256 sellLPFee = _sellLPFee;\r\n            uint256 sellFundFee = _sellFundFee;\r\n            uint256 sellEthNFTFee = _sellEthNFTFee;\r\n            uint256 sellBtcNFTFee = _sellBtcNFTFee;\r\n            uint256 taxFee = sellLPFee + sellFundFee + sellEthNFTFee + sellBtcNFTFee;\r\n            uint256 taxAmount = tAmount * taxFee / 100;\r\n            feeAmount += taxAmount;\r\n            _addToken(sender, address(this), taxAmount, currentRate);\r\n\r\n            if (!inSwap) {\r\n                inSwap = true;\r\n                taxFee += taxFee;\r\n                uint256 addLPAmount = taxAmount * sellLPFee / taxFee;\r\n                address tokenDistributor = address(_tokenDistributor);\r\n                address usdt = _usdt;\r\n                address[] memory path = new address[](2);\r\n                path[0] = address(this);\r\n                path[1] = usdt;\r\n                _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                    taxAmount - addLPAmount,\r\n                    0,\r\n                    path,\r\n                    tokenDistributor,\r\n                    block.timestamp\r\n                );\r\n                _distributeUSDT(\r\n                    usdt, tokenDistributor,\r\n                    taxFee, sellLPFee, sellFundFee, sellEthNFTFee, sellBtcNFTFee,\r\n                    addLPAmount\r\n                );\r\n                inSwap = false;\r\n            }\r\n        } else {//Transfer\r\n            uint256 transferFeeAmount = tAmount * _transferFee / 100;\r\n            if (transferFeeAmount > 0) {\r\n                feeAmount += transferFeeAmount;\r\n                _addToken(sender, address(0x000000000000000000000000000000000000dEaD), transferFeeAmount, currentRate);\r\n            }\r\n        }\r\n        _addToken(sender, recipient, tAmount - feeAmount, currentRate);\r\n    }\r\n\r\n    function _calTeamAmount(address account) private {\r\n        uint256 lastStatisticsAmount = _statisticsAmount[account];\r\n        uint256 balance = balanceOf(account);\r\n        if (lastStatisticsAmount == balance) {\r\n            return;\r\n        }\r\n        _statisticsAmount[account] = balance;\r\n\r\n        if (lastStatisticsAmount > balance) {//minus teamAmount\r\n            uint256 debtAmount = lastStatisticsAmount - balance;\r\n            address invitor;\r\n            uint256 teamAmount;\r\n            for (uint256 i; i < 20;) {\r\n                invitor = _inviter[account];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n                account = invitor;\r\n                teamAmount = _teamAmount[invitor];\r\n            unchecked{\r\n                if (teamAmount > debtAmount) {\r\n                    _teamAmount[invitor] = teamAmount - debtAmount;\r\n                } else {\r\n                    _teamAmount[invitor] = 0;\r\n                }\r\n                ++i;\r\n            }\r\n            }\r\n        } else {//add teamAmount\r\n            uint256 debtAmount = balance - lastStatisticsAmount;\r\n            address invitor;\r\n            for (uint256 i; i < 20;) {\r\n                invitor = _inviter[account];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n                account = invitor;\r\n            unchecked{\r\n                _teamAmount[invitor] += debtAmount;\r\n                ++i;\r\n            }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _distributeUSDT(\r\n        address usdt, address tokenDistributor,\r\n        uint256 taxFee, uint256 sellLPFee, uint256 sellFundFee, uint256 sellEthNFTFee, uint256 sellBtcNFTFee,\r\n        uint256 addLPAmount\r\n    ) private {\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalance = USDT.balanceOf(tokenDistributor);\r\n        taxFee -= sellLPFee;\r\n\r\n        uint256 fundUSDT = usdtBalance * sellFundFee * 2 / taxFee;\r\n        USDT.transferFrom(tokenDistributor, fundAddress, fundUSDT);\r\n\r\n        uint256 ethNFTUSDT = usdtBalance * sellEthNFTFee * 2 / taxFee;\r\n        USDT.transferFrom(tokenDistributor, address(_ethNFTTokenDistributor), ethNFTUSDT);\r\n        _ethRewardUsdt += ethNFTUSDT;\r\n\r\n        uint256 btcNFTUSDT = usdtBalance * sellBtcNFTFee * 2 / taxFee;\r\n        USDT.transferFrom(tokenDistributor, address(_btcNFTTokenDistributor), btcNFTUSDT);\r\n        _btcRewardUsdt += btcNFTUSDT;\r\n\r\n        _addLP(tokenDistributor, usdt, usdtBalance, sellLPFee, taxFee, addLPAmount);\r\n    }\r\n\r\n    function _addLP(address tokenDistributor, address usdt, uint256 usdtBalance, uint256 sellLPFee, uint256 taxFee, uint256 addLPAmount) private {\r\n        uint256 addLPUSDT = usdtBalance * sellLPFee / taxFee;\r\n        if (addLPUSDT > 0 && addLPAmount > 0) {\r\n            IERC20(usdt).transferFrom(tokenDistributor, address(this), addLPUSDT);\r\n            _swapRouter.addLiquidity(\r\n                address(this), usdt, addLPAmount, addLPUSDT, 0, 0, fundAddress, block.timestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    function _fundTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount,\r\n        uint256 fundFee\r\n    ) private {\r\n        uint256 currentRate = _getRate();\r\n        _subToken(sender, tAmount, currentRate);\r\n        uint256 fundAmount = tAmount * fundFee / 100;\r\n        if (fundAmount > 0) {\r\n            _addToken(sender, fundAddress, fundAmount, currentRate);\r\n        }\r\n        _addToken(sender, recipient, tAmount - fundAmount, currentRate);\r\n    }\r\n\r\n    function _subToken(address sender, uint256 tAmount, uint256 currentRate) private {\r\n        if (_tOwned[sender] > tAmount) {\r\n            _tOwned[sender] -= tAmount;\r\n        } else {\r\n            _tOwned[sender] = 0;\r\n        }\r\n        uint256 rAmount = tAmount * currentRate;\r\n        _rOwned[sender] = _rOwned[sender] - rAmount;\r\n        _calTeamAmount(sender);\r\n    }\r\n\r\n    function _addToken(\r\n        address sender,\r\n        address to,\r\n        uint256 tAmount,\r\n        uint256 currentRate\r\n    ) private {\r\n        _tOwned[to] += tAmount;\r\n\r\n        uint256 rAmount = tAmount * currentRate;\r\n        _rOwned[to] = _rOwned[to] + rAmount;\r\n        emit Transfer(sender, to, tAmount);\r\n        _addHolder(to);\r\n        _calTeamAmount(to);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function claimBalance() external onlyOwner {\r\n        payable(fundAddress).transfer(address(this).balance);\r\n    }\r\n\r\n    function claimToken(address token, uint256 amount, address to) external onlyOwner {\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n\r\n    function setFundAddress(address addr) external onlyOwner {\r\n        fundAddress = addr;\r\n        _feeWhiteList[addr] = true;\r\n    }\r\n\r\n    function setDefaultInvitor(address addr) external onlyOwner {\r\n        defaultInvitor = addr;\r\n        _feeWhiteList[addr] = true;\r\n    }\r\n\r\n    function setNftDefaultInvitor(address addr) external onlyOwner {\r\n        _nftDefaultInvitor = addr;\r\n        _feeWhiteList[addr] = true;\r\n    }\r\n\r\n    function setEthNFTAddress(address addr) external onlyOwner {\r\n        _ethNFTAddress = addr;\r\n    }\r\n\r\n    function setBtcNFTAddress(address addr) external onlyOwner {\r\n        _btcNFTAddress = addr;\r\n    }\r\n\r\n    function setFeeWhiteList(address addr, bool enable) external onlyOwner {\r\n        _feeWhiteList[addr] = enable;\r\n    }\r\n\r\n    function setSwapPairList(address addr, bool enable) external onlyOwner {\r\n        _swapPairList[addr] = enable;\r\n        if (enable) {\r\n            _setExcludeReward(addr, true);\r\n        }\r\n    }\r\n\r\n    function setExcludeReward(address addr, bool enable) external onlyOwner {\r\n        _setExcludeReward(addr, enable);\r\n    }\r\n\r\n    function _setExcludeReward(address addr, bool enable) private {\r\n        _tOwned[addr] = balanceOf(addr);\r\n        _rOwned[addr] = _tOwned[addr] * _getRate();\r\n        _excludeRewardList[addr] = enable;\r\n    }\r\n\r\n    function startAutoApy() external onlyOwner {\r\n        require(!_autoApy, \"autoAping\");\r\n        _startAutoApy();\r\n    }\r\n\r\n    function _startAutoApy() private {\r\n        _autoApy = true;\r\n        _lastRewardTime = block.timestamp;\r\n    }\r\n\r\n    function emergencyCloseAutoApy() external onlyOwner {\r\n        _autoApy = false;\r\n    }\r\n\r\n    function closeAutoApy() external onlyOwner {\r\n        calApy();\r\n        _autoApy = false;\r\n    }\r\n\r\n    function setApr15Minutes(uint256 apr) external onlyOwner {\r\n        calApy();\r\n        apr15Minutes = apr;\r\n    }\r\n\r\n    function setInvitorHoldCondition(uint256 amount) external onlyOwner {\r\n        _invitorHoldCondition = amount * 10 ** _decimals;\r\n    }\r\n\r\n    function setInvitorHoldCondition2(uint256 amount) external onlyOwner {\r\n        _invitorHoldCondition2 = amount * 10 ** _decimals;\r\n    }\r\n\r\n    mapping(address => address) public _inviter;\r\n    mapping(address => address[]) public _binders;\r\n    mapping(address => uint256) public _teamNum;\r\n    mapping(address => bool) public _inProject;\r\n    \r\n    function bindInvitor(address account, address invitor) public {\r\n        address caller = msg.sender;\r\n        require(_inProject[caller], \"notInProj\");\r\n        _bindInvitor(account, invitor);\r\n    }\r\n\r\n    function _bindInvitor(address account, address invitor) private {\r\n        if (_inviter[account] == address(0) && invitor != address(0) && invitor != account) {\r\n            if (_binders[account].length == 0) {\r\n                uint256 size;\r\n                assembly {size := extcodesize(invitor)}\r\n                if (size > 0) {\r\n                    return;\r\n                }\r\n                _inviter[account] = invitor;\r\n                _binders[invitor].push(account);\r\n                _teamNum[invitor] += 1;\r\n                for (uint256 i = 1; i < 20;) {\r\n                    invitor = _inviter[invitor];\r\n                    if (address(0) == invitor) {\r\n                        break;\r\n                    }\r\n                unchecked{\r\n                    _teamNum[invitor] += 1;\r\n                    ++i;\r\n                }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setInProject(address adr, bool enable) external onlyOwner {\r\n        _inProject[adr] = enable;\r\n    }\r\n\r\n    function getBinderLength(address account) external view returns (uint256){\r\n        return _binders[account].length;\r\n    }\r\n\r\n    address[] private _holders;\r\n    mapping(address => uint256) private _holderIndex;\r\n\r\n    function _addHolder(address adr) private {\r\n        if (0 == _holderIndex[adr]) {\r\n            if (0 == _holders.length || _holders[0] != adr) {\r\n                _holderIndex[adr] = _holders.length;\r\n                _holders.push(adr);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getHolderLength() public view returns (uint256){\r\n        return _holders.length;\r\n    }\r\n\r\n    function getHolderList(uint256 start, uint256 length) external view returns (\r\n        uint256 returnLen, address[] memory holders,\r\n        uint256[] memory balances, uint256[] memory teamAmounts\r\n    ){\r\n        uint256 holderLength = getHolderLength();\r\n        if (0 == length) {\r\n            length = holderLength;\r\n        }\r\n        returnLen = length;\r\n\r\n        holders = new address[](length);\r\n        balances = new uint256[](length);\r\n        teamAmounts = new uint256[](length);\r\n        uint256 index = 0;\r\n        for (uint256 i = start; i < start + length; ++i) {\r\n            if (i >= holderLength)\r\n                return (index, holders, balances, teamAmounts);\r\n            address holder = _holders[i];\r\n            holders[index] = holder;\r\n            balances[index] = balanceOf(holder);\r\n            teamAmounts[index] = _teamAmount[holder];\r\n            ++index;\r\n        }\r\n    }\r\n\r\n    //BTCNFT\r\n    uint256 public currentBtcNFTIndex;\r\n    uint256 public btcNftRewardCondition;\r\n    uint256 public _btcNftHolderCondition;\r\n    uint256 public progressBtcNFTBlock;\r\n    mapping(address => bool) public excludeBtcNFTHolder;\r\n    uint256 public progressBtcNFTBlockDebt = 200;\r\n    uint256 public _btcNftBaseId = 1;\r\n\r\n    uint256 private _ethRewardUsdt;\r\n    uint256 private _btcRewardUsdt;\r\n    address public _nftDefaultInvitor;\r\n\r\n    function processBtcNFT(uint256 gas) private {\r\n        if (progressBtcNFTBlock + progressBtcNFTBlockDebt > block.number) {\r\n            return;\r\n        }\r\n        IBtcNFT btcNft = IBtcNFT(_btcNFTAddress);\r\n        uint totalNFT = btcNft.totalSupply();\r\n        if (0 == totalNFT) {\r\n            return;\r\n        }\r\n        address tokenDistributor = address(_btcNFTTokenDistributor);\r\n        IERC20 USDT = IERC20(_usdt);\r\n        uint256 tokenBalance = USDT.balanceOf(tokenDistributor);\r\n        if (tokenBalance < btcNftRewardCondition) {\r\n            return;\r\n        }\r\n\r\n        uint256 amount = tokenBalance / totalNFT;\r\n        if (100 > amount) {\r\n            return;\r\n        }\r\n        uint256 totalRewardAmount;\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 iterations = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 nftBaseId = _btcNftBaseId;\r\n        uint256 btcNftHolderCondition = _btcNftHolderCondition;\r\n\r\n        uint256 invitorHoldCondition = _invitorHoldCondition;\r\n        uint256 invitorHoldCondition2 = _invitorHoldCondition2;\r\n\r\n        while (gasUsed < gas && iterations < totalNFT) {\r\n            if (currentBtcNFTIndex >= totalNFT) {\r\n                currentBtcNFTIndex = 0;\r\n            }\r\n            address shareHolder = btcNft.ownerOf(nftBaseId + currentBtcNFTIndex);\r\n            if (!excludeBtcNFTHolder[shareHolder] && balanceOf(shareHolder) >= btcNftHolderCondition) {\r\n                totalRewardAmount += amount;\r\n                _progressBtcReward(btcNft, shareHolder, amount, invitorHoldCondition, invitorHoldCondition2);\r\n            }\r\n\r\n            gasUsed = gasUsed + (gasLeft - gasleft());\r\n            gasLeft = gasleft();\r\n            currentBtcNFTIndex++;\r\n            iterations++;\r\n        }\r\n\r\n        progressBtcNFTBlock = block.number;\r\n        if (totalRewardAmount > 0) {\r\n            USDT.transferFrom(tokenDistributor, _btcNFTAddress, totalRewardAmount);\r\n        }\r\n    }\r\n\r\n    function _progressBtcReward(IBtcNFT btcNft, address shareHolder, uint256 amount, uint256 invitorHoldCondition, uint256 invitorHoldCondition2) private {\r\n        uint256 rewardAmount = amount * 92 / 100;\r\n        btcNft.addReward(shareHolder, rewardAmount);\r\n        address current = shareHolder;\r\n        address invitor;\r\n        uint256 fundAmount = amount - rewardAmount;\r\n        uint256 inviteAmount = amount * 5 / 100;\r\n        uint256 inviteAmount2 = fundAmount - inviteAmount;\r\n        for (uint256 i; i < 2;) {\r\n            invitor = _inviter[current];\r\n            if (address(0) == invitor) {\r\n                break;\r\n            }\r\n            if (0 == i) {\r\n                if (balanceOf(invitor) >= invitorHoldCondition) {\r\n                    fundAmount -= inviteAmount;\r\n                    btcNft.addInviteReward(invitor, inviteAmount);\r\n                }\r\n            } else {\r\n                if (balanceOf(invitor) >= invitorHoldCondition2) {\r\n                    fundAmount -= inviteAmount2;\r\n                    btcNft.addInviteReward(invitor, inviteAmount2);\r\n                }\r\n            }\r\n            current = invitor;\r\n        unchecked{\r\n            ++i;\r\n        }\r\n        }\r\n        if (fundAmount > 0) {\r\n            btcNft.addInviteReward(_nftDefaultInvitor, fundAmount);\r\n        }\r\n    }\r\n\r\n    function setBtcNFTRewardCondition(uint256 amount) external onlyOwner {\r\n        btcNftRewardCondition = amount;\r\n    }\r\n\r\n    function setBtcNFTHoldCondition(uint256 amount) external onlyOwner {\r\n        _btcNftHolderCondition = amount;\r\n    }\r\n\r\n    function setBtcExcludeNFTHolder(address addr, bool enable) external onlyOwner {\r\n        excludeBtcNFTHolder[addr] = enable;\r\n    }\r\n\r\n    function setProgressBtcNFTBlockDebt(uint256 blockDebt) external onlyOwner {\r\n        progressBtcNFTBlockDebt = blockDebt;\r\n    }\r\n\r\n    function setBtcNftBaseId(uint256 baseId) external onlyOwner {\r\n        _btcNftBaseId = baseId;\r\n    }\r\n\r\n    //ETHNFT\r\n    uint256 public currentEthNFTIndex;\r\n    uint256 public ethNftRewardCondition;\r\n    uint256 public progressEthNFTBlock;\r\n    mapping(address => bool) public excludeEthNFTHolder;\r\n    uint256 public progressEthNFTBlockDebt = 20;\r\n    uint256 public _ethNftBaseId = 1;\r\n\r\n    function processEthNFT(uint256 gas) private {\r\n        if (progressEthNFTBlock + progressEthNFTBlockDebt > block.number) {\r\n            return;\r\n        }\r\n        IEthNFT ethNft = IEthNFT(_ethNFTAddress);\r\n        uint totalNFT = ethNft.activeSupply();\r\n        if (0 == totalNFT) {\r\n            return;\r\n        }\r\n        address tokenDistributor = address(_ethNFTTokenDistributor);\r\n        IERC20 USDT = IERC20(_usdt);\r\n        uint256 tokenBalance = USDT.balanceOf(tokenDistributor);\r\n        if (tokenBalance < ethNftRewardCondition) {\r\n            return;\r\n        }\r\n\r\n        uint256 amount = tokenBalance / totalNFT;\r\n\r\n        if (100 > amount) {\r\n            return;\r\n        }\r\n        uint256 totalRewardAmount;\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 iterations = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 nftBaseId = _ethNftBaseId;\r\n\r\n        uint256 invitorHoldCondition = _invitorHoldCondition;\r\n        uint256 invitorHoldCondition2 = _invitorHoldCondition2;\r\n\r\n        while (gasUsed < gas && iterations < totalNFT) {\r\n            if (currentEthNFTIndex >= totalNFT) {\r\n                currentEthNFTIndex = 0;\r\n            }\r\n            (, bool isActive, address shareHolder) = ethNft.initIdInfo(nftBaseId + currentEthNFTIndex);\r\n            if (!excludeEthNFTHolder[shareHolder] && isActive) {\r\n                totalRewardAmount += amount;\r\n                _progressEthReward(ethNft, shareHolder, amount, invitorHoldCondition, invitorHoldCondition2);\r\n            }\r\n\r\n            gasUsed = gasUsed + (gasLeft - gasleft());\r\n            gasLeft = gasleft();\r\n            currentEthNFTIndex++;\r\n            iterations++;\r\n        }\r\n\r\n        progressEthNFTBlock = block.number;\r\n        if (totalRewardAmount > 0) {\r\n            USDT.transferFrom(tokenDistributor, _ethNFTAddress, totalRewardAmount);\r\n        }\r\n    }\r\n\r\n    function _progressEthReward(IEthNFT ethNft, address shareHolder, uint256 amount, uint256 invitorHoldCondition, uint256 invitorHoldCondition2) private {\r\n        uint256 rewardAmount = amount * 92 / 100;\r\n        ethNft.addReward(shareHolder, rewardAmount);\r\n        address current = shareHolder;\r\n        address invitor;\r\n        uint256 fundAmount = amount - rewardAmount;\r\n        uint256 inviteAmount = amount * 5 / 100;\r\n        uint256 inviteAmount2 = fundAmount - inviteAmount;\r\n        for (uint256 i; i < 2;) {\r\n            invitor = _inviter[current];\r\n            if (address(0) == invitor) {\r\n                break;\r\n            }\r\n            if (0 == i) {\r\n                if (balanceOf(invitor) >= invitorHoldCondition) {\r\n                    fundAmount -= inviteAmount;\r\n                    ethNft.addInviteReward(invitor, inviteAmount);\r\n                }\r\n            } else {\r\n                if (balanceOf(invitor) >= invitorHoldCondition2) {\r\n                    fundAmount -= inviteAmount2;\r\n                    ethNft.addInviteReward(invitor, inviteAmount2);\r\n                }\r\n            }\r\n            current = invitor;\r\n        unchecked{\r\n            ++i;\r\n        }\r\n        }\r\n        if (fundAmount > 0) {\r\n            ethNft.addInviteReward(_nftDefaultInvitor, fundAmount);\r\n        }\r\n    }\r\n\r\n    function setEthNFTRewardCondition(uint256 amount) external onlyOwner {\r\n        ethNftRewardCondition = amount;\r\n    }\r\n\r\n    function setEthExcludeNFTHolder(address addr, bool enable) external onlyOwner {\r\n        excludeEthNFTHolder[addr] = enable;\r\n    }\r\n\r\n    function setProgressEthNFTBlockDebt(uint256 blockDebt) external onlyOwner {\r\n        progressEthNFTBlockDebt = blockDebt;\r\n    }\r\n\r\n    function setEthNftBaseId(uint256 baseId) external onlyOwner {\r\n        _ethNftBaseId = baseId;\r\n    }\r\n\r\n    function getTokenInfo() external view returns (\r\n        uint256 tokenDecimals, string memory tokenSymbol,\r\n        address usdt, uint256 usdtDecimals, string memory usdtSymbol\r\n    ){\r\n        tokenDecimals = _decimals;\r\n        tokenSymbol = _symbol;\r\n        usdt = _usdt;\r\n        usdtDecimals = IERC20(usdt).decimals();\r\n        usdtSymbol = IERC20(usdt).symbol();\r\n    }\r\n\r\n    function getTotalInfo() external view returns (\r\n        uint256 ethRewardUsdt, uint256 btcRewardUsdt,\r\n        uint256 invitorHoldCondition, uint256 invitorHoldCondition2, uint256 btcNftHolderCondition,\r\n        uint256 tokenPrice, uint256 lpValue, uint256 validTotal, uint256 total\r\n    ){\r\n        ethRewardUsdt = _ethRewardUsdt;\r\n        btcRewardUsdt = _btcRewardUsdt;\r\n        invitorHoldCondition = _invitorHoldCondition;\r\n        invitorHoldCondition2 = _invitorHoldCondition2;\r\n        btcNftHolderCondition = _btcNftHolderCondition;\r\n        uint256 lpU = IERC20(_usdt).balanceOf(_usdtPair);\r\n        lpValue = lpU * 2;\r\n        uint256 lpTokenAmount = balanceOf(_usdtPair);\r\n        if (lpTokenAmount > 0) {\r\n            tokenPrice = 10 ** _decimals * lpU / lpTokenAmount;\r\n        }\r\n        total = totalSupply();\r\n        validTotal = total - balanceOf(address(0)) - balanceOf(address(0x000000000000000000000000000000000000dEaD));\r\n    }\r\n\r\n    function getAllInvitor(address account) external view returns (address[] memory invitors){\r\n        invitors = new address[](20);\r\n        address current = account;\r\n        address invitor;\r\n        for (uint256 i; i < 20; ++i) {\r\n            invitor = _inviter[current];\r\n            if (address(0) == invitor) {\r\n                break;\r\n            }\r\n            invitors[i] = invitor;\r\n            current = invitor;\r\n        }\r\n    }\r\n}\r\n\r\ncontract TMTToken is AbsToken {\r\n    constructor() AbsToken(\r\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\r\n        address(0x55d398326f99059fF775485246999027B3197955),\r\n        \"TMT Token\",\r\n        \"TMT\",\r\n        6,\r\n        13000000,\r\n        address(0xD9E1326497970C541c2fEc65Ea190411e52729E5),\r\n        address(0xb78d7b977e62B09Cd3934ba37404d8261B4b84D3),\r\n        address(0xB7dC2FD542Fb373255CB4c493b51808F1b2F18e7),\r\n        address(0x6477F5D55E8cd3a9a2d85DccF6B3aB09AAc47547),\r\n        address(0xf2cab01D0344c024378cc6A9Edf6D3089936dF36),\r\n        address(0x23bDd3bAf49dd13fC43A9AC084cC8b4AB776F677)\r\n    ){\r\n\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_autoApy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_binders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_btcNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_btcNFTTokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_btcNftBaseId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_btcNftHolderCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyDestroyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyInviteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ethNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ethNFTTokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ethNftBaseId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_excludeRewardList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nftDefaultInvitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_rOwned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellBtcNFTFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellEthNFTFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFundFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLPFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_statisticsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_tOwned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_teamAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_teamNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdtPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apr15Minutes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"bindInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"btcNftRewardCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calApyTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeAutoApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBtcNFTIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEthNFTIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultInvitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyCloseAutoApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethNftRewardCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludeBtcNFTHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludeEthNFTHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAllInvitor\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"invitors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBinderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHolderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getHolderList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnLen\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"holders\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"teamAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdtDecimals\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"usdtSymbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ethRewardUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btcRewardUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invitorHoldCondition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invitorHoldCondition2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"btcNftHolderCondition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progressBtcNFTBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progressBtcNFTBlockDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progressEthNFTBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progressEthNFTBlockDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"}],\"name\":\"setApr15Minutes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setBtcExcludeNFTHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setBtcNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBtcNFTHoldCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBtcNFTRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseId\",\"type\":\"uint256\"}],\"name\":\"setBtcNftBaseId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDefaultInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setEthExcludeNFTHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEthNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEthNFTRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseId\",\"type\":\"uint256\"}],\"name\":\"setEthNftBaseId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setExcludeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setInProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setInvitorHoldCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setInvitorHoldCondition2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNftDefaultInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockDebt\",\"type\":\"uint256\"}],\"name\":\"setProgressBtcNFTBlockDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockDebt\",\"type\":\"uint256\"}],\"name\":\"setProgressEthNFTBlockDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAutoApy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TMTToken", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://daa65af98c3fc3dd1c4e149e3cb31961b0cbba689d7b6ac3561429f330c65160"}