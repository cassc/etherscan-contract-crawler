{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/lending/compound/ComptrollerInterface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ncontract ComptrollerInterface {\\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\\n  bool public constant isComptroller = true;\\n\\n  /*** Assets You Are In ***/\\n\\n  function enterMarkets(\\n    address[] calldata cTokens\\n  ) external returns (uint[] memory);\\n\\n  function exitMarket(address cToken) external returns (uint);\\n\\n  /*** Policy Hooks ***/\\n\\n  function mintAllowed(\\n    address cToken,\\n    address minter,\\n    uint mintAmount\\n  ) external returns (uint);\\n\\n  function mintVerify(\\n    address cToken,\\n    address minter,\\n    uint mintAmount,\\n    uint mintTokens\\n  ) external;\\n\\n  function redeemAllowed(\\n    address cToken,\\n    address redeemer,\\n    uint redeemTokens\\n  ) external returns (uint);\\n\\n  function redeemVerify(\\n    address cToken,\\n    address redeemer,\\n    uint redeemAmount,\\n    uint redeemTokens\\n  ) external;\\n\\n  function borrowAllowed(\\n    address cToken,\\n    address borrower,\\n    uint borrowAmount\\n  ) external returns (uint);\\n\\n  function borrowVerify(\\n    address cToken,\\n    address borrower,\\n    uint borrowAmount\\n  ) external;\\n\\n  function repayBorrowAllowed(\\n    address cToken,\\n    address payer,\\n    address borrower,\\n    uint repayAmount\\n  ) external returns (uint);\\n\\n  function repayBorrowVerify(\\n    address cToken,\\n    address payer,\\n    address borrower,\\n    uint repayAmount,\\n    uint borrowerIndex\\n  ) external;\\n\\n  function liquidateBorrowAllowed(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    address liquidator,\\n    address borrower,\\n    uint repayAmount\\n  ) external returns (uint);\\n\\n  function liquidateBorrowVerify(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    address liquidator,\\n    address borrower,\\n    uint repayAmount,\\n    uint seizeTokens\\n  ) external;\\n\\n  function seizeAllowed(\\n    address cTokenCollateral,\\n    address cTokenBorrowed,\\n    address liquidator,\\n    address borrower,\\n    uint seizeTokens\\n  ) external returns (uint);\\n\\n  function seizeVerify(\\n    address cTokenCollateral,\\n    address cTokenBorrowed,\\n    address liquidator,\\n    address borrower,\\n    uint seizeTokens\\n  ) external;\\n\\n  function transferAllowed(\\n    address cToken,\\n    address src,\\n    address dst,\\n    uint transferTokens\\n  ) external returns (uint);\\n\\n  function transferVerify(\\n    address cToken,\\n    address src,\\n    address dst,\\n    uint transferTokens\\n  ) external;\\n\\n  /*** Liquidity/Liquidation Calculations ***/\\n\\n  function liquidateCalculateSeizeTokens(\\n    address cTokenBorrowed,\\n    address cTokenCollateral,\\n    uint repayAmount\\n  ) external view returns (uint, uint);\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/ComptrollerStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"contracts/lending/compound/tokens/cToken.sol\\\";\\nimport \\\"./PriceOracle.sol\\\";\\n\\ncontract UnitrollerAdminStorage {\\n  /**\\n   * @notice Administrator for this contract\\n   */\\n  address public admin;\\n\\n  /**\\n   * @notice Pending administrator for this contract\\n   */\\n  address public pendingAdmin;\\n\\n  /**\\n   * @notice Active brains of Unitroller\\n   */\\n  address public comptrollerImplementation;\\n\\n  /**\\n   * @notice Pending brains of Unitroller\\n   */\\n  address public pendingComptrollerImplementation;\\n}\\n\\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\\n  /**\\n   * @notice Oracle which gives the price of any given asset\\n   */\\n  PriceOracle public oracle;\\n\\n  /**\\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\n   */\\n  uint public closeFactorMantissa;\\n\\n  /**\\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\\n   */\\n  uint public liquidationIncentiveMantissa;\\n\\n  /**\\n   * @notice Max number of assets a single account can participate in (borrow or use as collateral)\\n   */\\n  uint public maxAssets;\\n\\n  /**\\n   * @notice Per-account mapping of \\\"assets you are in\\\", capped by maxAssets\\n   */\\n  mapping(address => CToken[]) public accountAssets;\\n}\\n\\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\\n  struct Market {\\n    /// @notice Whether or not this market is listed\\n    bool isListed;\\n    /**\\n     * @notice Multiplier representing the most one can borrow against their collateral in this market.\\n     *  For instance, 0.9 to allow borrowing 90% of collateral value.\\n     *  Must be between 0 and 1, and stored as a mantissa.\\n     */\\n    uint collateralFactorMantissa;\\n    /// @notice Per-market mapping of \\\"accounts in this asset\\\"\\n    mapping(address => bool) accountMembership;\\n    /// @notice Whether or not this market receives COMP\\n    bool isComped;\\n  }\\n\\n  /**\\n   * @notice Official mapping of cTokens -> Market metadata\\n   * @dev Used e.g. to determine if a market is supported\\n   */\\n  mapping(address => Market) public markets;\\n\\n  /**\\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\n   *  Actions which allow users to remove their own assets cannot be paused.\\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n   */\\n  address public pauseGuardian;\\n  bool public _mintGuardianPaused;\\n  bool public _borrowGuardianPaused;\\n  bool public transferGuardianPaused;\\n  bool public seizeGuardianPaused;\\n  mapping(address => bool) public mintGuardianPaused;\\n  mapping(address => bool) public borrowGuardianPaused;\\n}\\n\\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\\n  struct CompMarketState {\\n    /// @notice The market's last updated compBorrowIndex or compSupplyIndex\\n    uint224 index;\\n    /// @notice The block number the index was last updated at\\n    uint32 block;\\n  }\\n\\n  /// @notice A list of all markets\\n  CToken[] public allMarkets;\\n\\n  /// @notice The rate at which the flywheel distributes COMP, per block\\n  uint public compRate;\\n\\n  /// @notice The portion of compRate that each market currently receives\\n  mapping(address => uint) public compSpeeds;\\n\\n  /// @notice The COMP market supply state for each market\\n  mapping(address => CompMarketState) public compSupplyState;\\n\\n  /// @notice The COMP market borrow state for each market\\n  mapping(address => CompMarketState) public compBorrowState;\\n\\n  /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\\n  mapping(address => mapping(address => uint)) public compSupplierIndex;\\n\\n  /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\\n  mapping(address => mapping(address => uint)) public compBorrowerIndex;\\n\\n  /// @notice The COMP accrued but not yet transferred to each user\\n  mapping(address => uint) public compAccrued;\\n}\\n\\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\\n  // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\\n  address public borrowCapGuardian;\\n\\n  // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\\n  mapping(address => uint) public borrowCaps;\\n}\\n\\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\\n  /// @notice The portion of COMP that each contributor receives per block\\n  mapping(address => uint) public compContributorSpeeds;\\n\\n  /// @notice Last block at which a contributor's COMP rewards have been allocated\\n  mapping(address => uint) public lastContributorBlock;\\n}\\n\\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\\n  /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)\\n  mapping(address => uint) public compBorrowSpeeds;\\n\\n  /// @notice The rate at which comp is distributed to the corresponding supply market (per block)\\n  mapping(address => uint) public compSupplySpeeds;\\n}\\n\\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\\n  /// @notice Flag indicating whether the function to fix COMP accruals has been executed (RE: proposal 62 bug)\\n  bool public proposal65FixExecuted;\\n\\n  /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.\\n  mapping(address => uint) public compReceivable;\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/ErrorReporter.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\ncontract ComptrollerErrorReporter {\\n  enum Error {\\n    NO_ERROR,\\n    UNAUTHORIZED,\\n    COMPTROLLER_MISMATCH,\\n    INSUFFICIENT_SHORTFALL,\\n    INSUFFICIENT_LIQUIDITY,\\n    INVALID_CLOSE_FACTOR,\\n    INVALID_COLLATERAL_FACTOR,\\n    INVALID_LIQUIDATION_INCENTIVE,\\n    MARKET_NOT_ENTERED, // no longer possible\\n    MARKET_NOT_LISTED,\\n    MARKET_ALREADY_LISTED,\\n    MATH_ERROR,\\n    NONZERO_BORROW_BALANCE,\\n    PRICE_ERROR,\\n    REJECTION,\\n    SNAPSHOT_ERROR,\\n    TOO_MANY_ASSETS,\\n    TOO_MUCH_REPAY\\n  }\\n\\n  enum FailureInfo {\\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\\n    EXIT_MARKET_BALANCE_OWED,\\n    EXIT_MARKET_REJECTION,\\n    SET_CLOSE_FACTOR_OWNER_CHECK,\\n    SET_CLOSE_FACTOR_VALIDATION,\\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\\n    SET_COLLATERAL_FACTOR_VALIDATION,\\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\\n    SET_IMPLEMENTATION_OWNER_CHECK,\\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\\n    SET_MAX_ASSETS_OWNER_CHECK,\\n    SET_PENDING_ADMIN_OWNER_CHECK,\\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\\n    SET_PRICE_ORACLE_OWNER_CHECK,\\n    SUPPORT_MARKET_EXISTS,\\n    SUPPORT_MARKET_OWNER_CHECK,\\n    SET_PAUSE_GUARDIAN_OWNER_CHECK\\n  }\\n\\n  /**\\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n   **/\\n  event Failure(uint error, uint info, uint detail);\\n\\n  /**\\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n   */\\n  function fail(Error err, FailureInfo info) internal returns (uint) {\\n    emit Failure(uint(err), uint(info), 0);\\n\\n    return uint(err);\\n  }\\n\\n  /**\\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n   */\\n  function failOpaque(\\n    Error err,\\n    FailureInfo info,\\n    uint opaqueError\\n  ) internal returns (uint) {\\n    emit Failure(uint(err), uint(info), opaqueError);\\n\\n    return uint(err);\\n  }\\n}\\n\\ncontract TokenErrorReporter {\\n  enum Error {\\n    NO_ERROR,\\n    UNAUTHORIZED,\\n    BAD_INPUT,\\n    COMPTROLLER_REJECTION,\\n    COMPTROLLER_CALCULATION_ERROR,\\n    INTEREST_RATE_MODEL_ERROR,\\n    INVALID_ACCOUNT_PAIR,\\n    INVALID_CLOSE_AMOUNT_REQUESTED,\\n    INVALID_COLLATERAL_FACTOR,\\n    MATH_ERROR,\\n    MARKET_NOT_FRESH,\\n    MARKET_NOT_LISTED,\\n    TOKEN_INSUFFICIENT_ALLOWANCE,\\n    TOKEN_INSUFFICIENT_BALANCE,\\n    TOKEN_INSUFFICIENT_CASH,\\n    TOKEN_TRANSFER_IN_FAILED,\\n    TOKEN_TRANSFER_OUT_FAILED\\n  }\\n\\n  /*\\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\\n   *       This is because FailureInfo grows significantly faster, and\\n   *       the order of Error has some meaning, while the order of FailureInfo\\n   *       is entirely arbitrary.\\n   */\\n  enum FailureInfo {\\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n    BORROW_ACCRUE_INTEREST_FAILED,\\n    BORROW_CASH_NOT_AVAILABLE,\\n    BORROW_FRESHNESS_CHECK,\\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n    BORROW_MARKET_NOT_LISTED,\\n    BORROW_COMPTROLLER_REJECTION,\\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\\n    LIQUIDATE_COMPTROLLER_REJECTION,\\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\\n    LIQUIDATE_FRESHNESS_CHECK,\\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\\n    LIQUIDATE_SEIZE_TOO_MUCH,\\n    MINT_ACCRUE_INTEREST_FAILED,\\n    MINT_COMPTROLLER_REJECTION,\\n    MINT_EXCHANGE_CALCULATION_FAILED,\\n    MINT_EXCHANGE_RATE_READ_FAILED,\\n    MINT_FRESHNESS_CHECK,\\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n    MINT_TRANSFER_IN_FAILED,\\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\\n    REDEEM_ACCRUE_INTEREST_FAILED,\\n    REDEEM_COMPTROLLER_REJECTION,\\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\\n    REDEEM_FRESHNESS_CHECK,\\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\\n    REDUCE_RESERVES_ADMIN_CHECK,\\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\\n    REDUCE_RESERVES_FRESH_CHECK,\\n    REDUCE_RESERVES_VALIDATION,\\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n    REPAY_BORROW_COMPTROLLER_REJECTION,\\n    REPAY_BORROW_FRESHNESS_CHECK,\\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\\n    SET_COLLATERAL_FACTOR_VALIDATION,\\n    SET_COMPTROLLER_OWNER_CHECK,\\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\\n    SET_MAX_ASSETS_OWNER_CHECK,\\n    SET_ORACLE_MARKET_NOT_LISTED,\\n    SET_PENDING_ADMIN_OWNER_CHECK,\\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\\n    SET_RESERVE_FACTOR_FRESH_CHECK,\\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\\n    TRANSFER_COMPTROLLER_REJECTION,\\n    TRANSFER_NOT_ALLOWED,\\n    TRANSFER_NOT_ENOUGH,\\n    TRANSFER_TOO_MUCH\\n  }\\n\\n  /**\\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\\n   **/\\n  event Failure(uint error, uint info, uint detail);\\n\\n  /**\\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\\n   */\\n  function fail(Error err, FailureInfo info) internal returns (uint) {\\n    emit Failure(uint(err), uint(info), 0);\\n\\n    return uint(err);\\n  }\\n\\n  /**\\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\\n   */\\n  function failOpaque(\\n    Error err,\\n    FailureInfo info,\\n    uint opaqueError\\n  ) internal returns (uint) {\\n    emit Failure(uint(err), uint(info), opaqueError);\\n\\n    return uint(err);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/PriceOracle.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"contracts/lending/compound/tokens/cToken.sol\\\";\\n\\ncontract PriceOracle {\\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\\n  bool public constant isPriceOracle = true;\\n\\n  /**\\n   * @notice Get the underlying price of a cToken asset\\n   * @param cToken The cToken to get the underlying price of\\n   * @return The underlying asset price mantissa (scaled by 1e18).\\n   *  Zero means the price is unavailable.\\n   */\\n  function getUnderlyingPrice(CToken cToken) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.8;\\n\\n/**\\n * @title Helps contracts guard against reentrancy attacks.\\n * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\\n * @dev If you mark a function `nonReentrant`, you should also\\n * mark it `external`.\\n */\\ncontract ReentrancyGuard {\\n  /// @dev counter to allow mutex lock with only one SSTORE operation\\n  uint256 private _guardCounter;\\n\\n  constructor() internal {\\n    // The counter starts at one to prevent changing it from zero to a non-zero\\n    // value, which is a more expensive operation.\\n    _guardCounter = 1;\\n  }\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `nonReentrant` function from another `nonReentrant`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `nonReentrant` function external, and make it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier nonReentrant() {\\n    _guardCounter += 1;\\n    uint256 localCounter = _guardCounter;\\n    _;\\n    require(localCounter == _guardCounter, \\\"re-entered\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/Unitroller.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\nimport \\\"./ErrorReporter.sol\\\";\\nimport \\\"./ComptrollerStorage.sol\\\";\\n\\n/**\\n * @title ComptrollerCore\\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\\n * CTokens should reference this contract as their comptroller.\\n */\\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\\n  /**\\n   * @notice Emitted when pendingComptrollerImplementation is changed\\n   */\\n  event NewPendingImplementation(\\n    address oldPendingImplementation,\\n    address newPendingImplementation\\n  );\\n\\n  /**\\n   * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\\n   */\\n  event NewImplementation(address oldImplementation, address newImplementation);\\n\\n  /**\\n   * @notice Emitted when pendingAdmin is changed\\n   */\\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n  /**\\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n   */\\n  event NewAdmin(address oldAdmin, address newAdmin);\\n\\n  constructor(address _admin) public {\\n    admin = _admin;\\n  }\\n\\n  /*** Admin Functions ***/\\n  function _setPendingImplementation(\\n    address newPendingImplementation\\n  ) public returns (uint) {\\n    if (msg.sender != admin) {\\n      return\\n        fail(\\n          Error.UNAUTHORIZED,\\n          FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK\\n        );\\n    }\\n\\n    address oldPendingImplementation = pendingComptrollerImplementation;\\n\\n    pendingComptrollerImplementation = newPendingImplementation;\\n\\n    emit NewPendingImplementation(\\n      oldPendingImplementation,\\n      pendingComptrollerImplementation\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\\n   * @dev Admin function for new implementation to accept it's role as implementation\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _acceptImplementation() public returns (uint) {\\n    // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\\n    if (\\n      msg.sender != pendingComptrollerImplementation ||\\n      pendingComptrollerImplementation == address(0)\\n    ) {\\n      return\\n        fail(\\n          Error.UNAUTHORIZED,\\n          FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK\\n        );\\n    }\\n\\n    // Save current values for inclusion in log\\n    address oldImplementation = comptrollerImplementation;\\n    address oldPendingImplementation = pendingComptrollerImplementation;\\n\\n    comptrollerImplementation = pendingComptrollerImplementation;\\n\\n    pendingComptrollerImplementation = address(0);\\n\\n    emit NewImplementation(oldImplementation, comptrollerImplementation);\\n    emit NewPendingImplementation(\\n      oldPendingImplementation,\\n      pendingComptrollerImplementation\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @param newPendingAdmin New pending admin.\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\\n    // Check caller = admin\\n    if (msg.sender != admin) {\\n      return\\n        fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n    }\\n\\n    // Save current value, if any, for inclusion in log\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    // Store pendingAdmin with value newPendingAdmin\\n    pendingAdmin = newPendingAdmin;\\n\\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n   * @dev Admin function for pending admin to accept role and update admin\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _acceptAdmin() public returns (uint) {\\n    // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n      return\\n        fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n    }\\n\\n    // Save current values for inclusion in log\\n    address oldAdmin = admin;\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    // Store admin with value pendingAdmin\\n    admin = pendingAdmin;\\n\\n    // Clear the pending value\\n    pendingAdmin = address(0);\\n\\n    emit NewAdmin(oldAdmin, admin);\\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @dev Delegates execution to an implementation contract.\\n   * It returns to the external caller whatever the implementation returns\\n   * or forwards reverts.\\n   */\\n  function() external payable {\\n    // delegate all other functions to current implementation\\n    (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\\n\\n    assembly {\\n      let free_mem_ptr := mload(0x40)\\n      returndatacopy(free_mem_ptr, 0, returndatasize)\\n\\n      switch success\\n      case 0 {\\n        revert(free_mem_ptr, returndatasize)\\n      }\\n      default {\\n        return(free_mem_ptr, returndatasize)\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/tokens/CarefulMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.8;\\n\\n/**\\n * @title Careful Math\\n * @author Compound\\n * @notice Derived from OpenZeppelin's SafeMath library\\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n */\\ncontract CarefulMath {\\n  /**\\n   * @dev Possible error codes that we can return\\n   */\\n  enum MathError {\\n    NO_ERROR,\\n    DIVISION_BY_ZERO,\\n    INTEGER_OVERFLOW,\\n    INTEGER_UNDERFLOW\\n  }\\n\\n  /**\\n   * @dev Multiplies two numbers, returns an error on overflow.\\n   */\\n  function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    if (a == 0) {\\n      return (MathError.NO_ERROR, 0);\\n    }\\n\\n    uint c = a * b;\\n\\n    if (c / a != b) {\\n      return (MathError.INTEGER_OVERFLOW, 0);\\n    } else {\\n      return (MathError.NO_ERROR, c);\\n    }\\n  }\\n\\n  /**\\n   * @dev Integer division of two numbers, truncating the quotient.\\n   */\\n  function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    if (b == 0) {\\n      return (MathError.DIVISION_BY_ZERO, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, a / b);\\n  }\\n\\n  /**\\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n   */\\n  function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    if (b <= a) {\\n      return (MathError.NO_ERROR, a - b);\\n    } else {\\n      return (MathError.INTEGER_UNDERFLOW, 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev Adds two numbers, returns an error on overflow.\\n   */\\n  function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\\n    uint c = a + b;\\n\\n    if (c >= a) {\\n      return (MathError.NO_ERROR, c);\\n    } else {\\n      return (MathError.INTEGER_OVERFLOW, 0);\\n    }\\n  }\\n\\n  /**\\n   * @dev add a and b and then subtract c\\n   */\\n  function addThenSubUInt(\\n    uint a,\\n    uint b,\\n    uint c\\n  ) internal pure returns (MathError, uint) {\\n    (MathError err0, uint sum) = addUInt(a, b);\\n\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, 0);\\n    }\\n\\n    return subUInt(sum, c);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/tokens/EIP20Interface.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n * https://eips.ethereum.org/EIPS/eip-20\\n * Taken from https://etherscan.deth.net/address/0xd513d22422a3062bd342ae374b4b9c20e0a9a074#code\\n */\\ninterface EIP20Interface {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @notice Get the total number of tokens in circulation\\n   * @return The supply of tokens\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Gets the balance of the specified address\\n   * @param owner The address from which the balance will be retrieved\\n   * @return The balance\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transfer(\\n    address dst,\\n    uint256 amount\\n  ) external returns (bool success);\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `src` to `dst`\\n   * @param src The address of the source account\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amount\\n  ) external returns (bool success);\\n\\n  /**\\n   * @notice Approve `spender` to transfer up to `amount` from `src`\\n   * @dev This will overwrite the approval amount for `spender`\\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n   * @param spender The address of the account which may transfer tokens\\n   * @param amount The number of tokens that are approved (-1 means infinite)\\n   * @return Whether or not the approval succeeded\\n   */\\n  function approve(\\n    address spender,\\n    uint256 amount\\n  ) external returns (bool success);\\n\\n  /**\\n   * @notice Get the current allowance from `owner` for `spender`\\n   * @param owner The address of the account which owns the tokens to be spent\\n   * @param spender The address of the account which may transfer tokens\\n   * @return The number of tokens allowed to be spent (-1 means infinite)\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) external view returns (uint256 remaining);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 amount\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/tokens/Exponential.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.8;\\n\\nimport \\\"./CarefulMath.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-decision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract Exponential is CarefulMath {\\n  uint constant expScale = 1e18;\\n  uint constant halfExpScale = expScale / 2;\\n  uint constant mantissaOne = expScale;\\n\\n  struct Exp {\\n    uint mantissa;\\n  }\\n\\n  /**\\n   * @dev Creates an exponential from numerator and denominator values.\\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n   *            or if `denom` is zero.\\n   */\\n  function getExp(\\n    uint num,\\n    uint denom\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\\n    if (err1 != MathError.NO_ERROR) {\\n      return (err1, Exp({mantissa: 0}));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n  }\\n\\n  /**\\n   * @dev Adds two exponentials, returning a new exponential.\\n   */\\n  function addExp(\\n    Exp memory a,\\n    Exp memory b\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\\n\\n    return (error, Exp({mantissa: result}));\\n  }\\n\\n  /**\\n   * @dev Subtracts two exponentials, returning a new exponential.\\n   */\\n  function subExp(\\n    Exp memory a,\\n    Exp memory b\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\\n\\n    return (error, Exp({mantissa: result}));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\\n   */\\n  function mulScalar(\\n    Exp memory a,\\n    uint scalar\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mulScalarTruncate(\\n    Exp memory a,\\n    uint scalar\\n  ) internal pure returns (MathError, uint) {\\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, truncate(product));\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n   */\\n  function mulScalarTruncateAddUInt(\\n    Exp memory a,\\n    uint scalar,\\n    uint addend\\n  ) internal pure returns (MathError, uint) {\\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return addUInt(truncate(product), addend);\\n  }\\n\\n  /**\\n   * @dev Divide an Exp by a scalar, returning a new Exp.\\n   */\\n  function divScalar(\\n    Exp memory a,\\n    uint scalar\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n  }\\n\\n  /**\\n   * @dev Divide a scalar by an Exp, returning a new Exp.\\n   */\\n  function divScalarByExp(\\n    uint scalar,\\n    Exp memory divisor\\n  ) internal pure returns (MathError, Exp memory) {\\n    /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n    (MathError err0, uint numerator) = mulUInt(expScale, scalar);\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n    return getExp(numerator, divisor.mantissa);\\n  }\\n\\n  /**\\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n   */\\n  function divScalarByExpTruncate(\\n    uint scalar,\\n    Exp memory divisor\\n  ) internal pure returns (MathError, uint) {\\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, truncate(fraction));\\n  }\\n\\n  /**\\n   * @dev Multiplies two exponentials, returning a new exponential.\\n   */\\n  function mulExp(\\n    Exp memory a,\\n    Exp memory b\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err0, uint doubleScaledProduct) = mulUInt(\\n      a.mantissa,\\n      b.mantissa\\n    );\\n    if (err0 != MathError.NO_ERROR) {\\n      return (err0, Exp({mantissa: 0}));\\n    }\\n\\n    // We add half the scale before dividing so that we get rounding instead of truncation.\\n    //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n    (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(\\n      halfExpScale,\\n      doubleScaledProduct\\n    );\\n    if (err1 != MathError.NO_ERROR) {\\n      return (err1, Exp({mantissa: 0}));\\n    }\\n\\n    (MathError err2, uint product) = divUInt(\\n      doubleScaledProductWithHalfScale,\\n      expScale\\n    );\\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n    assert(err2 == MathError.NO_ERROR);\\n\\n    return (MathError.NO_ERROR, Exp({mantissa: product}));\\n  }\\n\\n  /**\\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n   */\\n  function mulExp(\\n    uint a,\\n    uint b\\n  ) internal pure returns (MathError, Exp memory) {\\n    return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n  }\\n\\n  /**\\n   * @dev Multiplies three exponentials, returning a new exponential.\\n   */\\n  function mulExp3(\\n    Exp memory a,\\n    Exp memory b,\\n    Exp memory c\\n  ) internal pure returns (MathError, Exp memory) {\\n    (MathError err, Exp memory ab) = mulExp(a, b);\\n    if (err != MathError.NO_ERROR) {\\n      return (err, ab);\\n    }\\n    return mulExp(ab, c);\\n  }\\n\\n  /**\\n   * @dev Divides two exponentials, returning a new exponential.\\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n   */\\n  function divExp(\\n    Exp memory a,\\n    Exp memory b\\n  ) internal pure returns (MathError, Exp memory) {\\n    return getExp(a.mantissa, b.mantissa);\\n  }\\n\\n  /**\\n   * @dev Truncates the given exp to a whole number value.\\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n   */\\n  function truncate(Exp memory exp) internal pure returns (uint) {\\n    // Note: We are not using careful math here as we're performing a division that cannot fail\\n    return exp.mantissa / expScale;\\n  }\\n\\n  /**\\n   * @dev Checks if first Exp is less than second Exp.\\n   */\\n  function lessThanExp(\\n    Exp memory left,\\n    Exp memory right\\n  ) internal pure returns (bool) {\\n    return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp <= right Exp.\\n   */\\n  function lessThanOrEqualExp(\\n    Exp memory left,\\n    Exp memory right\\n  ) internal pure returns (bool) {\\n    return left.mantissa <= right.mantissa;\\n  }\\n\\n  /**\\n   * @dev returns true if Exp is exactly zero\\n   */\\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\\n    return value.mantissa == 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/tokens/LegacyInterestRateModel.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.16;\\n\\n/**\\n * @title Compound's Legacy InterestRateModel Interface\\n * @author Compound (modified by Arr00)\\n */\\ncontract InterestRateModel {\\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\\n  bool public constant isInterestRateModel = true;\\n\\n  /**\\n   * @notice Calculates the current borrow interest rate per block\\n   * @param cash The total amount of cash the market has\\n   * @param borrows The total amount of borrows the market has outstanding\\n   * @param reserves The total amount of reserves the market has\\n   * @return error code (0 = no error), The borrow rate per block (as a percentage, and scaled by 1e18)\\n   */\\n  function getBorrowRate(\\n    uint cash,\\n    uint borrows,\\n    uint reserves\\n  ) external view returns (uint, uint);\\n\\n  /**\\n   * @notice Calculates the current supply interest rate per block\\n   * @param cash The total amount of cash the market has\\n   * @param borrows The total amount of borrows the market has outstanding\\n   * @param reserves The total amount of reserves the market has\\n   * @param reserveFactorMantissa The current reserve factor the market has\\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\\n   */\\n  function getSupplyRate(\\n    uint cash,\\n    uint borrows,\\n    uint reserves,\\n    uint reserveFactorMantissa\\n  ) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/lending/compound/tokens/cToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.8;\\n\\nimport \\\"./EIP20Interface.sol\\\";\\nimport \\\"./Exponential.sol\\\";\\nimport \\\"./LegacyInterestRateModel.sol\\\";\\nimport \\\"contracts/lending/compound/ErrorReporter.sol\\\";\\nimport \\\"contracts/lending/compound/ReentrancyGuard.sol\\\";\\nimport \\\"contracts/lending/compound/ComptrollerInterface.sol\\\";\\n\\n/**\\n * @title Compound's CToken Contract\\n * @notice Abstract base for CTokens\\n * @author Compound\\n * @dev Copied by Ondo from cUSDC at https://etherscan.io/token/0x39aa39c021dfbae8fac545936693ac917d5e7563#code\\n */\\ncontract CToken is\\n  EIP20Interface,\\n  Exponential,\\n  TokenErrorReporter,\\n  ReentrancyGuard\\n{\\n  /**\\n   * @notice Indicator that this is a CToken contract (for inspection)\\n   */\\n  bool public constant isCToken = true;\\n\\n  /**\\n   * @notice EIP-20 token name for this token\\n   */\\n  string public name;\\n\\n  /**\\n   * @notice EIP-20 token symbol for this token\\n   */\\n  string public symbol;\\n\\n  /**\\n   * @notice EIP-20 token decimals for this token\\n   */\\n  uint public decimals;\\n\\n  /**\\n   * @notice Maximum borrow rate that can ever be applied (.0005% / block)\\n   */\\n  uint constant borrowRateMaxMantissa = 5e14;\\n\\n  /**\\n   * @notice Maximum fraction of interest that can be set aside for reserves\\n   */\\n  uint constant reserveFactorMaxMantissa = 1e18;\\n\\n  /**\\n   * @notice Administrator for this contract\\n   */\\n  address payable public admin;\\n\\n  /**\\n   * @notice Pending administrator for this contract\\n   */\\n  address payable public pendingAdmin;\\n\\n  /**\\n   * @notice Contract which oversees inter-cToken operations\\n   */\\n  ComptrollerInterface public comptroller;\\n\\n  /**\\n   * @notice Model which tells what the current interest rate should be\\n   */\\n  InterestRateModel public interestRateModel;\\n\\n  /**\\n   * @notice Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\\n   */\\n  uint public initialExchangeRateMantissa;\\n\\n  /**\\n   * @notice Fraction of interest currently set aside for reserves\\n   */\\n  uint public reserveFactorMantissa;\\n\\n  /**\\n   * @notice Block number that interest was last accrued at\\n   */\\n  uint public accrualBlockNumber;\\n\\n  /**\\n   * @notice Accumulator of total earned interest since the opening of the market\\n   */\\n  uint public borrowIndex;\\n\\n  /**\\n   * @notice Total amount of outstanding borrows of the underlying in this market\\n   */\\n  uint public totalBorrows;\\n\\n  /**\\n   * @notice Total amount of reserves of the underlying held in this market\\n   */\\n  uint public totalReserves;\\n\\n  /**\\n   * @notice Total number of tokens in circulation\\n   */\\n  uint256 public totalSupply;\\n\\n  /**\\n   * @notice Official record of token balances for each account\\n   */\\n  mapping(address => uint256) accountTokens;\\n\\n  /**\\n   * @notice Approved token transfer amounts on behalf of others\\n   */\\n  mapping(address => mapping(address => uint256)) transferAllowances;\\n\\n  /**\\n   * @notice Container for borrow balance information\\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\n   */\\n  struct BorrowSnapshot {\\n    uint principal;\\n    uint interestIndex;\\n  }\\n\\n  /**\\n   * @notice Mapping of account addresses to outstanding borrow balances\\n   */\\n  mapping(address => BorrowSnapshot) accountBorrows;\\n\\n  /*** Market Events ***/\\n\\n  /**\\n   * @notice Event emitted when interest is accrued\\n   */\\n  event AccrueInterest(\\n    uint interestAccumulated,\\n    uint borrowIndex,\\n    uint totalBorrows\\n  );\\n\\n  /**\\n   * @notice Event emitted when tokens are minted\\n   */\\n  event Mint(address minter, uint mintAmount, uint mintTokens);\\n\\n  /**\\n   * @notice Event emitted when tokens are redeemed\\n   */\\n  event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\\n\\n  /**\\n   * @notice Event emitted when underlying is borrowed\\n   */\\n  event Borrow(\\n    address borrower,\\n    uint borrowAmount,\\n    uint accountBorrows,\\n    uint totalBorrows\\n  );\\n\\n  /**\\n   * @notice Event emitted when a borrow is repaid\\n   */\\n  event RepayBorrow(\\n    address payer,\\n    address borrower,\\n    uint repayAmount,\\n    uint accountBorrows,\\n    uint totalBorrows\\n  );\\n\\n  /**\\n   * @notice Event emitted when a borrow is liquidated\\n   */\\n  event LiquidateBorrow(\\n    address liquidator,\\n    address borrower,\\n    uint repayAmount,\\n    address cTokenCollateral,\\n    uint seizeTokens\\n  );\\n\\n  /*** Admin Events ***/\\n\\n  /**\\n   * @notice Event emitted when pendingAdmin is changed\\n   */\\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n  /**\\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\\n   */\\n  event NewAdmin(address oldAdmin, address newAdmin);\\n\\n  /**\\n   * @notice Event emitted when comptroller is changed\\n   */\\n  event NewComptroller(\\n    ComptrollerInterface oldComptroller,\\n    ComptrollerInterface newComptroller\\n  );\\n\\n  /**\\n   * @notice Event emitted when interestRateModel is changed\\n   */\\n  event NewMarketInterestRateModel(\\n    InterestRateModel oldInterestRateModel,\\n    InterestRateModel newInterestRateModel\\n  );\\n\\n  /**\\n   * @notice Event emitted when the reserve factor is changed\\n   */\\n  event NewReserveFactor(\\n    uint oldReserveFactorMantissa,\\n    uint newReserveFactorMantissa\\n  );\\n\\n  /**\\n   * @notice Event emitted when the reserves are reduced\\n   */\\n  event ReservesReduced(\\n    address admin,\\n    uint reduceAmount,\\n    uint newTotalReserves\\n  );\\n\\n  /**\\n   * @notice Construct a new money market\\n   * @param comptroller_ The address of the Comptroller\\n   * @param interestRateModel_ The address of the interest rate model\\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\n   * @param name_ EIP-20 name of this token\\n   * @param symbol_ EIP-20 symbol of this token\\n   * @param decimals_ EIP-20 decimal precision of this token\\n   */\\n  constructor(\\n    ComptrollerInterface comptroller_,\\n    InterestRateModel interestRateModel_,\\n    uint initialExchangeRateMantissa_,\\n    string memory name_,\\n    string memory symbol_,\\n    uint decimals_\\n  ) internal {\\n    // Set admin to msg.sender\\n    admin = msg.sender;\\n\\n    // Set initial exchange rate\\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\\n    require(\\n      initialExchangeRateMantissa > 0,\\n      \\\"Initial exchange rate must be greater than zero.\\\"\\n    );\\n\\n    // Set the comptroller\\n    uint err = _setComptroller(comptroller_);\\n    require(err == uint(Error.NO_ERROR), \\\"Setting comptroller failed\\\");\\n\\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\n    accrualBlockNumber = getBlockNumber();\\n    borrowIndex = mantissaOne;\\n\\n    // Set the interest rate model (depends on block number / borrow index)\\n    err = _setInterestRateModelFresh(interestRateModel_);\\n    require(err == uint(Error.NO_ERROR), \\\"Setting interest rate model failed\\\");\\n\\n    name = name_;\\n    symbol = symbol_;\\n    decimals = decimals_;\\n  }\\n\\n  /**\\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\n   * @dev Called by both `transfer` and `transferFrom` internally\\n   * @param spender The address of the account performing the transfer\\n   * @param src The address of the source account\\n   * @param dst The address of the destination account\\n   * @param tokens The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transferTokens(\\n    address spender,\\n    address src,\\n    address dst,\\n    uint tokens\\n  ) internal returns (uint) {\\n    /* Fail if transfer not allowed */\\n    uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.TRANSFER_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Do not allow self-transfers */\\n    if (src == dst) {\\n      return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\\n    }\\n\\n    /* Get the allowance, infinite for the account owner */\\n    uint startingAllowance = 0;\\n    if (spender == src) {\\n      startingAllowance = uint(-1);\\n    } else {\\n      startingAllowance = transferAllowances[src][spender];\\n    }\\n\\n    /* Do the calculations, checking for {under,over}flow */\\n    MathError mathErr;\\n    uint allowanceNew;\\n    uint srcTokensNew;\\n    uint dstTokensNew;\\n\\n    (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\\n    if (mathErr != MathError.NO_ERROR) {\\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\\n    }\\n\\n    (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\\n    if (mathErr != MathError.NO_ERROR) {\\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\\n    }\\n\\n    (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\\n    if (mathErr != MathError.NO_ERROR) {\\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    accountTokens[src] = srcTokensNew;\\n    accountTokens[dst] = dstTokensNew;\\n\\n    /* Eat some of the allowance (if necessary) */\\n    if (startingAllowance != uint(-1)) {\\n      transferAllowances[src][spender] = allowanceNew;\\n    }\\n\\n    /* We emit a Transfer event */\\n    emit Transfer(src, dst, tokens);\\n\\n    /* We call the defense hook (which checks for under-collateralization) */\\n    comptroller.transferVerify(address(this), src, dst, tokens);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transfer(\\n    address dst,\\n    uint256 amount\\n  ) external nonReentrant returns (bool) {\\n    return\\n      transferTokens(msg.sender, msg.sender, dst, amount) ==\\n      uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Transfer `amount` tokens from `src` to `dst`\\n   * @param src The address of the source account\\n   * @param dst The address of the destination account\\n   * @param amount The number of tokens to transfer\\n   * @return Whether or not the transfer succeeded\\n   */\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amount\\n  ) external nonReentrant returns (bool) {\\n    return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Approve `spender` to transfer up to `amount` from `src`\\n   * @dev This will overwrite the approval amount for `spender`\\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n   * @param spender The address of the account which may transfer tokens\\n   * @param amount The number of tokens that are approved (-1 means infinite)\\n   * @return Whether or not the approval succeeded\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool) {\\n    address src = msg.sender;\\n    transferAllowances[src][spender] = amount;\\n    emit Approval(src, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Get the current allowance from `owner` for `spender`\\n   * @param owner The address of the account which owns the tokens to be spent\\n   * @param spender The address of the account which may transfer tokens\\n   * @return The number of tokens allowed to be spent (-1 means infinite)\\n   */\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) external view returns (uint256) {\\n    return transferAllowances[owner][spender];\\n  }\\n\\n  /**\\n   * @notice Get the token balance of the `owner`\\n   * @param owner The address of the account to query\\n   * @return The number of tokens owned by `owner`\\n   */\\n  function balanceOf(address owner) external view returns (uint256) {\\n    return accountTokens[owner];\\n  }\\n\\n  /**\\n   * @notice Get the underlying balance of the `owner`\\n   * @dev This also accrues interest in a transaction\\n   * @param owner The address of the account to query\\n   * @return The amount of underlying owned by `owner`\\n   */\\n  function balanceOfUnderlying(address owner) external returns (uint) {\\n    Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\n    (MathError mErr, uint balance) = mulScalarTruncate(\\n      exchangeRate,\\n      accountTokens[owner]\\n    );\\n    require(mErr == MathError.NO_ERROR);\\n    return balance;\\n  }\\n\\n  /**\\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\\n   * @param account Address of the account to snapshot\\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\\n   */\\n  function getAccountSnapshot(\\n    address account\\n  ) external view returns (uint, uint, uint, uint) {\\n    uint cTokenBalance = accountTokens[account];\\n    uint borrowBalance;\\n    uint exchangeRateMantissa;\\n\\n    MathError mErr;\\n\\n    (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\\n    if (mErr != MathError.NO_ERROR) {\\n      return (uint(Error.MATH_ERROR), 0, 0, 0);\\n    }\\n\\n    (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\\n    if (mErr != MathError.NO_ERROR) {\\n      return (uint(Error.MATH_ERROR), 0, 0, 0);\\n    }\\n\\n    return (\\n      uint(Error.NO_ERROR),\\n      cTokenBalance,\\n      borrowBalance,\\n      exchangeRateMantissa\\n    );\\n  }\\n\\n  /**\\n   * @dev Function to simply retrieve block number\\n   *  This exists mainly for inheriting test contracts to stub this result.\\n   */\\n  function getBlockNumber() internal view returns (uint) {\\n    return block.number;\\n  }\\n\\n  /**\\n   * @notice Returns the current per-block borrow interest rate for this cToken\\n   * @return The borrow interest rate per block, scaled by 1e18\\n   */\\n  function borrowRatePerBlock() external view returns (uint) {\\n    (uint opaqueErr, uint borrowRateMantissa) = interestRateModel.getBorrowRate(\\n      getCashPrior(),\\n      totalBorrows,\\n      totalReserves\\n    );\\n    require(\\n      opaqueErr == 0,\\n      \\\"borrowRatePerBlock: interestRateModel.borrowRate failed\\\"\\n    ); // semi-opaque\\n    return borrowRateMantissa;\\n  }\\n\\n  /**\\n   * @notice Returns the current per-block supply interest rate for this cToken\\n   * @return The supply interest rate per block, scaled by 1e18\\n   */\\n  function supplyRatePerBlock() external view returns (uint) {\\n    /* We calculate the supply rate:\\n     *  underlying = totalSupply \u00d7 exchangeRate\\n     *  borrowsPer = totalBorrows \u00f7 underlying\\n     *  supplyRate = borrowRate \u00d7 (1-reserveFactor) \u00d7 borrowsPer\\n     */\\n    uint exchangeRateMantissa = exchangeRateStored();\\n\\n    (uint e0, uint borrowRateMantissa) = interestRateModel.getBorrowRate(\\n      getCashPrior(),\\n      totalBorrows,\\n      totalReserves\\n    );\\n    require(e0 == 0, \\\"supplyRatePerBlock: calculating borrowRate failed\\\"); // semi-opaque\\n\\n    (MathError e1, Exp memory underlying) = mulScalar(\\n      Exp({mantissa: exchangeRateMantissa}),\\n      totalSupply\\n    );\\n    require(\\n      e1 == MathError.NO_ERROR,\\n      \\\"supplyRatePerBlock: calculating underlying failed\\\"\\n    );\\n\\n    (MathError e2, Exp memory borrowsPer) = divScalarByExp(\\n      totalBorrows,\\n      underlying\\n    );\\n    require(\\n      e2 == MathError.NO_ERROR,\\n      \\\"supplyRatePerBlock: calculating borrowsPer failed\\\"\\n    );\\n\\n    (MathError e3, Exp memory oneMinusReserveFactor) = subExp(\\n      Exp({mantissa: mantissaOne}),\\n      Exp({mantissa: reserveFactorMantissa})\\n    );\\n    require(\\n      e3 == MathError.NO_ERROR,\\n      \\\"supplyRatePerBlock: calculating oneMinusReserveFactor failed\\\"\\n    );\\n\\n    (MathError e4, Exp memory supplyRate) = mulExp3(\\n      Exp({mantissa: borrowRateMantissa}),\\n      oneMinusReserveFactor,\\n      borrowsPer\\n    );\\n    require(\\n      e4 == MathError.NO_ERROR,\\n      \\\"supplyRatePerBlock: calculating supplyRate failed\\\"\\n    );\\n\\n    return supplyRate.mantissa;\\n  }\\n\\n  /**\\n   * @notice Returns the current total borrows plus accrued interest\\n   * @return The total borrows with interest\\n   */\\n  function totalBorrowsCurrent() external nonReentrant returns (uint) {\\n    require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n    return totalBorrows;\\n  }\\n\\n  /**\\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\n   * @param account The address whose balance should be calculated after updating borrowIndex\\n   * @return The calculated balance\\n   */\\n  function borrowBalanceCurrent(\\n    address account\\n  ) external nonReentrant returns (uint) {\\n    require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n    return borrowBalanceStored(account);\\n  }\\n\\n  /**\\n   * @notice Return the borrow balance of account based on stored data\\n   * @param account The address whose balance should be calculated\\n   * @return The calculated balance\\n   */\\n  function borrowBalanceStored(address account) public view returns (uint) {\\n    (MathError err, uint result) = borrowBalanceStoredInternal(account);\\n    require(\\n      err == MathError.NO_ERROR,\\n      \\\"borrowBalanceStored: borrowBalanceStoredInternal failed\\\"\\n    );\\n    return result;\\n  }\\n\\n  /**\\n   * @notice Return the borrow balance of account based on stored data\\n   * @param account The address whose balance should be calculated\\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\\n   */\\n  function borrowBalanceStoredInternal(\\n    address account\\n  ) internal view returns (MathError, uint) {\\n    /* Note: we do not assert that the market is up to date */\\n    MathError mathErr;\\n    uint principalTimesIndex;\\n    uint result;\\n\\n    /* Get borrowBalance and borrowIndex */\\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\\n\\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\n     */\\n    if (borrowSnapshot.principal == 0) {\\n      return (MathError.NO_ERROR, 0);\\n    }\\n\\n    /* Calculate new borrow balance using the interest index:\\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\n     */\\n    (mathErr, principalTimesIndex) = mulUInt(\\n      borrowSnapshot.principal,\\n      borrowIndex\\n    );\\n    if (mathErr != MathError.NO_ERROR) {\\n      return (mathErr, 0);\\n    }\\n\\n    (mathErr, result) = divUInt(\\n      principalTimesIndex,\\n      borrowSnapshot.interestIndex\\n    );\\n    if (mathErr != MathError.NO_ERROR) {\\n      return (mathErr, 0);\\n    }\\n\\n    return (MathError.NO_ERROR, result);\\n  }\\n\\n  /**\\n   * @notice Accrue interest then return the up-to-date exchange rate\\n   * @return Calculated exchange rate scaled by 1e18\\n   */\\n  function exchangeRateCurrent() public nonReentrant returns (uint) {\\n    require(accrueInterest() == uint(Error.NO_ERROR), \\\"accrue interest failed\\\");\\n    return exchangeRateStored();\\n  }\\n\\n  /**\\n   * @notice Calculates the exchange rate from the underlying to the CToken\\n   * @dev This function does not accrue interest before calculating the exchange rate\\n   * @return Calculated exchange rate scaled by 1e18\\n   */\\n  function exchangeRateStored() public view returns (uint) {\\n    (MathError err, uint result) = exchangeRateStoredInternal();\\n    require(\\n      err == MathError.NO_ERROR,\\n      \\\"exchangeRateStored: exchangeRateStoredInternal failed\\\"\\n    );\\n    return result;\\n  }\\n\\n  /**\\n   * @notice Calculates the exchange rate from the underlying to the CToken\\n   * @dev This function does not accrue interest before calculating the exchange rate\\n   * @return (error code, calculated exchange rate scaled by 1e18)\\n   */\\n  function exchangeRateStoredInternal()\\n    internal\\n    view\\n    returns (MathError, uint)\\n  {\\n    if (totalSupply == 0) {\\n      /*\\n       * If there are no tokens minted:\\n       *  exchangeRate = initialExchangeRate\\n       */\\n      return (MathError.NO_ERROR, initialExchangeRateMantissa);\\n    } else {\\n      /*\\n       * Otherwise:\\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\\n       */\\n      uint totalCash = getCashPrior();\\n      uint cashPlusBorrowsMinusReserves;\\n      Exp memory exchangeRate;\\n      MathError mathErr;\\n\\n      (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\\n        totalCash,\\n        totalBorrows,\\n        totalReserves\\n      );\\n      if (mathErr != MathError.NO_ERROR) {\\n        return (mathErr, 0);\\n      }\\n\\n      (mathErr, exchangeRate) = getExp(\\n        cashPlusBorrowsMinusReserves,\\n        totalSupply\\n      );\\n      if (mathErr != MathError.NO_ERROR) {\\n        return (mathErr, 0);\\n      }\\n\\n      return (MathError.NO_ERROR, exchangeRate.mantissa);\\n    }\\n  }\\n\\n  /**\\n   * @notice Get cash balance of this cToken in the underlying asset\\n   * @return The quantity of underlying asset owned by this contract\\n   */\\n  function getCash() external view returns (uint) {\\n    return getCashPrior();\\n  }\\n\\n  struct AccrueInterestLocalVars {\\n    MathError mathErr;\\n    uint opaqueErr;\\n    uint borrowRateMantissa;\\n    uint currentBlockNumber;\\n    uint blockDelta;\\n    Exp simpleInterestFactor;\\n    uint interestAccumulated;\\n    uint totalBorrowsNew;\\n    uint totalReservesNew;\\n    uint borrowIndexNew;\\n  }\\n\\n  /**\\n   * @notice Applies accrued interest to total borrows and reserves.\\n   * @dev This calculates interest accrued from the last checkpointed block\\n   *      up to the current block and writes new checkpoint to storage.\\n   */\\n  function accrueInterest() public returns (uint) {\\n    AccrueInterestLocalVars memory vars;\\n\\n    /* Calculate the current borrow interest rate */\\n    (vars.opaqueErr, vars.borrowRateMantissa) = interestRateModel.getBorrowRate(\\n      getCashPrior(),\\n      totalBorrows,\\n      totalReserves\\n    );\\n    require(\\n      vars.borrowRateMantissa <= borrowRateMaxMantissa,\\n      \\\"borrow rate is absurdly high\\\"\\n    );\\n    if (vars.opaqueErr != 0) {\\n      return\\n        failOpaque(\\n          Error.INTEREST_RATE_MODEL_ERROR,\\n          FailureInfo.ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\\n          vars.opaqueErr\\n        );\\n    }\\n\\n    /* Remember the initial block number */\\n    vars.currentBlockNumber = getBlockNumber();\\n\\n    /* Calculate the number of blocks elapsed since the last accrual */\\n    (vars.mathErr, vars.blockDelta) = subUInt(\\n      vars.currentBlockNumber,\\n      accrualBlockNumber\\n    );\\n    assert(vars.mathErr == MathError.NO_ERROR); // Block delta should always succeed and if it doesn't, blow up.\\n\\n    /*\\n     * Calculate the interest accumulated into borrows and reserves and the new index:\\n     *  simpleInterestFactor = borrowRate * blockDelta\\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\n     */\\n    (vars.mathErr, vars.simpleInterestFactor) = mulScalar(\\n      Exp({mantissa: vars.borrowRateMantissa}),\\n      vars.blockDelta\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.interestAccumulated) = mulScalarTruncate(\\n      vars.simpleInterestFactor,\\n      totalBorrows\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.totalBorrowsNew) = addUInt(\\n      vars.interestAccumulated,\\n      totalBorrows\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.totalReservesNew) = mulScalarTruncateAddUInt(\\n      Exp({mantissa: reserveFactorMantissa}),\\n      vars.interestAccumulated,\\n      totalReserves\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.borrowIndexNew) = mulScalarTruncateAddUInt(\\n      vars.simpleInterestFactor,\\n      borrowIndex,\\n      borrowIndex\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We write the previously calculated values into storage */\\n    accrualBlockNumber = vars.currentBlockNumber;\\n    borrowIndex = vars.borrowIndexNew;\\n    totalBorrows = vars.totalBorrowsNew;\\n    totalReserves = vars.totalReservesNew;\\n\\n    /* We emit an AccrueInterest event */\\n    emit AccrueInterest(\\n      vars.interestAccumulated,\\n      vars.borrowIndexNew,\\n      totalBorrows\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param mintAmount The amount of the underlying asset to supply\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function mintInternal(uint mintAmount) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n      return fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED);\\n    }\\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\\n    return mintFresh(msg.sender, mintAmount);\\n  }\\n\\n  struct MintLocalVars {\\n    Error err;\\n    MathError mathErr;\\n    uint exchangeRateMantissa;\\n    uint mintTokens;\\n    uint totalSupplyNew;\\n    uint accountTokensNew;\\n  }\\n\\n  /**\\n   * @notice User supplies assets into the market and receives cTokens in exchange\\n   * @dev Assumes interest has already been accrued up to the current block\\n   * @param minter The address of the account which is supplying the assets\\n   * @param mintAmount The amount of the underlying asset to supply\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function mintFresh(address minter, uint mintAmount) internal returns (uint) {\\n    /* Fail if mint not allowed */\\n    uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.MINT_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK);\\n    }\\n\\n    MintLocalVars memory vars;\\n\\n    /* Fail if checkTransferIn fails */\\n    vars.err = checkTransferIn(minter, mintAmount);\\n    if (vars.err != Error.NO_ERROR) {\\n      return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_NOT_POSSIBLE);\\n    }\\n\\n    /*\\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\\n     *  mintTokens = mintAmount / exchangeRate\\n     */\\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\\n      mintAmount,\\n      Exp({mantissa: vars.exchangeRateMantissa})\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.MINT_EXCHANGE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /*\\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\\n     *  totalSupplyNew = totalSupply + mintTokens\\n     *  accountTokensNew = accountTokens[minter] + mintTokens\\n     */\\n    (vars.mathErr, vars.totalSupplyNew) = addUInt(totalSupply, vars.mintTokens);\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.accountTokensNew) = addUInt(\\n      accountTokens[minter],\\n      vars.mintTokens\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     * We call doTransferIn for the minter and the mintAmount\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken holds an additional mintAmount of cash.\\n     *  If doTransferIn fails despite the fact we checked pre-conditions,\\n     *   we revert because we can't be sure if side effects occurred.\\n     */\\n    vars.err = doTransferIn(minter, mintAmount);\\n    if (vars.err != Error.NO_ERROR) {\\n      return fail(vars.err, FailureInfo.MINT_TRANSFER_IN_FAILED);\\n    }\\n\\n    /* We write previously calculated values into storage */\\n    totalSupply = vars.totalSupplyNew;\\n    accountTokens[minter] = vars.accountTokensNew;\\n\\n    /* We emit a Mint event, and a Transfer event */\\n    emit Mint(minter, mintAmount, vars.mintTokens);\\n    emit Transfer(address(this), minter, vars.mintTokens);\\n\\n    /* We call the defense hook */\\n    comptroller.mintVerify(address(this), minter, mintAmount, vars.mintTokens);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sender redeems cTokens in exchange for the underlying asset\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param redeemTokens The number of cTokens to redeem into underlying\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemInternal(\\n    uint redeemTokens\\n  ) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\\n      return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\\n    }\\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n    return redeemFresh(msg.sender, redeemTokens, 0);\\n  }\\n\\n  /**\\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\\n   * @param redeemAmount The amount of underlying to redeem\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemUnderlyingInternal(\\n    uint redeemAmount\\n  ) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\\n      return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\\n    }\\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\\n    return redeemFresh(msg.sender, 0, redeemAmount);\\n  }\\n\\n  struct RedeemLocalVars {\\n    Error err;\\n    MathError mathErr;\\n    uint exchangeRateMantissa;\\n    uint redeemTokens;\\n    uint redeemAmount;\\n    uint totalSupplyNew;\\n    uint accountTokensNew;\\n  }\\n\\n  /**\\n   * @notice User redeems cTokens in exchange for the underlying asset\\n   * @dev Assumes interest has already been accrued up to the current block\\n   * @param redeemer The address of the account which is redeeming the tokens\\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\\n   * @param redeemAmountIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be zero)\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function redeemFresh(\\n    address payable redeemer,\\n    uint redeemTokensIn,\\n    uint redeemAmountIn\\n  ) internal returns (uint) {\\n    require(\\n      redeemTokensIn == 0 || redeemAmountIn == 0,\\n      \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\"\\n    );\\n\\n    RedeemLocalVars memory vars;\\n\\n    /* exchangeRate = invoke Exchange Rate Stored() */\\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /* If redeemTokensIn > 0: */\\n    if (redeemTokensIn > 0) {\\n      /*\\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\\n       *  redeemTokens = redeemTokensIn\\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\\n       */\\n      vars.redeemTokens = redeemTokensIn;\\n\\n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\\n        Exp({mantissa: vars.exchangeRateMantissa}),\\n        redeemTokensIn\\n      );\\n      if (vars.mathErr != MathError.NO_ERROR) {\\n        return\\n          failOpaque(\\n            Error.MATH_ERROR,\\n            FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\\n            uint(vars.mathErr)\\n          );\\n      }\\n    } else {\\n      /*\\n       * We get the current exchange rate and calculate the amount to be redeemed:\\n       *  redeemTokens = redeemAmountIn / exchangeRate\\n       *  redeemAmount = redeemAmountIn\\n       */\\n\\n      (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\\n        redeemAmountIn,\\n        Exp({mantissa: vars.exchangeRateMantissa})\\n      );\\n      if (vars.mathErr != MathError.NO_ERROR) {\\n        return\\n          failOpaque(\\n            Error.MATH_ERROR,\\n            FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\\n            uint(vars.mathErr)\\n          );\\n      }\\n\\n      vars.redeemAmount = redeemAmountIn;\\n    }\\n\\n    /* Fail if redeem not allowed */\\n    uint allowed = comptroller.redeemAllowed(\\n      address(this),\\n      redeemer,\\n      vars.redeemTokens\\n    );\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.REDEEM_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\\n    }\\n\\n    /*\\n     * We calculate the new total supply and redeemer balance, checking for underflow:\\n     *  totalSupplyNew = totalSupply - redeemTokens\\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\\n     */\\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(\\n      totalSupply,\\n      vars.redeemTokens\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.accountTokensNew) = subUInt(\\n      accountTokens[redeemer],\\n      vars.redeemTokens\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /* Fail gracefully if protocol has insufficient cash */\\n    if (getCashPrior() < vars.redeemAmount) {\\n      return\\n        fail(\\n          Error.TOKEN_INSUFFICIENT_CASH,\\n          FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE\\n        );\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken has redeemAmount less of cash.\\n     *  If doTransferOut fails despite the fact we checked pre-conditions,\\n     *   we revert because we can't be sure if side effects occurred.\\n     */\\n    vars.err = doTransferOut(redeemer, vars.redeemAmount);\\n    require(vars.err == Error.NO_ERROR, \\\"redeem transfer out failed\\\");\\n\\n    /* We write previously calculated values into storage */\\n    totalSupply = vars.totalSupplyNew;\\n    accountTokens[redeemer] = vars.accountTokensNew;\\n\\n    /* We emit a Transfer event, and a Redeem event */\\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\\n\\n    /* We call the defense hook */\\n    comptroller.redeemVerify(\\n      address(this),\\n      redeemer,\\n      vars.redeemAmount,\\n      vars.redeemTokens\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sender borrows assets from the protocol to their own address\\n   * @param borrowAmount The amount of the underlying asset to borrow\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function borrowInternal(\\n    uint borrowAmount\\n  ) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n      return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\\n    }\\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\\n    return borrowFresh(msg.sender, borrowAmount);\\n  }\\n\\n  struct BorrowLocalVars {\\n    Error err;\\n    MathError mathErr;\\n    uint accountBorrows;\\n    uint accountBorrowsNew;\\n    uint totalBorrowsNew;\\n  }\\n\\n  /**\\n   * @notice Users borrow assets from the protocol to their own address\\n   * @param borrowAmount The amount of the underlying asset to borrow\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function borrowFresh(\\n    address payable borrower,\\n    uint borrowAmount\\n  ) internal returns (uint) {\\n    /* Fail if borrow not allowed */\\n    uint allowed = comptroller.borrowAllowed(\\n      address(this),\\n      borrower,\\n      borrowAmount\\n    );\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.BORROW_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\\n    }\\n\\n    /* Fail gracefully if protocol has insufficient underlying cash */\\n    if (getCashPrior() < borrowAmount) {\\n      return\\n        fail(\\n          Error.TOKEN_INSUFFICIENT_CASH,\\n          FailureInfo.BORROW_CASH_NOT_AVAILABLE\\n        );\\n    }\\n\\n    BorrowLocalVars memory vars;\\n\\n    /*\\n     * We calculate the new borrower and total borrow balances, failing on overflow:\\n     *  accountBorrowsNew = accountBorrows + borrowAmount\\n     *  totalBorrowsNew = totalBorrows + borrowAmount\\n     */\\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.accountBorrowsNew) = addUInt(\\n      vars.accountBorrows,\\n      borrowAmount\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     * We invoke doTransferOut for the borrower and the borrowAmount.\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken borrowAmount less of cash.\\n     *  If doTransferOut fails despite the fact we checked pre-conditions,\\n     *   we revert because we can't be sure if side effects occurred.\\n     */\\n    vars.err = doTransferOut(borrower, borrowAmount);\\n    require(vars.err == Error.NO_ERROR, \\\"borrow transfer out failed\\\");\\n\\n    /* We write the previously calculated values into storage */\\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\\n    accountBorrows[borrower].interestIndex = borrowIndex;\\n    totalBorrows = vars.totalBorrowsNew;\\n\\n    /* We emit a Borrow event */\\n    emit Borrow(\\n      borrower,\\n      borrowAmount,\\n      vars.accountBorrowsNew,\\n      vars.totalBorrowsNew\\n    );\\n\\n    /* We call the defense hook */\\n    comptroller.borrowVerify(address(this), borrower, borrowAmount);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sender repays their own borrow\\n   * @param repayAmount The amount to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function repayBorrowInternal(\\n    uint repayAmount\\n  ) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n      return\\n        fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED);\\n    }\\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\\n  }\\n\\n  /**\\n   * @notice Sender repays a borrow belonging to borrower\\n   * @param borrower the account with the debt being payed off\\n   * @param repayAmount The amount to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function repayBorrowBehalfInternal(\\n    address borrower,\\n    uint repayAmount\\n  ) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\\n      return\\n        fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED);\\n    }\\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\\n  }\\n\\n  struct RepayBorrowLocalVars {\\n    Error err;\\n    MathError mathErr;\\n    uint repayAmount;\\n    uint borrowerIndex;\\n    uint accountBorrows;\\n    uint accountBorrowsNew;\\n    uint totalBorrowsNew;\\n  }\\n\\n  /**\\n   * @notice Borrows are repaid by another user (possibly the borrower).\\n   * @param payer the account paying off the borrow\\n   * @param borrower the account with the debt being payed off\\n   * @param repayAmount the amount of undelrying tokens being returned\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function repayBorrowFresh(\\n    address payer,\\n    address borrower,\\n    uint repayAmount\\n  ) internal returns (uint) {\\n    /* Fail if repayBorrow not allowed */\\n    uint allowed = comptroller.repayBorrowAllowed(\\n      address(this),\\n      payer,\\n      borrower,\\n      repayAmount\\n    );\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      return\\n        fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK);\\n    }\\n\\n    RepayBorrowLocalVars memory vars;\\n\\n    /* We remember the original borrowerIndex for verification purposes */\\n    vars.borrowerIndex = accountBorrows[borrower].interestIndex;\\n\\n    /* We fetch the amount the borrower owes, with accumulated interest */\\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /* If repayAmount == -1, repayAmount = accountBorrows */\\n    if (repayAmount == uint(-1)) {\\n      vars.repayAmount = vars.accountBorrows;\\n    } else {\\n      vars.repayAmount = repayAmount;\\n    }\\n\\n    /* Fail if checkTransferIn fails */\\n    vars.err = checkTransferIn(payer, vars.repayAmount);\\n    if (vars.err != Error.NO_ERROR) {\\n      return fail(vars.err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\\n    }\\n\\n    /*\\n     * We calculate the new borrower and total borrow balances, failing on underflow:\\n     *  accountBorrowsNew = accountBorrows - repayAmount\\n     *  totalBorrowsNew = totalBorrows - repayAmount\\n     */\\n    (vars.mathErr, vars.accountBorrowsNew) = subUInt(\\n      vars.accountBorrows,\\n      vars.repayAmount\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo\\n            .REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    (vars.mathErr, vars.totalBorrowsNew) = subUInt(\\n      totalBorrows,\\n      vars.repayAmount\\n    );\\n    if (vars.mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\\n          uint(vars.mathErr)\\n        );\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /*\\n     * We call doTransferIn for the payer and the repayAmount\\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\\n     *  On success, the cToken holds an additional repayAmount of cash.\\n     *  If doTransferIn fails despite the fact we checked pre-conditions,\\n     *   we revert because we can't be sure if side effects occurred.\\n     */\\n    vars.err = doTransferIn(payer, vars.repayAmount);\\n    require(vars.err == Error.NO_ERROR, \\\"repay borrow transfer in failed\\\");\\n\\n    /* We write the previously calculated values into storage */\\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\\n    accountBorrows[borrower].interestIndex = borrowIndex;\\n    totalBorrows = vars.totalBorrowsNew;\\n\\n    /* We emit a RepayBorrow event */\\n    emit RepayBorrow(\\n      payer,\\n      borrower,\\n      vars.repayAmount,\\n      vars.accountBorrowsNew,\\n      vars.totalBorrowsNew\\n    );\\n\\n    /* We call the defense hook */\\n    comptroller.repayBorrowVerify(\\n      address(this),\\n      payer,\\n      borrower,\\n      vars.repayAmount,\\n      vars.borrowerIndex\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice The sender liquidates the borrowers collateral.\\n   *  The collateral seized is transferred to the liquidator.\\n   * @param borrower The borrower of this cToken to be liquidated\\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\\n   * @param repayAmount The amount of the underlying borrowed asset to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function liquidateBorrowInternal(\\n    address borrower,\\n    uint repayAmount,\\n    CToken cTokenCollateral\\n  ) internal nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n      return\\n        fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED);\\n    }\\n\\n    error = cTokenCollateral.accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\n      return\\n        fail(\\n          Error(error),\\n          FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED\\n        );\\n    }\\n\\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\\n    return\\n      liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\\n  }\\n\\n  /**\\n   * @notice The liquidator liquidates the borrowers collateral.\\n   *  The collateral seized is transferred to the liquidator.\\n   * @param borrower The borrower of this cToken to be liquidated\\n   * @param liquidator The address repaying the borrow and seizing collateral\\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\\n   * @param repayAmount The amount of the underlying borrowed asset to repay\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function liquidateBorrowFresh(\\n    address liquidator,\\n    address borrower,\\n    uint repayAmount,\\n    CToken cTokenCollateral\\n  ) internal returns (uint) {\\n    /* Fail if liquidate not allowed */\\n    uint allowed = comptroller.liquidateBorrowAllowed(\\n      address(this),\\n      address(cTokenCollateral),\\n      liquidator,\\n      borrower,\\n      repayAmount\\n    );\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Verify market's block number equals current block number */\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      return\\n        fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK);\\n    }\\n\\n    /* Verify cTokenCollateral market's block number equals current block number */\\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\\n      return\\n        fail(\\n          Error.MARKET_NOT_FRESH,\\n          FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK\\n        );\\n    }\\n\\n    /* Fail if borrower = liquidator */\\n    if (borrower == liquidator) {\\n      return\\n        fail(\\n          Error.INVALID_ACCOUNT_PAIR,\\n          FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\\n        );\\n    }\\n\\n    /* Fail if repayAmount = 0 */\\n    if (repayAmount == 0) {\\n      return\\n        fail(\\n          Error.INVALID_CLOSE_AMOUNT_REQUESTED,\\n          FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO\\n        );\\n    }\\n\\n    /* Fail if repayAmount = -1 */\\n    if (repayAmount == uint(-1)) {\\n      return\\n        fail(\\n          Error.INVALID_CLOSE_AMOUNT_REQUESTED,\\n          FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX\\n        );\\n    }\\n\\n    /* We calculate the number of collateral tokens that will be seized */\\n    (uint amountSeizeError, uint seizeTokens) = comptroller\\n      .liquidateCalculateSeizeTokens(\\n        address(this),\\n        address(cTokenCollateral),\\n        repayAmount\\n      );\\n    if (amountSeizeError != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_CALCULATION_ERROR,\\n          FailureInfo.LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\\n          amountSeizeError\\n        );\\n    }\\n\\n    /* Fail if seizeTokens > borrower collateral token balance */\\n    if (seizeTokens > cTokenCollateral.balanceOf(borrower)) {\\n      return\\n        fail(\\n          Error.TOKEN_INSUFFICIENT_BALANCE,\\n          FailureInfo.LIQUIDATE_SEIZE_TOO_MUCH\\n        );\\n    }\\n\\n    /* Fail if repayBorrow fails */\\n    uint repayBorrowError = repayBorrowFresh(liquidator, borrower, repayAmount);\\n    if (repayBorrowError != uint(Error.NO_ERROR)) {\\n      return\\n        fail(\\n          Error(repayBorrowError),\\n          FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\\n        );\\n    }\\n\\n    /* Revert if seize tokens fails (since we cannot be sure of side effects) */\\n    uint seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\\n    require(seizeError == uint(Error.NO_ERROR), \\\"token seizure failed\\\");\\n\\n    /* We emit a LiquidateBorrow event */\\n    emit LiquidateBorrow(\\n      liquidator,\\n      borrower,\\n      repayAmount,\\n      address(cTokenCollateral),\\n      seizeTokens\\n    );\\n\\n    /* We call the defense hook */\\n    comptroller.liquidateBorrowVerify(\\n      address(this),\\n      address(cTokenCollateral),\\n      liquidator,\\n      borrower,\\n      repayAmount,\\n      seizeTokens\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Transfers collateral tokens (this market) to the liquidator.\\n   * @dev Will fail unless called by another cToken during the process of liquidation.\\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\\n   * @param liquidator The account receiving seized collateral\\n   * @param borrower The account having collateral seized\\n   * @param seizeTokens The number of cTokens to seize\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function seize(\\n    address liquidator,\\n    address borrower,\\n    uint seizeTokens\\n  ) external nonReentrant returns (uint) {\\n    /* Fail if seize not allowed */\\n    uint allowed = comptroller.seizeAllowed(\\n      address(this),\\n      msg.sender,\\n      liquidator,\\n      borrower,\\n      seizeTokens\\n    );\\n    if (allowed != 0) {\\n      return\\n        failOpaque(\\n          Error.COMPTROLLER_REJECTION,\\n          FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\\n          allowed\\n        );\\n    }\\n\\n    /* Fail if borrower = liquidator */\\n    if (borrower == liquidator) {\\n      return\\n        fail(\\n          Error.INVALID_ACCOUNT_PAIR,\\n          FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER\\n        );\\n    }\\n\\n    MathError mathErr;\\n    uint borrowerTokensNew;\\n    uint liquidatorTokensNew;\\n\\n    /*\\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\n     */\\n    (mathErr, borrowerTokensNew) = subUInt(\\n      accountTokens[borrower],\\n      seizeTokens\\n    );\\n    if (mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\\n          uint(mathErr)\\n        );\\n    }\\n\\n    (mathErr, liquidatorTokensNew) = addUInt(\\n      accountTokens[liquidator],\\n      seizeTokens\\n    );\\n    if (mathErr != MathError.NO_ERROR) {\\n      return\\n        failOpaque(\\n          Error.MATH_ERROR,\\n          FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\\n          uint(mathErr)\\n        );\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    /* We write the previously calculated values into storage */\\n    accountTokens[borrower] = borrowerTokensNew;\\n    accountTokens[liquidator] = liquidatorTokensNew;\\n\\n    /* Emit a Transfer event */\\n    emit Transfer(borrower, liquidator, seizeTokens);\\n\\n    /* We call the defense hook */\\n    comptroller.seizeVerify(\\n      address(this),\\n      msg.sender,\\n      liquidator,\\n      borrower,\\n      seizeTokens\\n    );\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /*** Admin Functions ***/\\n\\n  /**\\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n   * @param newPendingAdmin New pending admin.\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   *\\n   * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\\n   */\\n  function _setPendingAdmin(\\n    address payable newPendingAdmin\\n  ) external returns (uint) {\\n    // Check caller = admin\\n    if (msg.sender != admin) {\\n      return\\n        fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\\n    }\\n\\n    // Save current value, if any, for inclusion in log\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    // Store pendingAdmin with value newPendingAdmin\\n    pendingAdmin = newPendingAdmin;\\n\\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n   * @dev Admin function for pending admin to accept role and update admin\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _acceptAdmin() external returns (uint) {\\n    // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\\n      return\\n        fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\\n    }\\n\\n    // Save current values for inclusion in log\\n    address oldAdmin = admin;\\n    address oldPendingAdmin = pendingAdmin;\\n\\n    // Store admin with value pendingAdmin\\n    admin = pendingAdmin;\\n\\n    // Clear the pending value\\n    pendingAdmin = address(0);\\n\\n    emit NewAdmin(oldAdmin, admin);\\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Sets a new comptroller for the market\\n   * @dev Admin function to set a new comptroller\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setComptroller(\\n    ComptrollerInterface newComptroller\\n  ) public returns (uint) {\\n    // Check caller is admin\\n    if (msg.sender != admin) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\\n    }\\n\\n    ComptrollerInterface oldComptroller = comptroller;\\n    // Ensure invoke comptroller.isComptroller() returns true\\n    require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\n\\n    // Set market's comptroller to newComptroller\\n    comptroller = newComptroller;\\n\\n    // Emit NewComptroller(oldComptroller, newComptroller)\\n    emit NewComptroller(oldComptroller, newComptroller);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\n   * @dev Admin function to accrue interest and set a new reserve factor\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setReserveFactor(\\n    uint newReserveFactorMantissa\\n  ) external nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\\n      return\\n        fail(\\n          Error(error),\\n          FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\\n        );\\n    }\\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\\n    return _setReserveFactorFresh(newReserveFactorMantissa);\\n  }\\n\\n  /**\\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\n   * @dev Admin function to set a new reserve factor\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setReserveFactorFresh(\\n    uint newReserveFactorMantissa\\n  ) internal returns (uint) {\\n    // Check caller is admin\\n    if (msg.sender != admin) {\\n      return\\n        fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\\n    }\\n\\n    // Verify market's block number equals current block number\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      // TODO: static_assert + no error code?\\n      return\\n        fail(\\n          Error.MARKET_NOT_FRESH,\\n          FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK\\n        );\\n    }\\n\\n    // Check newReserveFactor \u2264 maxReserveFactor\\n    if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\\n      return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\\n    }\\n\\n    uint oldReserveFactorMantissa = reserveFactorMantissa;\\n    reserveFactorMantissa = newReserveFactorMantissa;\\n\\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice Accrues interest and reduces reserves by transferring to admin\\n   * @param reduceAmount Amount of reduction to reserves\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _reduceReserves(\\n    uint reduceAmount\\n  ) external nonReentrant returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\\n      return\\n        fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\\n    }\\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\\n    return _reduceReservesFresh(reduceAmount);\\n  }\\n\\n  /**\\n   * @notice Reduces reserves by transferring to admin\\n   * @dev Requires fresh interest accrual\\n   * @param reduceAmount Amount of reduction to reserves\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\\n    Error err;\\n    // totalReserves - reduceAmount\\n    uint totalReservesNew;\\n\\n    // Check caller is admin\\n    if (msg.sender != admin) {\\n      return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\\n    }\\n\\n    // We fail gracefully unless market's block number equals current block number\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      // TODO: static_assert + no error code?\\n      return\\n        fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\\n    }\\n\\n    // Fail gracefully if protocol has insufficient underlying cash\\n    if (getCashPrior() < reduceAmount) {\\n      return\\n        fail(\\n          Error.TOKEN_INSUFFICIENT_CASH,\\n          FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE\\n        );\\n    }\\n\\n    // Check reduceAmount \u2264 reserves[n] (totalReserves)\\n    // TODO: I'm following the spec literally here but I think we should we just use SafeMath instead and fail on an error (which would be underflow)\\n    if (reduceAmount > totalReserves) {\\n      return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\\n    }\\n\\n    /////////////////////////\\n    // EFFECTS & INTERACTIONS\\n    // (No safe failures beyond this point)\\n\\n    totalReservesNew = totalReserves - reduceAmount;\\n    // We checked reduceAmount <= totalReserves above, so this should never revert.\\n    require(\\n      totalReservesNew <= totalReserves,\\n      \\\"reduce reserves unexpected underflow\\\"\\n    );\\n\\n    // Store reserves[n+1] = reserves[n] - reduceAmount\\n    totalReserves = totalReservesNew;\\n\\n    // invoke doTransferOut(reduceAmount, admin)\\n    err = doTransferOut(admin, reduceAmount);\\n    // we revert on the failure of this command\\n    require(err == Error.NO_ERROR, \\\"reduce reserves transfer out failed\\\");\\n\\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /**\\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\n   * @dev Admin function to accrue interest and update the interest rate model\\n   * @param newInterestRateModel the new interest rate model to use\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setInterestRateModel(\\n    InterestRateModel newInterestRateModel\\n  ) public returns (uint) {\\n    uint error = accrueInterest();\\n    if (error != uint(Error.NO_ERROR)) {\\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\\n      return\\n        fail(\\n          Error(error),\\n          FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED\\n        );\\n    }\\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\\n    return _setInterestRateModelFresh(newInterestRateModel);\\n  }\\n\\n  /**\\n   * @notice updates the interest rate model (*requires fresh interest accrual)\\n   * @dev Admin function to update the interest rate model\\n   * @param newInterestRateModel the new interest rate model to use\\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n   */\\n  function _setInterestRateModelFresh(\\n    InterestRateModel newInterestRateModel\\n  ) internal returns (uint) {\\n    // Used to store old model for use in the event that is emitted on success\\n    InterestRateModel oldInterestRateModel;\\n\\n    // Check caller is admin\\n    if (msg.sender != admin) {\\n      return\\n        fail(\\n          Error.UNAUTHORIZED,\\n          FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK\\n        );\\n    }\\n\\n    // We fail gracefully unless market's block number equals current block number\\n    if (accrualBlockNumber != getBlockNumber()) {\\n      // TODO: static_assert + no error code?\\n      return\\n        fail(\\n          Error.MARKET_NOT_FRESH,\\n          FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\\n        );\\n    }\\n\\n    // Track the market's current interest rate model\\n    oldInterestRateModel = interestRateModel;\\n\\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\n    require(\\n      newInterestRateModel.isInterestRateModel(),\\n      \\\"marker method returned false\\\"\\n    );\\n\\n    // Set the interest rate model to newInterestRateModel\\n    interestRateModel = newInterestRateModel;\\n\\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\\n\\n    return uint(Error.NO_ERROR);\\n  }\\n\\n  /*** Safe Token ***/\\n\\n  /**\\n   * @notice Gets balance of this contract in terms of the underlying\\n   * @dev This excludes the value of the current message, if any\\n   * @return The quantity of underlying owned by this contract\\n   */\\n  function getCashPrior() internal view returns (uint);\\n\\n  /**\\n   * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and\\n   *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.\\n   */\\n  function checkTransferIn(\\n    address from,\\n    uint amount\\n  ) internal view returns (Error);\\n\\n  /**\\n   * @dev Performs a transfer in, ideally returning an explanatory error code upon failure rather than reverting.\\n   *  If caller has not called `checkTransferIn`, this may revert due to insufficient balance or insufficient allowance.\\n   *  If caller has called `checkTransferIn` successfully, this should not revert in normal conditions.\\n   */\\n  function doTransferIn(address from, uint amount) internal returns (Error);\\n\\n  /**\\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\\n   */\\n  function doTransferOut(\\n    address payable to,\\n    uint amount\\n  ) internal returns (Error);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingImplementation\",\"type\":\"address\"}],\"name\":\"NewPendingImplementation\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_acceptImplementation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"_setPendingAdmin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingImplementation\",\"type\":\"address\"}],\"name\":\"_setPendingImplementation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comptrollerImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingComptrollerImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Unitroller", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000817cbea752a640f1f20276cbc9b86feb7d23e668", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}