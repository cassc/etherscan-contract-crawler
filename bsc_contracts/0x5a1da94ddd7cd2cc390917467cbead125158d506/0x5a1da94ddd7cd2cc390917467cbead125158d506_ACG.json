{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/acg.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.17;\\n\\n/*\\n * Import the ERC20 contract, which implements the standard ERC20 token interface\\n * for managing and transferring tokens on the Ethereum/BSC blockchain.\\n */\\nimport \\\"./contracts/token/ERC20/ERC20.sol\\\";\\n/*\\n * Import the SafeERC20 library, which provides additional safety checks when interacting with ERC20 tokens.\\n * This library is used to make sure that token transfers and approvals are executed safely without common security vulnerabilities.\\n */\\nimport \\\"./contracts/token/ERC20/SafeERC20.sol\\\";\\n/*\\n * Import the Ownable contract, which provides basic access control functions and allows the\\n * contract owner to transfer ownership to another address.\\n */\\nimport \\\"./contracts/access/Ownable.sol\\\";\\n/*\\n * Import the Address library, which provides utility functions for working with Ethereum addresses,\\n * including checking if an address is a contract or not.\\n */\\nimport \\\"./contracts/utils/Address.sol\\\";\\n\\n/*\\n * Import the interface for the Uniswap V2 / Pancakeswap V2 Factory contract, which provides functions for\\n * creating and managing pairs of tokens on the Uniswap V2 / Pancakeswap V2 decentralized exchange.\\n */\\nimport \\\"./contracts/interfaces/IUniswapV2Factory.sol\\\";\\n/*\\n * Import the interface for the Uniswap V2 / Pancakeswap V2 Pair contract, which represents a pair of tokens\\n * in the Uniswap V2 / Pancakeswap V2 decentralized exchange.\\n */\\nimport \\\"./contracts/interfaces/IUniswapV2Pair.sol\\\";\\n/*\\n * Import the interface for the Uniswap V2 / Pancakeswap V2 Router contract, which provides functions for\\n * swapping tokens on the Uniswap V2 / Pancakeswap V2 decentralized exchange.\\n */\\nimport \\\"./contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\n/// @custom:security-contact contact@addictivecryptogames.com\\ncontract ACG is ERC20, Ownable {\\n    // Use the Address library to interact with Ethereum addresses.\\n    using Address for address;\\n    // Use the SafeERC20 library to add additional safety checks\\n    // when interacting with ERC20 tokens through the IERC20 interface.\\n    using SafeERC20 for IERC20;\\n\\n    // Balances of token holders.\\n    mapping(address => uint256) private _balances;\\n    // Allowances granted by token holders to other addresses.\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    // A mapping of addresses that are excluded or included in fee calculations.\\n    // Fees are not charged to excluded addresses.\\n    mapping(address => bool) private _isExcludedFromFee;\\n\\n    // Define the total number of tokens that can be created and\\n    // set it to 1,000,000,000 multiplied by 10^18 (to account for decimal places).\\n    // This is the total supply of tokens that will ever exist in the system.\\n    uint256 private constant TOTAL_SUPPLY = 1000000000 * 10 ** 18;\\n    // Set a maximum value that a variable can hold.\\n    // This is done to ensure that the token supply remains within a certain limit.\\n    uint256 private constant MAX_TOKEN_SUPPLY = ~uint256(0);\\n    // Calculate the largest possible number of tokens that\\n    // can be minted by the smart contract, which is evenly divisible by the total supply of tokens.\\n    // This ensures that the total number of tokens remains consistent and\\n    // makes it easier to manage token balances and transactions.\\n    uint256 private _maxMintableSupply = (MAX_TOKEN_SUPPLY -\\n        (MAX_TOKEN_SUPPLY % TOTAL_SUPPLY));\\n    // The maximum amount of tokens that can be transferred in a single transaction.\\n    uint256 public constant MAX_TX_AMOUNT = 150000000 * 10 ** 18; // 15% of the total supply\\n    // The whale amount of tokens that is being swapped in a single transaction.\\n    uint256 public penaltyTxAmount = 10000000 * 10 ** 18; // 1% of the total supply\\n\\n    // The total amount of tokens that have been charged as Buy & Sell orders transaction fees.\\n    uint256 public totalFeesCharged;\\n\\n    // The minimum balance of tokens that must be held in the contract before\\n    // it can swap tokens and collect transaction fees.\\n    // Once the balance of tokens held in the contract exceeds the\\n    // swapThresholdLimit, the contract can swap tokens for the underlying asset and collect fees.\\n    uint256 public swapThresholdLimit = 500000 * 10 ** 18;\\n\\n    // The name of the token.\\n    string private constant NAME = \\\"Addictive Crypto Games\\\";\\n    // The symbol of the token.\\n    string private constant SYMBOL = \\\"ACG\\\";\\n    // The number of decimal places for the token.\\n    uint8 private constant DECIMALS = 18;\\n\\n    // The address of the PancakeSwap Router contract.\\n    IUniswapV2Router02 public uniswapV2Router;\\n    // The address of the token pair contract.\\n    address public uniswapV2Pair;\\n\\n    // A boolean flag to indicate whether the contract is currently swapping and adding/getting liquidity/fees.\\n    bool private _isSwappingAndGettingFees;\\n    // Swap/get liquidity/fees Enabled/Disabled\\n    bool public isSwapAndGetFeesEnabled = true;\\n\\n    // Boolean flag to track if fees are being set\\n    bool private _feesAreBeingSet;\\n\\n    // Struct to store information about each user's last transfer block and sell count\\n    struct BotInfo {\\n        uint256 lastTransferBlock; // To keep track of the block number of the last transfer for each user\\n        uint256 sellCount; // To keep track of the number of times each user has sold tokens\\n    }\\n\\n    // Public mapping that maps an Ethereum address to a BotInfo struct for each user\\n    mapping(address => BotInfo) public botInfo;\\n    // Maximum number of times a user can sell tokens within the time limit\\n    uint256 public maxBotSellCount = 5;\\n    // Time limit for the anti-bot mechanism, measured in blocks\\n    uint256 public botSellBlockLimit = 100; // 1Block/3sec - 100blocks = 5 minutes\\n    // Boolean variable to check if antiBot is enabled\\n    bool public isAntiBotEnabled = true;\\n\\n    // The percentage fee charged for operations.\\n    uint256 public operationFee = 2;\\n    uint256 private _previousOperationFee = operationFee;\\n\\n    // The percentage fee charged for marketing.\\n    uint256 public marketingFee = 3;\\n    uint256 private _previousMarketingFee = marketingFee;\\n\\n    // The percentage fee charged for pools & leaderboards.\\n    uint256 public poolsLeaderboardFee = 5;\\n    uint256 private _previousPoolsLeaderboardsFee = poolsLeaderboardFee;\\n\\n    // The percentage fee charged for community.\\n    uint256 public communityFee = 1;\\n    uint256 private _previousCommunityFee = communityFee;\\n\\n    // The percentage fee charged for treasury one.\\n    uint256 public treasuryOneFee = 2;\\n    uint256 private _previousTreasuryOneFee = treasuryOneFee;\\n\\n    // The percentage fee charged for treasury two.\\n    uint256 public treasuryTwoFee = 2;\\n    uint256 private _previousTreasuryTwoFee = treasuryTwoFee;\\n\\n    // The percentage fee charged for liquidity.\\n    uint256 public liquidityFee = 5;\\n    uint256 private _previousLiquidityFee = liquidityFee;\\n\\n    // The percentage fee charged for whales penalty.\\n    uint256 public penaltyFee = 10;\\n    uint256 private _previousPenaltyFee = penaltyFee;\\n\\n    /**\\n     * The total fees required for a Buy or Sell transaction,\\n     * including development, marketing, game, and liquidity fees\\n     */\\n    uint256 public totalRequiredFees =\\n        operationFee +\\n            marketingFee +\\n            poolsLeaderboardFee +\\n            communityFee +\\n            treasuryOneFee +\\n            treasuryTwoFee +\\n            liquidityFee +\\n            penaltyFee;\\n\\n    /**\\n     * The total fees required for a Buy orders.\\n     */\\n    uint256 public totalRequiredBuyFees =\\n        operationFee + marketingFee + liquidityFee;\\n\\n    /**\\n     * The total fees required for a sell orders.\\n     */\\n    uint256 public totalRequiredSellFees =\\n        poolsLeaderboardFee + communityFee + treasuryOneFee + treasuryTwoFee;\\n\\n    // The total ERC20 fees charged for Buy & Sell.\\n    uint256 public totalERC20Fees = totalRequiredFees - liquidityFee;\\n\\n    // Addresses of the wallets to receive the respective fees\\n    address public operationWallet = 0xAd1dd1645CFA26462fa53D343B9498E0a04cf60D;\\n    address public marketingWallet = 0xd6e3572f5989857CFAF18aBd45decf3d69e38178;\\n    address public poolsLeaderboardWallet =\\n        0x4A93c75bE2172ac4e2136a323E24b5b0360f73C1;\\n    address public communityWallet = 0x265dA26D5081Dc2aEC9612e8c646D5031BE9c482;\\n    address public treasuryOneWallet =\\n        0x6473CB09Ca62C0e257e601b58FD240704855c2F9;\\n    address public treasuryTwoWallet =\\n        0x4A8a3530a1925BCC936340481F073EE7eCdD0B4E;\\n    address public penaltyWallet = 0x3F406F6E74A08Ac33d59b8c82813b92734C18B41;\\n\\n    // Address of the ERC20 token to receive the fees in (e.g., BUSD, USDT)\\n    address public erc20TokenFeeAddress;\\n\\n    // Uint256 variable to check which pool should we add liquidity to e.g(ACG/WBNB - ACG/USDT)\\n    uint256 public liquidityPoolToUse = 0; // 0 = WBNB/ACG - 1 = USDT/ACG - 2 = Special/ACG\\n\\n    // Address of ERC20 token USDT\\n    address public usdtAddress;\\n\\n    // Address of ERC20 token e.g: BTC/...\\n    address public specialAddress;\\n\\n    // Modifier to prevent swapping and adding liquidity simultaneously\\n    modifier lockTheSwap() {\\n        require(\\n            !_isSwappingAndGettingFees,\\n            \\\"ACG: Swap and liquify in progress\\\"\\n        );\\n        _isSwappingAndGettingFees = true;\\n        _;\\n        _isSwappingAndGettingFees = false;\\n    }\\n\\n    // Modifier to ensure that fees are not currently being set\\n    modifier feesNotBeingSet() {\\n        // Check that fees are not currently being set\\n        require(!_feesAreBeingSet, \\\"ACG: Fees are being set.\\\");\\n        // Set the flag to indicate that fees are being set\\n        _feesAreBeingSet = true;\\n        // Execute the function\\n        _;\\n        // Reset the flag to indicate that fees are no longer being set\\n        _feesAreBeingSet = false;\\n    }\\n\\n    // Events to track setters\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiquidity\\n    );\\n    event SwapAndGetFees(\\n        uint256 contractTokenBalance,\\n        uint256 newBalance,\\n        uint256 availableAmount\\n    );\\n    event NewFeeWAllet(address newFeeWallet);\\n    event SetNewSwapRouter(address newRouterAddress, address newPairAddress);\\n    event SetNewSwapThresholdLimit(uint256 newThresholdLimit);\\n    event SetNewPenaltyTxAmount(uint256 newPenaltyLimit);\\n    event SetNewErc20TokenAddress(address newErc20TokenAddress);\\n    event SetNewMaxBoxSellCount(uint256 newMaxBotLimit);\\n    event SetNewBotSellTime(uint256 newBotSellTime);\\n    event SetAntiBotStatus(bool newStatus);\\n    event SetNewFees(\\n        uint256 newBuySellFees,\\n        uint256 newTotalRequiredFees,\\n        uint256 newErc20Fees\\n    );\\n    event SetNewPenaltyFees(\\n        uint256 newPenaltyFe,\\n        uint256 newTotalRequiredFees,\\n        uint256 newErc20Fees\\n    );\\n    event ExcludeAddressFromFee(address account);\\n    event IncludeAddressInFee(address account);\\n    event SendFeesToWallets(\\n        uint256 operationAmount,\\n        uint256 marketingAmount,\\n        uint256 poolsLeaderboardAmount,\\n        uint256 communityAmount,\\n        uint256 treasuryOneAmount,\\n        uint256 treasuryTwoAmount,\\n        uint256 penaltyAmount\\n    );\\n    event ManualBNBSwap(uint256 tokensAmount);\\n    event ManualErc20Swap(uint256 tokensAmount);\\n    event RecoverContractBNB(uint256 bnbAmount);\\n    event AutoErc20Swap(uint256 tokenAmount);\\n    event RecoverErc20TokensToOwner(address token, uint256 tokenAmount);\\n    event RecoverErc20TokensTAddress(\\n        address token,\\n        uint256 tokenAmount,\\n        address to\\n    );\\n    event SetNewLiquidityPoolToUse(uint256 newLiquidityPool);\\n    event SetNewUSDTAddress(address newAddress);\\n    event SetNewSpecialAddress(address newAddress);\\n    event ApproveRouterToSpendTokens(address tokenAddress, uint256 amount);\\n\\n    /**\\n     * @dev Constructor function to initialize the token and its initial state\\n     */\\n    constructor() ERC20(NAME, SYMBOL) {\\n        // Initialize balances\\n        _balances[_msgSender()] = _maxMintableSupply;\\n\\n        // Set up the pancake router and create a new pair for the token and WETH(WBNB)\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\\n        );\\n        // Create a pancake pair for this new token\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        uniswapV2Router = _uniswapV2Router;\\n\\n        // Set the token used for fees to USDT\\n        erc20TokenFeeAddress = address(\\n            0x55d398326f99059fF775485246999027B3197955\\n        );\\n\\n        // Exclude the owner and this contract from fees\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n        // Emit a transfer event to show the initial supply has been transferred to the contract deployer\\n        emit Transfer(address(0), _msgSender(), TOTAL_SUPPLY);\\n    }\\n\\n    // Get the name of the token\\n    function name() public pure override returns (string memory) {\\n        return NAME;\\n    }\\n\\n    // Get the symbol of the token\\n    function symbol() public pure override returns (string memory) {\\n        return SYMBOL;\\n    }\\n\\n    // Get the number of decimal places used by the token\\n    function decimals() public pure override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    // Get the total supply of the token\\n    function totalSupply() public pure override returns (uint256) {\\n        return TOTAL_SUPPLY;\\n    }\\n\\n    // Get the balance of a specific account\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return tokenFromReflection(_balances[account]);\\n    }\\n\\n    // Fallback function to receive ETH\\n    receive() external payable {}\\n\\n    /* overrides */\\n\\n    /**\\n     * @dev Approves the given address to spend the specified amount of tokens on behalf of the owner.\\n     * @param owner The address that owns the tokens.\\n     * @param spender The address that will spend the tokens.\\n     * @param amount The amount of tokens to be spent.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal override {\\n        require(owner != address(0), \\\"ACG: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ACG: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Transfer amount of tokens from the caller's account to recipient.\\n     * @param recipient The address of the recipient.\\n     * @param amount The amount of tokens to transfer.\\n     * @return A boolean value indicating whether the transfer was successful or not.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens that the spender is allowed to transfer from owner.\\n     * @param owner The address of the account holding the tokens.\\n     * @param spender The address of the account allowed to spend the tokens.\\n     * @return The number of tokens that spender is allowed to spend on behalf of owner.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of the sender.\\n     * @param spender The address that will be allowed to spend the tokens.\\n     * @param amount The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the approval was successful or not.\\n     */\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    // Returns the contract's BNB balance\\n    function getBNBBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    // Returns the contract's balance of a specific ERC20 token (e.g. BUSD, USDT, etc.)\\n    function getErc20TokenFeeBalance() public view returns (uint256) {\\n        return IERC20(erc20TokenFeeAddress).balanceOf(address(this));\\n    }\\n\\n    // Returns the contract's balance of a specific ERC20 token (specified by its address)\\n    function getErc20TokensBalance(\\n        address token\\n    ) public view returns (uint256) {\\n        return IERC20(token).balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Internal function to check if the tokenAddress requested have WBNB/token pair\\n     * @param tokenAddress The address of the token to get check pair for\\n     */\\n    function _checkTokenWBNBPair(address tokenAddress) internal view {\\n        address[] memory path = new address[](2);\\n        path[0] = address(tokenAddress);\\n        path[1] = uniswapV2Router.WETH();\\n        uint[] memory amounts = uniswapV2Router.getAmountsOut(1e18, path);\\n        require(\\n            amounts.length > 0 && amounts[amounts.length - 1] > 0,\\n            \\\"ACG: No WBNNB pair for ERC20 token\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the new USDT address\\n     * @param newAddress The address of USDT\\n     */\\n    function setUSDTAddress(address newAddress) external onlyOwner {\\n        require(newAddress != address(0), \\\"ACG: Address zero detected\\\");\\n        require(newAddress != usdtAddress, \\\"ACG: Already set\\\");\\n\\n        _checkTokenWBNBPair(newAddress);\\n\\n        usdtAddress = address(newAddress);\\n\\n        emit SetNewUSDTAddress(newAddress);\\n    }\\n\\n    /**\\n     * @dev Set the new special address\\n     * @param newAddress The address of special address\\n     */\\n    function setSpecialAddress(address newAddress) external onlyOwner {\\n        require(newAddress != address(0), \\\"ACG: Address zero detected\\\");\\n        require(newAddress != specialAddress, \\\"ACG: Already set\\\");\\n\\n        _checkTokenWBNBPair(newAddress);\\n\\n        specialAddress = address(newAddress);\\n\\n        emit SetNewSpecialAddress(newAddress);\\n    }\\n\\n    /**\\n     * @dev Set the new pool to add liquidity to e.g(ACG/WBNB - ACG/USDT)\\n     * @param newLiquidityPool The number of the new liquidity pool to add (1 = usdt / 2 = specialERC20Address)\\n     */\\n    function setLiquidityPoolToUse(\\n        uint256 newLiquidityPool\\n    ) external onlyOwner {\\n        require(\\n            newLiquidityPool != liquidityPoolToUse,\\n            \\\"ACG: Already the same pair is set\\\"\\n        );\\n        require(\\n            newLiquidityPool == 0 ||\\n                newLiquidityPool == 1 ||\\n                newLiquidityPool == 2,\\n            \\\"ACG: Please choose between 0/1/2\\\"\\n        );\\n\\n        if (newLiquidityPool == 1) {\\n            require(usdtAddress != address(0), \\\"ACG: Add USDT address first\\\");\\n        } else if (newLiquidityPool == 2) {\\n            require(\\n                specialAddress != address(0),\\n                \\\"ACG: Add ERC20 special address first\\\"\\n            );\\n        }\\n\\n        liquidityPoolToUse = newLiquidityPool;\\n\\n        emit SetNewLiquidityPoolToUse(newLiquidityPool);\\n    }\\n\\n    /**\\n     * @dev Approves the Uniswap V2 router to spend tokens on behalf of the contract for a specified amount.\\n     * @param tokenAddress The address of the token to be approved for spending.\\n     * @param amount The amount of tokens to be approved for spending.\\n     */\\n    function approveRouterToSpendTokens(\\n        address tokenAddress,\\n        uint256 amount\\n    ) external onlyOwner {\\n        // Ensure that the token address is not the zero address.\\n        require(tokenAddress != address(0), \\\"ACG: Address zero detected\\\");\\n\\n        // Ensure that the token address is either the USDT token address\\n        // or a special token address configured within the contract.\\n        require(\\n            tokenAddress == usdtAddress || tokenAddress == specialAddress,\\n            \\\"ACG: Approve spend is allowed to be called using one of the tokens configured within the contract\\\"\\n        );\\n\\n        // Approve the Uniswap V2 router to spend the specified amount of tokens on behalf of the contract.\\n        IERC20(tokenAddress).safeApprove(address(uniswapV2Router), amount);\\n\\n        // Emit an event to notify that the token has been approved for spending.\\n        emit ApproveRouterToSpendTokens(tokenAddress, amount);\\n    }\\n\\n    /**\\n     * @dev Sets the address of the Uniswap router and creates a new pair for the token and WETH if it does not already exist.\\n     * @param newRouter The address of the new Uniswap router.\\n     */\\n    function setSwapRouter(address newRouter) external onlyOwner {\\n        require(newRouter != address(0), \\\"ACG: Invalid router address\\\");\\n        require(\\n            newRouter != address(uniswapV2Router),\\n            \\\"ACG: Router already set\\\"\\n        );\\n\\n        IUniswapV2Factory factory = IUniswapV2Factory(newRouter);\\n        address wethAddress = IUniswapV2Router02(newRouter).WETH();\\n\\n        // Check if a pair already exists for this token and WETH on the new router\\n        address pairAddress = factory.getPair(address(this), wethAddress);\\n        if (pairAddress == address(0)) {\\n            // If no pair exists, create a new one\\n            pairAddress = factory.createPair(address(this), wethAddress);\\n        }\\n\\n        // Update the router and pair addresses\\n        uniswapV2Router = IUniswapV2Router02(newRouter);\\n        uniswapV2Pair = pairAddress;\\n\\n        emit SetNewSwapRouter(newRouter, pairAddress);\\n    }\\n\\n    /**\\n     * @dev Sets the new swap threshold limit.\\n     * @param newLimit The new swap threshold limit to set.\\n     */\\n    function setSwapThresholdLimit(uint256 newLimit) external onlyOwner {\\n        uint256 _vLimiter = 5000000 * 10 ** 18; // 5 million max\\n        require(\\n            newLimit * 10 ** 18 <= _vLimiter,\\n            \\\"ACG: New limit should not be greater than 5 million\\\"\\n        );\\n        require(\\n            newLimit * 10 ** 18 != swapThresholdLimit,\\n            \\\"ACG: New value should not be equal to the same value\\\"\\n        );\\n        swapThresholdLimit = newLimit * 10 ** 18;\\n\\n        emit SetNewSwapThresholdLimit(newLimit);\\n    }\\n\\n    /**\\n     * @dev Sets the new penalty tx amount.\\n     * @param newLimit The new penalty tx amount.\\n     */\\n    function setPenaltyTxAmount(uint256 newLimit) external onlyOwner {\\n        require(newLimit > 0, \\\"ACG: New limit should be greater than 0\\\");\\n        require(\\n            newLimit * 10 ** 18 != penaltyTxAmount,\\n            \\\"ACG: New limit should be the same as the current limit\\\"\\n        );\\n        penaltyTxAmount = newLimit * 10 ** 18;\\n\\n        emit SetNewPenaltyTxAmount(newLimit);\\n    }\\n\\n    /**\\n     * @dev Sets the address of the ERC-20 token to be used as the fee.\\n     * @param newToken The new address of the ERC-20 token to be used as the fee.\\n     */\\n    function setErc20TokenAddress(address newToken) external onlyOwner {\\n        require(newToken != address(0), \\\"ACG: Invalid ERC-20 token address\\\");\\n        require(\\n            newToken != erc20TokenFeeAddress,\\n            \\\"ACG: Token address is the same.\\\"\\n        );\\n\\n        // Check if a WBNNB pair exists for the ERC20 token\\n        _checkTokenWBNBPair(newToken);\\n\\n        erc20TokenFeeAddress = address(newToken);\\n\\n        emit SetNewErc20TokenAddress(newToken);\\n    }\\n\\n    /**\\n     * @dev Sets the new antiBot status.\\n     * @param newStatus The new antiBot status (true/false).\\n     */\\n    function setAntiBotStatus(bool newStatus) external onlyOwner {\\n        require(\\n            newStatus != isAntiBotEnabled,\\n            \\\"ACG: New antiBot status should not be equal to the current status\\\"\\n        );\\n\\n        isAntiBotEnabled = newStatus;\\n\\n        emit SetAntiBotStatus(newStatus);\\n    }\\n\\n    /**\\n     * @dev Sets the new bot sell count limit.\\n     * @param newCount The new bot sell count.\\n     */\\n    function setMaxBotSellCount(uint256 newCount) external onlyOwner {\\n        require(\\n            newCount != maxBotSellCount,\\n            \\\"ACG: New count should not be same as the current value\\\"\\n        );\\n        require(newCount >= 1, \\\"ACG: Value should be greater than 0\\\");\\n        maxBotSellCount = newCount;\\n\\n        emit SetNewMaxBoxSellCount(newCount);\\n    }\\n\\n    /**\\n     * @dev Sets the new bot sell time limit.\\n     * @param newLimit The new bot sell time limit in (minitues).\\n     */\\n    function setBotSellTimeLimit(uint256 newLimit) external onlyOwner {\\n        require(\\n            newLimit <= 5,\\n            \\\"ACG: Value should be less than or equal to 5 minitues\\\"\\n        );\\n\\n        uint256 _newSellTimeLimitInBlocks = (newLimit * 60 seconds) / 3;\\n\\n        require(\\n            _newSellTimeLimitInBlocks != botSellBlockLimit,\\n            \\\"ACG: Same value\\\"\\n        );\\n\\n        botSellBlockLimit = _newSellTimeLimitInBlocks;\\n\\n        emit SetNewBotSellTime(_newSellTimeLimitInBlocks);\\n    }\\n\\n    /**\\n     * @dev Functions to set the fee wallets\\n     */\\n    function setOperationWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != operationWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        operationWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    function setMarketingWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != marketingWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        marketingWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    function setPoolsLeaderboardWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != poolsLeaderboardWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        poolsLeaderboardWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    function setCommunityWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != communityWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        communityWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    function setTreasuryOneWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != treasuryOneWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        treasuryOneWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    function setTreasuryTwoWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != treasuryTwoWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        treasuryTwoWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    function setPenaltyWallet(address newWallet) external onlyOwner {\\n        require(newWallet != address(0), \\\"ACG: new wallet, zero address\\\");\\n        require(\\n            newWallet != penaltyWallet,\\n            \\\"ACG: New wallet should not be equal to the current wallet\\\"\\n        );\\n        penaltyWallet = newWallet;\\n        emit NewFeeWAllet(newWallet);\\n    }\\n\\n    /**\\n     * @dev Private function to update the fee configuration\\n     * @param totalNewFees The total amount of new fees to be set\\n     * @param isBuyFees A boolean indicating whether the new fees are for buy or sell transactions\\n     * @return A tuple containing the new values of totalRequiredFees and totalERC20Fees\\n     */\\n    function _updateFees(\\n        uint256 totalNewFees,\\n        bool isBuyFees\\n    ) private returns (uint256, uint256) {\\n        if (isBuyFees) {\\n            // Update the total required buy fees to reflect the new fee configuration\\n            totalRequiredBuyFees = totalNewFees;\\n\\n            // Update the total required fees to reflect the new fee configuration\\n            totalRequiredFees =\\n                totalNewFees +\\n                totalRequiredSellFees +\\n                penaltyFee;\\n\\n            // Update the total ERC20 fees to reflect the new fee configuration\\n            // Subtract the liquidity fee as it is handled separately\\n            totalERC20Fees =\\n                totalNewFees +\\n                totalRequiredSellFees +\\n                penaltyFee -\\n                liquidityFee;\\n        } else {\\n            // Update the total required sell fees to reflect the new fee configuration\\n            totalRequiredSellFees = totalNewFees;\\n\\n            // Update the total required fees to reflect the new fee configuration\\n            totalRequiredFees =\\n                totalNewFees +\\n                totalRequiredBuyFees +\\n                penaltyFee;\\n\\n            // Update the total ERC20 fees to reflect the new fee configuration\\n            // Subtract the liquidity fee as it is handled separately\\n            totalERC20Fees =\\n                totalNewFees +\\n                totalRequiredBuyFees +\\n                penaltyFee -\\n                liquidityFee;\\n        }\\n\\n        return (totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate the total new fees\\n     * @param newFee The amount of the new fee to be added\\n     * @param feeToSet The amount of the old fee to be replaced\\n     * @param isBuyFees A boolean indicating whether the function is calculating buy fees or sell fees\\n     * @return The total amount of new fees\\n     */\\n    function _calculateTotalNewFees(\\n        uint256 newFee,\\n        uint256 feeToSet,\\n        bool isBuyFees\\n    ) internal view returns (uint256) {\\n        uint256 totalNewFees;\\n\\n        if (isBuyFees) {\\n            totalNewFees = totalRequiredBuyFees + newFee - feeToSet;\\n        } else {\\n            totalNewFees = totalRequiredSellFees + newFee - feeToSet;\\n        }\\n\\n        return totalNewFees;\\n    }\\n\\n    /**\\n     * @dev Function to set the operations fee percentage\\n     * @param newFee The new operations fee percentage to be set\\n     */\\n    function setOperationFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != operationFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            operationFee,\\n            true\\n        );\\n\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the new fees\\n        operationFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, true);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the marketing fee percentage\\n     * @param newFee The new marketing fee percentage to be set\\n     */\\n    function setMarketingFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != marketingFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            marketingFee,\\n            true\\n        );\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the new fees\\n        marketingFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, true);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the liquidity fee percentage\\n     * @param newFee The new liquidity fee percentage to be set\\n     */\\n    function setLiquidityFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != liquidityFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            liquidityFee,\\n            true\\n        );\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the new fees\\n        liquidityFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, true);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the pools & leaderboard one fee percentage\\n     * @param newFee The new pools & leaderboard one fee percentage to be set\\n     */\\n    function setPoolsLeaderboardFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != poolsLeaderboardFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            poolsLeaderboardFee,\\n            false\\n        );\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the the fees\\n        poolsLeaderboardFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, false);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the community fee percentage\\n     * @param newFee The new community fee percentage to be set\\n     */\\n    function setCommunityFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != communityFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            communityFee,\\n            false\\n        );\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the the fees\\n        communityFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, false);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the treasuryOneFee fee percentage\\n     * @param newFee The new treasuryOneFee fee percentage to be set\\n     */\\n    function setTreasuryOneFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != treasuryOneFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            treasuryOneFee,\\n            false\\n        );\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the fees\\n        treasuryOneFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, false);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the treasuryTwoFee fee percentage\\n     * @param newFee The new treasuryTwoFee fee percentage to be set\\n     */\\n    function setTreasuryTwoFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != treasuryTwoFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Calculate the total new fees after the fee change\\n        uint256 totalNewFees = _calculateTotalNewFees(\\n            newFee,\\n            treasuryTwoFee,\\n            false\\n        );\\n        // Ensure the total fees do not exceed 15%\\n        require(totalNewFees <= 15, \\\"ACG: Total fees should not exceed 15%.\\\");\\n\\n        // Set the fees\\n        treasuryTwoFee = newFee;\\n\\n        (totalRequiredFees, totalERC20Fees) = _updateFees(totalNewFees, false);\\n\\n        emit SetNewFees(totalNewFees, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to set the penalty fee percentage\\n     * @param newFee The new penalty fee percentage to be set\\n     */\\n    function setPenaltyFeePercent(\\n        uint256 newFee\\n    ) external onlyOwner feesNotBeingSet {\\n        // Ensure the new fee is not the same as the current fee\\n        require(\\n            newFee != penaltyFee,\\n            \\\"ACG: New Fee already the same as the current fee.\\\"\\n        );\\n\\n        // Ensure the total penalty fees do not exceed 10%\\n        require(newFee <= 10, \\\"ACG: Total penalty fees should not exceed 10%.\\\");\\n\\n        // Set the fees\\n        penaltyFee = newFee;\\n\\n        // Update the total required fees to reflect the new fee configuration\\n        totalRequiredFees =\\n            newFee +\\n            totalRequiredBuyFees +\\n            totalRequiredSellFees;\\n        // Update the total ERC20 fees to reflect the new fee configuration\\n        // Subtract the liquidity fee as it is handled separately\\n        totalERC20Fees =\\n            newFee +\\n            totalRequiredBuyFees +\\n            totalRequiredSellFees -\\n            liquidityFee;\\n\\n        emit SetNewPenaltyFees(newFee, totalRequiredFees, totalERC20Fees);\\n    }\\n\\n    /**\\n     * @dev Function to remove all fees.\\n     * It checks if all the fees are already set to 0, if so, it returns without doing anything.\\n     * Otherwise, it stores the current fees in _previousXFee variables, where X can be operation/...\\n     * After that, it sets all the fees to 0.\\n     */\\n    function _removeAllFees() private {\\n        if (\\n            operationFee == 0 &&\\n            marketingFee == 0 &&\\n            poolsLeaderboardFee == 0 &&\\n            communityFee == 0 &&\\n            treasuryOneFee == 0 &&\\n            treasuryTwoFee == 0 &&\\n            liquidityFee == 0 &&\\n            penaltyFee == 0\\n        ) {\\n            _previousOperationFee = 0;\\n            _previousMarketingFee = 0;\\n            _previousPoolsLeaderboardsFee = 0;\\n            _previousCommunityFee = 0;\\n            _previousTreasuryOneFee = 0;\\n            _previousTreasuryTwoFee = 0;\\n            _previousLiquidityFee = 0;\\n            _previousPenaltyFee = 0;\\n            return;\\n        }\\n\\n        _previousOperationFee = operationFee;\\n        _previousMarketingFee = marketingFee;\\n        _previousPoolsLeaderboardsFee = poolsLeaderboardFee;\\n        _previousCommunityFee = communityFee;\\n        _previousTreasuryOneFee = treasuryOneFee;\\n        _previousTreasuryTwoFee = treasuryTwoFee;\\n        _previousLiquidityFee = liquidityFee;\\n        _previousPenaltyFee = penaltyFee;\\n\\n        operationFee = 0;\\n        marketingFee = 0;\\n        poolsLeaderboardFee = 0;\\n        communityFee = 0;\\n        treasuryOneFee = 0;\\n        treasuryTwoFee = 0;\\n        liquidityFee = 0;\\n        penaltyFee = 0;\\n    }\\n\\n    /**\\n     * @dev Function to restore all fees.\\n     * It restores all the fees to their previous values stored in `_previousXFee` variables, where X can be Dev, Marketing,\\n     * GameOne, GameTwo, GameThree or Liquidity.\\n     */\\n    function _restoreAllFees() private {\\n        operationFee = _previousOperationFee;\\n        marketingFee = _previousMarketingFee;\\n        poolsLeaderboardFee = _previousPoolsLeaderboardsFee;\\n        communityFee = _previousCommunityFee;\\n        treasuryOneFee = _previousTreasuryOneFee;\\n        treasuryTwoFee = _previousTreasuryTwoFee;\\n        liquidityFee = _previousLiquidityFee;\\n        penaltyFee = _previousPenaltyFee;\\n    }\\n\\n    /**\\n     * @dev Function to exclude an account from paying fees.\\n     * @param account The address of the account to be excluded from paying fees.\\n     * It sets the `_isExcludedFromFee` mapping value for the given account to true,\\n     * effectively excluding it from paying any fees.\\n     */\\n    function excludeFromFee(address account) public onlyOwner {\\n        require(!_isExcludedFromFee[account], \\\"ACG: Already excluded\\\");\\n        _isExcludedFromFee[account] = true;\\n\\n        emit ExcludeAddressFromFee(account);\\n    }\\n\\n    /**\\n     * @dev Function to include an account in paying fees.\\n     * @param account The address of the account to be included in paying fees.\\n     * It sets the `_isExcludedFromFee` mapping value for the given account to false,\\n     *  effectively including it inpaying fees.\\n     */\\n    function includeInFee(address account) public onlyOwner {\\n        require(_isExcludedFromFee[account], \\\"ACG: Already included\\\");\\n        _isExcludedFromFee[account] = false;\\n\\n        emit IncludeAddressInFee(account);\\n    }\\n\\n    /**\\n     * @dev Function to enable/disable swapping and liquifying tokens.\\n     * @param enabled A boolean value indicating whether to enable/disable swapping and liquifying tokens.\\n     * It sets the `isSwapAndGetFeesEnabled` boolean value to the given `enabled` value\\n     * and emits an `SwapAndLiquifyEnabledUpdated` event.\\n     */\\n    function setSwapAndLiquifyEnabled(bool enabled) public onlyOwner {\\n        require(\\n            isSwapAndGetFeesEnabled != enabled,\\n            \\\"ACG: Already the same value\\\"\\n        );\\n        isSwapAndGetFeesEnabled = enabled;\\n        emit SwapAndLiquifyEnabledUpdated(enabled);\\n    }\\n\\n    /**\\n     * @dev Calculates the fees based on a given amount and fee percentage.\\n     * @param tAmount The amount to calculate fees for.\\n     * @param recipient The address to check if sell oder.\\n     * @return The calculated fee amount.\\n     */\\n    function _calculateFees(\\n        uint256 tAmount,\\n        address recipient\\n    ) private view returns (uint256) {\\n        uint256 _totalFees;\\n\\n        if (recipient == uniswapV2Pair) {\\n            _totalFees = _calculateSellFee(tAmount);\\n        } else {\\n            _totalFees = _calculateBuyFee(tAmount);\\n        }\\n\\n        return _totalFees;\\n    }\\n\\n    // calculate buy fees\\n    function _calculateBuyFee(uint256 tAmount) private view returns (uint256) {\\n        uint256 _tOperationFee = _calculateFee(tAmount, operationFee);\\n        uint256 _tMarketingFee = _calculateFee(tAmount, marketingFee);\\n        uint256 _tLiquidityFee = _calculateFee(tAmount, liquidityFee);\\n\\n        uint256 _buyFees = _tOperationFee + _tMarketingFee + _tLiquidityFee;\\n\\n        return _buyFees;\\n    }\\n\\n    // calculate sell fees\\n    function _calculateSellFee(uint256 tAmount) private view returns (uint256) {\\n        uint256 _tPoolsLeaderboardFee = _calculateFee(\\n            tAmount,\\n            poolsLeaderboardFee\\n        );\\n        uint256 _tCommunityFee = _calculateFee(tAmount, communityFee);\\n        uint256 _tTreasuryOneFee = _calculateFee(tAmount, treasuryOneFee);\\n        uint256 _tTreasuryTwoFee = _calculateFee(tAmount, treasuryTwoFee);\\n\\n        uint256 _sellFees = _tPoolsLeaderboardFee +\\n            _tCommunityFee +\\n            _tTreasuryOneFee +\\n            _tTreasuryTwoFee;\\n\\n        if (tAmount >= penaltyTxAmount) {\\n            uint256 _tPenaltyFee = _calculateFee(tAmount, penaltyFee);\\n            _sellFees += _tPenaltyFee;\\n        }\\n\\n        return _sellFees;\\n    }\\n\\n    function _calculateFee(\\n        uint256 tAmount,\\n        uint256 _fee\\n    ) private pure returns (uint256) {\\n        return (tAmount * _fee) / 100;\\n    }\\n\\n    /**\\n     * @dev Retrieves the current supply of tokens in reflection and token form.\\n     * @return The current reflection supply and token supply.\\n     */\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = _maxMintableSupply;\\n        uint256 tSupply = TOTAL_SUPPLY;\\n        if (rSupply < _maxMintableSupply / TOTAL_SUPPLY)\\n            return (_maxMintableSupply, TOTAL_SUPPLY);\\n        return (rSupply, tSupply);\\n    }\\n\\n    /**\\n     * @dev Retrieves the current rate of tokens based on the current supply.\\n     * @return The current token rate.\\n     */\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    /**\\n     * @dev Calculates the token amount from a given reflection amount.\\n     * @param rAmount The reflection amount to convert to token amount.\\n     * @return The calculated token amount.\\n     */\\n    function tokenFromReflection(\\n        uint256 rAmount\\n    ) public view returns (uint256) {\\n        require(\\n            rAmount <= _maxMintableSupply,\\n            \\\"ACG: Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    /**\\n     * @dev Internal function to reflect the fees to the contract\\n     * @param rFee The fee to be deducted from the reflection total\\n     * @param tFee The fee to be added to the total fees available for use\\n     */\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\n        _maxMintableSupply -= rFee;\\n        totalFeesCharged += tFee;\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate and return the reflection and token values for a given token amount\\n     * @param tAmount The token amount to calculate values for\\n     * @return rAmount The reflection amount\\n     * @return rTransferAmount The reflection transfer amount\\n     * @return rFee The reflection fee amount\\n     * @return tTransferAmount The token transfer amount\\n     * @return tFee The token fee amount\\n     */\\n    function _getValues(\\n        uint256 tAmount,\\n        address recipient\\n    ) private view returns (uint256, uint256, uint256, uint256, uint256) {\\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(\\n            tAmount,\\n            recipient\\n        );\\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\\n            tAmount,\\n            tFee,\\n            _getRate()\\n        );\\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate and return the token values for a given token amount\\n     * @param tAmount The token amount to calculate values for\\n     * @return tTransferAmount The token transfer amount\\n     * @return tFee The token fee amount\\n     */\\n    function _getTValues(\\n        uint256 tAmount,\\n        address recipient\\n    ) private view returns (uint256, uint256) {\\n        uint256 tFee = _calculateFees(tAmount, recipient);\\n\\n        uint256 tTransferAmount = tAmount - tFee;\\n\\n        return (tTransferAmount, tFee);\\n    }\\n\\n    /**\\n     * @dev Internal function to calculate and return the reflection values for a given token amount\\n     * @param tAmount The token amount to calculate values for\\n     * @param tFee The token fee amount\\n     * @param currentRate The current reflection rate\\n     * @return rAmount The reflection amount equivalent to the token amount\\n     *  @return rTransferAmount The reflection amount after subtracting fee and liquidity\\n     */\\n    function _getRValues(\\n        uint256 tAmount,\\n        uint256 tFee,\\n        uint256 currentRate\\n    ) private pure returns (uint256, uint256, uint256) {\\n        uint256 rAmount = tAmount * currentRate;\\n        uint256 rFee = tFee * currentRate;\\n        uint256 rTransferAmount = rAmount - rFee;\\n        return (rAmount, rTransferAmount, rFee);\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of ERC20 tokens to be deducted as fees.\\n     * @param amount The amount of tokens to calculate fees for.\\n     * @param _fee The percentage of fees to be charged.\\n     * @return The amount of ERC20 tokens to be deducted as fees.\\n     */\\n    function _calculateERC20TokenFees(\\n        uint256 amount,\\n        uint256 _fee\\n    ) private view returns (uint256) {\\n        return (amount * _fee) / totalERC20Fees;\\n    }\\n\\n    /**\\n     * @dev Calculates the amount of liquidity tokens to be deducted as fees.\\n     * @param amount The amount of tokens to calculate fees for.\\n     * @return The amount of liquidity tokens to be deducted as fees.\\n     */\\n    function _calculateLiquidityTokenFees(\\n        uint256 amount\\n    ) private view returns (uint256) {\\n        return (amount * liquidityFee) / totalRequiredFees;\\n    }\\n\\n    /**\\n     * @dev Internal function to add the transaction fees to the contract's balance.\\n     * @param rFee The amount of reflection tokens to add to the contract's balance.\\n     */\\n    function _takeFees(uint256 rFee) private {\\n        _balances[address(this)] += rFee;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer.\\n     * This function checks the validity of the transaction parameters.\\n     * Requirements:\\n     * - from cannot be the zero address.\\n     * - to cannot be the zero address.\\n     * - amount must be greater than zero.\\n     * - If from and to are not the owner, the amount must be less than or equal to MAX_TX_AMOUNT.\\n     *\\n     * @param from The address from which the tokens are transferred.\\n     * @param to The address to which the tokens are transferred.\\n     * @param amount The amount of tokens to be transferred.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal view override {\\n        // Ensure that neither the sender nor the recipient is the zero address.\\n        require(from != address(0), \\\"ACG: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ACG: transfer to the zero address\\\");\\n        // Ensure that the transfer amount is greater than zero.\\n        require(amount > 0, \\\"ACG: transfer amount must be greater than zero\\\");\\n        // If neither the sender nor the recipient is the owner,\\n        // check that the transfer amount does not exceed the maximum allowed transaction amount.\\n        if (from != owner() && to != owner()) {\\n            require(\\n                amount <= MAX_TX_AMOUNT,\\n                \\\"ACG: transfer amount exceeds the MAX_TX_AMOUNT.\\\"\\n            );\\n        }\\n        // require(_balances[from] >= amount, \\\"ACG: Not Enough Tokens.\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to check if a user is allowed to transfer tokens.\\n     * This function checks whether the user has exceeded the maximum number of allowed sell orders within the specified time limit.\\n     * @param from The address info from which the tokens are being transferred.\\n     * @return A boolean value indicating whether the transfer is allowed or not.\\n     */\\n    function _checkCanTransfer(address from) internal view returns (bool) {\\n        // Retrieve the BotInfo struct for the sender of the transaction\\n        BotInfo memory info = botInfo[from];\\n\\n        // Calculate the required block number for the next transfer\\n        uint256 _reqLimit = info.lastTransferBlock + botSellBlockLimit;\\n\\n        // Check whether the user has exceeded the maximum number of allowed sell orders\\n        // and whether the current block number is less than the required block number\\n        return !(info.sellCount >= maxBotSellCount && block.number < _reqLimit);\\n    }\\n\\n    /**\\n     * @dev Internal function to check if the anti-bot mechanism is enabled for a particular transaction.\\n     * @param to The address of the recipient.\\n     * @param from The address of the sender.\\n     * @return A boolean indicating whether the anti-bot mechanism is enabled for the transaction.\\n     */\\n    function _checkAntibotStatus(\\n        address to,\\n        address from\\n    ) internal view returns (bool) {\\n        // Check if the anti-bot mechanism is enabled and the transaction is going to the Unisiswap V2 pair, but not coming from the contract itself\\n        return isAntiBotEnabled && to == uniswapV2Pair && from != address(this);\\n    }\\n\\n    /**\\n     * @dev Transfers tokens from sender to recipient.\\n     *\\n     * Requirements:\\n     * - If the contract's token balance is greater than or equal to swapThresholdLimit, it sets the contractTokenBalance to swapThresholdLimit and sets the overSwapThresholdLimit to true.\\n     * - If the contractTokenBalance is greater than or equal to swapThresholdLimit and isSwapAndGetFeesEnabled is true, it calls _swapAndGetFees() function.\\n     * - Sets takeFee to true initially and sets it to false only if to is not the Uniswap V2 pair or from is not the Uniswap V2 pair, indicating a stadard transfer operation respectively.\\n     * - If from or to belongs to _isExcludedFromFee, the takeFee value is set to false to remove the fee.\\n     * - Calls _tokenTransfer() function to transfer the specified amount of tokens, including the fees if takeFee is true.\\n     *\\n     * @param from Address sending the tokens.\\n     * @param to Address receiving the tokens.\\n     * @param amount Amount of tokens to transfer.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        // Check transfer requirements\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        // local boolean variable to check if the transfer is a sell order && is antiBot enabled,\\n        // using it multiple times\\n        bool antiBotStatus = _checkAntibotStatus(to, from);\\n\\n        // Check if the transfer is a sell order\\n        if (antiBotStatus) {\\n            // Check if the user has exceeded the maximum number of\\n            // allowed transfers within the specified time limit\\n            bool canTransfer = _checkCanTransfer(from);\\n\\n            // If the user has exceeded the transfer limit,\\n            // exit the function and return the tokens to the sender\\n            if (!canTransfer) {\\n                return; // Exit, potential bot activity detected.\\n            }\\n        }\\n\\n        // Get contract's token balance\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        // Check if the contract's token balance is over the swap threshold limit\\n        bool overSwapThresholdLimit = false;\\n\\n        // Set contract's token balance to MAX_TX_AMOUNT if it is greater than MAX_TX_AMOUNT\\n        if (contractTokenBalance >= swapThresholdLimit) {\\n            contractTokenBalance = swapThresholdLimit;\\n            overSwapThresholdLimit = true;\\n        }\\n\\n        // If contract's token balance is greater than or equal to the swap threshold limit,\\n        // call _swapAndGetFees() function to swap the available fees\\n        if (\\n            overSwapThresholdLimit &&\\n            !_isSwappingAndGettingFees &&\\n            from != uniswapV2Pair &&\\n            isSwapAndGetFeesEnabled\\n        ) {\\n            _swapAndGetFees(contractTokenBalance);\\n        }\\n\\n        // Indicates if fee should be deducted from transfer\\n        bool takeFee = true; // Sell or Buy\\n\\n        // indicating a standard transfer operation\\n        if (from != uniswapV2Pair && to != uniswapV2Pair) {\\n            takeFee = false; // standard transfer\\n        }\\n\\n        // If any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\\n            takeFee = false;\\n        }\\n\\n        // Transfer amount, including fees if takeFee is true\\n        _tokenTransfer(from, to, amount, takeFee, antiBotStatus);\\n    }\\n\\n    /**\\n     * @dev Private helper function that transfers tokens from the sender to the recipient, while optionally taking fees and liquidity into account.\\n     * @param sender The address of the token sender.\\n     * @param recipient The address of the token recipient.\\n     * @param amount The amount of tokens to transfer.\\n     * @param takeFee A boolean value indicating whether or not fees should be taken.\\n     * @notice This function should only be called from within the contract as it is a private function.\\n     *         The function uses the `_transferStandard`, `_removeAllFees`, and `_restoreAllFees` helper functions.\\n     *         If `takeFee` is false, then all fees are temporarily removed before the transfer and then restored afterwards.\\n     */\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee,\\n        bool antiBotStatus\\n    ) private {\\n        if (!takeFee) _removeAllFees();\\n\\n        _transferStandard(sender, recipient, amount, antiBotStatus);\\n\\n        if (!takeFee) _restoreAllFees();\\n    }\\n\\n    /**\\n     * @dev Private helper function that transfers tokens from the sender to the recipient, while taking fees and liquidity into account.\\n     * @param sender The address of the token sender.\\n     * @param recipient The address of the token recipient.\\n     * @param tAmount The amount of tokens to transfer.\\n     * @notice This function should only be called from within the contract as it is a private function.\\n     *         The function uses the `_getValues`, `_takeFees`, `_reflectBot`, and `_reflectFee` helper functions.\\n     *         The `_balances` mapping should be updated accordingly.\\n     *         Emits a `Transfer` event with the sender, recipient, and the amount of tokens transferred.\\n     */\\n    function _transferStandard(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount,\\n        bool antiBotStatus\\n    ) private {\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 rFee,\\n            uint256 tTransferAmount,\\n            uint256 tFee\\n        ) = _getValues(tAmount, recipient);\\n        _balances[sender] -= rAmount;\\n        _balances[recipient] += rTransferAmount;\\n\\n        // take fees\\n        _takeFees(rFee);\\n\\n        _reflectFee(rFee, tFee);\\n\\n        // call _reflectBot function, if it's a sell order\\n        if (antiBotStatus) {\\n            _reflectBot(sender); // update the bot status\\n        }\\n\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    /**\\n     * @dev Private helper function that updates the bot sell count for a given address if necessary.\\n     * @param sender The address of the sender.\\n     * @notice This function should only be called from within the contract as it is a private function.\\n     *         The function checks if the current block number is greater than or equal to the required limit.\\n     *         If it is, the sellCount for the sender is set to 1. If it's not, the sellCount is incremented by 1.\\n     *         The botLastTransferBlock is updated with the current block number.\\n     */\\n    function _reflectBot(address sender) private {\\n        // Retrieve the BotInfo struct for the sender of the transaction\\n        BotInfo memory info = botInfo[sender];\\n\\n        // Calculate the required limit based on the lastTransferBlock and the botSellBlockLimit\\n        uint256 _reqLimit = info.lastTransferBlock + botSellBlockLimit;\\n\\n        // Get the current block number\\n        uint256 _currentBlockNumber = block.number;\\n\\n        // Check if the current block timestamp is greater than or equal to the required limit\\n        if (_currentBlockNumber >= _reqLimit) {\\n            // If itis, set the sellCount for the sender to 1\\n            info.sellCount = 1;\\n        } else {\\n            // If it's not, increment the sellCount for the sender by 1\\n            info.sellCount++;\\n        }\\n\\n        // Update the lastTransferBlock with the current block number\\n        info.lastTransferBlock = _currentBlockNumber;\\n\\n        // Update the botInfo mapping\\n        botInfo[sender] = info;\\n    }\\n\\n    /**\\n     * @dev Swaps the contract's token balance for BUSD/USDT/... and transfers the resulting fees to the respective wallets.\\n     * @param contractTokenBalance The amount of tokens in the contract's balance to swap and collect fees for.\\n     * @notice This function should only be called from within the contract as it is a private function.\\n     *         The `liquidityFee` value should be greater than 0 in order for the function to swap and liquify tokens.\\n     *         The `erc20TokenFeeAddress` contract should be a valid ERC20 token contract address.\\n     *         The function uses the `_calculateLiquidityTokenFees`, `_swapAndLiquify`, `_swapTokensForTokens`, and `_calculateAvailableFeesAndTransfer` helper functions.\\n     *         Emits a `SwapAndGetFees` event with the amount of tokens swapped and the resulting fees transferred.\\n     */\\n    function _swapAndGetFees(uint256 contractTokenBalance) private lockTheSwap {\\n        uint256 availableAmount = contractTokenBalance;\\n\\n        if (liquidityFee > 0) {\\n            uint256 liquidityAmount = _calculateLiquidityTokenFees(\\n                contractTokenBalance\\n            );\\n\\n            // for adding liquidity to pools\\n            _swapAndLiquify(liquidityAmount);\\n\\n            availableAmount = contractTokenBalance - liquidityAmount;\\n        }\\n\\n        // swap tokens for BUSD/USDT/...\\n        _swapTokensForTokens(availableAmount, erc20TokenFeeAddress);\\n\\n        // how much BUSD/USDT/... we just swapped\\n        uint256 newBalance = IERC20(erc20TokenFeeAddress).balanceOf(\\n            address(this)\\n        );\\n\\n        _calculateAvailableFeesAndTransfer(newBalance);\\n\\n        emit SwapAndGetFees(contractTokenBalance, newBalance, availableAmount);\\n    }\\n\\n    /**\\n     * @dev Private helper function that swaps the specified amount of tokens for BNB, and adds the resulting liquidity to the liquidity pool.\\n     * @param liquidityAmount The amount of tokens to swap and add to the liquidity pool.\\n     * @notice This function should only be called from within the contract as it is a private function.\\n     *         The function splits the liquidity amount into two halves.\\n     *         The first half is swapped for BNB using the `_swapTokensForBnb` helper function.\\n     *         The second half is added to the liquidity pool using the `_addLiquidity` helper function.\\n     *         Emits a `SwapAndLiquify` event with the liquidity amount, the new BNB balance, and the amount of tokens added to the liquidity pool.\\n     */\\n    function _swapAndLiquify(uint256 liquidityAmount) private {\\n        // Split the liquidity amount into two halves\\n        uint256 half = liquidityAmount / 2;\\n        uint256 otherHalf = liquidityAmount - half;\\n\\n        // check pair and return the balance\\n        uint256 newBalance = _checkPoolAndSwapAndAddLiquidity(half, otherHalf);\\n\\n        // Emit a `SwapAndLiquify` event with the liquidity amount, the new BNB/USDT... balance,\\n        // and the amount of tokens added to the liquidity pool\\n        emit SwapAndLiquify(liquidityAmount, newBalance, otherHalf);\\n    }\\n\\n    /**\\n     * @dev Checks if the Uniswap V2 router has sufficient allowance to spend a specified amount of tokens\\n     * on behalf of the contract.\\n     * @param tokenAddress The address of the token to be checked for allowance.\\n     * @param amount The amount of tokens to be checked for allowance.\\n     * @return A boolean indicating whether the Uniswap V2 router has sufficient allowance\\n     * to spend the specified amount of tokens on behalf of the contract.\\n     */\\n    function _checkRouterTokenAllowance(\\n        address tokenAddress,\\n        uint256 amount\\n    ) internal view returns (bool) {\\n        // Get the allowance for the Uniswap V2 router to spend the specified\\n        // amount of tokens on behalf of the contract.\\n        uint256 routerAllowance = IERC20(tokenAddress).allowance(\\n            address(this),\\n            address(uniswapV2Router)\\n        );\\n\\n        // Check if the allowance is greater than or equal to the specified amount of tokens.\\n        return routerAllowance >= amount;\\n    }\\n\\n    /**\\n     * @dev Checks which ERC20 token to use for swapping based on the selected liquidity pool\\n     * and the Uniswap V2 router's allowance to spend the specified amount of tokens on behalf of the contract.\\n     * @param half The amount of ACG tokens to be swapped for the other ERC20 token.\\n     * @return The address of the ERC20 token to be used for swapping,\\n     * or address(0) if there is no token available for swapping.\\n     */\\n    function _checkRouterAllowanceAndGetToken(\\n        uint256 half\\n    ) internal view returns (address) {\\n        // Initialize the ERC20 token address to address(0).\\n        address tokenAddress = address(0);\\n\\n        // Check if the selected liquidity pool is 1 (ACG/USDT pool)\\n        // and the Uniswap V2 router has sufficient allowance to spend USDT tokens on behalf of the contract.\\n        if (\\n            liquidityPoolToUse == 1 &&\\n            usdtAddress != address(0) &&\\n            _checkRouterTokenAllowance(usdtAddress, half)\\n        ) {\\n            // Set the ERC20 token address to the USDT token address.\\n            tokenAddress = usdtAddress;\\n        } else if (\\n            // Check if the selected liquidity pool is 2 (ACG/Special Token pool)\\n            // and the Uniswap V2 router has sufficient allowance to spend the special\\n            // token on behalf of the contract.\\n            liquidityPoolToUse == 2 &&\\n            specialAddress != address(0) &&\\n            _checkRouterTokenAllowance(specialAddress, half)\\n        ) {\\n            // Set the ERC20 token address to the special token address.\\n            tokenAddress = specialAddress;\\n        }\\n\\n        // Return the ERC20 token address to be used for swapping,\\n        // or address(0) if no token is available for swapping.\\n        return tokenAddress;\\n    }\\n\\n    /**\\n     * @dev Checks the selected liquidity pool and performs a token swap and liquidity addition if possible, or a token swap to BNB and liquidity addition if not.\\n     * @param half The amount of ACG tokens to be swapped for the other ERC20 token or BNB.\\n     * @param otherHalf The amount of the other ERC20 token or BNB to be added to the liquidity pool.\\n     * @return The new balance of the contract after the token swap and liquidity addition.\\n     */\\n    function _checkPoolAndSwapAndAddLiquidity(\\n        uint256 half,\\n        uint256 otherHalf\\n    ) private returns (uint256) {\\n        // Initialize the new balance to 0.\\n        uint256 newBalance;\\n\\n        // Check the selected liquidity pool and get the ERC20 token to be used for swapping and liquidity addition.\\n        address tokenAddress = _checkRouterAllowanceAndGetToken(half);\\n\\n        // If a liquidity pool is selected and the ERC20 token is available,\\n        // perform a token swap and liquidity addition to the ERC20 pool.\\n        if (liquidityPoolToUse != 0 && tokenAddress != address(0)) {\\n            newBalance = _swapAndAddLiquidityToERC20Pool(\\n                half,\\n                otherHalf,\\n                tokenAddress\\n            );\\n        } else {\\n            // If a liquidity pool is not selected or the ERC20 token is not available,\\n            // perform a token swap to BNB and liquidity addition to the BNB pool.\\n            _swapTokensForBnb(half);\\n            newBalance = address(this).balance;\\n\\n            _addLiquidity(otherHalf, newBalance);\\n        }\\n\\n        // Return the new balance of the contract after the token swap and liquidity addition.\\n        return newBalance;\\n    }\\n\\n    /**\\n     * @dev Swaps half of the ACG tokens for another ERC20 token,\\n     * then adds liquidity to the Uniswap V2 pool by providing the swapped tokens and the remaining ACG tokens.\\n     * @param half The amount of ACG tokens to be swapped for the other ERC20 token.\\n     * @param otherHalf The amount of ACG tokens to be added to the Uniswap V2 pool.\\n     * @param tokenAddress The address of the ERC20 token to be swapped for ACG tokens.\\n     * @return The new balance of the ERC20 token in the contract's balance.\\n     */\\n    function _swapAndAddLiquidityToERC20Pool(\\n        uint256 half,\\n        uint256 otherHalf,\\n        address tokenAddress\\n    ) private returns (uint256) {\\n        // Swap half of the ACG tokens for the other ERC20 token.\\n        _swapTokensForTokens(half, tokenAddress);\\n\\n        // Get the new balance of the other ERC20 token in the contract's balance.\\n        uint256 newBalance = IERC20(tokenAddress).balanceOf(address(this));\\n\\n        // Add liquidity to the Uniswap V2 pool by providing the swapped tokens and the remaining ACG tokens.\\n        _addLiquidityToERC20Pool(otherHalf, newBalance, tokenAddress);\\n\\n        // Return the new balance of the other ERC20 token in the contract's balance.\\n        return newBalance;\\n    }\\n\\n    /**\\n     * @dev Adds liquidity to the Uniswap V2 pool by providing an amount of ACG tokens and an amount of another ERC20 token.\\n     * @param acgAmount The amount of ACG tokens to be added to the pool.\\n     * @param tokenAmount The amount of the other ERC20 token to be added to the pool.\\n     * @param tokenAddress The address of the ERC20 token to be added to the pool.\\n     */\\n    function _addLiquidityToERC20Pool(\\n        uint256 acgAmount,\\n        uint256 tokenAmount,\\n        address tokenAddress\\n    ) private {\\n        // Approve the Uniswap V2 router to spend ACG tokens on behalf of the contract.\\n        _approve(address(this), address(uniswapV2Router), acgAmount);\\n\\n        // Add liquidity to the Uniswap V2 pool by providing the ACG token address, the address of the other ERC20 token, and the amounts of tokens to be added.\\n        uniswapV2Router.addLiquidity(\\n            address(this),\\n            tokenAddress,\\n            acgAmount,\\n            tokenAmount,\\n            0,\\n            0,\\n            owner(),\\n            block.timestamp + 3000\\n        );\\n    }\\n\\n    /**\\n     * @dev Calculates the fees to be deducted and transfers them to their respective wallets.\\n     * @param totalAmount The total amount of tokens to calculate fees for.\\n     */\\n    function _calculateAvailableFeesAndTransfer(uint256 totalAmount) private {\\n        // Calculate the amount of fees to be transferred to each wallet\\n        uint256 operationAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            operationFee\\n        );\\n        uint256 marketingAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            marketingFee\\n        );\\n        uint256 poolsLeaderboardAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            poolsLeaderboardFee\\n        );\\n        uint256 communityAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            communityFee\\n        );\\n        uint256 treasuryOneAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            treasuryOneFee\\n        );\\n        uint256 treasuryTwoAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            treasuryTwoFee\\n        );\\n        uint256 penaltyAmount = _calculateERC20TokenFees(\\n            totalAmount,\\n            penaltyFee\\n        );\\n\\n        // Transfer tokens to each wallet\\n        _transferFeesToWallet(operationWallet, operationAmount);\\n        _transferFeesToWallet(marketingWallet, marketingAmount);\\n        _transferFeesToWallet(poolsLeaderboardWallet, poolsLeaderboardAmount);\\n        _transferFeesToWallet(communityWallet, communityAmount);\\n        _transferFeesToWallet(treasuryOneWallet, treasuryOneAmount);\\n        _transferFeesToWallet(treasuryTwoWallet, treasuryTwoAmount);\\n        _transferFeesToWallet(penaltyWallet, penaltyAmount);\\n\\n        emit SendFeesToWallets(\\n            operationAmount,\\n            marketingAmount,\\n            poolsLeaderboardAmount,\\n            communityAmount,\\n            treasuryOneAmount,\\n            treasuryTwoAmount,\\n            penaltyAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers the given amount of tokens from the `erc20TokenFeeAddress` contract to the specified wallet address.\\n     * @param _wallet The address of the wallet to transfer tokens to.\\n     * @param amount The amount of tokens to transfer.\\n     * @notice This function should only be called from within the contract as it is a private function.\\n     *         Also, the `erc20TokenFeeAddress` contract should be a valid ERC20 token contract address.\\n     *         The tokens transferred through this function are intended to be used as fees for the contract's services.\\n     */\\n    function _transferFeesToWallet(address _wallet, uint256 amount) private {\\n        IERC20(erc20TokenFeeAddress).safeTransfer(_wallet, amount);\\n    }\\n\\n    /**\\n     * @dev Function to swap ERC20 tokens for BNB using the UniswapV2Router02\\n     * @param tokenAmount The amount of ERC20 tokens to be swapped for BNB\\n     * Effects:\\n     * Approves the specified tokenAmount to be spent by the UniswapV2Router02 contract\\n     * Swaps the specified tokenAmount of ERC20 tokens for BNB\\n     */\\n    function _swapTokensForBnb(uint256 tokenAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH(); // BNB\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of BNB\\n            path,\\n            address(this), // address(uniswapV2Pair)\\n            block.timestamp + 3000\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to add liquidity to Pancake for this ERC20 token and WBNB\\n     * @param tokenAmount The amount of ERC20 tokens to add to the liquidity pool\\n     * @param ethAmount The amount of WBNB to add to the liquidity pool\\n     * Effects:\\n     * Approves the specified tokenAmount to be spent by the UniswapV2Router02 contract\\n     * Adds the specified tokenAmount of ERC20 tokens and ethAmount of WBNB to the Pancake liquidity pool\\n     * Sends the liquidity pool tokens to the contract owner\\n     */\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            owner(),\\n            block.timestamp + 3000\\n        );\\n    }\\n\\n    /**\\n     * @dev Function to swap ERC20 tokens for another ERC20 token using the UniswapV2Router02\\n     * @param tokenAmount The amount of ERC20 tokens to be swapped for another ERC20 token\\n     * Effects:\\n     * Approves the specified tokenAmount to be spent by the UniswapV2Router02 contract\\n     * Swaps the specified tokenAmount of ERC20 tokens for another ERC20 token that has the erc20TokenFeeAddress\\n     */\\n    function _swapTokensForTokens(\\n        uint256 tokenAmount,\\n        address tokenAddress\\n    ) private {\\n        address[] memory path = new address[](3);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        path[2] = address(tokenAddress);\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp + 3000\\n        );\\n    }\\n\\n    /* Helper functions */\\n\\n    /**\\n     * @dev Function to manually swap BNB tokens for ETH\\n     * @param amount The amount of BNB tokens to be swapped for ETH\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The specified amount must be less than or equal to the swap threshold limit\\n     * The contract balance must be greater than or equal to the amout requested\\n     * Effects:\\n     * Swaps the specified amount of BNB tokens for ETH\\n     */\\n    function manualBNBSwap(uint256 amount) external onlyOwner {\\n        require(\\n            amount <= swapThresholdLimit,\\n            \\\"ACG: Amount should be less than or equal to swap threshold limit\\\"\\n        );\\n        uint256 balance = balanceOf(address(this));\\n        require(\\n            balance >= amount,\\n            \\\"ACG: Contract balance is less than the amout requested\\\"\\n        );\\n\\n        _swapTokensForBnb(amount);\\n\\n        emit ManualBNBSwap(amount);\\n    } // need a check\\n\\n    /**\\n     * @dev Function to manually swap tokens for ERC20 and get fees\\n     * @param amount The amount of tokens to be swapped for ERC20 and to get fees\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The specified amount must be less than or equal to the swap threshold limit\\n     * The contract balance must be greater than or equal to the amout requested\\n     * Effects:\\n     * Swaps the specified amount of tokens for ERC20 and gets fees\\n     * Deducts the specified amount from the total fees available\\n     */\\n    function manualERC20Swap(uint256 amount) external onlyOwner lockTheSwap {\\n        require(\\n            amount <= swapThresholdLimit,\\n            \\\"ACG: Amount should be less than or equal to swap threshold limit\\\"\\n        );\\n        uint256 balance = balanceOf(address(this));\\n        require(\\n            balance >= amount,\\n            \\\"ACG: Contract balance is less than the amout requested\\\"\\n        );\\n        _swapAndGetFees(amount);\\n\\n        emit ManualErc20Swap(amount);\\n    }\\n\\n    /**\\n     * @dev Function to automatically swap tokens for ERC20 and get fees\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The contract balance must be greater than or equal to the swap threshold limit\\n     * Effects:\\n     * Swaps the total fees available of tokens for ERC20 and gets fees\\n     * Deducts the previous total fees available from the new total fees available\\n     */\\n    function autoERC20Swap() external onlyOwner {\\n        uint256 balance = balanceOf(address(this));\\n        require(\\n            balance >= swapThresholdLimit,\\n            \\\"ACG: Contract balance is less than swap threshold limit\\\"\\n        );\\n\\n        balance = swapThresholdLimit;\\n\\n        _swapAndGetFees(balance);\\n\\n        emit AutoErc20Swap(balance);\\n    }\\n\\n    /**\\n     * @dev Function to recover BNB from the contract to the owner address\\n     * @param amount The amount of BNB to be recovered\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The contract must have a balance equal to or greater than the amount to be recovered\\n     * Effects:\\n     * Transfers the specified amount of BNB to the owner address\\n     */\\n    function recoverBNB(uint256 amount) external onlyOwner {\\n        uint256 balance = address(this).balance;\\n        require(\\n            balance >= amount,\\n            \\\"ACG: Cannot recover more than the available balance\\\"\\n        );\\n        payable(owner()).transfer(amount);\\n\\n        emit RecoverContractBNB(amount);\\n    }\\n\\n    /**\\n     * @dev Function to recover BNB from the contract to a specified wallet address\\n     * @param to The wallet address to which BNB will be transferred\\n     * @param amount The amount of BNB to be recovered\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The contract must have a balance equal to or greater than the amount to be recovered\\n     * Effects:\\n     * Transfers the specified amount of BNB to the specified wallet address\\n     */\\n    function recoverBNBToWallet(address to, uint256 amount) external onlyOwner {\\n        require(to != address(0), \\\"ACG: transfer to the zero address\\\");\\n        uint256 balance = address(this).balance;\\n        require(\\n            balance >= amount,\\n            \\\"ACG: Cannot recover more than the available balance\\\"\\n        );\\n        payable(to).transfer(amount);\\n\\n        emit RecoverContractBNB(amount);\\n    }\\n\\n    /**\\n     * @dev Function to recover ERC20 tokens from the contract to the owner address\\n     * @param token The address of the ERC20 token to be recovered\\n     * @param amount The amount of ERC20 tokens to be recovered\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The contract must have a balance of at least amount of the specified ERC20 token\\n     * Effects:\\n     * Transfers the specified amount of the specified ERC20 token to the owner address\\n     */\\n    function recoverERC20Tokens(\\n        address token,\\n        uint256 amount\\n    ) external onlyOwner {\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(\\n            balance >= amount,\\n            \\\"ACG: Cannot recover more than available balance\\\"\\n        );\\n        IERC20(token).safeTransfer(owner(), amount);\\n\\n        emit RecoverErc20TokensToOwner(token, amount);\\n    }\\n\\n    /**\\n     * @dev Function to recover ERC20 tokens from the contract to a specified wallet address\\n     * @param token The address of the ERC20 token to be recovered\\n     * @param to The wallet address to which the ERC20 tokens will be transferred\\n     * @param amount The amount of ERC20 tokens to be recovered\\n     * Requirements:\\n     * Only the contract owner can call this function\\n     * The to address must not be the zero address\\n     * The contract must have a balance of at least amount of the specified ERC20 token\\n     * Effects:\\n     * Transfers the specified amount of the specified ERC20 token to the specified wallet address\\n     */\\n    function recoverERC20TokensToWallet(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner {\\n        require(to != address(0), \\\"ACG: transfer to the zero address\\\");\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(\\n            balance >= amount,\\n            \\\"ACG: Cannot recover more than available balance\\\"\\n        );\\n        IERC20(token).safeTransfer(to, amount);\\n\\n        emit RecoverErc20TokensTAddress(token, amount, to);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\r\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\r\\n *\\r\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\r\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\r\\n * need to send a transaction, and thus is not required to hold Ether at all.\\r\\n */\\r\\ninterface IERC20Permit {\\r\\n    /**\\r\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\r\\n     * given ``owner``'s signed approval.\\r\\n     *\\r\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\r\\n     * ordering also apply here.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `deadline` must be a timestamp in the future.\\r\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\r\\n     * over the EIP712-formatted function arguments.\\r\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\r\\n     *\\r\\n     * For more information on the signature format, see the\\r\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\r\\n     * section].\\r\\n     */\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current nonce for `owner`. This value must be\\r\\n     * included whenever a signature is generated for {permit}.\\r\\n     *\\r\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\r\\n     * prevents a signature from being used multiple times.\\r\\n     */\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\"\r\n    },\r\n    \"/contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./extensions/IERC20Permit.sol\\\";\\r\\nimport \\\"../../utils/Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\r\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Deprecated. This function has issues similar to the ones found in\\r\\n     * {IERC20-approve}, and its usage is discouraged.\\r\\n     *\\r\\n     * Whenever possible, use {safeIncreaseAllowance} and\\r\\n     * {safeDecreaseAllowance} instead.\\r\\n     */\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful.\\r\\n     */\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        unchecked {\\r\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\r\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\r\\n     * 0 before setting it to a non-zero value.\\r\\n     */\\r\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\r\\n\\r\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\r\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\r\\n            _callOptionalReturn(token, approvalCall);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\r\\n     * Revert on invalid signature.\\r\\n     */\\r\\n    function safePermit(\\r\\n        IERC20Permit token,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal {\\r\\n        uint256 nonceBefore = token.nonces(owner);\\r\\n        token.permit(owner, spender, value, deadline, v, r, s);\\r\\n        uint256 nonceAfter = token.nonces(owner);\\r\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\r\\n        // the target address contains contract code and also asserts for success in the low-level call.\\r\\n\\r\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     *\\r\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\r\\n     */\\r\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\r\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\r\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\r\\n        // and not revert is the subcall reverts.\\r\\n\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        return\\r\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner - Disabled.\\n     */\\n    // function renounceOwnership() public virtual onlyOwner {\\n    //     _transferOwnership(address(0));\\n    // }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApproveRouterToSpendTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AutoErc20Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeAddressFromFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeAddressInFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"ManualBNBSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"ManualErc20Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeWallet\",\"type\":\"address\"}],\"name\":\"NewFeeWAllet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbAmount\",\"type\":\"uint256\"}],\"name\":\"RecoverContractBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"RecoverErc20TokensTAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"RecoverErc20TokensToOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"operationAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolsLeaderboardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"communityAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasuryOneAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasuryTwoAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"SendFeesToWallets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"SetAntiBotStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBotSellTime\",\"type\":\"uint256\"}],\"name\":\"SetNewBotSellTime\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newErc20TokenAddress\",\"type\":\"address\"}],\"name\":\"SetNewErc20TokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBuySellFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalRequiredFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newErc20Fees\",\"type\":\"uint256\"}],\"name\":\"SetNewFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidityPool\",\"type\":\"uint256\"}],\"name\":\"SetNewLiquidityPoolToUse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxBotLimit\",\"type\":\"uint256\"}],\"name\":\"SetNewMaxBoxSellCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPenaltyFe\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotalRequiredFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newErc20Fees\",\"type\":\"uint256\"}],\"name\":\"SetNewPenaltyFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPenaltyLimit\",\"type\":\"uint256\"}],\"name\":\"SetNewPenaltyTxAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SetNewSpecialAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPairAddress\",\"type\":\"address\"}],\"name\":\"SetNewSwapRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThresholdLimit\",\"type\":\"uint256\"}],\"name\":\"SetNewSwapThresholdLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SetNewUSDTAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractTokenBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"availableAmount\",\"type\":\"uint256\"}],\"name\":\"SwapAndGetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TX_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveRouterToSpendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoERC20Swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"botInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTransferBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botSellBlockLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20TokenFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBNBBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getErc20TokenFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getErc20TokensBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAntiBotEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapAndGetFeesEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPoolToUse\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualBNBSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manualERC20Swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBotSellCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsLeaderboardFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsLeaderboardWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverBNBToWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20TokensToWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"setAntiBotStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setBotSellTimeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setCommunityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setCommunityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setErc20TokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidityPool\",\"type\":\"uint256\"}],\"name\":\"setLiquidityPoolToUse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setMarketingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCount\",\"type\":\"uint256\"}],\"name\":\"setMaxBotSellCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setOperationFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setOperationWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setPenaltyFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setPenaltyTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setPenaltyWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setPoolsLeaderboardFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setPoolsLeaderboardWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setSpecialAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"setSwapThresholdLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setTreasuryOneFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setTreasuryOneWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setTreasuryTwoFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setTreasuryTwoWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setUSDTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThresholdLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalERC20Fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeesCharged\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequiredBuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequiredFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRequiredSellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryOneFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryOneWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryTwoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryTwoWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ACG", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}