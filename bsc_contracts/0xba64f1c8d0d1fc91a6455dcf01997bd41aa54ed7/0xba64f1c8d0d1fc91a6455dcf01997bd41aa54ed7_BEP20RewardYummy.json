{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Initializable {\r\n\r\n    bool private _initialized;\r\n\r\n    bool private _initializing;\r\n\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract BEP20RewardYummy is Ownable, Initializable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount;     // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IERC20 lpToken;           // Address of LP token contract.\r\n        uint256 allocPoint;       // How many allocation points assigned to this pool. Rewards to distribute per block.\r\n        uint256 lastRewardBlock;  // Last block number that Rewards distribution occurs.\r\n        uint256 accRewardTokenPerShare; // Accumulated Rewards per share, times 1e30. See below.\r\n    }\r\n\r\n    // The stake token\r\n    IERC20 public STAKE_TOKEN;\r\n    // The reward token\r\n    IERC20 public REWARD_TOKEN;\r\n\r\n    // Reward tokens created per block.\r\n    uint256 public rewardPerBlock;\r\n\r\n    // Keep track of number of tokens staked in case the contract earns reflect fees\r\n    uint256 public totalStaked = 0;\r\n\r\n    // Info of each pool.\r\n    PoolInfo public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping (address => UserInfo) public userInfo;\r\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n    uint256 private totalAllocPoint = 0;\r\n    // The block number when Reward mining starts.\r\n    uint256 public startBlock;\r\n\t// The block number when mining ends.\r\n    uint256 public bonusEndBlock;\r\n\r\n    event Deposit(address indexed user, uint256 amount);\r\n    event DepositRewards(uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event EmergencyWithdraw(address indexed user, uint256 amount);\r\n    event SkimStakeTokenFees(address indexed user, uint256 amount);\r\n    event LogUpdatePool(uint256 bonusEndBlock, uint256 rewardPerBlock);\r\n    event EmergencyRewardWithdraw(address indexed user, uint256 amount);\r\n    event EmergencySweepWithdraw(address indexed user, IERC20 indexed token, uint256 amount);\r\n\r\n    function initialize(\r\n        IERC20 _stakeToken,\r\n        IERC20 _rewardToken,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _startBlock,\r\n        uint256 _bonusEndBlock\r\n    ) external initializer\r\n    {\r\n        STAKE_TOKEN = _stakeToken;\r\n        REWARD_TOKEN = _rewardToken;\r\n        rewardPerBlock = _rewardPerBlock;\r\n        startBlock = _startBlock;\r\n        bonusEndBlock = _bonusEndBlock;\r\n\r\n        // staking pool\r\n        poolInfo = PoolInfo({\r\n            lpToken: _stakeToken,\r\n            allocPoint: 1000,\r\n            lastRewardBlock: startBlock,\r\n            accRewardTokenPerShare: 0\r\n        });\r\n\r\n        totalAllocPoint = 1000;\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\r\n        if (_to <= bonusEndBlock) {\r\n            return _to - _from;\r\n        } else if (_from >= bonusEndBlock) {\r\n            return 0;\r\n        } else {\r\n            return bonusEndBlock - _from;\r\n        }\r\n    }\r\n\r\n    /// @param  _bonusEndBlock The block when rewards will end\r\n    function setBonusEndBlock(uint256 _bonusEndBlock) external onlyOwner {\r\n        require(_bonusEndBlock > bonusEndBlock, 'new bonus end block must be greater than current');\r\n        bonusEndBlock = _bonusEndBlock;\r\n        emit LogUpdatePool(bonusEndBlock, rewardPerBlock);\r\n    }\r\n\r\n    // View function to see pending Reward on frontend.\r\n    function pendingReward(address _user) external view returns (uint256) {\r\n        UserInfo storage user = userInfo[_user];\r\n        uint256 accRewardTokenPerShare = poolInfo.accRewardTokenPerShare;\r\n        if (block.number > poolInfo.lastRewardBlock && totalStaked != 0) {\r\n            uint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\r\n            uint256 tokenReward = multiplier * rewardPerBlock * poolInfo.allocPoint / totalAllocPoint;\r\n            accRewardTokenPerShare = accRewardTokenPerShare + (tokenReward * 1e30 / totalStaked);\r\n        }\r\n        return user.amount * accRewardTokenPerShare / 1e30 - user.rewardDebt;\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool() public {\r\n        if (block.number <= poolInfo.lastRewardBlock) {\r\n            return;\r\n        }\r\n        if (totalStaked == 0) {\r\n            poolInfo.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\r\n        uint256 tokenReward = multiplier * rewardPerBlock * poolInfo.allocPoint / totalAllocPoint;\r\n        poolInfo.accRewardTokenPerShare = poolInfo.accRewardTokenPerShare + (tokenReward * 1e30 / totalStaked);\r\n        poolInfo.lastRewardBlock = block.number;\r\n    }\r\n\r\n\r\n    /// Deposit staking token into the contract to earn rewards.\r\n    /// @dev Since this contract needs to be supplied with rewards we are\r\n    ///  sending the balance of the contract if the pending rewards are higher\r\n    /// @param _amount The amount of staking tokens to deposit\r\n    function deposit(uint256 _amount) public nonReentrant {\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        uint256 finalDepositAmount = 0;\r\n        updatePool();\r\n        if (user.amount > 0) {\r\n            uint256 pending = user.amount * poolInfo.accRewardTokenPerShare / 1e30 - user.rewardDebt;\r\n            if(pending > 0) {\r\n                uint256 currentRewardBalance = rewardBalance();\r\n                if(currentRewardBalance > 0) {\r\n                    if(pending > currentRewardBalance) {\r\n                        safeTransferReward(address(msg.sender), currentRewardBalance);\r\n                    } else {\r\n                        safeTransferReward(address(msg.sender), pending);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            uint256 preStakeBalance = STAKE_TOKEN.balanceOf(address(this));\r\n            poolInfo.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n            finalDepositAmount = STAKE_TOKEN.balanceOf(address(this)) - preStakeBalance;\r\n            user.amount = user.amount + finalDepositAmount;\r\n            totalStaked = totalStaked + finalDepositAmount;\r\n        }\r\n        user.rewardDebt = user.amount * poolInfo.accRewardTokenPerShare / 1e30;\r\n\r\n        emit Deposit(msg.sender, finalDepositAmount);\r\n    }\r\n\r\n    /// Withdraw rewards and/or staked tokens. Pass a 0 amount to withdraw only rewards\r\n    /// @param _amount The amount of staking tokens to withdraw\r\n    function withdraw(uint256 _amount) public nonReentrant{\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool();\r\n        uint256 pending = user.amount * poolInfo.accRewardTokenPerShare / 1e30 - user.rewardDebt;\r\n        if(pending > 0) {\r\n            uint256 currentRewardBalance = rewardBalance();\r\n            if(currentRewardBalance > 0) {\r\n                if(pending > currentRewardBalance) {\r\n                    safeTransferReward(address(msg.sender), currentRewardBalance);\r\n                } else {\r\n                    safeTransferReward(address(msg.sender), pending);\r\n                }\r\n            }\r\n        }\r\n        if(_amount > 0) {\r\n            user.amount = user.amount - _amount;\r\n            poolInfo.lpToken.safeTransfer(address(msg.sender), _amount);\r\n            totalStaked = totalStaked - _amount;\r\n        }\r\n\r\n        user.rewardDebt = user.amount * poolInfo.accRewardTokenPerShare / 1e30;\r\n\r\n        emit Withdraw(msg.sender, _amount);\r\n    }\r\n\r\n    /// Obtain the reward balance of this contract\r\n    /// @return wei balace of conract\r\n    function rewardBalance() public view returns (uint256) {\r\n        uint256 balance = REWARD_TOKEN.balanceOf(address(this));\r\n        if (STAKE_TOKEN == REWARD_TOKEN)\r\n            return balance - totalStaked;\r\n        return balance;\r\n    }\r\n\r\n    // Deposit Rewards into contract\r\n    function depositRewards(uint256 _amount) external {\r\n        require(_amount > 0, 'Deposit value must be greater than 0.');\r\n        REWARD_TOKEN.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n        emit DepositRewards(_amount);\r\n    }\r\n\r\n    /// @param _to address to send reward token to\r\n    /// @param _amount value of reward token to transfer\r\n    function safeTransferReward(address _to, uint256 _amount) internal {\r\n        REWARD_TOKEN.safeTransfer(_to, _amount);\r\n    }\r\n\r\n    /// @dev Obtain the stake balance of this contract\r\n    function totalStakeTokenBalance() public view returns (uint256) {\r\n        if (STAKE_TOKEN == REWARD_TOKEN)\r\n            return totalStaked;\r\n        return STAKE_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Obtain the stake token fees (if any) earned by reflect token\r\n    function getStakeTokenFeeBalance() public view returns (uint256) {\r\n        return STAKE_TOKEN.balanceOf(address(this)) - totalStaked;\r\n    }\r\n\r\n    /* Admin Functions */\r\n\r\n    /// @param _rewardPerBlock The amount of reward tokens to be given per block\r\n    function setRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner {\r\n        rewardPerBlock = _rewardPerBlock;\r\n        emit LogUpdatePool(bonusEndBlock, rewardPerBlock);\r\n    }\r\n\r\n        /// @dev Remove excess stake tokens earned by reflect fees\r\n    function skimStakeTokenFees() external onlyOwner {\r\n        uint256 stakeTokenFeeBalance = getStakeTokenFeeBalance();\r\n        STAKE_TOKEN.safeTransfer(msg.sender, stakeTokenFeeBalance);\r\n        emit SkimStakeTokenFees(msg.sender, stakeTokenFeeBalance);\r\n    }\r\n\r\n    /* Emergency Functions */\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw() external nonReentrant{\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        poolInfo.lpToken.safeTransfer(address(msg.sender), user.amount);\r\n        totalStaked = totalStaked - user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        emit EmergencyWithdraw(msg.sender, user.amount);\r\n    }\r\n\r\n    // Withdraw reward. EMERGENCY ONLY.\r\n    function emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\r\n        require(_amount <= rewardBalance(), 'not enough rewards');\r\n        // Withdraw rewards\r\n        safeTransferReward(address(msg.sender), _amount);\r\n        emit EmergencyRewardWithdraw(msg.sender, _amount);\r\n    }\r\n\r\n    /// @notice A public function to sweep accidental BEP20 transfers to this contract.\r\n    ///   Tokens are sent to owner\r\n    /// @param token The address of the BEP20 token to sweep\r\n    function sweepToken(IERC20 token) external onlyOwner {\r\n        require(address(token) != address(STAKE_TOKEN), \"can not sweep stake token\");\r\n        uint256 balance = token.balanceOf(address(this));\r\n        token.transfer(msg.sender, balance);\r\n        emit EmergencySweepWithdraw(msg.sender, token, balance);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract YummyFactory {\r\n  address public defaultOwner;\r\n\r\n  event DeployedPoolContract(\r\n      address indexed pool,\r\n      address stakeToken,\r\n      address rewardToken,\r\n      uint256 rewardPerBlock,\r\n      uint256 startBlock,\r\n      uint256 bonusEndBlock,\r\n      address owner);\r\n\r\n  constructor (address _defaultOwner) {\r\n    defaultOwner = _defaultOwner;\r\n  }\r\n\r\n  function deployDefaultPoolContract(\r\n        IERC20 _stakeToken,\r\n        IERC20 _rewardToken,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _startBlock,\r\n        uint256 _bonusEndBlock) public {\r\n    deployPoolContract(_stakeToken, _rewardToken, _rewardPerBlock, _startBlock, _bonusEndBlock, defaultOwner);\r\n  }\r\n\r\n  function deployPoolContract(\r\n        IERC20 _stakeToken,\r\n        IERC20 _rewardToken,\r\n        uint256 _rewardPerBlock,\r\n        uint256 _startBlock,\r\n        uint256 _bonusEndBlock,\r\n        address _owner) public {\r\n    BEP20RewardYummy pool = new BEP20RewardYummy();\r\n\r\n    pool.initialize(_stakeToken, _rewardToken, _rewardPerBlock, _startBlock, _bonusEndBlock);\r\n\r\n    pool.transferOwnership(_owner);\r\n\r\n    emit DeployedPoolContract(address(pool), address(_stakeToken), address(_rewardToken), _rewardPerBlock, _startBlock, _bonusEndBlock, _owner);\r\n  }\r\n\r\n  function deployComputedPoolContract(\r\n        IERC20 _stakeToken,\r\n        IERC20 _rewardToken,\r\n        uint256 _startBlock,\r\n        uint256 _blocksDuration,\r\n        uint256 _totalRewards,\r\n        address _owner) public {\r\n    (uint256 rewardPerBlock, uint256 bonusEndBlock) = calculatedConfig(_totalRewards, _startBlock, _blocksDuration);\r\n    deployPoolContract(_stakeToken, _rewardToken, rewardPerBlock, _startBlock, bonusEndBlock, _owner);\r\n  }\r\n\r\n  function calculatedConfig(\r\n    uint256 _totalRewards,\r\n    uint256 _startBlock,\r\n    uint256 _blocksDuration) public pure returns (uint256 rewardsPerBlock, uint256 bonusEndBlock) {\r\n\r\n    rewardsPerBlock = _totalRewards / _blocksDuration;\r\n    bonusEndBlock = _startBlock + _blocksDuration;\r\n\r\n    return (rewardsPerBlock, bonusEndBlock);\r\n  }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyRewardWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencySweepWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusEndBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SkimStakeTokenFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REWARD_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRewardWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeTokenFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardTokenPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"}],\"name\":\"setBonusEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRewardPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skimStakeTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakeTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BEP20RewardYummy", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://abbe9b17a845af8401b79063df8e7e934d8aed48408cdb640bfc198a836c9b52"}