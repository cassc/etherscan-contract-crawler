{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/GloryDoge.sol\": {\r\n      \"content\": \"/**\\n *  SPDX-License-Identifier: UNLICENSED\\n *\\n *              :-==--:.                                   .::::.\\n *             -+#******+-.                             :=+**##*+-\\n *            .+##=++++*##*=.                        .-+*####**##+-\\n *            -+#*=+##*++*##+==++++=-----:::::::.. .-+###**###**#*+\\n *            +*#=++###*+++*####################****###***####***#+.\\n *           :+##=++####++++##*+++++**************####***#####***#+.\\n *           :+##==+###*++*#*+#*++++++++++++******++*########***##+.\\n *           -+##==+*#####*++##++++++++++++**********+**#####***##+.\\n *           =*##=++++##*+++*#*++++++++++++************++*##****##+.\\n *          .+##==++*+==+++*++++++++++++++******+********++###**#*=\\n *          :+#+=+#*===++++++**+++++++++++++++++++********++*####+:\\n *          -+#+*#+=+++++++**##*++++++++++++++++*#####**++**++##+-\\n *          -+###+=++++++++*#*#####*++++++++++*####+*#****++**+#+-\\n *         :+####==++++++++*#:+=*#*++++++++*++###==-*#*****+**+*#+:\\n *        .+###+--:.   -+++++*+*##*++++++++*+*#####****++++*+**+#*+\\n *        =*##*.        .=*****+++++++++++++++*#******====++***++#+:\\n *       -+##+.           =+++++++++++++++++++*******+=====-+++-*#+-\\n *      .+###:  .#=         .:=++++=-----:..:+****+======== === *#*-\\n *      :+*#*..  #=          =++-.:++::::-++.-*+=+=========.=== =#+-\\n *      :=+#*:. .#=.        .+++. ##########+:+======-.====.==- =#+:\\n *       .+##*.  =*#.   . *#=+++- -*+*###*++-======+*#-===. -=. *#+.\\n *        ++##-   .#=    ..###=     .+###**=======*##*==== :=- -#*=\\n *        +=+##-   +#    . .##*=.    ==*#+++++++*###*====:-== =##+.\\n *        : :+##:   *:    . .##=-+###########*+####+========. ##+:\\n *           :+*#-   -     . .*#*:+*########***###+=======-. -#+-\\n *            .++#=.           =###===+*#****####*========   **=\\n *             .=*#+.           :##=====+===***#*======-=.  +#+.\\n *              .=*#*-..         -#--=======***#+====: :.  *#+-\\n *                -+*#*+=.        *+.-=====+**#+====    -=##+-\\n *                  ::=*##=.       +*-===*=+*#*===-   .*##*+:\\n *                     -+*##-        -=+*#***+===--==*###+-.\\n *                       -+*##+=:.        .=+**###*****+-.\\n *                         .:=+*****+*##+=*#*+=-::-=-:.\\n *                              ..::-=+*##+=:\\n *\\n *  GloryDoge (GLORYD) - Building platforms & tools to secure DeFi investors'\\n *  funds during IDO private sales and presales.\\n *\\n *  Tokenomics:\\n *    - 10% total tax on every transaction.\\n *    - 4% tax is distributed proportionally to all holders.\\n *    - 2% tax for marketing, contests, and celebratory distribution events.\\n *      Used in full transparency to investors.\\n *    - 4% devs and team expenses. No one should work for free.\\n *    - Normal transfers from a wallet to another wallet are 100% tax-free.\\n *    - 50% of the revenues from our DAPPs will be distributed proportionally\\n *      to all holders in GLORYD.\\n *    - Burn and CEX wallets are excluded from tax/revenue distribution.\\n *    - 0 initial dev or team wallets.\\n *\\n *  We are here to disrupt. We are here for Glory.\\n *\\n *  Website--------glorydogecoin.com\\n *  Whitepaper-----docs.glorydogecoin.com\\n *  Telegram-------t.me/GloryDogeCoin\\n *  Twitter--------twitter.com/GloryDogeCoin\\n *  Email----------hello@glorydogecoin.com\\n */\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\n\\n/**\\n * @title GloryDoge token contract.\\n * @author The GloryDoge team.\\n */\\ncontract GloryDoge is Context, IERC20, IERC20Metadata, Ownable {\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    mapping(address => uint256) private _supplyOwned;\\n    mapping(address => uint256) private _rewardPointsOwned;\\n\\n    mapping(address => bool) private _excludedFromRewards;\\n    mapping(address => bool) private _excludedFromTaxes;\\n\\n    mapping(address => bool) private _distributionAddress;\\n    mapping(address => bool) private _pair;\\n\\n    address private _marketingTaxAddress =\\n        0xe2149C2E2A9e664E9AD5f20eb90db575bcb95F18;\\n    address private _teamTaxAddress =\\n        0xDc4340b73A388863590476EF7D450Bc316D87712;\\n    address private constant _factoryAddress =\\n        0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\\n    address private constant _routerAddress =\\n        0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    address private constant _deadAddress =\\n        0x000000000000000000000000000000000000dEaD;\\n\\n    uint256 private _totalSupply;\\n    uint256 private _excludedSupply;\\n\\n    uint256 private _rewardPoints;\\n    uint256 private _excludedRewardPoints;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    uint256 private _rewardsTax = 4;\\n    uint256 private _marketingTax = 2;\\n    uint256 private _teamTax = 4;\\n    uint256 private _taxSwapThreshold;\\n\\n    uint256 private constant _MAX_UINT = type(uint256).max;\\n    uint256 private _maxTransferLimit;\\n\\n    IUniswapV2Factory private _factory;\\n    IUniswapV2Router02 private _router;\\n\\n    bool private _inSwap;\\n\\n    event MarketingTaxAddressChange(address indexed from, address indexed to);\\n    event TeamTaxAddressChange(address indexed from, address indexed to);\\n    event IncludeInRewards(address indexed account);\\n    event ExcludeFromRewards(address indexed account);\\n    event IncludeInTaxes(address indexed account);\\n    event ExcludeFromTaxes(address indexed account);\\n    event AddDistributor(address indexed account);\\n    event RemoveDistributor(address indexed account);\\n    event Distribution(address indexed from, uint256 amount);\\n    event AddPair(address indexed pairAddress);\\n    event EnableTransferLimit(uint256 limit);\\n    event DisableTransferLimit(uint256 limit);\\n    event TaxSwapThresholdChange(uint256 threshold);\\n    event TaxesChange(\\n        uint256 rewardsTax,\\n        uint256 marketingTax,\\n        uint256 teamTax\\n    );\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 totalSupply_\\n    ) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _totalSupply = totalSupply_ * 10**decimals();\\n        _rewardPoints = _MAX_UINT - (_MAX_UINT % _totalSupply);\\n        _maxTransferLimit = _totalSupply;\\n        _taxSwapThreshold = 5 * 10**10 * 10**decimals();\\n        _router = IUniswapV2Router02(_routerAddress);\\n        _factory = IUniswapV2Factory(_factoryAddress);\\n\\n        _rewardPointsOwned[_msgSender()] = _rewardPoints;\\n\\n        excludeFromRewards(address(this));\\n        excludeFromTaxes(address(this));\\n\\n        excludeFromRewards(_msgSender());\\n        excludeFromTaxes(_msgSender());\\n\\n        excludeFromRewards(_marketingTaxAddress);\\n        excludeFromTaxes(_marketingTaxAddress);\\n\\n        excludeFromRewards(_teamTaxAddress);\\n        excludeFromTaxes(_teamTaxAddress);\\n\\n        excludeFromRewards(_deadAddress);\\n        excludeFromTaxes(_deadAddress);\\n\\n        addPair(_factory.createPair(address(this), _router.WETH()));\\n\\n        // Burn 50% of the supply on contract creation.\\n        transfer(_deadAddress, _totalSupply / 2);\\n\\n        enableTransferLimit();\\n    }\\n\\n    modifier swapLock() {\\n        _inSwap = true;\\n        _;\\n        _inSwap = false;\\n    }\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public pure override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * Returns the current rewards tax.\\n     */\\n    function rewardsTax() public view returns (uint256) {\\n        return _rewardsTax;\\n    }\\n\\n    /**\\n     * Returns the current marketing tax.\\n     */\\n    function marketingTax() public view returns (uint256) {\\n        return _marketingTax;\\n    }\\n\\n    /**\\n     * Returns the current team tax.\\n     */\\n    function teamTax() public view returns (uint256) {\\n        return _teamTax;\\n    }\\n\\n    /**\\n     * Returns the current total taxes.\\n     */\\n    function totalTaxes() public view returns (uint256) {\\n        return _rewardsTax + _marketingTax + _teamTax;\\n    }\\n\\n    /**\\n     * Returns the current tax swap threshold.\\n     */\\n    function taxSwapThreshold() public view returns (uint256) {\\n        return _taxSwapThreshold;\\n    }\\n\\n    /**\\n     * Returns true if an address is excluded from rewards.\\n     * @param account The address to ckeck.\\n     */\\n    function excludedFromRewards(address account) public view returns (bool) {\\n        return _excludedFromRewards[account];\\n    }\\n\\n    /**\\n     * Returns true if an address is excluded from taxes.\\n     * @param account The address to ckeck.\\n     */\\n    function excludedFromTaxes(address account) public view returns (bool) {\\n        return _excludedFromTaxes[account];\\n    }\\n\\n    /**\\n     * Returns true if an address is a distribution address.\\n     * @param account The address to ckeck.\\n     */\\n    function distributionAddress(address account) public view returns (bool) {\\n        return _distributionAddress[account];\\n    }\\n\\n    /**\\n     * Returns true if an address is a pair address.\\n     * @param account The address to ckeck.\\n     */\\n    function pair(address account) public view returns (bool) {\\n        return _pair[account];\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_excludedFromRewards[account]) return _supplyOwned[account];\\n        uint256 rate = _getRewardsRate();\\n        return _getBalanceFromRewardPoints(_rewardPointsOwned[account], rate);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        public\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(\\n            currentAllowance >= amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender] + addedValue\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(\\n            currentAllowance >= subtractedValue,\\n            \\\"ERC20: decreased allowance below zero\\\"\\n        );\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Updates the marketing tax address.\\n     * @param marketingTaxAddress The new marketing tax address.\\n     */\\n    function setMarketingTaxAddress(address marketingTaxAddress)\\n        public\\n        onlyOwner\\n    {\\n        address _oldMarketingTaxAddress = _marketingTaxAddress;\\n\\n        includeInRewards(_oldMarketingTaxAddress);\\n        includeInTaxes(_oldMarketingTaxAddress);\\n\\n        excludeFromRewards(marketingTaxAddress);\\n        excludeFromTaxes(marketingTaxAddress);\\n\\n        _marketingTaxAddress = marketingTaxAddress;\\n\\n        emit MarketingTaxAddressChange(\\n            _oldMarketingTaxAddress,\\n            _marketingTaxAddress\\n        );\\n    }\\n\\n    /**\\n     * Updates the team tax address.\\n     * @param teamTaxAddress The new team tax address.\\n     */\\n    function setTeamTaxAddress(address teamTaxAddress) public onlyOwner {\\n        address _oldTeamTaxAddress = _teamTaxAddress;\\n\\n        includeInRewards(_oldTeamTaxAddress);\\n        includeInTaxes(_oldTeamTaxAddress);\\n\\n        excludeFromRewards(teamTaxAddress);\\n        excludeFromTaxes(teamTaxAddress);\\n\\n        _teamTaxAddress = teamTaxAddress;\\n\\n        emit MarketingTaxAddressChange(_oldTeamTaxAddress, _teamTaxAddress);\\n    }\\n\\n    /**\\n     * Updates the taxes. Makes sure total taxes are never above 10% and\\n     * reward tax is always 2% or more.\\n     * @param rewardsTax_ The new rewardTax value.\\n     * @param marketingTax_ The new marketingTax value.\\n     * @param teamTax_ The new teamTax value.\\n     */\\n    function setTaxes(\\n        uint256 rewardsTax_,\\n        uint256 marketingTax_,\\n        uint256 teamTax_\\n    ) public onlyOwner {\\n        require(\\n            rewardsTax_ + marketingTax_ + teamTax_ <= 10,\\n            \\\"Total taxes should never be more than 10%.\\\"\\n        );\\n\\n        _rewardsTax = rewardsTax_;\\n        _marketingTax = marketingTax_;\\n        _teamTax = teamTax_;\\n\\n        emit TaxesChange(_rewardsTax, _marketingTax, _teamTax);\\n    }\\n\\n    /**\\n     * Distributes an amount from the sender's wallet to all holders.\\n     * Can only be called by Owner, or an address that is a distributor.\\n     * @param amount The amount of tokens to be distributed.\\n     */\\n    function distribute(uint256 amount) external {\\n        require(\\n            _distributionAddress[_msgSender()] || owner() == _msgSender(),\\n            \\\"Only owner and distribution addresses can call this function.\\\"\\n        );\\n\\n        uint256 balance = balanceOf(_msgSender());\\n\\n        require(balance >= amount, \\\"Distribution amount exceeds balance\\\");\\n\\n        uint256 rate = _getRewardsRate();\\n\\n        uint256 balanceRewardPoints = _getRewardPointsFromBalance(\\n            balance,\\n            rate\\n        );\\n        uint256 amountRewardPoints = _getRewardPointsFromBalance(amount, rate);\\n\\n        if (_excludedFromRewards[_msgSender()]) {\\n            _supplyOwned[_msgSender()] -= amount;\\n            _excludedSupply -= amount;\\n            _excludedRewardPoints -= amountRewardPoints;\\n        } else\\n            _rewardPointsOwned[_msgSender()] =\\n                balanceRewardPoints -\\n                amountRewardPoints;\\n\\n        _rewardPoints -= amountRewardPoints;\\n\\n        emit Distribution(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * Adds an address to distributors.\\n     * @param account The address to be added to distributors.\\n     */\\n    function addDistributor(address account) public onlyOwner {\\n        require(\\n            !_distributionAddress[account],\\n            \\\"Address is already a distributor\\\"\\n        );\\n        _distributionAddress[account] = true;\\n\\n        emit AddDistributor(account);\\n    }\\n\\n    /**\\n     * Removes an address from distributors.\\n     * @param account The address to be removed from distributors.\\n     */\\n    function removeDistributor(address account) public onlyOwner {\\n        require(_distributionAddress[account], \\\"Address is not a distributor\\\");\\n        _distributionAddress[account] = true;\\n\\n        emit RemoveDistributor(account);\\n    }\\n\\n    /**\\n     * Includes an address in rewards. Calculates new reward points from\\n     * current balance to avoid pulling rewards from existing holders.\\n     * @param account The address to be excluded from rewards.\\n     */\\n    function includeInRewards(address account) public onlyOwner {\\n        if (!_excludedFromRewards[account]) return;\\n\\n        uint256 rate = _getRewardsRate();\\n        uint256 accountSupplyBalance = balanceOf(account);\\n        uint256 accountRewardPoints = _getRewardPointsFromBalance(\\n            accountSupplyBalance,\\n            rate\\n        );\\n\\n        _rewardPointsOwned[account] = accountRewardPoints;\\n        _excludedSupply -= accountSupplyBalance;\\n        _excludedRewardPoints -= accountRewardPoints;\\n\\n        _excludedFromRewards[account] = false;\\n\\n        emit IncludeInRewards(account);\\n    }\\n\\n    /**\\n     * Excludes an address from rewards. Calculates new Balance from current\\n     * reward points.\\n     * @param account The address to be included in rewards.\\n     */\\n    function excludeFromRewards(address account) public onlyOwner {\\n        if (_excludedFromRewards[account]) return;\\n\\n        uint256 rate = _getRewardsRate();\\n        uint256 accountSupplyBalance = balanceOf(account);\\n        uint256 accountRewardPoints = _getRewardPointsFromBalance(\\n            accountSupplyBalance,\\n            rate\\n        );\\n\\n        _supplyOwned[account] = accountSupplyBalance;\\n        _excludedSupply += accountSupplyBalance;\\n        _excludedRewardPoints += accountRewardPoints;\\n\\n        _excludedFromRewards[account] = true;\\n\\n        emit ExcludeFromRewards(account);\\n    }\\n\\n    /**\\n     * Includces an address in taxes.\\n     * @param account The address to be included in taxes.\\n     */\\n    function includeInTaxes(address account) public onlyOwner {\\n        if (!_excludedFromTaxes[account]) return;\\n        _excludedFromTaxes[account] = false;\\n\\n        emit IncludeInTaxes(account);\\n    }\\n\\n    /**\\n     * Excludes an address from taxes.\\n     * @param account The address to be excluded from taxes.\\n     */\\n    function excludeFromTaxes(address account) public onlyOwner {\\n        if (_excludedFromTaxes[account]) return;\\n        _excludedFromTaxes[account] = true;\\n\\n        emit ExcludeFromTaxes(account);\\n    }\\n\\n    /**\\n     * Enables the 0.2% transfer amount limit.\\n     */\\n    function enableTransferLimit() public onlyOwner {\\n        require(\\n            _maxTransferLimit == _totalSupply,\\n            \\\"Transfer limit already enabled\\\"\\n        );\\n        _maxTransferLimit = _totalSupply / 500;\\n\\n        emit EnableTransferLimit(_maxTransferLimit);\\n    }\\n\\n    /**\\n     * Disables the 0.2% transfer amount limit.\\n     */\\n    function disableTransferLimit() public onlyOwner {\\n        require(\\n            _maxTransferLimit != _totalSupply,\\n            \\\"Transfer limit already disabled\\\"\\n        );\\n        _maxTransferLimit = _totalSupply;\\n\\n        emit DisableTransferLimit(_maxTransferLimit);\\n    }\\n\\n    /**\\n     * Adds new pair address and excludes it from rewards distribution.\\n     * @param pairAddress The new pair address to be added.\\n     */\\n    function addPair(address pairAddress) public onlyOwner {\\n        _pair[pairAddress] = true;\\n        excludeFromRewards(pairAddress);\\n\\n        emit AddPair(pairAddress);\\n    }\\n\\n    /**\\n     * Updates the tax swap threshold.\\n     * @param threshold The new tax swap threshold.\\n     */\\n    function setTaxSwapThreshold(uint256 threshold) public onlyOwner {\\n        _taxSwapThreshold = threshold;\\n\\n        emit TaxSwapThresholdChange(_taxSwapThreshold);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (_inSwap) return _swapTransfer(sender, recipient, amount);\\n        if (_pair[recipient]) _swapTaxes();\\n\\n        uint256 rate = _getRewardsRate();\\n\\n        uint256 afterTaxAmount = amount;\\n        uint256 rewardsTaxAmount;\\n        uint256 taxesToExclude;\\n\\n        uint256 amountRewardPoints = _getRewardPointsFromBalance(amount, rate);\\n        uint256 afterTaxAmountRewardPoints = amountRewardPoints;\\n\\n        // Take taxes only if both sender and recepient are not excluded\\n        // and if one of them is the liquidity pool address.\\n        // This doesn't exclude the taxes from _rewardPoints and _totalSupply.\\n        if (\\n            !_excludedFromTaxes[sender] &&\\n            !_excludedFromTaxes[recipient] &&\\n            (_pair[sender] || _pair[recipient])\\n        ) {\\n            require(\\n                amount <= _maxTransferLimit,\\n                \\\"Transfer amount exceeds max transfer limit\\\"\\n            );\\n\\n            (afterTaxAmount, rewardsTaxAmount, taxesToExclude) = _takeTaxes(\\n                amount\\n            );\\n\\n            afterTaxAmountRewardPoints = _getRewardPointsFromBalance(\\n                afterTaxAmount,\\n                rate\\n            );\\n        }\\n\\n        if (_excludedFromRewards[sender]) {\\n            _supplyOwned[sender] -= amount;\\n            _excludedSupply -= amount;\\n            _excludedRewardPoints -= amountRewardPoints;\\n        } else {\\n            // We should already have the sender's _ownedRewardPoints, but\\n            // due to the rate changes we should recalculate it for more\\n            // precision.\\n            _rewardPointsOwned[sender] =\\n                _getRewardPointsFromBalance(balanceOf(sender), rate) -\\n                amountRewardPoints;\\n        }\\n\\n        // Exclude the taxes from _rewardPoints and _totalSupply, if any.\\n        if (taxesToExclude != 0) {\\n            _excludedSupply += taxesToExclude;\\n            _excludedRewardPoints += _getRewardPointsFromBalance(\\n                taxesToExclude,\\n                rate\\n            );\\n        }\\n\\n        // Update rewards rate before concluding the transfer so that the\\n        // senders get their part of the reward taxes paid. (Sent to recipient)\\n        if (rewardsTaxAmount != 0) {\\n            _rewardPoints -= _getRewardPointsFromBalance(\\n                rewardsTaxAmount,\\n                rate\\n            );\\n            rate = _getRewardsRate();\\n\\n            afterTaxAmount = _getBalanceFromRewardPoints(\\n                afterTaxAmountRewardPoints,\\n                rate\\n            );\\n        }\\n\\n        if (_excludedFromRewards[recipient]) {\\n            _supplyOwned[recipient] += afterTaxAmount;\\n            _excludedSupply += afterTaxAmount;\\n            _excludedRewardPoints += afterTaxAmountRewardPoints;\\n        } else {\\n            _rewardPointsOwned[recipient] += afterTaxAmountRewardPoints;\\n        }\\n\\n        emit Transfer(sender, recipient, afterTaxAmount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * Lightweight version of _transfer. Used only during tax swapping to keep\\n     * gas fees low.\\n     */\\n    function _swapTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(\\n            _excludedFromRewards[sender] && _excludedFromRewards[recipient],\\n            \\\"Both Contract and Pair should be excluded from rewards for tax swaps to work\\\"\\n        );\\n        _supplyOwned[sender] -= amount;\\n        _supplyOwned[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /**\\n     * Swaps the accumulated marketing and team taxes to ETH and sends\\n     * the corresponding amounts to the marketing and team tax wallets.\\n     */\\n    function _swapTaxes() internal swapLock {\\n        uint256 contractBalance = balanceOf(address(this));\\n        if (\\n            contractBalance < _taxSwapThreshold ||\\n            (_rewardsTax == 0 && _marketingTax == 0)\\n        ) return;\\n\\n        _approve(address(this), address(_router), contractBalance);\\n\\n        uint256 marketingAmount = (_taxSwapThreshold * _marketingTax) /\\n            (_marketingTax + _teamTax);\\n        uint256 teamAmount = (_taxSwapThreshold * _teamTax) /\\n            (_marketingTax + _teamTax);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _router.WETH();\\n\\n        _router.swapExactTokensForETH(\\n            marketingAmount,\\n            0,\\n            path,\\n            _marketingTaxAddress,\\n            block.timestamp\\n        );\\n\\n        _router.swapExactTokensForETH(\\n            teamAmount,\\n            0,\\n            path,\\n            _teamTaxAddress,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * Calculates and assigns tax amounts to the contract.\\n     * @param amount The amount to take taxes from.\\n     */\\n    function _takeTaxes(uint256 amount)\\n        internal\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rewardsTaxAmount = (amount * _rewardsTax) / 100;\\n        uint256 marketingTaxAmount = (amount * _marketingTax) / 100;\\n        uint256 teamTaxAmount = (amount * _teamTax) / 100;\\n\\n        uint256 afterTaxAmount = amount -\\n            rewardsTaxAmount -\\n            marketingTaxAmount -\\n            teamTaxAmount;\\n\\n        _supplyOwned[address(this)] += marketingTaxAmount + teamTaxAmount;\\n\\n        return (\\n            afterTaxAmount,\\n            rewardsTaxAmount,\\n            marketingTaxAmount + teamTaxAmount\\n        );\\n    }\\n\\n    /**\\n     * Calculates current rewards rate.\\n     */\\n    function _getRewardsRate() internal view returns (uint256) {\\n        uint256 remainingRewardPoints = _rewardPoints - _excludedRewardPoints;\\n        uint256 remainingTotalSupply = _totalSupply - _excludedSupply;\\n\\n        if (remainingRewardPoints == 0 || remainingTotalSupply == 0)\\n            return _rewardPoints / _totalSupply;\\n\\n        return remainingRewardPoints / remainingTotalSupply;\\n    }\\n\\n    /**\\n     * Calculates reward points from balance.\\n     * @param balance The balance to calculate from.\\n     */\\n    function _getRewardPointsFromBalance(uint256 balance, uint256 rate)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return balance * rate;\\n    }\\n\\n    /**\\n     * Calculates balance from reward points.\\n     * @param rewardPoints The amount of reward points to calculate from.\\n     */\\n    function _getBalanceFromRewardPoints(uint256 rewardPoints, uint256 rate)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return rewardPoints / rate;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddDistributor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"}],\"name\":\"AddPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"DisableTransferLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Distribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"EnableTransferLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeInRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeInTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"MarketingTaxAddressChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveDistributor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"TaxSwapThresholdChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"teamTax\",\"type\":\"uint256\"}],\"name\":\"TaxesChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TeamTaxAddressChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairAddress\",\"type\":\"address\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"distributionAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTransferLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludedFromRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludedFromTaxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingTaxAddress\",\"type\":\"address\"}],\"name\":\"setMarketingTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setTaxSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsTax_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingTax_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTax_\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"teamTaxAddress\",\"type\":\"address\"}],\"name\":\"setTeamTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GloryDoge", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000000000000000009476c6f7279446f676500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006474c4f5259440000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}