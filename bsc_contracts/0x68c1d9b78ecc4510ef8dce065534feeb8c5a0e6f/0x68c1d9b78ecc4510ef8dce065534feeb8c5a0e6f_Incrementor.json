{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/Incrementor.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface CallProxy {\r\n    function anyCall(\r\n        address _to,\r\n        bytes calldata _data,\r\n        uint256 _toChainID,\r\n        uint256 _flags,\r\n        bytes calldata _extdata\r\n    ) external payable;\r\n}\r\n\r\ninterface IMultichainRouter {\r\n    function anySwapOutUnderlying(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 toChainID\r\n    ) external;\r\n\r\n    function anySwapOut(\r\n        address token,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 toChainID\r\n    ) external;\r\n\r\n    function anySwapOutNative(\r\n        address token,\r\n        address to,\r\n        uint256 toChainID\r\n    ) external payable;\r\n\r\n    function wNATIVE() external returns (address);\r\n}\r\n\r\n\r\ncontract Incrementor {  \r\n\r\n    address private multichainRouter;\r\n    address internal anyCallProxy;\r\n\r\n    event LogCallIn(address srcServer, uint256 srcChain, address receiver, address token, uint256 amount, uint256 currentBalance);\r\n\r\n    mapping(address => mapping(uint256 => address)) private tokenPeer;\r\n    mapping(uint256 => address) private serverPeer;\r\n\r\n    function setTokenPeer(address token, uint256 chain, address desToken) public {\r\n        tokenPeer[token][chain] = desToken;\r\n    }\r\n\r\n    function getTokenPeer(address token, uint256 chain) public view returns (address) {\r\n        return (tokenPeer[token][chain]);\r\n    }\r\n\r\n    function setServerPeer(uint256 chainId, address peer) public {\r\n        serverPeer[chainId] = peer;\r\n    }\r\n\r\n    function getServerPeer(uint256 chainId) public view returns (address) {\r\n        return (serverPeer[chainId]);\r\n    }\r\n\r\n    function setMultichainRouter(address _multichainRouter) public {\r\n        multichainRouter = _multichainRouter;\r\n    }\r\n\r\n    function getMultichainRouter() public view returns (address) {\r\n        return (multichainRouter);\r\n    }\r\n\r\n    function setAnyCallProxy(address _anyCallProxy) public {\r\n        anyCallProxy = _anyCallProxy;\r\n    }\r\n\r\n    function getAnyCallProxy() public view returns (address) {\r\n        return anyCallProxy;\r\n    }\r\n\r\n    function callOut(\r\n        uint256 serverChainId,\r\n        address token,\r\n        address receiver,\r\n        uint256 amount,\r\n        uint256 flag,\r\n        address contractAddressTo\r\n    ) public {\r\n        bytes memory message = abi.encode(\r\n            address(this),\r\n            block.chainid,\r\n            receiver,\r\n            tokenPeer[token][serverChainId],\r\n            amount\r\n        );\r\n\r\n        IERC20(token).approve(multichainRouter, amount);\r\n            // replace tokenAddress with anyTokenAddress (if mapping found) and call ERC20 asset bridge function\r\n        IMultichainRouter(multichainRouter).anySwapOutUnderlying(\r\n            tokenPeer[token][serverChainId],\r\n            contractAddressTo,\r\n            amount,\r\n            serverChainId\r\n        );\r\n\r\n        CallProxy(anyCallProxy).anyCall{value: 0.1 ether}(\r\n                serverPeer[serverChainId],\r\n                message,\r\n                serverChainId,\r\n                flag, // flags\r\n                \"\"\r\n            );\r\n    }\r\n\r\n    function anyExecute(bytes calldata data) external returns (bool success, bytes memory result){\r\n        (address contratSender, uint256 srcChain, address receiver, address token, uint256 amount) = \r\n        abi.decode(\r\n            data,\r\n            (address, uint256, address, address, uint256)\r\n        );\r\n\r\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\r\n        if (currentBalance >= 0){\r\n            IERC20(token).transfer(receiver, currentBalance);\r\n        }\r\n\r\n        emit LogCallIn(contratSender, srcChain, receiver, token, amount, currentBalance);\r\n    }\r\n\r\n    function withdrawFunds(address token, address receiver) public {\r\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\r\n        IERC20(token).transfer(receiver, currentBalance);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcServer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"}],\"name\":\"LogCallIn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"anyExecute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serverChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddressTo\",\"type\":\"address\"}],\"name\":\"callOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAnyCallProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMultichainRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getServerPeer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain\",\"type\":\"uint256\"}],\"name\":\"getTokenPeer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_anyCallProxy\",\"type\":\"address\"}],\"name\":\"setAnyCallProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_multichainRouter\",\"type\":\"address\"}],\"name\":\"setMultichainRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"peer\",\"type\":\"address\"}],\"name\":\"setServerPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"desToken\",\"type\":\"address\"}],\"name\":\"setTokenPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Incrementor", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://db2cb6766015a5b4831a3be1601b0449dcfeb8a196578d7dfce71afe5928b52d"}