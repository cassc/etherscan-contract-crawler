{"SourceCode": "{\"BSCSunRise.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/*\\r\\n \u2584\u2584\u2584\u2584     \u2588\u2588\u2588\u2588\u2588\u2588  \u2584\u2588\u2588\u2588\u2588\u2584       \u2588\u2588\u2588\u2588\u2588\u2588  \u2588    \u2588\u2588  \u2588\u2588\u2588\u2584    \u2588  \u2588\u2588\u2580\u2588\u2588\u2588   \u2588\u2588\u2593  \u2588\u2588\u2588\u2588\u2588\u2588 \u2593\u2588\u2588\u2588\u2588\u2588 \\r\\n\u2593\u2588\u2588\u2588\u2588\u2588\u2584 \u2592\u2588\u2588    \u2592 \u2592\u2588\u2588\u2580 \u2580\u2588     \u2592\u2588\u2588    \u2592  \u2588\u2588  \u2593\u2588\u2588\u2592 \u2588\u2588 \u2580\u2588   \u2588 \u2593\u2588\u2588 \u2592 \u2588\u2588\u2592\u2593\u2588\u2588\u2592\u2592\u2588\u2588    \u2592 \u2593\u2588   \u2580 \\r\\n\u2592\u2588\u2588\u2592 \u2584\u2588\u2588\u2591 \u2593\u2588\u2588\u2584   \u2592\u2593\u2588    \u2584    \u2591 \u2593\u2588\u2588\u2584   \u2593\u2588\u2588  \u2592\u2588\u2588\u2591\u2593\u2588\u2588  \u2580\u2588 \u2588\u2588\u2592\u2593\u2588\u2588 \u2591\u2584\u2588 \u2592\u2592\u2588\u2588\u2592\u2591 \u2593\u2588\u2588\u2584   \u2592\u2588\u2588\u2588   \\r\\n\u2592\u2588\u2588\u2591\u2588\u2580    \u2592   \u2588\u2588\u2592\u2592\u2593\u2593\u2584 \u2584\u2588\u2588\u2592     \u2592   \u2588\u2588\u2592\u2593\u2593\u2588  \u2591\u2588\u2588\u2591\u2593\u2588\u2588\u2592  \u2590\u258c\u2588\u2588\u2592\u2592\u2588\u2588\u2580\u2580\u2588\u2584  \u2591\u2588\u2588\u2591  \u2592   \u2588\u2588\u2592\u2592\u2593\u2588  \u2584 \\r\\n\u2591\u2593\u2588  \u2580\u2588\u2593\u2592\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2592\u2592 \u2593\u2588\u2588\u2588\u2580 \u2591   \u2592\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2592\u2592\u2592\u2588\u2588\u2588\u2588\u2588\u2593 \u2592\u2588\u2588\u2591   \u2593\u2588\u2588\u2591\u2591\u2588\u2588\u2593 \u2592\u2588\u2588\u2592\u2591\u2588\u2588\u2591\u2592\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2592\u2591\u2592\u2588\u2588\u2588\u2588\u2592\\r\\n\u2591\u2592\u2593\u2588\u2588\u2588\u2580\u2592\u2592 \u2592\u2593\u2592 \u2592 \u2591\u2591 \u2591\u2592 \u2592  \u2591   \u2592 \u2592\u2593\u2592 \u2592 \u2591\u2591\u2592\u2593\u2592 \u2592 \u2592 \u2591 \u2592\u2591   \u2592 \u2592 \u2591 \u2592\u2593 \u2591\u2592\u2593\u2591\u2591\u2593  \u2592 \u2592\u2593\u2592 \u2592 \u2591\u2591\u2591 \u2592\u2591 \u2591\\r\\n\u2592\u2591\u2592   \u2591 \u2591 \u2591\u2592  \u2591 \u2591  \u2591  \u2592      \u2591 \u2591\u2592  \u2591 \u2591\u2591\u2591\u2592\u2591 \u2591 \u2591 \u2591 \u2591\u2591   \u2591 \u2592\u2591  \u2591\u2592 \u2591 \u2592\u2591 \u2592 \u2591\u2591 \u2591\u2592  \u2591 \u2591 \u2591 \u2591  \u2591\\r\\n \u2591    \u2591 \u2591  \u2591  \u2591  \u2591           \u2591  \u2591  \u2591   \u2591\u2591\u2591 \u2591 \u2591    \u2591   \u2591 \u2591   \u2591\u2591   \u2591  \u2592 \u2591\u2591  \u2591  \u2591     \u2591   \\r\\n \u2591            \u2591  \u2591 \u2591               \u2591     \u2591              \u2591    \u2591      \u2591        \u2591     \u2591  \u2591\\r\\n      \u2591          \u2591                                                                     \\r\\n*/\\r\\npragma solidity ^0.8.2;\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\ncontract BSCSunRise is Storage {  \\r\\n    constructor() { \\r\\n        setLevels(); \\r\\n        totalUsers++;\\r\\n        Nodes[totalUsers].registerTime =block.timestamp;\\r\\n        Nodes[totalUsers].ad = msg.sender; \\r\\n        Nodes[totalUsers].ln = (uint8)(pl.length);\\r\\n        Nodes[totalUsers].rwi = lastCalcIndex;\\r\\n        Nodes[totalUsers].lwi = lastCalcIndex;\\r\\n        uids[msg.sender] = totalUsers;\\r\\n    }\\r\\n\\r\\n    function setLevels() internal{\\r\\n        for(uint8 i = 0; i \\u003c pl.length; i++){\\r\\n            Levels[i + 1].price = (uint256)(pl[i] * basePrice) * (10 ** 18);\\r\\n            Levels[i + 1].parityAmount = pl[i];\\r\\n            Levels[i + 1].perDay =(uint16)(pl[i]) * 25 ;\\r\\n        }\\r\\n    }    \\r\\n\\r\\n    function checkLastCalc() private {\\r\\n        if(block.timestamp - lastCalc \\u003e calcPeriod){ \\r\\n\\r\\n            if(pool[lastCalcIndex].sumParity ==0){\\r\\n                pool[lastCalcIndex+1].sumDeposit = pool[lastCalcIndex].sumDeposit;\\r\\n            }   \\r\\n            \\r\\n            lastCalcIndex++;\\r\\n            lastCalc = block.timestamp;\\r\\n            canWithdraw = true;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function CalcParity(address user) internal{\\r\\n        uint24 currentUserParity = 0;\\r\\n        uint32 userId = uids[user];\\r\\n\\r\\n        if(Nodes[userId].isLeaved){\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint16 pd = Levels[Nodes[userId].ln].perDay;\\r\\n\\r\\n        if(Nodes[userId].LCap \\u003e= Nodes[userId].RCap ){\\r\\n            if(Nodes[userId].RCap + pool[lastCalcIndex].userParity[user] \\u003e pd){\\r\\n                currentUserParity = pd - pool[lastCalcIndex].userParity[user];\\r\\n                if(currentUserParity \\u003e 0){\\r\\n                    pool[lastCalcIndex].userParity[user] = pd;\\r\\n                }\\r\\n            } else {\\r\\n                pool[lastCalcIndex].userParity[user] += Nodes[userId].RCap;\\r\\n                currentUserParity = Nodes[userId].RCap;\\r\\n            }\\r\\n\\r\\n            Nodes[userId].LCap = Nodes[userId].LCap - Nodes[userId].RCap; \\r\\n            Nodes[userId].RCap = 0;\\r\\n        } else{\\r\\n            if(Nodes[userId].LCap + pool[lastCalcIndex].userParity[user] \\u003e pd){\\r\\n                currentUserParity = pd - pool[lastCalcIndex].userParity[user];\\r\\n                if(currentUserParity \\u003e 0){\\r\\n                    pool[lastCalcIndex].userParity[user] = pd;\\r\\n                }\\r\\n            } else {\\r\\n                pool[lastCalcIndex].userParity[user] += Nodes[userId].LCap;\\r\\n                currentUserParity = Nodes[userId].LCap;\\r\\n            }\\r\\n            Nodes[userId].RCap = Nodes[userId].RCap - Nodes[userId].LCap; \\r\\n            Nodes[userId].LCap = 0;\\r\\n        }\\r\\n        if(currentUserParity \\u003e 0){\\r\\n            Nodes[userId].allTimeParity += currentUserParity;\\r\\n            pool[lastCalcIndex].sumParity += currentUserParity;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setRefferalsSalesCap(address currentUser , uint8 levelId) internal{\\r\\n        uint16 forPool = 900; //percent will be divided by 1000 =\\u003e means 89%\\r\\n        uint16 forLottery = 80;\\r\\n        uint16 forWd = 20;\\r\\n\\r\\n        if(levelId == 1){\\r\\n            forWd = 50;\\r\\n            forLottery = 50;\\r\\n        } \\r\\n\\r\\n        if(levelId == 2){\\r\\n            forWd = 15;\\r\\n            forLottery = 85;\\r\\n        }\\r\\n\\r\\n        pool[lastCalcIndex].sumDeposit += Levels[levelId].price * forPool / 1000;      // 89% for public pool\\r\\n        lotteryPool     += Levels[levelId].price * forLottery  / 1000;   \\r\\n        withdrawPool    += Levels[levelId].price * forWd  / 1000;    \\r\\n                  \\r\\n        address child = currentUser;\\r\\n        address userParent = parent[child];\\r\\n        uint32 userId = uids[userParent];\\r\\n   \\r\\n        do{\\r\\n          \\r\\n            if(children[userParent][0] == child){\\r\\n                Nodes[userId].LCap += Levels[levelId].parityAmount;\\r\\n            } else {\\r\\n                Nodes[userId].RCap += Levels[levelId].parityAmount ;\\r\\n            }\\r\\n            \\r\\n            if(Nodes[userId].LCap \\u003e 0 \\u0026\\u0026 Nodes[userId].RCap \\u003e 0){\\r\\n                CalcParity(userParent);    \\r\\n            } \\r\\n\\r\\n            child = userParent;\\r\\n            userParent = parent[child];\\r\\n            userId = uids[userParent];\\r\\n   \\r\\n        } while(userParent !=  address(0));\\r\\n    }\\r\\n\\r\\n    function getChildCount(address a) internal view returns (uint8){\\r\\n        uint8 c = 0;\\r\\n        \\r\\n        if(children[a][0] != address(0) )\\r\\n            c++;\\r\\n        \\r\\n        if(children[a][1] != address(0))\\r\\n            c++;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n    \\r\\n    function setUserChild(address p ,address c) private{\\r\\n        if(children[p][0] == address(0)) {\\r\\n            children[p][0] = c;\\r\\n        } else {\\r\\n            children[p][1] = c;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function Register(address upline,uint8 levelId) external {\\r\\n        bool v = levelId \\u003e 0 \\u0026\\u0026 levelId \\u003c=4;\\r\\n        \\r\\n        require(v , \\\"Wrong level Id\\\");\\r\\n\\r\\n        uint256 needAmount = Levels[levelId].price ;\\r\\n        uint32 upId = uids[upline];\\r\\n\\r\\n        require(PaymentToken.allowance(msg.sender , address(this)) == needAmount , \\\"Approve to transfer 20 BUSD first.\\\");\\r\\n        \\r\\n        require(upId \\u003e 0 , \\\"Your selected upline is not exists.\\\");\\r\\n        \\r\\n        require(parent[msg.sender]  == address(0) , \\\"You are already registered.\\\");\\r\\n\\r\\n        uint8 legs = getChildCount(upline);\\r\\n        require(legs \\u003c 2 , \\\"Upline already has 2 directs.\\\");         \\r\\n        \\r\\n        checkLastCalc();\\r\\n\\r\\n        PaymentToken.transferFrom(msg.sender , address(this) , needAmount);\\r\\n\\r\\n        totalUsers++;\\r\\n        parent[msg.sender] = upline; \\r\\n        Nodes[totalUsers].registerTime = block.timestamp;\\r\\n        Nodes[totalUsers].ln = 1;\\r\\n        Nodes[totalUsers].ad = msg.sender;\\r\\n        Nodes[totalUsers].lwi = lastCalcIndex;\\r\\n        Nodes[totalUsers].rwi = lastCalcIndex;\\r\\n        uids[msg.sender] = totalUsers;\\r\\n\\r\\n        setUserChild(upline , msg.sender);\\r\\n        \\r\\n        setRefferalsSalesCap(msg.sender, levelId);\\r\\n    } \\r\\n\\r\\n    function getUserId() external view returns(uint32){\\r\\n        return uids[msg.sender];\\r\\n    }\\r\\n\\r\\n    function LevelUp(uint8 levelId) public {\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        \\r\\n        require(Nodes[userId].ln \\u003c 3 , \\\"You are in max level\\\");\\r\\n\\r\\n        bool v = levelId \\u003e 0 \\u0026\\u0026 levelId \\u003c=4; \\r\\n        require(v , \\\"Wrong level Id\\\");\\r\\n        require(levelId \\u003e Nodes[userId].ln , \\\"Level Id should greater than current.\\\");\\r\\n\\r\\n        uint256 needPrice = Levels[levelId].price;\\r\\n        \\r\\n        require(PaymentToken.allowance(msg.sender , address(this)) == needPrice , \\\"Payment token allowance error\\\");\\r\\n\\r\\n        checkLastCalc();\\r\\n        PaymentToken.transferFrom(msg.sender , address(this) , needPrice);\\r\\n        Nodes[userId].ln = levelId;         \\r\\n\\r\\n        setRefferalsSalesCap(msg.sender, levelId);\\r\\n    } \\r\\n\\r\\n    function LeaveNetwork() external{\\r\\n            uint32 userId = uids[msg.sender];\\r\\n            require(userId \\u003e 0 , \\\"Permission Denied.\\\");\\r\\n            \\r\\n            uint8 levelId  = Nodes[userId].ln;\\r\\n            require(lotteryPool \\u003e= Levels[levelId].price , \\\"Lottery pool is empty. wait for next cycle.\\\");\\r\\n            require(!Nodes[userId].isLeaved , \\\"Was leaved the network before\\\");\\r\\n            require(Nodes[userId].allTimeParity == 0 , \\\"you have already at least 1 parity points.\\\");\\r\\n            require(block.timestamp -  Nodes[userId].registerTime \\u003e 16070400 , // 6  month\\r\\n            \\\"Only users who have been registered for at least six month can leave the network\\\");\\r\\n\\r\\n            lotteryPool -= Levels[levelId].price;\\r\\n            Nodes[userId].isLeaved = true;\\r\\n            PaymentToken.transfer(msg.sender, Levels[levelId].price);\\r\\n    }\\r\\n\\r\\n    function SmartLottery() external{\\r\\n        uint256 am = 10 ** 19;\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0 , \\\"You are not Registered.\\\");\\r\\n        uint8 levelId  = Nodes[userId].ln;\\r\\n        require(!Nodes[userId].isLeaved , \\\"Permission Denied\\\");\\r\\n        require(lotteryPool \\u003e= am, \\\"Lottery pool is empty. wait for next cycle.\\\");\\r\\n        require(lotteryPerUser[msg.sender] \\u003c Levels[levelId].price * 2 , \\\"You can\\u0027t participate in the lottery anymore\\\");\\r\\n        require(Nodes[userId].allTimeParity \\u003c= 1 , \\\"you have already more than 3 parity points.\\\");\\r\\n        require(block.timestamp -  Nodes[userId].registerTime \\u003e 2678400 ,\\r\\n         \\\"Only users who have been registered for at least one month can participate in the lottery\\\");\\r\\n        require(lotteryPerUserTime[msg.sender] \\u003c block.timestamp , \\\"You already participated in lottey in this cycle.\\\");\\r\\n\\r\\n        uint8 randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp ,block.number, msg.sender))) % 6);\\r\\n        uint256 tm = block.timestamp + 43200;\\r\\n        randomNumber++;\\r\\n        if(randomNumber == 6){\\r\\n            lotteryPool -= am;\\r\\n            lotteryPerUser[msg.sender] += am;\\r\\n            tm = block.timestamp + 86400;\\r\\n            PaymentToken.transfer(msg.sender, am);\\r\\n        }  \\r\\n\\r\\n        lotteryPerUserTime[msg.sender] = tm;\\r\\n    }\\r\\n\\r\\n    function WithdrawForAll() public {\\r\\n        checkLastCalc();\\r\\n        require(uids[msg.sender] \\u003e 0 , \\\"Permission Denied!\\\");\\r\\n        require(canWithdraw , \\\"It has not been 12 hours past yet.\\\");  \\r\\n        bool hasBonus = false;\\r\\n\\r\\n        for(uint32 i = 1 ; i \\u003c= totalUsers ; i++){\\r\\n            address ad = Nodes[i].ad;\\r\\n            uint16 baseUWI = Nodes[i].lwi;\\r\\n            uint256 cup = 0;\\r\\n            for(uint16 j = baseUWI ; j\\u003c lastCalcIndex; j++){\\r\\n                if(pool[j].sumParity \\u003e 0){\\r\\n                    uint256 profit =(pool[j].sumDeposit * pool[j].userParity[ad]) / pool[j].sumParity;\\r\\n                    if(profit \\u003e 0){ \\r\\n                        cup += profit;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            Nodes[i].lwi = lastCalcIndex;\\r\\n            \\r\\n            if(cup \\u003e 0){\\r\\n                cup = PaymentToken.balanceOf(address(this)) \\u003e= cup  ? cup : PaymentToken.balanceOf(address(this));\\r\\n                PaymentToken.transfer(ad, cup);\\r\\n                hasBonus = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        require(hasBonus , \\\"Total users\\u0027 balances is currently zero.\\\");\\r\\n        \\r\\n        canWithdraw = false; \\r\\n        uint256 bonus = withdrawPool; \\r\\n        withdrawPool = 0;\\r\\n\\r\\n        bonus = PaymentToken.balanceOf(address(this)) \\u003e= bonus  ? bonus : PaymentToken.balanceOf(address(this));\\r\\n        PaymentToken.transfer(msg.sender, bonus);\\r\\n\\r\\n    }\\r\\n \\r\\n    function Withdraw() public {\\r\\n        checkLastCalc();\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0 , \\\"Permission Denied!\\\");\\r\\n\\r\\n        address ad = Nodes[userId].ad;\\r\\n        uint16 baseUWI = Nodes[userId].lwi;\\r\\n\\r\\n        uint256 cup = 0;\\r\\n        for(uint16 i = baseUWI ; i\\u003c lastCalcIndex; i++){\\r\\n            if(pool[i].sumParity \\u003e 0){ \\r\\n                uint256 profit =(pool[i].sumDeposit * pool[i].userParity[ad]) / pool[i].sumParity ;\\r\\n                if(profit \\u003e 0){ \\r\\n                    cup +=profit;\\r\\n                }\\r\\n\\r\\n            }\\r\\n        }\\r\\n        Nodes[userId].lwi = lastCalcIndex; \\r\\n\\r\\n        cup = PaymentToken.balanceOf(address(this)) \\u003e= cup  ? cup : PaymentToken.balanceOf(address(this));\\r\\n        \\r\\n        if(cup \\u003e 0){\\r\\n            PaymentToken.transfer(ad, cup);\\r\\n        }\\r\\n    }\\r\\n \\r\\n    function MyWithdrawableProfit() public view returns (uint256){\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0 , \\\"Permission Denied!\\\");\\r\\n\\r\\n        address ad = Nodes[userId].ad;\\r\\n        uint16 baseUWI = Nodes[userId].lwi;\\r\\n\\r\\n        uint256 cup = 0;\\r\\n        for(uint16 i = baseUWI ; i\\u003c lastCalcIndex; i++){\\r\\n            if(pool[i].sumParity \\u003e 0){ \\r\\n\\r\\n                uint256 profit =(pool[i].sumDeposit * pool[i].userParity[ad]) / pool[i].sumParity ;\\r\\n                if(profit \\u003e 0){ \\r\\n                    cup +=profit;\\r\\n                }\\r\\n\\r\\n            }\\r\\n        } \\r\\n\\r\\n        return cup;\\r\\n    }\\r\\n  \\r\\n    function TotalUsers() external view returns(uint32){return totalUsers;}\\r\\n    \\r\\n    function MyParityCountToday() public view returns(uint24){\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0 , \\\"You are not registered.\\\"); \\r\\n        return pool[lastCalcIndex].userParity[msg.sender];\\r\\n    }\\r\\n    \\r\\n    function MyProfitToday() public view returns(uint256){\\r\\n        return userProfitToday(msg.sender);\\r\\n    }\\r\\n\\r\\n    function userProfitToday(address ad) internal view returns(uint256){\\r\\n        require(uids[ad] \\u003e 0 , \\\"You are not registered.\\\"); \\r\\n        if(pool[lastCalcIndex].sumParity == 0){\\r\\n            return 0;\\r\\n        }\\r\\n        return (pool[lastCalcIndex].sumDeposit * pool[lastCalcIndex].userParity[ad]) / pool[lastCalcIndex].sumParity  ;\\r\\n    } \\r\\n\\r\\n    function MyAllTimeProfit() internal view returns(uint256){\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0 , \\\"You are not registered.\\\"); \\r\\n        uint256 sumProfit = 0;\\r\\n        for(uint16 i = Nodes[userId].rwi ; i\\u003c lastCalcIndex ; i++){\\r\\n            if(pool[i].sumParity \\u003e 0){\\r\\n                sumProfit +=  (pool[i].sumDeposit * pool[i].userParity[msg.sender]) / pool[i].sumParity ;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return sumProfit;\\r\\n    } \\r\\n\\r\\n    function TodayPoolAmount() public view returns(uint256){\\r\\n        return pool[lastCalcIndex].sumDeposit;\\r\\n    }\\r\\n\\r\\n    function TodayTotalParity() public view returns(uint24){\\r\\n        return pool[lastCalcIndex].sumParity;\\r\\n    }\\r\\n      \\r\\n    function LotteryPoolAmount() public view returns(uint256){\\r\\n        return lotteryPool;\\r\\n    }\\r\\n    \\r\\n    function UserDirects(address userAddress) public view returns(address , address){\\r\\n        return (\\r\\n            children[userAddress][0],\\r\\n            children[userAddress][1]\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function MyDirects() public view returns(address , address){\\r\\n        return UserDirects(msg.sender);\\r\\n    }\\r\\n\\r\\n    function getSystemData() public view returns(uint256,uint256,uint256,uint256,uint32,bool){\\r\\n        return (                                    \\r\\n            LotteryPoolAmount(),\\r\\n            TodayTotalParity(),\\r\\n            TodayPoolAmount(),\\r\\n            withdrawPool,\\r\\n            totalUsers,\\r\\n            canWithdraw\\r\\n       );\\r\\n    }\\r\\n\\r\\n    function getUserCap() public view returns(uint24 , uint24){\\r\\n         uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0, \\\"System: You are not registered!\\\");\\r\\n        uint24 lc =  Nodes[userId].LCap;\\r\\n        uint24 rc =  Nodes[userId].RCap;\\r\\n        return (lc, rc);\\r\\n    }\\r\\n\\r\\n    function getUserData() public view returns(uint256,uint256,uint256,address,address,address,uint8,uint32,uint256 , uint24){\\r\\n        uint32 userId = uids[msg.sender];\\r\\n        require(userId \\u003e 0, \\\"System: You are not registered!\\\");\\r\\n        address D1 = children[msg.sender][0];\\r\\n        address D2 = children[msg.sender][1];\\r\\n        uint8 levelId = Nodes[userId].ln;\\r\\n        uint32 allTimeP = Nodes[userId].allTimeParity;\\r\\n        uint256 lotWins = lotteryPerUser[msg.sender];\\r\\n        return (                                    \\r\\n            MyProfitToday(),\\r\\n            MyWithdrawableProfit(),\\r\\n            MyAllTimeProfit(),\\r\\n            parent[msg.sender],\\r\\n            D1,\\r\\n            D2,\\r\\n            levelId,\\r\\n            allTimeP,\\r\\n            lotWins,\\r\\n            MyParityCountToday()\\r\\n       );\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(account)\\r\\n        }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance \\u003e= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n    function functionCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance \\u003e= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n    function _functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 weiValue,\\r\\n        string memory errorMessage\\r\\n    ) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\r\\n            data\\r\\n        );\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        IERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        require(\\r\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) +\\r\\n            (value);\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n    function safeDecreaseAllowance(\\r\\n        IERC20 token,\\r\\n        address spender,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender) -\\r\\n            (value);\\r\\n        _callOptionalReturn(\\r\\n            token,\\r\\n            abi.encodeWithSelector(\\r\\n                token.approve.selector,\\r\\n                spender,\\r\\n                newAllowance\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        bytes memory returndata = address(token).functionCall(\\r\\n            data,\\r\\n            \\\"SafeERC20: low-level call failed\\\"\\r\\n        );\\r\\n        if (returndata.length \\u003e 0) {\\r\\n            require(\\r\\n                abi.decode(returndata, (bool)),\\r\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n \\r\\n\"},\"Storage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract Storage is Ownable { \\r\\n    uint24 internal calcPeriod = 43200;\\r\\n    uint16 internal basePrice = 20;\\r\\n    uint16 internal lastCalcIndex = 1;\\r\\n    uint256 lastCalc = block.timestamp - (block.timestamp % 86400); //  Deployment day at 00:00:00 UTC    \\r\\n    bool internal canWithdraw;\\r\\n\\r\\n\\r\\n    struct Level{\\r\\n        uint256 price;\\r\\n        uint8  parityAmount;\\r\\n        uint16 perDay;\\r\\n    }\\r\\n    \\r\\n    mapping (uint8 =\\u003e Level)  internal Levels;\\r\\n    \\r\\n    struct Node {\\r\\n        address ad;\\r\\n        uint24 LCap;\\r\\n        uint24 RCap;\\r\\n        uint8 ln;\\r\\n        uint16 lwi;\\r\\n        uint32 allTimeParity;\\r\\n        uint256 registerTime;\\r\\n        uint16 rwi;\\r\\n        bool isLeaved;\\r\\n    }\\r\\n    \\r\\n    mapping (uint32 =\\u003e Node) internal Nodes;\\r\\n\\r\\n    uint32 internal totalUsers = 0;\\r\\n \\r\\n    IERC20 PaymentToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\\r\\n    \\r\\n    uint256 internal withdrawPool;\\r\\n    uint256 internal lotteryPool;\\r\\n\\r\\n    struct PoolStruct {\\r\\n        uint256 sumDeposit;\\r\\n        uint24  sumParity;    \\r\\n        mapping(address =\\u003e uint24) userParity;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    mapping (uint16=\\u003ePoolStruct) internal pool;\\r\\n    mapping (address =\\u003e address) internal parent;\\r\\n    mapping (address =\\u003e mapping (uint8 =\\u003e address)) internal children;\\r\\n    mapping (address =\\u003e uint32) internal uids;\\r\\n    \\r\\n    \\r\\n    uint8[5] pl = [1,3,5,10,0xff]; \\r\\n    mapping(address =\\u003e uint256) internal lotteryPerUser;\\r\\n    mapping(address =\\u003e uint256) internal lotteryPerUserTime;\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LeaveNetwork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"levelId\",\"type\":\"uint8\"}],\"name\":\"LevelUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LotteryPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyDirects\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyParityCountToday\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyProfitToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyWithdrawableProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"levelId\",\"type\":\"uint8\"}],\"name\":\"Register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SmartLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TodayPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TodayTotalParity\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalUsers\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"UserDirects\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserCap\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BSCSunRise", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1c26df4f5004e1a51564af0aeb83cc19c05b3e7c65c824b5348f3723fdf3e7fa"}