{"SourceCode": "{\"AltrucoinERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity ^0.7.5;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IOHM.sol\\\";\\r\\nimport \\\"./IERC20Permit.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\n\\r\\nimport \\\"./ERC20Permit.sol\\\";\\r\\nimport \\\"./OlympusAccessControlled.sol\\\";\\r\\n\\r\\ncontract AltrucoinERC20Token is ERC20Permit, IOHM, OlympusAccessControlled {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    //--------VARIABLES---------//\\r\\n\\r\\n    // Multisig Protocol Wallets\\r\\n    address payable public developmentAddress = payable(0x6EC3D658A79fEbB2Fa87a92C66Fd2A3ddd495B74); // Multisig Protocol Wallet\\r\\n    address payable public charityAddress = payable(0x8cd3282F41ae28Ea2efBcEA59dA7392503DcD46b); // Multisig Protocol Wallet\\r\\n    address payable public vaultAddress = payable(0x12Fc3CCd4C8BCA5c03a49397B136223552eB0763); //TODO Replace after vault launch \\r\\n    address payable public liquidityAddress = payable(address(this)); \\r\\n\\r\\n    mapping (address =\\u003e bool) private _isExcludedFromFee;\\r\\n    mapping (address =\\u003e bool) private blacklist; \\r\\n\\r\\n    // Protocol Fees\\r\\n    uint256 public burnFee = 100;\\r\\n    uint256 public charityFee = 100;\\r\\n    uint256 public vaultFee = 400;\\r\\n    uint256 public devFee = 400;\\r\\n    uint256 public liquidityFee = 0;\\r\\n    uint256 public divisorNum = 10000; \\r\\n\\r\\n    //Minimums before sending tokens from contract to destinations\\r\\n    uint256 private burnMinSend = 0;\\r\\n    uint256 private charityMinSend = 0;\\r\\n    uint256 private vaultMinSend = 0;\\r\\n    uint256 private devMinSend = 0;\\r\\n\\r\\n    //Running totals \\r\\n    uint256 private burnRunningTotal = 0;\\r\\n    uint256 private charityRunningTotal = 0;\\r\\n    uint256 private devRunningTotal = 0;\\r\\n    uint256 private vaultRunningTotal = 0;\\r\\n\\r\\n    //Liquidity swaping variables\\r\\n    uint256 private _startTimeForSwap;\\r\\n    uint256 private _intervalMinutesForSwap = 1 * 1 minutes;\\r\\n    uint256 public minimumTokensBeforeSwap = 1; //Breaks if set to 0\\r\\n\\r\\n    //Mode settings\\r\\n    bool private _bmode = true;\\r\\n    bool public tradingOpen = false;\\r\\n\\r\\n    //Pancakeswap variables\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    address public uniswapV2Pair;\\r\\n    IERC20 private feeOutToken;\\r\\n    \\r\\n    //Swap and liquify settings\\r\\n    bool inSwapAndLiquify;\\r\\n    bool public swapAndLiquifyEnabled = false;\\r\\n    \\r\\n\\r\\n    //--------EVENTS--------//\\r\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\r\\n    event Bmode(bool enabled);\\r\\n    event SwapAndLiquifyBNB(\\r\\n        uint256 BNBSwapped,\\r\\n        uint256 TokensReceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n    event SwapAndLiquifyTokens(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n    \\r\\n    event SwapETHForTokens(\\r\\n        uint256 amountIn,\\r\\n        address[] path\\r\\n    );\\r\\n    \\r\\n    event SwapTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        address[] path\\r\\n    );\\r\\n\\r\\n    event SwapStakingTokensForSecondTokens(\\r\\n        uint256 amountIn,\\r\\n        address[] path\\r\\n    );\\r\\n    \\r\\n    modifier lockTheSwap {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n    \\r\\n    constructor(address _authority) \\r\\n    ERC20(\\\"Altrucoin\\\", \\\"ALTRU\\\", 18) \\r\\n    ERC20Permit(\\\"Altrucoin\\\") \\r\\n    OlympusAccessControlled(IOlympusAuthority(_authority)) {\\r\\n\\r\\n        //IOHM(address(this)).mint(msg.sender, 250000000);\\r\\n\\r\\n        feeOutToken = IERC20(0x55d398326f99059fF775485246999027B3197955); // BSC BEP20 USDT MAINNET\\r\\n\\r\\n        //feeOutToken = IERC20(0x337610d27c682E347C9cD60BD4b3b107C9d34dDd); // TETSNET BSC BEP20 USDT\\r\\n        \\r\\n        //MAINNET PCS Router: 0x10ED43C718714eb63d5aA57B78B54704E256024E\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n\\r\\n        // TESTNET PCS Router: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1\\r\\n        //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0xD99D1c33F9fC3444f8101754aBC46c52416550D1);\\r\\n\\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\r\\n            .createPair(address(this), _uniswapV2Router.WETH());\\r\\n\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n\\r\\n        // Protocol Multisig Wallets\\r\\n        _isExcludedFromFee[authority.governor()] = true;\\r\\n        _isExcludedFromFee[liquidityAddress] = true;\\r\\n        _isExcludedFromFee[developmentAddress] = true;\\r\\n        _isExcludedFromFee[vaultAddress] = true;\\r\\n        _isExcludedFromFee[charityAddress] = true;\\r\\n\\r\\n        _startTimeForSwap = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function mint(address account_, uint256 amount_) external override onlyVault {\\r\\n        _mint(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) external override {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) external override {\\r\\n        _burnFrom(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function _burnFrom(address account_, uint256 amount_) internal {\\r\\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(amount_, \\\"ERC20: burn amount exceeds allowance\\\");\\r\\n\\r\\n        _approve(account_, msg.sender, decreasedAllowance_);\\r\\n        _burn(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override (ERC20, IERC20) returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public override (ERC20, IERC20) returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function _transfer(address from, address to, uint256 amount) internal override (ERC20) {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n\\r\\n        //Blacklist, trading open and max TX checks\\r\\n        if(from != authority.governor() \\u0026\\u0026 to != authority.governor() \\u0026\\u0026 ! _isExcludedFromFee[to] \\u0026\\u0026 ! _isExcludedFromFee[from]) {\\r\\n            if(_bmode == true){\\r\\n                require(blacklist[from] != true, \\\"No blacklist transactions during antiblacklistmode.\\\");\\r\\n            }\\r\\n            if(tradingOpen == false){\\r\\n                require( _isExcludedFromFee[to] || _isExcludedFromFee[from], \\\"Trading paused temporarily.\\\");\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        // If any account belongs to _isExcludedFromFee account then send without fees\\r\\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\\r\\n            _beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n            _balances[from] = _balances[from].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n            _balances[to] = _balances[to].add(amount);\\r\\n\\r\\n            emit Transfer(from, to, amount);\\r\\n        }\\r\\n\\r\\n        else{ //Transfer and take fees\\r\\n\\r\\n            //Calculate Fees\\r\\n            uint256 vaultAmount = amount.mul(vaultFee).div(divisorNum);\\r\\n            uint256 charityAmount = amount.mul(charityFee).div(divisorNum);\\r\\n            uint256 developmentAmount = amount.mul(devFee).div(divisorNum);\\r\\n            uint256 liquidityAmount = amount.mul(liquidityFee).div(divisorNum);\\r\\n            uint256 burnAmount = amount.mul(burnFee).div(divisorNum);\\r\\n\\r\\n            //Send all fees as 1 tx to token contract to save gas\\r\\n            uint256 feeTotal = charityAmount.add(developmentAmount).add(vaultAmount).add(liquidityAmount).add(burnAmount);\\r\\n            if(feeTotal \\u003e 0){\\r\\n                _beforeTokenTransfer(from, address(this), feeTotal);\\r\\n\\r\\n                //All fees to contract\\r\\n                _balances[from] = _balances[from].sub(feeTotal, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n                _balances[liquidityAddress] = _balances[liquidityAddress].add(feeTotal);\\r\\n            }\\r\\n\\r\\n            //Add to thresholds\\r\\n            vaultRunningTotal = vaultRunningTotal.add(vaultAmount);\\r\\n            charityRunningTotal = charityRunningTotal.add(charityAmount);\\r\\n            devRunningTotal = devRunningTotal.add(developmentAmount);\\r\\n            burnRunningTotal = burnRunningTotal.add(burnAmount);\\r\\n\\r\\n            //Send to vault only if above threshold to save gas\\r\\n            if(vaultRunningTotal \\u003e= vaultMinSend){\\r\\n                IERC20(address(this)).transfer(vaultAddress, vaultRunningTotal);\\r\\n                vaultRunningTotal = 0;\\r\\n            }\\r\\n            //Swap and send tokens to charity wallet only if above threshold to save gas\\r\\n            if(charityRunningTotal \\u003e= charityMinSend){\\r\\n                swapStakingTokensForSecondTokens(charityRunningTotal, address(this), feeOutToken, charityAddress);\\r\\n                charityRunningTotal = 0;\\r\\n            }\\r\\n            //swap and send tokens to dev address only if above threshold to save gas\\r\\n            if(devRunningTotal \\u003e= devMinSend){\\r\\n                swapStakingTokensForSecondTokens(devRunningTotal, address(this), feeOutToken, developmentAddress);\\r\\n                devRunningTotal = 0; \\r\\n            }\\r\\n            //Burn tokens only if above threshold to save gas\\r\\n            if(burnRunningTotal \\u003e= burnMinSend){\\r\\n                IOHM(address(this)).burn(burnRunningTotal);\\r\\n                burnRunningTotal = 0; \\r\\n            }\\r\\n\\r\\n            // Sell tokens for ETH\\r\\n            if (!inSwapAndLiquify \\u0026\\u0026 swapAndLiquifyEnabled \\u0026\\u0026 balanceOf(uniswapV2Pair) \\u003e 0 \\u0026\\u0026 to == uniswapV2Pair) {\\r\\n                //Check to see if enough tokens for swap and liquify\\r\\n                uint256 contractTokenBalance = balanceOf(address(this)).sub(vaultRunningTotal).sub(charityRunningTotal).sub(devRunningTotal).sub(burnRunningTotal);    \\r\\n\\r\\n                if (contractTokenBalance \\u003e= minimumTokensBeforeSwap \\u0026\\u0026 _startTimeForSwap + _intervalMinutesForSwap \\u003c= block.timestamp) {\\r\\n                    _startTimeForSwap = block.timestamp;\\r\\n                    contractTokenBalance = minimumTokensBeforeSwap;\\r\\n                    swapAndLiquify(contractTokenBalance);\\r\\n                }  \\r\\n            }\\r\\n\\r\\n            //Send remaining tokens to user\\r\\n            uint256 sendAmount = amount.sub(feeTotal);\\r\\n            _beforeTokenTransfer(from, to, sendAmount);\\r\\n\\r\\n            require(_balances[from] \\u003e= sendAmount, \\\"ERC20: transfer exceeds balance\\\");\\r\\n            _balances[from] = _balances[from].sub(sendAmount);\\r\\n            _balances[to] = _balances[to].add(sendAmount);\\r\\n\\r\\n            emit Transfer(from, to, sendAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\\r\\n\\r\\n        if(liquidityFee != 0){\\r\\n            // split the contract balance into halves\\r\\n            uint256 half = contractTokenBalance.div(2);\\r\\n            uint256 otherHalf = contractTokenBalance.sub(half);\\r\\n\\r\\n            // capture the contract\\u0027s current ETH balance.\\r\\n            // this is so that we can capture exactly the amount of ETH that the\\r\\n            // swap creates, and not make the liquidity event include any ETH that\\r\\n            // has been manually sent to the contract\\r\\n            uint256 initialBalance = address(this).balance;\\r\\n\\r\\n            // swap tokens for ETH\\r\\n            swapTokensForEth(half);\\r\\n\\r\\n            // how much ETH did we just swap into?\\r\\n            uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n\\r\\n            // add liquidity to pancakeswap\\r\\n            addLiquidity(otherHalf, newBalance);\\r\\n            \\r\\n            emit SwapAndLiquify(half, newBalance, otherHalf);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*------------FEE EXCLUDING FUNCITONS---------*/\\r\\n    \\r\\n    function isExcludedFromFee(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFee[account];\\r\\n    }\\r\\n    \\r\\n    function excludeFromFee(address account) public onlyGovernor {\\r\\n        _isExcludedFromFee[account] = true;\\r\\n    }\\r\\n    \\r\\n    function includeInFee(address account) public onlyGovernor {\\r\\n        _isExcludedFromFee[account] = false;\\r\\n    }\\r\\n\\r\\n    /*------------BLACKLIST FUNCTIONS---------*/\\r\\n\\r\\n    // Toggle trading enabled\\r\\n    function setTradingOpen(bool _status) public onlyGovernor {\\r\\n        tradingOpen = _status;\\r\\n    }\\r\\n\\r\\n    //Toggle blacklist mode\\r\\n    function setBmode(bool _enabled) public onlyGovernor {\\r\\n        _bmode = _enabled;\\r\\n        emit Bmode(_enabled);\\r\\n    }\\r\\n\\r\\n    //Add to blacklist\\r\\n    function setBlacklist(address[] memory blacklist_) public onlyGovernor {\\r\\n        for (uint i = 0; i \\u003c blacklist_.length; i++) {\\r\\n            blacklist[blacklist_[i]] = true;\\r\\n        }\\r\\n    }\\r\\n    //Remove from blacklist\\r\\n    function delBlacklist(address notblacklist) public onlyGovernor {\\r\\n        blacklist[notblacklist] = false;\\r\\n    }\\r\\n\\r\\n    function checkIfOnBlacklist(address _address) view public onlyGovernor returns(bool){\\r\\n        return blacklist[_address];\\r\\n    }\\r\\n\\r\\n\\r\\n    /*------------SWAPANDLIQUIFY CONTROLS---------*/\\r\\n\\r\\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyGovernor {\\r\\n        swapAndLiquifyEnabled = _enabled;\\r\\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\\r\\n    }\\r\\n\\r\\n    // newMinutes is in minutes\\r\\n    function SetSwapMinutes(uint256 newMinutes) external onlyGovernor {\\r\\n        _intervalMinutesForSwap = newMinutes * 1 minutes;\\r\\n    }\\r\\n\\r\\n    function setMinimumTokensBeforeSwap(uint256 _minimumTokensBeforeSwap) external onlyGovernor {\\r\\n        minimumTokensBeforeSwap = _minimumTokensBeforeSwap;\\r\\n    }\\r\\n    \\r\\n\\r\\n    /*------------TX FEE CONTROLS---------*/\\r\\n    \\r\\n    // 10000 makes 100 = 1% on all fees\\r\\n    function setFeeDivisorNum(uint256 divisorNumSet) external onlyGovernor {\\r\\n        divisorNum = divisorNumSet;\\r\\n    }\\r\\n    // 100 = 1%\\r\\n    function setDevFeePercent(uint256 devFeeSet, uint256 burnFeeSet, uint256 charityFeeSet, uint256 vaultFeeSet, uint256 liquidityFeeSet) external onlyGovernor() {\\r\\n        devFee = devFeeSet;\\r\\n        burnFee = burnFeeSet;\\r\\n        charityFee = charityFeeSet;\\r\\n        vaultFee = vaultFeeSet;\\r\\n        liquidityFee = liquidityFeeSet;\\r\\n    }\\r\\n\\r\\n    //Fee min sends (this saves gas for users on normal transactions)\\r\\n    function setMinSends(uint256 _burnMinSend, uint256 _charityMinSend, uint256 _vaultMinSend, uint256 _devMinSend) external onlyGovernor {\\r\\n        burnMinSend = _burnMinSend;\\r\\n        charityMinSend = _charityMinSend;\\r\\n        vaultMinSend = _vaultMinSend;\\r\\n        devMinSend = _devMinSend;\\r\\n    }\\r\\n\\r\\n\\r\\n    /*------------FEE DESTINATION ADDRESSES---------*/\\r\\n\\r\\n    function setDevelopmentAddress(address _developmentAddress) external onlyGovernor {\\r\\n        developmentAddress = payable(_developmentAddress);\\r\\n        _isExcludedFromFee[developmentAddress] = true;\\r\\n    }\\r\\n\\r\\n    function setCharityAddress(address _charityAddress) external onlyGovernor {\\r\\n        charityAddress = payable(_charityAddress);\\r\\n        _isExcludedFromFee[charityAddress] = true;\\r\\n    }\\r\\n\\r\\n    function setVaultAddress(address _vaultAddress) external onlyGovernor {\\r\\n        vaultAddress = payable(_vaultAddress);\\r\\n        _isExcludedFromFee[vaultAddress] = true;\\r\\n    }\\r\\n\\r\\n    function setLiquidityAddress(address _liquidityAddress) external onlyGovernor {\\r\\n        liquidityAddress = payable(_liquidityAddress);\\r\\n        _isExcludedFromFee[liquidityAddress] = true;\\r\\n    }\\r\\n\\r\\n    //Set the BEP20 token used for charity and development fees\\r\\n    function setFeeOutTokenAddress(address _feeOutToken) external onlyGovernor {\\r\\n        feeOutToken = IERC20(_feeOutToken);\\r\\n    }\\r\\n    \\r\\n\\r\\n    //--------PRESALE FUNCTIONS---------//\\r\\n\\r\\n    function prepareForPreSale() external onlyGovernor {\\r\\n        //All modes false\\r\\n        setSwapAndLiquifyEnabled(false);\\r\\n        setBmode(false);\\r\\n        setTradingOpen(false);\\r\\n\\r\\n        //Turn off all fees\\r\\n        burnFee = 0;\\r\\n        charityFee = 0;\\r\\n        vaultFee = 0;\\r\\n        devFee = 0;\\r\\n        liquidityFee = 0;\\r\\n    }\\r\\n\\r\\n    function afterPreSale() external onlyGovernor {\\r\\n        //Turn on modes\\r\\n        setSwapAndLiquifyEnabled(true); //swap and liquify\\r\\n        setBmode(true); //blacklist\\r\\n\\r\\n        //Set fees\\r\\n        burnFee = 100;\\r\\n        charityFee = 100;\\r\\n        vaultFee = 400;\\r\\n        devFee = 400;\\r\\n        liquidityFee = 0;\\r\\n\\r\\n        //change min sends after testing\\r\\n        burnMinSend = 150000000000000000000000;\\r\\n        charityMinSend = 250000000000000000000000;\\r\\n        vaultMinSend = 150000000000000000000000;\\r\\n        devMinSend = 250000000000000000000000;\\r\\n\\r\\n        minimumTokensBeforeSwap = 150000000000000000000000;\\r\\n\\r\\n        //Turn on trading\\r\\n        setTradingOpen(true);\\r\\n    }\\r\\n\\r\\n\\r\\n    //--------PANCAKESWAP SWAP FUNCTIONS----------------//\\r\\n\\r\\n    //Swap Altrucoin for BNB\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n        // Generate the uniswap pair path of token -\\u003e WETH\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // Make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // Accept any amount of ETH\\r\\n            path,\\r\\n            address(this), // The contract\\r\\n            block.timestamp\\r\\n        );\\r\\n        \\r\\n        emit SwapTokensForETH(tokenAmount, path);\\r\\n    }\\r\\n\\r\\n    //Swap from firstToken to tokenSwapping\\r\\n    function swapStakingTokensForSecondTokens(uint256 amount, address firstToken, IERC20 tokenSwapping, address destination) private {\\r\\n        // Generate the pancakeswap pair path of token -\\u003e WETH\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(firstToken);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        path[2] = address(tokenSwapping);\\r\\n\\r\\n        _approve(address(this), address(uniswapV2Router), amount);\\r\\n      // Make the swap\\r\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0, // Accept any amount of Tokens\\r\\n            path,\\r\\n            address(destination), // Vault address\\r\\n            block.timestamp.add(300)\\r\\n        );\\r\\n        \\r\\n        emit SwapStakingTokensForSecondTokens(amount, path);\\r\\n    }\\r\\n\\r\\n    //Swap from BNB to Altrucoin, tokens end up on contract\\r\\n    function swapETHForTokensToHere(uint256 amount) private {\\r\\n        // Generate the uniswap pair path of token -\\u003e WETH\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = uniswapV2Router.WETH();\\r\\n        path[1] = address(this);\\r\\n\\r\\n      // Make the swap\\r\\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\\r\\n            0, // Accept any amount of Tokens\\r\\n            path,\\r\\n            address(this), // Contract address\\r\\n            block.timestamp.add(300)\\r\\n        );\\r\\n        \\r\\n        emit SwapETHForTokens(amount, path);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*------------LIQUIDITY SWAPING FUNCTIONS---------*/\\r\\n\\r\\n    //Add liquidity on PCS\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // Approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n\\r\\n        // Add the liquidity\\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // Slippage is unavoidable\\r\\n            0, // Slippage is unavoidable\\r\\n            authority.governor(), //Contract Owner\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //Create additional liquidity using BNB tokens in contract\\r\\n    function manualSwapAndLiquifyBNB(uint256 bnbLiquifyAmount) external lockTheSwap onlyGovernor {\\r\\n        // split the contract balance into halves\\r\\n        uint256 half = bnbLiquifyAmount.div(2); // WBNB\\r\\n        uint256 otherHalf = bnbLiquifyAmount.sub(half); // WBNB not swapped\\r\\n\\r\\n        // capture the contract\\u0027s current Token balance.\\r\\n        // this is so that we can capture exactly the amount of Tokens that the\\r\\n        // swap creates, and not make the liquidity event include any Tokens that\\r\\n        // has been manually sent to the contract\\r\\n        uint256 initialTokenBalance = balanceOf(address(this));\\r\\n\\r\\n        // swap ETH for Tokens\\r\\n        swapETHForTokensToHere(half); \\r\\n\\r\\n        // how much Tokens did we just swap into?\\r\\n        uint256 newTokenBalance = balanceOf(address(this)).sub(initialTokenBalance);\\r\\n\\r\\n        // add liquidity to uniswap\\r\\n        addLiquidity(newTokenBalance, otherHalf);\\r\\n        \\r\\n        emit SwapAndLiquifyBNB(half, newTokenBalance, otherHalf);\\r\\n    }\\r\\n\\r\\n    //Create additional liquidity using BankerDoge tokens in contract\\r\\n    function manualSwapAndLiquifyTokens(uint256 tokenLiquifyAmount) external lockTheSwap onlyGovernor{\\r\\n        // split the contract balance into halves\\r\\n        uint256 half = tokenLiquifyAmount.div(2); //staking tokens to be swaped\\r\\n        uint256 otherHalf = tokenLiquifyAmount.sub(half); //staking tokens not swapped\\r\\n\\r\\n        // capture the contract\\u0027s current ETH balance.\\r\\n        // this is so that we can capture exactly the amount of ETH that the\\r\\n        // swap creates, and not make the liquidity event include any ETH that\\r\\n        // has been manually sent to the contract\\r\\n        uint256 initialBalance = address(this).balance;\\r\\n\\r\\n        // swap tokens for ETH\\r\\n        swapTokensForEth(half);\\r\\n\\r\\n        // how much ETH did we just swap into?\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n\\r\\n        // add liquidity to uniswap\\r\\n        addLiquidity(otherHalf, newBalance);\\r\\n        \\r\\n        emit SwapAndLiquifyTokens(half, newBalance, otherHalf);\\r\\n    }\\r\\n    \\r\\n\\r\\n    /*------------SAFETY FUNCTIONS---------*/\\r\\n\\r\\n    // Recommended to add by certik: For stuck tokens (as a result of slight miscalculations/rounding errors) \\r\\n    function SweepStuck(uint256 _amount) external onlyGovernor {\\r\\n        payable(authority.governor()).transfer(_amount);\\r\\n    }\\r\\n\\r\\n    // for stuck tokens of other types\\r\\n    function transferForeignToken(address _token, address _to) public onlyGovernor returns(bool _sent){\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*-------------LIQUIDITY POOL CONTROL FUNCTIONS-----------*/\\r\\n\\r\\n    function changeRouterVersion(address _router) public onlyGovernor returns(address _pair) {\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_router);\\r\\n        \\r\\n        _pair = IUniswapV2Factory(_uniswapV2Router.factory()).getPair(address(this), _uniswapV2Router.WETH());\\r\\n        if(_pair == address(0)){\\r\\n            // Pair doesn\\u0027t exist\\r\\n            _pair = IUniswapV2Factory(_uniswapV2Router.factory())\\r\\n            .createPair(address(this), _uniswapV2Router.WETH());\\r\\n        }\\r\\n        uniswapV2Pair = _pair;\\r\\n\\r\\n        // Set the router of the contract variables\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n    }\\r\\n\\r\\n    //Use when new router is released but pair hasnt been created yet.\\r\\n    //Make sure to add initial liquidity manually after pair is made! Otherwise swapAndLiquify will fail.\\r\\n    function setRouterAddressAndCreatePair(address newRouter) public onlyGovernor() {\\r\\n        IUniswapV2Router02 _newPancakeRouter = IUniswapV2Router02(newRouter);\\r\\n        uniswapV2Pair = IUniswapV2Factory(_newPancakeRouter.factory()).createPair(address(this), _newPancakeRouter.WETH());\\r\\n        uniswapV2Router = _newPancakeRouter;\\r\\n    }\\r\\n    \\r\\n    //Use when new router is released and pair HAS been created already.\\r\\n    function setRouterAddress(address newRouter) public onlyGovernor() {\\r\\n        IUniswapV2Router02 _newPancakeRouter = IUniswapV2Router02(newRouter);\\r\\n        uniswapV2Router = _newPancakeRouter;\\r\\n    }\\r\\n    \\r\\n    //Use when new router is released and pair HAS been created already.\\r\\n    function setPairAddress(address newPair) public onlyGovernor() {\\r\\n        uniswapV2Pair = newPair;\\r\\n    }\\r\\n    \\r\\n    // To receive ETH from uniswapV2Router when swapping\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"},\"Counters.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library\\u0027s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.5;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature \\u0027v\\u0027 value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 \\u0026\\u0026 v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\"},\"EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.5;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = chainID;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        if (chainID == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, chainID, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity \\u003e=0.7.5;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\nabstract contract ERC20 is IERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    // TODO comment actual hash value.\\n    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( \\\"ERC20Token\\\" );\\n    \\n    mapping (address =\\u003e uint256) internal _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string internal _name;\\n    \\n    string internal _symbol;\\n    \\n    uint8 internal immutable _decimals;\\n\\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address(0), account, amount);\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\\n}\\n\"},\"ERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.5;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./EIP712.sol\\\";\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"./Counters.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account\\u0027s ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn\\u0027t\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address =\\u003e Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It\\u0027s a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp \\u003c= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity \\u003e=0.7.5;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.7.5;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account\\u0027s ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn\\u0027t\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as th xe allowance of `spender` over ``owner``\\u0027s tokens,\\n     * given ``owner``\\u0027s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``\\u0027s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``\\u0027s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"},\"IOHM.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity \\u003e=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IOHM is IERC20 {\\n  function mint(address account_, uint256 amount_) external;\\n\\n  function burn(uint256 amount) external;\\n\\n  function burnFrom(address account_, uint256 amount_) external;\\n}\\n\"},\"IOlympusAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity \\u003e=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"},\"IUniswapV2ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity \\u003e=0.7.5;\\n\\ninterface IUniswapV2ERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"},\"IUniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity \\u003e=0.7.5;\\n\\nimport \\\"./IUniswapV2ERC20.sol\\\";\\n\\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\\n    function token0() external pure returns (address);\\n    function token1() external pure returns (address);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function mint(address to) external returns (uint liquidity);\\n    function sync() external;\\n}\"},\"IUniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\r\\n\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\n\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"},\"OlympusAccessControlled.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.7.5;\\n\\nimport \\\"./IOlympusAuthority.sol\\\";\\n\\nabstract contract OlympusAccessControlled {\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\\n\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n    \\n\\n    /* ========== MODIFIERS ========== */\\n    \\n    modifier onlyGovernor() {\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\n        _;\\n    }\\n    \\n    modifier onlyGuardian() {\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\n        _;\\n    }\\n    \\n    modifier onlyPolicy() {\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\n        _;\\n    }\\n    \\n    /* ========== GOV ONLY ========== */\\n    \\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n}\\n\"},\"OlympusAuthority.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity \\u003e=0.7.5;\\n\\nimport \\\"./IOlympusAuthority.sol\\\";\\n\\nimport \\\"./OlympusAccessControlled.sol\\\";\\n\\ncontract OlympusAuthority is IOlympusAuthority, OlympusAccessControlled {\\n\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public override governor;\\n\\n    address public override guardian;\\n\\n    address public override policy;\\n\\n    address public override vault;\\n\\n    address public newGovernor;\\n\\n    address public newGuardian;\\n\\n    address public newPolicy;\\n\\n    address public newVault;\\n\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(\\n        address _governor,\\n        address _guardian,\\n        address _policy,\\n        address _vault\\n    ) OlympusAccessControlled( IOlympusAuthority(address(this)) ) {\\n        governor = _governor;\\n        emit GovernorPushed(address(0), governor, true);\\n        guardian = _guardian;\\n        emit GuardianPushed(address(0), guardian, true);\\n        policy = _policy;\\n        emit PolicyPushed(address(0), policy, true);\\n        vault = _vault;\\n        emit VaultPushed(address(0), vault, true);\\n    }\\n\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function pushGovernor(address _newGovernor, bool _effectiveImmediately) external onlyGovernor {\\n        if( _effectiveImmediately ) governor = _newGovernor;\\n        newGovernor = _newGovernor;\\n        emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\\n    }\\n\\n    function pushGuardian(address _newGuardian, bool _effectiveImmediately) external onlyGovernor {\\n        if( _effectiveImmediately ) guardian = _newGuardian;\\n        newGuardian = _newGuardian;\\n        emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\\n    }\\n\\n    function pushPolicy(address _newPolicy, bool _effectiveImmediately) external onlyGovernor {\\n        if( _effectiveImmediately ) policy = _newPolicy;\\n        newPolicy = _newPolicy;\\n        emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\\n    }\\n\\n    function pushVault(address _newVault, bool _effectiveImmediately) external onlyGovernor {\\n        if( _effectiveImmediately ) vault = _newVault;\\n        newVault = _newVault;\\n        emit VaultPushed(vault, newVault, _effectiveImmediately);\\n    }\\n\\n\\n    /* ========== PENDING ROLE ONLY ========== */\\n\\n    function pullGovernor() external {\\n        require(msg.sender == newGovernor, \\\"!newGovernor\\\");\\n        emit GovernorPulled(governor, newGovernor);\\n        governor = newGovernor;\\n    }\\n\\n    function pullGuardian() external {\\n        require(msg.sender == newGuardian, \\\"!newGuard\\\");\\n        emit GuardianPulled(guardian, newGuardian);\\n        guardian = newGuardian;\\n    }\\n\\n    function pullPolicy() external {\\n        require(msg.sender == newPolicy, \\\"!newPolicy\\\");\\n        emit PolicyPulled(policy, newPolicy);\\n        policy = newPolicy;\\n    }\\n\\n    function pullVault() external {\\n        require(msg.sender == newVault, \\\"!newVault\\\");\\n        emit VaultPulled(vault, newVault);\\n        vault = newVault;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.7.5;\\n\\n\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a \\u003e 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b \\u003c c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"Bmode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BNBSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquifyBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquifyTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapETHForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapStakingTokensForSecondTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinutes\",\"type\":\"uint256\"}],\"name\":\"SetSwapMinutes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SweepStuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"afterPreSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"changeRouterVersion\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkIfOnBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notblacklist\",\"type\":\"address\"}],\"name\":\"delBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"divisorNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnbLiquifyAmount\",\"type\":\"uint256\"}],\"name\":\"manualSwapAndLiquifyBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLiquifyAmount\",\"type\":\"uint256\"}],\"name\":\"manualSwapAndLiquifyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareForPreSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"blacklist_\",\"type\":\"address[]\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setBmode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_charityAddress\",\"type\":\"address\"}],\"name\":\"setCharityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"devFeeSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnFeeSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"charityFeeSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultFeeSet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityFeeSet\",\"type\":\"uint256\"}],\"name\":\"setDevFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_developmentAddress\",\"type\":\"address\"}],\"name\":\"setDevelopmentAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"divisorNumSet\",\"type\":\"uint256\"}],\"name\":\"setFeeDivisorNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeOutToken\",\"type\":\"address\"}],\"name\":\"setFeeOutTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityAddress\",\"type\":\"address\"}],\"name\":\"setLiquidityAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burnMinSend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_charityMinSend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vaultMinSend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devMinSend\",\"type\":\"uint256\"}],\"name\":\"setMinSends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minimumTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"setMinimumTokensBeforeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPair\",\"type\":\"address\"}],\"name\":\"setPairAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouterAddressAndCreatePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setTradingOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"setVaultAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AltrucoinERC20Token", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000522363396b2646b77d1c62dd5eba927d571b48ea", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6ecd6a7640ae7dd535994c93acdc1d5c96431db214f5b32ead548c2f277430d5"}