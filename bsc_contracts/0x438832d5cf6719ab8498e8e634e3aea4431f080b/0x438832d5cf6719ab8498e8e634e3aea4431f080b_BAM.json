{"SourceCode": "// SPDX-License-Identifier: MIT License\r\npragma solidity ^0.8.9;\r\n\r\n/// @title BAM\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = 0xAcBb8962821fCc52ABcc8f337960d2061a97fC62;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n      emit OwnershipTransferred(_owner, address(0));\r\n      _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract BAM is Ownable, ReentrancyGuard {\r\n    uint256[5] public referralLevelCommission = [\r\n        10 * 100,\r\n        5 * 100,\r\n        3 * 100,\r\n        2 * 100,\r\n        1 * 100\r\n    ];\r\n\r\n    uint256 public constant percentageDivider = 10000;\r\n\r\n    uint256 public minimumStakeValue;\r\n    uint256 public maximumStakeValue; // Amount being sent by the user\r\n    uint256 public maxStakedBalance; // Total amount staked by the user\r\n    uint256 public maximumReturnPercentage;\r\n    uint256 public minimumWithdrawalAmount;\r\n    bool public isActive = true;\r\n\r\n    address public nextOwner;\r\n\r\n    uint256[] public pauseTime;\r\n    uint256[] public resumeTime;\r\n    // Indirect earnings to be updated as required. They will contribute to total earnings only if eligible\r\n    struct Stake {\r\n        bool isActive;\r\n        bool maxed;\r\n        uint256 stakedAmount; // amount staked\r\n        uint256 activeStake; // amount after fee deduction\r\n        uint256 dailyEarningsBeforeFee; // daily earnings per day -> UPATES TOTAL Earnings\r\n        uint256 dailyEarningsAfterFee; // daily earnings after performance fee deduction -> UPDATES USER BALANCE\r\n        uint256[5] referralEarning; // earnings from referral comissions that has been added to total earnings\r\n        uint256[5] missedReferralEarnings; // referral earnings that has not contributed to total earnings\r\n        uint256[] stakeAmountHistory;\r\n        uint256[] stakeTimeHistory;\r\n        uint256 residualCommissionPerDay; // residual comission per day\r\n        uint256 totalResidualCommission;\r\n        uint256 totalReferralCommission;\r\n        uint256 totalWithdrawalCommission;\r\n        uint256 totalEarnings; // total earnings\r\n        uint256 lastUpdated; // time\r\n        uint256 creationTime;\r\n        uint256 dailyEarningRate;\r\n        uint256 maxReferralLevel;\r\n    }\r\n\r\n    struct User {\r\n        bool isRegistered;\r\n        bool isSuspended;\r\n        uint256 balance;\r\n        uint256[] withdrawalrequestedAmount;\r\n        uint256[] withdrawalAmountRecieved;\r\n        uint256[] withdrawalTime;\r\n        Stake activeStake;\r\n        // Stake[] previousStakes;\r\n        uint256 cycles;\r\n        uint256 previousEarnings;\r\n        uint256 teamEarnings;\r\n        address referredBy;\r\n        uint256[5] downlineLevelStakedAmount;\r\n        uint256[5] downlineLevelActiveStakes;\r\n        uint256[5] teamsize;\r\n    }\r\n    struct adminEarnings {\r\n        uint256 teamSize;\r\n        uint256 downlineBalance;\r\n        uint256 totalEarnings;\r\n        uint256 currentBalance;\r\n        // uint256 residualCommissionPerDay;\r\n        uint256 lastUpdated;\r\n        uint256 teamEarnings;\r\n        uint256 depositFees;\r\n        uint256 withdrawFees;\r\n        uint256 referralFees;\r\n        uint256 residualCommissions;\r\n        uint256 performanceFeeCommissions; // From Fee split\r\n        uint256 residualCommissionsPerDay; // from per referee share\r\n        uint256 perFormanceFeeCommissionPerDay;\r\n    }\r\n\r\n    struct Fee {\r\n        uint256 fee;\r\n        uint256 adminShare;\r\n        uint256 liquidity;\r\n        uint256 directSponsor;\r\n        uint256 upline;\r\n    }\r\n\r\n    Fee public depositFee =\r\n        Fee({\r\n            fee: 1000,\r\n            adminShare: 2500,\r\n            liquidity: 7500,\r\n            directSponsor: 0,\r\n            upline: 0\r\n        });\r\n\r\n    Fee public withdrawalFee =\r\n        Fee({\r\n            fee: 1000,\r\n            adminShare: 2500,\r\n            liquidity: 6500,\r\n            directSponsor: 1000,\r\n            upline: 0\r\n        });\r\n\r\n    Fee public performanceFee =\r\n        Fee({\r\n            fee: 1000,\r\n            adminShare: 2500,\r\n            liquidity: 6000,\r\n            directSponsor: 0,\r\n            upline: 1500\r\n        });\r\n\r\n    Fee public referralCommissionFee =\r\n        Fee({\r\n            fee: 1000,\r\n            adminShare: 2500,\r\n            liquidity: 7500,\r\n            directSponsor: 0,\r\n            upline: 0\r\n        });\r\n\r\n    mapping(address => User) userDetails;\r\n\r\n    event UserRegistered(address user, address referee);\r\n    event UserSuspended(address user);\r\n    event UserReinstated(address user);\r\n    event Paused(uint256);\r\n    event Resumed(uint256);\r\n    event Staked(address user, uint256 amount);\r\n    event Withdrawal(\r\n        address user,\r\n        uint256 amountRequested,\r\n        uint256 amountRecieved\r\n    );\r\n\r\n    uint256 public totalBNBStaked;\r\n    uint256 public totalBNBWithdrawan;\r\n    uint256 public totalBNBWithdrawanAfterDeduction;\r\n    uint256 public totalFeePaid;\r\n    uint256 public startTime;\r\n\r\n    uint256 public dailyEarnings_A = 100; // Active Stake <= 100BNB\r\n    uint256 public dailyEarnings_B = 125; //  100 BNB < Active Stake <= 250 BNB\r\n    uint256 public dailyEarnings_C = 150; // 250BNB < Active Stake < 500BNB\r\n\r\n    adminEarnings public AdminEarnings;\r\n\r\n    constructor() {\r\n        minimumStakeValue = 0.0125 ether; // 0.01 BNB\r\n        maximumStakeValue = 555 ether; // 500 BNB\r\n        maxStakedBalance = 555 ether; // 500 BNB\r\n        minimumWithdrawalAmount = 0.01 ether; // 0.01 BNB\r\n\r\n        isActive = true;\r\n\r\n        userDetails[msg.sender].isRegistered = true;\r\n        AdminEarnings = adminEarnings({\r\n            teamSize: 0,\r\n            downlineBalance: 0,\r\n            totalEarnings: 0,\r\n            currentBalance: 0,\r\n            teamEarnings: 0,\r\n            depositFees: 0,\r\n            withdrawFees: 0,\r\n            referralFees: 0,\r\n            residualCommissions: 0,\r\n            performanceFeeCommissions: 0,\r\n            residualCommissionsPerDay: 0,\r\n            perFormanceFeeCommissionPerDay: 0,\r\n            lastUpdated: block.timestamp\r\n        });\r\n        startTime = block.timestamp;\r\n        maximumReturnPercentage = 25000;\r\n    }\r\n\r\n    /// MODIFIERS/MISC\r\n\r\n    /// @notice In case the user sends funds to the contract\r\n    receive() external payable {}\r\n    /// @notice In case the user calls an inexistent function\r\n    fallback() external {\r\n        revert(\"No Function Called!\");\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    /// @notice To add additional liquidity to smart contract\r\n    function AddLiquidity() external payable {}\r\n\r\n    /// SETTERS\r\n\r\n    ///@notice To see user's maximum return\r\n    ///@dev presense of active stake should be checked before calling this function\r\n    ///@param _user user's address\r\n    function maxReturn(address _user) public view returns (uint256) {\r\n        return\r\n            (userDetails[_user].activeStake.activeStake *\r\n                maximumReturnPercentage) / percentageDivider;\r\n    }\r\n\r\n    /// @notice To see Admins Total Earnings\r\n    function viewAdminEarnings() external view returns (adminEarnings memory) {\r\n        adminEarnings memory tempAdmin = AdminEarnings;\r\n\r\n        uint256 lastUpdated = AdminEarnings.lastUpdated;\r\n\r\n        if (lastUpdated < block.timestamp) {\r\n            uint256 timePassed;\r\n            uint256 pauseTimeLength = pauseTime.length;\r\n\r\n            if (pauseTimeLength > 0) {\r\n                for (uint256 i = 0; i < pauseTimeLength; i++) {\r\n                    if (lastUpdated < pauseTime[i]) {\r\n                        timePassed = pauseTime[i] - lastUpdated;\r\n                        lastUpdated = resumeTime[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            timePassed += block.timestamp - lastUpdated;\r\n\r\n            // uint256 daysPassed = timePassed / (1 days);\r\n            uint256 perFormanceFeeCommissionPerSecond = AdminEarnings\r\n                .perFormanceFeeCommissionPerDay / 1 days;\r\n            uint256 residualCommissionPerSecond = 0;\r\n\r\n            if (tempAdmin.downlineBalance >= 100 ether) {\r\n                residualCommissionPerSecond = (tempAdmin\r\n                    .residualCommissionsPerDay / 1 days);\r\n            }\r\n            uint256 amountToAdd = ((perFormanceFeeCommissionPerSecond +\r\n                residualCommissionPerSecond) * timePassed);\r\n\r\n            tempAdmin.residualCommissions += (residualCommissionPerSecond *\r\n                timePassed);\r\n            tempAdmin\r\n                .performanceFeeCommissions += (perFormanceFeeCommissionPerSecond *\r\n                timePassed);\r\n\r\n            tempAdmin.totalEarnings += amountToAdd;\r\n            tempAdmin.currentBalance += amountToAdd;\r\n            tempAdmin.lastUpdated = block.timestamp;\r\n        }\r\n        return tempAdmin;\r\n    }\r\n\r\n    /// @notice To view details about a user's active stake\r\n    /// @param _user user's address\r\n    /// @return user's current active stake details\r\n    function viewUserStake(address _user) external view returns (Stake memory) {\r\n        Stake memory userStake;\r\n        if (\r\n            !userDetails[_user].activeStake.isActive ||\r\n            userDetails[_user].isSuspended\r\n        ) {\r\n            return userStake;\r\n        }\r\n        userStake = userDetails[_user].activeStake;\r\n\r\n        uint256 timePassed;\r\n        uint256 lastUpdated = userDetails[_user].activeStake.lastUpdated;\r\n        uint256 pauseTimeLength = pauseTime.length;\r\n\r\n        if (pauseTimeLength > 0) {\r\n            for (uint256 i = 0; i < pauseTimeLength; i++) {\r\n                if (lastUpdated < pauseTime[i]) {\r\n                    timePassed = pauseTime[i] - lastUpdated;\r\n                    lastUpdated = resumeTime[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        timePassed += block.timestamp - lastUpdated;\r\n        // uint256 daysPassed = timePassed / (1 days);\r\n\r\n        uint256 perDayEarnings = userDetails[_user]\r\n            .activeStake\r\n            .dailyEarningsBeforeFee;\r\n\r\n        uint256 earningPerSecond = perDayEarnings / 1 days;\r\n        uint256 downlineBalance;\r\n        for (uint256 i = 0; i < 5; i++) {\r\n                    downlineBalance += userDetails[_user].downlineLevelActiveStakes[i];\r\n        }\r\n        if (downlineBalance > 100 ether) {\r\n            uint256 residualCommissionPerSecond = (\r\n                userDetails[_user].activeStake.residualCommissionPerDay\r\n            ) / 1 days;\r\n            earningPerSecond += residualCommissionPerSecond;\r\n\r\n            userStake.totalResidualCommission +=\r\n                ((userDetails[_user].activeStake.residualCommissionPerDay) /\r\n                    1 days) *\r\n                timePassed;\r\n        }\r\n\r\n        uint256 earnings = (earningPerSecond * timePassed);\r\n\r\n        uint256 maxAmountToAdd = maxReturn(_user) -\r\n            userDetails[_user].activeStake.totalEarnings;\r\n        uint256 amountToAdd = min(earnings, maxAmountToAdd);\r\n\r\n        userStake.totalEarnings += amountToAdd;\r\n        userStake.lastUpdated += block.timestamp;\r\n        return userStake;\r\n    }\r\n\r\n    /// @notice To view details about a user's active balance\r\n    /// @param _user user's address\r\n    /// @return user's current balance\r\n    function viewUserBalance(address _user) external view returns (uint256) {\r\n        Stake memory userStake;\r\n        uint256 amountToAddAfterFee;\r\n        userStake = userDetails[_user].activeStake;\r\n\r\n        if (userStake.isActive) {\r\n            uint256 timePassed;\r\n            uint256 lastUpdated = userDetails[_user].activeStake.lastUpdated;\r\n            uint256 pauseTimeLength = pauseTime.length;\r\n\r\n            if (pauseTimeLength > 0) {\r\n                for (uint256 i = 0; i < pauseTimeLength; i++) {\r\n                    if (lastUpdated < pauseTime[i]) {\r\n                        timePassed = pauseTime[i] - lastUpdated;\r\n                        lastUpdated = resumeTime[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            timePassed += block.timestamp - lastUpdated;\r\n\r\n            // uint256 daysPassed = timePassed / (1 days);\r\n\r\n            uint256 earningsPerSecond = userDetails[_user]\r\n                .activeStake\r\n                .dailyEarningsBeforeFee / 1 days;\r\n            uint256 downlineBalance;\r\n            for (uint256 i = 0; i < 5; i++) {\r\n                    downlineBalance += userDetails[_user].downlineLevelActiveStakes[i];\r\n            }\r\n            if (downlineBalance > 100 ether) {\r\n                uint256 residualCommissionPerSecond = (\r\n                    userDetails[_user].activeStake.residualCommissionPerDay\r\n                ) / 1 days;\r\n                earningsPerSecond += residualCommissionPerSecond;\r\n            }\r\n\r\n            uint256 earnings = (earningsPerSecond * timePassed);\r\n\r\n            uint256 earningsAfterFee = earnings -\r\n                    (earnings * performanceFee.fee) /\r\n                    percentageDivider;\r\n\r\n            uint256 maxAmountToAdd = maxReturn(_user) -\r\n                userDetails[_user].activeStake.totalEarnings;\r\n\r\n            amountToAddAfterFee = min(\r\n                    earningsAfterFee,\r\n                    maxAmountToAdd\r\n                );\r\n        }\r\n\r\n        uint256 userBalance = userDetails[_user].balance;\r\n\r\n        userBalance += amountToAddAfterFee;\r\n\r\n        return userBalance;\r\n    }\r\n\r\n    /// @notice To view a user's team size\r\n    /// @param _user user's details\r\n    function viewUserDetails(address _user)\r\n        external\r\n        view\r\n        returns (User memory)\r\n    {\r\n        return userDetails[_user];\r\n    }\r\n\r\n    /// @notice To view a user's team size\r\n    /// @param _user user's address\r\n    function seeTeamSize(address _user)\r\n        external\r\n        view\r\n        returns (uint256[5] memory)\r\n    {\r\n        uint256[5] memory teamsize = userDetails[_user].teamsize;\r\n        return teamsize;\r\n    }\r\n\r\n    /// @notice To view a user registrations status\r\n    /// @param _user user's address\r\n    function checkUserRegistry(address _user) external view returns (bool) {\r\n        return userDetails[_user].isRegistered;\r\n    }\r\n\r\n    function getEarningsRate(uint256 _amount) public view returns (uint256) {\r\n        if (_amount <= 100 ether) {\r\n            return dailyEarnings_A;\r\n        } else if (_amount <= 250 ether) {\r\n            return dailyEarnings_B;\r\n        } else return dailyEarnings_C;\r\n    }\r\n\r\n    /// @notice To check upto what level a user can get referral commisson based on staked amount\r\n    /// @param _amount Staked amount\r\n    /// @return 5  max level eligible for referral\r\n    function maxEligibleLevelForReferralCommission(uint256 _amount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_amount < 0.1 ether) return 0;\r\n        else if (_amount < 1 ether) return 1;\r\n        else if (_amount < 5 ether) return 2;\r\n        else if (_amount < 10 ether) return 3;\r\n        else return 4;\r\n    }\r\n\r\n    /// @notice Deducts Anti-whale Tax\r\n    /// @param _amount Transaction amount\r\n    /// @return amountAfterDeduction Amount after tax deduction\r\n    function AntiWhaleTax(uint256 _amount) public view returns (uint256) {\r\n        uint256 contractCurrentBalance = address(this).balance;\r\n\r\n        uint256 relativePercentage = (_amount * 100) / (contractCurrentBalance);\r\n\r\n        if (relativePercentage < 5) {\r\n            return 0;\r\n        }\r\n        else if (relativePercentage > 14) {\r\n            relativePercentage = 14;\r\n        } \r\n\r\n        uint256 taxPercentage = 5 * (relativePercentage - 4) * 100;\r\n\r\n        uint256 tax = (_amount * taxPercentage) / percentageDivider;\r\n\r\n        return tax;\r\n    }\r\n\r\n\r\n    /// BAM\r\n\r\n    /// @notice To check if a user's active stake has reached it's theshold.\r\n    /// @dev Presence of active stake must be checked before calling this function | Upadate earnings must be called before using this function\r\n    /// @param _user address of user\r\n    function checkBreakthrough(address _user) internal {\r\n        if (!isActive) return;\r\n\r\n        if (userDetails[_user].activeStake.totalEarnings >= maxReturn(_user)) {\r\n\r\n            uint256 activeStake = userDetails[_user].activeStake.activeStake;\r\n            uint256 dailyEarnings = (getEarningsRate(activeStake) *\r\n                activeStake) / percentageDivider;\r\n            uint256 feeOnDailyEarnings = (performanceFee.fee * dailyEarnings) /\r\n                percentageDivider;\r\n            uint256 adminShare = (feeOnDailyEarnings *\r\n                performanceFee.adminShare) / percentageDivider;\r\n            uint256 uplineShare = (feeOnDailyEarnings * performanceFee.upline) /\r\n                percentageDivider;\r\n            updateAdminEarnings();\r\n            AdminEarnings.perFormanceFeeCommissionPerDay = (\r\n                AdminEarnings.perFormanceFeeCommissionPerDay < adminShare\r\n                    ? 0\r\n                    : AdminEarnings.perFormanceFeeCommissionPerDay - adminShare\r\n            );\r\n            uint256 perRefereeShare = uplineShare / 5;\r\n\r\n            userDetails[_user].activeStake.maxed = true;\r\n\r\n            address referee = userDetails[_user].referredBy;\r\n            for (uint8 i = 0; i < 5; i++) {\r\n                if (referee == owner()) {\r\n                    AdminEarnings.residualCommissionsPerDay = (\r\n                        AdminEarnings.residualCommissionsPerDay <\r\n                            perRefereeShare\r\n                            ? 0\r\n                            : AdminEarnings.residualCommissionsPerDay -\r\n                                perRefereeShare\r\n                    );\r\n\r\n                    AdminEarnings.downlineBalance = (AdminEarnings\r\n                        .downlineBalance >\r\n                        userDetails[_user].activeStake.activeStake)\r\n                        ? (AdminEarnings.downlineBalance -\r\n                            userDetails[_user].activeStake.activeStake)\r\n                        : 0;\r\n                    return;\r\n                } else {\r\n                    updateUserEarnings(referee);\r\n\r\n                    userDetails[referee].downlineLevelStakedAmount[\r\n                            i\r\n                        ] = (userDetails[referee].downlineLevelStakedAmount[i] >\r\n                        userDetails[_user].activeStake.stakedAmount)\r\n                        ? (userDetails[referee].downlineLevelStakedAmount[i] -\r\n                            userDetails[_user].activeStake.stakedAmount)\r\n                        : 0;\r\n\r\n                    userDetails[referee].downlineLevelActiveStakes[\r\n                            i\r\n                        ] = (userDetails[referee].downlineLevelActiveStakes[i] >\r\n                        userDetails[_user].activeStake.activeStake)\r\n                        ? (userDetails[referee].downlineLevelActiveStakes[i] -\r\n                            userDetails[_user].activeStake.activeStake)\r\n                        : 0;\r\n\r\n                    if (\r\n                        userDetails[referee].activeStake.isActive &&\r\n                        !userDetails[referee].activeStake.maxed\r\n                    ) {\r\n                        userDetails[referee]\r\n                            .activeStake\r\n                            .residualCommissionPerDay = (\r\n                            userDetails[referee]\r\n                                .activeStake\r\n                                .residualCommissionPerDay < perRefereeShare\r\n                                ? 0\r\n                                : userDetails[referee]\r\n                                    .activeStake\r\n                                    .residualCommissionPerDay - perRefereeShare\r\n                        );\r\n                    }\r\n                }\r\n                referee = userDetails[referee].referredBy;\r\n            }\r\n\r\n            // userDetails[_user].previousStakes.push(\r\n            //     userDetails[_user].activeStake\r\n            // );\r\n        }\r\n    }\r\n\r\n    /// @notice To deduct Deposit Fees\r\n    /// @param _amount transaction amount\r\n    /// @return amountAfterDeduction amount after deducting Fees\r\n    function deductDepositFee(uint256 _amount) internal returns (uint256) {\r\n        uint256 fee = (_amount * depositFee.fee) / (percentageDivider);\r\n        uint256 amountAfterDeduction = _amount - fee;\r\n\r\n        uint256 adminShare = (fee * depositFee.adminShare) /\r\n            (percentageDivider);\r\n\r\n        totalFeePaid += fee;\r\n        // No need to transfer liquidity share\r\n        AdminEarnings.currentBalance += adminShare;\r\n        AdminEarnings.totalEarnings += adminShare;\r\n        AdminEarnings.depositFees += adminShare;\r\n\r\n        return amountAfterDeduction;\r\n    }\r\n\r\n    /// @notice To deduct Performance Fees\r\n    /// @param _amount transaction amount\r\n    /// @param _user user's address\r\n    /// @return amountAfterDeduction amount after deducting Fees\r\n    function deductPerformanceFee(uint256 _amount, address _user)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 fee = (_amount * performanceFee.fee) / (percentageDivider);\r\n        uint256 amountAfterDeduction = _amount - fee;\r\n\r\n        uint256 adminShare = (fee * performanceFee.adminShare) /\r\n            (percentageDivider);\r\n\r\n        uint256 uplineShare = (fee * performanceFee.upline) /\r\n            (percentageDivider);\r\n\r\n        uint256 perRefereeShare = uplineShare / 5;\r\n\r\n        address referee = userDetails[_user].referredBy;\r\n\r\n        AdminEarnings.perFormanceFeeCommissionPerDay += adminShare;\r\n\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            if (referee == owner()) {\r\n                AdminEarnings.residualCommissionsPerDay += perRefereeShare;\r\n                break;\r\n            } else if (\r\n                userDetails[referee].activeStake.isActive &&\r\n                !userDetails[referee].activeStake.maxed\r\n            ) {\r\n                if (userDetails[referee].isSuspended) {\r\n                    continue;\r\n                }\r\n                userDetails[referee]\r\n                    .activeStake\r\n                    .residualCommissionPerDay += perRefereeShare;\r\n            }\r\n            referee = userDetails[_user].referredBy;\r\n        }\r\n\r\n        totalFeePaid += fee;\r\n\r\n        return amountAfterDeduction;\r\n    }\r\n\r\n    /// @notice To deduct Referral Fees\r\n    /// @param _amount transaction amount\r\n    /// @return amountAfterDeduction amount after deducting Fees\r\n    function deductReferralFee(uint256 _amount) internal returns (uint256) {\r\n        uint256 fee = (_amount * referralCommissionFee.fee) /\r\n            (percentageDivider);\r\n\r\n        uint256 amountAfterDeduction = _amount - fee;\r\n\r\n        uint256 adminShare = (fee * referralCommissionFee.adminShare) /\r\n            (percentageDivider);\r\n\r\n        AdminEarnings.currentBalance += adminShare;\r\n        AdminEarnings.totalEarnings += adminShare;\r\n        AdminEarnings.referralFees += adminShare;\r\n\r\n        totalFeePaid += fee;\r\n\r\n        return amountAfterDeduction;\r\n    }\r\n\r\n    /// @notice To deduct withdrawal Fees\r\n    /// @param _amount transaction amount\r\n    /// @param _user user's address\r\n    /// @return amountAfterDeduction amount after deducting Fees\r\n    function deductWithdrawalFees(uint256 _amount, address _user)\r\n        internal \r\n        returns (uint256)\r\n    {\r\n        uint256 fee = (_amount * withdrawalFee.fee) / percentageDivider;\r\n        uint256 AntiWhaleTaxAmount = AntiWhaleTax(_amount);\r\n        uint256 amountAfterDeduction = _amount - fee - AntiWhaleTaxAmount;\r\n\r\n        uint256 adminShare = (fee * withdrawalFee.adminShare) /\r\n            percentageDivider;\r\n\r\n        uint256 directSponsorShare = (fee * withdrawalFee.directSponsor) /\r\n            percentageDivider;\r\n\r\n        address directSponsor = userDetails[_user].referredBy;\r\n\r\n        AdminEarnings.currentBalance += adminShare;\r\n        AdminEarnings.totalEarnings += adminShare;\r\n        AdminEarnings.withdrawFees += adminShare;\r\n\r\n        \r\n\r\n        if (directSponsor == owner()) {\r\n            AdminEarnings.currentBalance += directSponsorShare;\r\n            AdminEarnings.totalEarnings += directSponsorShare;\r\n            AdminEarnings.teamEarnings += directSponsorShare;\r\n        } else {\r\n            updateUserEarnings(directSponsor);\r\n            if (\r\n                userDetails[directSponsor].activeStake.isActive &&\r\n                !userDetails[directSponsor].activeStake.maxed\r\n            ) {\r\n                uint256 maxAmountToAdd = maxReturn(directSponsor) -\r\n                    userDetails[directSponsor].activeStake.totalEarnings;\r\n\r\n                uint256 amountToAdd = min(directSponsorShare, maxAmountToAdd);\r\n\r\n                userDetails[directSponsor]\r\n                    .activeStake\r\n                    .totalWithdrawalCommission += amountToAdd;\r\n\r\n                userDetails[directSponsor]\r\n                    .activeStake\r\n                    .totalEarnings += amountToAdd;\r\n\r\n                userDetails[directSponsor].balance += amountToAdd;\r\n\r\n                checkBreakthrough(directSponsor);\r\n            }\r\n        }\r\n\r\n        totalFeePaid += (fee + AntiWhaleTaxAmount);\r\n\r\n        return amountAfterDeduction;\r\n    }\r\n\r\n    /// @notice To add a referee's referral commissions\r\n    /// @param _amount referral commission amount\r\n    /// @param _referee referee address\r\n    function addReferralCommissionToReferee(\r\n        uint256 _amount,\r\n        address _referee,\r\n        uint256 _referralLevel\r\n    ) internal {\r\n        if (_referee == owner()) {\r\n            AdminEarnings.totalEarnings += _amount;\r\n            AdminEarnings.currentBalance += _amount;\r\n            AdminEarnings.teamEarnings += _amount;\r\n        } else if (\r\n            userDetails[_referee].activeStake.isActive &&\r\n            !userDetails[_referee].activeStake.maxed\r\n        ) {\r\n            // No update if referee is suspended\r\n\r\n            if (userDetails[_referee].isSuspended) {\r\n                return;\r\n            }\r\n\r\n            uint256 maxAmountToAddBeforeFee = maxReturn(_referee) -\r\n                userDetails[_referee].activeStake.totalEarnings;\r\n\r\n            uint256 amountToAddBeforeFee = min(\r\n                _amount,\r\n                maxAmountToAddBeforeFee\r\n            );\r\n\r\n            uint256 maxEligibleLevel = maxEligibleLevelForReferralCommission(\r\n                userDetails[_referee].activeStake.activeStake\r\n            );\r\n\r\n            if (maxEligibleLevel >= _referralLevel) {\r\n                uint256 amountToAddAfterFee = deductReferralFee(\r\n                    amountToAddBeforeFee\r\n                );\r\n\r\n                // Change here to see amount earned before fee\r\n                userDetails[_referee].activeStake.referralEarning[\r\n                        _referralLevel\r\n                    ] += amountToAddBeforeFee;\r\n\r\n                userDetails[_referee]\r\n                    .activeStake\r\n                    .totalEarnings += amountToAddBeforeFee;\r\n\r\n                userDetails[_referee].balance += amountToAddAfterFee;\r\n\r\n                userDetails[_referee].activeStake.totalReferralCommission += amountToAddBeforeFee;\r\n\r\n                checkBreakthrough(_referee);\r\n            } else {\r\n                userDetails[_referee].activeStake.missedReferralEarnings[\r\n                        _referralLevel\r\n                    ] += amountToAddBeforeFee;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice To distribute referral commissions whenever a user stakes\r\n    /// @param _amount Transaction Amount\r\n    /// @param _user Staker's address\r\n    function distributeReferralCommissions(uint256 _amount, address _user)\r\n        internal\r\n    {\r\n        address _referee = userDetails[_user].referredBy;\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            uint256 referralCommission = (referralLevelCommission[i] *\r\n                _amount) / (percentageDivider);\r\n            addReferralCommissionToReferee(referralCommission, _referee, i);\r\n            if (_referee == owner()) {\r\n                break;\r\n            }\r\n            _referee = userDetails[_referee].referredBy;\r\n        }\r\n    }\r\n\r\n    /// @notice To stake BNB\r\n    /// @dev Checks for presence of active stake. If present adds BNB to it, else creates a new stake.\r\n    function stakeBNB(address referree) external payable {\r\n        require(\r\n            msg.sender != owner() && msg.sender != nextOwner,\r\n            \"B.A.M:Owner cannot stake\"\r\n        );\r\n        require(\r\n            msg.value >= minimumStakeValue,\r\n            \"B.A.M:Amount less than minimun required\"\r\n        );\r\n        require(\r\n            msg.value <= maximumStakeValue,\r\n            \"B.A.M:Amount exceeds maximum allowed\"\r\n        );\r\n        require(isActive, \"B.A.M:Project paused\");\r\n        require(!userDetails[msg.sender].isSuspended, \"B.A.M:User suspended\");\r\n\r\n        if (!userDetails[referree].isRegistered || userDetails[referree].isSuspended) {\r\n                referree = owner();\r\n        }\r\n        \r\n        if (userDetails[msg.sender].isRegistered) {\r\n            referree = userDetails[msg.sender].referredBy;\r\n        }\r\n        else {\r\n            address originalReferee = referree;\r\n            userDetails[msg.sender].referredBy = referree;\r\n            userDetails[msg.sender].isRegistered = true;\r\n\r\n            emit UserRegistered(msg.sender, originalReferee);\r\n\r\n            for (uint8 i = 0; i < 5; i++) {\r\n                if (referree == owner()) {\r\n                    AdminEarnings.teamSize += 1;\r\n                    break;\r\n                } else {\r\n                    userDetails[referree].teamsize[i] += 1;\r\n                    referree = userDetails[referree].referredBy;\r\n                }\r\n            }\r\n        }\r\n        \r\n\r\n        if (\r\n            !userDetails[msg.sender].activeStake.isActive || userDetails[msg.sender].activeStake.maxed\r\n        ) {\r\n            \r\n            if (userDetails[msg.sender].activeStake.maxed) {\r\n                userDetails[msg.sender].previousEarnings += userDetails[msg.sender].activeStake.totalEarnings;\r\n            }\r\n            userDetails[msg.sender].teamEarnings += userDetails[msg.sender].activeStake.totalResidualCommission + userDetails[msg.sender].activeStake.totalReferralCommission + userDetails[msg.sender].activeStake.totalWithdrawalCommission;\r\n        \r\n            userDetails[msg.sender].cycles++;\r\n            Stake memory newStake;\r\n\r\n            newStake.isActive = true;\r\n            newStake.lastUpdated = block.timestamp;\r\n            newStake.creationTime = block.timestamp;\r\n\r\n            delete userDetails[msg.sender].activeStake;\r\n            userDetails[msg.sender].activeStake = newStake;\r\n        }\r\n\r\n        uint256 amount = msg.value;\r\n\r\n        uint256 currentStake = userDetails[msg.sender].activeStake.stakedAmount;\r\n        require(\r\n            currentStake + msg.value <= maxStakedBalance,\r\n            \"B.A.M:Total Stake exceeds maximum allowed\"\r\n        );\r\n\r\n        // Previous stake present\r\n        if (userDetails[msg.sender].activeStake.lastUpdated < block.timestamp) {\r\n            updateUserEarnings(msg.sender);\r\n        }\r\n\r\n        address referee = userDetails[msg.sender].referredBy;\r\n\r\n        uint256 amountAfterDeduction = deductDepositFee(amount);\r\n\r\n        // update earnings for all referee to handle performance commission, referral commission\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            {\r\n                if (referee == owner()) {\r\n                    AdminEarnings.downlineBalance += amountAfterDeduction;\r\n                    updateAdminEarnings();\r\n                    break;\r\n                } else {\r\n\r\n                    userDetails[referee].downlineLevelActiveStakes[\r\n                            i\r\n                        ] += amountAfterDeduction;\r\n\r\n                    userDetails[referee].downlineLevelStakedAmount[i] += amount;\r\n\r\n                    if (\r\n                        userDetails[referee].activeStake.isActive &&\r\n                        !userDetails[referee].activeStake.maxed\r\n                    ) {\r\n                        updateUserEarnings(referee);\r\n                    }\r\n                    referee = userDetails[referee].referredBy;\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 newStakeAmount = amountAfterDeduction +\r\n            userDetails[msg.sender].activeStake.activeStake;\r\n\r\n        uint256 newEarningsRate = getEarningsRate(newStakeAmount);\r\n\r\n        uint256 newDailyEarningsBeforeFee = (newStakeAmount * newEarningsRate) /\r\n            percentageDivider;\r\n\r\n        uint256 previousDailyEarnings = userDetails[msg.sender]\r\n            .activeStake\r\n            .dailyEarningsBeforeFee;\r\n\r\n        uint256 additionalDailyEarnings = newDailyEarningsBeforeFee -\r\n            previousDailyEarnings;\r\n\r\n        // Update Residual commissions\r\n        deductPerformanceFee(additionalDailyEarnings, msg.sender);\r\n\r\n        uint256 newDailyEarningsAfterFee = newDailyEarningsBeforeFee -\r\n            ((newDailyEarningsBeforeFee * performanceFee.fee) /\r\n                (percentageDivider));\r\n\r\n        // Update Referral Commissions\r\n        distributeReferralCommissions(amountAfterDeduction, msg.sender);\r\n\r\n        userDetails[msg.sender].activeStake.stakedAmount += msg.value;\r\n        userDetails[msg.sender].activeStake.activeStake += amountAfterDeduction;\r\n        userDetails[msg.sender]\r\n            .activeStake\r\n            .dailyEarningsBeforeFee = newDailyEarningsBeforeFee;\r\n        userDetails[msg.sender]\r\n            .activeStake\r\n            .dailyEarningsAfterFee = newDailyEarningsAfterFee;\r\n\r\n        userDetails[msg.sender]\r\n            .activeStake\r\n            .maxReferralLevel = maxEligibleLevelForReferralCommission(\r\n            userDetails[msg.sender].activeStake.activeStake\r\n        );\r\n\r\n        userDetails[msg.sender].activeStake.dailyEarningRate = getEarningsRate(\r\n            userDetails[msg.sender].activeStake.stakedAmount\r\n        );\r\n\r\n        userDetails[msg.sender].activeStake.stakeAmountHistory.push(\r\n            amountAfterDeduction\r\n        );\r\n        userDetails[msg.sender].activeStake.stakeTimeHistory.push(\r\n            block.timestamp\r\n        );\r\n\r\n        totalBNBStaked += amountAfterDeduction;\r\n\r\n        emit Staked(msg.sender, msg.value);\r\n    }\r\n\r\n    ///@notice To update user's earnings via private calls\r\n    ///@dev presense of active stake should be checked before calling this function\r\n    function updateUserEarnings(address _user) internal {\r\n        if (userDetails[_user].isSuspended) return;\r\n        if (!isActive) return;\r\n\r\n        if (userDetails[_user].activeStake.lastUpdated < block.timestamp) {\r\n            if (userDetails[_user].activeStake.isActive) {\r\n                uint256 timePassed;\r\n                uint256 lastUpdated = userDetails[_user]\r\n                    .activeStake\r\n                    .lastUpdated;\r\n                uint256 pauseTimeLength = pauseTime.length;\r\n\r\n                if (pauseTimeLength > 0) {\r\n                    for (uint256 i = 0; i < pauseTimeLength; i++) {\r\n                        if (lastUpdated < pauseTime[i]) {\r\n                            timePassed += (pauseTime[i] - lastUpdated);\r\n                            lastUpdated = resumeTime[i];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                timePassed += block.timestamp - lastUpdated;\r\n\r\n                uint256 perDayEarnings = userDetails[_user]\r\n                    .activeStake\r\n                    .dailyEarningsBeforeFee;\r\n\r\n                uint256 earningPerSecond = perDayEarnings / 1 days;\r\n                uint256 downlineBalance;\r\n                for (uint256 i = 0; i < 5; i++) {\r\n                    downlineBalance += userDetails[_user].downlineLevelActiveStakes[i];\r\n                }\r\n                if (downlineBalance > 100 ether) {\r\n                    uint256 residualCommissionPerSecond = (\r\n                        userDetails[_user].activeStake.residualCommissionPerDay\r\n                    ) / 1 days;\r\n                    earningPerSecond += residualCommissionPerSecond;\r\n\r\n                    userDetails[_user].activeStake.totalResidualCommission +=\r\n                        ((\r\n                            userDetails[_user]\r\n                                .activeStake\r\n                                .residualCommissionPerDay\r\n                        ) / 1 days) *\r\n                        timePassed;\r\n                }\r\n\r\n                uint256 earnings = (earningPerSecond * timePassed);\r\n\r\n                uint256 earningsAfterFee = earnings -\r\n                    (earnings * performanceFee.fee) /\r\n                    percentageDivider;\r\n\r\n                uint256 maxAmountToAdd = maxReturn(_user) -\r\n                    userDetails[_user].activeStake.totalEarnings;\r\n\r\n                uint256 amountToAdd = min(earnings, maxAmountToAdd);\r\n\r\n                uint256 amountToAddAfterFee = min(\r\n                    earningsAfterFee,\r\n                    maxAmountToAdd\r\n                );\r\n                userDetails[_user].activeStake.totalEarnings += amountToAdd;\r\n\r\n                userDetails[_user].balance += amountToAddAfterFee;\r\n\r\n                userDetails[_user].activeStake.lastUpdated = block.timestamp;\r\n\r\n                checkBreakthrough(_user);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice To update Admins Earnings\r\n    function updateAdminEarnings() internal {\r\n        uint256 lastUpdated = AdminEarnings.lastUpdated;\r\n\r\n        if (lastUpdated < block.timestamp) {\r\n            uint256 timePassed;\r\n            uint256 pauseTimeLength = pauseTime.length;\r\n\r\n            if (pauseTimeLength > 0) {\r\n                for (uint256 i = 0; i < pauseTimeLength; i++) {\r\n                    if (lastUpdated < pauseTime[i]) {\r\n                        timePassed += (pauseTime[i] - lastUpdated);\r\n                        lastUpdated = resumeTime[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            timePassed += block.timestamp - lastUpdated;\r\n\r\n            // uint256 daysPassed = timePassed / (1 days);\r\n            uint256 perFormanceFeeCommissionPerSecond = AdminEarnings\r\n                .perFormanceFeeCommissionPerDay / 1 days;\r\n            uint256 residualCommissionPerSecond = 0;\r\n\r\n            if (AdminEarnings.downlineBalance >= 100 ether) {\r\n                residualCommissionPerSecond = (AdminEarnings\r\n                    .residualCommissionsPerDay / 1 days);\r\n            }\r\n            uint256 amountToAdd = ((perFormanceFeeCommissionPerSecond +\r\n                residualCommissionPerSecond) * timePassed);\r\n\r\n            AdminEarnings.residualCommissions += (residualCommissionPerSecond *\r\n                timePassed);\r\n            AdminEarnings\r\n                .performanceFeeCommissions += (perFormanceFeeCommissionPerSecond *\r\n                timePassed);\r\n            AdminEarnings.totalEarnings += amountToAdd;\r\n            AdminEarnings.currentBalance += amountToAdd;\r\n            AdminEarnings.lastUpdated = block.timestamp;\r\n        }\r\n    }\r\n\r\n    /// @notice For users to withdraw their earnings\r\n    /// @param _amount amount to withdraw\r\n    function withdrawEarnings(uint256 _amount) external nonReentrant {\r\n        require(\r\n            _amount >= minimumWithdrawalAmount,\r\n            \"B.A.M:Amount less than minimum allowed withdrawal\"\r\n        );\r\n\r\n        require(msg.sender != owner(), \"B.A.M:Not for owner\");\r\n        require(isActive, \"B.A.M:Project paused\");\r\n\r\n        require(\r\n            userDetails[msg.sender].isRegistered,\r\n            \"B.A.M:Unregistered user\"\r\n        );\r\n        require(!userDetails[msg.sender].isSuspended, \"B.A.M:User Suspended\");\r\n\r\n        updateUserEarnings(msg.sender);\r\n        \r\n        require(\r\n            _amount <= userDetails[msg.sender].balance,\r\n            \"B.A.M:Not enough earnings\"\r\n        );\r\n        require(\r\n            _amount <= address(this).balance,\r\n            \"B.A.M:Insufficient funds,Contact Admin\"\r\n        );\r\n\r\n        /*require(\r\n            _amount <= userDetails[msg.sender].activeStake.stakedAmount,\r\n            \"B.A.M:Amount exceeds active stake\"\r\n        );*/\r\n\r\n        uint256 amountAfterDeduction = deductWithdrawalFees(\r\n            _amount,\r\n            msg.sender\r\n        );\r\n\r\n        userDetails[msg.sender].withdrawalrequestedAmount.push(_amount);\r\n        userDetails[msg.sender].withdrawalAmountRecieved.push(\r\n            amountAfterDeduction\r\n        );\r\n        userDetails[msg.sender].withdrawalTime.push(block.timestamp);\r\n        userDetails[msg.sender].balance -= _amount;\r\n\r\n        if (userDetails[msg.sender].balance == 0) {\r\n            userDetails[msg.sender].activeStake.isActive = false;\r\n        }\r\n\r\n        (bool sent, ) = payable(msg.sender).call{value: amountAfterDeduction}(\r\n            \"\"\r\n        );\r\n\r\n        totalBNBWithdrawan += _amount;\r\n        totalBNBWithdrawan += amountAfterDeduction;\r\n        emit Withdrawal(msg.sender, _amount, amountAfterDeduction);\r\n        require(sent, \"B.A.M:Failed to send BNB\");\r\n    }\r\n\r\n    \r\n\r\n    /// ADMIN\r\n\r\n    /// @notice Overridding transferOwnership\r\n    /// @param _newOwner _newOwner's address\r\n    function transferOwnership(address _newOwner)\r\n        public\r\n        virtual\r\n        override(Ownable)\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        require(!userDetails[_newOwner].isRegistered, \"B.A.M:Invalid user\");\r\n        require(nextOwner != owner(), \"B.A.M:Next owner same as current owner\");\r\n        nextOwner = _newOwner;\r\n    }\r\n\r\n    /// @notice For new owner to accept ownership\r\n    function acceptOwnerShip() external {\r\n        require(msg.sender == nextOwner, \"B.A.M:Not next owner\");\r\n        _transferOwnership(nextOwner);\r\n        userDetails[msg.sender].isRegistered = true;\r\n        nextOwner = address(0);\r\n    }\r\n\r\n    /// @notice For Owner to pause contracts functionality\r\n    function pauseContract() external onlyOwner {\r\n        require(isActive == true, \"B.A.M:Contract already paused\");\r\n        isActive = false;\r\n        pauseTime.push(block.timestamp);\r\n        emit Paused(block.timestamp);\r\n    }\r\n\r\n    /// @notice For Owner to resume contracts functionality\r\n    function resumeContract() external onlyOwner {\r\n        require(!isActive, \"B.A.M:Contract already active\");\r\n        isActive = true;\r\n        resumeTime.push(block.timestamp);\r\n        emit Resumed(block.timestamp);\r\n    }\r\n\r\n    /// @notice For admin to suspend a user. A suspended user will not have any earnings after suspension.\r\n    /// @param _user address of user to be suspended\r\n    function suspendUser(address _user) external onlyOwner {\r\n        require(\r\n            !userDetails[_user].isSuspended,\r\n            \"B.A.M:User already suspended\"\r\n        );\r\n\r\n        if (userDetails[_user].isRegistered) {\r\n            updateUserEarnings(_user);\r\n        }\r\n        \r\n        userDetails[_user].isSuspended = true;\r\n        emit UserSuspended(_user);\r\n    }\r\n\r\n    /// @notice For admin to re-instate a suspended user. User will start recieving all earnings now.\r\n    /// @param _user address of user to be suspended\r\n    function reinstateUser(address _user) external onlyOwner {\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        require(userDetails[_user].isRegistered, \"B.A.M:User not registered\");\r\n        require(userDetails[_user].isSuspended, \"B.A.M:User already active\");\r\n\r\n        userDetails[_user].isSuspended = false;\r\n        if (userDetails[_user].activeStake.isActive) {\r\n            userDetails[_user].activeStake.lastUpdated = block.timestamp;\r\n        }\r\n        emit UserReinstated(_user);\r\n    }\r\n\r\n    /// @notice For owner to change deposit fee\r\n    /// @param _fee:  % to deduct from transaction amount * 100\r\n    /// @param _adminShare new admin's share in deducted fee * 100\r\n    /// @param _liquidity new share of fee to be stored in smart contract *100\r\n    function changeDepositFee(\r\n        uint256 _fee,\r\n        uint256 _adminShare,\r\n        uint256 _liquidity\r\n    ) external onlyOwner {\r\n        require(_fee <= 2000, \"B.A.M :Fees cannot exceed 20%\");\r\n        require(isActive, \"B.A.M : Project Paused\");\r\n        uint256 total = _adminShare + _liquidity;\r\n        require(total == 10000, \"B.A.M : Incorrect Distribution\");\r\n        depositFee.fee = _fee;\r\n        depositFee.adminShare = _adminShare;\r\n        depositFee.liquidity = _liquidity;\r\n    }\r\n\r\n    /// @notice For owner to change withdrawal fee\r\n    /// @param _fee:  % to deduct from transaction amount\r\n    /// @param _adminShare admin's share in deducted fee * 100\r\n    /// @param _liquidity share of fee to be stored in smart contract *100\r\n    /// @param _directSponsor share of fee to be sent to direct sponsor * 100\r\n    function changeWithdrawalFee(\r\n        uint256 _fee,\r\n        uint256 _adminShare,\r\n        uint256 _liquidity,\r\n        uint256 _directSponsor\r\n    ) external onlyOwner {\r\n        require(_fee <= 2000, \"B.A.M :Fees cannot exceed 20%\");\r\n\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n\r\n        uint256 total = _adminShare + _liquidity + _directSponsor;\r\n        require(total == 10000, \"B.A.M:Incorrect Distribution\");\r\n        withdrawalFee.fee = _fee;\r\n        withdrawalFee.adminShare = _adminShare;\r\n        withdrawalFee.liquidity = _liquidity;\r\n        withdrawalFee.directSponsor = _directSponsor;\r\n    }\r\n\r\n    /// @notice For owner to change Performance fee\r\n    /// @param _fee:  % to deduct from transaction amount * 100\r\n    /// @param _adminShare admin's share in deducted fee * 100\r\n    /// @param _liquidity share of fee to be stored in smart contract * 100\r\n    /// @param _upline share of fee to be shared with upper levels * 100\r\n    function changePerformanceFee(\r\n        uint256 _fee,\r\n        uint256 _adminShare,\r\n        uint256 _liquidity,\r\n        uint256 _upline\r\n    ) external onlyOwner {\r\n        require(_fee <= 2000, \"B.A.M :Fees cannot exceed 20%\");\r\n\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n\r\n        require(\r\n            _adminShare + _liquidity + _upline == 10000,\r\n            \"B.A.M:Incorrect Distribution\"\r\n        );\r\n        performanceFee.fee = _fee;\r\n        performanceFee.adminShare = _adminShare;\r\n        performanceFee.liquidity = _liquidity;\r\n        performanceFee.upline = _upline;\r\n    }\r\n\r\n    /// @notice For owner to change Referral Commission fee\r\n    /// @param _fee:  % to deduct from transaction amount * 100\r\n    /// @param _adminShare admin's share in deducted fee * 100\r\n    /// @param _liquidity share of fee to be stored in smart contract * 100\r\n    function changeReferralCommissionFee(\r\n        uint256 _fee,\r\n        uint256 _adminShare,\r\n        uint256 _liquidity\r\n    ) external onlyOwner {\r\n        require(_fee <= 2000, \"B.A.M :Fees cannot exceed 20%\");\r\n\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        require(\r\n            _adminShare + _liquidity == 10000,\r\n            \"B.A.M:Incorrect Distribution\"\r\n        );\r\n        referralCommissionFee.fee = _fee;\r\n        referralCommissionFee.adminShare = _adminShare;\r\n        referralCommissionFee.liquidity = _liquidity;\r\n    }\r\n\r\n    /// @notice For owner to change daily earnings rate for :\r\n    /// @param _rate_A:  new daily earnings percentage * 100 | Active Stake <= 100BNB\r\n    /// @param _rate_B:  new daily earnings percentage * 100 | 100 BNB < Active Stake <= 250 BNB\r\n    /// @param _rate_C:  new daily earnings percentage * 100 | 250BNB < Active Stake < 500BNB\r\n    function ChangeEarningsRate(\r\n        uint256 _rate_A,\r\n        uint256 _rate_B,\r\n        uint256 _rate_C\r\n    ) external onlyOwner {\r\n        require(_rate_A > 0, \"B.A.M: Earning rate cannot be zero\");\r\n        require(_rate_B > 0, \"B.A.M: Earning rate cannot be zero\");\r\n        require(_rate_C > 0, \"B.A.M: Earning rate cannot be zero\");\r\n\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        dailyEarnings_A = _rate_A;\r\n        dailyEarnings_B = _rate_B;\r\n        dailyEarnings_C = _rate_C;\r\n    }\r\n\r\n    /// @notice To change minimum staking amount\r\n    /// @param _minStake - new minimum stake.\r\n    function ChangeMinStake(uint256 _minStake) external onlyOwner {\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        require(_minStake < maximumStakeValue, \"B.A.M: Minimum Stake Exceeds Maximumu Stake!\");\r\n        minimumStakeValue = _minStake;\r\n    }\r\n\r\n    /// @notice To change maximum staking amount\r\n    /// @param _maxStake - new maximum stake.\r\n    function ChangeMaxStake(uint256 _maxStake) external onlyOwner {\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        require(_maxStake > minimumStakeValue, \"B.A.M: Minimum Stake Exceeds Maximumu Stake!\");\r\n        maximumStakeValue = _maxStake;\r\n    }\r\n\r\n    /// @notice For Admin to withdraw their earnings\r\n    /// @param _amount amount to withdraw\r\n    function WithdrawAdminEarnings(uint256 _amount)\r\n        external\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        require(\r\n            _amount >= minimumWithdrawalAmount,\r\n            \"B.A.M.:Amount less than minimum allowed\"\r\n        );\r\n        require(isActive, \"B.A.M:Project Paused\");\r\n        updateAdminEarnings();\r\n        require(\r\n            AdminEarnings.currentBalance >= _amount,\r\n            \"B.A.M:Not enough admin earnings\"\r\n        );\r\n\r\n        AdminEarnings.currentBalance -= _amount;\r\n        (bool sent, ) = payable(owner()).call{value: _amount}(\"\");\r\n\r\n        totalBNBWithdrawan += _amount;\r\n        totalBNBWithdrawanAfterDeduction += _amount;\r\n\r\n        require(sent, \"B.A.M:Failed to send BNB\");\r\n        emit Withdrawal(msg.sender, _amount, _amount);\r\n    }\r\n\r\n\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"UserRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"UserReinstated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"UserSuspended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRecieved\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AddLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AdminEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"teamSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downlineBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residualCommissions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFeeCommissions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residualCommissionsPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perFormanceFeeCommissionPerDay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"AntiWhaleTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate_A\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate_B\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate_C\",\"type\":\"uint256\"}],\"name\":\"ChangeEarningsRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxStake\",\"type\":\"uint256\"}],\"name\":\"ChangeMaxStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStake\",\"type\":\"uint256\"}],\"name\":\"ChangeMinStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAdminEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnerShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"}],\"name\":\"changeDepositFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_upline\",\"type\":\"uint256\"}],\"name\":\"changePerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"}],\"name\":\"changeReferralCommissionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_directSponsor\",\"type\":\"uint256\"}],\"name\":\"changeWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkUserRegistry\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyEarnings_A\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyEarnings_B\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyEarnings_C\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directSponsor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upline\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getEarningsRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"maxEligibleLevelForReferralCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"maxReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumReturnPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumStakeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentageDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directSponsor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upline\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCommissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directSponsor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upline\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralLevelCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"reinstateUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resumeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resumeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"seeTeamSize\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referree\",\"type\":\"address\"}],\"name\":\"stakeBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"suspendUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBNBStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBNBWithdrawan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBNBWithdrawanAfterDeduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeePaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewAdminEarnings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"teamSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"downlineBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residualCommissions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"performanceFeeCommissions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residualCommissionsPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perFormanceFeeCommissionPerDay\",\"type\":\"uint256\"}],\"internalType\":\"struct BAM.adminEarnings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isRegistered\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSuspended\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalrequestedAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalAmountRecieved\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"withdrawalTime\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyEarningsBeforeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyEarningsAfterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"referralEarning\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"missedReferralEarnings\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeAmountHistory\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeTimeHistory\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"residualCommissionPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalResidualCommission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferralCommission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawalCommission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyEarningRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReferralLevel\",\"type\":\"uint256\"}],\"internalType\":\"struct BAM.Stake\",\"name\":\"activeStake\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"cycles\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnings\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referredBy\",\"type\":\"address\"},{\"internalType\":\"uint256[5]\",\"name\":\"downlineLevelStakedAmount\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"downlineLevelActiveStakes\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"teamsize\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct BAM.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserStake\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyEarningsBeforeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyEarningsAfterFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"referralEarning\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"missedReferralEarnings\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeAmountHistory\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeTimeHistory\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"residualCommissionPerDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalResidualCommission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferralCommission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawalCommission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyEarningRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxReferralLevel\",\"type\":\"uint256\"}],\"internalType\":\"struct BAM.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directSponsor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upline\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BAM", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6175e18e608e08f1e133c1b2b8a32cfe6342f13879d0a3898925f355fca2055"}