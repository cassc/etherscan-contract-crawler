{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// import './modules/Context.sol';\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// import './modules/Ownable.sol';\r\nabstract contract Ownable is Context {\r\n    \r\n    address private _owner;\r\n    bytes4 private constant SELECTOR_TRANSFER = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    bytes4 private constant SELECTOR_TRANSFERFROM = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _owner = address(0);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        \r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n    }\r\n    \r\n    function withdraw(address payable to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"Warning: address cannot be zero.\");\r\n        require(address(this).balance >= amount, \"Warning: insufficient balance.\");\r\n        to.transfer(amount);\r\n    }\r\n    \r\n    function withdrawToken(address token, address to, uint256 amount) public onlyOwner {\r\n        _safeTransfer(token, to, amount);\r\n    }\r\n    \r\n    function _safeTransfer(address token, address spender, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR_TRANSFER, spender, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Warning: Transaction failed.');\r\n    }\r\n\r\n    function _safeTransferFrom(address token, address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR_TRANSFERFROM, sender, recipient, amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Warning: TransferFrom failed.');\r\n        \r\n        return success;\r\n    }\r\n}\r\n\r\n// import './libraries/SafeMath.sol';\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// import './interfaces/IERC20.sol';\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract F8 is Context, Ownable, IERC20 {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    struct Owned {\r\n        uint256 balanceOf;\r\n        uint256 level;\r\n        address referrer;\r\n        bool lockRef;\r\n        bool active;\r\n    }\r\n\r\n    address[] ownedList;\r\n    mapping(address => Owned) private _owned;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    address[] private _excludedFromRewardList;\r\n    mapping(address => bool) private _isExcludedFromReward;\r\n\r\n    address[] private _excludedFromFeeList;\r\n    mapping(address => bool) private _isExcludedFromFee;\r\n    \r\n    string public name = \"F8 DAO\";\r\n    string public symbol = \"F8\";\r\n    uint256 public decimals = 18;\r\n    uint256 override public totalSupply = 2100 * 10**8 * 10**18;\r\n\r\n    uint256 public minCirculation = 21000000;\r\n    uint256 public blackholeLimit = totalSupply - minCirculation;\r\n    \r\n    address public ecologicalFund;\r\n    address public constant blackhole = 0x0000000000000000000000000000000000000001;\r\n\r\n    bool private _feeIt = true;\r\n    uint256 private _tax = 8;\r\n    uint256 private _feeShareByBlackhole = 20;\r\n    uint256 private _feeShareByMarketReward = 80;\r\n\r\n    uint256 private _feeShareByLps = 30;\r\n    uint256 private _feeShareByOwned = 20;\r\n    uint256 private _feeShareBySuperPartner = 10;\r\n    uint256 private _feeShareByCommunityPartner = 10;\r\n    uint256 private _feeShareByEcologicalFund = 10;\r\n\r\n    uint256 private enterCount = 0;\r\n    uint256 private constant DIVIDING = 100 * 10**18;\r\n\r\n    mapping(address => bool) private stores;\r\n    mapping(address => bool) private operators;\r\n\r\n    address[] superPartnerList;\r\n    uint256 public superPartnerCount;\r\n    uint256 public constant SUPER_PARTNER_LIMIT = 19;\r\n\r\n    address[] communityPartnerList;\r\n    uint256 public communityPartnerCount;\r\n    uint256 public constant COMMUNITY_PARTNER_LIMIT = 199;\r\n\r\n    address[] liquidityRewardAccountList;\r\n    mapping(address => bool) liquidityRewardAccounts;\r\n\r\n    uint256[8] marketRewardPercents = [40, 20, 10, 10, 5, 5, 5, 5];\r\n    address constant pancakeSwapRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    \r\n    // modifier\r\n    modifier onlyStore{\r\n        require(stores[_msgSender()], \"Warning: No permissions.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator{\r\n        require(operators[_msgSender()], \"Warning: No permissions.\");\r\n        _;\r\n    }\r\n    \r\n    modifier transferCounter {\r\n        enterCount = enterCount.add(1);\r\n        _;\r\n        enterCount = enterCount.sub(1, \"transfer counter\");\r\n    }\r\n\r\n    // constructor\r\n    constructor(address _ecologicalFund) {\r\n\r\n        ecologicalFund = _ecologicalFund;\r\n        _owned[_msgSender()].balanceOf = totalSupply;\r\n\r\n        operators[_msgSender()] = true;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n\r\n        emit Transfer(address(0), _msgSender(), totalSupply);\r\n    }\r\n\r\n    // set \r\n\r\n    function setOperator(address account, bool isEnable) external onlyOwner {\r\n        require(account != address(0), \"Warning: This address cannot be zero.\");\r\n        require(account != owner(), \"Warning: The owner's permissions cannot be changed.\");\r\n        operators[account] = isEnable;\r\n    }\r\n    \r\n    function setStore(address account, bool isEnable) external onlyOwner {\r\n        require(account != address(0), \"Warning: This address cannot be zero.\");\r\n        require(account != owner(), \"Warning: The owner's permissions cannot be changed.\");\r\n        stores[account] = isEnable;\r\n    }\r\n    \r\n    function setEcologicalFund(address account) public onlyOperator {\r\n        require(account != address(0), \"Warning: This address cannot be zero.\");\r\n        ecologicalFund = account;\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n\r\n    function excludeFromReward(address account) public onlyOperator {\r\n        require(!_isExcludedFromReward[account], \"Account is already excluded\");\r\n        _isExcludedFromReward[account] = true;\r\n        _excludedFromRewardList.push(account);\r\n    }\r\n\r\n    function includeInReward(address account) external onlyOperator {\r\n        require(_isExcludedFromReward[account], \"Account is already excluded\");\r\n        for (uint256 i = 0; i < _excludedFromRewardList.length; i++) {\r\n            if (_excludedFromRewardList[i] == account) {\r\n                _excludedFromRewardList[i] = _excludedFromRewardList[_excludedFromRewardList.length - 1];\r\n                _isExcludedFromReward[account] = false;\r\n                _excludedFromRewardList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function excludeFromFee(address account) public onlyOperator {\r\n        _isExcludedFromFee[account] = true;\r\n        _excludedFromFeeList.push(account);\r\n    }\r\n\r\n    function includeInFee(address account) public onlyOperator {\r\n        _isExcludedFromFee[account] = false;\r\n        \r\n        for (uint256 i = 0; i < _excludedFromFeeList.length; i++) {\r\n            if (_excludedFromFeeList[i] == account) {\r\n                _excludedFromFeeList[i] = _excludedFromFeeList[_excludedFromFeeList.length - 1];\r\n                _excludedFromFeeList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addLiquidityRewardAccount(address[] memory accounts) public onlyOperator {\r\n        for(uint256 i = 0; i < accounts.length; i++){\r\n            address account = accounts[i];\r\n            if(!liquidityRewardAccounts[account]){\r\n                liquidityRewardAccounts[account] = true;\r\n                liquidityRewardAccountList.push(account);\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeLiquidityRewardAccount(address account) public onlyOperator {\r\n\r\n        liquidityRewardAccounts[account] = false;\r\n        for(uint256 i = 0; i < liquidityRewardAccountList.length; i++){\r\n            if(liquidityRewardAccountList[i] == account){\r\n                liquidityRewardAccountList[i] = liquidityRewardAccountList[liquidityRewardAccountList.length - 1];\r\n                liquidityRewardAccountList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateOwned(address account, address ref, uint256 level) public onlyStore {\r\n        require(account != address(0), \"Warning: Can not be a zero\");\r\n\r\n        if(level == 1){\r\n            require(communityPartnerCount <= COMMUNITY_PARTNER_LIMIT, \"Warning: The number of recruits has reached the upper limit.\");\r\n            communityPartnerList.push(account);\r\n            communityPartnerCount += 1;\r\n\r\n            _owned[account].level = level;\r\n        }\r\n\r\n        if(level == 2){\r\n            require(superPartnerCount <= SUPER_PARTNER_LIMIT, \"Warning: The number of recruits has reached the upper limit.\");\r\n            superPartnerList.push(account);\r\n            superPartnerCount += 1;\r\n\r\n            _owned[account].level = level;\r\n        }\r\n\r\n        if(_owned[account].referrer == address(0)){\r\n            _owned[account].referrer = ref;\r\n        }\r\n\r\n    }\r\n\r\n    // erc20 function\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _owned[account].balanceOf;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool){\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256){\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool){\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool){\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool){\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    // get\r\n\r\n    function getStore(address account) external view returns (bool){\r\n        return stores[account];\r\n    }\r\n    \r\n    function getOperator(address account) external view returns (bool){\r\n        return operators[account];\r\n    }\r\n\r\n    function getOwend(address account) external view returns (Owned memory) {\r\n        return _owned[account];\r\n    }\r\n\r\n    function getRefByOwend(address account) external view returns (address) {\r\n        return _owned[account].referrer;\r\n    }\r\n    \r\n    function getAllSuperPartners() public view returns(address[] memory){\r\n        return superPartnerList;\r\n    }\r\n\r\n    function getAllCommunityPartners() public view returns(address[] memory){\r\n        return communityPartnerList;\r\n    }\r\n\r\n    function isExcludedFromReward(address account) public view returns (bool) {\r\n        return _isExcludedFromReward[account];\r\n    }\r\n    \r\n    function getExcludedFromRewardList() external view returns(address[] memory){\r\n        return _excludedFromRewardList;\r\n    }\r\n\r\n    function isExcludedFromFee(address account) public view returns (bool) {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n    \r\n    function getExcludedFromFeeList() external view returns(address[] memory){\r\n        return _excludedFromFeeList;\r\n    }\r\n\r\n    function getLiquidityRewardAccount(address account) public view returns(bool) {\r\n        return liquidityRewardAccounts[account];\r\n    }\r\n\r\n    function getAllLiquidityRewardAccount() public view returns(address[] memory) {\r\n        return liquidityRewardAccountList;\r\n    }\r\n\r\n    function getAllOwend() public view returns(address[] memory){\r\n        return ownedList;\r\n    }\r\n\r\n    // pay\r\n    receive() external payable {}\r\n\r\n    // private\r\n    function _removeAllFee() private {\r\n        if (!_feeIt) return;\r\n        _feeIt = false;\r\n    }\r\n\r\n    function _restoreAllFee() private {\r\n        _feeIt = true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        \r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private transferCounter {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        //indicates if fee should be deducted from transfer\r\n        bool takeFee = true;\r\n\r\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\r\n            takeFee = false;\r\n        }\r\n\r\n        if (!takeFee) _removeAllFee();\r\n        \r\n        _transferStandard(from, to, amount);\r\n\r\n        if(!_owned[to].active){\r\n            _owned[to].active = true;\r\n            ownedList.push(to);\r\n        }\r\n\r\n        if (!takeFee) _restoreAllFee();\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 amount) private {\r\n        (uint256 amountAfterTax, uint256 tax) = _getTxValues(amount);\r\n        \r\n        _owned[sender].balanceOf = _owned[sender].balanceOf.sub(amount, \"sub1 amount\");\r\n        _owned[recipient].balanceOf = _owned[recipient].balanceOf.add(amountAfterTax);\r\n\r\n        if (amount >= DIVIDING && _owned[recipient].lockRef == false){\r\n            _owned[recipient].referrer = sender;\r\n            _owned[recipient].lockRef = true;\r\n        }\r\n        \r\n        emit Transfer(sender, recipient, amountAfterTax);\r\n        \r\n        if (_feeIt) {\r\n\r\n            if(sender == pancakeSwapRouter) {\r\n\r\n                uint256 blackholeAmount = ((tax * _feeShareByBlackhole) / 100);\r\n                uint256 atferBlackholeDestruction = _blackholeMechanism(blackholeAmount);\r\n                _owned[ecologicalFund].balanceOf = _owned[ecologicalFund].balanceOf.add(atferBlackholeDestruction);\r\n\r\n                uint256 marketRewardAmount = ((tax * _feeShareByMarketReward) / 100);\r\n                uint256 atferMarketRewardAmount = _rewardReferrers(recipient, marketRewardAmount);\r\n                _owned[ecologicalFund].balanceOf = _owned[ecologicalFund].balanceOf.add(atferMarketRewardAmount);\r\n\r\n            } else {\r\n                uint256 ecologicalFundAmount = 0;\r\n\r\n                // blackhole\r\n                uint256 blackholeAmount = ((tax * _feeShareByBlackhole) / 100);\r\n                uint256 atferBlackholeDestruction = _blackholeMechanism(blackholeAmount);\r\n                ecologicalFundAmount += atferBlackholeDestruction;\r\n\r\n                // superPartner\r\n                uint256 superPartnerAmount = ((tax * _feeShareBySuperPartner) / 100);\r\n                uint256 atferSuperPartnerDividend = _superPartnerDividend(superPartnerAmount);\r\n                ecologicalFundAmount += atferSuperPartnerDividend;\r\n\r\n                // community\r\n                uint256 communityPartnerAmount = ((tax * _feeShareByCommunityPartner) / 100);\r\n                uint256 atferCommunityPartnerDividend = _communityPartnerDividend(communityPartnerAmount);\r\n                ecologicalFundAmount += atferCommunityPartnerDividend;\r\n\r\n                // owend\r\n                uint256 owendAmount = ((tax * _feeShareByOwned) / 100);\r\n                uint256 atferOwendDividend = _ownedDividend(owendAmount);\r\n                ecologicalFundAmount += atferOwendDividend;\r\n\r\n                // LPS\r\n                uint256 lpsAmount = ((tax * _feeShareByLps) / 100);\r\n                uint256 atferLpsDividend = _lpsDividend(lpsAmount);\r\n                ecologicalFundAmount += atferLpsDividend;\r\n\r\n                // ecologicalFund\r\n                ecologicalFundAmount += ((tax * _feeShareByEcologicalFund) / 100);\r\n                _owned[ecologicalFund].balanceOf = _owned[ecologicalFund].balanceOf.add(ecologicalFundAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _rewardReferrers(address account, uint256 amount) internal returns(uint256 amountAfterDeduction){\r\n\r\n        uint256 refReward;\r\n        address currentAccount = account;\r\n        amountAfterDeduction = amount;\r\n\r\n        for(uint256 i = 0; i < marketRewardPercents.length; i++){\r\n            address ref = _owned[currentAccount].referrer;\r\n            if(ref == address(0)){\r\n                break;\r\n            }\r\n\r\n            if(_checkIterationCount(ref) < i.add(1)) {\r\n                continue;\r\n            }\r\n\r\n            refReward = ((amount * marketRewardPercents[i]) / 100);\r\n            _owned[ref].balanceOf += refReward;\r\n\r\n            currentAccount = ref;\r\n            amountAfterDeduction = amount - refReward;\r\n        }\r\n\r\n        return amountAfterDeduction;\r\n    }\r\n\r\n    function _checkIterationCount(address ref) internal view returns (uint256 i) {\r\n\r\n        if(_owned[ref].balanceOf >= 100 * 10**18){\r\n            if(_owned[ref].balanceOf >= 1000 * 10**18){\r\n                if(_owned[ref].balanceOf >= 10000 * 10**18){\r\n                    if(_owned[ref].balanceOf >= 100000  * 10**18){\r\n                        return 8;\r\n                    } else {\r\n                        return 6;\r\n                    }\r\n                } else {\r\n                    return 4;\r\n                }\r\n            } else {\r\n                return 2;\r\n            }\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function _getTxValues(uint256 amount) private view returns (uint256 amountAfterTax, uint256 tax){\r\n        \r\n        if (!_feeIt) {\r\n            return (amount, 0);\r\n        }\r\n        \r\n        tax = ((amount * _tax) / 100); \r\n        amountAfterTax = amount - tax;\r\n    }\r\n\r\n    function _blackholeMechanism(uint256 amount) internal returns (uint256 atferBlackholeDestruction){\r\n        atferBlackholeDestruction = amount;\r\n        uint256 blackholeBalanceOf = _owned[blackhole].balanceOf;\r\n        \r\n        if(blackholeBalanceOf <= blackholeLimit){\r\n            uint256 destructionAmount = ((atferBlackholeDestruction * _feeShareByBlackhole) / 100);\r\n\r\n            if((blackholeBalanceOf + destructionAmount) <= blackholeLimit){\r\n                _owned[blackhole].balanceOf += destructionAmount;\r\n                atferBlackholeDestruction -= destructionAmount;\r\n                return atferBlackholeDestruction;\r\n            } else {\r\n                destructionAmount = ((blackholeBalanceOf + destructionAmount) - blackholeLimit);\r\n                _owned[blackhole].balanceOf += destructionAmount;\r\n                atferBlackholeDestruction -= destructionAmount;\r\n                return atferBlackholeDestruction;\r\n            }\r\n        }\r\n\r\n        return atferBlackholeDestruction;\r\n    }\r\n\r\n    function _superPartnerDividend(uint256 amount) internal returns(uint256 unallocateAmount){\r\n\r\n        uint256 allocateAmount = 0;\r\n        if(superPartnerList.length > 0 && amount > 0){\r\n            uint256 avgAmount = amount/superPartnerList.length;\r\n            for(uint256 i = 0; i < superPartnerList.length; i++){\r\n                _owned[superPartnerList[i]].balanceOf = _owned[superPartnerList[i]].balanceOf.add(avgAmount);\r\n                allocateAmount += avgAmount;\r\n            }\r\n        }\r\n\r\n        unallocateAmount = amount - allocateAmount;\r\n\r\n        return unallocateAmount;\r\n    }\r\n\r\n    function _communityPartnerDividend(uint256 amount) internal returns(uint256 unallocateAmount){\r\n\r\n        uint256 allocateAmount = 0;\r\n        if(communityPartnerList.length > 0 && amount > 0){\r\n            uint256 avgAmount = amount/communityPartnerList.length;\r\n            for(uint256 i = 0; i < communityPartnerList.length; i++){\r\n                _owned[communityPartnerList[i]].balanceOf = _owned[communityPartnerList[i]].balanceOf.add(avgAmount);\r\n                allocateAmount += avgAmount;\r\n            }\r\n        }\r\n\r\n        unallocateAmount = amount - allocateAmount;\r\n\r\n        return unallocateAmount;\r\n    }\r\n\r\n    function _ownedDividend(uint256 amount) internal returns(uint256 unallocateAmount){\r\n\r\n        uint256 allocateAmount = 0;\r\n        if(ownedList.length > 0 && amount > 0){\r\n            uint256 avgAmount = amount/ownedList.length;\r\n\r\n            for(uint256 i = 0; i < ownedList.length; i++){\r\n                _owned[ownedList[i]].balanceOf = _owned[ownedList[i]].balanceOf.add(avgAmount);\r\n                allocateAmount += avgAmount;\r\n            }\r\n        }\r\n\r\n        unallocateAmount = amount - allocateAmount;\r\n\r\n        return unallocateAmount;\r\n    }\r\n\r\n    // liquidity Reward Account\r\n    function _lpsDividend(uint256 amount) internal returns(uint256 unallocateAmount){\r\n\r\n        uint256 allocateAmount = 0;\r\n        if(liquidityRewardAccountList.length > 0 && amount > 0){\r\n            uint256 avgAmount = amount/liquidityRewardAccountList.length;\r\n\r\n            for(uint256 i = 0; i < liquidityRewardAccountList.length; i++){\r\n                _owned[liquidityRewardAccountList[i]].balanceOf = _owned[liquidityRewardAccountList[i]].balanceOf.add(avgAmount);\r\n                allocateAmount += avgAmount;\r\n            }\r\n        }\r\n\r\n        unallocateAmount = amount - allocateAmount;\r\n\r\n        return unallocateAmount;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ecologicalFund\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COMMUNITY_PARTNER_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPER_PARTNER_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addLiquidityRewardAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackhole\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackholeLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityPartnerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecologicalFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllCommunityPartners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllLiquidityRewardAccount\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllOwend\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllSuperPartners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExcludedFromFeeList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExcludedFromRewardList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLiquidityRewardAccount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getOwend\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balanceOf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"lockRef\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct F8.Owned\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getRefByOwend\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getStore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minCirculation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeLiquidityRewardAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setEcologicalFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEnable\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEnable\",\"type\":\"bool\"}],\"name\":\"setStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superPartnerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"updateOwned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "F8", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e2e51586c8255dd2a456a7544179b241053a4b20", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://75ebe749967e7997192a9a3eda4ae05119d115be7a0bd4521d3196efc359c894"}