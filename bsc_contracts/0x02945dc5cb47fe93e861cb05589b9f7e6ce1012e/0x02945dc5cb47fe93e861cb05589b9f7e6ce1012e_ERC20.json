{"SourceCode": "///// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\ninterface  administrator {\r\n    function getOwner() external view returns (address); \r\n    function licenceSet(address _who,bool  enable) external  returns (bool) ;\r\n    function TokenNamepermissionSet(string memory  _name,bool _state) external  returns (bool);\r\n    function transferpermissionSet(address _who,bool  enable) external  returns (bool);\r\n    function Qmathaddress() external view  returns (address _mathaddress);\r\n    function Qusdaddress() external view  returns (address _usdaddress);\r\n    function QBaseTokenmanagement() external view returns (address _BaseTokenmanagement);\r\n    function Qtokendatabase() external view  returns (address _tokendatabase);\r\n    function QMembship() external view  returns (address _Membship);\r\n    function qtransferpermission(address _who) external view returns (bool);\r\n    function licence(address _who) external view  returns (bool);\r\n    function QDaoAddress() external view  returns (address _DaoAddress) ;\r\n    function QTdbAddress() external view returns (address _TdbAddress);\r\n    function Qcommission() external view returns (uint  ommissionRate_);\r\n    function QTokenNamepermission(string memory _name) external view returns (bool _state);\r\n}\r\ninterface BaseTokenmanagement{\r\n    function AddData(address _token1,uint32 _varieties,uint256 _n1,uint256  _n2) external  returns (bool _complete);\r\n    function QAddData0(address _who) external view  returns (uint32 varieties_);\r\n    function QAddData(address _who) external view  returns (uint32 varieties_,uint256 tokenN1_,uint256 tokenN2_);\r\n}\r\ninterface IERC20 {\r\n    function name() external view  returns (string memory);\r\n    function symbol() external view returns (string memory);    \r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);  \r\n}\r\ninterface Math  {\r\n   function isContract(address account) external view returns (bool);\r\n   function mathpermissionSet(address _who,bool  enable)external returns (bool);\r\n   function qmathpermission(address _who) external view returns (bool);\r\n   function Qnowprice(uint256 Tamount,uint256 unitsNumber,uint256 multiple) external view returns (uint256 _price) ;\r\n   function QBIPprice(uint256 _tokenvalue,uint256 Tamount,uint256 unitsNumber,uint256 multiple) external view  returns (uint256 _price);\r\n   function QSIPprice(uint256 _tokenvalue,uint256 Tamount,uint256 unitsNumber,uint256 multiple) external view  returns (uint256  _price);\r\n   function QBuy(uint256 _tokenvalue,uint256 Tamount,uint256 unitsNumber,uint256 multiple) external view  returns (uint256 _usdcvalue);\r\n   function QSell(uint256 _tokenvalue,uint256 Tamount,uint256 unitsNumber,uint256 multiple) external view  returns (uint256 _usdcvalue);\r\n   function Qpurchase(uint256 usdvalue,uint256 Tamount,uint256 unitsNumber,uint256 multiple) external view  returns (uint256 _uv,uint256 _tv);\r\n    } \r\ninterface MemberManagement  {\r\n    function init(address _who) external returns (bool _complete);\r\n    function MemberMa(address _from,address _to) external returns (bool _complete);\r\n    function SetCommunity ()external;\r\n    function SetCeo (address _who) external;\r\n    function SetManager (address _who) external;\r\n    function acceptUP  (address _who,uint256 _amo) external;\r\n    function Qaddress1(address _who) external view  returns(uint256 _MsAdToN,address _MsFa,address _community,address _Ceo,address _Manager,address _ExDi,address _Agent);\r\n    function Qnum(uint256 _num) external view  returns (address _who);\r\n    function QAchievement(address _who) external view  returns (uint256 _num);\r\n    function QApNu()external view  returns (uint256 _num);\r\n}\r\ninterface tokendatabase  {\r\n    function AddData(address _token1,address _token2,address _tokenswap) external  returns (bool _complete);\r\n    function QAddData(address _who) external view returns(uint256 tokenNum_,address tokenexchange_ ,address _tokenswap,string memory  _name1,string memory _name2);\r\n    function qQAddDatanum(uint256 _num)external view returns(address _token1,address tokenexchange_ ,address _tokenswap,string  memory _name1,string memory  _name2);\r\n}\r\n\r\ncontract CreateToken {\r\n\r\n    address newtoken;\r\n    address newswap;\r\n    administrator creatorT =administrator(0xBd541dFa9d184A6fEb4823D79c191AC19E17049c);\r\n    uint256 Expensestandard=300000000000000000000;/////////////////////////\r\n\r\n    function ExpensestandardSet(uint256 mun)   public   {\r\n    require( creatorT.licence(msg.sender) == true);\r\n    Expensestandard=mun;\r\n    }\r\n\r\n    function createToken \r\n     (string memory setname, string memory setsymbol,uint256 unitsNumber,\r\n     address usd,uint256 multiple,uint256 _Capitalpror,uint256 _commissionRate)\r\n    public virtual{\r\n\r\n    require(  creatorT.QTokenNamepermission(setname)==false );\r\n    require( _Capitalpror<=1500);   \r\n    require( _commissionRate<=1500 && _commissionRate>=creatorT.Qcommission());     \r\n    require(multiple>=1 && multiple<=1000000000);\r\n    require(unitsNumber>=10**19  && unitsNumber<=10**35 );///////////////////\r\n\r\n    BaseTokenmanagement bt=BaseTokenmanagement(creatorT.QBaseTokenmanagement());\r\n    require(bt.QAddData0(usd)==1);\r\n\r\n    MemberManagement mbm =MemberManagement(creatorT.QMembship());\r\n    tokendatabase tt=tokendatabase(creatorT.Qtokendatabase());\r\n   \r\n    ERC20 usdc=ERC20 (creatorT.Qusdaddress());\r\n    usdc.transferFrom(msg.sender,creatorT.getOwner()  , Expensestandard);//////////////////////////////\r\n    //\r\n    ERC20 temp1 = new ERC20() ;\r\n    TDBswap temp2 = new TDBswap() ;\r\n    //Set\r\n    temp1.initialize( setname, setsymbol, unitsNumber,address(temp2),msg.sender );\r\n    temp2.initialize(  usd,address(temp1),msg.sender,unitsNumber,multiple ,_Capitalpror, _commissionRate);  \r\n    creatorT.TokenNamepermissionSet(setname,true);\r\n    mbm.init(address(temp2));//////////////////////////////////\r\n    creatorT.licenceSet( address(temp2),true);\r\n    tt. AddData( address(temp1),  usd, address(temp2));\r\n    addset(address(temp1),address(temp2));\r\n    \r\n    }\r\n\r\n    function addset(address ta1,address ta2)   internal   {\r\n    Math matha=Math(creatorT.Qmathaddress());\r\n    matha.mathpermissionSet(ta2,true);\r\n    newtoken=ta1;\r\n    newswap=ta2;\r\n    }\r\n\r\n    function Qaddress() public view virtual returns (address,address) {\r\n    return (address(newtoken),address(newswap));\r\n    }\r\n}\r\n   \r\ncontract ERC20 is Context,IERC20 {\r\n    \r\n    mapping (address => uint256) private _balances;\r\n    address private creator;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool)  private  transferpermission;\r\n    mapping (address => mapping(address =>bool) ) private  selftransferpermission;\r\n    uint256 private _totalSupply;\r\n    uint256 private unitsNumber;\r\n    string private _name;\r\n    string private _symbol;\r\n    address private _swapaddress;\r\n    administrator creatorT =administrator(0xBd541dFa9d184A6fEb4823D79c191AC19E17049c);\r\n    function initialize(string memory name_, string memory symbol_,uint256  _unitsNumber,address  Swapadd ,address creator_) public virtual {\r\n        require(_totalSupply ==0);//////////////////////////////////////////////\r\n        require( creatorT.licence(msg.sender) == true);\r\n        creator=creator_;\r\n         _name = name_;\r\n        _symbol = symbol_;\r\n        unitsNumber=_unitsNumber;\r\n        _mint(Swapadd,unitsNumber*300);\r\n        _swapaddress=Swapadd;\r\n        transferpermission[_swapaddress] = true;\r\n    }\r\n\r\n    function isContract(address account) public view returns (bool) {    \r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (!(codehash != 0x0 && codehash != accountHash)||creatorT.qtransferpermission(account) == true\r\n         ||qtransferpermission(account) == true ||selftransferpermission[msg.sender][account] == true);\r\n    }\r\n\r\n    function transferpermissionSet(address _who,bool  enable) public  returns (bool) {\r\n        require( msg.sender==creator);\r\n        require( _who!=_swapaddress);\r\n        transferpermission[_who] = enable;\r\n        return true;\r\n    }\r\n\r\n    function selftransferpermissionSet(address _who,bool  enable) public  returns (bool) {\r\n        selftransferpermission[msg.sender][_who] = enable;\r\n        return true;\r\n    }\r\n  ///////////////////////////\r\n    function qselftransferpermission(address _who) public view virtual returns (bool) {\r\n        return selftransferpermission[msg.sender][_who];\r\n    }\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n    ////////////////////////////////////////////\r\n    function qtransferpermission(address _who) public view virtual returns (bool) {\r\n        return transferpermission[ _who];\r\n    }\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overloaded;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function swapaddress() public view virtual  returns (address) {\r\n        return _swapaddress;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n \r\n         \r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        ////////////////////////////////////////////\r\n       \r\n        require( isContract(recipient)==true );//////////////////////\r\n        \r\n        //////////////////////////////////\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        /////////////////////////////////\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function MintToSwap() public virtual returns (bool){\r\n        require( msg.sender==creator ||creatorT.licence(msg.sender) == true );\r\n        TDBswap t1 = TDBswap(_swapaddress);\r\n        require(t1.QTamount()>(_totalSupply*97/100) );\r\n        _mint(_swapaddress,unitsNumber*100);  \r\n        return true;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function Qcreator() public view  returns (address _creator){\r\n      return creator;  \r\n    }\r\n} \r\ncontract TDBswap {\r\n    administrator creatorT =administrator(0xBd541dFa9d184A6fEb4823D79c191AC19E17049c);\r\n    mapping (address => bool)  private  transferpermission;\r\n    address private creator;\r\n    uint256 private  unitsNumber;\r\n    uint256 private  multiple;\r\n    uint256 private Capitalpror;\r\n    uint256 private commissionRate;\r\n    bool private  state;\r\n    //Transactions   \r\n    uint256 private Counter;\r\n    mapping(uint256=>bool)ts;\r\n    mapping(uint256=>uint256)tq1;\r\n    mapping(uint256=>uint256)tq2;\r\n    mapping(uint256=>uint256)time;\r\n    mapping(uint256=>address)user;\r\n\r\n    uint256 private Tamount;\r\n    uint256 private Uamount;\r\n    IERC20 myToken; \r\n    IERC20 Usdt1;  \r\n\r\n    function initialize\r\n    ( address usd,address _myToken,address _creator ,uint256 _unitsNumber,uint256 _multiple,\r\n    uint256 _Capitalpror,uint256 _commissionRate) public virtual {\r\n        require(unitsNumber==0);\r\n        creator=_creator;\r\n        Usdt1 = IERC20(usd);\r\n        myToken = ERC20(_myToken);\r\n        multiple=_multiple;\r\n        Counter=0;\r\n        unitsNumber =_unitsNumber;\r\n        Capitalpror=_Capitalpror;\r\n        commissionRate=_commissionRate;\r\n        state=false;\r\n    }\r\n    function isContract(address account) public view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    function StateSet(bool _state) public returns (bool success) {\r\n    require(msg.sender==creator);\r\n    state=_state;\r\n    return true;   \r\n    }   \r\n    /////////////////////////\r\n    function Creatorchange(address newCreator) public returns (bool success) {\r\n    require(msg.sender==creator);\r\n    require(isContract(newCreator)==false);\r\n    creator=newCreator;\r\n    return true;   \r\n    }\r\n    //////////////////////////\r\n    function CapitalprorSet(uint256 _Capitalpror) public returns (bool success) {\r\n    require(msg.sender==creator);\r\n    require(_Capitalpror<Capitalpror );\r\n    Capitalpror=_Capitalpror;\r\n    return true;   \r\n    }\r\n    //////////////////////\r\n    function commissionSet(uint256 _commissionRate) public returns (bool success) {\r\n    require(msg.sender==creator);\r\n    require(_commissionRate< commissionRate  &&  _commissionRate>=creatorT.Qcommission());\r\n    commissionRate=_commissionRate;\r\n    return true;   \r\n    }\r\n\r\n    function Buy( uint256 _tokenvalue,uint256 _usdvalue,uint256 _data ) public  returns (bool success) {  \r\n    require(_tokenvalue > 0 && ( myToken.balanceOf(msg.sender)+_tokenvalue )<unitsNumber); \r\n    if(state==false){\r\n      require(transferpermission[msg.sender]==true||creatorT.qtransferpermission(msg.sender)==true);\r\n     }\r\n    if(state==true ){\r\n      require(transferpermission[msg.sender]==true||isContract(msg.sender)==false||creatorT.qtransferpermission(msg.sender)==true);\r\n     }     \r\n    require(_data<1000);\r\n    uint256  v1;uint256  p1;\r\n    (,v1)=Qpurchase(_usdvalue) ;//price\r\n    require( v1 >= (_tokenvalue*(1000-_data)/1000));\r\n     p1=QBuy(v1);\r\n     require(p1>=10000000);\r\n     require(Usdt1.balanceOf(msg.sender)>=p1);\r\n     require(Usdt1.allowance(msg.sender,address(this)) >= p1); \r\n     assert(Usdt1.transferFrom(msg.sender,address(this),p1));\r\n\r\n     MemberManagement mbm =MemberManagement(creatorT.QMembship());\r\n     assert(myToken.transfer(msg.sender,v1*(10000-Capitalpror-commissionRate)/10000));\r\n     assert(myToken.transfer(creator,v1*Capitalpror/10000));\r\n\r\n     mbm.MemberMa(creatorT.getOwner(),msg.sender);\r\n     mbm.acceptUP (msg.sender,p1);\r\n     address a1;address a2;address a3;address a4;address a5;\r\n     (,,a1,a2,a3,a4,a5)=mbm. Qaddress1(msg.sender);\r\n    assert(myToken.transfer(a1,v1*commissionRate/50000));\r\n    assert(myToken.transfer(a2,v1*commissionRate/50000));\r\n    assert(myToken.transfer(a3,v1*commissionRate/50000));\r\n    assert(myToken.transfer(a4,v1*commissionRate/50000));\r\n    assert(myToken.transfer(a5,v1*commissionRate/50000));\r\n\r\n     Tamount+=v1;\r\n     Uamount+=p1;\r\n\r\n    Counter++; \r\n    ts[Counter]=true;\r\n    tq1[Counter]=v1;\r\n    tq2[Counter]=p1;\r\n    time[Counter]=block.timestamp;  \r\n    user [Counter]=msg.sender;\r\n\r\n    return true;\r\n       }\r\n\r\n     function Sell(uint256 _tokenvalue,uint256 _usdvalue,uint256 _data) public  returns (bool success) {\r\n      require(transferpermission[msg.sender]==true||isContract(msg.sender)==false||creatorT.qtransferpermission(msg.sender)==true);\r\n      require(_data<100);   \r\n      uint256  p1 ;\r\n      p1=QSell(_tokenvalue) ;   \r\n      require(p1>(_usdvalue*(1000-_data)/1000) ); ///////////////\r\n      require(_tokenvalue <unitsNumber && _tokenvalue > 0 && myToken.balanceOf(msg.sender) >=  _tokenvalue && Tamount>=  _tokenvalue); \r\n\r\n      require(myToken.allowance(msg.sender,address(this)) >=  _tokenvalue); \r\n      require(p1>=10000000);\r\n      assert(myToken.transferFrom(msg.sender,address(this),_tokenvalue));   \r\n      assert(Usdt1.transfer(msg.sender,p1*(10000-Capitalpror-creatorT.Qcommission())/10000));\r\n      assert(Usdt1.transfer(creator,p1*Capitalpror/10000));\r\n      assert(Usdt1.transfer(creatorT.QTdbAddress(),p1*creatorT.Qcommission()/10000));\r\n      Tamount-=_tokenvalue;\r\n      Uamount-= p1 ;\r\n\r\n    Counter++; \r\n    ts[Counter]=false;\r\n    tq1[Counter]=_tokenvalue;\r\n    tq2[Counter]=p1;\r\n    time[Counter]=block.timestamp; \r\n    user [Counter]=msg.sender;\r\n    return true;\r\n       }  \r\n     \r\n      function QunitsNumber() public view  returns (uint256 _unitsNumber){\r\n      return unitsNumber;  \r\n      }\r\n      function Qmultiple() public view  returns (uint256 _multiple){\r\n      return  multiple;  \r\n      }\r\n      function QCapitalpror() public view  returns (uint256 _Capitalpror){\r\n      return Capitalpror;  \r\n      }\r\n      function QcommissionRate() public view  returns (uint256 _commissionRate){\r\n      return commissionRate;  \r\n      }\r\n      function QCounter() public view  returns (uint256 _Counter){\r\n      return Counter;  \r\n      }\r\n      function Qcreator() public view  returns (address _creator){\r\n      return creator;  \r\n      }\r\n      function QTamount() public view  returns (uint256 _Tamount){\r\n      return Tamount;  \r\n      }\r\n      function QUamount() public view  returns (uint256 _Uamount){\r\n      return Uamount;  \r\n      }\r\n      function QPurchaserate() public view  returns (uint256 _Purchaserate){\r\n      return Capitalpror+commissionRate;  \r\n      }\r\n      function QSellingrate() public view  returns (uint256 _Sellingrate){\r\n      return Capitalpror+creatorT.Qcommission();  \r\n      }  \r\n      function QbalanceOf() public view returns (uint256 _usdt,uint256 _ERC20) {\r\n      return(Usdt1.balanceOf(address(this)) ,myToken.balanceOf(address(this)) );  \r\n      }    \r\n      function QAccountbook(uint256 _n) public view returns\r\n      (bool _symbol,address _user,uint256 _token1,uint256 _token2,uint256 _time,uint256 _Counter ,uint256 _now) {\r\n      return(ts[_n],user [_n],tq1[_n],tq2[_n] ,time[_n],Counter,block.timestamp);  \r\n      }  \r\n      function nowprice() public view returns (uint256 _price) {\r\n      Math matha=Math(creatorT.Qmathaddress());    \r\n      return matha.Qnowprice(Tamount,unitsNumber,multiple);\r\n      } \r\n      function QBIPprice(uint256 _tokenvalue) public view  returns (uint256 _price){\r\n      Math matha=Math(creatorT.Qmathaddress());\r\n      return matha.QBIPprice( _tokenvalue,Tamount,unitsNumber,multiple);     \r\n      }\r\n      function QSIPprice(uint256 _tokenvalue) public view  returns (uint256  _price){\r\n      Math matha=Math(creatorT.Qmathaddress());     \r\n      return matha.QSIPprice( _tokenvalue,Tamount,unitsNumber,multiple); \r\n      }\r\n      function QBuy(uint256 _tokenvalue) public view  returns (uint256 _usdcvalue){\r\n      Math matha=Math(creatorT.Qmathaddress());     \r\n      return matha.QBuy(_tokenvalue,Tamount,unitsNumber,multiple);  \r\n      }\r\n      function QSell(uint256 _tokenvalue) public view  returns (uint256 _usdcvalue){\r\n      Math matha=Math(creatorT.Qmathaddress());     \r\n      return matha.QSell(_tokenvalue,Tamount,unitsNumber,multiple);  \r\n      }  \r\n      function Qpurchase(uint256 usdvalue) public view  returns (uint256 _uv,uint256 _tv){\r\n      Math matha=Math(creatorT.Qmathaddress());   \r\n      uint256 u1;uint256 v1;\r\n      (u1,v1)=matha.Qpurchase(usdvalue,Tamount,unitsNumber,multiple);\r\n      return(u1,v1) ; \r\n      }\r\n      function transferpermissionSet(address _who,bool  enable) public  returns (bool) {\r\n        require( msg.sender==creator);\r\n        require( _who!=address(this));\r\n        transferpermission[_who] = enable;\r\n        return true;\r\n    }\r\n      function qtransferpermission(address _who) public view virtual returns (bool) {\r\n        return transferpermission[ _who];\r\n    }\r\n      function qstate() public view virtual returns (bool) {\r\n        return state;\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MintToSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Qcreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_unitsNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Swapadd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creator_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"qselftransferpermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"qtransferpermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"selftransferpermissionSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"transferpermissionSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ERC20", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://15a0aaf8e98a9435437cc93ad311f43c7cd6171850e70ed8890cbc41ac9b8dee"}