{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/Denominations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Denominations {\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\\n\\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\\n  address public constant USD = address(840);\\n  address public constant GBP = address(826);\\n  address public constant EUR = address(978);\\n  address public constant JPY = address(392);\\n  address public constant KRW = address(410);\\n  address public constant CNY = address(156);\\n  address public constant AUD = address(36);\\n  address public constant CAD = address(124);\\n  address public constant CHF = address(756);\\n  address public constant ARS = address(32);\\n  address public constant PHP = address(608);\\n  address public constant NZD = address(554);\\n  address public constant SGD = address(702);\\n  address public constant NGN = address(566);\\n  address public constant ZAR = address(710);\\n  address public constant RUB = address(643);\\n  address public constant INR = address(356);\\n  address public constant BRL = address(986);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/ErrorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @title ErrorLibrary\\n * @author Velvet.Capital\\n * @notice This is a library contract including custom defined errors\\n */\\n\\nlibrary ErrorLibrary {\\n  error ContractPaused();\\n  /// @notice Thrown when caller is not rebalancer contract\\n  error CallerNotRebalancerContract();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotAssetManager();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotSuperAdmin();\\n  /// @notice Thrown when caller is not whitelist manager\\n  error CallerNotWhitelistManager();\\n  /// @notice Thrown when length of slippage array is not equal to tokens array\\n  error InvalidSlippageLength();\\n  /// @notice Thrown when length of tokens array is zero\\n  error InvalidLength();\\n  /// @notice Thrown when token is not permitted\\n  error TokenNotPermitted();\\n  /// @notice Thrown when user is not allowed to invest\\n  error UserNotAllowedToInvest();\\n  /// @notice Thrown when index token in not initialized\\n  error NotInitialized();\\n  /// @notice Thrown when investment amount is greater than or less than the set range\\n  error WrongInvestmentAmount(uint256 minInvestment, uint256 maxInvestment);\\n  /// @notice Thrown when swap amount is greater than BNB balance of the contract\\n  error NotEnoughBNB();\\n  /// @notice Thrown when the total sum of weights is not equal to 10000\\n  error InvalidWeights(uint256 totalWeight);\\n  /// @notice Thrown when balance is below set velvet min investment amount\\n  error BalanceCantBeBelowVelvetMinInvestAmount(uint256 minVelvetInvestment);\\n  /// @notice Thrown when caller is not holding underlying token amount being swapped\\n  error CallerNotHavingGivenTokenAmount();\\n  /// @notice Thrown when length of denorms array is not equal to tokens array\\n  error InvalidInitInput();\\n  /// @notice Thrown when the tokens are already initialized\\n  error AlreadyInitialized();\\n  /// @notice Thrown when the token is not whitelisted\\n  error TokenNotWhitelisted();\\n  /// @notice Thrown when denorms array length is zero\\n  error InvalidDenorms();\\n  /// @notice Thrown when token address being passed is zero\\n  error InvalidTokenAddress();\\n  /// @notice Thrown when token is not permitted\\n  error InvalidToken();\\n  /// @notice Thrown when token is not approved\\n  error TokenNotApproved();\\n  /// @notice Thrown when transfer is prohibited\\n  error Transferprohibited();\\n  /// @notice Thrown when transaction caller balance is below than token amount being invested\\n  error LowBalance();\\n  /// @notice Thrown when address is already approved\\n  error AddressAlreadyApproved();\\n  /// @notice Thrown when swap handler is not enabled inside token registry\\n  error SwapHandlerNotEnabled();\\n  /// @notice Thrown when swap amount is zero\\n  error ZeroBalanceAmount();\\n  /// @notice Thrown when caller is not index manager\\n  error CallerNotIndexManager();\\n  /// @notice Thrown when caller is not fee module contract\\n  error CallerNotFeeModule();\\n  /// @notice Thrown when lp balance is zero\\n  error LpBalanceZero();\\n  /// @notice Thrown when desired swap amount is greater than token balance of this contract\\n  error InvalidAmount();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInAlpacaProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValue();\\n  /// @notice Thrown when the mint function returned 0 for success & 1 for failure\\n  error MintProcessFailed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInApeSwap();\\n  /// @notice Thrown when the redeeming was success(0) or failure(1)\\n  error RedeemingCTokenFailed();\\n  /// @notice Thrown when native BNB is sent for any vault other than mooVenusBNB\\n  error PleaseDepositUnderlyingToken();\\n  /// @notice Thrown when redeem amount is greater than tokenBalance of protocol\\n  error NotEnoughBalanceInBeefyProtocol();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBeefy();\\n  /// @notice Thrown when the deposit amount of underlying token A is more than contract balance\\n  error InsufficientTokenABalance();\\n  /// @notice Thrown when the deposit amount of underlying token B is more than contract balance\\n  error InsufficientTokenBBalance();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBiSwapProtocol();\\n  //Not enough funds\\n  error InsufficientFunds(uint256 available, uint256 required);\\n  //Not enough eth for protocol fee\\n  error InsufficientFeeFunds(uint256 available, uint256 required);\\n  //Order success but amount 0\\n  error ZeroTokensSwapped();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInLiqeeProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValuePassed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInPancakeProtocol();\\n  /// @notice Thrown when Pid passed is not equal to Pid stored in Pid map\\n  error InvalidPID();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error InsufficientBalance();\\n  /// @notice Thrown when the redeem function returns 1 for fail & 0 for success\\n  error RedeemingFailed();\\n  /// @notice Thrown when the token passed in getUnderlying is not vToken\\n  error NotVToken();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInWombatProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountNotEqualToPassedValue();\\n  /// @notice Thrown when slippage value passed is greater than 100\\n  error SlippageCannotBeGreaterThan100();\\n  /// @notice Thrown when tokens are already staked\\n  error TokensStaked();\\n  /// @notice Thrown when contract is not paused\\n  error ContractNotPaused();\\n  /// @notice Thrown when offchain handler is not valid\\n  error OffHandlerNotValid();\\n  /// @notice Thrown when offchain handler is not enabled\\n  error OffHandlerNotEnabled();\\n  /// @notice Thrown when swapHandler is not enabled\\n  error SwaphandlerNotEnabled();\\n  /// @notice Thrown when account other than asset manager calls\\n  error OnlyAssetManagerCanCall();\\n  /// @notice Thrown when already redeemed\\n  error AlreadyRedeemed();\\n  /// @notice Thrown when contract is not paused\\n  error NotPaused();\\n  /// @notice Thrown when token is not index token\\n  error TokenNotIndexToken();\\n  /// @notice Thrown when swaphandler is invalid\\n  error SwapHandlerNotValid();\\n  /// @notice Thrown when token that will be bought is invalid\\n  error BuyTokenAddressNotValid();\\n  /// @notice Thrown when not redeemed\\n  error NotRedeemed();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerIsNotAssetManager();\\n  /// @notice Thrown when account other than asset manager is trying to pause\\n  error OnlyAssetManagerCanCallUnpause();\\n  /// @notice Thrown when trying to redeem token that is not staked\\n  error TokensNotStaked();\\n  /// @notice Thrown when account other than asset manager is trying to revert or unpause\\n  error FifteenMinutesNotExcedeed();\\n  /// @notice Thrown when swapping weight is zero\\n  error WeightNotGreaterThan0();\\n  /// @notice Thrown when dividing by zero\\n  error DivBy0Sumweight();\\n  /// @notice Thrown when lengths of array are not equal\\n  error LengthsDontMatch();\\n  /// @notice Thrown when contract is not paused\\n  error ContractIsNotPaused();\\n  /// @notice Thrown when set time period is not over\\n  error TimePeriodNotOver();\\n  /// @notice Thrown when trying to set any fee greater than max allowed fee\\n  error InvalidFee();\\n  /// @notice Thrown when zero address is passed for treasury\\n  error ZeroAddressTreasury();\\n  /// @notice Thrown when assetManagerFee or performaceFee is set zero\\n  error ZeroFee();\\n  /// @notice Thrown when trying to enable an already enabled handler\\n  error HandlerAlreadyEnabled();\\n  /// @notice Thrown when trying to disable an already disabled handler\\n  error HandlerAlreadyDisabled();\\n  /// @notice Thrown when zero is passed as address for oracle address\\n  error InvalidOracleAddress();\\n  /// @notice Thrown when zero is passed as address for handler address\\n  error InvalidHandlerAddress();\\n  /// @notice Thrown when token is not in price oracle\\n  error TokenNotInPriceOracle();\\n  /// @notice Thrown when address is not approved\\n  error AddressNotApproved();\\n  /// @notice Thrown when minInvest amount passed is less than minInvest amount set\\n  error InvalidMinInvestmentAmount();\\n  /// @notice Thrown when maxInvest amount passed is greater than minInvest amount set\\n  error InvalidMaxInvestmentAmount();\\n  /// @notice Thrown when zero address is being passed\\n  error InvalidAddress();\\n  /// @notice Thrown when caller is not the owner\\n  error CallerNotOwner();\\n  /// @notice Thrown when out asset address is zero\\n  error InvalidOutAsset();\\n  /// @notice Thrown when protocol is not paused\\n  error ProtocolNotPaused();\\n  /// @notice Thrown when protocol is paused\\n  error ProtocolIsPaused();\\n  /// @notice Thrown when proxy implementation is wrong\\n  error ImplementationNotCorrect();\\n  /// @notice Thrown when caller is not offChain contract\\n  error CallerNotOffChainContract();\\n  /// @notice Thrown when user has already redeemed tokens\\n  error TokenAlreadyRedeemed();\\n  /// @notice Thrown when user has not redeemed tokens\\n  error TokensNotRedeemed();\\n  /// @notice Thrown when user has entered wrong amount\\n  error InvalidSellAmount();\\n  /// @notice Thrown when trasnfer fails\\n  error WithdrawTransferFailed();\\n  /// @notice Thrown when caller is not having minter role\\n  error CallerNotMinter();\\n  /// @notice Thrown when caller is not handler contract\\n  error CallerNotHandlerContract();\\n  /// @notice Thrown when token is not enabled\\n  error TokenNotEnabled();\\n  /// @notice Thrown when index creation is paused\\n  error IndexCreationIsPause();\\n  /// @notice Thrown denorm value sent is zero\\n  error ZeroDenormValue();\\n  /// @notice Thrown when asset manager is trying to input token which already exist\\n  error TokenAlreadyExist();\\n  /// @notice Thrown when cool down period is not passed\\n  error CoolDownPeriodNotPassed();\\n  /// @notice Thrown When Buy And Sell Token Are Same\\n  error BuyAndSellTokenAreSame();\\n  /// @notice Throws arrow when token is not a reward token\\n  error NotRewardToken();\\n  /// @notice Throws arrow when MetaAggregator Swap Failed\\n  error SwapFailed();\\n  /// @notice Throws arrow when Token is Not  Primary\\n  error NotPrimaryToken();\\n  /// @notice Throws when the setup is failed in gnosis\\n  error ModuleNotInitialised();\\n  /// @notice Throws when threshold is more than owner length\\n  error InvalidThresholdLength();\\n  /// @notice Throws when no owner address is passed while fund creation\\n  error NoOwnerPassed();\\n  /// @notice Throws when length of underlying token is greater than 1\\n  error InvalidTokenLength();\\n  /// @notice Throws when already an operation is taking place and another operation is called\\n  error AlreadyOngoingOperation();\\n  /// @notice Throws when wrong function is executed for revert offchain fund\\n  error InvalidExecution();\\n  /// @notice Throws when Final value after investment is zero\\n  error ZeroFinalInvestmentValue();\\n  /// @notice Throws when token amount after swap / token amount to be minted comes out as zero\\n  error ZeroTokenAmount();\\n  /// @notice Throws eth transfer failed\\n  error ETHTransferFailed();\\n  /// @notice Thorws when the caller does not have a default admin role\\n  error CallerNotAdmin();\\n  /// @notice Throws when buyAmount is not correct in offchainIndexSwap\\n  error InvalidBuyValues();\\n  /// @notice Throws when token is not primary\\n  error TokenNotPrimary();\\n  /// @notice Throws when tokenOut during withdraw is not permitted in the asset manager config\\n  error _tokenOutNotPermitted();\\n  /// @notice Throws when token balance is too small to be included in index\\n  error BalanceTooSmall();\\n  /// @notice Throws when a public fund is tried to made transferable only to whitelisted addresses\\n  error PublicFundToWhitelistedNotAllowed();\\n  /// @notice Throws when list input by user is invalid (meta aggregator)\\n  error InvalidInputTokenList();\\n  /// @notice Generic call failed error\\n  error CallFailed();\\n  /// @notice Generic transfer failed error\\n  error TransferFailed();\\n  /// @notice Throws when incorrect token amount is encountered during offchain/onchain investment\\n  error IncorrectInvestmentTokenAmount();\\n  /// @notice Throws when final invested amount after slippage is 0\\n  error ZeroInvestedAmountAfterSlippage();\\n  /// @notice Throws when the slippage trying to be set is in incorrect range\\n  error IncorrectSlippageRange();\\n  /// @notice Throws when invalid LP slippage is passed\\n  error InvalidLPSlippage();\\n  /// @notice Throws when invalid slippage for swapping is passed\\n  error InvalidSlippage();\\n  /// @notice Throws when msg.value is less than the amount passed into the handler\\n  error WrongNativeValuePassed();\\n  /// @notice Throws when there is an overflow during muldiv full math operation\\n  error FULLDIV_OVERFLOW();\\n  /// @notice Throws when the oracle price is not updated under set timeout\\n  error PriceOracleExpired();\\n  /// @notice Throws when the oracle price is returned 0\\n  error PriceOracleInvalid();\\n  /// @notice Throws when the initToken or updateTokenList function of IndexSwap is having more tokens than set by the Registry\\n  error TokenCountOutOfLimit(uint256 limit);\\n  /// @notice Throws when the array lenghts don't match for adding price feed or enabling tokens\\n  error IncorrectArrayLength();\\n  /// @notice Common Reentrancy error for IndexSwap and IndexSwapOffChain\\n  error ReentrancyGuardReentrantCall();\\n  /// @notice Throws when user calls updateFees function before proposing a new fee\\n  error NoNewFeeSet();\\n  /// @notice Throws when token is not ETH\\n  error TokenNotETH();\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport {AggregatorV2V3Interface, AggregatorInterface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport {Denominations} from \\\"@chainlink/contracts/src/v0.8/Denominations.sol\\\";\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\n\\ncontract PriceOracle is Ownable {\\n  /// @notice Thrown when aggregator already exists in price oracle\\n  error AggregatorAlreadyExists();\\n  /// @notice Thrown when zero address is passed in aggregator\\n  error FeedNotFound();\\n\\n  struct AggregatorInfo {\\n    mapping(address => AggregatorV2V3Interface) aggregatorInterfaces;\\n  }\\n\\n  address public WETH;\\n\\n  mapping(address => AggregatorInfo) internal aggregatorAddresses;\\n\\n  uint256 public oracleExpirationThreshold;\\n\\n  // Events\\n  event addFeed(address[] base, address[] quote, AggregatorV2V3Interface[] aggregator);\\n  event updateFeed(address base, address quote, address aggregator);\\n\\n  constructor(address _WETH) {\\n    WETH = _WETH;\\n    oracleExpirationThreshold = 90000; // 25 hours\\n  }\\n\\n  /**\\n   * @notice Retrieve the aggregator of an base / quote pair in the current phase\\n   * @param base base asset address\\n   * @param quote quote asset address\\n   * @return aggregator\\n   */\\n  function _getFeed(address base, address quote) internal view returns (AggregatorV2V3Interface aggregator) {  \\n    aggregator = aggregatorAddresses[base].aggregatorInterfaces[quote];\\n  }\\n\\n  /**\\n   * @notice Add a new aggregator of an base / quote pair\\n   * @param base base asset address\\n   * @param quote quote asset address\\n   * @param aggregator aggregator\\n   */\\n  function _addFeed(\\n    address[] memory base,\\n    address[] memory quote,\\n    AggregatorV2V3Interface[] memory aggregator\\n  ) public onlyOwner {\\n    if (!((base.length == quote.length) && (quote.length == aggregator.length)))\\n      revert ErrorLibrary.IncorrectArrayLength();\\n\\n    for (uint256 i = 0; i < base.length; i++) {\\n      if(base[i] == address(0))\\n        revert ErrorLibrary.InvalidAddress();\\n      if(quote[i] == address(0))\\n        revert ErrorLibrary.InvalidAddress();\\n      if((address(aggregator[i])) == address(0))\\n        revert ErrorLibrary.InvalidAddress();\\n      \\n      if (aggregatorAddresses[base[i]].aggregatorInterfaces[quote[i]] != AggregatorInterface(address(0))) {\\n        revert AggregatorAlreadyExists();\\n      }\\n      aggregatorAddresses[base[i]].aggregatorInterfaces[quote[i]] = aggregator[i];\\n    }\\n    emit addFeed(base, quote, aggregator);\\n  }\\n\\n  /**\\n   * @notice Updatee an existing feed\\n   * @param base base asset address\\n   * @param quote quote asset address\\n   * @param aggregator aggregator\\n   */\\n  function _updateFeed(address base, address quote, AggregatorV2V3Interface aggregator) public onlyOwner {\\n    if(base == address(0))\\n      revert ErrorLibrary.InvalidAddress();\\n    if(quote == address(0))\\n      revert ErrorLibrary.InvalidAddress();\\n    if((address(aggregator)) == address(0))\\n      revert ErrorLibrary.InvalidAddress();\\n    \\n    aggregatorAddresses[base].aggregatorInterfaces[quote] = aggregator;\\n    emit updateFeed(base, quote, address(aggregator));\\n  }\\n\\n  /**\\n   * @notice Returns the decimals of a token pair price feed\\n   * @param base base asset address\\n   * @param quote quote asset address\\n   * @return Decimals of the token pair\\n   */\\n  function decimals(address base, address quote) public view returns (uint8) {\\n    AggregatorV2V3Interface aggregator = _getFeed(base, quote);\\n    if (address(aggregator) == address(0)) {\\n      revert FeedNotFound();\\n    }\\n    return aggregator.decimals();\\n  }\\n\\n  /**\\n   * @notice Returns the latest price\\n   * @param base base asset address\\n   * @param quote quote asset address\\n   * @return The latest token price of the pair\\n   */\\n  function latestRoundData(address base, address quote) internal view returns (int256) {\\n    (\\n      ,\\n      /*uint80 roundID*/\\n      int256 price /*uint startedAt*/ /*uint timeStamp*/ /*uint80 answeredInRound*/,\\n      ,\\n      uint256 updatedAt,\\n\\n    ) = aggregatorAddresses[base].aggregatorInterfaces[quote].latestRoundData();\\n\\n    if (updatedAt + oracleExpirationThreshold < block.timestamp) {\\n      revert ErrorLibrary.PriceOracleExpired();\\n    }\\n\\n    if (price == 0) {\\n      revert ErrorLibrary.PriceOracleInvalid();\\n    }\\n\\n    return price;\\n  }\\n\\n  /**\\n   * @notice Returns the latest ETH price for a specific token amount\\n   * @param amountIn The amount of base tokens to be converted to ETH\\n   * @return amountOut The latest ETH token price of the base token\\n   */\\n  function getUsdEthPrice(uint256 amountIn) public view returns (uint256 amountOut) {\\n    uint256 price = uint256(latestRoundData(Denominations.ETH, Denominations.USD));\\n    uint256 decimal = decimals(Denominations.ETH, Denominations.USD);\\n    amountOut = (amountIn * (10 ** decimal)) / (price);\\n  }\\n\\n  /**\\n   * @notice Returns the latest USD price for a specific token amount\\n   * @param amountIn The amount of base tokens to be converted to ETH\\n   * @return amountOut The latest USD token price of the base token\\n   */\\n  function getEthUsdPrice(uint256 amountIn) public view returns (uint256 amountOut) {\\n    uint256 price = uint256(latestRoundData(Denominations.ETH, Denominations.USD));\\n    uint256 decimal = decimals(Denominations.ETH, Denominations.USD);\\n    amountOut = (amountIn * price) / (10 ** decimal);\\n  }\\n\\n  /**\\n   * @notice Returns the latest price\\n   * @param base base asset address\\n   * @param quote quote asset address\\n   * @return The latest token price of the pair\\n   */\\n  function getPrice(address base, address quote) public view returns (int256) {\\n    int256 price = latestRoundData(base, quote);\\n    return price;\\n  }\\n\\n  /**\\n   * @notice Returns the latest price for a specific amount\\n   * @param token token asset address\\n   * @param amount token amount\\n   * @param ethPath boolean parameter for is the path for ETH (native token)\\n   * @return amountOut The latest token price of the pair\\n   */\\n  function getPriceForAmount(address token, uint256 amount, bool ethPath) public view returns (uint256 amountOut) {\\n    // token / eth\\n    if (ethPath) {\\n      // getPriceTokenUSD18Decimals returns usd amount in 18 decimals\\n      uint256 price = getPriceTokenUSD18Decimals(token, amount);\\n      amountOut = getUsdEthPrice(price);\\n    } else {\\n      // eth will be in 18 decimals, price and decimal2 is also 18 decimals\\n      uint256 price = uint256(latestRoundData(Denominations.ETH, Denominations.USD));\\n      uint256 decimal2 = decimals(Denominations.ETH, Denominations.USD);\\n      // getPriceUSDToken returns the amount in decimals of token (out)\\n      amountOut = getPriceUSDToken(token, (price * amount) / (10 ** decimal2));\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the latest price for a specific amount\\n   * @param tokenIn token asset address\\n   * @param tokenOut token asset address\\n   * @param amount token amount\\n   * @return amountOut The latest token price of the pair\\n   */\\n\\n  function getPriceForTokenAmount(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amount\\n  ) public view returns (uint256 amountOut) {\\n    // getPriceTokenUSD18Decimals returns usd amount in 18 decimals\\n    uint256 price = getPriceTokenUSD18Decimals(tokenIn, amount);\\n    // getPriceUSDToken returns the amount in decimals of token (out)\\n    amountOut = getPriceUSDToken(tokenOut, price);\\n  }\\n\\n  /**\\n   * @notice Returns the latest USD price for a specific token and amount\\n   * @param _base base asset address\\n   * @param amountIn The amount of base tokens to be converted to USD\\n   * @return amountOut The latest USD token price of the base token\\n   */\\n  function getPriceTokenUSD18Decimals(address _base, uint256 amountIn) public view returns (uint256 amountOut) {\\n    uint256 output = uint256(getPrice(_base, Denominations.USD));\\n    uint256 decimalChainlink = decimals(_base, Denominations.USD);\\n    IERC20MetadataUpgradeable token = IERC20MetadataUpgradeable(_base);\\n    uint8 decimal = token.decimals();\\n\\n    uint256 diff = uint256(18) - (decimal);\\n\\n    amountOut = (output * amountIn * (10 ** diff)) / (10 ** decimalChainlink);\\n  }\\n\\n  /**\\n   * @notice Returns the latest token price for a specific USD amount\\n   * @param _base base asset address\\n   * @param amountIn The amount of base tokens to be converted to USD\\n   * @return amountOut The latest USD token price of the base token\\n   */\\n  function getPriceUSDToken(address _base, uint256 amountIn) public view returns (uint256 amountOut) {\\n    uint256 output = uint256(getPrice(_base, Denominations.USD));\\n    uint256 decimal = decimals(_base, Denominations.USD);\\n\\n    uint8 tokenOutDecimal = IERC20MetadataUpgradeable(_base).decimals();\\n    uint256 diff = uint256(18) - (tokenOutDecimal);\\n\\n    amountOut = ((amountIn * (10 ** decimal)) / output) / (10 ** diff);\\n  }\\n\\n  /**\\n   * @notice Returns the latest token price for a specific token for 1 unit\\n   * @param _base base asset address\\n   * @return amountOut The latest USD token price of the base token in 18 decimals\\n   */\\n  function getPriceForOneTokenInUSD(address _base) public view returns (uint256 amountOut) {\\n    uint256 amountIn = 10 ** IERC20MetadataUpgradeable(_base).decimals();\\n    amountOut = getPriceTokenUSD18Decimals(_base, amountIn);\\n  }\\n\\n  /**\\n   * @notice Updates the oracle timeout threshold\\n   * @param _newTimeout New timeout threshold set by owner\\n   */\\n  function updateOracleExpirationThreshold(uint256 _newTimeout) public onlyOwner {\\n    oracleExpirationThreshold = _newTimeout;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AggregatorAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FeedNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceOracleExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceOracleInvalid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"base\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"quote\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"contract AggregatorV2V3Interface[]\",\"name\":\"aggregator\",\"type\":\"address[]\"}],\"name\":\"addFeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"updateFeed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"base\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"quote\",\"type\":\"address[]\"},{\"internalType\":\"contract AggregatorV2V3Interface[]\",\"name\":\"aggregator\",\"type\":\"address[]\"}],\"name\":\"_addFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"_updateFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getEthUsdPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ethPath\",\"type\":\"bool\"}],\"name\":\"getPriceForAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"}],\"name\":\"getPriceForOneTokenInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPriceForTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getPriceTokenUSD18Decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getPriceUSDToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getUsdEthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleExpirationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTimeout\",\"type\":\"uint256\"}],\"name\":\"updateOracleExpirationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceOracle", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}