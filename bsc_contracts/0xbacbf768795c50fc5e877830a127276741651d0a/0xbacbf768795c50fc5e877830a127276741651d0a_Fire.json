{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n\\t/**\\n\\t * @dev Returns true if `account` is a contract.\\n\\t *\\n\\t * [IMPORTANT]\\n\\t * ====\\n\\t * It is unsafe to assume that an address for which this function returns\\n\\t * false is an externally-owned account (EOA) and not a contract.\\n\\t *\\n\\t * Among others, `isContract` will return false for the following\\n\\t * types of addresses:\\n\\t *\\n\\t *  - an externally-owned account\\n\\t *  - a contract in construction\\n\\t *  - an address where a contract will be created\\n\\t *  - an address where a contract lived, but was destroyed\\n\\t * ====\\n\\t */\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t\\t// This method relies on extcodesize, which returns 0 for contracts in\\n\\t\\t// construction, since the code is only stored at the end of the\\n\\t\\t// constructor execution.\\n\\n\\t\\tuint256 size;\\n\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tsize := extcodesize(account)\\n\\t\\t}\\n\\t\\treturn size \\u003e 0;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n\\t * `recipient`, forwarding all available gas and reverting on errors.\\n\\t *\\n\\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n\\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n\\t * imposed by `transfer`, making them unable to receive funds via\\n\\t * `transfer`. {sendValue} removes this limitation.\\n\\t *\\n\\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n\\t *\\n\\t * IMPORTANT: because control is transferred to `recipient`, care must be\\n\\t * taken to not create reentrancy vulnerabilities. Consider using\\n\\t * {ReentrancyGuard} or the\\n\\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n\\t */\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\n\\t\\trequire(\\n\\t\\t\\taddress(this).balance \\u003e= amount,\\n\\t\\t\\t\\\"Address: insufficient balance\\\"\\n\\t\\t);\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n\\t\\t(bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n\\t\\trequire(\\n\\t\\t\\tsuccess,\\n\\t\\t\\t\\\"Address: unable to send value, recipient may have reverted\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Performs a Solidity function call using a low level `call`. A\\n\\t * plain`call` is an unsafe replacement for a function call: use this\\n\\t * function instead.\\n\\t *\\n\\t * If `target` reverts with a revert reason, it is bubbled up by this\\n\\t * function (like regular Solidity function calls).\\n\\t *\\n\\t * Returns the raw returned data. To convert to the expected return value,\\n\\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `target` must be a contract.\\n\\t * - calling `target` with `data` must not revert.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCall(address target, bytes memory data)\\n\\t\\tinternal\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n\\t * `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but also transferring `value` wei to `target`.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the calling contract must have an ETH balance of at least `value`.\\n\\t * - the called Solidity function must be `payable`.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn\\n\\t\\t\\tfunctionCallWithValue(\\n\\t\\t\\t\\ttarget,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\\"Address: low-level call with value failed\\\"\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n\\t * with `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t *\\n\\t * _Available since v3.1._\\n\\t */\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\trequire(\\n\\t\\t\\taddress(this).balance \\u003e= value,\\n\\t\\t\\t\\\"Address: insufficient balance for call\\\"\\n\\t\\t);\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) =\\n\\t\\t\\ttarget.call{ value: value }(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but performing a static call.\\n\\t *\\n\\t * _Available since v3.3._\\n\\t */\\n\\tfunction functionStaticCall(address target, bytes memory data)\\n\\t\\tinternal\\n\\t\\tview\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn\\n\\t\\t\\tfunctionStaticCall(\\n\\t\\t\\t\\ttarget,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\t\\\"Address: low-level static call failed\\\"\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n\\t * but performing a static call.\\n\\t *\\n\\t * _Available since v3.3._\\n\\t */\\n\\tfunction functionStaticCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal view returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) = target.staticcall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t * but performing a delegate call.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction functionDelegateCall(address target, bytes memory data)\\n\\t\\tinternal\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn\\n\\t\\t\\tfunctionDelegateCall(\\n\\t\\t\\t\\ttarget,\\n\\t\\t\\t\\tdata,\\n\\t\\t\\t\\t\\\"Address: low-level delegate call failed\\\"\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n\\t * but performing a delegate call.\\n\\t *\\n\\t * _Available since v3.4._\\n\\t */\\n\\tfunction functionDelegateCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\trequire(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, bytes memory returndata) = target.delegatecall(data);\\n\\t\\treturn _verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\tfunction _verifyCallResult(\\n\\t\\tbool success,\\n\\t\\tbytes memory returndata,\\n\\t\\tstring memory errorMessage\\n\\t) private pure returns (bytes memory) {\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\t// Look for revert reason and bubble it up if present\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\n\\t\\t\\t\\t// The easiest way to bubble the revert reason is using memory via assembly\\n\\n\\t\\t\\t\\t// solhint-disable-next-line no-inline-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n\\tfunction _msgSender() internal view virtual returns (address) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\n\\t\\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n\"},\"Fire.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./FireMetaData.sol\\\";\\n\\ncontract Fire is Ownable, FireMetaData {\\n\\tevent SwapAndLiquefy(\\n\\t\\tuint256 tokensSwapped,\\n\\t\\tuint256 ethReceived,\\n\\t\\tuint256 tokensIntoLiqudity\\n\\t);\\n\\tevent SwapAndLiquefyStateUpdate(bool state);\\n\\n\\t/**\\n\\t *@dev Adds the Address library utility methods to the type {address}.\\n\\t */\\n\\tusing Address for address;\\n\\n\\t/**\\n\\t *@dev the maximum uint256 value in solidity, which is used to convert the total supply of tokens to reflections for the reward mechanism.\\n\\t */\\n\\tuint256 private constant MAX_INT_VALUE = type(uint256).max;\\n\\n\\tuint256 private _tokenSupply = 10**9 * 10**18;\\n\\t/**\\n\\t *@dev Convert the total supply to reflections with perfect rouding using the maximum uint256 as the numerator.\\n\\t */\\n\\tuint256 private _reflectionSupply = (MAX_INT_VALUE -\\n\\t\\t(MAX_INT_VALUE % _tokenSupply));\\n\\n\\t/**\\n\\t *@dev The total amount of fees paid by the users.\\n\\t */\\n\\tuint256 private _totalTokenFees;\\n\\n\\t/**\\n\\t *@dev The transaction fee users will incur upon selling the token. 2 percent of the principal.\\n\\t */\\n\\tuint8 public taxFee = 2;\\n\\t/**\\n\\t *@dev The wallet which holds the account balance in reflections.\\n\\t */\\n\\tmapping(address =\\u003e uint256) private _reflectionBalance;\\n\\n\\t/**\\n\\t *@dev Accounts which are excluded from paying txs fees.\\n\\t */\\n\\tmapping(address =\\u003e bool) private _isExcludedFromFees;\\n\\n\\t/**\\n\\t *@dev Contains the allowances a parent account has provided to children accounts in reflections;\\n\\t */\\n\\tmapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n\\t/**\\n\\t *@dev A maximum amount that can be transfered at once. Which is equivalent to 0.5% of the total supply.\\n\\t */\\n\\tuint256 public maxTxAmount = 5 * 10**6 * 10**18;\\n\\n\\t/**\\n\\t *@dev Number of tokens needed to provide liquidity to the pool\\n\\t */\\n\\tuint256 private _numberTokensSellToAddToLiquidity = 5 * 10**6 * 10**18;\\n\\n\\t/**\\n\\t *@dev State indicating that we are in a liquefaction process to prevent stacking liquefaction events.\\n\\t */\\n\\tbool swapAndLiquifyingInProgress;\\n\\n\\t/**\\n\\t *@dev Variable to allow the owner to enable or disable liquefaction  events\\n\\t */\\n\\tbool public isSwapAndLiquifyingEnabled = false;\\n\\n\\tbool public startTrading = false;\\n\\n\\tbool public catchWhales = true;\\n\\n\\tIUniswapV2Router02 public immutable uniswapV2Router;\\n\\taddress public immutable uniswapV2WETHPair;\\n\\n\\taddress public immutable fireFund;\\n\\n\\tconstructor(address routerAddress, address fireFundAddress) {\\n\\t\\t/**\\n\\t\\t *@dev Gives all the reflection to the deplyer (the first owner) of the contract upon creation.\\n\\t\\t */\\n\\t\\t_reflectionBalance[_msgSender()] = _reflectionSupply;\\n\\n\\t\\t// Tells solidity this address follows the IUniswapV2Router interface\\n\\t\\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\\n\\n\\t\\t// Creates a pair between our token and WETH and saves the address in a state variable\\n\\t\\tuniswapV2WETHPair = IUniswapV2Factory(_uniswapV2Router.factory())\\n\\t\\t\\t.createPair(address(this), _uniswapV2Router.WETH());\\n\\n\\t\\t// Saves the UniswapV2Router in a state variable\\n\\t\\tuniswapV2Router = _uniswapV2Router;\\n\\n\\t\\tfireFund = fireFundAddress;\\n\\n\\t\\t_isExcludedFromFees[owner()] = true;\\n\\t\\t_isExcludedFromFees[address(this)] = true;\\n\\t\\t_isExcludedFromFees[fireFundAddress] = true;\\n\\n\\t\\temit Transfer(address(0), _msgSender(), _tokenSupply);\\n\\t}\\n\\n\\t/**\\n\\t *@dev Tell the contract we are swapping\\n\\t */\\n\\tmodifier lockTheSwap {\\n\\t\\tswapAndLiquifyingInProgress = true;\\n\\t\\t_;\\n\\t\\tswapAndLiquifyingInProgress = false;\\n\\t}\\n\\n\\t/**\\n\\t *@dev returns the total supply of tokens.\\n\\t */\\n\\tfunction totalSupply() external view override returns (uint256) {\\n\\t\\treturn _tokenSupply;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Returns the rate betweenthe total reflections and the total tokens.\\n\\t */\\n\\tfunction _getRate() private view returns (uint256) {\\n\\t\\treturn _reflectionSupply / _tokenSupply;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Converts an amount of tokens to reflections using the current rate.\\n\\t */\\n\\tfunction _reflectionFromToken(uint256 amount)\\n\\t\\tprivate\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\trequire(\\n\\t\\t\\t_tokenSupply \\u003e= amount,\\n\\t\\t\\t\\\"You cannot own more tokens than the total token supply\\\"\\n\\t\\t);\\n\\t\\treturn amount * _getRate();\\n\\t}\\n\\n\\t/**\\n\\t *@dev Converts an amount of reflections to tokens using the current rate.\\n\\t */\\n\\tfunction _tokenFromReflection(uint256 reflectionAmount)\\n\\t\\tprivate\\n\\t\\tview\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\trequire(\\n\\t\\t\\t_reflectionSupply \\u003e= reflectionAmount,\\n\\t\\t\\t\\\"Cannot have a personal reflection amount larger than total reflection\\\"\\n\\t\\t);\\n\\t\\treturn reflectionAmount / _getRate();\\n\\t}\\n\\n\\t/**\\n\\t *@dev returns the total tokens a user holds. It first finds the reflections and converts to tokens to reflect the rewards the user has accrued over time.\\n\\t * if the account does not receive rewards. It returns the balance from the token balance.\\n\\t */\\n\\tfunction balanceOf(address account) public view override returns (uint256) {\\n\\t\\treturn _tokenFromReflection(_reflectionBalance[account]);\\n\\t}\\n\\n\\tfunction totalFees() external view returns (uint256) {\\n\\t\\treturn _totalTokenFees;\\n\\t}\\n\\n\\t/**\\n\\t *@dev It allows a non excluded account to airdrop to other users.\\n\\t */\\n\\tfunction deliver(uint256 amount) external {\\n\\t\\taddress sender = _msgSender();\\n\\t\\tuint256 reflectionAmount = _reflectionFromToken(amount);\\n\\t\\t_reflectionBalance[sender] =\\n\\t\\t\\t_reflectionBalance[sender] -\\n\\t\\t\\treflectionAmount;\\n\\t\\t_reflectionSupply -= reflectionAmount;\\n\\t\\t_totalTokenFees += amount;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Removes all fees and saves them to be reinstated at a later date.\\n\\t */\\n\\tfunction removeAllFees() private {\\n\\t\\tif (taxFee == 0) return;\\n\\n\\t\\ttaxFee = 0;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Restores the fees to their previous values.\\n\\t */\\n\\tfunction restoreAllFees() private {\\n\\t\\ttaxFee = 2;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Gives the owner of the contract control if the logic to add liquidity to the pool is enabled or not.\\n\\t */\\n\\tfunction enableSwapAndLiquifyingState() external onlyOwner() {\\n\\t\\tisSwapAndLiquifyingEnabled = true;\\n\\t\\temit SwapAndLiquefyStateUpdate(true);\\n\\t}\\n\\n\\t/**\\n\\t *@dev Calculates a fee final amount based on a ratio.\\n\\t *important This funciton only works with values based on token supply and NOT reflection supply.\\n\\t */\\n\\tfunction _calculateFee(uint256 amount, uint8 fee)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn (amount * fee) / 100;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Returns the final amount for the tax.\\n\\t *important This function only works with values based on token supply and NOT reflection supply.\\n\\t */\\n\\tfunction _calculateTax(uint256 amount) private view returns (uint256) {\\n\\t\\treturn _calculateFee(amount, taxFee);\\n\\t}\\n\\n\\t/**\\n\\t *@dev Updates the value of the total fees paid and reduces the reflection supply to reward all holders.\\n\\t */\\n\\tfunction _reflectFee(uint256 rfee, uint256 fee) private {\\n\\t\\t_reflectionSupply -= rfee;\\n\\t\\t_totalTokenFees += fee + fee + fee;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Stores the liquidity fee in the contract\\u0027s address\\n\\t */\\n\\tfunction _takeLiquidity(uint256 amount) private {\\n\\t\\t_reflectionBalance[address(this)] =\\n\\t\\t\\t_reflectionBalance[address(this)] +\\n\\t\\t\\tamount;\\n\\t}\\n\\n\\t/**\\n\\t *@dev This is used to recieve ETH from uniswapv2router when swaping.\\n\\t */\\n\\treceive() external payable {}\\n\\n\\t/**\\n\\t *@dev Allows a user to transfer his reflections to another user. It taxes the sender by the tax fee while inflating the all tokens value.\\n\\t */\\n\\tfunction _transferToken(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount,\\n\\t\\tbool removeFees\\n\\t) private {\\n\\t\\t// If this is a feeless transaction. Remove all fees and store them.\\n\\t\\tif (removeFees) removeAllFees();\\n\\n\\t\\tuint256 rAmount = _reflectionFromToken(amount);\\n\\n\\t\\tif (\\n\\t\\t\\tcatchWhales \\u0026\\u0026\\n\\t\\t\\trecipient != uniswapV2WETHPair \\u0026\\u0026\\n\\t\\t\\tsender != owner() \\u0026\\u0026\\n\\t\\t\\trecipient != owner()\\n\\t\\t) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t_tokenFromReflection(_reflectionBalance[recipient] + rAmount) \\u003c=\\n\\t\\t\\t\\t\\tmaxTxAmount,\\n\\t\\t\\t\\t\\\"No whales allowed right now :)\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t// Because this account comes from a excluded account to an excluded. We only to reduce it\\u0027s reflections and tokens.\\n\\t\\t_reflectionBalance[sender] = _reflectionBalance[sender] - rAmount;\\n\\n\\t\\t// Calculates transaction fee\\n\\t\\tuint256 tax = _calculateTax(amount);\\n\\t\\tuint256 rTax = _reflectionFromToken(tax);\\n\\n\\t\\t// Since the recipient is also  excluded. We need to update his reflections and tokens.\\n\\t\\t_reflectionBalance[recipient] =\\n\\t\\t\\t_reflectionBalance[recipient] +\\n\\t\\t\\trAmount -\\n\\t\\t\\trTax -\\n\\t\\t\\trTax -\\n\\t\\t\\trTax;\\n\\n\\t\\t_reflectionBalance[fireFund] = _reflectionBalance[fireFund] + rTax;\\n\\n\\t\\t_takeLiquidity(rTax);\\n\\t\\t_reflectFee(rTax, tax);\\n\\n\\t\\temit Transfer(sender, recipient, amount - tax * 3);\\n\\n\\t\\t// Restores all fees if they were disabled.\\n\\t\\tif (removeFees) restoreAllFees();\\n\\t}\\n\\n\\t/**\\n\\t *@dev buys ETH with tokens stored in this contract\\n\\t */\\n\\tfunction _swapTokensForEth(uint256 tokenAmount) private {\\n\\t\\t// generate the uniswap pair path of token -\\u003e weth\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = address(this);\\n\\t\\tpath[1] = uniswapV2Router.WETH();\\n\\n\\t\\t_approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n\\t\\t// make the swap\\n\\t\\tuniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\t\\ttokenAmount,\\n\\t\\t\\t0, // accept any amount of ETH\\n\\t\\t\\tpath,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t *@dev Adds equal amount of eth and tokens to the ETH liquidity pool\\n\\t */\\n\\tfunction _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n\\t\\t// approve token transfer to cover all possible scenarios\\n\\t\\t_approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n\\t\\t// add the liquidity\\n\\t\\tuniswapV2Router.addLiquidityETH{ value: ethAmount }(\\n\\t\\t\\taddress(this),\\n\\t\\t\\ttokenAmount,\\n\\t\\t\\t0, // slippage is unavoidable\\n\\t\\t\\t0, // slippage is unavoidable\\n\\t\\t\\taddress(0),\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _swapAndLiquefy() private lockTheSwap {\\n\\t\\t// split the contract token balance into halves\\n\\t\\tuint256 half = _numberTokensSellToAddToLiquidity / 2;\\n\\t\\tuint256 otherHalf = _numberTokensSellToAddToLiquidity - half;\\n\\n\\t\\tuint256 initialETHContractBalance = address(this).balance;\\n\\n\\t\\t// Buys ETH at current token price\\n\\t\\t_swapTokensForEth(half);\\n\\n\\t\\t// This is to make sure we are only using ETH derived from the liquidity fee\\n\\t\\tuint256 ethBought = address(this).balance - initialETHContractBalance;\\n\\n\\t\\t// Add liquidity to the pool\\n\\t\\t_addLiquidity(otherHalf, ethBought);\\n\\n\\t\\temit SwapAndLiquefy(half, ethBought, otherHalf);\\n\\t}\\n\\n\\t/**\\n    @dev Function to enable trading\\n   */\\n\\tfunction enableTrading() external onlyOwner() {\\n\\t\\tstartTrading = true;\\n\\t}\\n\\n\\t/**\\n\\t@dev Function to allow holders to have more than 0.5% of tokens\\n\\t */\\n\\tfunction freeWhales() external onlyOwner() {\\n\\t\\tcatchWhales = false;\\n\\t}\\n\\n\\t/**\\n\\t *@dev This function first adds liquidity to the pool, then transfers tokens between accounts\\n\\t */\\n\\tfunction _transfer(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) private {\\n\\t\\trequire(\\n\\t\\t\\tsender != address(0),\\n\\t\\t\\t\\\"ERC20: Sender cannot be the zero address\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\trecipient != address(0),\\n\\t\\t\\t\\\"ERC20: Recipient cannot be the zero address\\\"\\n\\t\\t);\\n\\t\\trequire(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\n\\t\\tif (sender != owner() \\u0026\\u0026 recipient != owner()) {\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tamount \\u003c= maxTxAmount,\\n\\t\\t\\t\\t\\\"Transfer amount exceeds the maxTxAmount.\\\"\\n\\t\\t\\t);\\n\\n\\t\\t\\trequire(startTrading, \\\"Nice try :)\\\");\\n\\t\\t}\\n\\n\\t\\t// Condition 1: Make sure the contract has the enough tokens to liquefy\\n\\t\\t// Condition 2: We are not in a liquefication event\\n\\t\\t// Condition 3: Liquification is enabled\\n\\t\\t// Condition 4: It is not the uniswapPair that is sending tokens\\n\\n\\t\\tif (\\n\\t\\t\\tbalanceOf(address(this)) \\u003e= _numberTokensSellToAddToLiquidity \\u0026\\u0026\\n\\t\\t\\t!swapAndLiquifyingInProgress \\u0026\\u0026\\n\\t\\t\\tisSwapAndLiquifyingEnabled \\u0026\\u0026\\n\\t\\t\\tsender != uniswapV2WETHPair\\n\\t\\t) _swapAndLiquefy();\\n\\n\\t\\t_transferToken(\\n\\t\\t\\tsender,\\n\\t\\t\\trecipient,\\n\\t\\t\\tamount,\\n\\t\\t\\t_isExcludedFromFees[sender] || _isExcludedFromFees[recipient]\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t *@dev Gives allowance to an account\\n\\t */\\n\\tfunction _approve(\\n\\t\\taddress owner,\\n\\t\\taddress beneficiary,\\n\\t\\tuint256 amount\\n\\t) private {\\n\\t\\trequire(\\n\\t\\t\\tbeneficiary != address(0),\\n\\t\\t\\t\\\"The burn address is not allowed to receive approval for allowances.\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\towner != address(0),\\n\\t\\t\\t\\\"The burn address is not allowed to approve allowances.\\\"\\n\\t\\t);\\n\\n\\t\\t_allowances[owner][beneficiary] = amount;\\n\\t\\temit Approval(owner, beneficiary, amount);\\n\\t}\\n\\n\\tfunction transfer(address recipient, uint256 amount)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\t_transfer(_msgSender(), recipient, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction approve(address beneficiary, uint256 amount)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\t_approve(_msgSender(), beneficiary, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t *@dev It allows an account to transfer it\\u0027s allowance to any other account;\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress provider,\\n\\t\\taddress beneficiary,\\n\\t\\tuint256 amount\\n\\t) external override returns (bool) {\\n\\t\\t_transfer(provider, beneficiary, amount);\\n\\t\\t_approve(\\n\\t\\t\\tprovider,\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\t_allowances[provider][_msgSender()] - amount\\n\\t\\t);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Shows the allowance of a beneficiary in tokens.\\n\\t */\\n\\tfunction allowance(address owner, address beneficiary)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\toverride\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn _allowances[owner][beneficiary];\\n\\t}\\n\\n\\t/**\\n\\t *@dev Increases the allowance of a beneficiary\\n\\t */\\n\\tfunction increaseAllowance(address beneficiary, uint256 amount)\\n\\t\\texternal\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\t_approve(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tbeneficiary,\\n\\t\\t\\t_allowances[_msgSender()][beneficiary] + amount\\n\\t\\t);\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/**\\n\\t *@dev Decreases the allowance of a beneficiary\\n\\t */\\n\\tfunction decreaseAllowance(address beneficiary, uint256 amount)\\n\\t\\texternal\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\t_approve(\\n\\t\\t\\t_msgSender(),\\n\\t\\t\\tbeneficiary,\\n\\t\\t\\t_allowances[_msgSender()][beneficiary] - amount\\n\\t\\t);\\n\\t\\treturn true;\\n\\t}\\n}\\n\"},\"FireMetaData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IERC20MetaData.sol\\\";\\n\\nabstract contract FireMetaData is IERC20Metadata {\\n\\t/**\\n\\t *@dev The name of the token managed by the this smart contract.\\n\\t */\\n\\tstring private _name = \\\"Fire\\\";\\n\\n\\t/**\\n\\t *@dev The symbol of the token managed by the this smart contract.\\n\\t */\\n\\tstring private _symbol = \\\"FIRE\\\";\\n\\n\\t/**\\n\\t *@dev The decimals of the token managed by the this smart contract.\\n\\t */\\n\\tuint8 private _decimals = 18;\\n\\n\\t/**\\n\\t *@dev It returns the name of the token.\\n\\t */\\n\\tfunction name() public view override returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\t/**\\n\\t *@dev It returns the symbol of the token.\\n\\t */\\n\\tfunction symbol() public view override returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\t/**\\n\\t *@dev It returns the decimal of the token.\\n\\t */\\n\\tfunction decimals() public view override returns (uint8) {\\n\\t\\treturn _decimals;\\n\\t}\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n\\t/**\\n\\t * @dev Returns the amount of tokens in existence.\\n\\t */\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the amount of tokens owned by `account`.\\n\\t */\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transfer(address recipient, uint256 amount)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\t/**\\n\\t * @dev Returns the remaining number of tokens that `spender` will be\\n\\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n\\t * zero by default.\\n\\t *\\n\\t * This value changes when {approve} or {transferFrom} are called.\\n\\t */\\n\\tfunction allowance(address owner, address spender)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n\\t * that someone may use both the old and the new allowance by unfortunate\\n\\t * transaction ordering. One possible solution to mitigate this race\\n\\t * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n\\t * desired value afterwards:\\n\\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n\\t *\\n\\t * Emits an {Approval} event.\\n\\t */\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n\\t * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n\\t * allowance.\\n\\t *\\n\\t * Returns a boolean value indicating whether the operation succeeded.\\n\\t *\\n\\t * Emits a {Transfer} event.\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\t/**\\n\\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n\\t * another (`to`).\\n\\t *\\n\\t * Note that `value` may be zero.\\n\\t */\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\t/**\\n\\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n\\t * a call to {approve}. `value` is the new allowance.\\n\\t */\\n\\tevent Approval(\\n\\t\\taddress indexed owner,\\n\\t\\taddress indexed spender,\\n\\t\\tuint256 value\\n\\t);\\n}\\n\"},\"IERC20MetaData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n\\t/**\\n\\t * @dev Returns the name of the token.\\n\\t */\\n\\tfunction name() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the symbol of the token.\\n\\t */\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\t/**\\n\\t * @dev Returns the decimals places of the token.\\n\\t */\\n\\tfunction decimals() external view returns (uint8);\\n}\\n\"},\"IUniswapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IUniswapV2Factory {\\n\\tevent PairCreated(\\n\\t\\taddress indexed token0,\\n\\t\\taddress indexed token1,\\n\\t\\taddress pair,\\n\\t\\tuint256\\n\\t);\\n\\n\\tfunction feeTo() external view returns (address);\\n\\n\\tfunction feeToSetter() external view returns (address);\\n\\n\\tfunction getPair(address tokenA, address tokenB)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address pair);\\n\\n\\tfunction allPairs(uint256) external view returns (address pair);\\n\\n\\tfunction allPairsLength() external view returns (uint256);\\n\\n\\tfunction createPair(address tokenA, address tokenB)\\n\\t\\texternal\\n\\t\\treturns (address pair);\\n\\n\\tfunction setFeeTo(address) external;\\n\\n\\tfunction setFeeToSetter(address) external;\\n}\\n\"},\"IUniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IUniswapV2Router01 {\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction addLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint256 amountADesired,\\n\\t\\tuint256 amountBDesired,\\n\\t\\tuint256 amountAMin,\\n\\t\\tuint256 amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t)\\n\\t\\texternal\\n\\t\\treturns (\\n\\t\\t\\tuint256 amountA,\\n\\t\\t\\tuint256 amountB,\\n\\t\\t\\tuint256 liquidity\\n\\t\\t);\\n\\n\\tfunction addLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint256 amountTokenDesired,\\n\\t\\tuint256 amountTokenMin,\\n\\t\\tuint256 amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (\\n\\t\\t\\tuint256 amountToken,\\n\\t\\t\\tuint256 amountETH,\\n\\t\\t\\tuint256 liquidity\\n\\t\\t);\\n\\n\\tfunction removeLiquidity(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint256 liquidity,\\n\\t\\tuint256 amountAMin,\\n\\t\\tuint256 amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256 amountA, uint256 amountB);\\n\\n\\tfunction removeLiquidityETH(\\n\\t\\taddress token,\\n\\t\\tuint256 liquidity,\\n\\t\\tuint256 amountTokenMin,\\n\\t\\tuint256 amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256 amountToken, uint256 amountETH);\\n\\n\\tfunction removeLiquidityWithPermit(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB,\\n\\t\\tuint256 liquidity,\\n\\t\\tuint256 amountAMin,\\n\\t\\tuint256 amountBMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline,\\n\\t\\tbool approveMax,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external returns (uint256 amountA, uint256 amountB);\\n\\n\\tfunction removeLiquidityETHWithPermit(\\n\\t\\taddress token,\\n\\t\\tuint256 liquidity,\\n\\t\\tuint256 amountTokenMin,\\n\\t\\tuint256 amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline,\\n\\t\\tbool approveMax,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external returns (uint256 amountToken, uint256 amountETH);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapTokensForExactTokens(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction swapTokensForExactETH(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 amountInMax,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapETHForExactTokens(\\n\\t\\tuint256 amountOut,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction quote(\\n\\t\\tuint256 amountA,\\n\\t\\tuint256 reserveA,\\n\\t\\tuint256 reserveB\\n\\t) external pure returns (uint256 amountB);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountOut);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountIn);\\n\\n\\tfunction getAmountsOut(uint256 amountIn, address[] calldata path)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256[] memory amounts);\\n\\n\\tfunction getAmountsIn(uint256 amountOut, address[] calldata path)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256[] memory amounts);\\n}\\n\"},\"IUniswapV2Router02.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\n\\t\\taddress token,\\n\\t\\tuint256 liquidity,\\n\\t\\tuint256 amountTokenMin,\\n\\t\\tuint256 amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256 amountETH);\\n\\n\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n\\t\\taddress token,\\n\\t\\tuint256 liquidity,\\n\\t\\tuint256 amountTokenMin,\\n\\t\\tuint256 amountETHMin,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline,\\n\\t\\tbool approveMax,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external returns (uint256 amountETH);\\n\\n\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external;\\n\\n\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable;\\n\\n\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n\\taddress private _owner;\\n\\n\\tevent OwnershipTransferred(\\n\\t\\taddress indexed previousOwner,\\n\\t\\taddress indexed newOwner\\n\\t);\\n\\n\\t/**\\n\\t * @dev Initializes the contract setting the deployer as the initial owner.\\n\\t */\\n\\tconstructor() {\\n\\t\\taddress msgSender = _msgSender();\\n\\t\\t_owner = msgSender;\\n\\t\\temit OwnershipTransferred(address(0), msgSender);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns the address of the current owner.\\n\\t */\\n\\tfunction owner() public view virtual returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Throws if called by any account other than the owner.\\n\\t */\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Leaves the contract without owner. It will not be possible to call\\n\\t * `onlyOwner` functions anymore. Can only be called by the current owner.\\n\\t *\\n\\t * NOTE: Renouncing ownership will leave the contract without an owner,\\n\\t * thereby removing any functionality that is only available to the owner.\\n\\t */\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\n\\t\\temit OwnershipTransferred(_owner, address(0));\\n\\t\\t_owner = address(0);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t * Can only be called by the current owner.\\n\\t */\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\n\\t\\trequire(\\n\\t\\t\\tnewOwner != address(0),\\n\\t\\t\\t\\\"Ownable: new owner is the zero address\\\"\\n\\t\\t);\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fireFundAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquefy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquefyStateUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"catchWhales\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableSwapAndLiquifyingState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fireFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeWhales\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapAndLiquifyingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2WETHPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Fire", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e00000000000000000000000046f1a57805fba13e266e0a9e2ccda6935257f570", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2776165373e847e25f9918601c86393d84fe6c44921e7b25d453113bd347dba9"}