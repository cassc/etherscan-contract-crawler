{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/staking.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.16;\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external;\\r\\n\\r\\n    function transfer(address to, uint256 value) external;\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) external;\\r\\n}\\r\\n\\r\\ncontract SeekcoinStaking {\\r\\n    using SafeMath for uint256;\\r\\n    IERC20 public stakeToken;\\r\\n\\r\\n    address payable public owner;\\r\\n\\r\\n    uint256 public totalStakedToken;\\r\\n    uint256 public totalUnStakedToken;\\r\\n    uint256 public totalWithdrawanToken;\\r\\n    uint256 public totalClaimedRewardToken;\\r\\n    uint256 public totalStakers;\\r\\n    uint256 public percentDivider;\\r\\n\\r\\n    uint256[5] public Duration = [\\r\\n        90 days,\\r\\n        180 days,\\r\\n        365 days,\\r\\n        540 days,\\r\\n        730 days\\r\\n    ];\\r\\n    uint256[5] public Bonus = [3_750, 8_250, 18_000, 29_250, 42_000];\\r\\n    uint256[5] public totalStakedPerPlan;\\r\\n    uint256[5] public totalStakersPerPlan;\\r\\n\\r\\n    struct Stake {\\r\\n        uint256 plan;\\r\\n        uint256 withdrawtime;\\r\\n        uint256 staketime;\\r\\n        uint256 amount;\\r\\n        uint256 reward;\\r\\n        uint256 persecondreward;\\r\\n        bool withdrawan;\\r\\n        bool unstaked;\\r\\n    }\\r\\n\\r\\n    struct User {\\r\\n        uint256 totalStakedTokenUser;\\r\\n        uint256 totalWithdrawanTokenUser;\\r\\n        uint256 totalUnStakedTokenUser;\\r\\n        uint256 totalClaimedRewardTokenUser;\\r\\n        uint256 stakeCount;\\r\\n        bool alreadyExists;\\r\\n    }\\r\\n\\r\\n    mapping(address => User) public Stakers;\\r\\n    mapping(uint256 => address) public StakersID;\\r\\n    mapping(address => mapping(uint256 => Stake)) public stakersRecord;\\r\\n    mapping(address => mapping(uint256 => uint256)) public userStakedPerPlan;\\r\\n\\r\\n    event STAKE(address Staker, uint256 amount);\\r\\n    event UNSTAKE(address Staker, uint256 amount);\\r\\n    event WITHDRAW(address Staker, uint256 amount);\\r\\n\\r\\n    modifier onlyowner() {\\r\\n        require(owner == msg.sender, \\\"only owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() {\\r\\n        owner = payable(0x754ddA1A30F4e2d8aDDcDf7A254298e365224273);\\r\\n        stakeToken = IERC20(0x4D71566F5F54E62daA455e4c5857D1aB20aA10d4);\\r\\n        percentDivider = 100_000;\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount, uint256 planIndex) public {\\r\\n        require(planIndex >= 0 && planIndex <= 4, \\\"Invalid Time Period\\\");\\r\\n        require(amount >= 0, \\\"stake more than 0\\\");\\r\\n\\r\\n        if (!Stakers[msg.sender].alreadyExists) {\\r\\n            Stakers[msg.sender].alreadyExists = true;\\r\\n            StakersID[totalStakers] = msg.sender;\\r\\n            totalStakers++;\\r\\n        }\\r\\n\\r\\n        stakeToken.transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        uint256 index = Stakers[msg.sender].stakeCount;\\r\\n        Stakers[msg.sender].totalStakedTokenUser = Stakers[msg.sender]\\r\\n            .totalStakedTokenUser\\r\\n            .add(amount);\\r\\n        totalStakedToken = totalStakedToken.add(amount);\\r\\n        stakersRecord[msg.sender][index].withdrawtime = block.timestamp.add(\\r\\n            Duration[planIndex]\\r\\n        );\\r\\n        stakersRecord[msg.sender][index].staketime = block.timestamp;\\r\\n        stakersRecord[msg.sender][index].amount = amount;\\r\\n        stakersRecord[msg.sender][index].reward = amount\\r\\n            .mul(Bonus[planIndex])\\r\\n            .div(percentDivider);\\r\\n        stakersRecord[msg.sender][index].persecondreward = stakersRecord[\\r\\n            msg.sender\\r\\n        ][index].reward.div(Duration[planIndex]);\\r\\n        stakersRecord[msg.sender][index].plan = planIndex;\\r\\n        Stakers[msg.sender].stakeCount++;\\r\\n        userStakedPerPlan[msg.sender][planIndex] = userStakedPerPlan[\\r\\n            msg.sender\\r\\n        ][planIndex].add(amount);\\r\\n        totalStakedPerPlan[planIndex] = totalStakedPerPlan[planIndex].add(\\r\\n            amount\\r\\n        );\\r\\n        totalStakersPerPlan[planIndex]++;\\r\\n\\r\\n        emit STAKE(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function unstake(uint256 index) public {\\r\\n        require(\\r\\n            !stakersRecord[msg.sender][index].withdrawan,\\r\\n            \\\"already withdrawan\\\"\\r\\n        );\\r\\n        require(!stakersRecord[msg.sender][index].unstaked, \\\"already unstaked\\\");\\r\\n        require(index < Stakers[msg.sender].stakeCount, \\\"Invalid index\\\");\\r\\n\\r\\n        stakersRecord[msg.sender][index].unstaked = true;\\r\\n        stakeToken.transfer(\\r\\n            msg.sender,\\r\\n            (stakersRecord[msg.sender][index].amount)\\r\\n        );\\r\\n        totalUnStakedToken = totalUnStakedToken.add(\\r\\n            stakersRecord[msg.sender][index].amount\\r\\n        );\\r\\n        Stakers[msg.sender].totalUnStakedTokenUser = Stakers[msg.sender]\\r\\n            .totalUnStakedTokenUser\\r\\n            .add(stakersRecord[msg.sender][index].amount);\\r\\n        uint256 planIndex = stakersRecord[msg.sender][index].plan;\\r\\n        userStakedPerPlan[msg.sender][planIndex] = userStakedPerPlan[\\r\\n            msg.sender\\r\\n        ][planIndex].sub(stakersRecord[msg.sender][index].amount, \\\"user stake\\\");\\r\\n        totalStakedPerPlan[planIndex] = totalStakedPerPlan[planIndex].sub(\\r\\n            stakersRecord[msg.sender][index].amount,\\r\\n            \\\"total stake\\\"\\r\\n        );\\r\\n        totalStakersPerPlan[planIndex]--;\\r\\n\\r\\n        emit UNSTAKE(msg.sender, stakersRecord[msg.sender][index].amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 index) public {\\r\\n        require(\\r\\n            !stakersRecord[msg.sender][index].withdrawan,\\r\\n            \\\"already withdrawan\\\"\\r\\n        );\\r\\n        require(!stakersRecord[msg.sender][index].unstaked, \\\"already unstaked\\\");\\r\\n        require(\\r\\n            stakersRecord[msg.sender][index].withdrawtime < block.timestamp,\\r\\n            \\\"cannot withdraw before stake duration\\\"\\r\\n        );\\r\\n        require(index < Stakers[msg.sender].stakeCount, \\\"Invalid index\\\");\\r\\n\\r\\n        stakersRecord[msg.sender][index].withdrawan = true;\\r\\n        stakeToken.transfer(\\r\\n            msg.sender,\\r\\n            stakersRecord[msg.sender][index].amount\\r\\n        );\\r\\n        stakeToken.transferFrom(\\r\\n            owner,\\r\\n            msg.sender,\\r\\n            stakersRecord[msg.sender][index].reward\\r\\n        );\\r\\n        totalWithdrawanToken = totalWithdrawanToken.add(\\r\\n            stakersRecord[msg.sender][index].amount\\r\\n        );\\r\\n        totalClaimedRewardToken = totalClaimedRewardToken.add(\\r\\n            stakersRecord[msg.sender][index].reward\\r\\n        );\\r\\n        Stakers[msg.sender].totalWithdrawanTokenUser = Stakers[msg.sender]\\r\\n            .totalWithdrawanTokenUser\\r\\n            .add(stakersRecord[msg.sender][index].amount);\\r\\n        Stakers[msg.sender].totalClaimedRewardTokenUser = Stakers[msg.sender]\\r\\n            .totalClaimedRewardTokenUser\\r\\n            .add(stakersRecord[msg.sender][index].reward);\\r\\n        uint256 planIndex = stakersRecord[msg.sender][index].plan;\\r\\n        userStakedPerPlan[msg.sender][planIndex] = userStakedPerPlan[\\r\\n            msg.sender\\r\\n        ][planIndex].sub(stakersRecord[msg.sender][index].amount, \\\"user stake\\\");\\r\\n        totalStakedPerPlan[planIndex] = totalStakedPerPlan[planIndex].sub(\\r\\n            stakersRecord[msg.sender][index].amount,\\r\\n            \\\"total stake\\\"\\r\\n        );\\r\\n        totalStakersPerPlan[planIndex]--;\\r\\n\\r\\n        emit WITHDRAW(\\r\\n            msg.sender,\\r\\n            stakersRecord[msg.sender][index].reward.add(\\r\\n                stakersRecord[msg.sender][index].amount\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function SetStakeDuration(\\r\\n        uint256 first,\\r\\n        uint256 second,\\r\\n        uint256 third,\\r\\n        uint256 fourth,\\r\\n        uint256 fifth\\r\\n    ) external onlyowner {\\r\\n        Duration[0] = first;\\r\\n        Duration[1] = second;\\r\\n        Duration[2] = third;\\r\\n        Duration[3] = fourth;\\r\\n        Duration[4] = fifth;\\r\\n    }\\r\\n\\r\\n    function SetStakeBonus(\\r\\n        uint256 first,\\r\\n        uint256 second,\\r\\n        uint256 third,\\r\\n        uint256 fourth,\\r\\n        uint256 fifth\\r\\n    ) external onlyowner {\\r\\n        Bonus[0] = first;\\r\\n        Bonus[1] = second;\\r\\n        Bonus[2] = third;\\r\\n        Bonus[3] = fourth;\\r\\n        Bonus[4] = fifth;\\r\\n    }\\r\\n\\r\\n    function realtimeReward(address user) public view returns (uint256) {\\r\\n        uint256 ret;\\r\\n        for (uint256 i; i < Stakers[user].stakeCount; i++) {\\r\\n            if (\\r\\n                !stakersRecord[user][i].withdrawan &&\\r\\n                !stakersRecord[user][i].unstaked\\r\\n            ) {\\r\\n                uint256 val;\\r\\n                val = block.timestamp - stakersRecord[user][i].staketime;\\r\\n                val = val.mul(stakersRecord[user][i].persecondreward);\\r\\n                if (val < stakersRecord[user][i].reward) {\\r\\n                    ret += val;\\r\\n                } else {\\r\\n                    ret += stakersRecord[user][i].reward;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return ret;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n        // benefit is lost if 'b' is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"STAKE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UNSTAKE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"Staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WITHDRAW\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Bonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"third\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fourth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fifth\",\"type\":\"uint256\"}],\"name\":\"SetStakeBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"first\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"third\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fourth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fifth\",\"type\":\"uint256\"}],\"name\":\"SetStakeDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawanTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUnStakedTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedRewardTokenUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"alreadyExists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"StakersID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"realtimeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planIndex\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakersRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staketime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"persecondreward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawan\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimedRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalStakedPerPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalStakersPerPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawanToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakedPerPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SeekcoinStaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}