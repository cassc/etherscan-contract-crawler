{"SourceCode": "pragma solidity ^0.8.6;\r\n/*\r\n\r\nOverview of features\r\n    Sell tax is higher than buy tax(10%) and gradually reduces after launch from 48% to 15%\r\n    The largest portion of tax is converted to BNB and distributed on the wallet to seperate 'pots' or reserves.\r\n    Rewards recalculated from holderPot every 2 hours approx.\r\n    Auto reward payouts in different currencies that are user selectable from a list (max 6 choice tokens + 1 promo token)\r\n    Admin and mods are paid from transfer tax instead of large token holdings \r\n    Lottery on every transaction excl. sells\r\n    Random airdrops (3 every 5 hours, max 1 win per 5 days) and manual airdrops (max 50 tokens after launch)\r\n    Some functions are reserved for a main wallet and marketing wallet or admin and workhelperwallet\r\n    Certain functions are disabled after launch using an disabledAfterLaunch modifier\r\n    Work is distributed between transactions. Each transaction calculates some rewards or pays out some rewards.\r\n    If the transactions are too slow, work can be performed by calling functions that iterate over tasks from the main or marketing wallet\r\n    Buyback function that buys and burns tokens until 50% initial supply is reached. Buyback is triggered by a growing increment in new holder addresses\r\n    Holders need to call setMyAutoPayout() function once to start getting auto payouts. This is to avoid bots from claiming\r\n    rewards. If rewards are unclaimed for 6 months they get redistributed to other holders\r\n\r\n\r\nIMPORTANT \r\ncall StartLaunch() after adding initial liquidity to LP to enable tax and transfers and renounce control of sensitive functions\r\n\r\n\r\n    \r\nORIGINAL TOKENOMICS\r\nSupply\r\nMax Supply: 100,000,000,000 (one hundred billion) \r\nBuy tax\r\nTax: 10% (slippage 11%)\r\n4% Payouts in $BTCB, $ETH, $BUSD, $MATIC, $ADA, $BNB & $PLX, more added later\r\n3% Auto buyback \r\n1% Gas Refunds \r\n1% Marketing in $Bnb\r\n0.4% admin \r\n0.2% mods\r\nSell tax\r\nSelling tax is time dependent:\r\nSell tax Selling tax is time dependent:\r\nAfter 1min-4h slippage 49%\r\nAfter 4-24h slippage 40% \r\n1-3d slippage 35%\r\n4-7 days slippage 30% \r\n8-13 days slippage 25% \r\n14-28 days slippage 20%\r\n29- 56 days slippage 17% \r\nAfter 56days slippage 15%\r\n\r\n* After launch, not hodl time!\r\nPayouts\r\n\u2192 all the sellers tax is given back in multiple tokens \u2192 no $PLX price dump from selling the sell tax\r\nOut of the seling tax:\r\n30% holders in $BTCB, $ETH, $ADA, $MATIC, $BNB, $BUSD & $PLX\r\n35% liquidity to pancakeswap \r\n19% Marketing\r\n2% lottery\r\n4% admin in bnb\r\n2% Mods in bnb\r\n\r\n*/\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n//////Pancake\r\n    interface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n //   function mint(address to) external returns (uint liquidity);\r\n //   function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n //   function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n/*Abi bytecodes for pancakerouter\r\n\r\n{\r\n\t\"ad5c4648\": \"WETH()\",\r\n\t\"e8e33700\": \"addLiquidity(address,address,uint256,uint256,uint256,uint256,address,uint256)\",\r\n\t\"f305d719\": \"addLiquidityETH(address,uint256,uint256,uint256,address,uint256)\",\r\n\t\"c45a0155\": \"factory()\",\r\n\t\"85f8c259\": \"getAmountIn(uint256,uint256,uint256)\",\r\n\t\"054d50d4\": \"getAmountOut(uint256,uint256,uint256)\",\r\n\t\"1f00ca74\": \"getAmountsIn(uint256,address[])\",\r\n\t\"d06ca61f\": \"getAmountsOut(uint256,address[])\",\r\n\t\"ad615dec\": \"quote(uint256,uint256,uint256)\",\r\n\t\"baa2abde\": \"removeLiquidity(address,address,uint256,uint256,uint256,address,uint256)\",\r\n\t\"02751cec\": \"removeLiquidityETH(address,uint256,uint256,uint256,address,uint256)\",\r\n\t\"af2979eb\": \"removeLiquidityETHSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256)\",\r\n\t\"ded9382a\": \"removeLiquidityETHWithPermit(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)\",\r\n\t\"5b0d5984\": \"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)\",\r\n\t\"2195995c\": \"removeLiquidityWithPermit(address,address,uint256,uint256,uint256,address,uint256,bool,uint8,bytes32,bytes32)\",\r\n\t\"fb3bdb41\": \"swapETHForExactTokens(uint256,address[],address,uint256)\",\r\n\t\"7ff36ab5\": \"swapExactETHForTokens(uint256,address[],address,uint256)\",\r\n\t\"b6f9de95\": \"swapExactETHForTokensSupportingFeeOnTransferTokens(uint256,address[],address,uint256)\",\r\n\t\"18cbafe5\": \"swapExactTokensForETH(uint256,uint256,address[],address,uint256)\",\r\n\t\"791ac947\": \"swapExactTokensForETHSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)\",\r\n\t\"38ed1739\": \"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\",\r\n\t\"5c11d795\": \"swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256,uint256,address[],address,uint256)\",\r\n\t\"4a25d94a\": \"swapTokensForExactETH(uint256,uint256,address[],address,uint256)\",\r\n\t\"8803dbee\": \"swapTokensForExactTokens(uint256,uint256,address[],address,uint256)\"\r\n}*/\r\n\r\n\r\n\r\n//Interface to generate the ABI code for the dapp\r\n\r\ninterface DAPP {\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function setMyAutoPayout(bool Checked)external returns (bool);\r\n    function getMyAutoPayoutisActive() external view returns (bool);\r\n    function ClaimMyRewards() external;\r\n    function ChooseSinglePayoutToken(uint32 PayoutTokenNumber) external;\r\n    function ChooseMultiplePayoutTokens(uint32 Token1,uint32 Slice1,uint32 Token2,uint32 Slice2,\r\n                                            uint32 Token3,uint32 Slice3,uint32 Token4,uint32 Slice4,\r\n                                            uint32 Token5,uint32 Slice5,uint32 Token6,uint32 Slice6) external;\r\n    function getSellSlippage() external view  returns (uint32);\r\n    function MyAvailableRewards() external view returns(uint256);\r\n    function ShowMyRewardTOKENS() external view returns (uint32[6] memory tokennumbers);\r\n    function ShowMyRewardSLICES() external view returns (uint32[6] memory slices);\r\n    function ShowAllRewardTokens() external view returns (string[] memory Rewards); \r\n}\r\n \r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED);\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}        \r\n\r\n\r\n\r\ncontract  EthernalFinanceII is ERC20, ReentrancyGuard {\r\n    string public constant symbol = \"ETHFIN\"; //ETHFIN\r\n    string public constant name = \"Ethernal Finance II\"; \r\n    uint8 public constant decimals = 18;\r\n\r\n    //100,000,000,000+18 zeros\r\n    uint256 constant initialSupply = 100000000000000000000000000000; //100 billion tokens\r\n    uint256 __totalSupply = initialSupply;\r\n    uint256 burnUntil; //buyback stop burning at 50% initial supply\r\n    uint256 _maxTxAmount;//0.1% of total supply\r\n\r\n\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n  \r\n    mapping (address => uint256) private _earnings;\r\n    mapping (address => uint256) private _PrevBalance;\r\n    mapping (address => uint256) private _LastPayout;\r\n    mapping (address => uint256) private _LastAirdrop; \r\n    mapping (address => uint256) private _LastRewardCycle; \r\n    mapping (address => bool) private _excludedfromTax;\r\n    mapping (address => RewardTokens) private _RewardTokens; //*\r\n    mapping (address => bool) private _SplitTokenRewards;\r\n    mapping (address => bool) private _AutoPayoutEnabled;\r\n    mapping (address => bool) private _isregistered; \r\n    mapping (address => bool) private _isAdmin; \r\n    mapping (address => bool) private _isMod; \r\n   \r\n   //* this struct is used to map reward token numbers and the percentage payout of each to holder addresses\r\n    struct RewardTokens{\r\n        uint32 Token1;\r\n        uint32 Token2;\r\n        uint32 Token3;\r\n        uint32 Token4;\r\n        uint32 Token5;\r\n        uint32 Token6;\r\n        uint32 Slice1;\r\n        uint32 Slice2;\r\n        uint32 Slice3;\r\n        uint32 Slice4;\r\n        uint32 Slice5;\r\n        uint32 Slice6;\r\n    }\r\n    \r\n\r\n   address[] private investorList; \r\n   address[] private ModList;\r\n   address[] private AdminList;\r\n   address[] public PayoutTokenList;\r\n   string[] public PayoutTokenListNames;\r\n   uint32 public RewardTokenoftheWeek;\r\n//   uint32 public PromoPerc;   \r\n   uint256 public distributedRewards;\r\n   uint256 public Rewardcycle;\r\n   uint256 public claimableBNBearnings;\r\n   \r\n    bool public _enableTax; \r\n    bool public _enableTransfer; \r\n    bool public _isLaunched; \r\n    \r\n    bool public _CalculatingRewards; \r\n    bool public _AutoCalcRewards; \r\n    uint256 public HolderPos;\r\n    uint256 public DistHolderPos;\r\n\r\n    uint256 public N_holders;\r\n    uint256 public N_Admin;\r\n    uint256 public N_Mods;\r\n    uint32 private N_perTransfer;\r\n    uint32 private N_payoutsperWorkRound; //@@@\r\n    uint256 private nonce;\r\n\r\n    \r\n    uint256 public launch_time;\r\n    uint32 public NumberofPayoutTokens;\r\n    \r\n    uint256 public LastRewardCalculationTime;\r\n \r\n //Tax reserves and pots kept public for maximum transparency  \r\n    uint256 public LQPotBNB;\r\n    uint256 public LQPotToken;\r\n    uint256 public MarketingBNB;\r\n    \r\n    uint256 public BuybackPotBNB;\r\n    uint256 public GasPotBNB;\r\n    uint256 public HolderPotBNB;\r\n    uint256 public AdminPotBNB;\r\n    uint256 public ModPotBNB;\r\n    uint256 public AirdropPot;\r\n    uint256 public RafflePot;\r\n    uint256 public LotteryPot;\r\n    uint256 public NextBuybackMemberCount;\r\n    \r\n    uint256 private HolderPotBNBcalc;\r\n    uint256 private AdminPotBNBcalc;\r\n    uint256 private ModPotBNBcalc;\r\n    uint256 private CircSupplycalc;\r\n    address private Contract;\r\n\r\n   uint32 public SellSlippage;\r\n   uint32 public NextTask;\r\n   \r\n   uint256 public SellTaxTokenPot;\r\n   uint256 public SellTaxBNBPot;\r\n\r\n   \r\n   uint256 public BuyTaxTokenPot;\r\n   uint256 public BuyTaxBNBPot;\r\n   address public MarketingWallet;\r\n   bool private SingleUntaxedTransfer;\r\n \r\n    uint32 private Buyback_increment; \r\n    uint256 private Airdrop_timeoflastPayout;\r\n    uint256 public Airdrop_totalPaidOut;\r\n \r\n     \r\nevent Buyback_(uint256 TokensBought, uint256 NumberofHolders);\r\nevent TokensBurned(uint256 amount);\r\nevent LotteryWon_(address _winner, uint256 _tokenAmount);\r\nevent RewardsRecalculated();\r\n//event PromotedtokenoftheWeek(string PromoToken); @@@\r\nevent Airdrop_(address recipient,uint256 _Tokens);\r\nevent TOKEN_LAUNCHED();\r\n\r\n\r\n     modifier onlyAdmin() {\r\n            \r\n        if(_isAdmin[msg.sender] != true)\r\n        require((msg.sender == MainWallet)||(msg.sender == MarketingWallet)||(msg.sender == WorkHelperWallet));\r\n        _;\r\n    }\r\n    \r\n    modifier onlyMain() {\r\n      require((msg.sender == MainWallet)||(msg.sender == MarketingWallet));\r\n      _;\r\n   }    \r\n   \r\n    modifier LockedafterLaunch() {\r\n      require(_isLaunched == false);\r\n      _;\r\n   }\r\n       modifier CheckforWork() {\r\n      \r\n      _;\r\n      if(_AutoCalcRewards == true)\r\n      doWork(NextTask);\r\n   }\r\n    //@@@ function replaced to retrieve gas to main wallet for contract running costs each time 0.1bnb is collected - more efficient\r\n       modifier RefundGas() {\r\n           \r\n        _;   \r\n        if(GasPotBNB>100000000000000000) //0.1 bnb\r\n        {\r\n        uint tempPot = GasPotBNB;\r\n        GasPotBNB = 0;\r\n        if(SendBNBfromContract(tempPot, MainWallet)==false) //transaction failed\r\n        GasPotBNB += tempPot; // put funds back in pot to try again next time\r\n        }\r\n        \r\n    }\r\n    \r\n//IMPORTANT \r\n//call StartLaunch() after adding liquidity to LP to enable tax and transfers and renounce control of sensitive functions\r\n\r\nfunction StartLaunch() public onlyMain() LockedafterLaunch(){ //cannot be undone\r\n\r\n          launch_time = block.timestamp;\r\n          LastRewardCalculationTime = 0; \r\n          _enableTax = true; \r\n          Buyback_increment = 200; //first increment after launch\r\n          NextBuybackMemberCount = N_holders + Buyback_increment;\r\n          _isLaunched = true;\r\n          _enableTransfer = true;\r\n          _AutoCalcRewards = true;\r\n          \r\n          emit TOKEN_LAUNCHED(); //LETS GO!!!\r\n        }\r\nfunction ToggleTransfers() public onlyMain() LockedafterLaunch(){\r\n         _enableTransfer = !_enableTransfer;// cannot disable transfers after launch \r\n        }\r\nfunction setMarketingOwnership(address newMarketOwner) public onlyMain(){\r\n        MarketingWallet = newMarketOwner;\r\n        _excludedfromTax[MarketingWallet] = true;\r\n        _isregistered[MarketingWallet] = true;\r\n    } \r\n    \r\n    //sets wallet with admin privelage for automation in the future\r\n    function setWorkHelper(address newWorkHelper) public onlyMain(){\r\n        WorkHelperWallet = newWorkHelper;\r\n        _excludedfromTax[WorkHelperWallet] = true;\r\n        _isregistered[WorkHelperWallet] = true;\r\n    } \r\n   \r\n    //TestNet    \r\n  //  address constant routerAddress=0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\r\n    \r\n    //MainNet\r\n    address constant routerAddress=0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n   \r\n    IPancakeRouter02 private _pancakeRouter;\r\n    address public _pancakePairAddress;\r\n    address public MainWallet; //address of the wallet that controls the contract\r\n     address public WorkHelperWallet; //address of the wallet used for automating tasks in the future. Has admin privelages\r\n    \r\n    constructor() {\r\n        N_perTransfer = 3;  //number of reward calculations\r\n        N_payoutsperWorkRound = 1;  //@@@ number of payouts per dapp interaction\r\n        nonce = 1;\r\n        burnUntil = initialSupply/2; //buyback stop burning at 50% initial supply\r\n        _maxTxAmount = __totalSupply * 1/1000; //0.1% of total supply\r\n        UpdateRegister(address(0),true);\r\n         UpdateRegister(address(0x000000000000000000000000000000000000dEaD),true);\r\n        _enableTransfer = true; //default\r\n\r\n          MainWallet = msg.sender;\r\n          WorkHelperWallet = msg.sender;\r\n          UpdateRegister(MainWallet,true);\r\n        __balanceOf[MainWallet] = __totalSupply;  \r\n        Contract = address(this);\r\n        \r\n        //Add to ModList@@@\r\n        UpdateRegister(0xb285B4a0EDCF9E13aBDd0a1Fad10832339Cd1D8f, false);\r\n        _isMod[0xb285B4a0EDCF9E13aBDd0a1Fad10832339Cd1D8f] = true;\r\n        N_Mods++;\r\n        ModList.push(0xb285B4a0EDCF9E13aBDd0a1Fad10832339Cd1D8f);\r\n\r\n        UpdateRegister(address(this),true);\r\n        \r\n//        __balanceOf[address(this)] = __totalSupply/2;\r\n\r\n        MarketingWallet = msg.sender;\r\n        UpdateRegister(MarketingWallet,true);\r\n       // RafflePot = initialSupply * 2 / 100; // 2% reserved in raffle pot to send airdrops to promotion winners and partnerships @@@\r\n\r\n        _pancakeRouter = IPancakeRouter02(routerAddress);\r\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\r\n         UpdateRegister(_pancakePairAddress,false);\r\n      //  AutoLiquidity = true;\r\n\r\n     //launch_time = block.timestamp;  //now as default - used for tax calculation\r\n   AddTokentoPayoutList(_pancakeRouter.WETH(), \"BNB\"); //BNB added as default\r\n   AddTokentoPayoutList(address(this), \"ETHFIN\"); //this contract token\r\n   \r\n   \r\n   //default testnet tokens for debugging\r\n  // AddTokentoPayoutList(0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7, \"BUSD\"); \r\n  // AddTokentoPayoutList(0x8a9424745056Eb399FD19a0EC26A14316684e274, \"DAI\");  \r\n  // AddTokentoPayoutList(0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7, \"BUSD\"); \r\n  // AddTokentoPayoutList(0x8a9424745056Eb399FD19a0EC26A14316684e274, \"DAI\"); \r\n\r\n    }\r\n\r\n \r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    //returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    //transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    //does the msg.sender have enough tokens to forfill the transfer\r\n    //decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n       require(_value > 0 && _value <= balanceOf(msg.sender)); \r\n       \r\n        UpdateRegister(_to, false);\r\n\r\n            _transferWithTax(msg.sender, _to, _value);\r\n\r\n            return true;\r\n        \r\n    }\r\n\r\n //contract addresses are as default excluded from auto payouts of rewards and have\r\n //to be enabled manually otherwise accumilated rewards are redistributed after 6 months\r\n\tfunction isContract(address account) private view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n\t}\r\n   \r\n//function called when a new address is sent tokens\r\n  function UpdateRegister(address recipient, bool ExcludedfromTax) private\r\n   {\r\n        if(_isregistered[recipient] == false)  \r\n        {investorList.push(recipient); //add new holder to list\r\n        _isregistered[recipient] = true;\r\n        _LastPayout[recipient] = block.timestamp;\r\n        \r\n        if(!isContract(recipient))\r\n        _AutoPayoutEnabled[recipient] = true; // only human holders get payed auto rewards as default\r\n         N_holders++;\r\n         _excludedfromTax[recipient] = ExcludedfromTax;\r\n         \r\n         _SplitTokenRewards[recipient] = true;\r\n         _RewardTokens[recipient].Slice1 = 75; //default 75% bnb\r\n         _RewardTokens[recipient].Slice2 = 25; //25% Native Currency\r\n         _RewardTokens[recipient].Token1 = 0; \r\n         _RewardTokens[recipient].Token2 = 1; \r\n\r\n        }\r\n   }\r\n   \r\n   function isModerator(address addr) public view returns (bool)\r\n   {\r\n       return _isMod[addr];\r\n   }\r\n   \r\n   function isExcludedfromTax(address addr) public view returns (bool)\r\n   {\r\n       return _excludedfromTax[addr];\r\n   }\r\n   \r\n   function addtoAdminList(address addr) public onlyMain() LockedafterLaunch()\r\n    {\r\n        if(_isAdmin[addr] == false)\r\n        {\r\n            if(_isregistered[addr] == false) \r\n            UpdateRegister(addr, false);\r\n        \r\n        _isAdmin[addr] = true;\r\n        N_Admin++;\r\n        AdminList.push(addr);\r\n        }\r\n    }\r\n    \r\n    \r\n    //Function to distribute marketing funds and  'salaries' to team members\r\n    //it is called once every reward calculation cycle\r\n    function _PayTeam() private {\r\n    \r\n        if(SendBNBfromContract(MarketingBNB, MarketingWallet)==true) \r\n        MarketingBNB = 0;\r\n        {//admin\r\n        \r\n        uint256 L = AdminList.length;\r\n         if((L>0)&&(AdminPotBNB > 0))\r\n           { uint256 Adminshare = AdminPotBNB / N_Admin;\r\n              AdminPotBNB = 0;\r\n            for(uint32 pos = 0 ; pos < L; pos++)\r\n             if(_isAdmin[AdminList[pos]])\r\n                SendBNBfromContract(Adminshare, AdminList[pos]);\r\n          }\r\n        }\r\n        //mod\r\n        {\r\n        \r\n         uint256 L = ModList.length;\r\n         if((L>0)&&(ModPotBNB > 0))\r\n           { uint256 Modshare = ModPotBNB / N_Mods;\r\n              ModPotBNB = 0;\r\n            for(uint32 pos = 0 ; pos < L; pos++)\r\n             if(_isMod[ModList[pos]])\r\n                SendBNBfromContract(Modshare, ModList[pos]);\r\n        }\r\n        }\r\n}\r\n\r\n    \r\n       function addtoModList(address addr) public onlyAdmin()\r\n    {\r\n        if(_isMod[addr] == false)\r\n        {\r\n            if(_isregistered[addr] == false) \r\n            UpdateRegister(addr, false);\r\n        \r\n        _isMod[addr] = true;\r\n        N_Mods++;\r\n        ModList.push(addr);\r\n        }\r\n    }\r\n    \r\n        function removefromModList(address addr) public onlyAdmin()\r\n    {\r\n        if(_isMod[addr] == true)\r\n        {\r\n        N_Mods--;\r\n        _isMod[addr] = false;\r\n        }\r\n    }\r\n    \r\n    //This function is used to temporarily exclude addresses from tax\r\n    //for partnership purposes, such as airdrops\r\n    //or for trading the token on other exchanges, expanding the reward system after launch using bridge contracts etc.\r\n       function ExcludefromTax(address addr) public onlyMain()\r\n    {\r\n            if(_isregistered[addr] == false) \r\n            UpdateRegister(addr, true);\r\n            else\r\n            _excludedfromTax[addr] = true;\r\n    }  \r\n   \r\n       function UndoExcludefromTax(address addr) public onlyMain()\r\n    { \r\n            if(_isregistered[addr] == false) \r\n            UpdateRegister(addr, false);\r\n            else\r\n            _excludedfromTax[addr] = false;\r\n    } \r\n    \r\n      function setMainWallet(address addr) public onlyMain()\r\n       {  \r\n          if(MainWallet != address(0))\r\n          _excludedfromTax[MainWallet] = false;\r\n          MainWallet = addr; \r\n          if(_isregistered[addr] == false) \r\n            UpdateRegister(addr, true);\r\n            else _excludedfromTax[addr] = true;\r\n          \r\n       }\r\n\r\n// This function is to enable or disable automatic calculation and distribution of payouts\r\n// in the event that a newly added reward token fails to transfer or similar isues arise,\r\n//temporarily disabling _AutoCalcRewards allows functions to be called without problem until the issue is resolved,\r\n//after which _AutoCalcRewards can be. enabled again.\r\n           function setAutoCalcRewards(bool isactive) public onlyMain()\r\n       {  \r\n          _AutoCalcRewards = isactive;\r\n       }\r\n\r\n    //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    //If the 3rd party has an allowance of >0 \r\n    //and the value to transfer is >0 \r\n    //and the allowance is >= the value of the transfer\r\n    //and it is not a contract\r\n    //perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        \r\n        UpdateRegister(_to, false);\r\n        require(__allowances[_from][msg.sender] > 0 &&\r\n            _value > 0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n               ); \r\n                  \r\n            _transferWithTax(_from, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n    function _transferWithTax(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0));\r\n      bool TaxFree;\r\n       if((_excludedfromTax[sender])||(_excludedfromTax[msg.sender])||(!_enableTax)||(_excludedfromTax[recipient]))\r\n       TaxFree = true;\r\n       \r\n       if(SingleUntaxedTransfer)\r\n       {\r\n           TaxFree = true;\r\n           SingleUntaxedTransfer = false; //resets state flag\r\n       }\r\n    /*\r\n    Different tax rates are applied to buy/transfer transactions and sell transactions.\r\n    Buy tax is fixed at 10% and sell tax is time variable starting very high, 90% in the first minute,\r\n    then below 49% and slowly decreasing down to 15%. Since a transfer tax above 30% can make sell transactions\r\n    on pancakeswap fail, the portion of tax larger than 30% is taken from the seller balance in addition to the amount\r\n    of tokens being sold. This overcomes the pancakeswap slippage limitation and also functions as an anti-dump mechanism. \r\n    During this inital period of high sell tax, one cannot sell all tokens in a sigle transcation without compensating\r\n    for the additional tax above 30%. \r\n    \r\n    So the following happens:\r\n    Sell tax        Of which additional tax     Holder tokens sellable in 1 transaction\r\n    90%             60%                         40%   \r\n    48%             18%                         82%   \r\n    40%             10%                         90%   \r\n    35%             5%                         95%   \r\n    30%             0%                         100%   \r\n    25%             0%                         100%   \r\n    20%             0%                         100%  \r\n    17%             0%                         100% \r\n    15%             0%                         100% \r\n    \r\n    In other words, in the most extreme case, if a holder sells 40% of his token balance during the first minute,\r\n    his remaining token balance will be zero. If the sell amount is larger than this, the transaction will revert.\r\n    */\r\n       \r\n       //transfer should be taxed and some work performed\r\n       if(!TaxFree)\r\n       {  uint256 TaxTokens;\r\n          uint256 AdditionalTax;\r\n       require(amount<=_maxTxAmount);\r\n         if((recipient==_pancakePairAddress))                   //sell\r\n           { SellSlippage = getSellSlippage();\r\n             if(SellSlippage>30) //sell tax portion higher than 30% is sent seperately \r\n             {\r\n                 TaxTokens = amount*30/100;\r\n                 AdditionalTax = amount*(SellSlippage-30)/100; //\r\n             }\r\n             else\r\n               TaxTokens = amount*SellSlippage/100;\r\n\r\n               _transfer(sender, Contract, amount+AdditionalTax);\r\n               _transfer(Contract, recipient, amount - TaxTokens);\r\n\r\n              SellTaxTokenPot += TaxTokens + AdditionalTax;\r\n             \r\n           }\r\n           else\r\n           {\r\n               TaxTokens = amount / 10; //10% buy tax applied to all non-sell transfers\r\n\r\n                      _transfer(sender, Contract, amount); //transaction sent to contract\r\n                      \r\n                    uint winnings = PlayLotto(amount);  \r\n                     if(winnings>0)\r\n                       emit LotteryWon_(recipient, winnings);\r\n                         _transfer(Contract, recipient, amount - TaxTokens + winnings); //net amount + winnings sent to recipient\r\n                       BuyTaxTokenPot += TaxTokens;\r\n\r\n                      BuyTaxTokenPot += TaxTokens;\r\n                   \r\n                 DistributeBuyTax();\r\n                 DistributeSellTax();\r\n                 \r\n           \r\n                      \r\n                 \r\n           }\r\n           \r\n           if(_AutoCalcRewards) //work moved to other functions due spread gas fees\r\n            {\r\n              if(_CalculatingRewards == true)\r\n             CalculateRewards(N_perTransfer);\r\n            }\r\n            \r\n       }\r\n       else  //no tax due\r\n        _transfer(sender, recipient, amount);\r\n        \r\n        //for reward calculation\r\n        if((_PrevBalance[sender] > __balanceOf[sender])&&(sender != _pancakePairAddress))\r\n          _PrevBalance[sender] = __balanceOf[sender];\r\n          \r\n        if(_isLaunched==false) //for presale buyers\r\n         _PrevBalance[recipient] += amount;\r\n    }\r\n \r\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {  \r\n     uint256 senderBalance = __balanceOf[sender];\r\n     \r\n         if(sender==address(this))\r\n         require(senderBalance >= amount + getReservedTokens()); //reserved tokens are excluded from contract balance \r\n         else\r\n         require(senderBalance >= amount);\r\n       \r\n        require((_enableTransfer)||(_excludedfromTax[sender])); \r\n\r\n         if(sender==_pancakePairAddress)\r\n          require(_isLaunched==true);   //buy transactions disabled until launch\r\n\r\n        \r\n        unchecked {\r\n            __balanceOf[sender] = senderBalance - amount;\r\n        }\r\n        __balanceOf[recipient] += amount;\r\n        \r\n         emit Transfer(sender, recipient, amount);\r\n\r\n  }\r\n  \r\nfunction DistributeSellTax() private\r\n{   //payouts\r\n        //35% lq to pancake lq \r\n        //50% holder BNB\r\n        //6% promo BNB\r\n        //1% airdrop token\r\n        //2% lottery token\r\n        //4% admin in bnb\r\n        //2% mod in bnb\r\n        \r\n        /*@@@\r\n        SELL TAX DISTRIBUTION  \r\n        35% lq to pancake lq \r\n        40% holder BNB\r\n        16% promo BNB\r\n        1% airdrop token\r\n        2% lottery token\r\n        4% admin in bnb\r\n        2% mod in bnb\r\n        */\r\n    if(SellTaxBNBPot>10000)  //skip if pot is empty\r\n    {\r\n          //since the remaining 79.5% is converted to bnb, the calculation percentages need to be normalized.\r\n      //40% total tax * 100/79.5    = 50.31 % bnb tax portion @@@\r\n      //17.5% total tax * 100/79.5  = 22.01 % bnb tax portion\r\n      //16% total tax * 100/79.5     = 20.13 % bnb tax portion @@@\r\n      //4% total tax * 100/79.5     = 5.03 % bnb tax portion\r\n      //2% total tax * 100/79.5     = 2.52 % bnb tax portion\r\n                            //      +=> 100% bnb tax portion  \r\n                            \r\n                     //bnbfromTax = BalanceBNB - bnbfromTax; \r\n         //40% holder BNB @@@\r\n            HolderPotBNB += SellTaxBNBPot * 5031 / 10000;  //adds to holder reward pot\r\n     \r\n       //16% promo BNB   @@@\r\n         MarketingBNB += SellTaxBNBPot * 2013 / 10000;\r\n             \r\n         //4% admin in bnb      \r\n            AdminPotBNB += SellTaxBNBPot * 503 / 10000;\r\n        \r\n        //2% mod in bnb     \r\n            ModPotBNB += SellTaxBNBPot * 252 / 10000;\r\n        \r\n            //35% lq to pancake lq \r\n     {       \r\n          //  netamount -= LQTax;\r\n     LQPotBNB += SellTaxBNBPot * 2200 / 10000; // half of 35% liquidity tax converted to BNB, rest is tokens on contract\r\n     SellTaxBNBPot = 0; //all tax distributed\r\n     }\r\n      }        \r\n   \r\n}\r\n\r\nfunction addLiquidityFromContract(uint256 TKN, uint256 BNB, bool fromLQpool) public onlyMain()\r\n{ \r\n    if(fromLQpool)\r\n    sendLiquidity();\r\n    else{\r\n        require(!_isLaunched);\r\n        _addLiquidityFromContract(TKN, BNB);\r\n    }\r\n}\r\n\r\nfunction sendLiquidity() private returns (bool)\r\n{\r\n            if((LQPotToken > 100000000)&&(LQPotBNB>=1000000000000000000)) // transfer at least 1 bnb@@@\r\n            {\r\n            (uint TKN, uint BNB) = _addLiquidityFromContract(LQPotToken, LQPotBNB); //sends tokens from contract along with LQ tax\r\n              if(TKN>0) // LQ transfer successful\r\n               {\r\n                   LQPotToken -= TKN;\r\n                   LQPotBNB -= BNB;\r\n               }\r\n            }   \r\n            return true;\r\n}\r\n\r\n\r\n/* @@@ \r\nBUY TAX DISTRIBUTION\r\n10% Gas costs\r\n30% Buyback and Burn\r\n35% holders in bnb \r\n19% marketing bnb\r\n4% admin in bnb\r\n2% mods in bnb\r\n*/\r\n\r\nfunction DistributeBuyTax() internal\r\n{\r\n     if(BuyTaxBNBPot>100)\r\n     {\r\n        //30% buybackpot\r\n        BuybackPotBNB += BuyTaxBNBPot * 30 / 100;\r\n        \r\n        //10% ges fees\r\n        GasPotBNB += BuyTaxBNBPot * 10 / 100; //1% goes to gas fees\r\n        \r\n        //35% holders in bnb \r\n        HolderPotBNB += BuyTaxBNBPot * 35 / 100;\r\n        \r\n        //19% marketing bnb\r\n        \r\n         MarketingBNB += BuyTaxBNBPot * 19 / 100;\r\n\r\n        //4% admin in bnb\r\n        \r\n        AdminPotBNB += BuyTaxBNBPot * 4 / 100;\r\n        \r\n        //2% mods in bnb\r\n        \r\n        ModPotBNB += BuyTaxBNBPot * 2 / 100;\r\n        BuyTaxBNBPot = 0;\r\n     }    \r\n}\r\n\r\n//public function to help accelerate auto calculations if required\r\nfunction WorkHelper(uint32 shifts) public onlyAdmin() RefundGas()\r\n{ NextTask = 0;\r\n  for(uint32 i = 0; i < shifts; i++)    \r\n  doWork(NextTask);\r\n}\r\n\r\nfunction doWork(uint32 task) private RefundGas()\r\n{ //work split between transfers and tasks\r\n    if(task == 0)\r\n    {\r\n       //convert tax to bnb and distribute to tax pots\r\n       _swapTaxTokenForBNB(_maxTxAmount,_maxTxAmount); //swap accumilated tax tokens to bnb up to _maxTxAmount   \r\n       DistributeBuyTax;\r\n       DistributeSellTax;\r\n\r\n     sendLiquidity();    \r\n \r\n    }\r\n    \r\n    if(task == 1)\r\n    {//calculateNrewards\r\n     if(_CalculatingRewards == true)\r\n       CalculateRewards(N_perTransfer);//calculate some rewards \r\n       else\r\n       {\r\n        if(block.timestamp - LastRewardCalculationTime > 3600) //@@@ restart 1 hour after previous round ends\r\n            if(HolderPotBNB >= 500000000000000000) //wait until at least 0.5 bnb in rewards have been accumilated \r\n            _StartRewardCalculation(); //can also be triggered manually by main wallet\r\n             task = 2; // do some payouts instead\r\n       }\r\n       \r\n    }\r\n    \r\n    if(task == 2)\r\n    {//payoutNrewards\r\n       _DistributeRewards(N_payoutsperWorkRound);//pay out some rewards   //@@@ changed from N_perTransfer to split the two values  \r\n    }\r\n    \r\n    if(task >= 3)\r\n    {//checkrestart reward calculation\r\n       if(AirdropPayout()==false) //checks if its time for next airdrop and does it, otherwhise dobuyback //PUT BACK\r\n          doBuyback();\r\n    }\r\n    \r\n    NextTask ++; \r\n    if(NextTask>3)  //max number of tasks\r\n    NextTask = 0; //restart task number\r\n}\r\n\r\n\r\n   function getSellSlippage() public view virtual returns (uint32) \r\n   {\r\n        uint256 current_time = block.timestamp; \r\n    if(_isLaunched==true) \r\n    {\r\n       if(current_time >= launch_time + 2419200)     //after 28 days\r\n       return 15; \r\n       else\r\n       if(current_time >= launch_time + 1123220)     //after 13 days\r\n       return 20; \r\n       else\r\n       if(current_time >= launch_time + 604800)     //after 7 days\r\n       return 22; \r\n       else\r\n       if(current_time >= launch_time + 259200)     //after 3 days\r\n       return 30; \r\n       else\r\n       if(current_time >= launch_time + 86400)     //after 24 hours\r\n       return 35; \r\n       else\r\n       if(current_time >= launch_time + 14400)     //after 4 hours\r\n       return 40; \r\n       else\r\n       if(current_time >= launch_time + 60)     //after 1 min\r\n       return 48; \r\n       else \r\n       return 90; //first minute \r\n    }\r\n    else\r\n       return 0; // - sell not possible before launch\r\n       }\r\nfunction checkRewards(address addr) public view returns (uint256)\r\n{\r\n   return _earnings[addr];\r\n}\r\n    \r\n         function PlayLotto(uint256 buyamount) private returns (uint256) {\r\n          // wins x2 purchase amount\r\n          //winningprobability = 5\r\n             uint256 winnings;\r\n           \r\n        if(LotteryPot > 0)\r\n        {\r\n             if(random(100) < 5) //won - buyamount multiplied 1/20 probability\r\n             winnings = buyamount; //adds winnings to sent amount (x2)\r\n             \r\n        if(winnings > 0)     \r\n        if(winnings <= LotteryPot)\r\n        LotteryPot -= winnings;\r\n        else\r\n        {\r\n          winnings = LotteryPot;\r\n          LotteryPot = 0;\r\n        }\r\n        }\r\n       return winnings; \r\n    }\r\n    \r\n        function random(uint256 range) internal returns (uint256) {  //pseudorandom number from 0 to range-1\r\n        \r\n    uint256 randomnumber = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, nonce))) % range;\r\n    nonce++;\r\n    \r\n    return randomnumber;\r\n}\r\n\r\n\r\n\r\n \r\n    //allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n        //allows a spender address to spend a specific amount of value\r\n    function _approveMore(address _owner, address _spender, uint _value) internal returns (bool success) {\r\n        uint256 old = __allowances[_owner][_spender];\r\n        __allowances[_owner][_spender] += _value;\r\n        emit Approval(_owner, _spender, old + _value);\r\n        return true;\r\n    }\r\n    \r\n\r\n\r\n    //shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n\r\n\r\n    receive () external payable {\r\n    } // fallback to receive bnb\r\n    \r\nfunction ReservesBNB() public view returns (uint256)\r\n{\r\n    return address(this).balance;\r\n}\r\n\r\nfunction ReservesToken() public view returns (uint256)\r\n{\r\n    return __balanceOf[address(this)];\r\n}\r\n\r\n    \r\n    //Adds Liquidity directly to the contract where LP are locked\r\n    function _addLiquidityFromContract(uint256 tokenamount, uint256 bnbamount) private returns (uint, uint){\r\n    \r\n      SingleUntaxedTransfer = true;//sets flag\r\n     _approveMore(Contract, address(_pancakeRouter), tokenamount); //test if works for third parties also\r\n       (uint amountToken, uint amountETH, ) = _pancakeRouter.addLiquidityETH{value: bnbamount}(\r\n            Contract,\r\n            tokenamount,\r\n            0,\r\n            0,\r\n            address(0),//liquidity locked permanently\r\n            block.timestamp\r\n        ); \r\n    SingleUntaxedTransfer = false;\r\n         return (amountToken, amountETH);\r\n    }\r\n\r\nfunction SendBNBfromContract(uint256 amountBNB, address receiver) private returns (bool) \r\n{\r\n  (bool success, ) = receiver.call{ value: amountBNB }(new bytes(0));\r\n\r\n  return success;\r\n}    \r\n\r\n//function for converting Bytes to uint[]\r\nfunction sliceUint(bytes memory bs, uint start)\r\n   public pure//internal pure\r\n    returns (uint)\r\n{\r\n    require(bs.length >= start + 32);\r\n    uint x;\r\n    assembly {\r\n        x := mload(add(bs, add(0x20, start)))\r\n    }\r\n    return x;\r\n}\r\n\r\n\r\nfunction swapTaxTokenForBNB(uint256 selltaxamount,uint256 buytaxamount) public onlyMain(){\r\n    _swapTaxTokenForBNB(selltaxamount,buytaxamount);\r\n}\r\n\r\n\r\nfunction _swapTaxTokenForBNB(uint256 selltaxamount,uint256 buytaxamount) private returns (bool){\r\n   uint256 total = selltaxamount+buytaxamount;\r\n   uint256 Sell = selltaxamount;\r\n   uint256 Buy = selltaxamount;\r\n   if(selltaxamount>SellTaxTokenPot)\r\n   Sell = SellTaxTokenPot; \r\n   if(buytaxamount>BuyTaxTokenPot)\r\n   Buy = BuyTaxTokenPot;\r\n   \r\n   \r\n   if(total == 0) //swap all\r\n   {\r\n      Sell = SellTaxTokenPot; \r\n      Buy = BuyTaxTokenPot;\r\n   }\r\n  \r\n  total = Sell+Buy;\r\n  if(total > 0)\r\n  {\r\n      \r\n      //split sell portion into token and bnb portions\r\n      \r\n      \r\n      BuyTaxTokenPot -= Buy;\r\n      SellTaxTokenPot -= Sell;\r\n      \r\n  \r\n   \r\n   uint256 bnbs;\r\n   \r\n   //swap and liquify small portion of contract balance relative to sell tax to add to liquidity in addition to tax\r\n\r\n   if(Sell>0)\r\n   {uint256 tokenportionofselltax = Sell * 205/1000;\r\n   \r\n                             //20.5% of sell tax is kept as tokens\r\n           \r\n        \r\n       //since 20.5% of the tax is not converted to bnb, the calculation percentages need to be normalized. \r\n        //0.75% total tax * 100/20.5   = 3.66 % token tax portion\r\n      //0.25% total tax * 100/20.5  = 1.22 % token tax portion\r\n      //2% total tax * 100/20.5     = 9.76 % token tax portion\r\n      //17.5% total tax * 100/20.5     = 85.36 % token tax portion\r\n                            //      +=> 100% token tax portion   \r\n                    //1% airdrop token \r\n                     AirdropPot += tokenportionofselltax * 366 / 10000; //0.75% to random airdrops => \r\n                     RafflePot +=  tokenportionofselltax * 122 / 10000; // 0.25%  to Raffle airdrops =>\r\n                     \r\n                     //2% lottery token   \r\n                     LotteryPot += tokenportionofselltax * 976 / 10000; //2% to lottery pot =>\r\n                     \r\n                     //liquidity tokens\r\n                     LQPotToken += tokenportionofselltax * 8536 / 10000;// 17.5% to loquidity tokens => \r\n   \r\n   \r\n    uint256 additionalLiquidity = Sell * 1/100; //0.5% bnb 0.5% token added additionally to liquidity from contract balance\r\n \r\n   \r\n   if(__balanceOf[Contract] > total + additionalLiquidity + getReservedTokens()) //enough available tokens for additional liquidity\r\n   {\r\n   bnbs = _swapTokenForBNB(total+additionalLiquidity/2-tokenportionofselltax); //tax + 0.5%\r\n   uint256 extraLQbnb = bnbs * 1/202; //0.5%\r\n   bnbs -= extraLQbnb;\r\n   LQPotBNB += extraLQbnb;\r\n   if(bnbs>0) //swap successful\r\n   LQPotToken += additionalLiquidity/2;\r\n   }\r\n   }\r\n   else\r\n   {\r\n    bnbs = _swapTokenForBNB(total);   \r\n   }\r\n\r\nif(bnbs>0)\r\n{\r\n   uint256 buybnbs = bnbs * Buy / total;\r\n   BuyTaxBNBPot += buybnbs;\r\n   SellTaxBNBPot += bnbs - buybnbs;\r\n}\r\nelse\r\n{ //swap failed, return tokens to post\r\n   BuyTaxTokenPot += Buy;\r\n  SellTaxTokenPot += Sell;  \r\n}\r\n\r\n  }\r\n  SingleUntaxedTransfer = false;\r\n  return true;\r\n}\r\n\r\nfunction _swapTokenForBNB(uint256 tokenamount) private returns (uint256){ \r\n  if(tokenamount>0)\r\n  {\r\n      \r\n        _approveMore(Contract, address(_pancakeRouter), tokenamount); \r\n\r\n        SingleUntaxedTransfer = true;//sets flag\r\n        address[] memory path = new address[](2);\r\n        path[0] = Contract;\r\n        path[1] = _pancakeRouter.WETH();\r\n        \r\n        (bool success, bytes memory data) = routerAddress.call(abi.encodeWithSelector(\r\n        0x18cbafe5,\r\n        \r\n        tokenamount,\r\n        0,\r\n        path,\r\n        Contract,\r\n        block.timestamp\r\n        )); \r\n\r\n    if(success)\r\n       { uint[] memory amounts = abi.decode(data, (uint[]));\r\n\r\n        if(amounts.length>=2)\r\n\r\n        return amounts[1];\r\n\r\n        }\r\n     }\r\n  SingleUntaxedTransfer = false;\r\n       return 0;\r\n    }\r\n    \r\n    \r\n     \r\n       \r\n//works for receiver != address(this) \r\n function _swapBNBforChosenTokenandPayout(uint256 amountBNB,address PayoutTokenContract, address receiver) private returns (bool){\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = PayoutTokenContract;\r\n\r\n    try _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountBNB}(\r\n            0,\r\n            path,\r\n            address(receiver),\r\n            block.timestamp\r\n        )\r\n        {return true;}\r\n        catch {}\r\n   \r\n     \r\n     return false;\r\n    }   \r\n\r\n/*function quotepriceToken(uint256 BNBs) public view returns (uint256)\r\n{\r\n    address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = address(this);\r\n        uint[] memory amounts = _pancakeRouter.getAmountsOut(BNBs, path); //returns (uint[] memory amounts)\r\n        return amounts[1];\r\n}*/\r\n\r\n/*function quotepriceBNB(uint256 Tokens) public view returns (uint256)\r\n{\r\n    \r\n     address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _pancakeRouter.WETH();\r\n       uint[] memory amounts =  _pancakeRouter.getAmountsOut(Tokens, path); \r\n   \r\n    return amounts[1];\r\n}*/\r\n\r\nfunction getFreeBNBs() public view returns (uint256)\r\n{\r\n  uint256 reservedBNBs = LQPotBNB + BuybackPotBNB + HolderPotBNB + AdminPotBNB + ModPotBNB;\r\n  reservedBNBs += MarketingBNB + SellTaxBNBPot + BuyTaxBNBPot + GasPotBNB + claimableBNBearnings;\r\n  return address(this).balance - reservedBNBs;\r\n}\r\n\r\n//extra funds can also be sent and distributed\r\n//use with caution. To recover BNB sent to contract without allocation \r\nfunction addBNBtoHolderPot(uint256 amountbnb) public onlyMain()\r\n{ \r\n  require(amountbnb <= getFreeBNBs());\r\n   HolderPotBNB += amountbnb;\r\n}\r\n\r\nfunction addBNBtoGasPot(uint256 amountbnb) public onlyMain()\r\n{ \r\n  require(amountbnb <= getFreeBNBs());\r\n   GasPotBNB += amountbnb;\r\n}\r\n///\r\n\r\n// buyback tokens and send to wallet address using main wallet to avoid invalid to address error in pancakeswap\r\nfunction _buyBackTokens(uint256 amountBNB) private returns (uint256){  \r\n    \r\n     address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = Contract;\r\n\r\n       SingleUntaxedTransfer = true;\r\n     uint[] memory amounts = _pancakeRouter.swapExactETHForTokens{value: amountBNB}(\r\n            0,\r\n            path,\r\n            MainWallet, //avoids \"Invalid TO\" error from pancakeswap (cannot swap for native tokens to contract address)\r\n            block.timestamp\r\n        );\r\n        uint256 TOKENS;\r\n       if(amounts[1]>0)\r\n       {\r\n         if(__balanceOf[MainWallet]>=amounts[1])\r\n            TOKENS = amounts[1];  \r\n         else  \r\n            TOKENS = __balanceOf[MainWallet];  //catch for if price turns out lower than expected\r\n       \r\n           \r\n           _transfer(MainWallet, address(this), TOKENS); //sends balance back to contract\r\n           return TOKENS;\r\n       }\r\n       SingleUntaxedTransfer = false;\r\n     return 0;\r\n}\r\n//@@@ not used\r\n //every week a new token is added to the payout list and a promo token is set that all holders receive\r\n/*    function setPromotedRewardTokenoftheWeek(uint32 newTOTW, uint32 _PromoPerc) public onlyMain() {\r\n        require(newTOTW < NumberofPayoutTokens);\r\n        require (_PromoPerc <= 10);  //max 10%\r\n        PromoPerc = _PromoPerc;\r\n        RewardTokenoftheWeek = newTOTW;\r\n      if(PromoPerc>0) //0% means promo inactive\r\n     emit PromotedtokenoftheWeek(PayoutTokenListNames[RewardTokenoftheWeek]);\r\n    } \r\n  \r\n*/   \r\n        function getPromotedRewardTokenoftheWeek() public view returns(string memory){\r\n\r\n        return PayoutTokenListNames[RewardTokenoftheWeek];\r\n    } \r\n    \r\n\r\nfunction burnbeforeLaunch(uint256 tokens) public onlyMain() LockedafterLaunch()\r\n{ \r\n  require(__balanceOf[address(this)] >= tokens);\r\n  _burn(address(this), tokens);\r\n    \r\n}\r\n\r\nfunction _burn(address account, uint256 amount) internal virtual {\r\n       require(account != address(0));\r\n       if(__totalSupply > burnUntil)\r\n       if(__totalSupply > amount)\r\n       { if(__totalSupply - amount < burnUntil)\r\n           amount = __totalSupply - burnUntil;\r\n        address deadwallet = address(0x000000000000000000000000000000000000dEaD);\r\n        //_beforeTokenTransfer(deadwallet, amount);\r\n\r\n        if(__balanceOf[account] >= amount)\r\n        {\r\n        unchecked {\r\n            __balanceOf[account] -= amount;\r\n        }\r\n        __totalSupply -= amount;\r\n       \r\n        emit Transfer(account, deadwallet, amount);\r\n        emit TokensBurned(amount);\r\n        }\r\n    }\r\n  }\r\n\r\n\r\n        function AddTokentoPayoutList(address TokenAddress, string memory Name) public onlyMain() {\r\n        \r\n       PayoutTokenList.push(TokenAddress);\r\n        PayoutTokenListNames.push(Name);\r\n        NumberofPayoutTokens++;\r\n    }\r\n\r\n//if a payout token has to be updated\r\n        function EditPayoutList(uint32 pos, address TokenAddress, string memory Name) public onlyMain(){\r\n        \r\n        require(pos < NumberofPayoutTokens);\r\n        PayoutTokenList[pos] = TokenAddress;\r\n        PayoutTokenListNames[pos] = Name;\r\n        \r\n    }\r\n    \r\n//returns the reward token selection of the caller    \r\nfunction ShowMyRewardTOKENS() public view returns (uint32[6] memory tokennumbers){\r\n    \r\n    \r\n    tokennumbers[0] =   _RewardTokens[msg.sender].Token1;\r\n    tokennumbers[1] =   _RewardTokens[msg.sender].Token2;\r\n    tokennumbers[2] =   _RewardTokens[msg.sender].Token3;\r\n    tokennumbers[3] =   _RewardTokens[msg.sender].Token4;\r\n    tokennumbers[4] =   _RewardTokens[msg.sender].Token5;\r\n    tokennumbers[5] =   _RewardTokens[msg.sender].Token6;\r\n \r\nreturn (tokennumbers);\r\n    }\r\n    \r\n//returns the names of all payout tokens    \r\nfunction ShowAllRewardTokens() public view returns (string[] memory Rewards){ \r\nreturn PayoutTokenListNames;\r\n}\r\n\r\n//returns the percentage payout settings of the caller\r\nfunction ShowMyRewardSLICES() public view returns (uint32[6] memory slices){\r\n    \r\n    \r\n    slices[0] =   _RewardTokens[msg.sender].Slice1; //percentage\r\n    slices[1] =   _RewardTokens[msg.sender].Slice2;\r\n    slices[2] =   _RewardTokens[msg.sender].Slice3;\r\n    slices[3] =   _RewardTokens[msg.sender].Slice4;\r\n    slices[4] =   _RewardTokens[msg.sender].Slice5;\r\n    slices[5] =   _RewardTokens[msg.sender].Slice6;\r\n    \r\nreturn (slices);\r\n    }    \r\n\r\n    function ChooseSinglePayoutToken(uint32 PayoutTokenNumber) public CheckforWork() {\r\n        require(PayoutTokenNumber < NumberofPayoutTokens);\r\n        _RewardTokens[msg.sender].Token1 = PayoutTokenNumber;\r\n        _RewardTokens[msg.sender].Slice1 = 100;\r\n        _SplitTokenRewards[msg.sender] = false;\r\n    }\r\n       //token numbers + percentage slice\r\n        function ChooseMultiplePayoutTokens(uint32 Token1,uint32 Slice1,uint32 Token2,uint32 Slice2,\r\n                                            uint32 Token3,uint32 Slice3,uint32 Token4,uint32 Slice4,\r\n                                            uint32 Token5,uint32 Slice5,uint32 Token6,uint32 Slice6) public CheckforWork() {\r\n       \r\n     //   require((Token1 > 0)||(Token2 > 0)||(Token3 > 0)||(Token4 > 0)||(Token5 > 0)||(Token6 > 0)||, \"No tokens selected\");\r\n        uint32 Whole = Slice1+Slice2+Slice3;\r\n        Whole += Slice4+Slice5+Slice6;\r\n        require(Whole > 0);\r\n       \r\n       uint32 N = uint32(NumberofPayoutTokens);\r\n       bool OutofBounds = ((Token1 >= N)||(Token2 >= N)||(Token3 >= N)||(Token4 >= N)||(Token5 >= N)||(Token6 >= N));\r\n        require(OutofBounds == false);\r\n       _RewardTokens[msg.sender].Token1 = Token1;\r\n       _RewardTokens[msg.sender].Token2 = Token2;\r\n       _RewardTokens[msg.sender].Token3 = Token3;\r\n       _RewardTokens[msg.sender].Token4 = Token4;\r\n       _RewardTokens[msg.sender].Token5 = Token5;\r\n       _RewardTokens[msg.sender].Token6 = Token6;\r\n        _RewardTokens[msg.sender].Slice1 = Slice1;\r\n        _RewardTokens[msg.sender].Slice2 = Slice2;\r\n        _RewardTokens[msg.sender].Slice3 = Slice3;\r\n        _RewardTokens[msg.sender].Slice4 = Slice4;\r\n        _RewardTokens[msg.sender].Slice5 = Slice5;\r\n        _RewardTokens[msg.sender].Slice6 = Slice6;\r\n        \r\n        _SplitTokenRewards[msg.sender] = true;\r\n       \r\n    }\r\n\r\nfunction StartRewardCalculation() public onlyMain()\r\n{  require(HolderPotBNB > 0);\r\n    _StartRewardCalculation();\r\n}\r\n\r\nfunction _StartRewardCalculation() private {\r\n   if((_CalculatingRewards == false)&&(HolderPotBNB > 0))\r\n   {\r\n   HolderPotBNBcalc = HolderPotBNB; //used as reference for calculation\r\n   AdminPotBNBcalc =  AdminPotBNB;\r\n   ModPotBNBcalc = ModPotBNB;\r\n   CircSupplycalc = __totalSupply - __balanceOf[address(this)] - __balanceOf[_pancakePairAddress] - __balanceOf[routerAddress]; //circulating supply\r\n   Rewardcycle++; //counter to keep track of rewards earned. next cycle starts when all rewards have been paid out\r\n   _CalculatingRewards = true;\r\n   //LastRewardCalculationTime = block.timestamp;\r\n   _PayTeam();\r\n   }\r\n   \r\n}\r\n\r\nfunction CalculateNRewards(uint32 counts) public onlyAdmin() RefundGas(){\r\n  // function calculates rewards \r\n  require(_CalculatingRewards == true);\r\n  if(counts > 0)\r\n   CalculateRewards(counts); \r\n}\r\n\r\nfunction setNperTransfer(uint32 N) public onlyMain(){\r\n    require(N<8);\r\n    N_perTransfer = N;\r\n}\r\n\r\nfunction setNpayoutsperWorkRound(uint32 N) public onlyMain(){ //@@@ added\r\n    require(N<8);\r\n    N_payoutsperWorkRound = N;\r\n}\r\n\r\nfunction CalculateRewards(uint32 counts) private returns (bool){\r\n         /////calculate reward for holders\r\n   if(counts > 0)\r\n   {   \r\n    uint32 maxtries = counts * 3;  \r\n    uint32 currenttry;\r\n    uint32 N_calculated;\r\n         \r\n        if((CircSupplycalc>0)&&(HolderPotBNBcalc>0))//safety check\r\n        {\r\n        \r\n        //for (uint256 k = startpos; k < stoppos; k++)\r\n        while((_CalculatingRewards == true)&&(currenttry<maxtries))\r\n         { address holder = investorList[HolderPos];\r\n\r\n         if(_CalculateSpecificReward(holder))\r\n         N_calculated++; \r\n         \r\n         currenttry++;\r\n         HolderPos++;\r\n         \r\n         if(N_calculated >= counts)\r\n          currenttry = maxtries; //enough rewards calculated\r\n         \r\n         \r\n         if(HolderPos >= N_holders) //all rewards for this cycle have been calculated\r\n           {HolderPos = 0;\r\n           HolderPotBNBcalc = 0;\r\n         \r\n           _CalculatingRewards = false;  //all rewards calculated\r\n           LastRewardCalculationTime = block.timestamp;\r\n            emit RewardsRecalculated();\r\n           }\r\n         }\r\n        // HolderPotBNB += Pot; //earnings distributed\r\n         return true;\r\n    }\r\n   }\r\n     return false;\r\n   }\r\n\r\nfunction _CalculateSpecificReward(address holder) private returns (bool)\r\n{      \r\n             if((_excludedfromTax[holder]==false)&&(_LastRewardCycle[holder]<Rewardcycle)) //check if holder has not manually claimed within the current reward cycle\r\n         if(holder !=_pancakePairAddress&&(holder !=routerAddress))  //excluded\r\n         {  _LastRewardCycle[holder] = Rewardcycle; \r\n            uint256 bal = _PrevBalance[holder]; \r\n            if(__balanceOf[holder]<bal)  \r\n              bal = __balanceOf[holder]; //only rewarded for tokens held for the full period\r\n              \r\n              _PrevBalance[holder] = __balanceOf[holder]; //balance set for next reward cycle calculation\r\n              \r\n            uint256 NewEarnings = HolderPotBNBcalc * bal / CircSupplycalc; \r\n            if(NewEarnings <= HolderPotBNB) //safety check, should always be true\r\n            {\r\n            HolderPotBNB -= NewEarnings;  \r\n            claimableBNBearnings += NewEarnings;\r\n             _earnings[holder] += NewEarnings;\r\n            \r\n            }\r\n           \r\n             return true; //reward distributed\r\n           \r\n         } \r\n         return false; //no rewards to distribute\r\n}\r\n\r\nfunction getReservedTokens() private view returns (uint256 reserves)\r\n{\r\n    reserves = LotteryPot + AirdropPot + RafflePot + BuyTaxTokenPot + SellTaxTokenPot + LQPotToken;\r\n    return reserves;\r\n\r\n}\r\n\r\n//allows caller to claim all accumilated earnings in the payout token of choice\r\nfunction ClaimMyRewards() public CheckforWork()\r\n{ \r\n_CalculateSpecificReward(msg.sender);  //check for any unprocessed rewards  \r\nrequire(_earnings[msg.sender] > 0, \"All rewards claimed\");\r\nrequire(__balanceOf[msg.sender] > 0);\r\n\r\n    ClaimRewards(msg.sender);\r\n}\r\n\r\nfunction setMyAutoPayout(bool Checked) public CheckforWork() returns (bool)\r\n{\r\n    _AutoPayoutEnabled[msg.sender] = Checked;\r\n    return _AutoPayoutEnabled[msg.sender];\r\n}\r\n\r\nfunction getMyAutoPayoutisActive() public view returns (bool)\r\n{\r\n    return _AutoPayoutEnabled[msg.sender];\r\n}\r\n\r\n//manually speed up reward distribution\r\nfunction DistributeRewards(uint32 count)  public onlyAdmin() RefundGas()\r\n{\r\n        _DistributeRewards(count);\r\n}\r\n\r\n\r\n//function for hosting raffles and paying out winners from raffle pot\r\nfunction sendAirdrop(uint256 _Tokens, address recipient) public onlyAdmin() \r\n{  //uint256 _Tokens = Tokens * 10**18;\r\n   if(_isLaunched)\r\n    require(_Tokens <= 5000000 * 10**18); //max 5000000 tokens per airdrop after launch @@@\r\n    \r\n    require(_Tokens <= RafflePot); // can only send from raffle pot reserve (0.25% of sell tax +2% at start)\r\n    RafflePot -= _Tokens;  //remove from reserve //@@@ changed to raffle pot\r\n    _transfer(address(this), recipient, _Tokens);\r\n}\r\n\r\n/*//this is to help people having trouble using the dapp.\r\nfunction setWalletAutoPayout(address holderaddr) public onlyAdmin()\r\n{\r\n    _AutoPayoutEnabled[holderaddr] = true;\r\n}*/\r\n//auto reward payout \r\nfunction _DistributeRewards(uint32 count) private\r\n{   uint32 runs;\r\n    uint32 tries;\r\n    uint32 maxtries = count * 2; \r\n    uint256 current_time = block.timestamp;\r\n   \r\n    while(runs < count)\r\n   { tries++;\r\n     if(tries >= maxtries)\r\n      runs = count; //quit loop\r\n    address recipient = investorList[DistHolderPos];\r\n    if(_AutoPayoutEnabled[recipient])  \r\n    {   \r\n        if(current_time - _LastPayout[recipient] > 3600)// last claimed 1h ago   @@@\r\n          ClaimRewards(recipient); //this function checks that rewards and balance of recipient > 0 and rewards\r\n    }\r\n   \r\n   \r\n    if(_earnings[recipient] > 0)\r\n    if(current_time - _LastPayout[recipient] > 15552000) //last claimed more than 180 days ago = dead wallet, rewards redistributed\r\n          {  \r\n              _LastPayout[recipient] = current_time;\r\n              uint256 temp = _earnings[recipient];\r\n              _earnings[recipient] = 0;\r\n              HolderPotBNB += temp;\r\n          }\r\n\r\n    runs++;\r\n    DistHolderPos++;\r\n    if(DistHolderPos >= N_holders)\r\n     {\r\n     DistHolderPos = 0; //restart list\r\n     runs = count; //quit loop\r\n     }\r\n    }\r\n}\r\nfunction ClaimRewards(address receiver) private returns(bool){\r\n  if((_earnings[receiver] > 0)&&(__balanceOf[receiver] > 0))\r\n  {  _LastPayout[receiver] = block.timestamp;\r\n      uint256 amountBNB = _earnings[receiver];\r\n     uint256 dist = amountBNB;\r\n     claimableBNBearnings -= amountBNB;\r\n     _earnings[receiver] = 0; //reentrancy guard\r\n/* //@@@  \r\n    if(PromoPerc > 0)//promoted token of the week\r\n    {\r\n      uint256 promotokenBNB = amountBNB * PromoPerc / 100;\r\n     if( _swapBNBforChosenTokenandPayout(promotokenBNB,PayoutTokenList[RewardTokenoftheWeek],receiver))\r\n     {\r\n       amountBNB -= promotokenBNB;\r\n       //distributed += promotokenBNB;\r\n     }\r\n    }\r\n */\r\n\r\n    if(_SplitTokenRewards[receiver] == false)\r\n    { //single token reward\r\n    address PayoutTokenContract = PayoutTokenList[_RewardTokens[receiver].Token1];\r\n     if(PayoutTokenContract == _pancakeRouter.WETH()) //payout bnb\r\n     {\r\n         \r\n       if(SendBNBfromContract(amountBNB, receiver))\r\n        {   \r\n          // distributed += amountBNB;\r\n           amountBNB = 0;\r\n        }\r\n     }\r\n       else\r\n     { \r\n         if(PayoutTokenContract == address(this)) //native token\r\n          SingleUntaxedTransfer = true;\r\n        if(_swapBNBforChosenTokenandPayout(amountBNB,PayoutTokenContract,receiver))\r\n    { \r\n     amountBNB = 0;\r\n    }\r\n     }\r\n    }\r\n    else\r\n    { //Split token rewards\r\n    \r\n      address PayoutTokenContract;\r\n       uint32 pie;\r\n       uint32 percslice;\r\n      \r\n      uint32[6] memory tokennumbers;\r\n      uint32[6] memory slices;\r\n      \r\n    tokennumbers[0] =   _RewardTokens[receiver].Token1;\r\n    tokennumbers[1] =   _RewardTokens[receiver].Token2;\r\n    tokennumbers[2] =   _RewardTokens[receiver].Token3;\r\n    tokennumbers[3] =   _RewardTokens[receiver].Token4;\r\n    tokennumbers[4] =   _RewardTokens[receiver].Token5;\r\n    tokennumbers[5] =   _RewardTokens[receiver].Token6;\r\n    \r\n    slices[0] =   _RewardTokens[receiver].Slice1; //percentage\r\n    slices[1] =   _RewardTokens[receiver].Slice2;\r\n    slices[2] =   _RewardTokens[receiver].Slice3;\r\n    slices[3] =   _RewardTokens[receiver].Slice4;\r\n    slices[4] =   _RewardTokens[receiver].Slice5;\r\n    slices[5] =   _RewardTokens[receiver].Slice6;\r\n      \r\n      uint256 slicevalue = amountBNB / 100; //1%\r\n      for(uint32 i = 0; i < 6; i++)\r\n      {uint256 BNBslice;\r\n       if((slices[i] > 0)&&(pie <= 100))\r\n       {\r\n        percslice = slices[i];  \r\n        if(pie+percslice>100)// check for sneaky percentages\r\n         percslice = 100-pie;\r\n         pie += percslice;\r\n         BNBslice = slicevalue * percslice;\r\n         if(BNBslice>amountBNB)\r\n          BNBslice = amountBNB; //safety check\r\n      PayoutTokenContract = PayoutTokenList[tokennumbers[i]];\r\n      \r\n      if(PayoutTokenContract == _pancakeRouter.WETH()) //payout bnb\r\n    {\r\n       if(SendBNBfromContract(BNBslice, receiver))\r\n          { amountBNB -= BNBslice; \r\n   \r\n          }\r\n    }\r\n    else\r\n    {   if(PayoutTokenContract == address(this)) //native token\r\n         SingleUntaxedTransfer = true;\r\n      if(_swapBNBforChosenTokenandPayout(BNBslice,PayoutTokenContract,receiver)){ \r\n       amountBNB -= BNBslice;\r\n  \r\n      }\r\n      }\r\n       }\r\n    }\r\n   }\r\n   _earnings[receiver] = amountBNB; //if anything is still left, it gets refunded to the holder earnings pot\r\n  distributedRewards += BNB2BUSDconverter(dist - amountBNB);\r\n  claimableBNBearnings += amountBNB;  \r\n\r\n }\r\n return true;\r\n} \r\n\r\n//@@@ BUSD price retriever - choose between testnet and mainnet addresses\r\nfunction BNB2BUSDconverter(uint256 BNBs) public view returns (uint256)\r\n{\r\n    address[] memory path = new address[](2);\r\n        path[0] = _pancakeRouter.WETH();\r\n        path[1] = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56); //mainnet BUSD\r\n      // path[1] = address(0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7); //testnet BUSD\r\n        uint[] memory amounts = _pancakeRouter.getAmountsOut(BNBs, path); //returns (uint[] memory amounts)\r\n        return amounts[1];\r\n}\r\n\r\nfunction MyAvailableRewards() public view returns(uint256){\r\n   \r\n    return _earnings[msg.sender];\r\n}\r\n\r\n\r\nfunction AirdropPayout() private returns (bool){ ////set to private\r\n uint256 currenttime = block.timestamp;\r\n    if((_isLaunched == true)&&(currenttime - Airdrop_timeoflastPayout > 18000)&&(AirdropPot>10000000000000)) //5 hours 18000; minimum pot size\r\n   {\r\n      uint256 payoutperwinner =  AirdropPot * 10 / 300;\r\n    //  payoutperwinner = AirdropPot / 3;//3 payouts per airdrop\r\n      if(payoutperwinner>_maxTxAmount)\r\n      payoutperwinner=_maxTxAmount; //max airdrop 1000 tokens\r\n      \r\n      uint256 tries;\r\n      uint256 maxtries = 6; //if a winner does not qualify, redraw up to 6 tries\r\n      uint256 Dropsmade;\r\n    while(tries < maxtries) \r\n    {  \r\n         uint256 randomnumber = random(N_holders); // pseudorandomly generated number from 0 to N_holders-1\r\n    \r\n      address winner = address(investorList[randomnumber]);\r\n      //min balance of 10 tokens for airdrop \r\n        if((__balanceOf[winner] >= 1000000000000000000000000)&&(_excludedfromTax[winner]==false)&&(!isContract(winner)))\r\n        if(currenttime - _LastAirdrop[winner] > 432000)//each address can only win once every 5 days to keep it fair\r\n        {\r\n        AirdropPot -= payoutperwinner;    \r\n         //_transfer(address(this), winner, payoutperwinner);\r\n         __balanceOf[address(this)] -= payoutperwinner;\r\n         __balanceOf[winner] += payoutperwinner;\r\n         _LastAirdrop[winner] = currenttime;\r\n         Airdrop_totalPaidOut += payoutperwinner;\r\n         emit Airdrop_(winner, payoutperwinner);\r\n         Dropsmade++;\r\n         if(Dropsmade >= 3)\r\n         tries = maxtries;//stops while loop\r\n        }\r\n        \r\n        tries++;\r\n    }\r\n\r\n    Airdrop_timeoflastPayout = currenttime;\r\n    return true;\r\n   }\r\n   return false;//no airdrops to be made\r\n}\r\n\r\n\r\n//Function waits until NextbuybackMember count is reached and then buys back tokens\r\n//The bought tokens are burned until 50% of the inital supply is left\r\n//tokens are first sent to the main wallet, as the pancake pair swap function\r\n//throws an exception when the receiving address is the contract of the native token.\r\nfunction doBuyback() public returns (bool) //set to private\r\n{\r\n   if((_isLaunched == true)&&(N_holders >= NextBuybackMemberCount)) \r\n   {\r\n     uint256 amountBNB = BuybackPotBNB * 40 / 100; //max 40% of pot per transaction\r\n      \r\n      uint256 tokens = __balanceOf[MainWallet];\r\n\r\n    //burn tokens\r\n    SingleUntaxedTransfer = true;\r\n    BuybackPotBNB -= amountBNB;\r\n    if(_swapBNBforChosenTokenandPayout(amountBNB,address(this),MainWallet)==false) //transaction did not revert\r\n    BuybackPotBNB += amountBNB; //failed put back into pot\r\n    else\r\n    {//success\r\n    \r\n    if(__balanceOf[MainWallet]>tokens)  //netto balance of contract increased\r\n    {\r\n        tokens = __balanceOf[MainWallet] - tokens; //set to difference and burn if required\r\n\r\n     _transfer(MainWallet,Contract,tokens);//transfers tokens back to contract address before burning.\r\n     if((__totalSupply - tokens > burnUntil))\r\n        _burn(address(this), tokens);\r\n    }\r\n       emit Buyback_(tokens, N_holders); \r\n    \r\n     NextBuybackMemberCount = NextBuybackMemberCount + Buyback_increment;\r\n     Buyback_increment = Buyback_increment * 110/100; //wait 10% longer each time\r\n     return true;\r\n    }\r\n   \r\n }\r\n return false;\r\n\r\n}\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_Tokens\",\"type\":\"uint256\"}],\"name\":\"Airdrop_\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NumberofHolders\",\"type\":\"uint256\"}],\"name\":\"Buyback_\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"LotteryWon_\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RewardsRecalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TOKEN_LAUNCHED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"AddTokentoPayoutList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AdminPotBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AirdropPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Airdrop_totalPaidOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"BNBs\",\"type\":\"uint256\"}],\"name\":\"BNB2BUSDconverter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyTaxBNBPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuyTaxTokenPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BuybackPotBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"counts\",\"type\":\"uint32\"}],\"name\":\"CalculateNRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"Token1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Slice1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Token2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Slice2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Token3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Slice3\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Token4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Slice4\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Token5\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Slice5\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Token6\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"Slice6\",\"type\":\"uint32\"}],\"name\":\"ChooseMultiplePayoutTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"PayoutTokenNumber\",\"type\":\"uint32\"}],\"name\":\"ChooseSinglePayoutToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimMyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DistHolderPos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"count\",\"type\":\"uint32\"}],\"name\":\"DistributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"pos\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"}],\"name\":\"EditPayoutList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ExcludefromTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GasPotBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HolderPos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HolderPotBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LQPotBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LQPotToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LastRewardCalculationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LotteryPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MainWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MarketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ModPotBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_Admin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_Mods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"N_holders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NextBuybackMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NextTask\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NumberofPayoutTokens\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PayoutTokenList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PayoutTokenListNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RafflePot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReservesBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReservesToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RewardTokenoftheWeek\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Rewardcycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SellSlippage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SellTaxBNBPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SellTaxTokenPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ShowAllRewardTokens\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"Rewards\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ShowMyRewardSLICES\",\"outputs\":[{\"internalType\":\"uint32[6]\",\"name\":\"slices\",\"type\":\"uint32[6]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ShowMyRewardTOKENS\",\"outputs\":[{\"internalType\":\"uint32[6]\",\"name\":\"tokennumbers\",\"type\":\"uint32[6]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StartLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StartRewardCalculation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ToggleTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"UndoExcludefromTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"shifts\",\"type\":\"uint32\"}],\"name\":\"WorkHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WorkHelperWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_AutoCalcRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CalculatingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_enableTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_enableTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isLaunched\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakePairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountbnb\",\"type\":\"uint256\"}],\"name\":\"addBNBtoGasPot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountbnb\",\"type\":\"uint256\"}],\"name\":\"addBNBtoHolderPot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"TKN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"BNB\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromLQpool\",\"type\":\"bool\"}],\"name\":\"addLiquidityFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addtoAdminList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addtoModList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"burnbeforeLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableBNBearnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doBuyback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFreeBNBs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMyAutoPayoutisActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPromotedRewardTokenoftheWeek\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellSlippage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExcludedfromTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isModerator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removefromModList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_Tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sendAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isactive\",\"type\":\"bool\"}],\"name\":\"setAutoCalcRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMainWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketOwner\",\"type\":\"address\"}],\"name\":\"setMarketingOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"Checked\",\"type\":\"bool\"}],\"name\":\"setMyAutoPayout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"N\",\"type\":\"uint32\"}],\"name\":\"setNpayoutsperWorkRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"N\",\"type\":\"uint32\"}],\"name\":\"setNperTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWorkHelper\",\"type\":\"address\"}],\"name\":\"setWorkHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bs\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"sliceUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"selltaxamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buytaxamount\",\"type\":\"uint256\"}],\"name\":\"swapTaxTokenForBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EthernalFinanceII", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "30", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://10c09d54b1482eca0f2edadcd5f56384c0cee0be8064d7b13c302aedff6cf820"}