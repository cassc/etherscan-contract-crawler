{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.12;\r\ninterface TokenLike {\r\n    function transferFrom(address,address,uint) external;\r\n    function transfer(address,uint) external;\r\n    function balanceOf(address) external view  returns (uint);\r\n}\r\n\r\ncontract FiFaCPFarm {\r\n\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external  auth { wards[usr] = 1; }\r\n    function deny(address usr) external  auth { wards[usr] = 0; }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"FiFaFarm/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256    amount;   \r\n        int256     rewardDebt;\r\n        uint256    harved;\r\n        uint256[2][]  withdrawList;\r\n        uint256[2][]  harveList;\r\n        uint256[2][]  depositList;\r\n    }\r\n    struct CpFarmInfo {  \r\n        uint256    dayAmount;\r\n        uint256    myAmount;\r\n        uint256    cpBlance;\r\n        uint256    cpUsed;\r\n        uint256    beHarve;\r\n        uint256    harved;\r\n        uint256[2][]  withdrawList;\r\n        uint256[2][]  harveList;\r\n        uint256[2][]  depositList;\r\n    }\r\n    uint256   public acclpPerShare;\r\n    uint256   public lastRewardBlock = 34173409;\r\n    uint256   public valuePerBlock = 347222*1E13;\r\n    uint256   public over;\r\n    TokenLike public token = TokenLike(0xc0756C6a815c8eE652e1a950EfC6Fc84B5481cb9);\r\n    TokenLike public lptoken = TokenLike(0x17CfF66d3D236bd2D53D6F258078F968a4eaE83D);\r\n\r\n    mapping (address => UserInfo) public userInfo;\r\n\r\n\r\n    event Deposit( address  indexed  owner,\r\n                   uint256           wad\r\n                  );\r\n    event Harvest( address  indexed  owner,\r\n                   uint256           wad\r\n                  );\r\n    event Withdraw( address  indexed  owner,\r\n                    uint256           wad\r\n                 );\r\n\r\n\r\n        // --- Math ---\r\n    function add(uint x, int y) internal pure returns (uint z) {\r\n        z = x + uint(y);\r\n        require(y >= 0 || z <= x);\r\n        require(y <= 0 || z >= x);\r\n    }\r\n    function sub(uint x, int y) internal pure returns (uint z) {\r\n        z = x - uint(y);\r\n        require(y <= 0 || z <= x);\r\n        require(y >= 0 || z >= x);\r\n    }\r\n    function mul(uint x, int y) internal pure returns (int z) {\r\n        z = int(x) * y;\r\n        require(int(x) >= 0);\r\n        require(y == 0 || z / y == int(x));\r\n    }\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    \r\n        return c;\r\n      }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"FiFaFarm/SignedSafeMath: subtraction overflow\");\r\n\r\n        return c;\r\n    }\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"FiFaFarm/SignedSafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function toUInt256(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0, \"Integer < 0\");\r\n        return uint256(a);\r\n    }\r\n    constructor() {\r\n        wards[msg.sender] = 1;\r\n    }\r\n    function setover() public auth{\r\n        if (over == 0)  {\r\n            updateReward();\r\n            over = 1;\r\n        }\r\n        else over = 0;\r\n    }\r\n    function setvaluePerBlock(uint256 _valuePerBlock) public auth{\r\n        updateReward();\r\n        valuePerBlock = _valuePerBlock;\r\n    }\r\n    function setlastRewardBlock(uint startblock) external auth {\r\n        lastRewardBlock = startblock;\r\n    }\r\n    function setAddress(address _token,address _lptoken) external auth {\r\n        token = TokenLike(_token);\r\n        lptoken = TokenLike(_lptoken); \r\n    }\r\n    //The pledge LP  \r\n    function deposit(uint _amount) public {\r\n        updateReward();\r\n        lptoken.transferFrom(msg.sender, address(this), _amount);\r\n        UserInfo storage user = userInfo[msg.sender]; \r\n        user.amount = add(user.amount,_amount); \r\n        user.rewardDebt = add(user.rewardDebt,int256(mul(_amount,acclpPerShare) / 1e18));\r\n        uint256[2] memory list = [_amount,block.timestamp];\r\n        user.depositList.push(list); \r\n        emit Deposit(msg.sender,_amount);     \r\n    }\r\n    function depositAll() public {\r\n        uint _amount = lptoken.balanceOf(msg.sender);\r\n        if (_amount == 0) return;\r\n        deposit(_amount);\r\n    }\r\n    //Update mining data\r\n    function updateReward() internal {\r\n        if (over == 1) return;\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint lpSupply = lptoken.balanceOf(address(this));\r\n        if (lpSupply == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 blocks = sub(block.number,lastRewardBlock);\r\n        uint256 lotReward = div(mul(mul(valuePerBlock,blocks),uint(1e18)),lpSupply);\r\n        acclpPerShare = add(acclpPerShare,lotReward);\r\n        lastRewardBlock = block.number; \r\n    }\r\n    //The harvest from mining\r\n    function harvest() public returns (uint256) {\r\n        return harvestForOther(msg.sender);  \r\n    }\r\n    function harvestForOther(address usr) public returns (uint256) {\r\n        updateReward();\r\n        UserInfo storage user = userInfo[usr];\r\n        int256 accumulatedlp = int(mul(user.amount,acclpPerShare) / 1e18);\r\n        uint256 _pendinglp = toUInt256(sub(accumulatedlp,user.rewardDebt));\r\n\r\n        // Effects\r\n        user.rewardDebt = accumulatedlp;\r\n\r\n        // Interactions\r\n        if (_pendinglp != 0) {\r\n            token.transfer(usr, _pendinglp);\r\n            user.harved = add(user.harved,_pendinglp);\r\n            uint256[2] memory list = [_pendinglp,block.timestamp];\r\n            user.harveList.push(list);\r\n        } \r\n        emit Harvest(usr,_pendinglp); \r\n       return  _pendinglp;    \r\n    }\r\n    //Withdrawal pledge currency\r\n    function withdraw(uint256 _amount) public {\r\n        if(_amount ==0) return;\r\n        updateReward();\r\n        UserInfo storage user = userInfo[msg.sender];\r\n        user.rewardDebt = sub(user.rewardDebt,int(mul(_amount,acclpPerShare) / 1e18));\r\n        user.amount = sub(user.amount,_amount);\r\n        lptoken.transfer(msg.sender, _amount);\r\n        uint256[2] memory list = [_amount,block.timestamp];\r\n        user.withdrawList.push(list);\r\n        emit Withdraw(msg.sender,_amount);     \r\n    }\r\n\r\n    function withdrawAll() public {\r\n        UserInfo storage user = userInfo[msg.sender]; \r\n        uint256 _amount = user.amount;\r\n        if (_amount == 0) return;\r\n        withdraw(_amount);\r\n    }\r\n    function getUserInfo(address usr) public view returns (UserInfo memory) {\r\n       return userInfo[usr];\r\n    }\r\n\r\n    //Estimate the harvest\r\n    function beharvest(address usr) public view returns (uint256) {\r\n        uint lpSupply = lptoken.balanceOf(address(this));\r\n        if(lpSupply ==0 || block.number<=lastRewardBlock) return 0;\r\n        uint256 blocks = sub(block.number,lastRewardBlock);\r\n        uint256 lotReward = div(mul(mul(valuePerBlock,blocks),uint(1e18)),lpSupply);\r\n        uint256 _acclpPerShare = add(acclpPerShare,lotReward);\r\n        UserInfo storage user = userInfo[usr];\r\n        int256 accumulatedlp = int(mul(user.amount,_acclpPerShare) / 1e18);\r\n        uint256 _pendinglp = toUInt256(sub(accumulatedlp,user.rewardDebt));\r\n        return _pendinglp;\r\n    }\r\n\r\n    function getCPFarm(address usr) public view returns(CpFarmInfo memory cpFarmInfo){\r\n        UserInfo memory user = userInfo[usr];\r\n        cpFarmInfo.dayAmount = mul(valuePerBlock,uint(28800));\r\n        uint lpSupply = lptoken.balanceOf(address(this));\r\n        if(lpSupply !=0) cpFarmInfo.myAmount = div(mul(mul(valuePerBlock,uint(28800)),user.amount),lpSupply);\r\n        cpFarmInfo.cpBlance = lptoken.balanceOf(usr);\r\n        cpFarmInfo.cpUsed = user.amount;\r\n        cpFarmInfo.beHarve = beharvest(usr);\r\n        cpFarmInfo.harved = user.harved;\r\n        uint length = user.depositList.length;\r\n        cpFarmInfo.depositList = new uint256[2][](length);\r\n        for(uint i=0;i<length;i++){\r\n            cpFarmInfo.depositList[i]=user.depositList[length-1-i];\r\n        }\r\n        uint length1 = user.withdrawList.length;\r\n        cpFarmInfo.withdrawList = new uint256[2][](length1);\r\n        for(uint i=0;i<length1;i++){\r\n            cpFarmInfo.withdrawList[i]=user.withdrawList[length1-1-i];\r\n        }\r\n        uint length2 = user.harveList.length;\r\n        cpFarmInfo.harveList = new uint256[2][](length2);\r\n        for(uint i=0;i<length2;i++){\r\n            cpFarmInfo.harveList[i]=user.harveList[length2-1-i];\r\n        }\r\n    }\r\n    function withdraw(address asses, uint256 amount, address ust) public auth {\r\n        TokenLike(asses).transfer(ust, amount);\r\n    }\r\n }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acclpPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"beharvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"getCPFarm\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"myAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cpBlance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cpUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beHarve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harved\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2][]\",\"name\":\"withdrawList\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"harveList\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"depositList\",\"type\":\"uint256[2][]\"}],\"internalType\":\"struct FiFaCPFarm.CpFarmInfo\",\"name\":\"cpFarmInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rewardDebt\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"harved\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2][]\",\"name\":\"withdrawList\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"harveList\",\"type\":\"uint256[2][]\"},{\"internalType\":\"uint256[2][]\",\"name\":\"depositList\",\"type\":\"uint256[2][]\"}],\"internalType\":\"struct FiFaCPFarm.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"harvestForOther\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lptoken\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"over\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lptoken\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startblock\",\"type\":\"uint256\"}],\"name\":\"setlastRewardBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_valuePerBlock\",\"type\":\"uint256\"}],\"name\":\"setvaluePerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rewardDebt\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"harved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"valuePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asses\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ust\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FiFaCPFarm", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://45e9754609a2f5ba2fe12bdd06088841950fadea8907cd11ac8a7b7821cddd47"}