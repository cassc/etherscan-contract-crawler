{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/SuperPositions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { ERC1155A } from \\\"ERC1155A/ERC1155A.sol\\\";\\nimport { aERC20 } from \\\"ERC1155A/aERC20.sol\\\";\\nimport { ISuperPositions } from \\\"src/interfaces/ISuperPositions.sol\\\";\\nimport { ISuperRegistry } from \\\"src/interfaces/ISuperRegistry.sol\\\";\\nimport { ISuperRBAC } from \\\"src/interfaces/ISuperRBAC.sol\\\";\\nimport { ISuperformFactory } from \\\"src/interfaces/ISuperformFactory.sol\\\";\\nimport { IBaseForm } from \\\"src/interfaces/IBaseForm.sol\\\";\\nimport { IBroadcastRegistry } from \\\"./interfaces/IBroadcastRegistry.sol\\\";\\nimport { IPaymentHelper } from \\\"./interfaces/IPaymentHelper.sol\\\";\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\nimport { DataLib } from \\\"src/libraries/DataLib.sol\\\";\\nimport {\\n    TransactionType,\\n    ReturnMultiData,\\n    ReturnSingleData,\\n    CallbackType,\\n    AMBMessage,\\n    BroadcastMessage\\n} from \\\"src/types/DataTypes.sol\\\";\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title SuperPositions\\n/// @dev Cross-chain LP token minted on source chain\\n/// @author Zeropoint Labs\\ncontract SuperPositions is ISuperPositions, ERC1155A {\\n    using DataLib for uint256;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    ISuperRegistry public immutable superRegistry;\\n    uint64 public immutable CHAIN_ID;\\n    uint8 internal constant CORE_STATE_REGISTRY_ID = 1;\\n    bytes32 internal constant DEPLOY_NEW_AERC20 = keccak256(\\\"DEPLOY_NEW_AERC20\\\");\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev maps all transaction data routed through the smart contract.\\n    mapping(uint256 transactionId => TxHistory txHistory) public override txHistory;\\n\\n    /// @dev is the base uri set by admin\\n    string public dynamicURI;\\n\\n    /// @dev is the base uri frozen status\\n    bool public dynamicURIFrozen;\\n\\n    /// @dev nonce for aERC20 broadcast\\n    uint256 public xChainPayloadCounter;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    modifier onlyRouter() {\\n        if (msg.sender != superRegistry.getAddress(keccak256(\\\"SUPERFORM_ROUTER\\\"))) revert Error.NOT_SUPERFORM_ROUTER();\\n        _;\\n    }\\n\\n    modifier onlyProtocolAdmin() {\\n        if (!ISuperRBAC(superRegistry.getAddress(keccak256(\\\"SUPER_RBAC\\\"))).hasProtocolAdminRole(msg.sender)) {\\n            revert Error.NOT_PROTOCOL_ADMIN();\\n        }\\n        _;\\n    }\\n\\n    /// @dev is used in same chain case (as superform is available on the chain to validate caller)\\n    modifier onlyMinter(uint256 superformId) {\\n        address router = superRegistry.getAddress(keccak256(\\\"SUPERFORM_ROUTER\\\"));\\n\\n        /// if msg.sender isn't superformRouter then it must be state registry of that form\\n        if (msg.sender != router) {\\n            uint8 registryId = superRegistry.getStateRegistryId(msg.sender);\\n\\n            (address superform,,) = DataLib.getSuperform(superformId);\\n            uint8 formRegistryId = IBaseForm(superform).getStateRegistryId();\\n\\n            if (registryId != formRegistryId) {\\n                revert Error.NOT_MINTER();\\n            }\\n        }\\n\\n        _;\\n    }\\n\\n    modifier onlyBroadcastRegistry() {\\n        if (msg.sender != superRegistry.getAddress(keccak256(\\\"BROADCAST_REGISTRY\\\"))) {\\n            revert Error.NOT_BROADCAST_REGISTRY();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyBatchMinter(uint256[] memory superformIds) {\\n        address router = superRegistry.getAddress(keccak256(\\\"SUPERFORM_ROUTER\\\"));\\n\\n        /// if msg.sender isn't superformRouter then it must be state registry for that superform\\n        if (msg.sender != router) {\\n            uint256 len = superformIds.length;\\n            for (uint256 i; i < len; ++i) {\\n                (, uint32 formImplementationId,) = DataLib.getSuperform(superformIds[i]);\\n                uint8 registryId = superRegistry.getStateRegistryId(msg.sender);\\n\\n                if (uint32(registryId) != formImplementationId) {\\n                    revert Error.NOT_MINTER();\\n                }\\n            }\\n        }\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @param dynamicURI_  URL for external metadata of ERC1155 SuperPositions\\n    /// @param superRegistry_ the superform registry contract\\n    constructor(string memory dynamicURI_, address superRegistry_) {\\n        if (block.chainid > type(uint64).max) {\\n            revert Error.BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n        }\\n\\n        CHAIN_ID = uint64(block.chainid);\\n\\n        superRegistry = ISuperRegistry(superRegistry_);\\n        dynamicURI = dynamicURI_;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ERC1155A\\n    function supportsInterface(bytes4 interfaceId_) public view virtual override(ERC1155A, IERC165) returns (bool) {\\n        return super.supportsInterface(interfaceId_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @inheritdoc ISuperPositions\\n    function updateTxHistory(\\n        uint256 payloadId_,\\n        uint256 txInfo_,\\n        address receiverAddressSP_\\n    )\\n        external\\n        override\\n        onlyRouter\\n    {\\n        txHistory[payloadId_] = TxHistory({ txInfo: txInfo_, receiverAddressSP: receiverAddressSP_ });\\n\\n        emit TxHistorySet(payloadId_, txInfo_, receiverAddressSP_);\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function mintSingle(address receiverAddressSP_, uint256 id_, uint256 amount_) external override onlyMinter(id_) {\\n        _mint(receiverAddressSP_, msg.sender, id_, amount_, \\\"\\\");\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function mintBatch(\\n        address receiverAddressSP_,\\n        uint256[] memory ids_,\\n        uint256[] memory amounts_\\n    )\\n        external\\n        override\\n        onlyBatchMinter(ids_)\\n    {\\n        if (ids_.length != amounts_.length) revert Error.ARRAY_LENGTH_MISMATCH();\\n        _batchMint(receiverAddressSP_, msg.sender, ids_, amounts_, \\\"\\\");\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function burnSingle(address srcSender_, uint256 id_, uint256 amount_) external override onlyRouter {\\n        _burn(srcSender_, msg.sender, id_, amount_);\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function burnBatch(\\n        address srcSender_,\\n        uint256[] memory ids_,\\n        uint256[] memory amounts_\\n    )\\n        external\\n        override\\n        onlyRouter\\n    {\\n        if (ids_.length != amounts_.length) revert Error.ARRAY_LENGTH_MISMATCH();\\n        _batchBurn(srcSender_, msg.sender, ids_, amounts_);\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function stateMultiSync(AMBMessage memory data_) external override returns (uint64 srcChainId_) {\\n        /// @dev here we decode the txInfo and params from the data brought back from destination\\n\\n        (uint256 returnTxType, uint256 callbackType, uint8 multi,,,) = data_.txInfo.decodeTxInfo();\\n\\n        if (callbackType != uint256(CallbackType.RETURN) && callbackType != uint256(CallbackType.FAIL)) {\\n            revert Error.INVALID_PAYLOAD_TYPE();\\n        }\\n\\n        /// @dev decode remaining info on superPositions to mint from destination\\n        ReturnMultiData memory returnData = abi.decode(data_.params, (ReturnMultiData));\\n\\n        _validateStateSyncer(returnData.superformIds);\\n\\n        uint256 txInfo = txHistory[returnData.payloadId].txInfo;\\n\\n        /// @dev if txInfo is zero then the payloadId is invalid for ack\\n        if (txInfo == 0) {\\n            revert Error.TX_HISTORY_NOT_FOUND();\\n        }\\n\\n        uint256 txType;\\n\\n        /// @dev decode initial payload info stored on source chain in this contract\\n        (txType,,,,, srcChainId_) = txInfo.decodeTxInfo();\\n\\n        /// @dev verify this is a not single vault mint\\n        if (multi != 1) revert Error.INVALID_PAYLOAD_TYPE();\\n        /// @dev compare txType to be the same (dst/src)\\n        if (returnTxType != txType) revert Error.SRC_TX_TYPE_MISMATCH();\\n\\n        /// @dev mint super positions accordingly\\n        if (\\n            (txType == uint256(TransactionType.DEPOSIT) && callbackType == uint256(CallbackType.RETURN))\\n                || (txType == uint256(TransactionType.WITHDRAW) && callbackType == uint256(CallbackType.FAIL))\\n        ) {\\n            _batchMint(\\n                txHistory[returnData.payloadId].receiverAddressSP,\\n                msg.sender,\\n                returnData.superformIds,\\n                returnData.amounts,\\n                \\\"\\\"\\n            );\\n        } else {\\n            revert Error.INVALID_PAYLOAD_TYPE();\\n        }\\n\\n        emit Completed(returnData.payloadId);\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function stateSync(AMBMessage memory data_) external override returns (uint64 srcChainId_) {\\n        /// @dev here we decode the txInfo and params from the data brought back from destination\\n\\n        (uint256 returnTxType, uint256 callbackType, uint8 multi,,,) = data_.txInfo.decodeTxInfo();\\n\\n        if (callbackType != uint256(CallbackType.RETURN) && callbackType != uint256(CallbackType.FAIL)) {\\n            revert Error.INVALID_PAYLOAD_TYPE();\\n        }\\n\\n        /// @dev decode remaining info on superPositions to mint from destination\\n        ReturnSingleData memory returnData = abi.decode(data_.params, (ReturnSingleData));\\n        _validateStateSyncer(returnData.superformId);\\n\\n        uint256 txInfo = txHistory[returnData.payloadId].txInfo;\\n\\n        /// @dev if txInfo is zero then the payloadId is invalid for ack\\n        if (txInfo == 0) {\\n            revert Error.TX_HISTORY_NOT_FOUND();\\n        }\\n\\n        uint256 txType;\\n\\n        /// @dev decode initial payload info stored on source chain in this contract\\n        (txType,,,,, srcChainId_) = txInfo.decodeTxInfo();\\n\\n        /// @dev this is a not multi vault mint\\n        if (multi != 0) revert Error.INVALID_PAYLOAD_TYPE();\\n        /// @dev compare txType to be the same (dst/src)\\n        if (returnTxType != txType) revert Error.SRC_TX_TYPE_MISMATCH();\\n\\n        /// @dev mint super positions accordingly\\n        if (\\n            (txType == uint256(TransactionType.DEPOSIT) && callbackType == uint256(CallbackType.RETURN))\\n                || (txType == uint256(TransactionType.WITHDRAW) && callbackType == uint256(CallbackType.FAIL))\\n        ) {\\n            _mint(\\n                txHistory[returnData.payloadId].receiverAddressSP,\\n                msg.sender,\\n                returnData.superformId,\\n                returnData.amount,\\n                \\\"\\\"\\n            );\\n        } else {\\n            revert Error.INVALID_PAYLOAD_TYPE();\\n        }\\n\\n        emit Completed(returnData.payloadId);\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function stateSyncBroadcast(bytes memory data_) external payable override onlyBroadcastRegistry {\\n        BroadcastMessage memory transmuterPayload = abi.decode(data_, (BroadcastMessage));\\n\\n        if (transmuterPayload.messageType != DEPLOY_NEW_AERC20) {\\n            revert Error.INVALID_MESSAGE_TYPE();\\n        }\\n        _deployTransmuter(transmuterPayload.message);\\n    }\\n\\n    /// @inheritdoc ISuperPositions\\n    function setDynamicURI(string memory dynamicURI_, bool freeze_) external override onlyProtocolAdmin {\\n        if (dynamicURIFrozen) {\\n            revert Error.DYNAMIC_URI_FROZEN();\\n        }\\n\\n        string memory oldURI = dynamicURI;\\n        dynamicURI = dynamicURI_;\\n        dynamicURIFrozen = freeze_;\\n\\n        emit DynamicURIUpdated(oldURI, dynamicURI_, freeze_);\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice Used to construct return url\\n    function _baseURI() internal view override returns (string memory) {\\n        return dynamicURI;\\n    }\\n\\n    /// @dev helps validate the state registry id for minting superform id\\n    /// @dev is used in cross chain case (as superform is not available on the chain to validate caller)\\n    function _validateStateSyncer(uint256 superformId_) internal view {\\n        uint8 registryId = superRegistry.getStateRegistryId(msg.sender);\\n        _isValidStateSyncer(registryId, superformId_);\\n    }\\n\\n    /// @dev helps validate the state registry id for minting superform id\\n    function _validateStateSyncer(uint256[] memory superformIds_) internal view {\\n        uint8 registryId = superRegistry.getStateRegistryId(msg.sender);\\n        for (uint256 i; i < superformIds_.length; ++i) {\\n            _isValidStateSyncer(registryId, superformIds_[i]);\\n        }\\n    }\\n\\n    function _isValidStateSyncer(uint8 registryId_, uint256 superformId_) internal view {\\n        /// @dev registryId_ zero check is done in superRegistry.getStateRegistryId()\\n\\n        /// @dev If registryId is 1, meaning CoreStateRegistry, no further checks are necessary.\\n        /// @dev This is because CoreStateRegistry is the default minter for all kinds of forms\\n        /// @dev In case registryId is > 1, we need to check if the registryId matches the formImplementationId\\n        if (registryId_ == CORE_STATE_REGISTRY_ID) {\\n            return;\\n        }\\n\\n        (, uint32 formImplementationId,) = DataLib.getSuperform(superformId_);\\n        uint8 formRegistryId = ISuperformFactory(superRegistry.getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\")))\\n            .getFormStateRegistryId(formImplementationId);\\n\\n        if (registryId_ != formRegistryId) {\\n            revert Error.NOT_MINTER_STATE_REGISTRY_ROLE();\\n        }\\n    }\\n\\n    function _registerAERC20(uint256 id) internal override returns (address aErc20Token) {\\n        if (!ISuperformFactory(superRegistry.getAddress(keccak256(\\\"SUPERFORM_FACTORY\\\"))).isSuperform(id)) {\\n            revert Error.SUPERFORM_ID_NONEXISTENT();\\n        }\\n        (address superform,,) = id.getSuperform();\\n\\n        string memory name = string.concat(\\\"SuperPositions AERC20 \\\", IBaseForm(superform).superformYieldTokenName());\\n        string memory symbol = string.concat(\\\"aERC20-\\\", IBaseForm(superform).superformYieldTokenSymbol());\\n        uint8 decimal = uint8(IBaseForm(superform).getVaultDecimals());\\n        aErc20Token = address(new aERC20(name, symbol, decimal));\\n        /// @dev broadcast and deploy to the other destination chains\\n        BroadcastMessage memory transmuterPayload = BroadcastMessage(\\n            \\\"SUPER_POSITIONS\\\",\\n            DEPLOY_NEW_AERC20,\\n            abi.encode(CHAIN_ID, ++xChainPayloadCounter, id, name, symbol, decimal)\\n        );\\n\\n        _broadcast(abi.encode(transmuterPayload));\\n\\n        emit AERC20TokenRegistered(id, aErc20Token);\\n\\n        return aErc20Token;\\n    }\\n\\n    /// @dev interacts with broadcast state registry to broadcasting state changes to all connected remote chains\\n    /// @param message_ is the crosschain message to be sent.\\n    function _broadcast(bytes memory message_) internal {\\n        bytes memory registerTransmuterAMBData =\\n            IPaymentHelper(superRegistry.getAddress(keccak256(\\\"PAYMENT_HELPER\\\"))).getRegisterTransmuterAMBData();\\n\\n        (uint8 ambId, bytes memory broadcastParams) = abi.decode(registerTransmuterAMBData, (uint8, bytes));\\n\\n        /// @dev if the broadcastParams are wrong this will revert\\n        (uint256 gasFee, bytes memory extraData) = abi.decode(broadcastParams, (uint256, bytes));\\n\\n        if (msg.value < gasFee) {\\n            revert Error.INVALID_BROADCAST_FEE();\\n        }\\n\\n        /// @dev ambIds are validated inside the broadcast state registry\\n        IBroadcastRegistry(superRegistry.getAddress(keccak256(\\\"BROADCAST_REGISTRY\\\"))).broadcastPayload{ value: gasFee }(\\n            msg.sender, ambId, gasFee, message_, extraData\\n        );\\n\\n        if (msg.value > gasFee) {\\n            /// @dev forwards the rest to msg.sender\\n            (bool success,) = payable(msg.sender).call{ value: msg.value - gasFee }(\\\"\\\");\\n\\n            if (!success) {\\n                revert Error.FAILED_TO_SEND_NATIVE();\\n            }\\n        }\\n    }\\n\\n    /// @dev deploys new transmuter on broadcasting\\n    function _deployTransmuter(bytes memory message_) internal {\\n        (,, uint256 superformId, string memory name, string memory symbol, uint8 decimal) =\\n            abi.decode(message_, (uint64, uint256, uint256, string, string, uint8));\\n        if (aErc20TokenId[superformId] != address(0)) revert AERC20_ALREADY_REGISTERED();\\n\\n        address aErc20Token = address(new aERC20(name, symbol, decimal));\\n\\n        aErc20TokenId[superformId] = aErc20Token;\\n\\n        emit AERC20TokenRegistered(superformId, aErc20Token);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/src/ERC1155A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC1155A } from \\\"./interfaces/IERC1155A.sol\\\";\\nimport { IaERC20 } from \\\"./interfaces/IaERC20.sol\\\";\\nimport { Strings } from \\\"openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\nimport { IERC165 } from \\\"openzeppelin-contracts/contracts/interfaces/IERC165.sol\\\";\\nimport { IERC1155 } from \\\"openzeppelin-contracts/contracts/interfaces/IERC1155.sol\\\";\\nimport { IERC1155MetadataURI } from \\\"openzeppelin-contracts/contracts/interfaces/IERC1155MetadataURI.sol\\\";\\nimport { IERC1155Errors } from \\\"openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol\\\";\\nimport { IERC1155Receiver } from \\\"openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/// @title ERC1155A\\n/// @dev Single/range based id approve capability with conversion to ERC20s\\n/// @author Zeropoint Labs\\nabstract contract ERC1155A is IERC1155A, IERC1155Errors {\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    bytes private constant EMPTY_BYTES = bytes(\\\"\\\");\\n\\n    //////////////////////////////////////////////////////////////\\n    //                     STATE VARIABLES                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev ERC20-like mapping for single id supply.\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /// @dev ERC20-like mapping for single id approvals.\\n    mapping(address owner => mapping(address operator => mapping(uint256 id => uint256 amount))) private allowances;\\n\\n    /// @dev Implementation copied from solmate/ERC1155\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    /// @dev Implementation copied from solmate/ERC1155\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /// @dev mapping of token ids to aErc20 token addresses\\n    mapping(uint256 id => address aErc20Token) public aErc20TokenId;\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    // Basic Token Information\\n    // --------------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function totalSupply(uint256 id) external view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function exists(uint256 id) external view virtual returns (bool) {\\n        return _totalSupply[id] != 0;\\n    }\\n\\n    /// @inheritdoc IERC1155\\n    function balanceOfBatch(\\n        address[] memory owners,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        if (owners.length != ids.length) revert LENGTH_MISMATCH();\\n\\n        balances = new uint256[](owners.length);\\n\\n        for (uint256 i; i < owners.length; ++i) {\\n            balances[i] = balanceOf[owners[i]][ids[i]];\\n        }\\n    }\\n\\n    // Allowance and Approval Checking\\n    // --------------------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function allowance(address owner, address operator, uint256 id) public view virtual returns (uint256) {\\n        return allowances[owner][operator][id];\\n    }\\n\\n    // aERC20 Token Management\\n    // ------------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function aERC20Exists(uint256 id) external view virtual returns (bool) {\\n        return aErc20TokenId[id] != address(0);\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function getERC20TokenAddress(uint256 id) external view virtual override returns (address) {\\n        return aErc20TokenId[id];\\n    }\\n\\n    // Metadata and Interface Support\\n    // ------------------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function uri(uint256 id) public view virtual returns (string memory) {\\n        return string.concat(_baseURI(), Strings.toString(id));\\n    }\\n\\n    /// @dev return interface checks\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId // ERC165 Interface ID for ERC165\\n            || interfaceId == type(IERC1155).interfaceId // ERC165 Interface ID for ERC1155\\n            || interfaceId == type(IERC1155MetadataURI).interfaceId; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    // Token Approval Management\\n    // --------------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function setApprovalForOne(address operator, uint256 id, uint256 amount) public virtual {\\n        _setAllowance(msg.sender, operator, id, amount, true);\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function setApprovalForMany(address operator, uint256[] memory ids, uint256[] memory amounts) public virtual {\\n        uint256 idsLength = ids.length;\\n        if (idsLength != amounts.length) revert LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < idsLength; ++i) {\\n            _setAllowance(msg.sender, operator, ids[i], amounts[i], true);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC1155\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        if (operator == address(0)) revert ZERO_ADDRESS();\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    // Allowance Modification\\n    // -----------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function increaseAllowance(address operator, uint256 id, uint256 addedValue) public virtual returns (bool) {\\n        _setAllowance(msg.sender, operator, id, allowance(msg.sender, operator, id) + addedValue, true);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function decreaseAllowance(address operator, uint256 id, uint256 subtractedValue) public virtual returns (bool) {\\n        return _decreaseAllowance(msg.sender, operator, id, subtractedValue, true);\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function increaseAllowanceForMany(\\n        address operator,\\n        uint256[] memory ids,\\n        uint256[] memory addedValues\\n    )\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 idsLength = ids.length;\\n        if (idsLength != addedValues.length) revert LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < idsLength; ++i) {\\n            _setAllowance(msg.sender, operator, ids[i], allowance(msg.sender, operator, ids[i]) + addedValues[i], true);\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function decreaseAllowanceForMany(\\n        address operator,\\n        uint256[] memory ids,\\n        uint256[] memory subtractedValues\\n    )\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 idsLength = ids.length;\\n        if (idsLength != subtractedValues.length) revert LENGTH_MISMATCH();\\n\\n        for (uint256 i; i < idsLength; ++i) {\\n            _decreaseAllowance(msg.sender, operator, ids[i], subtractedValues[i], true);\\n        }\\n\\n        return true;\\n    }\\n\\n    // Token Transfer Functions\\n    // -------------------------\\n\\n    /// @notice see {IERC1155-safeTransferFrom}\\n    /// @dev adds supports for user to not have called setApprovalForAll\\n    /// @dev single id approval is senior in execution flow\\n    /// @dev if approved for all, function executes without reducing allowance\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        if (from == address(0) || to == address(0)) revert ZERO_ADDRESS();\\n\\n        address operator = msg.sender;\\n\\n        /// @dev message sender is not from and is not approved for all\\n        if (from != operator && !isApprovedForAll[from][operator]) {\\n            _decreaseAllowance(from, operator, id, amount, false);\\n            _safeTransferFrom(from, to, id, amount);\\n        } else {\\n            /// @dev message sender is from || is approved for all\\n            _safeTransferFrom(from, to, id, amount);\\n        }\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /// @notice see {IERC1155-safeBatchTransferFrom}\\n    /// @dev adds supports for user to not have called setApprovalForAll\\n    /// @dev single id approvals are senior in execution flow\\n    /// @dev if approved for all, function executes without reducing allowance\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        if (from == address(0) || to == address(0)) revert ZERO_ADDRESS();\\n\\n        uint256 len = ids.length;\\n        if (len != amounts.length) revert LENGTH_MISMATCH();\\n\\n        address operator = msg.sender;\\n\\n        /// @dev case to handle single id / multi id approvals\\n        if (operator != from && !isApprovedForAll[from][operator]) {\\n            uint256 id;\\n            uint256 amount;\\n\\n            for (uint256 i; i < len; ++i) {\\n                id = ids[i];\\n                amount = amounts[i];\\n\\n                _decreaseAllowance(from, operator, id, amount, false);\\n                _safeTransferFrom(from, to, id, amount);\\n            }\\n        } else {\\n            for (uint256 i; i < len; ++i) {\\n                _safeTransferFrom(from, to, ids[i], amounts[i]);\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    // Token Transmutation\\n    // --------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function transmuteToERC20(address owner, uint256 id, uint256 amount, address receiver) external override {\\n        if (owner == address(0) || receiver == address(0)) revert ZERO_ADDRESS();\\n        /// @dev an approval is needed to burn\\n        _burn(owner, msg.sender, id, amount);\\n\\n        address aERC20Token = aErc20TokenId[id];\\n        if (aERC20Token == address(0)) revert AERC20_NOT_REGISTERED();\\n\\n        IaERC20(aERC20Token).mint(receiver, amount);\\n        emit TransmutedToERC20(owner, id, amount, receiver);\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function transmuteToERC1155A(address owner, uint256 id, uint256 amount, address receiver) external override {\\n        if (owner == address(0) || receiver == address(0)) revert ZERO_ADDRESS();\\n\\n        address aERC20Token = aErc20TokenId[id];\\n        if (aERC20Token == address(0)) revert AERC20_NOT_REGISTERED();\\n\\n        /// @dev an approval is needed to burn\\n        IaERC20(aERC20Token).burn(owner, msg.sender, amount);\\n        _mint(receiver, msg.sender, id, amount, EMPTY_BYTES);\\n\\n        emit TransmutedToERC1155A(owner, id, amount, receiver);\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function transmuteBatchToERC20(\\n        address owner,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        address receiver\\n    )\\n        external\\n        override\\n    {\\n        if (owner == address(0) || receiver == address(0)) revert ZERO_ADDRESS();\\n\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n        if (idsLength != amounts.length) revert LENGTH_MISMATCH();\\n\\n        /// @dev an approval is needed to burn\\n        _batchBurn(owner, msg.sender, ids, amounts);\\n\\n        for (uint256 i; i < idsLength; ++i) {\\n            address aERC20Token = aErc20TokenId[ids[i]];\\n            if (aERC20Token == address(0)) revert AERC20_NOT_REGISTERED();\\n\\n            IaERC20(aERC20Token).mint(receiver, amounts[i]);\\n        }\\n\\n        emit TransmutedBatchToERC20(owner, ids, amounts, receiver);\\n    }\\n\\n    /// @inheritdoc IERC1155A\\n    function transmuteBatchToERC1155A(\\n        address owner,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        address receiver\\n    )\\n        external\\n        override\\n    {\\n        if (owner == address(0) || receiver == address(0)) revert ZERO_ADDRESS();\\n\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n        if (idsLength != amounts.length) revert LENGTH_MISMATCH();\\n\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i; i < ids.length; ++i) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            address aERC20Token = aErc20TokenId[id];\\n            if (aERC20Token == address(0)) revert AERC20_NOT_REGISTERED();\\n            /// @dev an approval is needed on each aERC20 to burn\\n            IaERC20(aERC20Token).burn(owner, msg.sender, amount);\\n        }\\n\\n        _batchMint(receiver, msg.sender, ids, amounts, EMPTY_BYTES);\\n\\n        emit TransmutedBatchToERC1155A(owner, ids, amounts, receiver);\\n    }\\n\\n    // aERC20 Registration\\n    // --------------------\\n\\n    /// @inheritdoc IERC1155A\\n    function registerAERC20(uint256 id) external payable override returns (address) {\\n        if (_totalSupply[id] == 0) revert ID_NOT_MINTED_YET();\\n        if (aErc20TokenId[id] != address(0)) revert AERC20_ALREADY_REGISTERED();\\n\\n        address aErc20Token = _registerAERC20(id);\\n\\n        aErc20TokenId[id] = aErc20Token;\\n        return aErc20TokenId[id];\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INTERNAL FUNCTIONS                      //\\n    //////////////////////////////////////////////////////////////\\n\\n    // Token Transfer and Balance Management\\n    // --------------------------------------\\n\\n    /// @notice Internal safeTranferFrom function called after all checks from the public function are done\\n    /// @dev Notice `operator` param. It's msg.sender to the safeTransferFrom function. Function is specific to\\n    /// @dev singleId approve logic.\\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 amount) internal virtual {\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n    }\\n\\n    /// @dev Implementation copied from solmate/ERC1155 and adapted with operator logic\\n    function _mint(address to, address operator, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        balanceOf[to][id] += amount;\\n        _totalSupply[id] += amount;\\n\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /// @dev Implementation copied from solmate/ERC1155 and adapted with operator logic\\n    function _batchMint(\\n        address to,\\n        address operator,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n    {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n        if (idsLength != amounts.length) revert LENGTH_MISMATCH();\\n\\n        uint256 id;\\n        uint256 amount;\\n        for (uint256 i; i < idsLength; ++i) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[to][id] += amount;\\n            _totalSupply[id] += amount;\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /// @dev Implementation copied from solmate/ERC1155 and adapted with operator logic\\n    function _burn(address from, address operator, uint256 id, uint256 amount) internal virtual {\\n        // Check if the msg.sender is the owner or is approved for all tokens\\n        /// Most implementations of _burn don't use allowance, but it is a good practice to check for it\\n        /// Otherwise it could allow to burn tokens on which no explicit allowance is given\\n        if (operator != from && !isApprovedForAll[from][operator]) {\\n            _decreaseAllowance(from, operator, id, amount, false);\\n        }\\n\\n        // Update the balances and total supply\\n        _safeTransferFrom(from, address(0), id, amount);\\n        _totalSupply[id] -= amount;\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n    }\\n\\n    /// @dev Implementation copied from solmate/ERC1155 and adapted with operator logic\\n    function _batchBurn(\\n        address from,\\n        address operator,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    )\\n        internal\\n        virtual\\n    {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n        if (idsLength != amounts.length) revert LENGTH_MISMATCH();\\n\\n        uint256 id;\\n        uint256 amount;\\n        /// @dev case to handle single id / multi id approvals\\n        if (operator != from && !isApprovedForAll[from][operator]) {\\n            for (uint256 i; i < idsLength; ++i) {\\n                id = ids[i];\\n                amount = amounts[i];\\n\\n                _decreaseAllowance(from, operator, id, amount, false);\\n                _safeTransferFrom(from, address(0), id, amount);\\n                _totalSupply[ids[i]] -= amounts[i];\\n            }\\n        } else {\\n            for (uint256 i; i < idsLength; ++i) {\\n                id = ids[i];\\n                amount = amounts[i];\\n\\n                _safeTransferFrom(from, address(0), id, amount);\\n                _totalSupply[ids[i]] -= amounts[i];\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n    }\\n\\n    // Allowance and Approval Handling\\n    // --------------------------------\\n\\n    /// @notice Internal function for decreasing single id approval amount\\n    /// @dev Only to be used by address(this)\\n    /// @dev Notice `owner` param, only contract functions should be able to define it\\n    /// @dev Re-adapted from ERC20\\n    function _decreaseAllowance(\\n        address owner,\\n        address operator,\\n        uint256 id,\\n        uint256 subtractedValue,\\n        bool emitEvent\\n    )\\n        internal\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = allowance(owner, operator, id);\\n        if (currentAllowance < subtractedValue) revert DECREASED_ALLOWANCE_BELOW_ZERO();\\n        _setAllowance(owner, operator, id, currentAllowance - subtractedValue, emitEvent);\\n\\n        return true;\\n    }\\n\\n    /// @notice Internal function for setting single id approval\\n    /// @dev Used for fine-grained control over approvals with increase/decrease allowance\\n    /// @dev Notice `owner` param, only contract functions should be able to define it\\n    function _setAllowance(\\n        address owner,\\n        address operator,\\n        uint256 id,\\n        uint256 amount,\\n        bool emitEvent\\n    )\\n        internal\\n        virtual\\n    {\\n        if (owner == address(0)) revert ZERO_ADDRESS();\\n        if (operator == address(0)) revert ZERO_ADDRESS();\\n\\n        allowances[owner][operator][id] = amount;\\n\\n        if (emitEvent) {\\n            emit ApprovalForOne(owner, operator, id, amount);\\n        }\\n    }\\n\\n    // ERC1155A Transfer Checks\\n    // ------------------------\\n\\n    /// @dev Implementation copied from openzeppelin-contracts/ERC1155 with new custom error logic\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.code.length != 0) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    // Tokens rejected\\n                    revert ERC1155InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-ERC1155Receiver implementer\\n                    revert ERC1155InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            if (to == address(0)) revert TRANSFER_TO_ADDRESS_ZERO();\\n        }\\n    }\\n\\n    /// @dev Implementation copied from openzeppelin-contracts/ERC1155 with new custom error logic  and revert on\\n    /// transfer to address 0\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.code.length != 0) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) returns (bytes4 response)\\n            {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    // Tokens rejected\\n                    revert ERC1155InvalidReceiver(to);\\n                }\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    // non-ERC1155Receiver implementer\\n                    revert ERC1155InvalidReceiver(to);\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            if (to == address(0)) revert TRANSFER_TO_ADDRESS_ZERO();\\n        }\\n    }\\n\\n    // aERC20 Token Creation\\n    // ----------------------\\n\\n    /// @dev allows a developer to integrate their logic to create an aERC20\\n    function _registerAERC20(uint256 id) internal virtual returns (address aErc20Token);\\n\\n    // Metadata and URI Handling\\n    // --------------------------\\n\\n    /// @dev Used to construct return url\\n    function _baseURI() internal view virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/src/aERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IaERC20 } from \\\"./interfaces/IaERC20.sol\\\";\\nimport { ERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/// @title aERC20\\n/// @dev ERC20 tokens out of 1155A\\n/// @author Zeropoint Labs\\ncontract aERC20 is ERC20, IaERC20 {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    address public immutable ERC1155A;\\n    uint8 private immutable TOKEN_DECIMALS;\\n\\n    //////////////////////////////////////////////////////////////\\n    //                       MODIFIERS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    modifier onlyTokenTransmuter() {\\n        if (msg.sender != ERC1155A) {\\n            revert ONLY_ERC1155A();\\n        }\\n        _;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                      CONSTRUCTOR                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\\n        ERC1155A = msg.sender;\\n        TOKEN_DECIMALS = decimals_;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// inheritdoc IaERC20\\n    function decimals() public view override returns (uint8) {\\n        return TOKEN_DECIMALS;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// inheritdoc IaERC20\\n    function mint(address owner, uint256 amount) external override onlyTokenTransmuter {\\n        _mint(owner, amount);\\n    }\\n\\n    /// inheritdoc IaERC20\\n    function burn(address owner, address operator, uint256 amount) external override onlyTokenTransmuter {\\n        if (owner != operator) _spendAllowance(owner, operator, amount);\\n\\n        _burn(owner, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperPositions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IERC1155A } from \\\"ERC1155A/interfaces/IERC1155A.sol\\\";\\nimport { AMBMessage } from \\\"../types/DataTypes.sol\\\";\\n\\n/// @title ISuperPositions\\n/// @dev Interface for SuperPositions\\n/// @author Zeropoint Labs\\ninterface ISuperPositions is IERC1155A {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct TxHistory {\\n        uint256 txInfo;\\n        address receiverAddressSP;\\n    }\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when a dynamic uri is updated\\n    event DynamicURIUpdated(string indexed oldURI, string indexed newURI, bool indexed frozen);\\n\\n    /// @dev is emitted when a cross-chain transaction is completed.\\n    event Completed(uint256 indexed txId);\\n\\n    /// @dev is emitted when a aErc20 token is registered\\n    event AERC20TokenRegistered(uint256 indexed tokenId, address indexed tokenAddress);\\n\\n    /// @dev is emitted when a tx info is saved\\n    event TxHistorySet(uint256 indexed payloadId, uint256 txInfo, address indexed receiverAddress);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the payload header and the receiver address for a tx id on the source chain\\n    /// @param txId_ is the identifier of the transaction issued by superform router\\n    /// @return txInfo is the header of the payload\\n    /// @return receiverAddressSP is the address of the receiver of superPositions\\n    function txHistory(uint256 txId_) external view returns (uint256 txInfo, address receiverAddressSP);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev saves the message being sent together with the associated id formulated in a router\\n    /// @param payloadId_ is the id of the message being saved\\n    /// @param txInfo_ is the header of the AMBMessage of the transaction being saved\\n    /// @param receiverAddressSP_ is the address of the receiver of superPositions\\n    function updateTxHistory(uint256 payloadId_, uint256 txInfo_, address receiverAddressSP_) external;\\n\\n    /// @dev allows minter to mint shares on source\\n    /// @param receiverAddress_ is the beneficiary of shares\\n    /// @param id_ is the id of the shares\\n    /// @param amount_ is the amount of shares to mint\\n    function mintSingle(address receiverAddress_, uint256 id_, uint256 amount_) external;\\n\\n    /// @dev allows minter to mint shares on source in batch\\n    /// @param receiverAddress_ is the beneficiary of shares\\n    /// @param ids_ are the ids of the shares\\n    /// @param amounts_ are the amounts of shares to mint\\n    function mintBatch(address receiverAddress_, uint256[] memory ids_, uint256[] memory amounts_) external;\\n\\n    /// @dev allows superformRouter to burn shares on source\\n    /// @notice burn is done optimistically by the router in the beginning of the withdraw transactions\\n    /// @notice in case the withdraw tx fails on the destination, shares are reminted through stateSync\\n    /// @param srcSender_ is the address of the sender\\n    /// @param id_ is the id of the shares\\n    /// @param amount_ is the amount of shares to burn\\n    function burnSingle(address srcSender_, uint256 id_, uint256 amount_) external;\\n\\n    /// @dev allows burner to burn shares on source in batch\\n    /// @param srcSender_ is the address of the sender\\n    /// @param ids_ are the ids of the shares\\n    /// @param amounts_ are the amounts of shares to burn\\n    function burnBatch(address srcSender_, uint256[] memory ids_, uint256[] memory amounts_) external;\\n\\n    /// @dev allows state registry contract to mint shares on source\\n    /// @param data_ is the received information to be processed.\\n    /// @return srcChainId_ is the decoded srcChainId.\\n    function stateMultiSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\\n\\n    /// @dev allows state registry contract to mint shares on source\\n    /// @param data_ is the received information to be processed.\\n    /// @return srcChainId_ is the decoded srcChainId.\\n    function stateSync(AMBMessage memory data_) external returns (uint64 srcChainId_);\\n\\n    /// @dev sets the dynamic uri for NFT\\n    /// @param dynamicURI_ is the dynamic uri of the NFT\\n    /// @param freeze_ is to prevent updating the metadata once migrated to IPFS\\n    function setDynamicURI(string memory dynamicURI_, bool freeze_) external;\\n\\n    /// @dev allows to create sERC0 using broadcast state registry\\n    /// @param data_ is the crosschain payload\\n    function stateSyncBroadcast(bytes memory data_) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperRegistry\\n/// @dev Interface for SuperRegistry\\n/// @author Zeropoint Labs\\ninterface ISuperRegistry {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when permit2 is set.\\n    event SetPermit2(address indexed permit2);\\n\\n    /// @dev is emitted when an address is set.\\n    event AddressUpdated(\\n        bytes32 indexed protocolAddressId, uint64 indexed chainId, address indexed oldAddress, address newAddress\\n    );\\n\\n    /// @dev is emitted when a new token bridge is configured.\\n    event SetBridgeAddress(uint256 indexed bridgeId, address indexed bridgeAddress);\\n\\n    /// @dev is emitted when a new bridge validator is configured.\\n    event SetBridgeValidator(uint256 indexed bridgeId, address indexed bridgeValidator);\\n\\n    /// @dev is emitted when a new amb is configured.\\n    event SetAmbAddress(uint8 indexed ambId_, address indexed ambAddress_, bool indexed isBroadcastAMB_);\\n\\n    /// @dev is emitted when a new state registry is configured.\\n    event SetStateRegistryAddress(uint8 indexed registryId_, address indexed registryAddress_);\\n\\n    /// @dev is emitted when a new delay is configured.\\n    event SetDelay(uint256 indexed oldDelay_, uint256 indexed newDelay_);\\n\\n    /// @dev is emitted when a new vault limit is configured\\n    event SetVaultLimitPerDestination(uint64 indexed chainId_, uint256 indexed vaultLimit_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev gets the deposit rescue delay\\n    function delay() external view returns (uint256);\\n\\n    /// @dev returns the permit2 address\\n    function PERMIT2() external view returns (address);\\n\\n    /// @dev returns the id of the superform router module\\n    function SUPERFORM_ROUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform factory module\\n    function SUPERFORM_FACTORY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform transmuter\\n    function SUPER_TRANSMUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform paymaster contract\\n    function PAYMASTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform payload helper contract\\n    function PAYMENT_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry module\\n    function CORE_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry module\\n    function TIMELOCK_STATE_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry module\\n    function BROADCAST_REGISTRY() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super positions module\\n    function SUPER_POSITIONS() external view returns (bytes32);\\n\\n    /// @dev returns the id of the super rbac module\\n    function SUPER_RBAC() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payload helper module\\n    function PAYLOAD_HELPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper keeper\\n    function DST_SWAPPER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency queue\\n    function EMERGENCY_QUEUE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the superform receiver\\n    function SUPERFORM_RECEIVER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin keeper\\n    function PAYMENT_ADMIN() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor keeper\\n    function CORE_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast registry processor keeper\\n    function BROADCAST_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock form state registry processor keeper\\n    function TIMELOCK_REGISTRY_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_UPDATER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_RESCUER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function CORE_REGISTRY_DISPUTER() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater keeper\\n    function DST_SWAPPER_PROCESSOR() external view returns (bytes32);\\n\\n    /// @dev gets the address of a contract on current chain\\n    /// @param id_ is the id of the contract\\n    function getAddress(bytes32 id_) external view returns (address);\\n\\n    /// @dev gets the address of a contract on a target chain\\n    /// @param id_ is the id of the contract\\n    /// @param chainId_ is the chain id of that chain\\n    function getAddressByChainId(bytes32 id_, uint64 chainId_) external view returns (address);\\n\\n    /// @dev gets the address of a bridge\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeAddress_ is the address of the form\\n    function getBridgeAddress(uint8 bridgeId_) external view returns (address bridgeAddress_);\\n\\n    /// @dev gets the address of a bridge validator\\n    /// @param bridgeId_ is the id of a bridge\\n    /// @return bridgeValidator_ is the address of the form\\n    function getBridgeValidator(uint8 bridgeId_) external view returns (address bridgeValidator_);\\n\\n    /// @dev gets the address of a amb\\n    /// @param ambId_ is the id of a bridge\\n    /// @return ambAddress_ is the address of the form\\n    function getAmbAddress(uint8 ambId_) external view returns (address ambAddress_);\\n\\n    /// @dev gets the id of the amb\\n    /// @param ambAddress_ is the address of an amb\\n    /// @return ambId_ is the identifier of an amb\\n    function getAmbId(address ambAddress_) external view returns (uint8 ambId_);\\n\\n    /// @dev gets the address of the registry\\n    /// @param registryId_ is the id of the state registry\\n    /// @return registryAddress_ is the address of the state registry\\n    function getStateRegistry(uint8 registryId_) external view returns (address registryAddress_);\\n\\n    /// @dev gets the id of the registry\\n    /// @notice reverts if the id is not found\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return registryId_ is the id of the state registry\\n    function getStateRegistryId(address registryAddress_) external view returns (uint8 registryId_);\\n\\n    /// @dev gets the safe vault limit\\n    /// @param chainId_ is the id of the remote chain\\n    /// @return vaultLimitPerDestination_ is the safe number of vaults to deposit\\n    /// without hitting out of gas error\\n    function getVaultLimitPerDestination(uint64 chainId_) external view returns (uint256 vaultLimitPerDestination_);\\n\\n    /// @dev helps validate if an address is a valid state registry\\n    /// @param registryAddress_ is the address of the state registry\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidStateRegistry(address registryAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid amb implementation\\n    /// @param ambAddress_ is the address of the amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    /// @dev helps validate if an address is a valid broadcast amb implementation\\n    /// @param ambAddress_ is the address of the broadcast amb implementation\\n    /// @return valid_ a flag indicating if its valid.\\n    function isValidBroadcastAmbImpl(address ambAddress_) external view returns (bool valid_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev sets the deposit rescue delay\\n    /// @param delay_ the delay in seconds before the deposit rescue can be finalized\\n    function setDelay(uint256 delay_) external;\\n\\n    /// @dev sets the permit2 address\\n    /// @param permit2_ the address of the permit2 contract\\n    function setPermit2(address permit2_) external;\\n\\n    /// @dev sets the safe vault limit\\n    /// @param chainId_ is the remote chain identifier\\n    /// @param vaultLimit_ is the max limit of vaults per transaction\\n    function setVaultLimitPerDestination(uint64 chainId_, uint256 vaultLimit_) external;\\n\\n    /// @dev sets a new address on a specific chain.\\n    /// @param id_ the identifier of the address on that chain\\n    /// @param newAddress_ the new address on that chain\\n    /// @param chainId_ the chain id of that chain\\n    function setAddress(bytes32 id_, address newAddress_, uint64 chainId_) external;\\n\\n    /// @dev allows admin to set the bridge address for an bridge id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param bridgeId_         represents the bridge unique identifier.\\n    /// @param bridgeAddress_    represents the bridge address.\\n    /// @param bridgeValidator_  represents the bridge validator address.\\n    function setBridgeAddresses(\\n        uint8[] memory bridgeId_,\\n        address[] memory bridgeAddress_,\\n        address[] memory bridgeValidator_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the amb address for an amb id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param ambId_         represents the bridge unique identifier.\\n    /// @param ambAddress_    represents the bridge address.\\n    /// @param isBroadcastAMB_ represents whether the amb implementation supports broadcasting\\n    function setAmbAddress(\\n        uint8[] memory ambId_,\\n        address[] memory ambAddress_,\\n        bool[] memory isBroadcastAMB_\\n    )\\n        external;\\n\\n    /// @dev allows admin to set the state registry address for an state registry id.\\n    /// @notice this function operates in an APPEND-ONLY fashion.\\n    /// @param registryId_    represents the state registry's unique identifier.\\n    /// @param registryAddress_    represents the state registry's address.\\n    function setStateRegistryAddress(uint8[] memory registryId_, address[] memory registryAddress_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperRBAC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { IAccessControl } from \\\"openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\n/// @title ISuperRBAC\\n/// @dev Interface for SuperRBAC\\n/// @author Zeropoint Labs\\ninterface ISuperRBAC is IAccessControl {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    struct InitialRoleSetup {\\n        address admin;\\n        address emergencyAdmin;\\n        address paymentAdmin;\\n        address csrProcessor;\\n        address tlProcessor;\\n        address brProcessor;\\n        address csrUpdater;\\n        address srcVaaRelayer;\\n        address dstSwapper;\\n        address csrRescuer;\\n        address csrDisputer;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when superRegistry is set\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev is emitted when an admin is set for a role\\n    event RoleAdminSet(bytes32 role, bytes32 adminRole);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the id of the protocol admin role\\n    function PROTOCOL_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the emergency admin role\\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the payment admin role\\n    function PAYMENT_ADMIN_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcaster role\\n    function BROADCASTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry processor role\\n    function CORE_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the timelock state registry processor role\\n    function TIMELOCK_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the broadcast state registry processor role\\n    function BROADCAST_STATE_REGISTRY_PROCESSOR_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry updater role\\n    function CORE_STATE_REGISTRY_UPDATER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the dst swapper role\\n    function DST_SWAPPER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescuer role\\n    function CORE_STATE_REGISTRY_RESCUER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of the core state registry rescue disputer role\\n    function CORE_STATE_REGISTRY_DISPUTER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns the id of wormhole vaa relayer role\\n    function WORMHOLE_VAA_RELAYER_ROLE() external view returns (bytes32);\\n\\n    /// @dev returns whether the given address has the protocol admin role\\n    /// @param admin_ the address to check\\n    function hasProtocolAdminRole(address admin_) external view returns (bool);\\n\\n    /// @dev returns whether the given address has the emergency admin role\\n    /// @param admin_ the address to check\\n    function hasEmergencyAdminRole(address admin_) external view returns (bool);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev updates the super registry address\\n    function setSuperRegistry(address superRegistry_) external;\\n\\n    /// @dev configures a new role in superForm\\n    /// @param role_ the role to set\\n    /// @param adminRole_ the admin role to set as admin\\n    function setRoleAdmin(bytes32 role_, bytes32 adminRole_) external;\\n\\n    /// @dev revokes the role_ from superRegistryAddressId_ on all chains\\n    /// @param role_ the role to revoke\\n    /// @param extraData_ amb config if broadcasting is required\\n    /// @param superRegistryAddressId_ the super registry address id\\n    function revokeRoleSuperBroadcast(\\n        bytes32 role_,\\n        bytes memory extraData_,\\n        bytes32 superRegistryAddressId_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows sync of global roles from different chains using broadcast registry\\n    /// @notice may not work for all roles\\n    function stateSyncBroadcast(bytes memory data_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISuperformFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title ISuperformFactory\\n/// @dev Interface for SuperformFactory\\n/// @author ZeroPoint Labs\\ninterface ISuperformFactory {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                         CONSTANTS                        //\\n    //////////////////////////////////////////////////////////////\\n\\n    enum PauseStatus {\\n        NON_PAUSED,\\n        PAUSED\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when a new formImplementation is entered into the factory\\n    /// @param formImplementation is the address of the new form implementation\\n    /// @param formImplementationId is the id of the formImplementation\\n    /// @param formStateRegistryId is any additional state registry id of the formImplementation\\n    event FormImplementationAdded(\\n        address indexed formImplementation, uint256 indexed formImplementationId, uint8 indexed formStateRegistryId\\n    );\\n\\n    /// @dev emitted when a new Superform is created\\n    /// @param formImplementationId is the id of the form implementation\\n    /// @param vault is the address of the vault\\n    /// @param superformId is the id of the superform\\n    /// @param superform is the address of the superform\\n    event SuperformCreated(\\n        uint256 indexed formImplementationId, address indexed vault, uint256 indexed superformId, address superform\\n    );\\n\\n    /// @dev emitted when a new SuperRegistry is set\\n    /// @param superRegistry is the address of the super registry\\n    event SuperRegistrySet(address indexed superRegistry);\\n\\n    /// @dev emitted when a form implementation is paused\\n    /// @param formImplementationId is the id of the form implementation\\n    /// @param paused is the new paused status\\n    event FormImplementationPaused(uint256 indexed formImplementationId, PauseStatus indexed paused);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the number of forms\\n    /// @return forms_ is the number of forms\\n    function getFormCount() external view returns (uint256 forms_);\\n\\n    /// @dev returns the number of superforms\\n    /// @return superforms_ is the number of superforms\\n    function getSuperformCount() external view returns (uint256 superforms_);\\n\\n    /// @dev returns the address of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return formImplementation_ is the address of the form implementation\\n    function getFormImplementation(uint32 formImplementationId_) external view returns (address formImplementation_);\\n\\n    /// @dev returns the form state registry id of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return stateRegistryId_ is the additional state registry id of the form\\n    function getFormStateRegistryId(uint32 formImplementationId_) external view returns (uint8 stateRegistryId_);\\n\\n    /// @dev returns the paused status of form implementation\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @return paused_ is the current paused status of the form formImplementationId_\\n    function isFormImplementationPaused(uint32 formImplementationId_) external view returns (bool paused_);\\n\\n    /// @dev returns the address of a superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return superform_ is the address of the superform\\n    /// @return formImplementationId_ is the id of the form implementation\\n    /// @return chainId_ is the chain id\\n    function getSuperform(uint256 superformId_)\\n        external\\n        pure\\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_);\\n\\n    /// @dev returns if an address has been added to a Form\\n    /// @param superformId_ is the id of the superform\\n    /// @return isSuperform_ bool if it exists\\n    function isSuperform(uint256 superformId_) external view returns (bool isSuperform_);\\n\\n    /// @dev Reverse query of getSuperform, returns all superforms for a given vault\\n    /// @param vault_ is the address of a vault\\n    /// @return superformIds_ is the id of the superform\\n    /// @return superforms_ is the address of the superform\\n    function getAllSuperformsFromVault(address vault_)\\n        external\\n        view\\n        returns (uint256[] memory superformIds_, address[] memory superforms_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows an admin to add a Form implementation to the factory\\n    /// @param formImplementation_ is the address of a form implementation\\n    /// @param formImplementationId_ is the id of the form implementation (generated off-chain and equal in all chains)\\n    /// @param formStateRegistryId_ is the id of any additional state registry for that form\\n    /// @dev formStateRegistryId_ 1 is default for all form implementations, pass in formStateRegistryId_ only if an\\n    /// additional state registry is required\\n    function addFormImplementation(\\n        address formImplementation_,\\n        uint32 formImplementationId_,\\n        uint8 formStateRegistryId_\\n    )\\n        external;\\n\\n    /// @dev To add new vaults to Form implementations, fusing them together into Superforms\\n    /// @param formImplementationId_ is the form implementation we want to attach the vault to\\n    /// @param vault_ is the address of the vault\\n    /// @return superformId_ is the id of the created superform\\n    /// @return superform_ is the address of the created superform\\n    function createSuperform(\\n        uint32 formImplementationId_,\\n        address vault_\\n    )\\n        external\\n        returns (uint256 superformId_, address superform_);\\n\\n    /// @dev to synchronize superforms added to different chains using broadcast registry\\n    /// @param data_ is the cross-chain superform id\\n    function stateSyncBroadcast(bytes memory data_) external payable;\\n\\n    /// @dev allows an admin to change the status of a form\\n    /// @param formImplementationId_ is the id of the form implementation\\n    /// @param status_ is the new status\\n    /// @param extraData_ is optional & passed when broadcasting of status is needed\\n    function changeFormImplementationPauseStatus(\\n        uint32 formImplementationId_,\\n        PauseStatus status_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBaseForm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { InitSingleVaultData } from \\\"src/types/DataTypes.sol\\\";\\nimport { IERC165 } from \\\"openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\\\";\\nimport { IERC4626 } from \\\"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\\\";\\n\\n/// @title IBaseForm\\n/// @dev Interface for BaseForm\\n/// @author ZeroPoint Labs\\ninterface IBaseForm is IERC165 {\\n    \\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                           //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev is emitted when a new vault is added by the admin.\\n    event VaultAdded(uint256 indexed id, IERC4626 indexed vault);\\n\\n    /// @dev is emitted when a payload is processed by the destination contract.\\n    event Processed(\\n        uint64 indexed srcChainID,\\n        uint64 indexed dstChainId,\\n        uint256 indexed srcPayloadId,\\n        uint256 amount,\\n        address vault\\n    );\\n\\n    /// @dev is emitted when an emergency withdrawal is processed\\n    event EmergencyWithdrawalProcessed(address indexed refundAddress, uint256 indexed amount);\\n\\n    /// @dev is emitted when dust is forwarded to the paymaster\\n    event FormDustForwardedToPaymaster(address indexed token, uint256 indexed amount);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice get Superform name of the ERC20 vault representation\\n    /// @return The ERC20 name\\n    function superformYieldTokenName() external view returns (string memory);\\n\\n    /// @notice get Superform symbol of the ERC20 vault representation\\n    /// @return The ERC20 symbol\\n    function superformYieldTokenSymbol() external view returns (string memory);\\n\\n    /// @notice get the state registry id associated with the vault\\n    function getStateRegistryId() external view returns (uint8);\\n\\n    /// @notice Returns the vault address\\n    /// @return The address of the vault\\n    function getVaultAddress() external view returns (address);\\n\\n    /// @notice Returns the vault address\\n    /// @return The address of the vault asset\\n    function getVaultAsset() external view returns (address);\\n\\n    /// @notice Returns the name of the vault.\\n    /// @return The name of the vault\\n    function getVaultName() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of a vault.\\n    /// @return The symbol associated with a vault\\n    function getVaultSymbol() external view returns (string memory);\\n\\n    /// @notice Returns the number of decimals in a vault for accounting purposes\\n    /// @return The number of decimals in the vault balance\\n    function getVaultDecimals() external view returns (uint256);\\n\\n    /// @notice Returns the amount of underlying tokens each share of a vault is worth.\\n    /// @return The pricePerVaultShare value\\n    function getPricePerVaultShare() external view returns (uint256);\\n\\n    /// @notice Returns the amount of vault shares owned by the form.\\n    /// @return The form's vault share balance\\n    function getVaultShareBalance() external view returns (uint256);\\n\\n    /// @notice get the total amount of underlying managed in the ERC4626 vault\\n    function getTotalAssets() external view returns (uint256);\\n\\n    /// @notice get the total amount of unredeemed vault shares in circulation\\n    function getTotalSupply() external view returns (uint256);\\n\\n    /// @notice get the total amount of assets received if shares are actually redeemed\\n    /// @notice https://eips.ethereum.org/EIPS/eip-4626\\n    function getPreviewPricePerVaultShare() external view returns (uint256);\\n\\n    /// @dev API may need to know state of funds deployed\\n    function previewDepositTo(uint256 assets_) external view returns (uint256);\\n\\n    /// @notice positionBalance() -> .vaultIds&destAmounts\\n    /// @return how much of an asset + interest (accrued) is to withdraw from the Vault\\n    function previewWithdrawFrom(uint256 assets_) external view returns (uint256);\\n\\n    /// @dev API may need to know state of funds deployed\\n    function previewRedeemFrom(uint256 shares_) external view returns (uint256);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev process same chain id deposits\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @return shares  The amount of vault shares received\\n    function directDepositIntoVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_\\n    )\\n        external\\n        payable\\n        returns (uint256 shares);\\n\\n    /// @dev process same chain id deposits\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @param srcChainId_ The chain id of the source chain\\n    /// @return shares  The amount of vault shares received\\n    /// @dev is shares is `0` then no further action/acknowledgement needs to be sent\\n    function xChainDepositIntoVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        external\\n        returns (uint256 shares);\\n\\n    /// @dev process withdrawal of asset from a vault\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @return assets  The amount of assets received\\n    function directWithdrawFromVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_\\n    )\\n        external\\n        returns (uint256 assets);\\n\\n    /// @dev process withdrawal of asset from a vault\\n    /// @param singleVaultData_  A bytes representation containing all the data required to make a form action\\n    /// @param srcSender_ The address of the sender of the transaction\\n    /// @param srcChainId_ The chain id of the source chain\\n    /// @return assets The amount of assets received\\n    function xChainWithdrawFromVault(\\n        InitSingleVaultData memory singleVaultData_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        external\\n        returns (uint256 assets);\\n\\n    /// @dev process withdrawal of shares if form is paused\\n    /// @param receiverAddress_ The address to refund the shares to\\n    /// @param amount_ The amount of vault shares to refund\\n    function emergencyWithdraw(address receiverAddress_, uint256 amount_) external;\\n\\n    /// @dev moves all dust in the contract to Paymaster contract\\n    /// @param token_ The address of the token to forward\\n    function forwardDustToPaymaster(address token_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBroadcastRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @title IBroadcastRegistry\\n/// @dev Interface for BroadcastRegistry\\n/// @author ZeroPoint Labs\\ninterface IBroadcastRegistry {\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev allows core contracts to send payload to all configured destination chain.\\n    /// @param srcSender_ is the caller of the function (used for gas refunds).\\n    /// @param ambId_ is the identifier of the arbitrary message bridge to be used\\n    /// @param gasFee_ is the gas fee to be used for broadcasting\\n    /// @param message_ is the crosschain payload to be broadcasted\\n    /// @param extraData_ defines all the message bridge related overrides\\n    function broadcastPayload(\\n        address srcSender_,\\n        uint8 ambId_,\\n        uint256 gasFee_,\\n        bytes memory message_,\\n        bytes memory extraData_\\n    )\\n        external\\n        payable;\\n\\n    /// @dev allows ambs to write broadcasted payloads\\n    function receiveBroadcastPayload(uint64 srcChainId_, bytes memory message_) external;\\n\\n    /// @dev allows privileged actors to process broadcasted payloads\\n    /// @param payloadId_ is the identifier of the cross-chain payload\\n    function processPayload(uint256 payloadId_) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPaymentHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport {\\n    MultiDstMultiVaultStateReq,\\n    MultiDstSingleVaultStateReq,\\n    SingleXChainMultiVaultStateReq,\\n    SingleXChainSingleVaultStateReq,\\n    SingleDirectSingleVaultStateReq,\\n    SingleDirectMultiVaultStateReq\\n} from \\\"src/types/DataTypes.sol\\\";\\n\\n/// @title IPaymentHelper\\n/// @dev Interface for PaymentHelper\\n/// @author ZeroPoint Labs\\ninterface IPaymentHelper {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                           STRUCTS                         //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @param nativeFeedOracle is the native price feed oracle\\n    /// @param gasPriceOracle is the gas price oracle\\n    /// @param swapGasUsed is the swap gas params\\n    /// @param updateGasUsed is the update gas params\\n    /// @param depositGasUsed is the deposit per vault gas on the chain\\n    /// @param withdrawGasUsed is the withdraw per vault gas on the chain\\n    /// @param defaultNativePrice is the native price on the specified chain\\n    /// @param defaultGasPrice is the gas price on the specified chain\\n    /// @param dstGasPerByte is the gas per size of data on the specified chain\\n    /// @param ackGasCost is the gas cost for processing acknowledgements on src chain\\n    /// @param timelockCost is the extra cost for processing timelocked payloads\\n    /// @param emergencyCost is the extra cost for processing emergency payloads\\n    struct PaymentHelperConfig {\\n        address nativeFeedOracle;\\n        address gasPriceOracle;\\n        uint256 swapGasUsed;\\n        uint256 updateGasUsed;\\n        uint256 depositGasUsed;\\n        uint256 withdrawGasUsed;\\n        uint256 defaultNativePrice;\\n        uint256 defaultGasPrice;\\n        uint256 dstGasPerByte;\\n        uint256 ackGasCost;\\n        uint256 timelockCost;\\n        uint256 emergencyCost;\\n    }\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    event ChainConfigUpdated(uint64 indexed chainId_, uint256 indexed configType_, bytes indexed config_);\\n    event ChainConfigAdded(uint64 chainId_, PaymentHelperConfig config_);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev returns the amb overrides & gas to be used\\n    /// @param dstChainId_ is the unique dst chain identifier\\n    /// @param ambIds_ is the identifiers of arbitrary message bridges to be used\\n    /// @param message_ is the encoded cross-chain payload\\n    function calculateAMBData(\\n        uint64 dstChainId_,\\n        uint8[] calldata ambIds_,\\n        bytes memory message_\\n    )\\n        external\\n        view\\n        returns (uint256 totalFees, bytes memory extraData);\\n\\n    /// @dev returns the amb overrides & gas to be used\\n    /// @return extraData the amb specific override information\\n    function getRegisterTransmuterAMBData() external view returns (bytes memory extraData);\\n\\n    /// @dev returns the gas fees estimation in native tokens if we send message through a combination of AMBs\\n    /// @param ambIds_ is the identifier of different AMBs\\n    /// @param dstChainId_ is the identifier of the destination chain\\n    /// @param message_ is the cross-chain message\\n    /// @param extraData_ is any amb-specific information\\n    /// @return ambFees is the native_tokens to be sent along the transaction for all the ambIds_ included\\n    function estimateAMBFees(\\n        uint8[] memory ambIds_,\\n        uint64 dstChainId_,\\n        bytes memory message_,\\n        bytes[] memory extraData_\\n    )\\n        external\\n        view\\n        returns (uint256 ambFees, uint256[] memory);\\n\\n    /// @dev estimates the gas fees for multiple destination and multi vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateMultiDstMultiVault(\\n        MultiDstMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for multiple destination and single vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateMultiDstSingleVault(\\n        MultiDstSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for single destination and multi vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleXChainMultiVault(\\n        SingleXChainMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for single destination and single vault operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return dstAmount is the gas expense on dst chain in terms of src chain's native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleXChainSingleVault(\\n        SingleXChainSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 dstAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for same chain operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleDirectSingleVault(\\n        SingleDirectSingleVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\\n\\n    /// @dev estimates the gas fees for multiple same chain operation\\n    /// @param req_ is the request object containing all necessary data for the actual operation on SuperRouter\\n    /// @param isDeposit_ indicated if the datatype will be used for a deposit\\n    /// @return liqAmount is the amount of liquidity to be provided in native tokens\\n    /// @return srcAmount is the gas expense on source chain in native tokens\\n    /// @return totalAmount is the native_tokens to be sent along the transaction\\n    function estimateSingleDirectMultiVault(\\n        SingleDirectMultiVaultStateReq calldata req_,\\n        bool isDeposit_\\n    )\\n        external\\n        view\\n        returns (uint256 liqAmount, uint256 srcAmount, uint256 totalAmount);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev admin can configure a remote chain for first time\\n    /// @param chainId_ is the identifier of new chain id\\n    /// @param config_ is the chain config\\n    function addRemoteChain(uint64 chainId_, PaymentHelperConfig calldata config_) external;\\n\\n    /// @dev admin can specifically configure/update certain configuration of a remote chain\\n    /// @param chainId_ is the remote chain's identifier\\n    /// @param configType_ is the type of config from 1 -> 6\\n    /// @param config_ is the encoded new configuration\\n    function updateRemoteChain(uint64 chainId_, uint256 configType_, bytes memory config_) external;\\n\\n    /// @dev admin updates config for register transmuter amb params\\n    /// @param extraDataForTransmuter_ is the broadcast extra data\\n    function updateRegisterAERC20Params(bytes memory extraDataForTransmuter_) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nlibrary Error {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  CONFIGURATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown in protocol setup\\n\\n    /// @dev thrown if chain id exceeds max(uint64)\\n    error BLOCK_CHAIN_ID_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if not possible to revoke a role in broadcasting\\n    error CANNOT_REVOKE_NON_BROADCASTABLE_ROLES();\\n\\n    /// @dev thrown if not possible to revoke last admin\\n    error CANNOT_REVOKE_LAST_ADMIN();\\n\\n    /// @dev thrown if trying to set again pseudo immutables in super registry\\n    error DISABLED();\\n\\n    /// @dev thrown if rescue delay is not yet set for a chain\\n    error DELAY_NOT_SET();\\n\\n    /// @dev thrown if get native token price estimate in paymentHelper is 0\\n    error INVALID_NATIVE_TOKEN_PRICE();\\n\\n    /// @dev thrown if wormhole refund chain id is not set\\n    error REFUND_CHAIN_ID_NOT_SET();\\n\\n    /// @dev thrown if wormhole relayer is not set\\n    error RELAYER_NOT_SET();\\n\\n    /// @dev thrown if a role to be revoked is not assigned\\n    error ROLE_NOT_ASSIGNED();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  AUTHORIZATION ERRORS                    //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if functions cannot be called\\n\\n    /// COMMON AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if caller is not address(this), internal call\\n    error INVALID_INTERNAL_CALL();\\n\\n    /// @dev thrown if msg.sender is not a valid amb implementation\\n    error NOT_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not an allowed broadcaster\\n    error NOT_ALLOWED_BROADCASTER();\\n\\n    /// @dev thrown if msg.sender is not broadcast amb implementation\\n    error NOT_BROADCAST_AMB_IMPLEMENTATION();\\n\\n    /// @dev thrown if msg.sender is not broadcast state registry\\n    error NOT_BROADCAST_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not core state registry\\n    error NOT_CORE_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not emergency admin\\n    error NOT_EMERGENCY_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not emergency queue\\n    error NOT_EMERGENCY_QUEUE();\\n\\n    /// @dev thrown if msg.sender is not minter\\n    error NOT_MINTER();\\n\\n    /// @dev thrown if msg.sender is not minter state registry\\n    error NOT_MINTER_STATE_REGISTRY_ROLE();\\n\\n    /// @dev thrown if msg.sender is not paymaster\\n    error NOT_PAYMASTER();\\n\\n    /// @dev thrown if msg.sender is not payment admin\\n    error NOT_PAYMENT_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not protocol admin\\n    error NOT_PROTOCOL_ADMIN();\\n\\n    /// @dev thrown if msg.sender is not state registry\\n    error NOT_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not super registry\\n    error NOT_SUPER_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not superform router\\n    error NOT_SUPERFORM_ROUTER();\\n\\n    /// @dev thrown if msg.sender is not a superform\\n    error NOT_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not superform factory\\n    error NOT_SUPERFORM_FACTORY();\\n\\n    /// @dev thrown if msg.sender is not timelock form\\n    error NOT_TIMELOCK_SUPERFORM();\\n\\n    /// @dev thrown if msg.sender is not timelock state registry\\n    error NOT_TIMELOCK_STATE_REGISTRY();\\n\\n    /// @dev thrown if msg.sender is not user or disputer\\n    error NOT_VALID_DISPUTER();\\n\\n    /// @dev thrown if the msg.sender is not privileged caller\\n    error NOT_PRIVILEGED_CALLER(bytes32 role);\\n\\n    /// STATE REGISTRY AUTHORIZATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev layerzero adapter specific error, thrown if caller not layerzero endpoint\\n    error CALLER_NOT_ENDPOINT();\\n\\n    /// @dev hyperlane adapter specific error, thrown if caller not hyperlane mailbox\\n    error CALLER_NOT_MAILBOX();\\n\\n    /// @dev wormhole relayer specific error, thrown if caller not wormhole relayer\\n    error CALLER_NOT_RELAYER();\\n\\n    /// @dev thrown if src chain sender is not valid\\n    error INVALID_SRC_SENDER();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  INPUT VALIDATION ERRORS                 //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown if input variables are not valid\\n\\n    /// COMMON INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if there is an array length mismatch\\n    error ARRAY_LENGTH_MISMATCH();\\n\\n    /// @dev thrown if payload id does not exist\\n    error INVALID_PAYLOAD_ID();\\n\\n    /// @dev error thrown when msg value should be zero in certain payable functions\\n    error MSG_VALUE_NOT_ZERO();\\n\\n    /// @dev thrown if amb ids length is 0\\n    error ZERO_AMB_ID_LENGTH();\\n\\n    /// @dev thrown if address input is address 0\\n    error ZERO_ADDRESS();\\n\\n    /// @dev thrown if amount input is 0\\n    error ZERO_AMOUNT();\\n\\n    /// @dev thrown if value input is 0\\n    error ZERO_INPUT_VALUE();\\n\\n    /// SUPERFORM ROUTER INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the vaults data is invalid\\n    error INVALID_SUPERFORMS_DATA();\\n\\n    /// @dev thrown if receiver address is not set\\n    error RECEIVER_ADDRESS_NOT_SET();\\n\\n    /// SUPERFORM FACTORY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if a form is not ERC165 compatible\\n    error ERC165_UNSUPPORTED();\\n\\n    /// @dev thrown if a form is not form interface compatible\\n    error FORM_INTERFACE_UNSUPPORTED();\\n\\n    /// @dev error thrown if form implementation address already exists\\n    error FORM_IMPLEMENTATION_ALREADY_EXISTS();\\n\\n    /// @dev error thrown if form implementation id already exists\\n    error FORM_IMPLEMENTATION_ID_ALREADY_EXISTS();\\n\\n    /// @dev thrown if a form does not exist\\n    error FORM_DOES_NOT_EXIST();\\n\\n    /// @dev thrown if form id is larger than max uint16\\n    error INVALID_FORM_ID();\\n\\n    /// @dev thrown if superform not on factory\\n    error SUPERFORM_ID_NONEXISTENT();\\n\\n    /// @dev thrown if same vault and form implementation is used to create new superform\\n    error VAULT_FORM_IMPLEMENTATION_COMBINATION_EXISTS();\\n\\n    /// FORM INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if in case of no txData, if liqData.token != vault.asset()\\n    /// in case of txData, if token output of swap != vault.asset()\\n    error DIFFERENT_TOKENS();\\n\\n    /// @dev thrown if the amount in direct withdraw is not correct\\n    error DIRECT_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// @dev thrown if the amount in xchain withdraw is not correct\\n    error XCHAIN_WITHDRAW_INVALID_LIQ_REQUEST();\\n\\n    /// LIQUIDITY BRIDGE INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev error thrown when txData selector of lifi bridged is a blacklisted selector\\n    error BLACKLISTED_SELECTOR();\\n\\n    /// @dev thrown if a certain action of the user is not allowed given the txData provided\\n    error INVALID_ACTION();\\n\\n    /// @dev thrown if in deposits, the liqDstChainId doesn't match the stateReq dstChainId\\n    error INVALID_DEPOSIT_LIQ_DST_CHAIN_ID();\\n\\n    /// @dev thrown if index is invalid\\n    error INVALID_INDEX();\\n\\n    /// @dev thrown if the chain id in the txdata is invalid\\n    error INVALID_TXDATA_CHAIN_ID();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to a destination call present\\n    error INVALID_TXDATA_NO_DESTINATIONCALL_ALLOWED();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong receiver\\n    error INVALID_TXDATA_RECEIVER();\\n\\n    /// @dev thrown if the validation of bridge txData fails due to wrong token\\n    error INVALID_TXDATA_TOKEN();\\n\\n    /// @dev thrown if txData is not present (in case of xChain actions)\\n    error NO_TXDATA_PRESENT();\\n\\n    /// STATE REGISTRY INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if payload is being updated with final amounts length different than amounts length\\n    error DIFFERENT_PAYLOAD_UPDATE_AMOUNTS_LENGTH();\\n\\n    /// @dev thrown if payload is being updated with tx data length different than liq data length\\n    error DIFFERENT_PAYLOAD_UPDATE_TX_DATA_LENGTH();\\n\\n    /// @dev thrown if keeper update final token is different than the vault underlying\\n    error INVALID_UPDATE_FINAL_TOKEN();\\n\\n    /// @dev thrown if broadcast finality for wormhole is invalid\\n    error INVALID_BROADCAST_FINALITY();\\n\\n    /// @dev thrown if amb id is not valid leading to an address 0 of the implementation\\n    error INVALID_BRIDGE_ID();\\n\\n    /// @dev thrown if chain id involved in xchain message is invalid\\n    error INVALID_CHAIN_ID();\\n\\n    /// @dev thrown if payload update amount isn't equal to dst swapper amount\\n    error INVALID_DST_SWAP_AMOUNT();\\n\\n    /// @dev thrown if message amb and proof amb are the same\\n    error INVALID_PROOF_BRIDGE_ID();\\n\\n    /// @dev thrown if order of proof AMBs is incorrect, either duplicated or not incrementing\\n    error INVALID_PROOF_BRIDGE_IDS();\\n\\n    /// @dev thrown if rescue data lengths are invalid\\n    error INVALID_RESCUE_DATA();\\n\\n    /// @dev thrown if delay is invalid\\n    error INVALID_TIMELOCK_DELAY();\\n\\n    /// @dev thrown if amounts being sent in update payload mean a negative slippage\\n    error NEGATIVE_SLIPPAGE();\\n\\n    /// @dev thrown if slippage is outside of bounds\\n    error SLIPPAGE_OUT_OF_BOUNDS();\\n\\n    /// SUPERPOSITION INPUT VALIDATION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if src senders mismatch in state sync\\n    error SRC_SENDER_MISMATCH();\\n\\n    /// @dev thrown if src tx types mismatch in state sync\\n    error SRC_TX_TYPE_MISMATCH();\\n\\n    //////////////////////////////////////////////////////////////\\n    //                  EXECUTION ERRORS                        //\\n    //////////////////////////////////////////////////////////////\\n    ///@notice errors thrown due to function execution logic\\n\\n    /// COMMON EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if the swap in a direct deposit resulted in insufficient tokens\\n    error DIRECT_DEPOSIT_SWAP_FAILED();\\n\\n    /// @dev thrown if payload is not unique\\n    error DUPLICATE_PAYLOAD();\\n\\n    /// @dev thrown if native tokens fail to be sent to superform contracts\\n    error FAILED_TO_SEND_NATIVE();\\n\\n    /// @dev thrown if allowance is not correct to deposit\\n    error INSUFFICIENT_ALLOWANCE_FOR_DEPOSIT();\\n\\n    /// @dev thrown if contract has insufficient balance for operations\\n    error INSUFFICIENT_BALANCE();\\n\\n    /// @dev thrown if native amount is not at least equal to the amount in the request\\n    error INSUFFICIENT_NATIVE_AMOUNT();\\n\\n    /// @dev thrown if payload cannot be decoded\\n    error INVALID_PAYLOAD();\\n\\n    /// @dev thrown if payload status is invalid\\n    error INVALID_PAYLOAD_STATUS();\\n\\n    /// @dev thrown if payload type is invalid\\n    error INVALID_PAYLOAD_TYPE();\\n\\n    /// LIQUIDITY BRIDGE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if we try to decode the final swap output token in a xChain liquidity bridging action\\n    error CANNOT_DECODE_FINAL_SWAP_OUTPUT_TOKEN();\\n\\n    /// @dev thrown if liquidity bridge fails for erc20 or native tokens\\n    error FAILED_TO_EXECUTE_TXDATA(address token);\\n\\n    /// @dev thrown if asset being used for deposit mismatches in multivault deposits\\n    error INVALID_DEPOSIT_TOKEN();\\n\\n    /// STATE REGISTRY EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if bridge tokens haven't arrived to destination\\n    error BRIDGE_TOKENS_PENDING();\\n\\n    /// @dev thrown if withdrawal tx data cannot be updated\\n    error CANNOT_UPDATE_WITHDRAW_TX_DATA();\\n\\n    /// @dev thrown if rescue passed dispute deadline\\n    error DISPUTE_TIME_ELAPSED();\\n\\n    /// @dev thrown if message failed to reach the specified level of quorum needed\\n    error INSUFFICIENT_QUORUM();\\n\\n    /// @dev thrown if broadcast payload is invalid\\n    error INVALID_BROADCAST_PAYLOAD();\\n\\n    /// @dev thrown if broadcast fee is invalid\\n    error INVALID_BROADCAST_FEE();\\n\\n    /// @dev thrown if retry fees is less than required\\n    error INVALID_RETRY_FEE();\\n\\n    /// @dev thrown if broadcast message type is wrong\\n    error INVALID_MESSAGE_TYPE();\\n\\n    /// @dev thrown if payload hash is invalid during `retryMessage` on Layezero implementation\\n    error INVALID_PAYLOAD_HASH();\\n\\n    /// @dev thrown if update payload function was called on a wrong payload\\n    error INVALID_PAYLOAD_UPDATE_REQUEST();\\n\\n    /// @dev thrown if a state registry id is 0\\n    error INVALID_REGISTRY_ID();\\n\\n    /// @dev thrown if a form state registry id is 0\\n    error INVALID_FORM_REGISTRY_ID();\\n\\n    /// @dev thrown if trying to finalize the payload but the withdraw is still locked\\n    error LOCKED();\\n\\n    /// @dev thrown if payload is already updated (during xChain deposits)\\n    error PAYLOAD_ALREADY_UPDATED();\\n\\n    /// @dev thrown if payload is already processed\\n    error PAYLOAD_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if payload is not in UPDATED state\\n    error PAYLOAD_NOT_UPDATED();\\n\\n    /// @dev thrown if rescue is still in timelocked state\\n    error RESCUE_LOCKED();\\n\\n    /// @dev thrown if rescue is already proposed\\n    error RESCUE_ALREADY_PROPOSED();\\n\\n    /// @dev thrown if payload hash is zero during `retryMessage` on Layezero implementation\\n    error ZERO_PAYLOAD_HASH();\\n\\n    /// DST SWAPPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if process dst swap is tried for processed payload id\\n    error DST_SWAP_ALREADY_PROCESSED();\\n\\n    /// @dev thrown if indices have duplicates\\n    error DUPLICATE_INDEX();\\n\\n    /// @dev thrown if failed dst swap is already updated\\n    error FAILED_DST_SWAP_ALREADY_UPDATED();\\n\\n    /// @dev thrown if indices are out of bounds\\n    error INDEX_OUT_OF_BOUNDS();\\n\\n    /// @dev thrown if failed swap token amount is 0\\n    error INVALID_DST_SWAPPER_FAILED_SWAP();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if token balance is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_TOKEN_BALANCE();\\n\\n    /// @dev thrown if failed swap token amount is not 0 and if native amount is less than amount (non zero)\\n    error INVALID_DST_SWAPPER_FAILED_SWAP_NO_NATIVE_BALANCE();\\n\\n    /// @dev forbid xChain deposits with destination swaps without interim token set (for user protection)\\n    error INVALID_INTERIM_TOKEN();\\n\\n    /// @dev thrown if dst swap output is less than minimum expected\\n    error INVALID_SWAP_OUTPUT();\\n\\n    /// FORM EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if try to forward 4626 share from the superform\\n    error CANNOT_FORWARD_4646_TOKEN();\\n\\n    /// @dev thrown in KYCDAO form if no KYC token is present\\n    error NO_VALID_KYC_TOKEN();\\n\\n    /// @dev thrown in forms where a certain functionality is not allowed or implemented\\n    error NOT_IMPLEMENTED();\\n\\n    /// @dev thrown if form implementation is PAUSED, users cannot perform any action\\n    error PAUSED();\\n\\n    /// @dev thrown if shares != deposit output or assets != redeem output when minting SuperPositions\\n    error VAULT_IMPLEMENTATION_FAILED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TOKEN_NOT_UPDATED();\\n\\n    /// @dev thrown if withdrawal tx data is not updated\\n    error WITHDRAW_TX_DATA_NOT_UPDATED();\\n\\n    /// @dev thrown when redeeming from vault yields zero collateral\\n    error WITHDRAW_ZERO_COLLATERAL();\\n\\n    /// PAYMENT HELPER EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if chainlink is reporting an improper price\\n    error CHAINLINK_MALFUNCTION();\\n\\n    /// @dev thrown if chainlink is reporting an incomplete round\\n    error CHAINLINK_INCOMPLETE_ROUND();\\n\\n    /// @dev thrown if feed decimals is not 8\\n    error CHAINLINK_UNSUPPORTED_DECIMAL();\\n\\n    /// EMERGENCY QUEUE EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if emergency withdraw is not queued\\n    error EMERGENCY_WITHDRAW_NOT_QUEUED();\\n\\n    /// @dev thrown if emergency withdraw is already processed\\n    error EMERGENCY_WITHDRAW_PROCESSED_ALREADY();\\n\\n    /// SUPERPOSITION EXECUTION ERRORS\\n    /// ---------------------------------------------------------\\n\\n    /// @dev thrown if uri cannot be updated\\n    error DYNAMIC_URI_FROZEN();\\n\\n    /// @dev thrown if tx history is not found while state sync\\n    error TX_HISTORY_NOT_FOUND();\\n}\\n\"\r\n    },\r\n    \"src/libraries/DataLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\nimport { Error } from \\\"src/libraries/Error.sol\\\";\\n\\nlibrary DataLib {\\n    function packTxInfo(\\n        uint8 txType_,\\n        uint8 callbackType_,\\n        uint8 multi_,\\n        uint8 registryId_,\\n        address srcSender_,\\n        uint64 srcChainId_\\n    )\\n        internal\\n        pure\\n        returns (uint256 txInfo)\\n    {\\n        txInfo = uint256(txType_);\\n        txInfo |= uint256(callbackType_) << 8;\\n        txInfo |= uint256(multi_) << 16;\\n        txInfo |= uint256(registryId_) << 24;\\n        txInfo |= uint256(uint160(srcSender_)) << 32;\\n        txInfo |= uint256(srcChainId_) << 192;\\n    }\\n\\n    function decodeTxInfo(uint256 txInfo_)\\n        internal\\n        pure\\n        returns (uint8 txType, uint8 callbackType, uint8 multi, uint8 registryId, address srcSender, uint64 srcChainId)\\n    {\\n        txType = uint8(txInfo_);\\n        callbackType = uint8(txInfo_ >> 8);\\n        multi = uint8(txInfo_ >> 16);\\n        registryId = uint8(txInfo_ >> 24);\\n        srcSender = address(uint160(txInfo_ >> 32));\\n        srcChainId = uint64(txInfo_ >> 192);\\n    }\\n\\n    /// @dev returns the vault-form-chain pair of a superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return superform_ is the address of the superform\\n    /// @return formImplementationId_ is the form id\\n    /// @return chainId_ is the chain id\\n    function getSuperform(uint256 superformId_)\\n        internal\\n        pure\\n        returns (address superform_, uint32 formImplementationId_, uint64 chainId_)\\n    {\\n        superform_ = address(uint160(superformId_));\\n        formImplementationId_ = uint32(superformId_ >> 160);\\n        chainId_ = uint64(superformId_ >> 192);\\n\\n        if (chainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n    }\\n\\n    /// @dev returns the vault-form-chain pair of an array of superforms\\n    /// @param superformIds_  array of superforms\\n    /// @return superforms_ are the address of the vaults\\n    function getSuperforms(uint256[] memory superformIds_) internal pure returns (address[] memory superforms_) {\\n        uint256 len = superformIds_.length;\\n        superforms_ = new address[](len);\\n\\n        for (uint256 i; i < len; ++i) {\\n            (superforms_[i],,) = getSuperform(superformIds_[i]);\\n        }\\n    }\\n\\n    /// @dev returns the destination chain of a given superform\\n    /// @param superformId_ is the id of the superform\\n    /// @return chainId_ is the chain id\\n    function getDestinationChain(uint256 superformId_) internal pure returns (uint64 chainId_) {\\n        chainId_ = uint64(superformId_ >> 192);\\n\\n        if (chainId_ == 0) {\\n            revert Error.INVALID_CHAIN_ID();\\n        }\\n    }\\n\\n    /// @dev generates the superformId\\n    /// @param superform_ is the address of the superform\\n    /// @param formImplementationId_ is the type of the form\\n    /// @param chainId_ is the chain id on which the superform is deployed\\n    function packSuperform(\\n        address superform_,\\n        uint32 formImplementationId_,\\n        uint64 chainId_\\n    )\\n        internal\\n        pure\\n        returns (uint256 superformId_)\\n    {\\n        superformId_ = uint256(uint160(superform_));\\n        superformId_ |= uint256(formImplementationId_) << 160;\\n        superformId_ |= uint256(chainId_) << 192;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/types/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.23;\\n\\n/// @dev contains all the common struct and enums used for data communication between chains.\\n\\n/// @dev There are two transaction types in Superform Protocol\\nenum TransactionType {\\n    DEPOSIT,\\n    WITHDRAW\\n}\\n\\n/// @dev Message types can be INIT, RETURN (for successful Deposits) and FAIL (for failed withdraws)\\nenum CallbackType {\\n    INIT,\\n    RETURN,\\n    FAIL\\n}\\n\\n/// @dev Payloads are stored, updated (deposits) or processed (finalized)\\nenum PayloadState {\\n    STORED,\\n    UPDATED,\\n    PROCESSED\\n}\\n\\n/// @dev contains all the common struct used for interchain token transfers.\\nstruct LiqRequest {\\n    /// @dev generated data\\n    bytes txData;\\n    /// @dev input token for deposits, desired output token on target liqDstChainId for withdraws. Must be set for\\n    /// txData to be updated on destination for withdraws\\n    address token;\\n    /// @dev intermediary token on destination. Relevant for xChain deposits where a destination swap is needed for\\n    /// validation purposes\\n    address interimToken;\\n    /// @dev what bridge to use to move tokens\\n    uint8 bridgeId;\\n    /// @dev dstChainId = liqDstchainId for deposits. For withdraws it is the target chain id for where the underlying\\n    /// is to be delivered\\n    uint64 liqDstChainId;\\n    /// @dev currently this amount is used as msg.value in the txData call.\\n    uint256 nativeAmount;\\n}\\n\\n/// @dev main struct that holds required multi vault data for an action\\nstruct MultiVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256[] superformIds;\\n    uint256[] amounts; // on deposits, amount of token to deposit on dst, on withdrawals, superpositions to burn\\n    uint256[] outputAmounts; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqRequests; // if length = 1; amount = sum(amounts) | else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev main struct that holds required single vault data for an action\\nstruct SingleVaultSFData {\\n    // superformids must have same destination. Can have different underlyings\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount; // on deposits, amount of shares to receive, on withdrawals, amount of assets to receive\\n    uint256 maxSlippage;\\n    LiqRequest liqRequest; // if length = 1; amount = sum(amounts)| else  amounts must match the amounts being sent\\n    bytes permit2data;\\n    bool hasDstSwap;\\n    bool retain4626; // if true, we don't mint SuperPositions, and send the 4626 back to the user instead\\n    address receiverAddress;\\n    /// this address must always be an EOA otherwise funds may be lost\\n    address receiverAddressSP;\\n    /// this address can be a EOA or a contract that implements onERC1155Receiver. must always be set for deposits\\n    bytes extraFormData; // extraFormData\\n}\\n\\n/// @dev overarching struct for multiDst requests with multi vaults\\nstruct MultiDstMultiVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    MultiVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with multi vaults\\nstruct SingleXChainMultiVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    MultiVaultSFData superformsData;\\n}\\n\\n/// @dev overarching struct for multiDst requests with single vaults\\nstruct MultiDstSingleVaultStateReq {\\n    uint8[][] ambIds;\\n    uint64[] dstChainIds;\\n    SingleVaultSFData[] superformsData;\\n}\\n\\n/// @dev overarching struct for single cross chain requests with single vaults\\nstruct SingleXChainSingleVaultStateReq {\\n    uint8[] ambIds;\\n    uint64 dstChainId;\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with single vaults\\nstruct SingleDirectSingleVaultStateReq {\\n    SingleVaultSFData superformData;\\n}\\n\\n/// @dev overarching struct for single direct chain requests with multi vaults\\nstruct SingleDirectMultiVaultStateReq {\\n    MultiVaultSFData superformData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\n/// @dev realize that receiverAddressSP is not passed, only needed on source chain to mint\\nstruct InitMultiVaultData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n    uint256[] outputAmounts;\\n    uint256[] maxSlippages;\\n    LiqRequest[] liqData;\\n    bool[] hasDstSwaps;\\n    bool[] retain4626s;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for SuperRouter with re-arranged data for the message (contains the payloadId)\\nstruct InitSingleVaultData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 outputAmount;\\n    uint256 maxSlippage;\\n    LiqRequest liqData;\\n    bool hasDstSwap;\\n    bool retain4626;\\n    address receiverAddress;\\n    bytes extraFormData;\\n}\\n\\n/// @dev struct for Emergency Queue\\nstruct QueuedWithdrawal {\\n    address receiverAddress;\\n    uint256 superformId;\\n    uint256 amount;\\n    uint256 srcPayloadId;\\n    bool isProcessed;\\n}\\n\\n/// @dev all statuses of the timelock payload\\nenum TimelockStatus {\\n    UNAVAILABLE,\\n    PENDING,\\n    PROCESSED\\n}\\n\\n/// @dev holds information about the timelock payload\\nstruct TimelockPayload {\\n    uint8 isXChain;\\n    uint64 srcChainId;\\n    uint256 lockedTill;\\n    InitSingleVaultData data;\\n    TimelockStatus status;\\n}\\n\\n/// @dev struct that contains the type of transaction, callback flags and other identification, as well as the vaults\\n/// data in params\\nstruct AMBMessage {\\n    uint256 txInfo; // tight packing of  TransactionType txType,  CallbackType flag  if multi/single vault, registry id,\\n        // srcSender and srcChainId\\n    bytes params; // decoding txInfo will point to the right datatype of params. Refer PayloadHelper.sol\\n}\\n\\n/// @dev struct that contains the information required for broadcasting changes\\nstruct BroadcastMessage {\\n    bytes target;\\n    bytes32 messageType;\\n    bytes message;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnMultiData {\\n    uint256 payloadId;\\n    uint256[] superformIds;\\n    uint256[] amounts;\\n}\\n\\n/// @dev struct that contains info on returned data from destination\\nstruct ReturnSingleData {\\n    uint256 payloadId;\\n    uint256 superformId;\\n    uint256 amount;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs\\nstruct AMBExtraData {\\n    uint256[] gasPerAMB;\\n    bytes[] extraDataPerAMB;\\n}\\n\\n/// @dev struct that contains the data on the fees to pay to the AMBs on broadcasts\\nstruct BroadCastAMBExtraData {\\n    uint256[] gasPerDst;\\n    bytes[] extraDataPerDst;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/src/interfaces/IERC1155A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC1155 } from \\\"openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title IERC1155A\\n/// @author Zeropoint Labs\\n/// @dev Single/range based id approve capability with conversion to ERC20s\\ninterface IERC1155A is IERC1155 {\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          EVENTS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev emitted when single id approval is set\\n    event ApprovalForOne(address indexed owner, address indexed spender, uint256 id, uint256 amount);\\n\\n    /// @dev emitted when an ERC1155A id is transmuted to an aERC20\\n    event TransmutedToERC20(address indexed user, uint256 id, uint256 amount, address indexed receiver);\\n\\n    /// @dev emitted when an aERC20 is transmuted to an ERC1155 id\\n    event TransmutedToERC1155A(address indexed user, uint256 id, uint256 amount, address indexed receiver);\\n\\n    /// @dev emitted when multiple ERC1155A ids are transmuted to aERC20s\\n    event TransmutedBatchToERC20(address indexed user, uint256[] ids, uint256[] amounts, address indexed receiver);\\n\\n    /// @dev emitted when multiple aERC20s are transmuted to ERC1155A ids\\n    event TransmutedBatchToERC1155A(address indexed user, uint256[] ids, uint256[] amounts, address indexed receiver);\\n\\n    //////////////////////////////////////////////////////////////\\n    //                          ERRORS                          //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @dev thrown if aERC20 was already registered\\n    error AERC20_ALREADY_REGISTERED();\\n\\n    /// @dev thrown if aERC20 was not registered\\n    error AERC20_NOT_REGISTERED();\\n\\n    /// @dev thrown if allowance amount will be decreased below zero\\n    error DECREASED_ALLOWANCE_BELOW_ZERO();\\n\\n    /// @dev thrown if the associated ERC1155A id has not been minted before registering an aERC20\\n    error ID_NOT_MINTED_YET();\\n\\n    /// @dev thrown if there is a length mismatch in batch operations\\n    error LENGTH_MISMATCH();\\n\\n    /// @dev thrown if transfer is made to address 0\\n    error TRANSFER_TO_ADDRESS_ZERO();\\n\\n    /// @dev thrown if address is 0\\n    error ZERO_ADDRESS();\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL VIEW FUNCTIONS                     //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice Public getter for existing single id total supply\\n    /// @param id id of the ERC1155 \\n    function totalSupply(uint256 id) external view returns (uint256);\\n\\n    /// @notice Public getter to know if a token id exists\\n    /// @dev determines based on total supply for the id\\n    /// @param id id of the ERC1155 \\n    function exists(uint256 id) external view returns (bool);\\n\\n    /// @notice Public getter for existing single id approval\\n    /// @param owner address of the owner of the ERC1155A id\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    function allowance(address owner, address spender, uint256 id) external returns (uint256);\\n\\n    /// @notice handy helper to check if a AERC20 is registered\\n    /// @param id id of the ERC1155 \\n    function aERC20Exists(uint256 id) external view returns (bool);\\n\\n    /// @notice Public getter for the address of the aErc20 token for a given ERC1155 id\\n    /// @param id id of the ERC1155 to get the aErc20 token address for\\n    /// @return aERC20 address of the aErc20 token for the given ERC1155 id\\n    function getERC20TokenAddress(uint256 id) external view returns (address aERC20);\\n\\n    /// @notice Compute return string from baseURI set for this contract and unique vaultId\\n    /// @param id id of the ERC1155 \\n    function uri(uint256 id) external view returns (string memory);\\n\\n    //////////////////////////////////////////////////////////////\\n    //              EXTERNAL WRITE FUNCTIONS                    //\\n    //////////////////////////////////////////////////////////////\\n\\n    /// @notice Public function for setting single id approval\\n    /// @dev Notice `owner` param, it will always be msg.sender, see _setApprovalForOne()\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    /// @param amount amount of the ERC1155A to approve\\n    function setApprovalForOne(address spender, uint256 id, uint256 amount) external;\\n\\n    /// @notice Public function for setting multiple id approval\\n    /// @dev extension of sigle id approval\\n    /// @param spender address of the contract to approve\\n    /// @param ids ids of the ERC1155A to approve\\n    /// @param amounts amounts of the ERC1155A to approve\\n    function setApprovalForMany(address spender, uint256[] memory ids, uint256[] memory amounts) external;\\n\\n    /// @notice Public function for increasing single id approval amount\\n    /// @dev Re-adapted from ERC20\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    /// @param addedValue amount of the allowance to increase by \\n    function increaseAllowance(address spender, uint256 id, uint256 addedValue) external returns (bool);\\n\\n    /// @notice Public function for decreasing single id approval amount\\n    /// @dev Re-adapted from ERC20\\n    /// @param spender address of the contract to approve\\n    /// @param id id of the ERC1155A to approve\\n    /// @param subtractedValue amount of the allowance to decrease by \\n    function decreaseAllowance(address spender, uint256 id, uint256 subtractedValue) external returns (bool);\\n\\n    /// @notice Public function for increasing multiple id approval amount at once\\n    /// @dev extension of single id increase allowance\\n    /// @param spender address of the contract to approve\\n    /// @param ids ids of the ERC1155A to approve\\n    /// @param addedValues amounts of the allowance to increase by \\n    function increaseAllowanceForMany(\\n        address spender,\\n        uint256[] memory ids,\\n        uint256[] memory addedValues\\n    )\\n        external\\n        returns (bool);\\n\\n    /// @notice Public function for decreasing multiple id approval amount at once\\n    /// @dev extension of single id decrease allowance\\n    /// @param spender address of the contract to approve\\n    /// @param ids ids of the ERC1155A to approve\\n    /// @param subtractedValues amounts of the allowance to decrease by \\n    function decreaseAllowanceForMany(\\n        address spender,\\n        uint256[] memory ids,\\n        uint256[] memory subtractedValues\\n    )\\n        external\\n        returns (bool);\\n\\n    /// @notice Turn ERC1155A id into an aERC20\\n    /// @dev allows owner to send ERC1155A id as an aERC20 to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param id id of the ERC20s to transmute to aERC20\\n    /// @param amount amount of the ERC20s to transmute to aERC20\\n    /// @param receiver address of the user to receive the aERC20 token\\n    function transmuteToERC20(address owner, uint256 id, uint256 amount, address receiver) external;\\n\\n    /// @notice Turn aERC20 into an ERC1155A id \\n    /// @dev allows owner to send ERC20 as an ERC1155A id to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param id id of the ERC20s to transmute to erc1155\\n    /// @param amount amount of the ERC20s to transmute to erc1155\\n    /// @param receiver address of the user to receive the erc1155 token id\\n    function transmuteToERC1155A(address owner, uint256 id, uint256 amount, address receiver) external;\\n\\n    /// @notice Turn ERC1155A ids into aERC20s\\n    /// @dev allows owner to send ERC1155A ids as aERC20s to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param ids ids of the ERC1155A to transmute\\n    /// @param amounts amounts of the ERC1155A to transmute\\n    /// @param receiver address of the user to receive the aERC20 tokens\\n    function transmuteBatchToERC20(address owner, uint256[] memory ids, uint256[] memory amounts, address receiver) external;\\n\\n    /// @notice Turn aERC20s into ERC1155A ids\\n    /// @dev allows owner to send aERC20s as ERC1155A ids to receiver\\n    /// @param owner address of the user on whose behalf this transmutation is happening\\n    /// @param ids ids of the ERC20 to transmute\\n    /// @param amounts amounts of the ERC20 to transmute\\n    /// @param receiver address of the user to receive the ERC1155 token ids\\n    function transmuteBatchToERC1155A(address owner, uint256[] memory ids, uint256[] memory amounts, address receiver) external;\\n\\n    /// @notice payable to allow any implementing cross-chain protocol to be paid for fees for broadcasting\\n    /// @dev should emit any required events inside _registerAERC20 internal function\\n    /// @param id of the ERC1155 to create a ERC20 for\\n    function registerAERC20(uint256 id) external payable returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/src/interfaces/IaERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC20 } from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title IaERC20\\n/// @author Zeropoint Labs\\n/// @dev ERC20 tokens out of 1155A\\ninterface IaERC20 is IERC20 {\\n\\n    /// @dev thrown if ERC1155A is not caller for mint/burn in transmute\\n    error ONLY_ERC1155A();\\n\\n    /// @dev allows msg.sender set in constructor to mint\\n    /// @param owner address of the owner of the tokens\\n    /// @param amount amount of tokens to mint\\n    function mint(address owner, uint256 amount) external;\\n\\n    /// @dev allows msg.sender set in constructor to burn\\n    /// @param owner address of the owner of the tokens\\n    /// @param operator address of the operator of the tokens\\n    /// @param amount amount of tokens to burn\\n    function burn(address owner, address operator, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Math} from \\\"./math/Math.sol\\\";\\nimport {SignedMath} from \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/interfaces/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../token/ERC1155/IERC1155.sol\\\";\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/interfaces/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155MetadataURI} from \\\"../token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC6093.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC-20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC-721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC-1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC-20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the ERC may not emit\\n * these events, as it isn't required by the specification.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the ERC. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     * ```\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4626.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC-4626 \\\"Tokenized Vault Standard\\\", as defined in\\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\\n */\\ninterface IERC4626 is IERC20, IERC20Metadata {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC-1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[ERC].\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\\n     * reentrancy guards when interacting with untrusted contracts.\\n     *\\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `values` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return a == 0 ? 0 : (a - 1) / b + 1;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC1155} from \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[ERC].\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155A/lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"solmate/=lib/ERC1155A/lib/solmate/src/\",\r\n      \"@openzeppelin/contracts/=lib/ERC1155A/lib/openzeppelin-contracts/contracts/\",\r\n      \"ERC1155A/=lib/ERC1155A/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/ERC1155A/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/ERC1155A/lib/openzeppelin-contracts/\",\r\n      \"pigeon/=lib/pigeon/src/\",\r\n      \"solady/=lib/pigeon/lib/solady/\",\r\n      \"super-vaults/=lib/super-vaults/src/\",\r\n      \"v2-core/=lib/super-vaults/lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/super-vaults/lib/v2-periphery/contracts/\",\r\n      \"v3-core/=lib/super-vaults/lib/v3-core/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dynamicURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"superRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AERC20_ALREADY_REGISTERED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AERC20_NOT_REGISTERED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ARRAY_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLOCK_CHAIN_ID_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DECREASED_ALLOWANCE_BELOW_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DYNAMIC_URI_FROZEN\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ERC1155InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"valuesLength\",\"type\":\"uint256\"}],\"name\":\"ERC1155InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidOperator\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC1155InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ERC1155MissingApprovalForAll\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FAILED_TO_SEND_NATIVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ID_NOT_MINTED_YET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BROADCAST_FEE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_CHAIN_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_MESSAGE_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PAYLOAD_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_BROADCAST_REGISTRY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_MINTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_MINTER_STATE_REGISTRY_ROLE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PROTOCOL_ADMIN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_SUPERFORM_ROUTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SRC_TX_TYPE_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SUPERFORM_ID_NONEXISTENT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TRANSFER_TO_ADDRESS_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TX_HISTORY_NOT_FOUND\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"AERC20TokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApprovalForOne\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"name\":\"Completed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"oldURI\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"DynamicURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"TransmutedBatchToERC1155A\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"TransmutedBatchToERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"TransmutedToERC1155A\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"TransmutedToERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payloadId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txInfo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"}],\"name\":\"TxHistorySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"aERC20Exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"aErc20TokenId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"aErc20Token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcSender_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcSender_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"burnSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"subtractedValues\",\"type\":\"uint256[]\"}],\"name\":\"decreaseAllowanceForMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicURIFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getERC20TokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"addedValues\",\"type\":\"uint256[]\"}],\"name\":\"increaseAllowanceForMany\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiverAddressSP_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiverAddressSP_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"mintSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"registerAERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setApprovalForMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setApprovalForOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"dynamicURI_\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"freeze_\",\"type\":\"bool\"}],\"name\":\"setDynamicURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"txInfo\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct AMBMessage\",\"name\":\"data_\",\"type\":\"tuple\"}],\"name\":\"stateMultiSync\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId_\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"txInfo\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"internalType\":\"struct AMBMessage\",\"name\":\"data_\",\"type\":\"tuple\"}],\"name\":\"stateSync\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"srcChainId_\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"stateSyncBroadcast\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superRegistry\",\"outputs\":[{\"internalType\":\"contract ISuperRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transmuteBatchToERC1155A\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transmuteBatchToERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transmuteToERC1155A\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transmuteToERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"txHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txInfo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payloadId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txInfo_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiverAddressSP_\",\"type\":\"address\"}],\"name\":\"updateTxHistory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xChainPayloadCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SuperPositions", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000b97612a25491e34f5fd11d521c14a042eca039fa000000000000000000000000000000000000000000000000000000000000006c68747470733a2f2f697066732d676174657761792e7375706572666f726d2e78797a2f69706e732f6b3531717a693575717535646739306671646f396a36336d353536776c6464657578346d6c67797974687033307a6f7573676833687568797a6f757971382f4a534f4e2f0000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}