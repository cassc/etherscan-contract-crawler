{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BNBMario.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a);\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary Percent {\\r\\n    struct percent {\\r\\n        uint256 num;\\r\\n        uint256 den;\\r\\n    }\\r\\n\\r\\n    function mul(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        return (a * p.num) / p.den;\\r\\n    }\\r\\n\\r\\n    function div(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        return (a / p.num) * p.den;\\r\\n    }\\r\\n\\r\\n    function sub(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        uint256 b = mul(p, a);\\r\\n        if (b >= a) return 0;\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function add(percent storage p, uint256 a) internal view returns (uint256) {\\r\\n        return a + mul(p, a);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract BNBMario is ReentrancyGuard {\\r\\n    using SafeMath for uint256;\\r\\n    using Percent for Percent.percent;\\r\\n\\r\\n    struct Plan {\\r\\n        Percent.percent daily;\\r\\n        Percent.percent max_payout;\\r\\n        Percent.percent additional;\\r\\n        uint256 max_additional;\\r\\n        bool reqiure_previous;\\r\\n        uint256 require_total_invested;\\r\\n        uint256 min_deposit;\\r\\n        uint256 max_deposit;\\r\\n        uint256 min_withdraw;\\r\\n    }\\r\\n\\r\\n    struct User {\\r\\n        address sponsor;\\r\\n        uint256 bonus;\\r\\n        uint256 deposited;\\r\\n        uint256 reinvested;\\r\\n        uint256 turnover_bonus;\\r\\n        uint256 turnover;\\r\\n        uint256 withdrawn;\\r\\n        uint256 withdraw_ref_date;\\r\\n        mapping(uint256 => uint256) referrals;\\r\\n    }\\r\\n\\r\\n    struct UserPlan {\\r\\n        uint256 pending;\\r\\n        uint256 pending_payout;\\r\\n        uint256 deposited;\\r\\n        uint256 withdrawn_payout;\\r\\n        uint256 withdraw_date;\\r\\n        uint256 last_date;\\r\\n    }\\r\\n\\r\\n    modifier onlyUser {\\r\\n        require(msg.sender == tx.origin);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    uint256 private ONE_DAY = 1 days;\\r\\n    uint256 private MIN_BONUS_WITHDRAWAL = 5e16; // 0.05 BNB\\r\\n    uint256 private TURNOVER_BONUS_EVERY = 200e18; // 200 BNB\\r\\n    uint256 private TURNOVER_BONUS_AMOUNT = 20e18; // 20 BNB\\r\\n    uint256 private DAILY_PLAN_WITHDRAWAL_LIMIT = 5e18; // 5 BNB\\r\\n\\r\\n    address payable private owner;\\r\\n    address payable private promote1;\\r\\n    address payable private promote2;\\r\\n\\r\\n    Percent.percent private ADMIN_FEE = Percent.percent(8, 100);\\r\\n    Percent.percent private WITHDRAW_REINVEST = Percent.percent(20, 100);\\r\\n\\r\\n    Percent.percent[5] private PERCENT_REFERRAL;\\r\\n    Plan[6] private PLANS;\\r\\n\\r\\n    mapping(address => User) public users;\\r\\n    mapping(address => mapping(uint256 => UserPlan)) public user_plans;\\r\\n\\r\\n    uint256 public total_withdrawn;\\r\\n    uint256 public total_deposited;\\r\\n    uint256 public total_rewards;\\r\\n    uint256 public total_reinvested;\\r\\n    uint256 public total_users;\\r\\n\\r\\n    event Sponsor(address indexed addr, address indexed sponsor);\\r\\n    event Deposit(address indexed addr, uint256 plan, uint256 amount);\\r\\n    event Reinvest(address indexed addr, uint256 plan, uint256 amount);\\r\\n    event Payout(address indexed addr, address indexed from, uint256 amount);\\r\\n    event Withdraw(address indexed addr, uint256 plan, uint256 amount);\\r\\n\\r\\n    constructor(address _promote1, address _promote2) {\\r\\n        promote1 = payable(_promote1);\\r\\n        promote2 = payable(_promote2);\\r\\n\\r\\n        owner = payable(_promote1);\\r\\n\\r\\n        // Set referral levels\\r\\n        PERCENT_REFERRAL[0] = Percent.percent(7, 100);\\r\\n        PERCENT_REFERRAL[1] = Percent.percent(3, 100);\\r\\n        PERCENT_REFERRAL[2] = Percent.percent(2, 100);\\r\\n        PERCENT_REFERRAL[3] = Percent.percent(2, 100);\\r\\n        PERCENT_REFERRAL[4] = Percent.percent(1, 100);\\r\\n\\r\\n        // Mario\\r\\n        PLANS[0] = Plan(\\r\\n            Percent.percent(12, 1000), // Daily ROI - 1.2%\\r\\n            Percent.percent(140, 100), // Full ROI - 140%\\r\\n            Percent.percent(1, 1000), // Daily Hold - 0.1%\\r\\n            10, // Max Hold - 10 days (1%)\\r\\n            true, // Require previous plan\\r\\n            0, // Require total invested\\r\\n            5e16, // Min deposit - 0.05 BNB\\r\\n            4e18, // Max deposit - 4 BNB\\r\\n            1e16 // Min withdraw - 0.01 BNB\\r\\n        );\\r\\n\\r\\n        // Big Mario\\r\\n        PLANS[1] = Plan(\\r\\n            Percent.percent(14, 1000), // Daily ROI - 1.4%\\r\\n            Percent.percent(200, 100), // Full ROI - 200%\\r\\n            Percent.percent(1, 1000), // Daily Hold - 0.1%\\r\\n            10, // Max Hold - 10 days (1%)\\r\\n            true, // Require previous plan\\r\\n            0, // Require total invested\\r\\n            4e18, // Min deposit - 4 BNB\\r\\n            10e18, // Max deposit - 10 BNB\\r\\n            1e16 // Min withdraw - 0.01 BNB\\r\\n        );\\r\\n\\r\\n        // Fire Mario\\r\\n        PLANS[2] = Plan(\\r\\n            Percent.percent(16, 1000), // Daily ROI - 1.6%\\r\\n            Percent.percent(250, 100), // Full ROI - 250%\\r\\n            Percent.percent(1, 1000), // Daily Hold - 0.1%\\r\\n            10, // Max Hold - 10 days (1%)\\r\\n            true, // Require previous plan\\r\\n            0, // Require total invested\\r\\n            10e18, // Min deposit - 10 BNB\\r\\n            20e18, // Max deposit - 20 BNB\\r\\n            1e16 // Min withdraw - 0.01 BNB\\r\\n        );\\r\\n\\r\\n        // Mario & Yoshi\\r\\n        PLANS[3] = Plan(\\r\\n            Percent.percent(18, 1000), // Daily ROI - 1.8%\\r\\n            Percent.percent(300, 100), // Full ROI - 300%\\r\\n            Percent.percent(1, 1000), // Daily Hold - 0.1%\\r\\n            10, // Max Hold - 10 days (1%)\\r\\n            true, // Require previous plan\\r\\n            0, // Require total invested\\r\\n            20e18, // Min deposit - 20 BNB\\r\\n            50e18, // Max deposit - 50 BNB\\r\\n            1e16 // Min withdraw - 0.01 BNB\\r\\n        );\\r\\n\\r\\n        // Luigi\\r\\n        PLANS[4] = Plan(\\r\\n            Percent.percent(2, 100), // Daily ROI - 2%\\r\\n            Percent.percent(300, 100), // Full ROI - 300%\\r\\n            Percent.percent(1, 1000), // Daily Hold - 0.1%\\r\\n            10, // Max Hold - 10 days (1%)\\r\\n            false, // Require previous plan\\r\\n            2000e18, // Require total invested - 2000 BNB\\r\\n            20e18, // Min deposit - 20 BNB\\r\\n            70e18, // Max deposit - 70 BNB\\r\\n            1e16 // Min withdraw - 0.01 BNB\\r\\n        );\\r\\n\\r\\n        // Rosalina\\r\\n        PLANS[5] = Plan(\\r\\n            Percent.percent(25, 1000), // Daily ROI - 2.5%\\r\\n            Percent.percent(350, 100), // Full ROI - 350%\\r\\n            Percent.percent(1, 1000), // Daily Hold - 0.1%\\r\\n            10, // Max Hold - 10 days (1%)\\r\\n            false, // Require previous plan\\r\\n            5000e18, // Require total invested - 5000 BNB\\r\\n            50e18, // Min deposit - 50 BNB\\r\\n            100e18, // Max deposit - 100 BNB\\r\\n            1e16 // Min withdraw - 0.01 BNB\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _setSponsor(address _addr, address _sponsor) private {\\r\\n        if (\\r\\n            users[_addr].sponsor == address(0) &&\\r\\n            _sponsor != _addr &&\\r\\n            _addr != owner &&\\r\\n            (user_plans[_sponsor][0].last_date > 0 || _sponsor == owner)\\r\\n        ) {\\r\\n            users[_addr].sponsor = _sponsor;\\r\\n\\r\\n            emit Sponsor(_addr, _sponsor);\\r\\n\\r\\n            for (uint8 i = 0; i < PERCENT_REFERRAL.length; i++) {\\r\\n                if (_sponsor == address(0)) break;\\r\\n                users[_sponsor].referrals[i]++;\\r\\n                _sponsor = users[_sponsor].sponsor;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _deposit(uint256 _plan, address _addr, uint256 _amount) private {\\r\\n        require(_plan >= 0 && _plan < PLANS.length, \\\"Bad plan\\\");\\r\\n        require(_amount > 0, \\\"Zero amount\\\");\\r\\n        require(\\r\\n            user_plans[_addr][_plan].deposited + _amount >=\\r\\n                PLANS[_plan].min_deposit,\\r\\n            \\\"Wrong min amount\\\"\\r\\n        );\\r\\n        if (PLANS[_plan].max_deposit > 0)\\r\\n            require(\\r\\n                user_plans[_addr][_plan].deposited + _amount <=\\r\\n                    PLANS[_plan].max_deposit,\\r\\n                \\\"Wrong max amount\\\"\\r\\n            );\\r\\n        if (_plan != 0 && PLANS[_plan].reqiure_previous)\\r\\n            require(\\r\\n                user_plans[_addr][_plan - 1].deposited > 0,\\r\\n                \\\"Previous plan not activated\\\"\\r\\n            );\\r\\n        if (PLANS[_plan].require_total_invested > 0)\\r\\n            require(\\r\\n                total_deposited >= PLANS[_plan].require_total_invested,\\r\\n                \\\"Total deposited not reached\\\"\\r\\n            );\\r\\n\\r\\n        if (users[_addr].deposited == 0) total_users++;\\r\\n\\r\\n        uint256 pending = this.payoutOf(_plan, _addr);\\r\\n        if (pending > 0) user_plans[_addr][_plan].pending += pending;\\r\\n\\r\\n        user_plans[_addr][_plan].last_date = block.timestamp;\\r\\n        user_plans[_addr][_plan].deposited += _amount;\\r\\n        users[_addr].deposited += _amount;\\r\\n        total_deposited += _amount;\\r\\n\\r\\n        _refPayout(_addr, _amount);\\r\\n\\r\\n        (bool successPromote1Fee, ) = promote1.call{\\r\\n            value: ADMIN_FEE.mul(_amount) / 2\\r\\n        }(\\\"\\\");\\r\\n        require(successPromote1Fee, \\\"Transfer failed.\\\");\\r\\n\\r\\n        (bool successPromote2Fee, ) = promote2.call{\\r\\n            value: ADMIN_FEE.mul(_amount) / 2\\r\\n        }(\\\"\\\");\\r\\n        require(successPromote2Fee, \\\"Transfer failed.\\\");\\r\\n\\r\\n        emit Deposit(_addr, _plan, _amount);\\r\\n    }\\r\\n\\r\\n    function _reinvest(uint256 _plan, address _addr, uint256 _amount) private {\\r\\n        uint256 pending = this.payoutOf(_plan, _addr);\\r\\n        if (pending > 0) user_plans[_addr][_plan].pending += pending;\\r\\n\\r\\n        user_plans[_addr][_plan].last_date = block.timestamp;\\r\\n        user_plans[_addr][_plan].deposited += _amount;\\r\\n        users[_addr].reinvested += _amount;\\r\\n        total_reinvested += _amount;\\r\\n\\r\\n        emit Reinvest(_addr, _plan, _amount);\\r\\n    }\\r\\n\\r\\n    function _refPayout(address _addr, uint256 _amount) private {\\r\\n        address up = users[_addr].sponsor;\\r\\n\\r\\n        for (uint256 i = 0; i < PERCENT_REFERRAL.length; i++) {\\r\\n            if (up == address(0)) break;\\r\\n            uint256 bonus = PERCENT_REFERRAL[i].mul(_amount);\\r\\n\\r\\n            if (i == 0) {\\r\\n                users[up].turnover_bonus += _amount;\\r\\n\\r\\n                if (users[up].turnover_bonus >= TURNOVER_BONUS_EVERY) {\\r\\n                    bonus += TURNOVER_BONUS_AMOUNT;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            users[up].turnover += _amount;\\r\\n            users[up].bonus += bonus;\\r\\n            total_rewards += bonus;\\r\\n            emit Payout(up, _addr, bonus);\\r\\n            up = users[up].sponsor;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function deposit(\\r\\n        uint256 _plan,\\r\\n        address _sponsor\\r\\n    ) external payable nonReentrant onlyUser {\\r\\n        _setSponsor(msg.sender, _sponsor);\\r\\n        _deposit(_plan, msg.sender, msg.value);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 _plan) external nonReentrant onlyUser {\\r\\n        require(_plan <= PLANS.length, \\\"Invalid plan\\\");\\r\\n\\r\\n        uint256 payout = 0;\\r\\n        uint256 payoutFull = 0;\\r\\n        if (_plan == PLANS.length) {\\r\\n            payoutFull = users[msg.sender].bonus;\\r\\n            require(payoutFull > 0, \\\"Zero payout\\\");\\r\\n            require(\\r\\n                payoutFull >= MIN_BONUS_WITHDRAWAL,\\r\\n                \\\"Minimum withdrawal amount is 0.05 BNB\\\"\\r\\n            );\\r\\n\\r\\n            uint256 diff = (block.timestamp -\\r\\n                users[msg.sender].withdraw_ref_date) / ONE_DAY;\\r\\n            require(diff > 0, \\\"One withdrawal per day is allowed\\\");\\r\\n\\r\\n            users[msg.sender].bonus = 0;\\r\\n            users[msg.sender].withdraw_ref_date = block.timestamp;\\r\\n\\r\\n            payout = payoutFull;\\r\\n        } else {\\r\\n            payoutFull = this.payoutOf(_plan, msg.sender);\\r\\n            require(payoutFull > 0, \\\"Zero payout\\\");\\r\\n\\r\\n            Plan storage plan = PLANS[_plan];\\r\\n            require(\\r\\n                payoutFull >= plan.min_withdraw,\\r\\n                \\\"Wrong minimum withdrawal amount\\\"\\r\\n            );\\r\\n\\r\\n            uint256 diff = (block.timestamp -\\r\\n                user_plans[msg.sender][_plan].withdraw_date) / ONE_DAY;\\r\\n            require(diff > 0, \\\"One withdrawal per day is allowed\\\");\\r\\n\\r\\n            uint256 payoutWithLimits = 0;\\r\\n            if (payoutFull > DAILY_PLAN_WITHDRAWAL_LIMIT) {\\r\\n                payoutWithLimits = DAILY_PLAN_WITHDRAWAL_LIMIT;\\r\\n            } else {\\r\\n                payoutWithLimits = payoutFull;\\r\\n            }\\r\\n\\r\\n            uint256 reinvest = WITHDRAW_REINVEST.mul(payoutWithLimits);\\r\\n            payout = payoutWithLimits - reinvest;\\r\\n\\r\\n            user_plans[msg.sender][_plan].pending = 0;\\r\\n            user_plans[msg.sender][_plan].pending_payout = 0;\\r\\n            user_plans[msg.sender][_plan].last_date = block.timestamp;\\r\\n            user_plans[msg.sender][_plan].withdraw_date = block.timestamp;\\r\\n            user_plans[msg.sender][_plan].withdrawn_payout += payout;\\r\\n\\r\\n            _reinvest(_plan, msg.sender, reinvest);\\r\\n\\r\\n            if (payoutFull > payoutWithLimits) {\\r\\n                user_plans[msg.sender][_plan].pending =\\r\\n                    payoutFull -\\r\\n                    payoutWithLimits;\\r\\n            }\\r\\n\\r\\n            payoutFull = payoutWithLimits;\\r\\n        }\\r\\n\\r\\n        users[msg.sender].withdrawn += payoutFull;\\r\\n        total_withdrawn += payoutFull;\\r\\n\\r\\n        (bool successWithdraw, ) = msg.sender.call{value: payout}(\\\"\\\");\\r\\n        require(successWithdraw, \\\"Transfer failed.\\\");\\r\\n\\r\\n        emit Withdraw(msg.sender, _plan, payoutFull);\\r\\n    }\\r\\n\\r\\n    function maxPayoutOf(\\r\\n        uint256 _plan,\\r\\n        uint256 _amount\\r\\n    ) internal view returns (uint256) {\\r\\n        return PLANS[_plan].max_payout.mul(_amount);\\r\\n    }\\r\\n\\r\\n    function payoutOf(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) external view returns (uint256 payout) {\\r\\n        uint256 max_payout = maxPayoutOf(\\r\\n            _plan,\\r\\n            user_plans[_addr][_plan].deposited\\r\\n        );\\r\\n        if (user_plans[_addr][_plan].withdrawn_payout >= max_payout) return 0;\\r\\n        payout =\\r\\n            (dailyBonus(_plan, _addr) + holdBonus(_plan, _addr)) +\\r\\n            user_plans[_addr][_plan].pending +\\r\\n            user_plans[_addr][_plan].pending_payout;\\r\\n        if (user_plans[_addr][_plan].withdrawn_payout + payout >= max_payout)\\r\\n            return max_payout - user_plans[_addr][_plan].withdrawn_payout;\\r\\n        return payout;\\r\\n    }\\r\\n\\r\\n    function dailyBonus(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) internal view returns (uint256 percent) {\\r\\n        if (user_plans[_addr][_plan].last_date == 0) return 0;\\r\\n        return\\r\\n            (PLANS[_plan].daily.mul(user_plans[_addr][_plan].deposited) *\\r\\n                (block.timestamp - user_plans[_addr][_plan].last_date)) /\\r\\n            ONE_DAY;\\r\\n    }\\r\\n\\r\\n    function getHoldBonus(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) public view returns (uint256 percent) {\\r\\n        if (user_plans[_addr][_plan].last_date == 0) return 0;\\r\\n        uint256 ldays = block\\r\\n            .timestamp\\r\\n            .sub(user_plans[_addr][_plan].last_date)\\r\\n            .div(ONE_DAY);\\r\\n        return\\r\\n            ldays > PLANS[_plan].max_additional\\r\\n                ? PLANS[_plan].max_additional\\r\\n                : ldays;\\r\\n    }\\r\\n\\r\\n    function holdBonus(\\r\\n        uint256 _plan,\\r\\n        address _addr\\r\\n    ) internal view returns (uint256 percent) {\\r\\n        if (user_plans[_addr][_plan].last_date == 0) return 0;\\r\\n        uint256 ldays = block\\r\\n            .timestamp\\r\\n            .sub(user_plans[_addr][_plan].last_date)\\r\\n            .div(ONE_DAY);\\r\\n        if (ldays == 0) return 0;\\r\\n\\r\\n        uint256 bonus = 0;\\r\\n        uint256 holdBonusMultiplier = getHoldBonus(_plan, _addr);\\r\\n\\r\\n        for (uint256 i = 1; i <= holdBonusMultiplier; i++) {\\r\\n            if (i == 10)\\r\\n                bonus +=\\r\\n                    ((user_plans[_addr][_plan].deposited *\\r\\n                        (PLANS[_plan].additional.num * i)) /\\r\\n                        PLANS[_plan].additional.den) *\\r\\n                    (ldays - 9);\\r\\n            else\\r\\n                bonus +=\\r\\n                    (user_plans[_addr][_plan].deposited *\\r\\n                        (PLANS[_plan].additional.num * i)) /\\r\\n                    PLANS[_plan].additional.den;\\r\\n        }\\r\\n\\r\\n        return bonus;\\r\\n    }\\r\\n\\r\\n    function referralsCount(\\r\\n        address _addr,\\r\\n        uint256 _level\\r\\n    ) external view returns (uint256 referrals) {\\r\\n        return users[_addr].referrals[_level];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_promote1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_promote2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"Sponsor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sponsor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getHoldBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"payoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"referralsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"referrals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_deposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_reinvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_withdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_plans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pending_payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn_payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw_date\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw_ref_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BNBMario", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ff8d1526b03627d33ad141c376a24861be5903f3000000000000000000000000f85693f4047b9d880d44f15fc687bdf7a4b18f17", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}