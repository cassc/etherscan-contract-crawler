{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function WETH() external pure returns (address);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface ISwapPair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\nabstract contract AbsLPPool is Ownable {\r\n    struct UserInfo {\r\n        bool isActive;\r\n        uint256 amount;\r\n        uint256 rewardMintDebt;\r\n        uint256 calMintReward;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint256 totalAmount;\r\n        uint256 accMintPerShare;\r\n        uint256 accMintReward;\r\n        uint256 mintPerSec;\r\n        uint256 lastMintTime;\r\n        uint256 totalMintReward;\r\n    }\r\n\r\n    PoolInfo private poolInfo;\r\n    mapping(address => UserInfo) private userInfo;\r\n\r\n    ISwapRouter private immutable _swapRouter;\r\n    ISwapFactory private immutable _swapFactory;\r\n    address private immutable _weth;\r\n    address private immutable _usdt;\r\n\r\n    uint256 private _minAmount;\r\n    address private _mintRewardToken;\r\n    address[] private _joinTokens;\r\n\r\n    function addJoinToken(address token) external onlyWhiteList {\r\n        _joinTokens.push(token);\r\n        safeApprove(token, address(_swapRouter), ~uint256(0));\r\n    }\r\n\r\n    function setJoinToken(uint256 i, address token) external onlyWhiteList {\r\n        _joinTokens[i] = token;\r\n        safeApprove(token, address(_swapRouter), ~uint256(0));\r\n    }\r\n\r\n    function setJoinTokens(address[] memory tokens) external onlyWhiteList {\r\n        _joinTokens = tokens;\r\n        uint256 len = tokens.length;\r\n        for (uint256 i; i < len; ++i) {\r\n            safeApprove(tokens[i], address(_swapRouter), ~uint256(0));\r\n        }\r\n    }\r\n\r\n    mapping(address => address) public _invitor;\r\n    mapping(address => address[]) public _binder;\r\n    mapping(uint256 => uint256) public _inviteFee;\r\n    uint256 private constant _inviteLen = 2;\r\n    address private _defaultInvitor;\r\n    mapping(address => uint256) private _teamNum;\r\n\r\n    mapping(address => uint256) private _inviteAmount;\r\n\r\n    address public _fundAddress;\r\n\r\n    function setFundAddress(address a) external onlyWhiteList {\r\n        _fundAddress = a;\r\n    }\r\n\r\n    bool private _pauseJoin = true;\r\n    uint256 public _lastDailyUpTime;\r\n    uint256 public _lastAmountRate = 10100;\r\n    uint256 public _amountDailyUp = 100;\r\n    uint256 private constant _divFactor = 10000;\r\n    uint256 private constant _dailyDuration = 1 days;\r\n\r\n    uint256 public _sellRate = 7000;\r\n    address public _burnReceiver = address(0x000000000000000000000000000000000000dEaD);\r\n\r\n    function setSellRate(uint256 r) external onlyWhiteList {\r\n        _sellRate = r;\r\n    }\r\n\r\n    function setAutoCalSellRate(bool e) external onlyWhiteList {\r\n        _autoCalSellRate = e;\r\n    }\r\n\r\n    function setHighPrice(uint256 r) external onlyWhiteList {\r\n        _highPrice = r;\r\n    }\r\n\r\n    function setHighPriceSellRate(uint256 r) external onlyWhiteList {\r\n        _highPriceSellRate = r;\r\n    }\r\n\r\n    function setBurnReceiver(address a) external onlyWhiteList {\r\n        _burnReceiver = a;\r\n    }\r\n\r\n    function setRewardToken(address a) external onlyWhiteList {\r\n        _mintRewardToken = a;\r\n        safeApprove(a, address(_swapRouter), ~uint256(0));\r\n    }\r\n\r\n    function setAmountDailyUp(uint256 r) external onlyWhiteList {\r\n        _amountDailyUp = r;\r\n    }\r\n\r\n    function setLastDailyUpTime(uint256 t) external onlyWhiteList {\r\n        _lastDailyUpTime = t;\r\n    }\r\n\r\n    function setLastAmountRate(uint256 r) external onlyWhiteList {\r\n        _lastAmountRate = r;\r\n    }\r\n\r\n    function _updateDailyUpRate() public {\r\n        uint256 lastDailyUpTime = _lastDailyUpTime;\r\n        if (0 == lastDailyUpTime) {\r\n            return;\r\n        }\r\n        uint256 dailyDuration = _dailyDuration;\r\n        uint256 nowTime = block.timestamp;\r\n        if (nowTime < lastDailyUpTime + dailyDuration) {\r\n            return;\r\n        }\r\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\r\n        _lastDailyUpTime = lastDailyUpTime + ds * dailyDuration;\r\n        _lastAmountRate = _lastAmountRate + ds * _amountDailyUp;\r\n    }\r\n\r\n    function getDailyRate() private view returns (uint256) {\r\n        uint256 lastAmountRate = _lastAmountRate;\r\n        uint256 lastDailyUpTime = _lastDailyUpTime;\r\n        if (0 == lastDailyUpTime) {\r\n            return lastAmountRate;\r\n        }\r\n        uint256 dailyDuration = _dailyDuration;\r\n        uint256 nowTime = block.timestamp;\r\n        if (nowTime < lastDailyUpTime + dailyDuration) {\r\n            return lastAmountRate;\r\n        }\r\n        uint256 ds = (nowTime - lastDailyUpTime) / dailyDuration;\r\n        return lastAmountRate + ds * _amountDailyUp;\r\n    }\r\n\r\n    function open() external onlyWhiteList {\r\n        if (0 == _lastDailyUpTime) {\r\n            _lastDailyUpTime = block.timestamp;\r\n        }\r\n        _pauseJoin = false;\r\n    }\r\n\r\n    function close() external onlyWhiteList {\r\n        _pauseJoin = true;\r\n    }\r\n\r\n    constructor(\r\n        address SwapRouter,\r\n        address USDT,\r\n        address MintRewardToken,\r\n        address DefaultInvitor,\r\n        address FundAddress\r\n    ){\r\n        _swapRouter = ISwapRouter(SwapRouter);\r\n        _swapFactory = ISwapFactory(_swapRouter.factory());\r\n        _weth = _swapRouter.WETH();\r\n        _usdt = USDT;\r\n        require(address(0) != _swapFactory.getPair(_weth, _usdt), \"Need BNBUPool\");\r\n\r\n        uint256 usdtUnit = 10 ** IERC20(USDT).decimals();\r\n        _minAmount = 100 * usdtUnit;\r\n        _mintRewardToken = MintRewardToken;\r\n        safeApprove(MintRewardToken, address(_swapRouter), ~uint256(0));\r\n\r\n        poolInfo.lastMintTime = block.timestamp;\r\n        _defaultInvitor = DefaultInvitor;\r\n        userInfo[DefaultInvitor].isActive = true;\r\n        _inviteFee[0] = 2000;\r\n        _inviteFee[1] = 1000;\r\n\r\n        _fundAddress = FundAddress;\r\n        _highPrice = 3000 * usdtUnit;\r\n\r\n        uint256 mossUnit = 10 ** IERC20(_mintRewardToken).decimals();\r\n        _normalRewardPerDay = 10 * mossUnit;\r\n        _autoRewardConfigs.push(AutoRewardConfig(4000 * usdtUnit, 125 * mossUnit / 10, false, false));\r\n        _autoRewardConfigs.push(AutoRewardConfig(3000 * usdtUnit, 25 * mossUnit, false, false));\r\n        _autoRewardConfigs.push(AutoRewardConfig(2000 * usdtUnit, 50 * mossUnit, false, false));\r\n        _autoRewardConfigs.push(AutoRewardConfig(1000 * usdtUnit, 100 * mossUnit, false, false));\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    uint256 private _totalUsdt;\r\n\r\n    //\r\n    function deposit(uint256 i, uint256 amount, uint256 maxTokenAmount, address invitor) external {\r\n        require(!_pauseJoin, \"pause\");\r\n\r\n        require(amount >= _minAmount, \"m\");\r\n        address account = msg.sender;\r\n        require(account == tx.origin, \"notOrigin\");\r\n\r\n        _totalUsdt += amount;\r\n\r\n        _bindInvitor(account, invitor);\r\n\r\n        address token = _joinTokens[i];\r\n        uint256 tokenAmount = getJoinTokenAmount(token, amount);\r\n        require(tokenAmount <= maxTokenAmount, \"MT\");\r\n\r\n        _dueToken(token, account, tokenAmount);\r\n\r\n        _updatePool();\r\n        _addUserAmount(account, amount * _lastAmountRate / _divFactor, true);\r\n    }\r\n\r\n    function getJoinTokenAmount(address token, uint256 usdtAmount) public view returns (uint256){\r\n        (uint256 rEth, uint256 rUsdt) = __getTokenETHReserves(_usdt);\r\n        (uint256 pEth, uint256 pToken) = __getTokenETHReserves(token);\r\n        uint256 pUsdt = pEth * rUsdt / rEth;\r\n        return usdtAmount * pToken / pUsdt;\r\n    }\r\n\r\n    bool public _autoCalSellRate;\r\n    uint256 public _highPrice;\r\n    uint256 public _highPriceSellRate = 5000;\r\n\r\n    //\r\n    function _dueToken(address token, address account, uint256 tokenAmount) private {\r\n        IERC20 Token = IERC20(token);\r\n        uint256 tokenBalanceBefore = Token.balanceOf(address(this));\r\n        _takeToken(token, account, address(this), tokenAmount);\r\n        uint256 tokenAmountIn = Token.balanceOf(address(this)) - tokenBalanceBefore;\r\n        address moss = _mintRewardToken;\r\n        uint256 sellRate = getSellRate();\r\n        uint256 sellAmount = tokenAmountIn * sellRate / 10000;\r\n\r\n        _giveToken(token, _burnReceiver, tokenAmountIn - sellAmount);\r\n        if (sellAmount > 0) {\r\n            uint256 ethBalance = address(this).balance;\r\n            address[] memory path = new address[](2);\r\n            path[0] = token;\r\n            path[1] = _weth;\r\n            uint256 nowTime = block.timestamp;\r\n            _swapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                sellAmount, 0, path, address(this), nowTime\r\n            );\r\n            ethBalance = address(this).balance - ethBalance;\r\n\r\n            //\r\n            if (ethBalance > 0) {\r\n                uint256 mossLPETH = ethBalance / 2;\r\n                uint256 mossAmount = IERC20(moss).balanceOf(address(this));\r\n                path[0] = _weth;\r\n                path[1] = moss;\r\n                _swapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value : mossLPETH}(\r\n                    0, path, address(this), nowTime\r\n                );\r\n                mossAmount = IERC20(moss).balanceOf(address(this)) - mossAmount;\r\n                _swapRouter.addLiquidityETH{value : mossLPETH}(moss, mossAmount, 0, 0, _fundAddress, nowTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getSellRate() public view returns (uint256 sellRate){\r\n        sellRate = _sellRate;\r\n        address moss = _mintRewardToken;\r\n        if (_autoCalSellRate) {\r\n            if (getTokenETHPrice(moss) >= _highPrice) {\r\n                sellRate = _highPriceSellRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    function __getTokenETHReserves(address token) public view returns (uint256 rEth, uint256 rToken){\r\n        address weth = _weth;\r\n        ISwapPair pair = ISwapPair(_swapFactory.getPair(weth, token));\r\n        (uint r0, uint256 r1,) = pair.getReserves();\r\n        if (weth < token) {\r\n            rEth = r0;\r\n            rToken = r1;\r\n        } else {\r\n            rEth = r1;\r\n            rToken = r0;\r\n        }\r\n    }\r\n\r\n    //\r\n    function _addUserAmount(address account, uint256 amount, bool calInvite) private {\r\n        UserInfo storage user = userInfo[account];\r\n        _calReward(user, false);\r\n\r\n        uint256 userAmount = user.amount;\r\n        userAmount += amount;\r\n        user.amount = userAmount;\r\n\r\n        uint256 poolTotalAmount = poolInfo.totalAmount;\r\n        poolTotalAmount += amount;\r\n\r\n        uint256 poolAccMintPerShare = poolInfo.accMintPerShare;\r\n        user.rewardMintDebt = userAmount * poolAccMintPerShare / 1e18;\r\n\r\n        if (calInvite) {\r\n            uint256 len = _inviteLen;\r\n            UserInfo storage invitorInfo;\r\n            address current = account;\r\n            address invitor;\r\n            uint256 invitorTotalAmount;\r\n            for (uint256 i; i < len; ++i) {\r\n                invitor = _invitor[current];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n                invitorInfo = userInfo[invitor];\r\n\r\n                _calReward(invitorInfo, false);\r\n                uint256 inviteAmount = amount * _inviteFee[i] / 10000;\r\n                _inviteAmount[invitor] += inviteAmount;\r\n\r\n                invitorTotalAmount = invitorInfo.amount;\r\n                invitorTotalAmount += inviteAmount;\r\n                invitorInfo.amount = invitorTotalAmount;\r\n                invitorInfo.rewardMintDebt = invitorTotalAmount * poolAccMintPerShare / 1e18;\r\n\r\n                poolTotalAmount += inviteAmount;\r\n\r\n                current = invitor;\r\n            }\r\n        }\r\n        poolInfo.totalAmount = poolTotalAmount;\r\n    }\r\n\r\n    //\r\n    function addUserAmount(address account, uint256 amount, bool calInvite) public {\r\n        require(_inProject[msg.sender], \"rq project\");\r\n        _updatePool();\r\n        _addUserAmount(account, amount, calInvite);\r\n    }\r\n\r\n    //\r\n    function addMintAmount(address account, uint256 amount) external onlyWhiteList {\r\n        _updatePool();\r\n        _addUserAmount(account, amount, false);\r\n    }\r\n\r\n    //\r\n    function claim() public {\r\n        address account = msg.sender;\r\n        UserInfo storage user = userInfo[account];\r\n        _calReward(user, true);\r\n        uint256 pendingMint = user.calMintReward;\r\n        if (pendingMint > 0) {\r\n            _giveToken(_mintRewardToken, account, pendingMint);\r\n            user.calMintReward = 0;\r\n        }\r\n    }\r\n\r\n    //\r\n    function _updatePool() private {\r\n        _updateDailyUpRate();\r\n        PoolInfo storage pool = poolInfo;\r\n        uint256 blockTime = block.timestamp;\r\n        uint256 lastRewardTime = pool.lastMintTime;\r\n        if (blockTime <= lastRewardTime) {\r\n            return;\r\n        }\r\n        pool.lastMintTime = blockTime;\r\n\r\n        uint256 accReward = pool.accMintReward;\r\n        uint256 totalReward = pool.totalMintReward;\r\n        if (accReward >= totalReward) {\r\n            return;\r\n        }\r\n\r\n        uint256 totalAmount = pool.totalAmount;\r\n        uint256 rewardPerSec = pool.mintPerSec;\r\n        if (0 < totalAmount && 0 < rewardPerSec) {\r\n            uint256 reward = rewardPerSec * (blockTime - lastRewardTime);\r\n            uint256 remainReward = totalReward - accReward;\r\n            if (reward > remainReward) {\r\n                reward = remainReward;\r\n            }\r\n            pool.accMintPerShare += reward * 1e18 / totalAmount;\r\n            pool.accMintReward += reward;\r\n        }\r\n    }\r\n\r\n    //\r\n    function _calReward(UserInfo storage user, bool updatePool) private {\r\n        if (updatePool) {\r\n            _updatePool();\r\n        }\r\n        if (user.amount > 0) {\r\n            uint256 accMintReward = user.amount * poolInfo.accMintPerShare / 1e18;\r\n            uint256 pendingMintAmount = accMintReward - user.rewardMintDebt;\r\n            if (pendingMintAmount > 0) {\r\n                user.rewardMintDebt = accMintReward;\r\n                user.calMintReward += pendingMintAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getPendingMintReward(address account) public view returns (uint256 reward) {\r\n        reward = 0;\r\n        PoolInfo storage pool = poolInfo;\r\n        UserInfo storage user = userInfo[account];\r\n        if (user.amount > 0) {\r\n            uint256 poolPendingReward;\r\n            uint256 blockTime = block.timestamp;\r\n            uint256 lastRewardTime = pool.lastMintTime;\r\n            if (blockTime > lastRewardTime) {\r\n                poolPendingReward = pool.mintPerSec * (blockTime - lastRewardTime);\r\n                uint256 totalReward = pool.totalMintReward;\r\n                uint256 accReward = pool.accMintReward;\r\n                uint256 remainReward;\r\n                if (totalReward > accReward) {\r\n                    remainReward = totalReward - accReward;\r\n                }\r\n                if (poolPendingReward > remainReward) {\r\n                    poolPendingReward = remainReward;\r\n                }\r\n            }\r\n            reward = user.amount * (pool.accMintPerShare + poolPendingReward * 1e18 / pool.totalAmount) / 1e18 - user.rewardMintDebt;\r\n        }\r\n    }\r\n\r\n    function viewPoolInfo() public view returns (\r\n        uint256 totalAmount,\r\n        uint256 accMintPerShare, uint256 accMintReward,\r\n        uint256 mintPerSec, uint256 lastMintTime, uint256 totalMintReward\r\n    ) {\r\n        totalAmount = poolInfo.totalAmount;\r\n        accMintPerShare = poolInfo.accMintPerShare;\r\n        accMintReward = poolInfo.accMintReward;\r\n        mintPerSec = poolInfo.mintPerSec;\r\n        lastMintTime = poolInfo.lastMintTime;\r\n        totalMintReward = poolInfo.totalMintReward;\r\n    }\r\n\r\n    function viewUserInfo(address account) public view returns (\r\n        bool isActive, uint256 amount,\r\n        uint256 calMintReward, uint256 rewardMintDebt\r\n    ) {\r\n        UserInfo storage user = userInfo[account];\r\n        isActive = user.isActive;\r\n        amount = user.amount;\r\n        calMintReward = user.calMintReward;\r\n        rewardMintDebt = user.rewardMintDebt;\r\n    }\r\n\r\n    function getUserInfo(address account) public view returns (\r\n        uint256 amount, uint256 pendingMintReward, uint256 inviteAmount,\r\n        uint256[] memory joinTokenBalances, uint256[] memory joinTokenAllowances,\r\n        uint256 teamNum\r\n    ) {\r\n        UserInfo storage user = userInfo[account];\r\n        amount = user.amount;\r\n        pendingMintReward = getPendingMintReward(account) + user.calMintReward;\r\n        inviteAmount = _inviteAmount[account];\r\n        uint256 len = _joinTokens.length;\r\n        joinTokenBalances = new uint256[](len);\r\n        joinTokenAllowances = new uint256[](len);\r\n        for (uint256 i; i < len; ++i) {\r\n            joinTokenBalances[i] = IERC20(_joinTokens[i]).balanceOf(account);\r\n            joinTokenAllowances[i] = IERC20(_joinTokens[i]).allowance(account, address(this));\r\n        }\r\n        teamNum = _teamNum[account];\r\n    }\r\n\r\n    function getBaseInfo() external view returns (\r\n        address usdt,\r\n        uint256 usdtDecimals,\r\n        address mintRewardToken,\r\n        uint256 mintRewardTokenDecimals,\r\n        uint256 totalUsdt,\r\n        uint256 totalAmount,\r\n        uint256 lastDailyReward,\r\n        uint256 dailyAmountRate,\r\n        uint256 minAmount,\r\n        address defaultInvitor,\r\n        bool pauseJoin,\r\n        uint256 rewardTokenPrice,\r\n        uint256 sellRate\r\n    ){\r\n        usdt = _usdt;\r\n        usdtDecimals = IERC20(usdt).decimals();\r\n        mintRewardToken = _mintRewardToken;\r\n        mintRewardTokenDecimals = IERC20(mintRewardToken).decimals();\r\n        totalUsdt = _totalUsdt;\r\n        totalAmount = poolInfo.totalAmount;\r\n        lastDailyReward = _lastDailyReward;\r\n        dailyAmountRate = getDailyRate();\r\n        minAmount = _minAmount;\r\n        defaultInvitor = _defaultInvitor;\r\n        pauseJoin = _pauseJoin;\r\n        rewardTokenPrice = getTokenETHPrice(mintRewardToken);\r\n        sellRate = getSellRate();\r\n    }\r\n\r\n    function getTokenETHPrice(address token) public view returns (uint256 price){\r\n        (uint256 rEth, uint256 rUsdt) = __getTokenETHReserves(_usdt);\r\n        (uint256 pEth, uint256 pToken) = __getTokenETHReserves(token);\r\n        uint256 pUsdt = pEth * rUsdt / rEth;\r\n        if (pToken > 0) {\r\n            return 10 ** IERC20(token).decimals() * pUsdt / pToken;\r\n        }\r\n    }\r\n\r\n    function getBinderLength(address account) public view returns (uint256){\r\n        return _binder[account].length;\r\n    }\r\n\r\n    //\r\n    function setTotalMintReward(uint256 reward) external onlyWhiteList {\r\n        _updatePool();\r\n        poolInfo.totalMintReward = reward;\r\n    }\r\n\r\n    uint256 private _lastDailyReward;\r\n\r\n    //\r\n    function setRewardPerDay(uint256 reward) external onlyWhiteList {\r\n        _autoCalRewardPerDay = false;\r\n        _setRewardPerDay(reward);\r\n    }\r\n\r\n    function _setRewardPerDay(uint256 reward) private {\r\n        _updatePool();\r\n        poolInfo.mintPerSec = reward / _dailyDuration;\r\n        _lastDailyReward = reward;\r\n    }\r\n\r\n    //\r\n    function setInviteFee(uint256 i, uint256 fee) external onlyWhiteList {\r\n        _inviteFee[i] = fee;\r\n    }\r\n\r\n    function claimBalance(address to, uint256 amount) external onlyWhiteList {\r\n        safeTransferETH(to, amount);\r\n    }\r\n\r\n    function claimToken(address token, address to, uint256 amount) external onlyWhiteList {\r\n        _giveToken(token, to, amount);\r\n    }\r\n\r\n    function setDefaultInvitor(address adr) external onlyWhiteList {\r\n        _defaultInvitor = adr;\r\n        userInfo[adr].isActive = true;\r\n    }\r\n\r\n    mapping(address => bool) public _inProject;\r\n\r\n    function setInProject(address adr, bool enable) external onlyWhiteList {\r\n        _inProject[adr] = enable;\r\n    }\r\n\r\n    function bindInvitor(address account, address invitor) public {\r\n        address caller = msg.sender;\r\n        require(_inProject[caller], \"NA\");\r\n        _bindInvitor(account, invitor);\r\n    }\r\n\r\n    function _bindInvitor(address account, address invitor) private {\r\n        UserInfo storage user = userInfo[account];\r\n        if (!user.isActive) {\r\n            require(address(0) != invitor, \"invitor 0\");\r\n            require(userInfo[invitor].isActive, \"invitor !Active\");\r\n            _invitor[account] = invitor;\r\n            _binder[invitor].push(account);\r\n            user.isActive = true;\r\n            for (uint256 i; i < _inviteLen;) {\r\n                _teamNum[invitor] += 1;\r\n                invitor = _invitor[invitor];\r\n                if (address(0) == invitor) {\r\n                    break;\r\n                }\r\n            unchecked{\r\n                ++i;\r\n            }\r\n            }\r\n        }\r\n    }\r\n\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'AF');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TF');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value : value}(new bytes(0));\r\n        require(success, 'ETF');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TFF');\r\n    }\r\n\r\n    function _giveToken(address tokenAddress, address account, uint256 amount) private {\r\n        if (0 == amount) {\r\n            return;\r\n        }\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(token.balanceOf(address(this)) >= amount, \"PTNE\");\r\n        safeTransfer(tokenAddress, account, amount);\r\n    }\r\n\r\n    function _takeToken(address tokenAddress, address from, address to, uint256 tokenNum) private {\r\n        IERC20 token = IERC20(tokenAddress);\r\n        require(token.balanceOf(address(from)) >= tokenNum, \"TNE\");\r\n        safeTransferFrom(tokenAddress, from, to, tokenNum);\r\n    }\r\n\r\n    modifier onlyWhiteList() {\r\n        address msgSender = msg.sender;\r\n        require(msgSender == _fundAddress || msgSender == _owner, \"nw\");\r\n        _;\r\n    }\r\n\r\n    function getJoinTokens() public view returns (\r\n        address[] memory tokens, uint256[] memory tokenDecimals, string[] memory tokenSymbols,\r\n        uint256[] memory poolUsdts, uint256[] memory poolTokens\r\n    ) {\r\n        uint256 len = _joinTokens.length;\r\n        tokens = new address[](len);\r\n        tokenDecimals = new uint256[](len);\r\n        tokenSymbols = new string[](len);\r\n        poolUsdts = new uint256[](len);\r\n        poolTokens = new uint256[](len);\r\n        (uint256 rEth, uint256 rUsdt) = __getTokenETHReserves(_usdt);\r\n        for (uint256 i; i < len; ++i) {\r\n            tokens[i] = _joinTokens[i];\r\n            tokenDecimals[i] = IERC20(tokens[i]).decimals();\r\n            tokenSymbols[i] = IERC20(tokens[i]).symbol();\r\n            (uint256 poolEth, uint256 poolToken) = __getTokenETHReserves(tokens[i]);\r\n            poolUsdts[i] = poolEth * rUsdt / rEth;\r\n            poolTokens[i] = poolToken;\r\n        }\r\n    }\r\n\r\n    bool public _autoCalRewardPerDay;\r\n    uint256 public _normalRewardPerDay;\r\n    AutoRewardConfig[] private _autoRewardConfigs;\r\n\r\n    struct AutoRewardConfig {\r\n        uint256 price;\r\n        uint256 rewardPerDay;\r\n        //\r\n        bool upped;\r\n        //\r\n        bool dropped;\r\n    }\r\n\r\n    function clearConfig() external onlyWhiteList {\r\n        uint256 len = _autoRewardConfigs.length;\r\n        for (uint256 i; i < len; ++i) {\r\n            _autoRewardConfigs.pop();\r\n        }\r\n    }\r\n\r\n    function addConfig(uint256 price, uint256 reward) external onlyWhiteList {\r\n        _autoRewardConfigs.push(AutoRewardConfig(price, reward, false, false));\r\n    }\r\n\r\n    function setConfigUpped(uint256 i, bool e) external onlyWhiteList {\r\n        _autoRewardConfigs[i].upped = e;\r\n    }\r\n\r\n    function setConfigDropped(uint256 i, bool e) external onlyWhiteList {\r\n        _autoRewardConfigs[i].dropped = e;\r\n    }\r\n\r\n    function setConfigPrice(uint256 i, uint256 price) external onlyWhiteList {\r\n        _autoRewardConfigs[i].price = price;\r\n    }\r\n\r\n    function setConfigRewardPerDay(uint256 i, uint256 rewardPerDay) external onlyWhiteList {\r\n        _autoRewardConfigs[i].rewardPerDay = rewardPerDay;\r\n    }\r\n\r\n    function _calAutoReward() private returns (uint256 reward){\r\n        reward = _normalRewardPerDay;\r\n        //\r\n        uint256 len = _autoRewardConfigs.length;\r\n        uint256 mossPrice = getTokenETHPrice(_mintRewardToken);\r\n        AutoRewardConfig storage rewardConfig;\r\n        //\r\n        for (uint256 i; i < len; ++i) {\r\n            rewardConfig = _autoRewardConfigs[i];\r\n            if (mossPrice >= rewardConfig.price) {//\r\n                //\r\n                rewardConfig.upped = true;\r\n                if (!rewardConfig.dropped) {//\r\n                    reward = rewardConfig.rewardPerDay;\r\n                    break;\r\n                }\r\n                //\r\n            } else {//\r\n                if (rewardConfig.upped) {//\r\n                    //\r\n                    rewardConfig.dropped = true;\r\n                }\r\n                //\r\n            }\r\n        }\r\n        //\r\n    }\r\n\r\n    //\r\n    function updateRewardPerDay() public {\r\n        if (!_autoCalRewardPerDay) {\r\n            return;\r\n        }\r\n        uint256 reward = _calAutoReward();\r\n        _setRewardPerDay(reward);\r\n    }\r\n\r\n    function setAutoCalRewardPerDay(bool e) external onlyWhiteList {\r\n        _autoCalRewardPerDay = e;\r\n    }\r\n\r\n    function setNormalRewardPerDay(uint256 r) external onlyWhiteList {\r\n        _normalRewardPerDay = r;\r\n    }\r\n\r\n    function getAutoRewardConfigs() public view returns (\r\n        uint256[] memory prices, uint256[] memory rewards, bool[] memory uppeds, bool[] memory droppeds\r\n    ) {\r\n        uint256 len = _autoRewardConfigs.length;\r\n        prices = new uint256[](len);\r\n        rewards = new uint256[](len);\r\n        uppeds = new bool[](len);\r\n        droppeds = new bool[](len);\r\n        for (uint256 i; i < len; ++i) {\r\n            AutoRewardConfig storage rewardConfig = _autoRewardConfigs[i];\r\n            prices[i] = rewardConfig.price;\r\n            rewards[i] = rewardConfig.rewardPerDay;\r\n            uppeds[i] = rewardConfig.upped;\r\n            droppeds[i] = rewardConfig.dropped;\r\n        }\r\n    }\r\n}\r\n\r\ncontract MintPool is AbsLPPool {\r\n    constructor() AbsLPPool(\r\n    //SwapRouter\r\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\r\n    //USDT\r\n        address(0x55d398326f99059fF775485246999027B3197955),\r\n    //MOSS\r\n        address(0xC651Cf5Dd958B6D7E4c417F1f366659237C34166),\r\n    //DefaultInvitor\r\n        address(0x7a46b44Eb5aebE29F0950e89366b87F558d2E988),\r\n    //Fund\r\n        address(0x26944342DE6c482bc5f93Fa094dE659DA2433639)\r\n    ){\r\n\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"__getTokenETHReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_amountDailyUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoCalRewardPerDay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoCalSellRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_binder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_burnReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fundAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_highPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_highPriceSellRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_inProject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_inviteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_invitor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastAmountRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lastDailyUpTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_normalRewardPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_updateDailyUpRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"addConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addJoinToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addMintAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"calInvite\",\"type\":\"bool\"}],\"name\":\"addUserAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"bindInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"invitor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutoRewardConfigs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewards\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"uppeds\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"droppeds\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBaseInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdtDecimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mintRewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintRewardTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUsdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDailyReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyAmountRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"defaultInvitor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"pauseJoin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rewardTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBinderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"}],\"name\":\"getJoinTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getJoinTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenDecimals\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"tokenSymbols\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"poolUsdts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"poolTokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingMintReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sellRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inviteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"joinTokenBalances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"joinTokenAllowances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setAmountDailyUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"e\",\"type\":\"bool\"}],\"name\":\"setAutoCalRewardPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"e\",\"type\":\"bool\"}],\"name\":\"setAutoCalSellRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setBurnReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"e\",\"type\":\"bool\"}],\"name\":\"setConfigDropped\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setConfigPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerDay\",\"type\":\"uint256\"}],\"name\":\"setConfigRewardPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"e\",\"type\":\"bool\"}],\"name\":\"setConfigUpped\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setDefaultInvitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setFundAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setHighPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setHighPriceSellRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setInProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setInviteFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setJoinToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"setJoinTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setLastAmountRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setLastDailyUpTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setNormalRewardPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"setRewardPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"setSellRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"setTotalMintReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewardPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPerSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastMintTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMintReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"viewUserInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calMintReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardMintDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MintPool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://25769cf9cafc0846026aebadb1d8400237fbc4550614685544e996ece1ec1a31"}