{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BioticGenerator.sol/BioFarm_State.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./IBioticGenerator.sol\\\";\\n\\ncontract BioFarm_State is Ownable, IBioticGenerator {\\n    using SafeMath for uint;\\n    // 1000 == 100%, 100 == 10%, 10 == 1%, 1 == 0.1%\\n    uint internal constant REFERRAL_LEGNTH = 5;\\n    uint[REFERRAL_LEGNTH] internal REFERRAL_PERCENTS = [80, 30, 20, 15, 5];\\n    uint internal INVEST_MIN_AMOUNT = 0.045 ether;\\n    // uint constant internal INVEST_FEE = 120;\\n    // uint internal constant WITHDRAW_FEE_PERCENT = 100;\\n    uint internal constant MIN_WITHDRAW = 1;\\n    uint internal constant PERCENTS_DIVIDER = 1_000;\\n    uint internal constant TIME_STEP = 1 days;\\n    uint internal constant MEMBRECY_STEP = 30 * TIME_STEP;\\n    uint internal constant CYCLE_STEP = 30 * TIME_STEP;\\n    // 2400 == 240%\\n    uint internal constant MAX_PROFIT = 2_400;\\n    // uint constant internal MARKET_FEE = 400;\\n    uint internal constant FORCE_WITHDRAW_PERCENT = 700;\\n    uint internal ROI_BONUS = 100;\\n\\n    uint internal initDate;\\n\\n    uint internal totalUsers;\\n    uint internal totalInvested;\\n    uint internal totalInvestedUsd;\\n    uint internal totalWithdrawn;\\n    uint internal totalWithdrawnTokens;\\n    uint internal totalDeposits;\\n    // uint internal totalReinvested;\\n\\n    uint public constant rewardsVault2Percent = 286;\\n    uint public membrecyPercent = 40;\\n    uint public constant MAX_MEMBRECY_PERCENT = 100;\\n\\n    uint internal defaultDevFee = 200;\\n    uint internal membrecyDevFee = 250;\\n\\n    FeeData public fees;\\n\\n    address public dAddress;\\n    address public oWalletIn;\\n    address public oWalletOut;\\n    address public vAddress;\\n    address public rAddress;\\n\\n    address public rewardsVaultX;\\n    address public rewardsVaultB;\\n    address public membrecyVault;\\n\\n    Plan public plan;\\n\\n    mapping(address => User) public users;\\n    mapping(address => uint) public lastBlock;\\n    mapping(uint => address) public addressByIndex;\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    modifier tenBlocks() {\\n        require(block.number.sub(lastBlock[msg.sender]) > 10, \\\"wait 10 blocks\\\");\\n        _;\\n        lastBlock[msg.sender] = block.number;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(initDate > 0, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(initDate == 0, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function setdAddress(address _address) external onlyOwner {\\n        dAddress = _address;\\n    }\\n\\n    function setoWalletIn(address _address) external onlyOwner {\\n        oWalletIn = _address;\\n    }\\n\\n    function setoWalletOut(address _address) external onlyOwner {\\n        oWalletOut = _address;\\n    }\\n\\n    function setvAddress(address _address) external onlyOwner {\\n        vAddress = _address;\\n    }\\n\\n    function setrAddress(address _address) external onlyOwner {\\n        rAddress = _address;\\n    }\\n\\n    function setRewardsVaultX(address _address) external onlyOwner {\\n        rewardsVaultX = _address;\\n    }\\n\\n    function setRewardsVaultB(address _address) external onlyOwner {\\n        rewardsVaultB = _address;\\n    }\\n\\n    function setMembrecyVault(address _address) external onlyOwner {\\n        membrecyVault = _address;\\n    }\\n\\n    function setMinInvest(uint _amount) external onlyOwner {\\n        INVEST_MIN_AMOUNT = _amount;\\n    }\\n\\n    function setRoiBonus(uint _amount) external onlyOwner {\\n        require(_amount <= PERCENTS_DIVIDER, \\\"wrong roi bonus\\\");\\n        ROI_BONUS = _amount;\\n    }\\n\\n    function setFees(uint _dev, uint _owner, uint _vip, uint _ranking, uint _withdrawOwner, uint _withdrawDev) external onlyOwner {\\n        fees = FeeData(_dev, _owner, _vip, _ranking, _withdrawOwner, _withdrawDev);\\n    }\\n\\n    function setReferralPercents(\\n        uint[REFERRAL_LEGNTH] memory _referralPercents\\n    ) external onlyOwner {\\n        uint sum;\\n        for (uint i = 0; i < REFERRAL_LEGNTH; i++) {\\n            sum = sum.add(_referralPercents[i]);\\n        }\\n        require(sum == PERCENTS_DIVIDER, \\\"wrong percents sum\\\");\\n        REFERRAL_PERCENTS = _referralPercents;\\n    }\\n\\n    function setMebrecyPercent(uint _amount) external onlyOwner {\\n        require(_amount <= MAX_MEMBRECY_PERCENT, \\\"wrong mebrecy percent\\\");\\n        membrecyPercent = _amount;\\n    }\\n\\n    function setDefaultAndMembrecyDevFee(uint _default, uint _membrecy) external onlyOwner {\\n        require(_default + _membrecy <= PERCENTS_DIVIDER, \\\"wrong dev fee\\\");\\n        defaultDevFee = _default;\\n        membrecyDevFee = _membrecy;\\n    }\\n\\n    function getConstans()\\n        external\\n        view\\n        returns (\\n            uint _refLenght,\\n            uint _investMinAmount,\\n            uint _minWithdraw,\\n            uint _percentsDivider,\\n            uint _timeStep,\\n            uint _memrecyStep,\\n            uint _forceWithdrawPercent,\\n            uint _roiBonus,\\n            uint _membrecyPercent\\n        )\\n    {\\n        return (\\n            REFERRAL_LEGNTH,\\n            INVEST_MIN_AMOUNT,\\n            MIN_WITHDRAW,\\n            PERCENTS_DIVIDER,\\n            TIME_STEP,\\n            MEMBRECY_STEP,\\n            FORCE_WITHDRAW_PERCENT,\\n            ROI_BONUS,\\n            membrecyPercent\\n        );\\n    }\\n\\n    function unpause() external whenPaused onlyOwner {\\n        initDate = block.timestamp;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    function isPaused() external view returns (bool) {\\n        return (initDate == 0);\\n    }\\n\\n    function getUser(address _user) public view override returns (User memory) {\\n        return users[_user];\\n    }\\n\\n    function getUserByindex(\\n        uint _index\\n    ) external view override returns (User memory) {\\n        return users[addressByIndex[_index]];\\n    }\\n\\n    function getAllUsers() external view override returns (User[] memory) {\\n        User[] memory _users = new User[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            _users[i] = users[addressByIndex[i]];\\n        }\\n        return _users;\\n    }\\n\\n    function getAllInvestors()\\n        external\\n        view\\n        override\\n        returns (address[] memory)\\n    {\\n        address[] memory _users = new address[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            _users[i] = addressByIndex[i];\\n        }\\n        return _users;\\n    }\\n\\n    function getUsersByRange(\\n        uint _init,\\n        uint end\\n    ) external view override returns (User[] memory) {\\n        User[] memory _users = new User[](end - _init);\\n        for (uint i = _init; i < end; i++) {\\n            _users[i] = users[addressByIndex[i]];\\n        }\\n        return _users;\\n    }\\n\\n    function getDepsitStartDate(\\n        Deposit memory ndeposit\\n    ) internal view returns (uint) {\\n        uint _date = getContracDate();\\n        if (_date > ndeposit.start) {\\n            return _date;\\n        } else {\\n            return ndeposit.start;\\n        }\\n    }\\n\\n    function getUserDepositInfo(\\n        address userAddress,\\n        uint index\\n    )\\n        external\\n        view\\n        returns (uint amount_, uint withdrawn_, uint timeStart_, uint maxProfit)\\n    {\\n        Deposit memory deposit = users[userAddress].deposits[index];\\n        amount_ = deposit.amount;\\n        withdrawn_ = deposit.withdrawn;\\n        timeStart_ = getDepsitStartDate(deposit);\\n        maxProfit = getMaxprofit(deposit);\\n    }\\n\\n    function getMaxprofit(\\n        Deposit memory ndeposit\\n    ) internal view returns (uint) {\\n        if (ndeposit.force) {\\n            return\\n                (ndeposit.amount.mul(FORCE_WITHDRAW_PERCENT)).div(\\n                    PERCENTS_DIVIDER\\n                );\\n        }\\n        return (ndeposit.amount.mul(plan.MAX_PROFIT)).div(PERCENTS_DIVIDER);\\n    }\\n\\n    function getDeposit(\\n        address _user,\\n        uint _index\\n    ) external view override returns (Deposit memory) {\\n        return users[_user].deposits[_index];\\n    }\\n\\n    function getAllDeposits(\\n        address _user\\n    ) external view override returns (Deposit[] memory) {\\n        return users[_user].deposits;\\n    }\\n\\n    function getUserPlans(\\n        address _user\\n    ) external view returns (Deposit[] memory) {\\n        User storage user = users[_user];\\n        Deposit[] memory result = new Deposit[](user.depositsLength);\\n        for (uint i; i < user.depositsLength; i++) {\\n            result[i] = user.deposits[i];\\n        }\\n        return result;\\n    }\\n\\n    // function getUserTotalDeposits(\\n    //     address userAddress\\n    // ) internal view returns (uint) {\\n    //     User storage user = users[userAddress];\\n    //     uint amount;\\n    //     for (uint i; i < user.depositsLength; i++) {\\n    //         amount += users[userAddress].deposits[i].amount;\\n    //     }\\n    //     return amount;\\n    // }\\n\\n    // function getUserTotalWithdrawn(\\n    //     address userAddress\\n    // ) internal view returns (uint) {\\n    //     User storage user = users[userAddress];\\n\\n    //     uint amount;\\n\\n    //     for (uint i; i < user.depositsLength; i++) {\\n    //         amount += users[userAddress].deposits[i].withdrawn;\\n    //     }\\n    //     return amount;\\n    // }\\n\\n    function getDAte() public view returns (uint) {\\n        return block.timestamp;\\n    }\\n\\n    function getReferrerBonus(\\n        address _user\\n    ) external view returns (uint[REFERRAL_LEGNTH] memory) {\\n        return users[_user].referrerBonus;\\n    }\\n\\n    function getContracDate() public view returns (uint) {\\n        if (initDate == 0) {\\n            return block.timestamp;\\n        }\\n        return initDate;\\n    }\\n\\n    function getPublicData()\\n        external\\n        view\\n        returns (\\n            uint totalUsers_,\\n            uint totalInvested_,\\n            uint totalInvestedUsd_,\\n            // uint totalReinvested_,\\n            uint totalWithdrawn_,\\n            uint totalDeposits_,\\n            uint balance_,\\n            uint _totalWithdrawnTokens,\\n            // uint maxProfit,\\n            uint minDeposit,\\n            uint daysFormdeploy\\n        )\\n    {\\n        totalUsers_ = totalUsers;\\n        totalInvested_ = totalInvested;\\n        totalInvestedUsd_ = totalInvestedUsd;\\n        // totalReinvested_ = totalReinvested;\\n        totalWithdrawn_ = totalWithdrawn;\\n        totalDeposits_ = totalDeposits;\\n        balance_ = getContractBalance();\\n        // roiBase = ROI_BASE;\\n        // maxProfit = MAX_PROFIT;\\n        minDeposit = INVEST_MIN_AMOUNT;\\n        daysFormdeploy = (block.timestamp.sub(getContracDate())).div(TIME_STEP);\\n        _totalWithdrawnTokens = totalWithdrawnTokens;\\n    }\\n\\n    function getContractBalance() public view returns (uint) {\\n        return address(this).balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BioticGenerator.sol/BioFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./BioFarm_State.sol\\\";\\nimport \\\"./IContractsLibrary.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\ncontract BioFarm is BioFarm_State, ReentrancyGuard {\\n    using SafeMath for uint;\\n    IERC20 public TOKEN_REWARD;\\n    IERC20 public TOKEN_MEMBRECY;\\n    IContractsLibrary public contractsLibrary;\\n    IVault public vault;\\n\\n    address internal constant _defaultWallet =\\n        0xFfC7982a7350A608e49c0242113855C408Fc0a54;\\n    event Newbie(address user);\\n    event NewDeposit(address indexed user, uint amount);\\n    event Withdrawn(address indexed user, uint amount);\\n    event RefBonus(\\n        address indexed referrer,\\n        address indexed referral,\\n        uint indexed level,\\n        uint amount\\n    );\\n    event FeePayed(address indexed user, uint totalAmount);\\n    event Reinvestment(address indexed user, uint amount);\\n    event ForceWithdraw(address indexed user, uint amount);\\n\\n    constructor(\\n        address _token,\\n        address _tokenMembrecy,\\n        address _contractsLibrary,\\n        address _vault,\\n        // address _dAddress,\\n        // address _oWalletIn,\\n        // address _oWalletOut,\\n        // address _vAddress,\\n        // address _rAddress,\\n        // address _rewardVault,\\n        // address _rewardVault2,\\n        // address _membrecyVault,\\n        // address _defWallet\\n        address[8] memory _addresses\\n    ) {\\n        User memory _user;\\n        // cheking referral length\\n        require(\\n            _user.referrerCount.length == REFERRAL_LEGNTH &&\\n                _user.referrerBonus.length == REFERRAL_LEGNTH,\\n            \\\"invalid referral length\\\"\\n        );\\n        TOKEN_REWARD = IERC20(_token);\\n        TOKEN_MEMBRECY = IERC20(_tokenMembrecy);\\n        contractsLibrary = IContractsLibrary(_contractsLibrary);\\n        vault = IVault(_vault);\\n        dAddress = _addresses[0];\\n        oWalletIn = _addresses[1];\\n        oWalletOut = _addresses[2];\\n        vAddress = _addresses[3];\\n        rAddress = _addresses[4];\\n        rewardsVaultX = _addresses[5];\\n        rewardsVaultB = _addresses[6];\\n        membrecyVault = _addresses[7];\\n        plan = Plan(CYCLE_STEP, 50, MAX_PROFIT);\\n        fees = FeeData(25, 75, 40, 10, 35, 15);\\n        emit Paused(msg.sender);\\n    }\\n\\n    modifier checkUser_() {\\n        uint check = block.timestamp.sub(\\n            getlastActionDate(users[msg.sender].checkpoint)\\n        );\\n        require(check > TIME_STEP, \\\"try again later\\\");\\n        _;\\n    }\\n\\n    function setReWardToken(address _token) external onlyOwner {\\n        TOKEN_REWARD = IERC20(_token);\\n    }\\n\\n    function setMenbrecyToken(address _token) external onlyOwner {\\n        TOKEN_MEMBRECY = IERC20(_token);\\n    }\\n\\n    function setContractsLibrary(address _contractsLibrary) external onlyOwner {\\n        contractsLibrary = IContractsLibrary(_contractsLibrary);\\n    }\\n\\n    function setVault(address _vault) external onlyOwner {\\n        vault = IVault(_vault);\\n    }\\n\\n    function checkUser() external view returns (bool) {\\n        uint check = block.timestamp.sub(\\n            getlastActionDate(users[msg.sender].checkpoint)\\n        );\\n        if (check > TIME_STEP) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function invest(\\n        address referrer\\n    ) external payable nonReentrant whenNotPaused tenBlocks {\\n        uint _amount = msg.value;\\n        payFeeInvest(_amount);\\n        investHandler(_amount, referrer, msg.sender);\\n        sendToVault();\\n    }\\n\\n    function membrecyPrice(address _user, uint _index) public view returns (uint) {\\n        require(_index < users[_user].depositsLength, \\\"invalid index\\\");\\n        uint usdAmount = users[_user].deposits[_index].amount.mul(membrecyPercent).div(PERCENTS_DIVIDER);\\n        uint _amount = contractsLibrary.getBusdToBNBToToken(\\n            address(TOKEN_MEMBRECY),\\n            usdAmount\\n        );\\n        return _amount;\\n    }\\n\\n    function payMembrecy(\\n        uint _index\\n    ) external nonReentrant whenNotPaused tenBlocks {\\n        User storage user = users[msg.sender];\\n        Deposit storage dep = user.deposits[_index];\\n        uint _amount = membrecyPrice(msg.sender, _index);\\n        TOKEN_MEMBRECY.transferFrom(msg.sender, address(this), _amount);\\n        updateDeposit(dep, user.checkpoint);\\n        if (dep.bonusEnd < block.timestamp) {\\n            dep.bonusEnd = block.timestamp + MEMBRECY_STEP;\\n            dep.bonusStart = block.timestamp;\\n            dep.bonusRoi = ROI_BONUS;\\n        } else {\\n            dep.bonusEnd += MEMBRECY_STEP;\\n        }\\n        uint _toDev = TOKEN_MEMBRECY\\n            .balanceOf(address(this))\\n            .mul(membrecyDevFee)\\n            .div(PERCENTS_DIVIDER);\\n        TOKEN_MEMBRECY.transfer(dAddress, _toDev);\\n        TOKEN_MEMBRECY.transfer(\\n            membrecyVault,\\n            TOKEN_MEMBRECY.balanceOf(address(this))\\n        );\\n    }\\n\\n    function investHandler(\\n        uint investAmt,\\n        address referrer,\\n        address _user\\n    ) internal {\\n        require(investAmt >= INVEST_MIN_AMOUNT, \\\"insufficient deposit\\\");\\n\\n        User storage user = users[_user];\\n\\n        if (user.user == address(0)) {\\n            if (\\n                user.referrer == address(0) &&\\n                users[referrer].depositsLength > 0 &&\\n                referrer != _user &&\\n                users[referrer].referrer != _user\\n            ) {\\n                user.referrer = referrer;\\n            }\\n        }\\n\\n        address upline;\\n\\n        if (user.referrer != address(0)) {\\n            upline = user.referrer;\\n        } else {\\n            upline = _defaultWallet;\\n        }\\n\\n        bool isFirst = false;\\n        if (user.depositsLength == 0) {\\n            isFirst = true;\\n        }\\n\\n        for (uint i; i < REFERRAL_PERCENTS.length; i++) {\\n            if (upline != address(0)) {\\n                uint amount = (investAmt.mul(REFERRAL_PERCENTS[i])).div(\\n                    PERCENTS_DIVIDER\\n                );\\n                transferHandler(upline, amount);\\n                users[upline].totalBonus += investAmt;\\n                if (isFirst) {\\n                    users[upline].referrerCount[i] += 1;\\n                    if (i == 0) {\\n                        users[upline].referralsv0.push(_user);\\n                    } else if (i == 1) {\\n                        users[upline].referralsv1.push(_user);\\n                    } else if (i == 2) {\\n                        users[upline].referralsv2.push(_user);\\n                    } else if (i == 3) {\\n                        users[upline].referralsv3.push(_user);\\n                    } else if (i == 4) {\\n                        users[upline].referralsv4.push(_user);\\n                    }\\n                }\\n                users[upline].referrerBonus[i] += amount;\\n                emit RefBonus(upline, _user, i, amount);\\n                upline = users[upline].referrer;\\n                if (\\n                    upline == address(0) ||\\n                    (i + 1) > users[upline].referrerCount[0]\\n                ) {\\n                    upline = _defaultWallet;\\n                }\\n            } else break;\\n        }\\n\\n        if (isFirst) {\\n            user.user = _user;\\n            user.checkpoint = block.timestamp;\\n            user.id = totalUsers;\\n            addressByIndex[totalUsers] = _user;\\n            totalUsers++;\\n            emit Newbie(_user);\\n        }\\n\\n        Deposit memory newDeposit;\\n        uint usdAmount = contractsLibrary.getBnbToUsd(investAmt);\\n        newDeposit.amount = usdAmount;\\n        newDeposit.start = block.timestamp;\\n        newDeposit.amountBnb = investAmt;\\n        newDeposit.id = user.depositsLength; // user.deposits[user.depositsLength] = newDeposit;\\n        user.deposits.push(newDeposit);\\n        user.depositsLength++;\\n        user.totalInvested += usdAmount;\\n        user.totalInvestedBnb += investAmt;\\n\\n        totalInvested += investAmt;\\n        totalInvestedUsd += usdAmount;\\n        totalDeposits += 1;\\n        emit NewDeposit(_user, investAmt);\\n    }\\n\\n    function withdraw()\\n        external\\n        whenNotPaused\\n        checkUser_\\n        tenBlocks\\n        returns (bool)\\n    {\\n        User storage user = users[msg.sender];\\n\\n        uint totalAmount;\\n\\n        for (uint i; i < user.depositsLength; i++) {\\n            uint dividends;\\n            Deposit memory deposit = user.deposits[i];\\n            if (\\n                deposit.withdrawn < getMaxprofit(deposit) &&\\n                deposit.force == false\\n            ) {\\n                dividends = calculateDividents(deposit, user.checkpoint);\\n\\n                if (dividends > 0) {\\n                    //changing of storage data\\n                    user.deposits[i].withdrawn += dividends;\\n                    delete user.deposits[i].acumulated;\\n                    totalAmount += dividends;\\n                }\\n            }\\n        }\\n\\n        require(totalAmount >= MIN_WITHDRAW, \\\"User has no dividends\\\");\\n\\n        // uint referralBonus = user.bonus;\\n        // if (referralBonus > 0) {\\n        //     totalAmount += referralBonus;\\n        //     delete user.bonus;\\n        // }\\n\\n        uint totalAmountTokens = contractsLibrary.getBusdToBNBToToken(\\n            address(TOKEN_REWARD),\\n            totalAmount\\n        );\\n\\n        uint contractBalance = getRewardsBalance();\\n        // if (contractBalance < totalAmount) {\\n        //     totalAmount = contractBalance;\\n        // }\\n        require(\\n            contractBalance >= totalAmountTokens,\\n            \\\"Insufficient funds in contract balance\\\"\\n        );\\n\\n        user.checkpoint = block.timestamp;\\n        user.totalWithdrawn += totalAmount;\\n        user.tokenWithdrawn += totalAmountTokens;\\n        totalWithdrawn += totalAmount;\\n        totalWithdrawnTokens += totalAmountTokens;\\n        uint256 fee = payFees(totalAmountTokens);\\n        uint256 toTransfer = totalAmountTokens.sub(fee);\\n        transferHandlerToken(msg.sender, toTransfer);\\n        emit FeePayed(msg.sender, fee);\\n        emit Withdrawn(msg.sender, totalAmountTokens);\\n        return true;\\n    }\\n\\n    // function reinvestment()\\n    //     external\\n    //     whenNotPaused\\n    //     checkUser_\\n    //     nonReentrant\\n    //     returns (bool)\\n    // {\\n    //     require(isActive(msg.sender), \\\"Dont is User\\\");\\n    //     User storage user = users[msg.sender];\\n\\n    //     uint totalDividends;\\n\\n    //     for (uint i; i < user.depositsLength; i++) {\\n    //         uint dividends;\\n    //         Deposit memory deposit = user.deposits[i];\\n\\n    //         if (\\n    //             deposit.withdrawn < getMaxprofit(deposit) &&\\n    //             deposit.force == false\\n    //         ) {\\n    //             dividends = calculateDividents(deposit, user, totalDividends);\\n\\n    //             if (dividends > 0) {\\n    //                 user.deposits[i].withdrawn += dividends;\\n    //                 totalDividends += dividends;\\n    //             }\\n    //         }\\n    //     }\\n\\n    //     require(totalDividends > 0, \\\"User has no dividends\\\");\\n\\n    //     uint referralBonus = user.bonus;\\n    //     if (referralBonus > 0) {\\n    //         totalDividends += referralBonus;\\n    //         delete user.bonus;\\n    //     }\\n\\n    //     user.reinvest += totalDividends;\\n    //     totalReinvested += totalDividends;\\n    //     totalWithdrawn += totalDividends;\\n    // \\tuser.totalWithdrawn += totalDividends;\\n    //     user.checkpoint = block.timestamp;\\n    //     investHandler(totalDividends, user.referrer);\\n    //     return true;\\n    // }\\n\\n    // function forceWithdraw() external whenNotPaused nonReentrant {\\n    //     User storage user = users[msg.sender];\\n    //     uint totalDividends;\\n    //     uint toFee;\\n    //     for (uint256 i; i < user.depositsLength; i++) {\\n    //         Deposit storage deposit = user.deposits[i];\\n    //         if (deposit.force == false) {\\n    //             deposit.force = true;\\n    //             uint maxProfit = getMaxprofit(deposit);\\n    //             if (deposit.withdrawn < maxProfit) {\\n    //                 uint profit = maxProfit.sub(deposit.withdrawn);\\n    //                 deposit.withdrawn = deposit.withdrawn.add(profit);\\n    //                 totalDividends += profit;\\n    //                 toFee += deposit.amount.sub(profit, \\\"sub error\\\");\\n    //             }\\n    //         }\\n    //     }\\n    //     require(totalDividends > 0, \\\"User has no dividends\\\");\\n    //     uint256 contractBalance = getContractBalance();\\n    //     if (contractBalance < totalDividends + toFee) {\\n    //         totalDividends = contractBalance.mul(FORCE_WITHDRAW_PERCENT).div(\\n    //             PERCENTS_DIVIDER\\n    //         );\\n    //         toFee = contractBalance.sub(totalDividends, \\\"sub error 2\\\");\\n    //     }\\n    //     user.checkpoint = block.timestamp;\\n    // TODO: check this\\n    //     payFees(toFee);\\n    //     transferHandler(msg.sender, totalDividends);\\n    //     emit FeePayed(msg.sender, toFee);\\n    //     emit ForceWithdraw(msg.sender, totalDividends);\\n    // }\\n\\n    function getNextUserAssignment(\\n        address userAddress\\n    ) public view returns (uint) {\\n        uint checkpoint = getlastActionDate(users[userAddress].checkpoint);\\n        uint _date = getContracDate();\\n        if (_date > checkpoint) checkpoint = _date;\\n        return checkpoint.add(TIME_STEP);\\n    }\\n\\n    function getUserData(\\n        address userAddress\\n    )\\n        external\\n        view\\n        returns (\\n            uint totalWithdrawn_,\\n            uint totalDeposits_,\\n            uint totalBonus_,\\n            uint totalReinvest_,\\n            uint balance_,\\n            uint nextAssignment_,\\n            uint amountOfDeposits,\\n            uint checkpoint,\\n            uint id,\\n            address referrer_,\\n            uint[REFERRAL_LEGNTH] memory referrerCount_,\\n            uint[REFERRAL_LEGNTH] memory referrerBonus_\\n        )\\n    {\\n        User storage user = users[userAddress];\\n        totalWithdrawn_ = user.totalWithdrawn;\\n        totalDeposits_ = user.totalInvested;\\n        nextAssignment_ = getNextUserAssignment(userAddress);\\n        balance_ = getUserDividends(userAddress);\\n        totalBonus_ = user.bonus;\\n        totalReinvest_ = user.reinvest;\\n        amountOfDeposits = user.depositsLength;\\n\\n        checkpoint = getlastActionDate(user.checkpoint);\\n        referrer_ = user.referrer;\\n        referrerCount_ = user.referrerCount;\\n        referrerBonus_ = user.referrerBonus;\\n        id = user.id;\\n    }\\n\\n    function getUserDividends(\\n        address userAddress\\n    ) internal view returns (uint) {\\n        User storage user = users[userAddress];\\n\\n        uint totalDividends;\\n\\n        for (uint i; i < user.depositsLength; i++) {\\n            Deposit memory deposit = users[userAddress].deposits[i];\\n\\n            if (\\n                deposit.withdrawn < getMaxprofit(deposit) &&\\n                deposit.force == false\\n            ) {\\n                uint dividends = calculateDividents(deposit, user.checkpoint);\\n                totalDividends += dividends;\\n            }\\n        }\\n\\n        return totalDividends;\\n    }\\n\\n    function calculateDividents(\\n        Deposit memory deposit,\\n        uint _userCheckpoint\\n    ) internal view returns (uint) {\\n        uint dividends;\\n        uint depositPercentRate = plan.percent;\\n\\n        uint checkDate = getDepsitStartDate(deposit);\\n\\n        if (checkDate < getlastActionDate(_userCheckpoint)) {\\n            checkDate = getlastActionDate(_userCheckpoint);\\n        }\\n        if (checkDate < deposit.checkpoint) {\\n            checkDate = deposit.checkpoint;\\n        }\\n\\n        dividends = (\\n            deposit.amount.mul(\\n                depositPercentRate.mul(block.timestamp.sub(checkDate))\\n            )\\n        ).div((PERCENTS_DIVIDER).mul(plan.cycle));\\n\\n        if (\\n            checkDate <= deposit.bonusEnd &&\\n            block.timestamp >= deposit.bonusStart\\n        ) {\\n            uint startBonus = deposit.bonusStart > checkDate\\n                ? deposit.bonusStart\\n                : checkDate;\\n            uint endBonus = deposit.bonusEnd < block.timestamp\\n                ? deposit.bonusEnd\\n                : block.timestamp;\\n            if(startBonus > endBonus) {\\n                startBonus = endBonus;\\n            }\\n            dividends += (\\n                deposit.amount.mul(\\n                    deposit.bonusRoi.mul(endBonus.sub(startBonus))\\n                )\\n            ).div((PERCENTS_DIVIDER).mul(plan.cycle));\\n        }\\n\\n        dividends += deposit.acumulated;\\n\\n        /*\\n\\t\\tif(dividends + _current > userMaxProfit) {\\n\\t\\t\\tdividends = userMaxProfit.sub(_current, \\\"max dividends\\\");\\n\\t\\t}\\n\\t\\t*/\\n\\n        if (deposit.withdrawn.add(dividends) > getMaxprofit(deposit)) {\\n            dividends = getMaxprofit(deposit).sub(deposit.withdrawn);\\n        }\\n\\n        return dividends;\\n    }\\n\\n    function updateDeposit(\\n        Deposit storage deposit,\\n        uint _userCheckpoint\\n    ) internal {\\n        require(\\n            deposit.withdrawn < getMaxprofit(deposit) && deposit.force == false,\\n            \\\"deposit is closed\\\"\\n        );\\n\\n        deposit.acumulated = calculateDividents(deposit, _userCheckpoint);\\n        deposit.checkpoint = block.timestamp;\\n    }\\n\\n    function getlastActionDate(\\n        uint _userCheckpoint\\n    ) internal view returns (uint) {\\n        uint checkpoint = _userCheckpoint;\\n        uint _date = getContracDate();\\n        if (_date > checkpoint) checkpoint = _date;\\n        return checkpoint;\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function getRewardsBalance() public view returns (uint) {\\n        return TOKEN_REWARD.balanceOf(address(vault));\\n    }\\n\\n    function transferHandler(address to, uint amount) internal {\\n        if (amount > getContractBalance()) {\\n            amount = getContractBalance();\\n        }\\n        if (to != _defaultWallet) {\\n            payable(to).transfer(amount);\\n        } else {\\n            uint toDev = amount.mul(defaultDevFee).div(PERCENTS_DIVIDER);\\n            payable(dAddress).transfer(toDev);\\n            payable(_defaultWallet).transfer(amount.sub(toDev));\\n        }\\n    }\\n\\n    function transferHandlerToken(address to, uint amount) internal {\\n        if (amount > getRewardsBalance()) {\\n            amount = getRewardsBalance();\\n        }\\n        if (to != _defaultWallet) {\\n            vault.safeTransfer(TOKEN_REWARD, to, amount);\\n        } else {\\n            uint toDev = amount.mul(defaultDevFee).div(PERCENTS_DIVIDER);\\n            vault.safeTransfer(TOKEN_REWARD, dAddress, toDev);\\n            vault.safeTransfer(TOKEN_REWARD, _defaultWallet, amount.sub(toDev));\\n        }\\n    }\\n\\n    //1_000\\n    function payFeeInvest(uint amount) internal {\\n        uint toDev = amount.mul(fees.dev).div(PERCENTS_DIVIDER);\\n        uint toOwner = amount.mul(fees.owner).div(PERCENTS_DIVIDER);\\n        uint toVip = amount.mul(fees.vip).div(PERCENTS_DIVIDER);\\n        uint toRanking = amount.mul(fees.ranking).div(PERCENTS_DIVIDER);\\n        transferHandler(dAddress, toDev);\\n        transferHandler(oWalletIn, toOwner);\\n        transferHandler(vAddress, toVip);\\n        transferHandler(rAddress, toRanking);\\n        emit FeePayed(msg.sender, toDev + toOwner + toVip + toRanking);\\n    }\\n\\n    function sendToVault() internal {\\n        uint amount = getContractBalance();\\n        uint toVault = amount.mul(rewardsVault2Percent).div(PERCENTS_DIVIDER);\\n        payable(rewardsVaultX).transfer(toVault);\\n        payable(rewardsVaultB).transfer(getContractBalance());\\n    }\\n\\n    function payFees(uint amount) internal returns (uint) {\\n        uint toOwner = amount.mul(fees.withdrawOwner).div(PERCENTS_DIVIDER);\\n        uint toDev = amount.mul(fees.withdrawDev).div(PERCENTS_DIVIDER);\\n        transferHandlerToken(oWalletOut, toOwner);\\n        transferHandlerToken(dAddress, toDev);\\n        uint _total = toOwner + toDev;\\n        emit FeePayed(msg.sender, _total);\\n        return _total;\\n    }\\n\\n    function takeTokens(address token) external onlyOwner {\\n        uint amount = IERC20(token).balanceOf(address(this));\\n        IERC20(token).transfer(msg.sender, amount);\\n    }\\n\\n    function takeETH() external onlyOwner {\\n        uint amount = address(this).balance;\\n        payable(msg.sender).transfer(amount);\\n    }\\n\\n    fallback() external payable {\\n    }\\n\\n    receive() external payable {\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BioticGenerator.sol/IBioticGenerator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\ninterface IBioticGenerator {\\n    struct Deposit {\\n        uint id;\\n        uint amount;\\n        uint acumulated;\\n        uint amountBnb;\\n        uint withdrawn;\\n        uint start;\\n        uint checkpoint;\\n        uint bonusStart;\\n        uint bonusEnd;\\n        uint bonusRoi;\\n        bool force;\\n    }\\n\\n    struct FeeData {\\n        uint dev;\\n        uint owner;\\n        uint vip;\\n        uint ranking;\\n        uint withdrawOwner;\\n        uint withdrawDev;\\n    }\\n\\n    struct Plan {\\n        uint cycle;\\n        uint percent;\\n        uint MAX_PROFIT;\\n    }\\n\\n    struct User {\\n        address user;\\n        address referrer;\\n        uint totalInvested;\\n        uint totalInvestedBnb;\\n        uint totalWithdrawn;\\n        uint tokenWithdrawn;\\n        uint depositsLength;\\n        uint bonus;\\n        uint reinvest;\\n        uint totalBonus;\\n        uint checkpoint;\\n        uint id;\\n        Deposit[] deposits;\\n        address[] referralsv0;\\n        address[] referralsv1;\\n        address[] referralsv2;\\n        address[] referralsv3;\\n        address[] referralsv4;\\n        uint[5] referrerCount;\\n        uint[5] referrerBonus;\\n    }\\n\\n    function getUser(address _user) external view returns (User memory);\\n\\n    function getDeposit(\\n        address _user,\\n        uint _index\\n    ) external view returns (Deposit memory);\\n\\n    function getAllDeposits(\\n        address _user\\n    ) external view returns (Deposit[] memory);\\n\\n    function getUserByindex(uint _index) external view returns (User memory);\\n\\n    function getAllUsers() external view returns (User[] memory);\\n\\n    function getAllInvestors() external view returns (address[] memory);\\n\\n    function getUsersByRange(\\n        uint _init,\\n        uint end\\n    ) external view returns (User[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/BioticGenerator.sol/IContractsLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"../IUniswapV2Router01.sol\\\";\\n\\nabstract contract IContractsLibrary {\\n    function BUSD() external view virtual returns (address);\\n\\n    function WBNB() external view virtual returns (address);\\n\\n    function ROUTER() external view virtual returns (IUniswapV2Router01);\\n\\n    function getBusdToBNBToToken(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBNBtoBusd(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBnb(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getBnbToTokens(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getTokenToBnbToAltToken(\\n        address token,\\n        address altToken,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getLpPrice(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getUsdToBnB(uint amount) external view virtual returns (uint256);\\n\\n    function getBnbToUsd(uint amount) external view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/BioticGenerator.sol/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IVault {\\n    function safeTransfer(IERC20 from, address to, uint amount) external;\\n\\n    function safeTransfer(address _to, uint _value) external;\\n\\n    function getTokenAddressBalance(address token) external view returns (uint);\\n\\n    function getTokenBalance(IERC20 token) external view returns (uint);\\n\\n    function getBalance() external view returns (uint);\\n\\n    function safeTransferAdmin(address from, address to, uint amount) external;\\n\\n    function safeTransferAdmin(address _to, uint _value) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenMembrecy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractsLibrary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address[8]\",\"name\":\"_addresses\",\"type\":\"address[8]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForceWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"MAX_MEMBRECY_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_MEMBRECY\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_REWARD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsLibrary\",\"outputs\":[{\"internalType\":\"contract IContractsLibrary\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"owner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ranking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawOwner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDev\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerCount\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerBonus\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct IBioticGenerator.User[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConstans\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_refLenght\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_investMinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentsDivider\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_memrecyStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_forceWithdrawPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_roiBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_membrecyPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContracDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getNextUserAssignment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUsers_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedUsd_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdrawnTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daysFormdeploy\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReferrerBonus\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerCount\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerBonus\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct IBioticGenerator.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserByindex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerCount\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerBonus\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct IBioticGenerator.User\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvest_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextAssignment_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOfDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer_\",\"type\":\"address\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerCount_\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerBonus_\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserDepositInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeStart_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserPlans\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_init\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getUsersByRange\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"acumulated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusRoi\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"internalType\":\"struct IBioticGenerator.Deposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv0\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv1\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv2\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv3\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referralsv4\",\"type\":\"address[]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerCount\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referrerBonus\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct IBioticGenerator.User[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membrecyPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"membrecyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membrecyVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oWalletIn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oWalletOut\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"payMembrecy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MAX_PROFIT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsVault2Percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsVaultB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsVaultX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractsLibrary\",\"type\":\"address\"}],\"name\":\"setContractsLibrary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_default\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_membrecy\",\"type\":\"uint256\"}],\"name\":\"setDefaultAndMembrecyDevFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_owner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vip\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ranking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawOwner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawDev\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMebrecyPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setMembrecyVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setMenbrecyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinInvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setReWardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"_referralPercents\",\"type\":\"uint256[5]\"}],\"name\":\"setReferralPercents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRewardsVaultB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRewardsVaultX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setRoiBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setdAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setoWalletIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setoWalletOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setrAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setvAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"takeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestedBnb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BioFarm", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000009945f6221efee040a12054217504cbc230f0acc90000000000000000000000003bdeecae844b96a133f98e54e36eb85414ffe5c900000000000000000000000037a051ca908477e8668bfd4df9eae57cff9b2d32000000000000000000000000792543d34200a9118d8487bfc64e6326165491260000000000000000000000009b1d285abae7c7d20a339f589f2ac3dd17f837ee0000000000000000000000004cd85d762198bccbcb39203763b58f86b8364f640000000000000000000000009179ab2f6e467a1fd7e18333c189b78941717a480000000000000000000000007d50f1f9c1e7f8032a572c3478e4d9ec3d1124ff000000000000000000000000b92d688387d6097641c7dd73eb13b21da65e97b2000000000000000000000000d2bbb7fbe62487fd68db7123f6196725c0ae195b000000000000000000000000999d65af6331a634a15fb5b373e5dc429ab2230900000000000000000000000016da54d2db03e10d5971cd31cdd8cfcfb6a5dfde", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}