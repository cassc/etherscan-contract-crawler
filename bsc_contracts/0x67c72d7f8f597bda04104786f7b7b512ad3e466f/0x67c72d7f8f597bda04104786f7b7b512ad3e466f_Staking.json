{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @title Staking\r\n * @author gotbit\r\n */\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address who) external view returns (uint256 balance);\r\n    function transfer(address to, uint256 value) external returns (bool trans1);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool trans);\r\n}\r\n\r\n\r\ncontract OwnableAndWhitelistble {\r\n\r\n    address public owner;\r\n    mapping(address => bool) internal whitelist;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event WhitelistAdded(address indexed sender, address indexed whitelistUser);\r\n    event WhitelistRemoved(address indexed sender, address indexed whitelistUser);\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, 'Only owner can call this function');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), 'You cant transfer ownerships to address 0x0');\r\n        require(newOwner != owner, 'You cant transfer ownerships to yourself');\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        whitelist[owner] = false;\r\n        whitelist[newOwner] = true;\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyWhitelist() {\r\n        require(whitelist[msg.sender], 'Only whitelist users can call this function');\r\n        _;\r\n    }\r\n\r\n    function addToWhitelist(address newWhitelistUser) external onlyOwner {\r\n        require(newWhitelistUser != address(0), 'You cant add to whitelist address 0x0');\r\n        emit WhitelistAdded(msg.sender, newWhitelistUser);\r\n        whitelist[newWhitelistUser] = true;\r\n    }\r\n\r\n    function removeFromWhitelist(address newWhitelistUser) external onlyOwner {\r\n        require(whitelist[newWhitelistUser], 'You cant remove from whitelist');\r\n        emit WhitelistRemoved(msg.sender, newWhitelistUser);\r\n        whitelist[newWhitelistUser] = false;\r\n    }\r\n}\r\n\r\ncontract Staking is OwnableAndWhitelistble {\r\n\r\n    struct Stake {\r\n        uint lastHarvest;\r\n        uint startStaking;\r\n        uint amount;\r\n        uint boost; \r\n    }\r\n\r\n    IERC20 public mainToken;\r\n\r\n    address public dividends;\r\n\r\n\r\n    uint public rate = 10;\r\n    uint constant public beforeCutoff = 15;\r\n    uint constant public afterCutoff = 10;\r\n\r\n    uint constant public year = 365 days;\r\n    \r\n    uint constant public cutoff = 48 hours;\r\n    uint constant public stakePeriod = 48 hours;\r\n    uint constant public maxStakePeriod = year;\r\n\r\n    mapping(address => Stake) public stakes;\r\n\r\n    event Staked(address indexed who, uint startTime, uint amount);\r\n    event Harvested(address indexed who, uint value, uint toDividends);\r\n    event Unstaked(address indexed who, uint amount);\r\n    event Boosted(address indexed who, uint boost);\r\n    event SettedDividends(address indexed who);\r\n    event SettedRate(address indexed who, uint rate);\r\n\r\n\r\n    constructor(address owner_, address token_, address dividends_) {\r\n        owner = owner_;\r\n        mainToken = IERC20(token_);\r\n        dividends = dividends_;\r\n    }\r\n\r\n    function stake(uint amount_) \r\n    external {   \r\n        require(stakes[msg.sender].startStaking == 0, 'You have already staked');\r\n        require(amount_ > 0, 'Amount must be greater then zero');\r\n        require(mainToken.balanceOf(msg.sender) >= amount_, 'You dont enough DES');\r\n        require(maxReward(amount_) < mainToken.balanceOf(address(this)), 'Pool is empty');\r\n\r\n        stakes[msg.sender] = Stake(block.timestamp, block.timestamp, amount_, 0);\r\n        emit Staked(msg.sender, block.timestamp, amount_);\r\n        \r\n        mainToken.transferFrom(msg.sender, address(this), amount_);\r\n    }\r\n\r\n    function maxReward(uint amount_) \r\n    public\r\n    view\r\n    returns (uint256) {\r\n        return (amount_ * rate) / 100;\r\n    }\r\n\r\n    function harvest() \r\n    public \r\n    returns (uint value, uint toDividends) {\r\n        require(stakes[msg.sender].startStaking != 0, 'You dont have stake');\r\n\r\n        (uint value_, uint toDividends_) = harvested(msg.sender);\r\n        require(mainToken.balanceOf(address(this)) >= (value_ + toDividends_), 'Contract doesnt have enough DES');\r\n    \r\n        stakes[msg.sender].lastHarvest = block.timestamp;\r\n        emit Harvested(msg.sender, value_, toDividends_);\r\n\r\n        require(mainToken.transfer(msg.sender, value_), 'Transfer issues');\r\n        require(mainToken.transfer(dividends, toDividends_), 'Transfer issues');\r\n\r\n\r\n        return (value_, toDividends_);\r\n    }\r\n\r\n    function harvested(address who_) \r\n    public \r\n    view\r\n    returns (uint value_, uint toDividends_) {\r\n        if (stakes[who_].lastHarvest == 0) return (0, 0);\r\n\r\n        Stake memory stake_ = stakes[who_];\r\n\r\n        uint timeNow = block.timestamp;\r\n        if ( (block.timestamp - stake_.startStaking) > maxStakePeriod ) {\r\n            timeNow = stake_.startStaking + maxStakePeriod;\r\n        }\r\n\r\n        uint timePassed_ = timeNow - stake_.lastHarvest;\r\n        uint percentDiv_ = timePassed_ < cutoff ? beforeCutoff: afterCutoff;\r\n\r\n        uint reward_ = (stake_.amount * timePassed_ * (rate + stake_.boost)) / (100 * year);\r\n        uint toDiv_ = (reward_ * percentDiv_) / 100;\r\n\r\n        return (reward_ - toDiv_, toDiv_);\r\n    }\r\n\r\n    function unstake() \r\n    external {\r\n        require(stakes[msg.sender].startStaking != 0, 'You dont have stake');\r\n        require((block.timestamp - stakes[msg.sender].startStaking) >= stakePeriod, 'Time does not pass');\r\n\r\n        harvest();\r\n        \r\n        uint amount_ = stakes[msg.sender].amount;\r\n        require(mainToken.balanceOf(address(this)) >= amount_, 'Contract doesnt have enough DES');\r\n        \r\n        delete stakes[msg.sender];\r\n        emit Unstaked(msg.sender, amount_);\r\n        \r\n        require(mainToken.transfer(msg.sender, amount_), 'Transfer issues');\r\n\r\n    }\r\n\r\n    function getStake(address user_)\r\n    external\r\n    view\r\n    returns (Stake memory) {\r\n        return stakes[user_];\r\n    }\r\n    \r\n    function setRate(uint rate_)\r\n    external\r\n    onlyOwner {\r\n        rate = rate_;\r\n        emit SettedRate(msg.sender, rate_);\r\n    }\r\n\r\n    function setBoost(address for_, uint boost_) \r\n    external\r\n    onlyWhitelist {\r\n        stakes[for_].boost = boost_;\r\n        emit Boosted(for_, boost_);\r\n    }\r\n\r\n    function setDividends(address newDividends_)\r\n    external\r\n    onlyOwner {\r\n        dividends = newDividends_;\r\n        emit SettedDividends(newDividends_);\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dividends_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"name\":\"Boosted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toDividends\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"SettedDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"SettedRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistUser\",\"type\":\"address\"}],\"name\":\"WhitelistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistUser\",\"type\":\"address\"}],\"name\":\"WhitelistRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWhitelistUser\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"afterCutoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beforeCutoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cutoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividends\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"internalType\":\"struct Staking.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toDividends\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"harvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toDividends_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"maxReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWhitelistUser\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"for_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"boost_\",\"type\":\"uint256\"}],\"name\":\"setBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDividends_\",\"type\":\"address\"}],\"name\":\"setDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate_\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastHarvest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"year\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f7909ae68bf8287f692d03fdda35441621b554c3000000000000000000000000b38b3c34e4bb6144c1e5283af720e046ee833a2a000000000000000000000000bf434b109a9cced493903abdb104ddbcb3470428", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d2306849f478f75892ce87fc887f42868f4f5cef20b6eb2b0d8fa282931ea32f"}