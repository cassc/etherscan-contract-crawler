{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n/*\r\n\u2726 \u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u3000\u3000\u3000\u02da\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\u2002\u2002\u3000\u3000. \u3000\u2008\u3000\u3000\u3000\u3000\u3000\r\n. \u3000\u3000\u3000\u3000\u3000\u200a\u200a\u200a\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\u3000\u3000\u3000* .\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u02da .\r\n \u2726 \u2726\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\uff9f\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\r\n \u3000\u3000\u3000\u02da \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000, .\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\uff9f\u3000\u2002\u2002\u3000\u3000\u3000.\u3000\u3000\u3000\r\n \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2726 \u3000\u3000\u3000\u3000\u3000\u3000,\u3000\u3000\u3000\u3000\u3000\u3000\u3000. . \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u3000\u2008\u2008\u2008\u2008\u2008\u200a\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u2008\u3000.\u3000\u3000\u3000\uff9f\u3000\u2008\u200a\u200a\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\r\n                                  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\r\n                                  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\r\n                                  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2550\u255d\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2551      \u3000\u3000\r\n                                  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2551\r\n                                  \u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\r\n                                  \u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d    \u3000\u3000\r\n\u3000\u3000. \u3000\u3000\u3000\u02da\u3000\u3000      \u3000\u3000. \u3000\u3000\u3000\r\n\r\n            \u2580\u2588\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2591\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\r\n            \u2591\u2588\u2591\u2003\u2588\u2580\u2588\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2588\u2584\u2003\u2580\u2584\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2584\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003 \u2003\u2588\u2584\u2588\u2003\u2588\u2580\u2591\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2591\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2584\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2584\u2588\r\n                                                      REFLECT YOUR WAY\r\n                                        \u2726 \u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u3000\u3000\u3000\u02da\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\r\n. \u3000\u3000\u3000\u3000\u3000\u200a\u200a\u200a\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2002\u2002\u3000\u3000\u3000* .\u3000\u3000\u3000\u3000\u3000\u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u02da .\r\n \u2726 \u2726\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\uff9f\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000. \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\r\n \u3000\u3000\u3000\u02da \u2008\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\u3000\u3000\u3000. \u2726 \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000, .\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000.\u3000\u3000\u3000\uff9f\u3000\u2002\u2002\u3000\u3000\u3000.\u3000\u3000\u3000\uff9f\u3000\u3000\u3000\r\n \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2726 \u3000\u3000\u3000\u3000\u3000\u3000,\u3000\u3000\u3000\u3000\u3000\u3000\u3000. . \u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u3000\u2008\u2008\u2008\u2008\u2008\u200a\u3000\u3000\u3000\u3000\u3000\u2008\u2008\u200a\u200a\u2008\u2008\u200a\u200a\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\r\n*/\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be authorized\r\n     */\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    /**\r\n     * Authorize address. Owner only. Calls internal _authorize method\r\n     */\r\n    function authorize(address adr) external onlyOwner {\r\n        _authorize(adr);\r\n    }\r\n    \r\n    function _authorize (address adr) internal {\r\n        authorizations[adr] = true;\r\n    }\r\n    /**\r\n     * Remove address' authorization. Owner only\r\n     */\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function getOwner() external view returns (address);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\nlibrary RocketLibrary {\r\n    struct Holder {\r\n        address _address;\r\n        uint256 totalPurchased;\r\n        uint256 totalSold;\r\n        bool isMerchant;\r\n    }\r\n\r\n    enum TransferType {\r\n        Sell,\r\n        Buy,\r\n        Transfer\r\n    }\r\n\r\n    struct Transfer {\r\n        Holder holder;\r\n        uint256 amt;\r\n        TransferType transferType;\r\n        address from;\r\n        address to;\r\n    }\r\n\r\n    struct Burner {\r\n        uint256 totalBurned;\r\n        uint256 stakingPoints;\r\n        uint256 totalSold;\r\n        uint256 loyaltyBoost;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n        uint256 totalRealisedUndeposited;\r\n        bool isExistingBurner;\r\n        bool isMigrated;\r\n    }\r\n\r\n    struct PlayCounter {\r\n        uint256 totalBurnPlays;\r\n        uint256 totalTransferPlays;\r\n        uint256 totalBuyPlays;\r\n    }\r\n\r\n    struct Winnings {\r\n        uint256 totalWonBurnBoost;\r\n        uint256 totalWonBuyBoost;\r\n        uint256 totalClaimedTransferBoost;\r\n        uint256 lastTimeWonBurnPool;\r\n        uint256 lastTimeWonBuyPool;\r\n        uint256 lastTimeClaimedTransferPool;\r\n    }\r\n\r\n    struct RocketPlayer {\r\n        PlayCounter playCounter;\r\n        Winnings winnings;\r\n        uint256 rocketTokens;\r\n    }\r\n}\r\ninterface IBurnToEarn {\r\n    function updateUser(address holder, uint256 burnedAmount) external; \r\n    function updateBurnToEarnFactors(address holder, uint256 boostID, uint256 updateAmount) external; \r\n    function syncDeposit(uint256 amount) external;\r\n}\r\ninterface IRocketPlay {\r\n    function getPoolThreshold(IERC20 token, uint poolID) external view returns (uint256, uint256);\r\n    function playRocketPools(address sender, address recipient, RocketLibrary.TransferType _transferType, uint256 amount) external;\r\n    function playBurnPools(IERC20 token, address sender, uint poolID, uint256 tokenAmount) external;\r\n    function updatePools(uint256 tokenAmount) external;\r\n    function updatePoolByID(uint256 tokenAmount, uint poolID) external;\r\n    function getFee(IERC20 token, uint poolID) external view returns (uint fee);\r\n    function validatePoolID(IERC20 token, uint poolID) external view returns (bool);\r\n}\r\ninterface IPoolDistributionGateway {\r\n    function depositBNB() external payable;\r\n    function onTransfer(RocketLibrary.Transfer memory _transfer) external;\r\n    function setShares(address from, address to, uint256 fromBalance, uint256 toBalance) external;\r\n}\r\ninterface IRocketForge {\r\n    function getDiscount(address holder) external view returns (uint256, uint256);\r\n}\r\n\r\ncontract RocketFi is IERC20, Auth {\r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    struct Interfaces {\r\n        bool isInterface;\r\n        uint256 merchantFee;\r\n        bool isMerchant;\r\n    }\r\n\r\n    struct RocketContractExclusions {\r\n        bool excludeRocketPlay;\r\n        bool excludePoolDistributionGateway;\r\n        bool excludeBurnToEarn;\r\n        bool excludeRocketForge;\r\n    }\r\n\r\n    struct Fees {\r\n        uint256 sell;\r\n        uint256 transfer;\r\n        uint256 buy;\r\n        uint256 burn; //Always divided by the fee.sell to calculate result\r\n        uint256 rocket; //Always divided by the fee.sell to calculate result\r\n        uint256 burn2Earn; //Always divided by the fee.sell to calculate result\r\n    }\r\n\r\n    // Fees\r\n    Fees public fee = Fees(2000,50,1000,0,375,350);   \r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD; \r\n\r\n    //Maintains tokens to burn seperately during swapback\r\n    uint256 public burnReserve; //keeps track of tokens meant to be burned\r\n    uint256 public burnThreshold = 10 * 1e15; //burn tokens when burn threshold is reached to save gas during transactions\r\n    uint256 public swapThreshold = 250 * 1e15; //swap tokens for BNB on a threshold\r\n    \r\n    //Token Pair Data\r\n    IDEXRouter  public router;\r\n    address     public pair;\r\n    mapping(address => bool) liquidityPairs;\r\n    \r\n    //RocketFi Token Info\r\n    string  constant _name          = \"RocketFi\";\r\n    string  constant _symbol        = \"ROCKETFI\";\r\n    uint8   constant _decimals      = 9;\r\n    uint256 public   _totalSupply   = 1e12 * 1e9;\r\n    uint256 public   _maxTxAmount   = _totalSupply;\r\n    \r\n    //Shareholder Standard Mappings\r\n    mapping(address => uint256)                            _balances;\r\n    mapping(address => mapping(address => uint256))        _allowances;\r\n    mapping(address => bool)                        public isFeeExempt;\r\n    mapping(address => bool)                        public isTxLimitExempt;\r\n    //Shareholder Rocket Mappings\r\n    mapping(address => RocketContractExclusions)    public rocketExclusions; //Manages exclusions with external RocketFi contracts\r\n    mapping (address => Interfaces)                 public interfaces; //Manages Interfacing contracts/merchants allowing contracts to make basic transfer. Custom fees only applicable to merchant/non-interface addresses\r\n    mapping (address => bool)                       public isRocketContract; //Manages each RocketFi contract that is authorized to interact with the burn pools function\r\n    mapping(address => RocketLibrary.Holder)        public holders;\r\n\r\n    //RocketFi Interfaces\r\n    IPoolDistributionGateway public  poolDistributionGateway;\r\n    IRocketPlay              public  rocketPlay;\r\n    IRocketForge             public  rocketForge;\r\n    IBurnToEarn              public  burnToEarn;\r\n\r\n    //Other \r\n    uint256 public  tokensBurned; //Counter for tokens burned within the RocketFi EcoSystem\r\n    bool    private allowContracts; //Used to prevent other contracts from interacting with our holder accessible functions that are not RocketFi contracts. Used to prevent spamming.\r\n    bool    public  enableCustomPool; //Allows interfacing with other IERC20 pools in the RocketPlay contract using the Burn function\r\n\r\n    //Determines if the contract executed a swap. Used to prevent circulation issues.\r\n    bool inSwap;\r\n    modifier swapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    event ErrorEvent(string reason);\r\n    event SetFeeExempt(address _addr, bool _exempt);\r\n    event SetTxLimitExempt(address _addr, bool _exempt);\r\n    event SetDexRouter(IDEXRouter _router);\r\n    event SetNewFees(uint256 _sellFee, uint256 _transferFee, uint256 _buyFee, uint256 _burnFee, uint256 _rocketFee, uint256 _burn2earnFee);\r\n    event SetInterface(address _interfaceAddr, bool _isInterface, uint256 _fee, bool _isMerchant);\r\n    event SetRocketContract(address _rocketContract, bool _enabled);\r\n    event SetRocketExclusions(address _addr, bool _excludeRocketPlay, bool _excludePoolDistributionGateway, bool _excludeBurnToEarn, bool _excludeRocketForge);\r\n    event SetSwapThreshold(uint256 _swapThreshold);\r\n    event SetTxLimit(uint256 _amount);\r\n    event SetContractInteraction(bool _allowContracts);\r\n    event SetContractInteraction(address _pair, bool _value);\r\n    event TokensBurned(address sender, uint256 amountBurned);\r\n\r\n    constructor(address _dexRouter) Auth(msg.sender) {\r\n\r\n        router  = IDEXRouter(_dexRouter);\r\n        pair    = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));\r\n        liquidityPairs[pair] = true;\r\n\r\n        isFeeExempt[msg.sender]     = true;\r\n        isTxLimitExempt[msg.sender] = true;\r\n        isTxLimitExempt[_dexRouter] = true;\r\n        isTxLimitExempt[pair]       = true;\r\n\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        approve(_dexRouter, _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != _totalSupply) {\r\n            _allowances[sender][msg.sender] -= amount;\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if (inSwap || interfaces[sender].isInterface || interfaces[recipient].isInterface)\r\n            return _basicTransfer(sender, recipient, amount);\r\n\r\n        require(amount <= _maxTxAmount || isTxLimitExempt[sender], \"TX Limit Exceeded\");\r\n\r\n        RocketLibrary.TransferType transferType = _determineTransferType(sender, recipient);\r\n\r\n        if (_shouldSwapBack() && transferType != RocketLibrary.TransferType.Transfer)\r\n            _swapBack();\r\n        else if(burnReserve >= burnThreshold)\r\n            _burnTokens();        \r\n\r\n        //RocketPlay\r\n        if (address(rocketPlay) != address(0) && transferType != RocketLibrary.TransferType.Sell && !rocketExclusions[sender].excludeRocketPlay) {\r\n            try rocketPlay.playRocketPools(sender, recipient, transferType, amount) {}\r\n            catch Error (string memory reason) {\r\n                emit ErrorEvent(\"_transferFrom(): rocketPlay.playRocketPools() Failed\");\r\n                emit ErrorEvent(reason);\r\n            }\r\n        }\r\n        \r\n        uint amountAfterFee = _getDiscountAndTakeFee(sender, recipient, amount, transferType);\r\n\r\n        _setMyRocket(sender, recipient);\r\n        \r\n        uint256 sold;\r\n        if(transferType == RocketLibrary.TransferType.Sell)\r\n                sold = amountAfterFee;\r\n\r\n        if(address(burnToEarn) != address(0) && !rocketExclusions[msg.sender].excludeBurnToEarn && sold > 0)\r\n                _updateBurnToEarnFactors(sender, 0, sold);\r\n\r\n        if (address(poolDistributionGateway) != address(0)) { \r\n            uint256 purchased;\r\n            if(transferType == RocketLibrary.TransferType.Buy)\r\n                purchased = amountAfterFee;\r\n\r\n            RocketLibrary.Holder memory holder = _updateHolder(address(sender), purchased, sold, interfaces[sender].isMerchant); //creates & updates holder data. Cumulative information\r\n            RocketLibrary.Transfer memory transf = _buildTransfer(holder, amount, transferType, sender, recipient); //creates a transfer for sending to the distribution gateway\r\n\r\n            try poolDistributionGateway.onTransfer(transf) {} //store transfer data externally to be used across RocketFi EcoSystem\r\n            catch Error (string memory reason) {\r\n                emit ErrorEvent('_transferFrom(): poolDistributionGateway.onTransfer() Failed');\r\n                emit ErrorEvent(reason);\r\n            }\r\n        }\r\n\r\n        emit Transfer(sender, recipient, amountAfterFee);\r\n        return true;\r\n    }\r\n\r\n    function _internalApprove(address spender, uint256 amount) internal returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        return true;\r\n    }\r\n\r\n    function _getDiscountAndTakeFee(address sender, address recipient, uint256 amount, RocketLibrary.TransferType transferType) internal returns (uint256) {\r\n        //Grab holder discount information from the RocketForge\r\n        uint256 buyDiscount;\r\n        uint256 sellDiscount; \r\n        if (address(rocketForge) != address(0)) {\r\n            if(transferType == RocketLibrary.TransferType.Sell && !rocketExclusions[sender].excludeRocketForge) \r\n                (buyDiscount, sellDiscount) = getDiscount(sender);\r\n            if(transferType == RocketLibrary.TransferType.Buy && !rocketExclusions[recipient].excludeRocketForge)\r\n                (buyDiscount, sellDiscount) = getDiscount(recipient);\r\n        }\r\n\r\n        //Calculates and takes applicable fees;\r\n        uint amountAfterFee = isFeeExempt[sender] ? amount : _takeFee(sender, recipient, amount, transferType, buyDiscount, sellDiscount);\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amountAfterFee;\r\n        return amountAfterFee;\r\n    }\r\n\r\n    //execute any time shareholder balances change to maintain mirrored balance values for external reward distributions\r\n    function _setMyRocket(address sender, address recipient) internal {\r\n        if (address(poolDistributionGateway) != address(0)) {\r\n            uint256 balancesSender = _balances[sender];\r\n            uint256 balancesRecipient = _balances[recipient];\r\n\r\n            try poolDistributionGateway.setShares(sender, recipient, balancesSender, balancesRecipient) {} \r\n            catch Error (string memory reason) {\r\n                emit ErrorEvent(\"_transferFrom(): poolDistributionGateway.setShares() Failed\");\r\n                emit ErrorEvent(reason);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateHolder(address sender, uint256 purchased, uint256 sold, bool isMerchant) internal returns (RocketLibrary.Holder memory) {\r\n        \r\n        uint256 _totalPurchased   = holders[sender].totalPurchased + purchased;\r\n        uint256 _totalSold        = holders[sender].totalSold + sold;\r\n        \r\n        RocketLibrary.Holder memory holder = RocketLibrary.Holder(sender, _totalPurchased, _totalSold, isMerchant);\r\n\r\n        holders[sender] = holder;\r\n\r\n        return holder;\r\n    }\r\n\r\n    //determines if the transfer is a buy/sell/transfer\r\n    function _determineTransferType(address _from, address _recipient) internal view returns (RocketLibrary.TransferType) {\r\n        if (liquidityPairs[_recipient]) {\r\n            return RocketLibrary.TransferType.Sell;\r\n        } else if (liquidityPairs[_from]) {\r\n            return RocketLibrary.TransferType.Buy;\r\n        }\r\n        return RocketLibrary.TransferType.Transfer;\r\n    }\r\n\r\n    //creates the transfer type\r\n    function _buildTransfer(RocketLibrary.Holder memory _holder, uint256 _amt, RocketLibrary.TransferType _transferType, address _from, address _to) internal pure returns (RocketLibrary.Transfer memory) {\r\n        RocketLibrary.Transfer memory _transfer = RocketLibrary.Transfer(_holder, _amt, _transferType, _from, _to);\r\n        return _transfer;\r\n    }\r\n\r\n    //handles interface/swap transfers without any other mechanisms. \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        if(!inSwap) _setMyRocket(sender, recipient); //ensures holder's shares are updated in the pool distribution gateway,  dex pairs/contracts are exempt at pool distribution gateway. \r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _takeFee(address _sender, address _receiver, uint256 _amount, RocketLibrary.TransferType _transferType, uint256 _buyDiscount, uint256 _sellDiscount) internal returns (uint256) {\r\n        // Takes the fee and keeps remainder in contract + burnToEarn contract\r\n        uint256 feeAmount = interfaces[_receiver].isMerchant\r\n            ? _amount.mul(interfaces[_receiver].merchantFee).div(10000)\r\n            : _amount.mul(getTotalFee(_transferType, _buyDiscount, _sellDiscount)).div(10000);\r\n\r\n        if (feeAmount > 0) {\r\n            //fund external contracts if fees & hooked contracts are present\r\n            (uint256 rocketPlayAlloc, uint256 burn2earnAlloc) = _fundHookedContracts(_sender, feeAmount);\r\n            \r\n            uint256 finalFee = feeAmount.sub(burn2earnAlloc).sub(rocketPlayAlloc); //removes the Burn-to-Earn/RocketPlay contract allocation when Burn-to-Earn/RocketPlay is active\r\n\r\n            burnReserve += finalFee.mul(fee.burn).div(fee.sell);//update balance for tokens to be burned in batches to save gas\r\n            \r\n            _balances[address(this)] += finalFee;\r\n            emit Transfer(_sender, address(this), finalFee);\r\n        }\r\n        return (_amount - feeAmount);\r\n    }\r\n\r\n    function _fundHookedContracts(address _sender, uint256 feeAmount) internal returns (uint256, uint256) {\r\n\r\n        uint256 burn2earnAlloc; //Allocation to send to the Burn 2 Earn Contract for Rewards\r\n        uint256 rocketPlayAlloc; //Allocation reserved for RocketPlay Contract\r\n\r\n        if(address(rocketPlay) != address(0) && fee.rocket > 0) {\r\n                rocketPlayAlloc = feeAmount.mul(fee.rocket).div(fee.sell);\r\n                _balances[address(rocketPlay)] += rocketPlayAlloc;\r\n                try rocketPlay.updatePools(rocketPlayAlloc) {} catch {}\r\n                emit Transfer(_sender, address(rocketPlay), rocketPlayAlloc);\r\n        }\r\n            \r\n        if(address(burnToEarn) != address(0) && fee.burn2Earn > 0) {\r\n                burn2earnAlloc = feeAmount.mul(fee.burn2Earn).div(fee.sell);\r\n                _balances[address(burnToEarn)] += burn2earnAlloc;\r\n                try burnToEarn.syncDeposit(burn2earnAlloc) {} catch {}\r\n                emit Transfer(_sender, address(burnToEarn), burn2earnAlloc);\r\n        }\r\n        return (rocketPlayAlloc, burn2earnAlloc);\r\n    }\r\n\r\n    function _shouldSwapBack() internal view returns (bool) {\r\n        return ((msg.sender != pair) && (!inSwap) && (_balances[address(this)].sub(burnReserve) >= swapThreshold));\r\n    }\r\n\r\n    function _swapBack() internal swapping {\r\n        uint256 amountToSwap = swapThreshold;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountBNB = address(this).balance;\r\n\r\n        if(address(poolDistributionGateway) != address(0)) {\r\n            try poolDistributionGateway.depositBNB{value : amountBNB}() {\r\n\r\n            } catch Error(string memory reason) {\r\n                emit ErrorEvent(\"_swapBack(): poolDistributionGateway.depositBNB() Failed\");\r\n                emit ErrorEvent(reason);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _playBurnPools(IERC20 token, address holder, uint poolID, uint256 tokenAmount) internal {\r\n        bool success;\r\n        try rocketPlay.validatePoolID(token, poolID) returns (bool _success) {\r\n            success = _success;\r\n        }\r\n        catch Error (string memory reason){\r\n            emit ErrorEvent('_playBurnPools(): rocketPlay.validatePoolID() Failed');\r\n            emit ErrorEvent(reason);\r\n        }\r\n        \r\n        if(success)\r\n        try rocketPlay.playBurnPools(token, holder, poolID, tokenAmount) {} \r\n        catch Error (string memory reason){\r\n            emit ErrorEvent('_playBurnPools(): rocketPlay.playBurnPools() Failed');\r\n            emit ErrorEvent(reason);\r\n        }\r\n    }\r\n\r\n    function _updateBurnToEarnUser(address _holder, uint256 _amountBurned) internal {\r\n        try burnToEarn.updateUser(_holder, _amountBurned) {}\r\n        catch Error (string memory reason){\r\n            emit ErrorEvent('_updateBurnToEarnUser(): burnToEarn.updateUser() Failed');\r\n            emit ErrorEvent(reason);\r\n        }\r\n    }\r\n\r\n    function _updateBurnToEarnFactors(address _holder, uint256 boostID, uint256 amountToUpdate) internal {\r\n        try burnToEarn.updateBurnToEarnFactors(_holder, boostID, amountToUpdate) {}\r\n        catch Error (string memory reason){\r\n            emit ErrorEvent('_updateBurnToEarnFactors(): burnToEarn.updateBurnToEarnFactors() Failed');\r\n            emit ErrorEvent(reason);\r\n        }\r\n    }\r\n\r\n    function _burnAndUpdateSupply(uint256 tokenAmount, uint256 feeAmount) internal {\r\n        uint256 amountToBurn = tokenAmount.sub(feeAmount); //subtract fee allocation from total to determine amount to burn\r\n        uint256 _total_supply = _totalSupply; //gas savings\r\n        _totalSupply = _total_supply.sub(amountToBurn, 'supply cannot be neg');\r\n        _balances[msg.sender] -= tokenAmount; //requires in place in top call will not revert -=\r\n\r\n        _setMyRocket(msg.sender, DEAD); //Dead wallet is exempt inside poolDistributionGateway\r\n\r\n        tokensBurned += amountToBurn;\r\n\r\n        if(address(burnToEarn) != address(0) && !rocketExclusions[msg.sender].excludeBurnToEarn)\r\n            _updateBurnToEarnUser(msg.sender, amountToBurn);\r\n       \r\n        _internalApprove(address(router), _total_supply);\r\n        _internalApprove(address(pair), _total_supply);\r\n        emit Transfer(msg.sender, address(0), amountToBurn);\r\n        emit TokensBurned(msg.sender, amountToBurn);\r\n    }\r\n\r\n    function _takeBurnFee(IERC20 token, uint256 tokenAmount, uint poolID) internal returns (uint256) {\r\n        address _burnToEarn = address(burnToEarn);\r\n        uint rocketPlayFees =  _getRocketFee(token, poolID);   // Grabs current fees from the RocketPlay contract\r\n        uint256 alloc = tokenAmount.mul(rocketPlayFees).div(10000); // Take sell fee alloc and send back to RocketPlay Contract + Other Taxes\r\n        _balances[_burnToEarn] += alloc;\r\n        try burnToEarn.syncDeposit(alloc) {} catch {}\r\n        emit Transfer(msg.sender, _burnToEarn, alloc);\r\n        return alloc;\r\n    }\r\n\r\n    function _burnTokens() internal {\r\n        address _rocketFiAddr = address(this);\r\n        uint256 _burnReserve = burnReserve;\r\n        uint256 _new_supply = _totalSupply.sub(_burnReserve, 'supply cannot be neg');\r\n        _totalSupply = _new_supply;\r\n        _balances[_rocketFiAddr] = _balances[_rocketFiAddr].sub(_burnReserve);\r\n        tokensBurned += _burnReserve;\r\n        burnReserve = 0;\r\n        _allowances[_rocketFiAddr][address(router)] = _new_supply;\r\n        _allowances[_rocketFiAddr][address(pair)] = _new_supply;\r\n    }\r\n\r\n    function _burnTokens(IERC20 token, uint poolID, uint256 tokenAmount, bool justBurn) internal {\r\n        require(tokenAmount > 0, '0 tokens not allowed');\r\n        uint256 feeAmount; //allocation used for fees, default 0\r\n        uint256 _holderBalance = _balances[msg.sender];\r\n\r\n        if(address(rocketPlay) != address(0) && !rocketExclusions[msg.sender].excludeRocketPlay && !justBurn) {\r\n            \r\n            uint256 holdAmount;\r\n            if(allowContracts) // Ensures that external unauthorized contracts are unable to interact with the function. Use to mitigate bot spamming. Only allow rocket contracts\r\n                require(!address(msg.sender).isContract() || isRocketContract[msg.sender],'no external contracts allowed'); \r\n\r\n            (tokenAmount, holdAmount) = _getPoolThreshold(token, poolID);   // Gather poolID thresholds for engaging with the Rocket Play platform\r\n\r\n            require(_holderBalance >= tokenAmount, 'not enough tokens'); // Ensures balances are checked; as tokenAmount of 1 is overridden. RocketPlay returns the number of tokens required to engage\r\n            require(_holderBalance >= holdAmount, 'does not hodl enough');\r\n            \r\n            _playBurnPools(token, msg.sender, poolID, tokenAmount);\r\n\r\n            feeAmount = _takeBurnFee(token, tokenAmount, poolID);\r\n        }\r\n        else\r\n            require(_holderBalance >= tokenAmount, 'does not hodl enough');\r\n\r\n        _burnAndUpdateSupply(tokenAmount, feeAmount);\r\n        \r\n    }    \r\n\r\n    function _takeExternalFee(uint256 feeAmount) internal returns (bool) {\r\n        // Takes the fee and keeps remainder in contract + burnToEarn contract\r\n        if (feeAmount > 0) {\r\n            \r\n            //fund external contracts if fees & hooked contracts are present\r\n            (uint256 rocketPlayAlloc, uint256 burn2earnAlloc) = _fundHookedContracts(msg.sender, feeAmount);\r\n            \r\n            uint256 finalFee = feeAmount.sub(burn2earnAlloc).sub(rocketPlayAlloc); //removes the Burn-to-Earn/RocketPlay contract allocation when Burn-to-Earn/RocketPlay is active\r\n\r\n            //update balance for tokens to be burned in batches to save gas on burn function execution\r\n            burnReserve += finalFee.mul(fee.burn).div(fee.sell);\r\n\r\n            _balances[address(this)] += finalFee;\r\n            emit Transfer(msg.sender, address(this), finalFee);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function _getRocketFee(IERC20 token, uint poolID) internal returns (uint rocketPlayFee) {\r\n        try rocketPlay.getFee(token, poolID) returns (uint _rocketPlayFee) {\r\n            rocketPlayFee = _rocketPlayFee;\r\n        } \r\n        catch Error (string memory reason){\r\n            emit ErrorEvent('_getRocketFee(): rocketPlay.getFee() Failed');\r\n            emit ErrorEvent(reason);\r\n        }\r\n        return rocketPlayFee;\r\n    }\r\n\r\n    function _getPoolThreshold(IERC20 token, uint poolID) internal returns (uint256 poolThreshold, uint256 holdAmount) {\r\n        try rocketPlay.getPoolThreshold(token, poolID) returns (uint256 _poolThreshold, uint256 _holdAmount){\r\n            poolThreshold=_poolThreshold;\r\n            holdAmount = _holdAmount;\r\n        } \r\n        catch Error (string memory reason){\r\n            emit ErrorEvent('_getPoolThreshold(): rocketPlay.getPoolThreshold() Failed');\r\n            emit ErrorEvent(reason);\r\n        }\r\n        return (poolThreshold, holdAmount);\r\n    }\r\n\r\n    // public getters\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return (_totalSupply - balanceOf(DEAD) - balanceOf(address(0)));\r\n    }\r\n    \r\n    function getLiquidityBacking(uint256 _accuracy) public view returns (uint256) {\r\n        return _accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply()); //reserved for external use later\r\n    }\r\n\r\n    function isOverLiquified(uint256 _target, uint256 _accuracy) public view returns (bool) {\r\n        return (getLiquidityBacking(_accuracy) > _target);\r\n    }\r\n\r\n    //grabs total fee based on transfer type\r\n    function getTotalFee(RocketLibrary.TransferType _transferType, uint256 _buyDiscount, uint256 _sellDiscount) public view returns (uint256) {\r\n        if (_transferType == RocketLibrary.TransferType.Sell) {\r\n            uint256 _sellFee = _sellDiscount > 0 ? fee.sell.sub(fee.sell.mul(_sellDiscount).div(10000)) : fee.sell;\r\n            return _sellFee;\r\n        }\r\n        if (_transferType == RocketLibrary.TransferType.Transfer) {\r\n            return fee.transfer;\r\n        }\r\n        else {\r\n            uint256 _buyFee = _buyDiscount > 0 ? fee.buy.sub(fee.buy.mul(_buyDiscount).div(10000)) : fee.buy;\r\n            return _buyFee;\r\n        }\r\n    }\r\n\r\n    //grabs holder discount if applicable from Rocket Forge/Referrals contract\r\n    function getDiscount(address _addr) public returns (uint256 buyDiscount, uint256 sellDiscount) {\r\n\r\n        try rocketForge.getDiscount(_addr) returns (uint256 _buyDiscount, uint256 _sellDiscount){\r\n            buyDiscount = _buyDiscount;\r\n            sellDiscount = _sellDiscount;\r\n\r\n        } catch Error (string memory reason){\r\n            emit ErrorEvent('getDiscount(): rocketForge.getDiscount() Failed');\r\n            emit ErrorEvent(reason);\r\n\r\n            buyDiscount = 0;\r\n            sellDiscount = 0;\r\n        }\r\n        return (buyDiscount, sellDiscount);\r\n    }\r\n\r\n    // authorized setters\r\n    function setNewFees(uint256 _sellFee, uint256 _transferFee, uint256 _buyFee, uint256 _burnFee, uint256 _rocketFee, uint256 _burn2earnFee) external authorized {\r\n        require(_sellFee <= 10000\r\n        && _transferFee <= 10000\r\n        && _buyFee <= 10000\r\n        && _burnFee + _rocketFee + _burn2earnFee <= _sellFee, \"New fees should be less than entire sell fee\");\r\n        \r\n        fee.sell = _sellFee;\r\n        fee.transfer = _transferFee;\r\n        fee.buy = _buyFee;\r\n        fee.burn = _burnFee;\r\n        fee.rocket = _rocketFee;\r\n        fee.burn2Earn = _burn2earnFee;\r\n\r\n        if(_burnFee == 0)\r\n            burnReserve = 0;\r\n        emit SetNewFees( _sellFee,  _transferFee, _buyFee, _burnFee, _rocketFee, _burn2earnFee);\r\n    }\r\n\r\n    //update DEX router\r\n    function setDexRouter(IDEXRouter _router) external authorized {\r\n        router = _router;\r\n        emit SetDexRouter(_router);\r\n    }\r\n\r\n    function setTxLimit(uint256 _amount) external authorized {\r\n        _maxTxAmount = _amount;\r\n        emit SetTxLimit(_amount);\r\n    }\r\n    //allows authorized external contracts to interact with the burn pool\r\n    function setContractInteraction(bool _allowContracts) external authorized {\r\n        allowContracts = _allowContracts;\r\n        emit SetContractInteraction( _allowContracts);\r\n    }\r\n\r\n    function setIsFeeExempt(address _addr, bool _exempt) external authorized {\r\n        isFeeExempt[_addr] = _exempt;\r\n        emit SetFeeExempt(_addr, _exempt);\r\n    }\r\n\r\n    function setIsTxLimitExempt(address _addr, bool _exempt) external authorized {\r\n        isTxLimitExempt[_addr] = _exempt;\r\n        emit SetTxLimitExempt(_addr, _exempt);\r\n    }\r\n\r\n    function setLiquidityPair(address _pair, bool _value) external authorized {\r\n        liquidityPairs[_pair] = _value;\r\n        emit SetContractInteraction(_pair,_value);\r\n    }\r\n    //threshold of RocketFi to collect before burning from supply\r\n    function setBurnThreshold(uint256 _burnThreshold) external authorized {\r\n        burnThreshold = _burnThreshold;\r\n    }\r\n    //threshold to determine how much RocketFi needs to be in the contract to liquidate for rewards\r\n    function setSwapThreshold(uint256 _swapThreshold) external authorized {\r\n        swapThreshold = _swapThreshold;\r\n        emit SetSwapThreshold(_swapThreshold);\r\n    }\r\n    //exempts address from external ecosystem contracts as needed\r\n    function setRocketExclusions(address _addr, bool _excludeRocketPlay, bool _excludePoolDistributionGateway, bool _excludeBurnToEarn, bool _excludeRocketForge) external authorized {\r\n        rocketExclusions[_addr].excludeRocketPlay = _excludeRocketPlay;\r\n        rocketExclusions[_addr].excludePoolDistributionGateway = _excludePoolDistributionGateway;\r\n        rocketExclusions[_addr].excludeBurnToEarn = _excludeBurnToEarn;\r\n        rocketExclusions[_addr].excludeRocketForge = _excludeRocketForge;\r\n        emit SetRocketExclusions( _addr,  _excludeRocketPlay,  _excludePoolDistributionGateway,  _excludeBurnToEarn, _excludeRocketForge);\r\n    }\r\n    //allows basic transfers of tokens without any of the hooks, with the exception of the pool distribution gateway only when present\r\n    function setInterface(address _interfaceAddr, bool _isInterface, uint256 _fee, bool _isMerchant) external authorized {\r\n        interfaces[_interfaceAddr].isInterface = _isInterface;\r\n        interfaces[_interfaceAddr].merchantFee = _fee;\r\n        interfaces[_interfaceAddr].isMerchant  = _isMerchant;\r\n        emit SetInterface(_interfaceAddr, _isInterface, _fee, _isMerchant);\r\n    }\r\n    //set interfacing contract addresses, allows future modularity and upgradeability \r\n    function setContractInterfaces(IPoolDistributionGateway _poolManager, IRocketPlay _rocketPlay, IRocketForge _rocketForge, IBurnToEarn _burnToEarn) external authorized {\r\n        \r\n        //Set Authorizations after setting Rocket Contract Interfaces;\r\n        poolDistributionGateway = _poolManager;\r\n        rocketPlay              = _rocketPlay;\r\n        rocketForge             = _rocketForge;\r\n        burnToEarn              = _burnToEarn;\r\n\r\n        if(address(poolDistributionGateway)!=address(0))\r\n            isRocketContract[address(poolDistributionGateway)] = true;\r\n        if(address(rocketPlay)!=address(0))\r\n            isRocketContract[address(rocketPlay)] = true;\r\n        if(address(rocketForge)!=address(0))\r\n            isRocketContract[address(rocketForge)] = true;\r\n        if(address(burnToEarn)!=address(0))\r\n            isRocketContract[address(burnToEarn)] = true;\r\n    }\r\n    //Allows authorized RocketFi eco system contracts access to the _burnTokens function \r\n    function setRocketContract(address _rocketContract, bool _enabled) external authorized {\r\n        isRocketContract[_rocketContract] = _enabled;\r\n        emit SetRocketContract( _rocketContract, _enabled);\r\n    }\r\n    //Allow additional pools to be rolled for/engaged during burning\r\n    function setCustomPool(bool _enableCustomPool) external authorized {\r\n        enableCustomPool = _enableCustomPool;\r\n    }\r\n    //Allows external Rocket contract/external source contribute directly to contract fees\r\n    function takeFee(uint256 feeAmount) external returns (bool) {\r\n        uint256 holderAmount = _balances[msg.sender];\r\n        require(holderAmount >= feeAmount, 'does not hold enough');\r\n        _balances[msg.sender] -= feeAmount;\r\n        return _takeExternalFee(feeAmount);\r\n    }\r\n    //function to manually kick off swapback\r\n    function manualSwapBack() external {\r\n        if(_shouldSwapBack())\r\n            _swapBack();\r\n    }\r\n    //Manually deposit tokens to the specified rocket pool\r\n    function depositTokenToRocketPools(uint256[3] memory boostAmounts) external {\r\n        address rocketPlayAddr = address(rocketPlay);\r\n        require(rocketPlayAddr != address(0),'not activated');\r\n        uint256 _totalTokens = boostAmounts[0] + boostAmounts[1] + boostAmounts[2];\r\n        require(_balances[msg.sender] >= _totalTokens,'not enough tokens');\r\n        \r\n        uint256 _finalBalance;\r\n        //boostAmounts[0] is BurnBoost;\r\n        //boostAmounts[1] is BuyBoost;\r\n        //boostAmounts[2] is TransferBoost;\r\n\r\n        for(uint x=0; x < boostAmounts.length; x++) {\r\n            if(boostAmounts[x] > 0)\r\n                try rocketPlay.updatePoolByID(x, boostAmounts[x]) {\r\n                _finalBalance += boostAmounts[x];\r\n                } catch {}\r\n        }\r\n\r\n        //only update balances & kick off rewarding rocketfuel points (pool id 2 in Burn To Earn if _finalBalance > 0\r\n        if(_finalBalance > 0){\r\n            if(address(burnToEarn) != address(0) && !rocketExclusions[msg.sender].excludeBurnToEarn)\r\n                    _updateBurnToEarnFactors(msg.sender, 2, _finalBalance);\r\n            _balances[rocketPlayAddr] += _finalBalance;\r\n            _balances[msg.sender] -= _finalBalance;\r\n            _setMyRocket(msg.sender, rocketPlayAddr); //rocketPlayAddr is exempt from the Pool Distribution Participation\r\n        }\r\n    }\r\n    //Public & External Interactive Functions\r\n    //Burn Functions\r\n    function burnTokenOnly(uint256 tokenAmount) external {\r\n        _burnTokens(IERC20(this), 0, tokenAmount, true);\r\n    }\r\n    function burnForDefaultPool(uint poolID) external {\r\n        _burnTokens(IERC20(this), poolID, 1, false);\r\n    }\r\n    function burnForCustomPool(address token, uint poolID) external {\r\n        require(enableCustomPool,'feature not enabled');\r\n        _burnTokens(IERC20(token), poolID, 1, false);\r\n    }\r\n    function transferBNB(address payable _to) external authorized {\r\n        (bool success,) = _to.call{value : address(this).balance}(\"\");\r\n        require(success, \"unable to transfer value\");\r\n    }\r\n\r\n    //Interface functions\r\n    receive() external payable {}\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n    function getOwner() public view override returns (address) {\r\n        return owner;\r\n    }\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function allowance(address holder, address spender) external view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dexRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ErrorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowContracts\",\"type\":\"bool\"}],\"name\":\"SetContractInteraction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"SetContractInteraction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IDEXRouter\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"SetDexRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"SetFeeExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_interfaceAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isInterface\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isMerchant\",\"type\":\"bool\"}],\"name\":\"SetInterface\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rocketFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_burn2earnFee\",\"type\":\"uint256\"}],\"name\":\"SetNewFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_rocketContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"SetRocketContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_excludeRocketPlay\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_excludePoolDistributionGateway\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_excludeBurnToEarn\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_excludeRocketForge\",\"type\":\"bool\"}],\"name\":\"SetRocketExclusions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"}],\"name\":\"SetSwapThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"SetTxLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"SetTxLimitExempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBurned\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"}],\"name\":\"burnForCustomPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolID\",\"type\":\"uint256\"}],\"name\":\"burnForDefaultPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnToEarn\",\"outputs\":[{\"internalType\":\"contract IBurnToEarn\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"burnTokenOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"boostAmounts\",\"type\":\"uint256[3]\"}],\"name\":\"depositTokenToRocketPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableCustomPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rocket\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn2Earn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellDiscount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum RocketLibrary.TransferType\",\"name\":\"_transferType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_buyDiscount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellDiscount\",\"type\":\"uint256\"}],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"holders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalPurchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMerchant\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"interfaces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isInterface\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"merchantFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isMerchant\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRocketContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDistributionGateway\",\"outputs\":[{\"internalType\":\"contract IPoolDistributionGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rocketExclusions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"excludeRocketPlay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"excludePoolDistributionGateway\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"excludeBurnToEarn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"excludeRocketForge\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rocketForge\",\"outputs\":[{\"internalType\":\"contract IRocketForge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rocketPlay\",\"outputs\":[{\"internalType\":\"contract IRocketPlay\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_burnThreshold\",\"type\":\"uint256\"}],\"name\":\"setBurnThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowContracts\",\"type\":\"bool\"}],\"name\":\"setContractInteraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPoolDistributionGateway\",\"name\":\"_poolManager\",\"type\":\"address\"},{\"internalType\":\"contract IRocketPlay\",\"name\":\"_rocketPlay\",\"type\":\"address\"},{\"internalType\":\"contract IRocketForge\",\"name\":\"_rocketForge\",\"type\":\"address\"},{\"internalType\":\"contract IBurnToEarn\",\"name\":\"_burnToEarn\",\"type\":\"address\"}],\"name\":\"setContractInterfaces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enableCustomPool\",\"type\":\"bool\"}],\"name\":\"setCustomPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setDexRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interfaceAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isInterface\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isMerchant\",\"type\":\"bool\"}],\"name\":\"setInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setLiquidityPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rocketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burn2earnFee\",\"type\":\"uint256\"}],\"name\":\"setNewFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rocketContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRocketContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_excludeRocketPlay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_excludePoolDistributionGateway\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_excludeBurnToEarn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_excludeRocketForge\",\"type\":\"bool\"}],\"name\":\"setRocketExclusions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"takeFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RocketFi", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ae44d277ac3cda87674cec525fc72a43f66a4041bcaadf0d2661949f2f35ec78"}