{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n  The original BUSD Pool by BNB Ocean. The most sustainable yield farming protocol.\r\n  See how it works: https://docs.bnbocean.finance/\r\n  Join our Telegram: https://t.me/BNBOceanAnnoucements\r\n*/\r\n\r\npragma solidity ^0.8.1;\r\n\r\ninterface IToken {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract BUSDPool {\r\n    using SafeMath for uint256;\r\n\r\n    IToken public BUSDToken;\r\n\r\n    uint256 private HASH_COEFFICIENT = 6912000;\r\n    uint256 private REFERRAL = 50;\r\n    uint256 private WALLET_DEPOSIT_LIMIT = 100000 * 1e18; /** 25 BNB  **/\r\n\r\n    uint256 private totalStaked;\r\n    uint256 private totalDeposits;\r\n    uint256 private totalCompound;\r\n    uint256 private totalRefBonus;\r\n    uint256 private totalWithdrawn;\r\n\r\n    uint256 private marketLiquidity;\r\n    uint256 private LQ_NUM = 3000;\r\n    uint256 private LQ_DOM = 1000;\r\n    bool private contractStarted;\r\n\r\n    uint256 private MAX_YIELD = 125; // 1.25%\r\n    uint256 private CUTOFF_STEP = 86400; // 24 hours\r\n    uint256 private WITHDRAW_COOLDOWN = 86400 * 7; /** 7 days  **/\r\n    uint256 private TIME_SPAN = 86400 * 7;\r\n\r\n    uint256 private MAX_FEE = 62; // 60%\r\n    uint256 private MIN_FEE = 8; // 8%\r\n\r\n    uint256 private MIN_COMPOUND = 3; // Minimum of 3 compounds before withdraw\r\n    uint256 private MULTIPLIER = 1;\r\n    uint256 private MAX_BONUS = 700; // 3.00x\r\n    uint256 private BONUS_SIZE = 150; // 1.50x\r\n    uint256 private BOOST = 1000;\r\n\r\n    address private owner;\r\n    address private dev1;\r\n\r\n    struct User {\r\n        uint256 initialDeposit;\r\n        uint256 userDeposit;\r\n        uint256 hashRate;\r\n        uint256 claimedYield;\r\n        uint256 lastCompound;\r\n        address referrer;\r\n        uint256 referralsCount;\r\n        uint256 referralRewards;\r\n        uint256 totalWithdrawn;\r\n        uint256 compoundCount;\r\n        uint256 lastWithdrawTime;\r\n        uint256 multiplier;\r\n    }\r\n    mapping(address => User) private users;\r\n\r\n    constructor(address _dev1, address tokenAddress) {\r\n\t\trequire(!isContract(_dev1));\r\n        owner = msg.sender;\r\n        dev1 = _dev1;\r\n        BUSDToken = IToken(tokenAddress);\r\n    }\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n    function compoundYield() public {\r\n        User storage user = users[msg.sender];\r\n        require(contractStarted, \"Contract not yet started.\");\r\n        user.multiplier = min(user.multiplier + calculateMultiplier(msg.sender), MAX_BONUS.mul(1e8));\r\n        user.compoundCount = user.compoundCount.add(1);\r\n        uint256 yieldUsed = getMyYield();\r\n        user.hashRate = user.hashRate.add(yieldUsed.div(HASH_COEFFICIENT));\r\n        user.claimedYield = 0;\r\n        user.lastCompound = block.timestamp;\r\n        marketLiquidity = marketLiquidity.add(yieldUsed);\r\n    }\r\n\r\n    function removeLiquidity() public {\r\n        require(contractStarted);\r\n        User storage user = users[msg.sender];\r\n        require(user.compoundCount >= 3, \"Need to compound 3 times to be able to withdraw!\");\r\n\r\n        uint256 hasYield = getMyYield();\r\n        uint256 sellValue = calculateLiquidityRemoval(hasYield);\r\n        sellValue = min(sellValue, (user.initialDeposit * MAX_YIELD) / 1e4);\r\n        sellValue = (sellValue  * (min(user.multiplier, MAX_BONUS.mul(1e8)) + 1e10)).div(1e10);\r\n        marketLiquidity = marketLiquidity.add(hasYield);\r\n\r\n        if(getBalance() < sellValue) {\r\n            sellValue = getBalance();\r\n        }\r\n\r\n        uint256 yieldPayout = sellValue.sub(payFees(sellValue, msg.sender, false));\r\n        BUSDToken.transfer(msg.sender, yieldPayout);\r\n        user.totalWithdrawn = user.totalWithdrawn.add(yieldPayout);\r\n        user.initialDeposit = user.initialDeposit.add(yieldPayout);\r\n        totalWithdrawn = totalWithdrawn.add(yieldPayout);\r\n\r\n        user.lastWithdrawTime = block.timestamp;\r\n        user.claimedYield = 0;\r\n        user.compoundCount = 0;\r\n        user.multiplier = 0;\r\n        user.lastCompound = block.timestamp;\r\n    }\r\n\r\n    function addLiquidity(address ref, uint256 amount) public payable{\r\n        require(contractStarted);\r\n        User storage user = users[msg.sender];\r\n        require(amount > 1*1e18, \"Mininum investment not met.\");\r\n        require(amount <= WALLET_DEPOSIT_LIMIT, \"Max deposit limit reached.\");\r\n\r\n        BUSDToken.transferFrom(address(msg.sender), address(this), amount);\r\n        uint256 hashRate = calculateLiquidityInjection(amount, getBalance().sub(amount));\r\n        user.userDeposit = user.userDeposit.add(amount);\r\n        user.initialDeposit = user.initialDeposit.add(amount);\r\n        user.claimedYield = user.claimedYield.add(hashRate);\r\n\r\n        if(user.lastWithdrawTime == 0){\r\n            user.lastWithdrawTime = getTimeStamp();\r\n        }\r\n\r\n        if (user.referrer == address(0)) {\r\n            if (ref != msg.sender) {\r\n                user.referrer = ref;\r\n            }\r\n\r\n            address upline1 = user.referrer;\r\n            if (upline1 != address(0)) {\r\n                users[upline1].referralsCount = users[upline1].referralsCount.add(1);\r\n            }\r\n        }\r\n\r\n        if (user.referrer != address(0)) {\r\n            address upline = user.referrer;\r\n            if (upline != address(0)) {\r\n                uint256 refRewards = amount.mul(REFERRAL).div(1e3);\r\n                BUSDToken.transfer(upline, refRewards);\r\n                users[upline].referralRewards = users[upline].referralRewards.add(refRewards);\r\n                totalRefBonus = totalRefBonus.add(refRewards);\r\n            }\r\n        }\r\n\r\n        uint256 yieldPayout = payFees(amount, msg.sender, true);\r\n        totalStaked = totalStaked.add(amount.sub(yieldPayout));\r\n        totalDeposits = totalDeposits.add(1);\r\n        compoundYield();\r\n    }\r\n\r\n    function getCoefficient(uint256 startTime, uint256 limit) internal view returns(uint256) {\r\n        uint256 timeElapsed = getTimeStamp() - startTime;\r\n        uint256 time = min(timeElapsed, limit);\r\n        uint256 x = time.mul(1e4).div(limit);\r\n        return x.mul(x);\r\n    }\r\n\r\n    function calculateMultiplier(address ref) internal view returns(uint256){\r\n        User storage user = users[ref];\r\n        uint256 coef = getCoefficient(user.lastCompound, CUTOFF_STEP).mul(BONUS_SIZE).div(1e4);\r\n        uint256 timeDelta = min(getTimeStamp()-user.lastWithdrawTime, TIME_SPAN).mul(1e4).div(TIME_SPAN);\r\n        coef = coef.mul(timeDelta);\r\n        return coef;\r\n    }\r\n\r\n    function calculateFee(address ref) internal view returns(uint256) {\r\n        require(contractStarted);\r\n        User storage user = users[ref];\r\n        require(user.initialDeposit > 0);\r\n        uint256 x = 1e8;\r\n        return MAX_FEE * (x.sub(getCoefficient(user.lastWithdrawTime, TIME_SPAN))) + (MIN_FEE.mul(x));\r\n    }\r\n\r\n    function payFees(uint256 yieldValue, address ref, bool isDeposit) internal returns(uint256){\r\n        uint256 tax = yieldValue.mul(MIN_FEE.mul(10)).div(1000);\r\n        if(!isDeposit){\r\n            uint256 fee_pct = calculateFee(ref);\r\n            tax = yieldValue.mul(fee_pct).div(1e10);\r\n        }\r\n        BUSDToken.transfer(dev1, tax);\r\n        return tax;\r\n    }\r\n\r\n    function getMultiplier(address ref) private view returns (uint256){\r\n        return min(users[ref].multiplier, MAX_BONUS.mul(1e8)).div(1e7);\r\n    }\r\n\r\n    function getUserInfo(address _adr) public view returns(uint256 _userDeposit, uint256 _hashRate, uint256 _multiplier,\r\n    uint256 _totalWithdrawn, uint256 _withdrawFee, uint256 _userCompounds, uint256 _userYield, uint256 _userPct) {\r\n         _userDeposit = users[_adr].userDeposit;\r\n         _hashRate = users[_adr].hashRate;\r\n         _multiplier = getMultiplier(_adr);\r\n         _totalWithdrawn = users[_adr].totalWithdrawn;\r\n         _withdrawFee = calculateFee(_adr).div(1e6);\r\n         _userCompounds = users[_adr].compoundCount;\r\n         if(getYieldSinceLastCompound(_adr) == 0){\r\n           _userYield = 0;\r\n         } else {\r\n           _userYield = min(calculateLiquidityRemoval(getYieldSinceLastCompound(_adr)), (users[_adr].initialDeposit * MAX_YIELD) / 1e4);\r\n         }\r\n        _userPct = (_userYield.max(1).mul(1e8)).div(_userDeposit);\r\n\t}\r\n\r\n    function getRefInfo(address _adr) public view returns(address _referrer, uint256 _referrals, uint256 _referralRewards){\r\n        _referrer = users[_adr].referrer;\r\n        _referrals = users[_adr].referralsCount;\r\n        _referralRewards = users[_adr].referralRewards;\r\n    }\r\n\r\n    function initialize() public{\r\n        if (!contractStarted) {\r\n    \t\tif (msg.sender == owner) {\r\n    \t\t    require(marketLiquidity == 0);\r\n    \t\t\tcontractStarted = true;\r\n                marketLiquidity = 86400000000;\r\n    \t\t} else revert(\"Not owner!\");\r\n    \t}\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return BUSDToken.balanceOf(address(this));\r\n\t}\r\n\r\n    function getTimeStamp() private view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function getAvailableEarnings(address _adr) private view returns(uint256) {\r\n        uint256 yield = users[_adr].claimedYield.add(getYieldSinceLastCompound(_adr));\r\n        return calculateLiquidityRemoval(yield);\r\n    }\r\n\r\n    function calculateLiquidity(uint256 rt,uint256 rs, uint256 bs) private view returns(uint256){\r\n        return SafeMath.div(SafeMath.mul(LQ_NUM, bs), SafeMath.add(LQ_DOM, SafeMath.div(SafeMath.add(SafeMath.mul(LQ_NUM, rs), SafeMath.mul(LQ_DOM, rt)), rt)));\r\n    }\r\n\r\n    function calculateLiquidityRemoval(uint256 yield) private view returns(uint256){\r\n        return calculateLiquidity(yield, marketLiquidity, getBalance());\r\n    }\r\n\r\n    function calculateLiquidityInjection(uint256 eth,uint256 contractBalance) private view returns(uint256){\r\n        return calculateLiquidity(eth, contractBalance, marketLiquidity);\r\n    }\r\n\r\n    function calculateLiquidityInjectionSimple(uint256 eth) private view returns(uint256){\r\n        return calculateLiquidityInjection(eth, getBalance());\r\n    }\r\n\r\n    function estimateYield(uint256 amount) public view returns(uint256,uint256) {\r\n        uint256 hashAmount = calculateLiquidityInjection(amount , getBalance());\r\n        uint256 hashRate = hashAmount.div(HASH_COEFFICIENT);\r\n        uint256 day = 1 days;\r\n        uint256 yieldPerDay = day.mul(hashRate);\r\n        uint256 earningsPerDay = calculateHashSellForYield(yieldPerDay, amount);\r\n        return(hashRate, earningsPerDay);\r\n    }\r\n\r\n    function calculateHashSellForYield(uint256 yield,uint256 amount) private view returns(uint256){\r\n        return calculateLiquidity(yield,marketLiquidity, getBalance().add(amount));\r\n    }\r\n\r\n    function getSiteInfo() public view returns (uint256 _totalStaked, uint256 _totalDeposits, uint256 _totalRefBonus) {\r\n        return (totalStaked, totalDeposits, totalRefBonus);\r\n    }\r\n\r\n    function getMyHashRate() private view returns(uint256){\r\n        return users[msg.sender].hashRate;\r\n    }\r\n\r\n    function getMyYield() private view returns(uint256){\r\n        return users[msg.sender].claimedYield.add(getYieldSinceLastCompound(msg.sender));\r\n    }\r\n\r\n    function getYieldSinceLastCompound(address adr) public view returns(uint256){\r\n        uint256 secondsSinceLastCompound = block.timestamp.sub(users[adr].lastCompound);\r\n        uint256 cutoffTime = min(secondsSinceLastCompound, CUTOFF_STEP);\r\n        uint256 secondsPassed = (min(HASH_COEFFICIENT, cutoffTime) * BOOST)/1000;\r\n        uint256 yield = secondsPassed.mul(users[adr].hashRate);\r\n        return yield;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function CHANGE_OWNERSHIP(address value) external {\r\n        require(msg.sender == owner, \"Admin use only.\");\r\n        owner = value;\r\n    }\r\n\r\n    function CHANGE_DEV1(address value) external {\r\n        require(msg.sender == dev1, \"Admin use only.\");\r\n        dev1 = value;\r\n    }\r\n\r\n    function _MULTIPLER(uint256 maxBonus, uint256 bonusSize) external {\r\n        require(msg.sender == owner, \"Admin use only.\");\r\n        require(maxBonus >= 200 && maxBonus <= 900); /** min 3x max 10x **/\r\n        require(bonusSize >= 10 && bonusSize <= 400); /** min 1.1x max 5x **/\r\n        MAX_BONUS = maxBonus;\r\n        BONUS_SIZE = bonusSize;\r\n    }\r\n\r\n    function _COMPOUNDS(uint256 compounds) external {\r\n        require(msg.sender == owner, \"Admin use only.\");\r\n        require(compounds >= 0 && compounds <= 5); /** 0 - 5 Compounds required **/\r\n        MIN_COMPOUND = compounds;\r\n    }\r\n\r\n    function _BOOST(uint256 boost) external {\r\n        require(msg.sender == owner, \"Admin use only.\");\r\n        require(boost >= 1000 && boost <= 5000); /** min 1x max 5x **/\r\n        BOOST = boost;\r\n    }\r\n\r\n    function _FEE(uint256 maxFee, uint256 minFee) external {\r\n        require(msg.sender == owner, \"Admin use only.\");\r\n        require(minFee <= 10 && minFee >= 3); /** 3-10% min **/\r\n        require(maxFee >= 50 && maxFee <= 90); /** 50-90% max **/\r\n        MAX_FEE = maxFee;\r\n        MIN_FEE = minFee;\r\n    }\r\n\r\n    function _CUTOFF_STEP(uint256 value) external {\r\n        require(msg.sender == owner, \"Admin use only\");\r\n        require(value <= 5 && value >= 1);\r\n        CUTOFF_STEP = value  * 24 * 60 * 60;\r\n    }\r\n\r\n    function _WITHDRAW_COOLDOWN(uint256 value) external {\r\n        require(msg.sender == owner, \"Admin use only\");\r\n        require(value >= 7 && value <= 14);\r\n        WITHDRAW_COOLDOWN = value * 24 * 60 * 60;\r\n    }\r\n\r\n    function _WALLET_DEPOSIT_LIMIT(uint256 value) external {\r\n        require(msg.sender == owner, \"Admin use only\");\r\n        require(value >= 20);\r\n        WALLET_DEPOSIT_LIMIT = value * 1e18;\r\n    }\r\n}\r\n\r\n/**\r\n\r\nBNB Pool by BNB Ocean\r\n\r\nBuy hashes, compound yield, boost earnings\r\n~1.25% Daily ROI\r\n5% Referral bonus, will go directly to referrer wallet.\r\n8.00x Maximum compound bonus.\r\nNO MINIMUM INVESTMENT\r\n\r\n**/", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dev1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BUSDToken\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"CHANGE_DEV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"CHANGE_OWNERSHIP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boost\",\"type\":\"uint256\"}],\"name\":\"_BOOST\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"compounds\",\"type\":\"uint256\"}],\"name\":\"_COMPOUNDS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_CUTOFF_STEP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minFee\",\"type\":\"uint256\"}],\"name\":\"_FEE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusSize\",\"type\":\"uint256\"}],\"name\":\"_MULTIPLER\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_WALLET_DEPOSIT_LIMIT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_WITHDRAW_COOLDOWN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"estimateYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"getRefInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referrals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referralRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSiteInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalRefBonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_userDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_hashRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userCompounds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userYield\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_userPct\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getYieldSinceLastCompound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BUSDPool", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000015230a9e26f4d86d78a893114063033676d48f0e000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://172c0d004f4226cdf2ac298cbdd4c15eea0f0fc424566f8973d9ef7461745cef"}