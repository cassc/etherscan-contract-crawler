{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\n interface IPancakeSwapPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeSwapRouter{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n      address token,\r\n      uint liquidity,\r\n      uint amountTokenMin,\r\n      uint amountETHMin,\r\n      address to,\r\n      uint deadline,\r\n      bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n  \r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n      uint amountIn,\r\n      uint amountOutMin,\r\n      address[] calldata path,\r\n      address to,\r\n      uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IPancakeSwapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n \r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n \r\n\r\ncontract WhiteTiggerFinance is IBEP20, Auth , ReentrancyGuard{\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    string constant _name = \"White Tigger Finance\";\r\n    string constant _symbol = \"WTF\";\r\n    uint8 constant _decimals = 18;\r\n\r\n    // TOTAL_GONS balances\r\n    mapping (address => uint256) _rBalance;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n\r\n    // controls on transactions to prevent pumping and dumping and sniping\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isTxLimitExempt;\r\n    mapping (address => bool) public isTimelockExempt;\r\n\r\n    bool public blacklistMode = true;\r\n    mapping (address => bool) public isBlacklisted;\r\n    mapping(address => uint256) public lastBuyBlock;\r\n    \r\n    uint256 public deadBlocks = 10;\r\n    uint256 public launchedAt = 0;\r\n    uint256 public launchedAtTime = 0;\r\n    bool public buyCooldownEnabled = true;\r\n    uint8 public cooldownTimerInterval = 15;\r\n    mapping (address => uint) public cooldownTimer;\r\n\r\n\r\n\r\n    // fee structure \r\n    uint256 public liquidityFee    = 5; \r\n    uint256 public treasuryFee    = 8;\r\n    uint256 public totalFee        = treasuryFee +  liquidityFee;\r\n    uint256 public feeDenominator  = 100;\r\n    uint256 public salesFee = 7;\r\n    uint256 public initialsurcharge = 9;\r\n    uint256 public surchargeextra = 2;\r\n\r\n    address public liquidityReceiver;\r\n    address public treasuryReceiver;\r\n    address public teamWallet;\r\n\r\n  \r\n  \r\n\r\n    // exchange settings \r\n    IPancakeSwapPair public pairContract;\r\n   \r\n    IPancakeSwapRouter public router;\r\n    address public pair;\r\n\r\n  \r\n    // on set up complete,  enable trading -  \r\n    bool public tradingOpen = false;\r\n    bool public feesOnNormalTransfers = false;\r\n\r\n    // restrict certain external calls to master of contract\r\n    address public master;\r\n    modifier onlyMaster() {\r\n        require(msg.sender == master || isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\r\n   \r\n\r\n    // supply settings \r\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY =  10**5 * 10**_decimals;\r\n    \r\n    uint256 public rebase_count = 0;\r\n    uint256 public rate;\r\n    uint256 public _totalSupply;\r\n    uint256 private constant MAX_UINT256 = type(uint256).max;  \r\n    uint256 private constant MAX_SUPPLY = type(uint128).max;  \r\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\r\n\r\n    // Max wallet & Transaction\r\n    uint256 public _maxTxAmount =  TOTAL_GONS /   uint256(2000) ;\r\n    uint256 public _maxWalletToken = TOTAL_GONS / uint256(50);\r\n\r\n    // rebase settings \r\n    uint256 public lastRebaseTime;\r\n    int256 public lastRebaseDelta;\r\n    uint256 public rebaseRate = 7349188;\r\n    uint256 public rebaseFrequency = 1800; \r\n    bool public autoRebase;\r\n \r\n   \r\n    constructor () Auth(msg.sender) ReentrancyGuard() {\r\n \r\n       \r\n      router =  IPancakeSwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n       \r\n          \r\n        pair = IPancakeSwapFactory(router.factory()).createPair( router.WETH(), address(this) );\r\n            \r\n        _allowances[address(this)][address(router)] = type(uint256).max;  \r\n        _allowances[address(this)][pair] = type(uint256).max;  \r\n\r\n\r\n        pairContract = IPancakeSwapPair(pair);\r\n\r\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\r\n\r\n        rate = TOTAL_GONS / (_totalSupply);\r\n\r\n        isFeeExempt[treasuryReceiver] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[DEAD] = true;\r\n        isFeeExempt[liquidityReceiver] = true;\r\n        isFeeExempt[teamWallet] = true;\r\n        \r\n        isTxLimitExempt[msg.sender] = true;\r\n        isTxLimitExempt[address(this)] = true;\r\n        isTxLimitExempt[treasuryReceiver] = true;\r\n        isTxLimitExempt[liquidityReceiver] = true;\r\n        isTxLimitExempt[DEAD] = true;\r\n        isTxLimitExempt[teamWallet] = true;\r\n\r\n        isTimelockExempt[msg.sender] = true;\r\n        isTimelockExempt[DEAD] = true;\r\n        isTimelockExempt[address(this)] = true;\r\n        isTimelockExempt[treasuryReceiver] = true;\r\n        isTimelockExempt[liquidityReceiver] = true;\r\n        isTimelockExempt[teamWallet] = true;\r\n\r\n        lastRebaseTime = block.timestamp;\r\n        lastRebaseDelta = 0;\r\n        autoRebase = false;\r\n\r\n  \r\n\r\n       liquidityReceiver =  0x1ade19d48B65336a050651E31337493af5523024;\r\n       treasuryReceiver = 0x43844DFd0f4aA469253381C2eaA4Ae62D914B79e;\r\n       teamWallet = 0x60EF3cB827189EF2a66651f635271F6750d21174;\r\n\r\n        _rBalance[msg.sender] = TOTAL_GONS;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n\r\n    }\r\n\r\n    // manage mistaken direct transfers to contract \r\n    fallback() external payable {}\r\n    receive() external payable { }\r\n\r\n    \r\n    // BEP 20 calls\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _rBalance[account] / (rate);\r\n    }\r\n    \r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function approveMax(address spender)  external returns (bool) {\r\n        return approve(spender,  type(uint256).max);\r\n    }\r\n\r\n    //transfer calls - transfer/transfFrom - both call _transferFrom \r\n    function transfer(address recipient, uint256 amount) external nonReentrant() override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external nonReentrant() override returns (bool) {\r\n        if(_allowances[sender][msg.sender] !=  type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - (amount);  //need to check if sufficient\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    // main transfer function \r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        \r\n        //check if trading is open\r\n        if(!authorizations[sender] && !authorizations[recipient]){\r\n            require(tradingOpen,\"Trading not open yet\");\r\n        }\r\n\r\n      //anti sniping control - prevent repeat buy/sell in same block\r\n      if(blacklistMode){\r\n          if (sender != pair && block.number == lastBuyBlock[sender]) { revert(); }\r\n          if (sender == pair) { lastBuyBlock[recipient] = block.number; }\r\n        }\r\n\r\n\r\n        uint256 rAmount = amount * (rate);\r\n\r\n        \r\n        //if cooldown enabled, prevent repeat purchases from same wallet\r\n        if (sender == pair &&\r\n            buyCooldownEnabled &&\r\n            !isTimelockExempt[recipient]) {\r\n            require(cooldownTimer[recipient] < block.timestamp,\"buy Cooldown exists\");\r\n            cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\r\n        }\r\n\r\n        // block blacklisted addresses\r\n        if(blacklistMode){\r\n            require(!isBlacklisted[sender] && !isBlacklisted[recipient],\"Blacklisted\");    \r\n        }\r\n\r\n        // prevent transaction size exceeding limit\r\n        checkTxLimit(sender, rAmount, (recipient == pair));\r\n\r\n        \r\n\r\n        //reduce sender balance by rAmount\r\n        require(_rBalance[sender] >= (rAmount) , 'Insufficient balance');\r\n        _rBalance[sender] = _rBalance[sender] - (rAmount);  \r\n\r\n\r\n        //check if transaction incurs fee - if so, calculate fee and increase receiver balance by nett after fee\r\n        uint256 amountReceived = (!shouldTakeFee(sender, recipient)) ? rAmount : takeFee(sender, rAmount,(recipient == pair));\r\n     \r\n        _rBalance[recipient] = _rBalance[recipient] + (amountReceived);\r\n\r\n         \r\n        emit Transfer(sender, recipient, amountReceived / (rate));\r\n\r\n        //if autorebase is on and time to rebase call rebase\r\n        if (shouldRebase()) {\r\n           rebase(block.timestamp, int256(_totalSupply * (rebaseRate) / (10 ** 10))); \r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        uint256 rAmount = amount * (rate);\r\n        _rBalance[sender] = _rBalance[sender] - (rAmount);  //need to check if sufficient\r\n        _rBalance[recipient] = _rBalance[recipient] + (rAmount);\r\n        emit Transfer(sender, recipient, rAmount / (rate));\r\n        return true;\r\n    }\r\n\r\n    //check if max transfer limit is exceeded\r\n    function checkTxLimit(address sender, uint256 rAmount,  bool isSell) internal view {\r\n        require(rAmount <= _maxTxAmount || isTxLimitExempt[sender] || !isSell, \"TX Limit Exceeded\");\r\n    }\r\n\r\n\r\n    // check if transfer incurs fee\r\n    function shouldTakeFee(address from, address to) internal view returns (bool) {\r\n      if(isFeeExempt[from] || isFeeExempt[to]){\r\n            return false;\r\n      }else if (feesOnNormalTransfers){\r\n          return true;\r\n      }else{\r\n          return ( pair == from || pair == to);\r\n      }\r\n\r\n    }\r\n\r\n    //calculate fee and credit contract balance with fee amount, return nett amount\r\n    function takeFee(address sender, uint256 rAmount, bool isSell) internal returns (uint256) {\r\n        \r\n        uint256 feeRate = totalFee;\r\n        if(isSell){\r\n            uint256 _salesFee = salesFee; \r\n            if (block.timestamp <  ( launchedAtTime + 240 minutes)) {\r\n              _salesFee = initialsurcharge + (5 * surchargeextra);\r\n            } else if (block.timestamp <  ( launchedAtTime + 480 minutes)) {\r\n                _salesFee = initialsurcharge + (4 * surchargeextra);\r\n            } else if (block.timestamp <  ( launchedAtTime + 720 minutes)) {\r\n                _salesFee = initialsurcharge + (3 * surchargeextra);\r\n            } else if (block.timestamp <  ( launchedAtTime + 960 minutes)) {\r\n                _salesFee = initialsurcharge + (2 * surchargeextra); \r\n            } else if (block.timestamp <  ( launchedAtTime + 1200 minutes)) {\r\n                _salesFee = initialsurcharge + (1 * surchargeextra); \r\n            } else if (block.timestamp <  ( launchedAtTime + 30 days)) {\r\n                _salesFee = initialsurcharge;  \r\n            } \r\n \r\n            feeRate += _salesFee ;\r\n        } \r\n\r\n        uint256 feeAmount = ( rAmount /  feeDenominator ) * (feeRate);\r\n\r\n        if( (launchedAt + deadBlocks) > block.number){\r\n            feeAmount = rAmount / (100) * (99);\r\n        }\r\n\r\n        _rBalance[treasuryReceiver] = _rBalance[treasuryReceiver] + (feeAmount);\r\n\r\n        emit Transfer(sender, address(this), feeAmount / (rate));\r\n\r\n        return rAmount - (feeAmount);\r\n    }\r\n\r\n     \r\n\r\n\r\n   \r\n    // check if automatic rebase should be called \r\n    function shouldRebase() internal view returns (bool) {\r\n      return  autoRebase &&  (_totalSupply < MAX_SUPPLY) && msg.sender != pair   \r\n        &&    block.timestamp >= (lastRebaseTime + rebaseFrequency );\r\n    }\r\n\r\n    //adjust total supply according to delta parameter\r\n    function rebase(uint256 epoch, int256 supplyDelta) internal returns (uint256) {\r\n        rebase_count++;\r\n        if(epoch == 0){\r\n            epoch = rebase_count;\r\n        }\r\n\r\n\r\n        if (supplyDelta == 0) {\r\n            emit LogRebase(epoch, _totalSupply);\r\n            lastRebaseTime = epoch;\r\n            lastRebaseDelta = supplyDelta;\r\n            return _totalSupply;\r\n        }\r\n\r\n        if (supplyDelta < 0) {\r\n            _totalSupply = _totalSupply - (uint256(-supplyDelta));\r\n        } else {\r\n            _totalSupply = _totalSupply + (uint256(supplyDelta));\r\n        }\r\n\r\n        if (_totalSupply > MAX_SUPPLY) {\r\n            _totalSupply = MAX_SUPPLY;\r\n        }\r\n\r\n        rate = TOTAL_GONS / _totalSupply;\r\n        \r\n        //sync up exchange with adjusted supply \r\n       \r\n        pairContract.sync();\r\n\r\n        lastRebaseTime = epoch;\r\n        lastRebaseDelta = supplyDelta;\r\n\r\n        emit LogRebase(epoch, _totalSupply);\r\n        return _totalSupply;\r\n    }\r\n \r\n\r\n    \r\n   \r\n    function manualSync() nonReentrant() external onlyOwner{\r\n        IPancakeSwapPair(pair).sync();\r\n    }\r\n    \r\n    \r\n    // enable / disable trading and set dead blocks \r\n    function tradingStatus(bool _status, uint256 _deadBlocks) nonReentrant() external onlyOwner {\r\n        tradingOpen = _status;\r\n        if(tradingOpen && launchedAt == 0){\r\n            launchedAt = block.number;\r\n            launchedAtTime = block.timestamp;\r\n            deadBlocks = _deadBlocks;\r\n        }\r\n    }\r\n\r\n    function setFeesOnNormalTransfers(bool _enabled) external onlyOwner {\r\n        require(feesOnNormalTransfers != _enabled, \"Not changed\");\r\n        feesOnNormalTransfers = _enabled;\r\n    }\r\n\r\n    // reset launch block\r\n    function launchStatus(uint256 _launchblock) nonReentrant() external onlyOwner {\r\n        launchedAt = _launchblock;\r\n    }\r\n\r\n    \r\n    // set blacklist mode\r\n    function enable_blacklist(bool _status) nonReentrant() external onlyOwner {\r\n        blacklistMode = _status;\r\n    }\r\n\r\n    function setBotBlacklist(address _botAddress, bool _flag) external onlyOwner {\r\n        require(isContract(_botAddress), \"only contract address, not allowed externally owned account\");\r\n        isBlacklisted[_botAddress] = _flag;    \r\n    }\r\n\r\n    // add / remove addresses to blacklist\r\n    function manage_blacklist(address[] calldata addresses, bool status) nonReentrant() external onlyOwner {\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            isBlacklisted[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    // set cooldown flag\r\n    function cooldownEnabled(bool _status, uint8 _interval) nonReentrant() external onlyOwner {\r\n        buyCooldownEnabled = _status;\r\n        cooldownTimerInterval = _interval;\r\n    }\r\n\r\n    // add or remove address to fee exempt\r\n    function setIsFeeExempt(address holder, bool exempt) nonReentrant() external authorized {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n    \r\n    // assign tax limit exemption status to address\r\n    function setIsTxLimitExempt(address holder, bool exempt) nonReentrant() external authorized {\r\n        isTxLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    // assign address with timelock status \r\n    function setIsTimelockExempt(address holder, bool exempt) nonReentrant() external authorized {\r\n        isTimelockExempt[holder] = exempt;\r\n    }\r\n\r\n    \r\n    function setCooldownTimer(address holder) nonReentrant() external authorized {\r\n        cooldownTimer[holder] = block.timestamp + cooldownTimerInterval;\r\n    }\r\n\r\n    \r\n\r\n\r\n    // set buy fees, including total fee and limit to 25%\r\n    function setFees(uint256 _liquidityFee,   uint256 _treasuryFee,   uint256 _salesFee) nonReentrant() external authorized {\r\n        liquidityFee = _liquidityFee;       \r\n        treasuryFee = _treasuryFee;\r\n        totalFee = _liquidityFee +  _treasuryFee  ;\r\n        salesFee = _salesFee;\r\n       \r\n        require((totalFee + _salesFee) <= 49, \"Fees cannot be more than 49%\");\r\n    }\r\n\r\n\r\n function setSurcharge(uint256 _initialsurcharge,   uint256 _surchargeextra) nonReentrant() external authorized {\r\n      initialsurcharge = _initialsurcharge;       \r\n      surchargeextra = _surchargeextra;\r\n  }\r\n \r\n   \r\n    \r\n    // assign main accounts with new addresses\r\n    function setFeeReceivers(address _liquidityReceiver, address _treasuryReceiver ,   address _teamWallet ) nonReentrant() external authorized {\r\n        liquidityReceiver = _liquidityReceiver;\r\n        treasuryReceiver = _treasuryReceiver;\r\n         teamWallet = _teamWallet;\r\n    }\r\n\r\n  \r\n   \r\n\r\n    \r\n   // change pair address\r\n    function setPair(address _pair) nonReentrant() external onlyOwner {\r\n        pair = _pair;\r\n    }\r\n\r\n\r\n    // change liquidity provider\r\n    function setLP(address _address) nonReentrant() external onlyOwner {\r\n        pairContract = IPancakeSwapPair(_address);\r\n        isFeeExempt[_address];\r\n    }\r\n\r\n    // change master address\r\n    function setMaster(address _master) nonReentrant() external onlyOwner {\r\n        master = _master;\r\n    }\r\n\r\n    // set max wallet balance as percentage of supply\r\n    function setMaxWalletPercent_base1000(uint256 maxWallPercent_base1000) nonReentrant() external onlyOwner() {\r\n        _maxWalletToken = TOTAL_GONS / (1000) * (maxWallPercent_base1000);\r\n    }\r\n\r\n    // set max transaction size as percentage of supply\r\n    function setMaxTxPercent_base1000(uint256 maxTXPercentage_base1000) nonReentrant() external onlyOwner() {\r\n        _maxTxAmount = TOTAL_GONS / (1000) * (maxTXPercentage_base1000);\r\n    }\r\n\r\n    \r\n   \r\n   \r\n    \r\n    // get circulating supply - excludes dead and zero balance\r\n    function getCirculatingSupply()   public view returns (uint256) {\r\n        return (TOTAL_GONS - (_rBalance[DEAD]) - (_rBalance[ZERO])) / (rate);\r\n    }\r\n\r\n    \r\n      \r\n    function withdrawAllToTreasury() external   nonReentrant()  onlyOwner {\r\n\r\n        uint256 amountToSwap = _rBalance[address(this)] / (rate);\r\n        require( amountToSwap > 0,\"There are no tokens deposited in token contract\");\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            treasuryReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n  function withdrawAllToTreasuryAmount(uint256 _amount) external   nonReentrant()  onlyOwner {\r\n\r\n        uint256 amountToSwap = _rBalance[address(this)] / (rate);\r\n         require( amountToSwap > 0,\"There are no tokens deposited in token contract\");\r\n         if (amountToSwap > _amount * 10 ** 18 ) {\r\n            amountToSwap = _amount * 10 ** 18;\r\n         } \r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            treasuryReceiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    \r\n\r\n\r\n    // query on limit set on wallet size\r\n    function checkMaxWalletToken() external view returns (uint256) {\r\n        return _maxWalletToken / (rate);\r\n    }\r\n\r\n    // query on limit set on transaction amount\r\n    function checkMaxTxAmount() external view returns (uint256) {\r\n        return _maxTxAmount / (rate);\r\n    }\r\n\r\n   function rescueToken(uint256 tokens) nonReentrant() external onlyOwner returns (bool success){\r\n        return _transferFrom(address(this), msg.sender, tokens * 10 ** 18);\r\n   }\r\n\r\n  // clear out balance in contract \r\n   function clearStuckBalance_sender(uint256 amountPercentage) nonReentrant() external onlyOwner {\r\n        uint256 amountBNB = address(this).balance;\r\n        payable(msg.sender).transfer(amountBNB * amountPercentage / 100);\r\n    }\r\n\r\n\r\n    // call rebase externally with nominal value\r\n    function manualRebase(uint256 epoch, int256 supplyDelta) external onlyOwner {    \r\n          if  ((_totalSupply < MAX_SUPPLY)   ) {\r\n           rebase(epoch, supplyDelta * 10 ** 18);\r\n         }    \r\n    }\r\n\r\n  \r\n    // call rebase externally with percentage value total supply\r\n     function rebase_percentage(uint256 _percentage_base1000, bool reduce) nonReentrant() external onlyMaster returns (uint256 newSupply){\r\n\r\n        if(reduce){\r\n            newSupply = rebase(0,int(_totalSupply / (1000000000) * (_percentage_base1000)) * (-1));\r\n        } else{\r\n            newSupply = rebase(0,int(_totalSupply / (1000000000) * (_percentage_base1000)));\r\n        }\r\n        \r\n    }\r\n\r\n    // enable auto rebase\r\n    function setAutoRebase(bool _flag) nonReentrant() external onlyOwner {\r\n        if (_flag) {\r\n            autoRebase = _flag;\r\n            lastRebaseTime = block.timestamp;\r\n        } else {\r\n            autoRebase = _flag;\r\n        }\r\n    }\r\n\r\n    // change rebase rate - factor of 10**10\r\n   function setRebaseRate( uint256 _rebaseRate ) nonReentrant() external onlyOwner {\r\n        rebaseRate = _rebaseRate;\r\n    }\r\n\r\n    // change rebase frequency - seconds between automatic calls\r\n    function setRebaseFrequency(uint256 _rebaseFrequency) nonReentrant() external onlyOwner {\r\n      rebaseFrequency = _rebaseFrequency;\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n\r\n    // airdrop individual specific number of tokens to batch of addresses \r\n  function multiTransfer(address[] calldata addresses, uint256[] calldata tokens) nonReentrant() external onlyOwner {\r\n\r\n    require(addresses.length < 501,\"GAS Error: max airdrop limit is 500 addresses\"); // to prevent overflow\r\n    require(addresses.length == tokens.length,\"Mismatch between Address and token count\");\r\n\r\n    uint256 airdropcount = 0;\r\n\r\n    for(uint i=0; i < addresses.length; i++){\r\n        airdropcount = airdropcount + tokens[i];\r\n    }\r\n\r\n    require(balanceOf(msg.sender) >= airdropcount, \"Not enough tokens in wallet\");\r\n\r\n    for(uint i=0; i < addresses.length; i++){\r\n        _basicTransfer(msg.sender,addresses[i],tokens[i]);\r\n    }\r\n   \r\n  }\r\n\r\n  // airdrop fixed amount to batch of addresses \r\n  function multiTransfer_fixed(address[] calldata addresses, uint256 tokens) nonReentrant() external onlyOwner {\r\n\r\n    require(addresses.length < 2001,\"GAS Error: max airdrop limit is 2000 addresses\"); // to prevent overflow\r\n\r\n    uint256 airdropcount = tokens * addresses.length;\r\n\r\n    require(balanceOf(msg.sender) >= airdropcount, \"Not enough tokens in wallet\");\r\n\r\n    for(uint i=0; i < addresses.length; i++){\r\n        _basicTransfer(msg.sender,addresses[i],tokens);\r\n    }\r\n}\r\n\r\n   \r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklistMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCooldownEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkMaxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkMaxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"clearStuckBalance_sender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_interval\",\"type\":\"uint8\"}],\"name\":\"cooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cooldownTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTimerInterval\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"enable_blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesOnNormalTransfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialsurcharge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTimelockExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBuyBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseDelta\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_launchblock\",\"type\":\"uint256\"}],\"name\":\"launchStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"manage_blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyDelta\",\"type\":\"int256\"}],\"name\":\"manualRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"multiTransfer_fixed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairContract\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase_count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentage_base1000\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"reduce\",\"type\":\"bool\"}],\"name\":\"rebase_percentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salesFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_botAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setBotBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"setCooldownTimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salesFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setFeesOnNormalTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTimelockExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_master\",\"type\":\"address\"}],\"name\":\"setMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTXPercentage_base1000\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent_base1000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent_base1000\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent_base1000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"setPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rebaseFrequency\",\"type\":\"uint256\"}],\"name\":\"setRebaseFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rebaseRate\",\"type\":\"uint256\"}],\"name\":\"setRebaseRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialsurcharge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_surchargeextra\",\"type\":\"uint256\"}],\"name\":\"setSurcharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surchargeextra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_deadBlocks\",\"type\":\"uint256\"}],\"name\":\"tradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllToTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAllToTreasuryAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WhiteTiggerFinance", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://38e463d71cc420672dd4df5043f3652249f6783c9f6d719b60e7e2710e4da3c3"}