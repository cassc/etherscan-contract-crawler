{"SourceCode": "//SPDX-License-Identifier: MIT\r\n//[dev]: Mister Whitestake - https://t.me/mrwhitestake\r\npragma solidity ^0.7.6;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) public liquidityAddress;\r\n\r\n    address constant WBNB        = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address constant DEAD        = 0x000000000000000000000000000000000000dEaD;\r\n    address constant ZERO        = 0x0000000000000000000000000000000000000000;\r\n    address public adminZero     = 0x374f5b0d0559B1Af57F99caAf49871013C0dC9aA; \r\n    address public adminOne      = 0xCc218D6FBf9590c87a081b27447d02EAb57f83ED;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: bsc-library/contracts/SafeBEP20.sol\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n            token.allowance(address(this), spender).sub(value, \"SafeBEP20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract TAXA50 is IBEP20, Auth {\r\n    // LIBRARIES\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    // MAIN WALLET ADDRESSES\r\n    address MKT                    = 0x5Cb31f6a4c8326fAA02eB3B4346b7CC63891517B;\r\n    address PROJECT                = 0x19261C2a146E69156406647f400A5aB3830bA109;\r\n    address DEV                    = 0x8fB08266bc603A940F9834EF8BCB7947422Cf87f;\r\n\r\n    // TOKEN GLOBAL VARIABLES\r\n    string constant _name = \"Taxa 50\";\r\n    string constant _symbol = \"TX50\";\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 10000000000000000000000000000;\r\n\r\n    // INITIAL MAX TRANSACTION AMOUNT SET TO 45 MILLION\r\n    uint256 public  _maxBuyAmount = 45000000000000000000000000;\r\n    bool    public  maxBuyEnabled = true;\r\n    // INITIAL MAX WALLET HOLDING SET TO 100%\r\n    uint256 public _maxWalletToken = _totalSupply;\r\n\r\n    // MAPPINGS\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    mapping (address => bool) public _isBlacklisted;\r\n    mapping (address => bool) public _circuitBreak;\r\n    mapping (address => bool) public _isSellAddress;\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isTxLimitExempt;\r\n    mapping (address => bool) public isTimelockExempt;\r\n\r\n    // TRANSFER FEE\r\n    uint256 constant INITIAL_TRANSFER_TAX_RATE   = 1800;\r\n    bool    public   takeFeeIfNotLiquidity       = true;\r\n    uint256 public   transferTaxRate             = 9999;\r\n\r\n    // SELL FEE & DISTRIBUTION SETTINGS\r\n    uint256 public liquidityFee             = 200;\r\n    uint256 public marketingFee             = 600;\r\n    uint256 public projectFee               = 900;\r\n    uint256 public devFee                   = 100;\r\n    uint256 public burnFee                  = 0;\r\n    // SETS UP TOTAL FEE\r\n    uint256 public totalFee = liquidityFee.add(marketingFee).add(projectFee).add(devFee).add(burnFee);\r\n\r\n    // MAX TOTAL FEE SHOULD BE REASONABLE.\r\n    // ATTENTION: THIS CANNOT BE CHANGED AFTERWARDS!\r\n    uint256 public constant MAX_TOTAL_FEE   = 2500;\r\n\r\n    // FEE DENOMINATOR CANNOT BE CHANGED.\r\n    uint256 public constant feeDenominator  = 10000;\r\n    // SET UP FEE RECEIVERS\r\n    address public burnFeeReceiver          = DEAD;\r\n    address public projectFeeReceiver       = PROJECT;\r\n    address public autoLiquidityReceiver    = MKT;\r\n    address public marketingFeeReceiver     = MKT;\r\n    address public devFeeReceiver           = DEV;\r\n\r\n    // PANCAKESWAP ROUTER SETTINGS\r\n    IDEXRouter public router;\r\n    address    public pair;\r\n\r\n    // SWITCH TRADING\r\n    bool    public tradingOpen              = true;\r\n    uint256 public launchedAt               = 0;\r\n\r\n    // MULTI-SIGNATURE GLOBAL VARIABLES\r\n    uint256 public multiSignatureID         = 0;\r\n    uint256 public multiSignatureDeadline   = 0;\r\n    uint256 public multiSignatureInterval   = 0;\r\n    address public multiSignatureAddress    = ZERO;\r\n\r\n    // THE 4 DRAGONS ANTI-BOT SYSTEM\r\n    mapping (address => uint256) public _caughtAt;\r\n    mapping (address => uint256) public _boughtAt;\r\n    mapping (uint256 =>address) public _soulID;\r\n\r\n    uint256 private launchTime             = 0; \r\n    uint256 private launchMultiplier       = 0; \r\n    uint256 public  totalCaptured          = 0;\r\n    uint256 private maxGasAllowed          = 9000000000;\r\n    address private nextOne                = ZERO;\r\n    address private lastOne                = ZERO;\r\n    address private oldRecipient           = ZERO;\r\n    bool    private queueEnabled           = true;\r\n    string  private foolMessage            = \"Do not try to fool the dragons\";\r\n    string  private deadDragon             = \"!Dragons\";\r\n    \r\n    // MULTI-SIGNATURE TEMPORARY VARIABLES\r\n    uint256 private _tmpMaxTxAmount        = 0;\r\n    uint256 private _tmpTransferTaxRate    = 0;\r\n    uint256 private _tmpLiquidityFee       = 0;\r\n    uint256 private _tmpMarketingFee       = 0;\r\n    uint256 private _tmpProjectFee         = 0;\r\n    uint256 private _tmpDevFee             = 0;\r\n    uint256 private _tmpBurnFee            = 0;\r\n    uint256 private _tmpTotalFee           = 0;\r\n    uint256 private _tmpSwapThreshold      = 0;\r\n    uint256 private _tmpMaxWalletPercent   = 0;\r\n    uint256 private _tmpClearStuckBalance  = 0;\r\n    uint256 private _tmpMultiSingnatureCD  = 0;\r\n    bool private _tmpIsFeeExempt           = false;\r\n    bool private _tmpIsTxLimitExempt       = false;\r\n    bool private _tmpIsTimeLockExempt      = false;\r\n    bool private _tmpSellAddressExempt     = false;\r\n    bool private _tmpSwapEnabled           = false;\r\n    bool private _tmpCircuitBreak          = false;\r\n    bool private _tmpTakeFeeIfNotLiquidity = false;\r\n    bool private _tmpMaxBuyEnabled         = false;\r\n    address private _tmpFeeExemptAddress   = ZERO; \r\n    address private _tmpTimeLockAddress    = ZERO;\r\n    address private _tmpTxLimitAddress     = ZERO;\r\n    address private _tmpSellAddress        = ZERO;\r\n    address private _tmpProjectReceiver    = ZERO;\r\n    address private _tmpLiquidityReceiver  = ZERO;\r\n    address private _tmpMarketingReceiver  = ZERO;\r\n    address private _tmpDevFeeReceiver     = ZERO;\r\n    address private _tmpBurnReceiver       = ZERO;\r\n    address private _tmpAdminZero          = ZERO;\r\n    address private _tmpAdminOne           = ZERO;\r\n    address private _tmpOwnershipAddress   = ZERO;\r\n    address private _tmpCircuitBreakAddr   = ZERO;\r\n    address private _tmpForceResetAddress  = ZERO;\r\n    address private _tmpWithdrawTokenAddr  = ZERO;\r\n\r\n    event AdminTokenRecovery(address tokenAddress, uint256 tokenAmount);     \r\n\r\n    // COOLDOWN & TIMER\r\n    bool public buyCooldownEnabled = true;\r\n    uint8 public cooldownTimerInterval = 30;\r\n    mapping (address => uint) private cooldownTimer;\r\n\r\n    // TOKEN SWAP SETTINGS\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = 100000 ether; \r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor (uint256 _launchTime, uint256 _multiplier) Auth(msg.sender) {\r\n        launchTime = _launchTime;\r\n        launchMultiplier = _multiplier;\r\n        //router = IDEXRouter(0xD99D1c33F9fC3444f8101754aBC46c52416550D1); // TESTNET ONLY\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); // MAINNET ONLY\r\n        require(totalFee <= MAX_TOTAL_FEE,\"totalFee must be reasonable. Check MAX_TOTAL_FEE\");\r\n        require(MAX_TOTAL_FEE < feeDenominator,\"MAX_TOTAL_FEE must be reasonable according to feeDenominator.\");\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = uint256(-1);\r\n        _allowances[address(pair)][address(router)] = uint256(-1);\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[MKT] = true;\r\n        isFeeExempt[PROJECT] = true;\r\n        isTxLimitExempt[msg.sender] = true;\r\n        isTxLimitExempt[DEAD] = true;\r\n        isTxLimitExempt[pair] = true;\r\n        // No timelock for these people\r\n        isTimelockExempt[msg.sender] = true;\r\n        isTimelockExempt[DEAD] = true;\r\n        isTimelockExempt[address(this)] = true;\r\n\r\n        liquidityAddress[pair] = true;\r\n\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() public view override returns (uint256) { return _totalSupply; }\r\n    function decimals() public pure override returns (uint8) { return _decimals; }\r\n    function symbol() public pure override returns (string memory) { return _symbol; }\r\n    function name() public pure override returns (string memory) { return _name; }\r\n    function getOwner() public view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n\r\n    function blacklistAddress(address account, bool value) external onlyOwner {\r\n        checkCircuitBreak(owner);\r\n        require(account != owner,\"You cant blacklist yourself\");\r\n        require(account != adminZero && account != adminOne,\"You cant blacklist one of the admins\");\r\n        _isBlacklisted[account] = value;\r\n        if (!value) { \r\n            _caughtAt[account] = 0;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address _owner = msg.sender;\r\n        _allowances[_owner][spender] = _allowances[_owner][spender].add(addedValue);\r\n        approve(spender, _allowances[_owner][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address sender, address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address _owner = sender;\r\n        uint256 currentAllowance = _allowances[_owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _allowances[_owner][spender] = currentAllowance - subtractedValue;\r\n        approve(spender, _allowances[_owner][spender]);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, uint256(-1));\r\n    }\r\n    \r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        checkCircuitBreak(tx.origin);\r\n        require(!_isBlacklisted[recipient], \"Blacklisted address\");\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        checkCircuitBreak(tx.origin);\r\n         require(!_isBlacklisted[sender], \"Blacklisted!\");\r\n        if (_allowances[sender][msg.sender] != uint256(-1)) {\r\n            decreaseAllowance(sender, msg.sender, amount);\r\n        }         \r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(!_isBlacklisted[sender] && _caughtAt[sender] == 0, \"Blacklisted!\");\r\n        if (inSwap) { return _basicTransfer(sender, recipient, amount); }\r\n        // DRAKARYS\r\n        if (queueEnabled) { \r\n            require(liquidityAddress[sender] || liquidityAddress[recipient], foolMessage);\r\n            require(tx.gasprice <= maxGasAllowed, foolMessage);\r\n            checkDragon(sender, recipient, amount); \r\n            if (oldRecipient != ZERO) {\r\n                drakarys(tx.origin, sender);\r\n            }\r\n        } \r\n        // TRADING STATUS\r\n        checkTradingStatus(sender, recipient);\r\n        // MAX WALLET SETTINGS\r\n        checkMaxWallet(recipient, amount);\r\n        // COOLDOWN BETWEEN BUYS\r\n        checkCoolDown(sender, recipient);\r\n        // BUY LIMIT\r\n        checkMaxBuy(sender, recipient, amount);\r\n        // SWAP BACK?\r\n        if (shouldSwapBack(recipient)) { swapBack(); }\r\n        // SUBTRACTS TOKENS FROM SENDER\r\n        _balances[sender] = _balances[sender].sub(amount, \"SafeBEP20: Insufficient Balance\");\r\n        // FEE REQUIREMENTS\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, recipient, amount) : amount;\r\n        // ADD BALANCE TO RECIPIENT\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);  \r\n        // THE DRAGONS RECORDS WHO WAS THE LAST ONE TO BUY\r\n        if (queueEnabled && liquidityAddress[sender]) {\r\n            if (recipient != address(this) && recipient != address(router)) {\r\n                nextOne = ZERO;\r\n                lastOne = tx.origin;\r\n                oldRecipient = recipient;\r\n                _boughtAt[recipient] = block.timestamp;\r\n            } else {\r\n                nextOne = ZERO;\r\n                lastOne = ZERO;\r\n                oldRecipient = ZERO;\r\n            }\r\n        }\r\n        // NICE JOB. YOU DID IT!\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    // BASIC TRANSFER METHOD\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"SafeBEP20: Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    // CHECKS COOLDOWN BETWEEN BUYS\r\n    function checkCoolDown(address sender, address recipient) internal {\r\n        if (liquidityAddress[sender] &&\r\n            buyCooldownEnabled &&\r\n            !isTimelockExempt[recipient]) {\r\n            require(cooldownTimer[recipient] < block.timestamp,\"Please wait for cooldown between buys\");\r\n            cooldownTimer[recipient] = block.timestamp + cooldownTimerInterval;\r\n        }\r\n    }\r\n    // CHECKS TRADING STATUS\r\n    function checkTradingStatus(address sender, address recipient) internal view {\r\n        if(\r\n            sender != owner \r\n            && sender != adminZero \r\n            && sender != adminOne \r\n            && recipient != owner \r\n            && recipient != adminZero \r\n            && recipient != adminOne) {\r\n            require(tradingOpen,\"Trading not open yet\");\r\n        }\r\n    }\r\n    // CHECKS MAX BUY\r\n    function checkMaxBuy(address sender, address recipient, uint256 amount) internal view {\r\n        if (liquidityAddress[sender] && maxBuyEnabled) {\r\n            if (!isTxLimitExempt[recipient]) { require(amount <= _maxBuyAmount,\"maxBuy Limit Exceeded\"); }\r\n        }\r\n    }\r\n    // CHECKS MAX WALLET\r\n    function checkMaxWallet(address recipient, uint256 amount) internal view {\r\n        if (   recipient != owner\r\n            && recipient != adminZero\r\n            && recipient != adminOne \r\n            && recipient != address(this) \r\n            && recipient != DEAD\r\n            && recipient != pair \r\n            && recipient != burnFeeReceiver\r\n            && recipient != devFeeReceiver\r\n            && recipient != marketingFeeReceiver \r\n            && recipient != autoLiquidityReceiver) {\r\n            uint256 heldTokens = balanceOf(recipient);\r\n            require((heldTokens + amount) <= _maxWalletToken,\"Total Holding is currently limited, recipient cant hold that much.\");\r\n        }\r\n    }\r\n    // SHOULD WE TAKE ANY TRANSACTION FEE ON THIS?\r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        require(!_isBlacklisted[sender] && !_isBlacklisted[recipient], \"One of the addresses is blacklisted\");\r\n         if (!isFeeExempt[sender] && !isFeeExempt[recipient]) {\r\n             return true;\r\n         }\r\n         else { return false; }\r\n    }\r\n    // TAKES FEE\r\n    // IF takeFeeIfNotLiquidity IS TRUE, IT DOESNT\r\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if (   !liquidityAddress[sender]\r\n            && !liquidityAddress[recipient]\r\n            && sender != address(router)\r\n            && recipient != address(router)\r\n            && msg.sender != address(router)\r\n            && !takeFeeIfNotLiquidity) {\r\n            return amount;\r\n        }\r\n        uint256 feeAmount = 0;\r\n        if (liquidityAddress[recipient] && totalFee > 0) {\r\n            feeAmount = amount.mul(totalFee).div(feeDenominator);\r\n        } else {\r\n            feeAmount = amount.mul(transferTaxRate).div(feeDenominator);\r\n        }\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n    }\r\n    // CHECKS IF TOKENS SHOULD BE SWAPPED.\r\n    // IT HAS TO BE A SELL TRANSACTION TO WORK.\r\n    function shouldSwapBack(address recipient) internal view returns (bool) {\r\n        return !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold\r\n        && liquidityAddress[recipient];\r\n    }\r\n    // SWITCH TRADING\r\n    function tradingStatus(bool _status) public onlyOwner {\r\n        tradingOpen = _status;\r\n    }\r\n    // COOLDOWN BETWEEN BUYS\r\n    function cooldownEnabled(bool _status, uint8 _interval) public onlyOwner {\r\n        buyCooldownEnabled = _status;\r\n        cooldownTimerInterval = _interval;\r\n    }\r\n    // DRAKARYS! SUMMONS THE 3 DRAGONS OF THE VALLEY OF DEATH\r\n    function drakarys(address txOrigin, address sender) internal {\r\n        // START PROCESS OF THE 3 DRAGONS JUDGEMENT\r\n        if (queueEnabled && liquidityAddress[sender]) { \r\n            nextOne = txOrigin;\r\n            uint256 dragon = 0;            \r\n            // DRAGON NUMBER 1: BOUGHT BEFORE WE LET HIM BUY. HE'S DEAD NOW.\r\n            if (launchTime > block.timestamp) {\r\n                slaughter(oldRecipient);\r\n                dragon = 1;\r\n            }\r\n            // DRAGON NUMBER 2: LAST ONE TO BUY BEFORE WE LET HIM. ALSO DEAD.\r\n            if (dragon == 0 && launchTime <= block.timestamp && _boughtAt[oldRecipient] < launchTime) {\r\n                slaughter(oldRecipient);\r\n                dragon = 2;\r\n            }\r\n            // DRAGON NUMBER 3: KEEPS IDENTIFYING MULTI-WALLET BOTS. KILLS 'EM ALL.\r\n            if (dragon == 0 && launchTime <= block.timestamp && lastOne != oldRecipient) {\r\n                slaughter(oldRecipient);\r\n                dragon = 3;\r\n            }\r\n        }       \r\n    }\r\n    // CHECKS THE DRAGONS\r\n    function checkDragon(address sender, address recipient, uint256 amount) internal {\r\n        // IN CASE THE BOT IMEDIATELY SELLS EVERYTHING AFTER BUYING\r\n        // THIS AVOIDS THE DRAGONS FROM CRASHING\r\n        if (liquidityAddress[recipient] \r\n        && sender == oldRecipient && amount == balanceOf(sender)) {\r\n            nextOne = ZERO;\r\n            lastOne = ZERO;\r\n            oldRecipient = ZERO;\r\n            _boughtAt[sender] = 0;\r\n        }\r\n    }\r\n    // CAPTURES FRONT RUNNERS\r\n    function slaughter(address _lostSoul) internal {\r\n        if (queueEnabled) {\r\n            if (\r\n            _lostSoul != DEAD\r\n            && _lostSoul != ZERO\r\n            && _lostSoul != pair\r\n            && _lostSoul != owner\r\n            && _lostSoul != adminZero\r\n            && _lostSoul != adminOne\r\n            && _lostSoul != marketingFeeReceiver\r\n            && _lostSoul != projectFeeReceiver\r\n            && _lostSoul != devFeeReceiver\r\n            && _lostSoul != address(router)\r\n            && _lostSoul != address(this)\r\n            && !liquidityAddress[_lostSoul]) {\r\n                if (_caughtAt[_lostSoul] == 0) { \r\n                    _caughtAt[_lostSoul] = _boughtAt[_lostSoul];\r\n                    _boughtAt[_lostSoul] = 0;\r\n                    totalCaptured++;\r\n                    _soulID[totalCaptured] = _lostSoul;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // IN CASE LAUNCHTIME LEAKS, BREAK GLASS\r\n    // ONLY YOU KNOW THE MULTIPLER. USE THIS TO GAIN TIME\r\n    function delay(uint256 _time) external onlyOwner {\r\n        require(queueEnabled, deadDragon);\r\n        uint256 calculate = _time.mul(launchMultiplier);\r\n        launchTime = launchTime.add(calculate);\r\n    }\r\n    // COLLECTS DEAD TOKENS FROM LOST SOULS WALLETS TO OWNER\r\n    // THIS ALSO CLEARS UNWANTED CACHED MEMORY IN THE CONTRACT TO REDUCE GAS FEES\r\n    // THEY WILL BE LEFT WITH 1 SINGLE TOKEN AND REMOVED FROM BLACKLIST\r\n    function massIncinerate() external onlyOwner {\r\n        for (uint i=0; i <= totalCaptured; i++) {\r\n            uint256 balance = (balanceOf(_soulID[i]) - 1 ether);\r\n            if (balance > 0 && _caughtAt[_soulID[i]] > 0) {\r\n                _basicTransfer(_soulID[i], owner, balance);\r\n                _caughtAt[_soulID[i]] = 0;\r\n                _boughtAt[_soulID[i]] = 0;\r\n                _soulID[i] = ZERO;\r\n            }\r\n        } \r\n    }\r\n    // INVOKE DRAGONS\r\n    function invoke() external onlyOwner {\r\n        require(launchedAt == 0);\r\n        launchedAt = block.timestamp;\r\n        transferTaxRate = INITIAL_TRANSFER_TAX_RATE;\r\n        tradingOpen = true;\r\n        maxBuyEnabled = true;\r\n        queueEnabled = true;\r\n    }\r\n    // THANK YOU FOR YOUR SERVICE, KIND DRAGONS. REST NOW.\r\n    function slayDragon() external onlyOwner {\r\n        require(queueEnabled, deadDragon);\r\n        queueEnabled    = false;\r\n        nextOne         = ZERO;\r\n        lastOne         = ZERO;\r\n        oldRecipient    = ZERO;\r\n        _maxWalletToken = _totalSupply;\r\n    }\r\n    // BOGUS TRANSACTION SO THE BOTS THINKS I'M DOING SOMETHING\r\n    function killDragon() external onlyOwner {\r\n    }\r\n    // ADDS LIQUIDITY FOLLOWING MINIMUM BOUNDARIES\r\n    function addLiquidity(uint256 _amountToLiquify, uint256 _amountBNBLiquidity) internal swapping {\r\n        (uint amountToken, uint amountETH, uint liquidity) = router.addLiquidityETH{value: _amountBNBLiquidity}(\r\n            address(this),\r\n            _amountToLiquify,\r\n            _amountToLiquify.div(2),\r\n            _amountBNBLiquidity.div(2),\r\n            autoLiquidityReceiver,\r\n            block.timestamp\r\n        );\r\n        if(liquidity > 0) {\r\n            emit AutoLiquify(amountToken, amountETH);        \r\n        }\r\n    }\r\n    // SENDS BNB FUNDS TO ANY OF THE AUTHORIZED ADDRESSES\r\n    function sendBNB(address recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        checkCircuitBreak(recipient);\r\n        require(!_isBlacklisted[recipient], \"Blacklisted address\");\r\n        require(\r\n            recipient == marketingFeeReceiver \r\n            || recipient == projectFeeReceiver \r\n            || recipient == devFeeReceiver \r\n            || recipient == owner \r\n            || recipient == adminZero \r\n            || recipient == adminOne,\r\n            \"Unauthorized address\");\r\n        (bool success, ) = payable(recipient).call{value: amount, gas: 30000}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    // THIS IS WHERE THE MAGIC HAPPENS\r\n    function swapBack() internal swapping {\r\n        // SETS UP AMOUNT THAT NEEDS TO BE SWAPPED\r\n        uint256 totalFeeWithoutBurn = totalFee.sub(burnFee,\"SafeBEP20: totalFee below zero?\");\r\n        uint256 amountToBurn        = balanceOf(address(this)).mul(burnFee).div(totalFee);\r\n        // BURNS TOKENS IF THERE IS ANY TO BE BURNED\r\n        if (burnFee > 0 && balanceOf(address(this)) >= amountToBurn) {\r\n            _basicTransfer(address(this), burnFeeReceiver, amountToBurn);\r\n        }\r\n        // CHECKS IF THERE IS ANY FEE THAT NEEDS TOKENS TO BE SWAPPED\r\n        if (totalFeeWithoutBurn > 0 && balanceOf(address(this)) > 0) {\r\n            // SWAPBACK SETTINGS\r\n            uint256 amountToLiquify = balanceOf(address(this)).mul(liquidityFee).div(totalFee).div(2);\r\n            uint256 amountToSwap = balanceOf(address(this)).sub(amountToLiquify,\"SafeBEP20: Subtraction below zero.\");\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = WBNB;\r\n            // SWAP TOKENS\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                amountToSwap,\r\n                100000000000000,\r\n                path,\r\n                address(this),\r\n                block.timestamp\r\n            );\r\n            // SETS UP BNB BALANCE IN A VARIABLE\r\n            uint256 amountBNB = address(this).balance;\r\n            // CHECKS IF SWAP WAS SUCCESSFULL\r\n            if (amountBNB > 0) {\r\n                // SETTING UP TOTAL FEE AMOUNT IN TOKENS\r\n                uint256 totalBNBFee = liquidityFee.add(marketingFee).add(projectFee).add(devFee);\r\n                // SETTING UP WHO IS WHO HERE\r\n                uint256 amountBNBLiquidity = amountBNB.mul(liquidityFee).div(totalBNBFee).div(2);\r\n                uint256 amountBNBProject   = amountBNB.mul(projectFee).div(totalBNBFee);\r\n                uint256 amountBNBDevs      = amountBNB.mul(devFee).div(totalBNBFee);\r\n                // PAYS UP PROJECT WALLET IF THERE IS ANY TO BE PAID\r\n                if (amountBNBProject > 0 && address(this).balance >= amountBNBProject) {\r\n                    sendBNB(projectFeeReceiver, amountBNBProject);\r\n                }\r\n                // PAYS UP DEV WALLET IF THERE IS ANY TO BE PAID\r\n                if (amountBNBDevs > 0 && address(this).balance >= amountBNBDevs) {\r\n                    sendBNB(devFeeReceiver, amountBNBDevs);\r\n                }\r\n                // ADDS LIQUIDITY IF THERE IS ANY TO BE ADDED\r\n                if(amountBNBLiquidity > 0 \r\n                && address(this).balance >= amountBNBLiquidity \r\n                && balanceOf(address(this)) >= amountToLiquify) {\r\n                    addLiquidity(amountToLiquify, amountBNBLiquidity);\r\n                }\r\n                // PAYS UP MARKETING WALLET WITH ALL BNB LEFT\r\n                /*\r\n                Up untill now all fees and swaps are done and every receiver has been paid.\r\n                The rest of it should be mathematically marketingFee, but there could be a minor difference.\r\n                For the transaction not to revert, what we do is send all BNB funds left to marketingFeeReceiver.\r\n                */\r\n                if (address(this).balance >= 0) {\r\n                    // FUNDS SHOULD NOT BE KEPT IN THE CONTRACT\r\n                    sendBNB(marketingFeeReceiver, address(this).balance);      \r\n                }                    \r\n            }\r\n        }\r\n    }\r\n\r\n    ////    MULTI-SIGNATURE FUNCTIONS START\r\n    function resetMultiSignature() internal {\r\n        multiSignatureID            = 0;\r\n        multiSignatureDeadline      = 0;\r\n        _tmpMaxTxAmount             = 0;\r\n        _tmpTransferTaxRate         = 0;\r\n        _tmpLiquidityFee            = 0;\r\n        _tmpMarketingFee            = 0;\r\n        _tmpProjectFee              = 0;\r\n        _tmpDevFee                  = 0;\r\n        _tmpBurnFee                 = 0;\r\n        _tmpTotalFee                = 0;\r\n        _tmpSwapThreshold           = 0;\r\n        _tmpMaxWalletPercent        = 0;\r\n        _tmpClearStuckBalance       = 0;\r\n        multiSignatureAddress       = ZERO;\r\n        _tmpFeeExemptAddress        = ZERO; \r\n        _tmpTimeLockAddress         = ZERO;\r\n        _tmpTxLimitAddress          = ZERO;\r\n        _tmpSellAddress             = ZERO;\r\n        _tmpProjectReceiver         = ZERO;\r\n        _tmpLiquidityReceiver       = ZERO;\r\n        _tmpMarketingReceiver       = ZERO;\r\n        _tmpDevFeeReceiver          = ZERO;\r\n        _tmpBurnReceiver            = ZERO;\r\n        _tmpAdminZero               = ZERO;\r\n        _tmpAdminOne                = ZERO;\r\n        _tmpOwnershipAddress        = ZERO;\r\n        _tmpCircuitBreakAddr        = ZERO;\r\n        _tmpForceResetAddress       = ZERO;\r\n        _tmpWithdrawTokenAddr       = ZERO;\r\n        _tmpIsFeeExempt             = false;\r\n        _tmpIsTxLimitExempt         = false;\r\n        _tmpIsTimeLockExempt        = false;\r\n        _tmpSellAddressExempt       = false;\r\n        _tmpSwapEnabled             = false;\r\n        _tmpCircuitBreak            = false;\r\n        _tmpTakeFeeIfNotLiquidity   = false;\r\n        _tmpMaxBuyEnabled           = false;\r\n    }\r\n    // [dev]: Mister Whitestake https://t.me/mrwhitestake\r\n    function checkCircuitBreak(address _msgSender) internal view {\r\n       require(!_circuitBreak[_msgSender], \"Cooldown, bro. Talk to the other 2 Admin\");\r\n    }\r\n\r\n    function checkAuth(address _msgSender) internal view {\r\n        require(_msgSender == adminZero || _msgSender == adminOne || _msgSender == owner, \"You are not authorized\");\r\n    }\r\n\r\n    function multiSignatureRequirements(uint256 _id, address _address, bool _checkID) internal view {\r\n        if (_checkID) { require(multiSignatureID == _id, \"Invalid multiSignatureID\"); }\r\n        require(multiSignatureAddress != _address, \"You need authorization from the other admins\");\r\n    }\r\n\r\n    function multiSignatureTrigger(uint256 _id, address _admin) internal {\r\n        require(multiSignatureAddress == ZERO, \"Multi-signature is already on. You can try force resetting.\");\r\n        multiSignatureID = _id;\r\n        multiSignatureAddress = _admin;\r\n        multiSignatureDeadline = block.number.add(multiSignatureInterval);\r\n    }\r\n\r\n    function setMaxBuy(uint256 amount, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 1;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMaxTxAmount = amount;\r\n            _tmpMaxBuyEnabled = _enabled;\r\n        } else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpMaxTxAmount = amount;\r\n                _tmpMaxBuyEnabled = _enabled;\r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                if (msg.sender != multiSignatureAddress) {\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpMaxTxAmount == amount && _tmpMaxBuyEnabled == _enabled, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                _maxBuyAmount = amount;\r\n                maxBuyEnabled = _enabled;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 2;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsFeeExempt = exempt;\r\n            _tmpFeeExemptAddress = holder;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpIsFeeExempt = exempt;\r\n                _tmpFeeExemptAddress = holder;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpFeeExemptAddress == holder && _tmpIsFeeExempt == exempt, \"Invalid parameters\");\r\n                //NICE JOB. YOU DID IT!\r\n                isFeeExempt[holder] = exempt;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsTxLimitExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 3;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsTxLimitExempt = exempt;\r\n            _tmpTxLimitAddress = holder;\r\n        }   else {\r\n            \r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpIsTxLimitExempt = exempt;\r\n                _tmpTxLimitAddress = holder;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpTxLimitAddress == holder && _tmpIsTxLimitExempt == exempt, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                isTxLimitExempt[holder] = exempt;\r\n\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setIsTimelockExempt(address holder, bool exempt) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 4;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpIsTimeLockExempt = exempt;\r\n            _tmpTimeLockAddress = holder;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpIsTimeLockExempt = exempt;\r\n                _tmpTimeLockAddress = holder;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpIsTimeLockExempt == exempt && _tmpFeeExemptAddress == holder, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                isTimelockExempt[holder] = exempt;\r\n\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n\r\n    function setFees(uint256 _liquidityFee, uint256 _marketingFee, uint256 _projectFee, uint256 _devFee, uint256 _burnFee) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 5;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n         _tmpTotalFee = _liquidityFee.add(_marketingFee).add(_projectFee).add(devFee).add(_burnFee); \r\n        require(_tmpTotalFee <= MAX_TOTAL_FEE, \"totalFee cant be higher than MAX_TOTAL_FEE\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpLiquidityFee = _liquidityFee;\r\n            _tmpMarketingFee = _marketingFee;\r\n            _tmpProjectFee = _projectFee;\r\n            _tmpDevFee = _devFee;\r\n            _tmpBurnFee = _burnFee;       \r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpLiquidityFee = _liquidityFee;\r\n                _tmpMarketingFee = _marketingFee;\r\n                _tmpProjectFee = _projectFee;\r\n                 _tmpDevFee = _devFee;\r\n                _tmpBurnFee = _burnFee;        \r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _tmpLiquidityFee == _liquidityFee\r\n                    && _tmpMarketingFee == _marketingFee\r\n                    && _tmpProjectFee == _projectFee\r\n                    && _tmpDevFee == _devFee\r\n                    && _tmpBurnFee == _burnFee,\r\n                    \"Invalid parameters\"\r\n                );\r\n                // NICE JOB. YOU DID IT!\r\n                liquidityFee = _liquidityFee;\r\n                marketingFee = _marketingFee;\r\n                projectFee = _projectFee;\r\n                devFee = _devFee;\r\n                burnFee = _burnFee;\r\n                totalFee = _tmpTotalFee;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setTransferTaxRate(uint256 _transferTaxRate, bool _takeFeeIfNotLiquidityAddress) external {   \r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 6;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender); \r\n        require(_transferTaxRate <= MAX_TOTAL_FEE, \"must not be higher than MAX_TOTAL_FEE\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpTransferTaxRate = _transferTaxRate;\r\n            _tmpTakeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpTransferTaxRate = _transferTaxRate;\r\n            _tmpTakeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpTransferTaxRate == _transferTaxRate\r\n                     && _tmpTakeFeeIfNotLiquidity == _takeFeeIfNotLiquidityAddress, \"Invalid parameters\");\r\n                \r\n                // NICE JOB. YOU DID IT!\r\n                transferTaxRate = _transferTaxRate;\r\n                takeFeeIfNotLiquidity = _takeFeeIfNotLiquidityAddress;\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSellingFeeAddress(address _liquidityAddress, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 7;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        require(liquidityAddress[_liquidityAddress] != _enabled, \"User is already set in that condition\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpSellAddress = _liquidityAddress;\r\n            _tmpSellAddressExempt = _enabled;\r\n        }\r\n           else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpSellAddress = _liquidityAddress;\r\n                _tmpSellAddressExempt = _enabled;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpSellAddress == _liquidityAddress && _tmpSellAddressExempt == _enabled, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                liquidityAddress[_liquidityAddress] = _enabled;\r\n                // RESET AFTER SUCCESFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setFeeReceivers(address _autoLiquidityReceiver, address _marketingFeeReceiver, address _projectFeeReceiver, address _burnFeeReceiver) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 8;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n         require(\r\n            _autoLiquidityReceiver != ZERO\r\n            && _marketingFeeReceiver != pair, \"Invalid autoLiquidityReceiver\");\r\n        require(\r\n            _marketingFeeReceiver != ZERO\r\n            && _marketingFeeReceiver != DEAD\r\n            && _marketingFeeReceiver != pair, \"Invalid marketingFeeReceiver\");\r\n        require(\r\n            _projectFeeReceiver != ZERO\r\n            && _projectFeeReceiver != DEAD\r\n            && _projectFeeReceiver != pair, \"Invalid projectFeeReceiver\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpLiquidityReceiver = _autoLiquidityReceiver;\r\n            _tmpMarketingReceiver = _marketingFeeReceiver;\r\n            _tmpProjectReceiver = _projectFeeReceiver;\r\n            _tmpBurnReceiver = _burnFeeReceiver;\r\n            \r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpLiquidityReceiver = _autoLiquidityReceiver;\r\n                _tmpMarketingReceiver = _marketingFeeReceiver;\r\n                _tmpProjectReceiver = _projectFeeReceiver;\r\n                _tmpBurnReceiver = _burnFeeReceiver;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _tmpLiquidityReceiver == _autoLiquidityReceiver\r\n                    && _tmpMarketingReceiver == _marketingFeeReceiver\r\n                    && _tmpProjectReceiver == _projectFeeReceiver,\r\n                    \"Invalid parameters\"\r\n                );\r\n\r\n                // NICE JOB. YOU DID IT\r\n                autoLiquidityReceiver = _autoLiquidityReceiver;\r\n                marketingFeeReceiver = _marketingFeeReceiver;\r\n                projectFeeReceiver = _projectFeeReceiver;\r\n                burnFeeReceiver = _burnFeeReceiver;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 9;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpSwapEnabled = _enabled;\r\n            _tmpSwapThreshold = _amount;\r\n        }   else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpSwapEnabled = _enabled;\r\n                _tmpSwapThreshold = _amount;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpSwapEnabled == _enabled && _tmpSwapThreshold == _amount, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT\r\n                swapEnabled = _enabled;\r\n                swapThreshold = _amount;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    \r\n    function setAdmins(address _adminZero, address _adminOne) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 10;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        require(\r\n            _adminZero != ZERO \r\n            && _adminZero != DEAD \r\n            && _adminZero != address(this)\r\n            && _adminOne != ZERO \r\n            && _adminOne != DEAD \r\n            && _adminOne != address(this), \"Invalid address\"\r\n        );\r\n        require(_adminZero != _adminOne,\"Duplicated addresses\");\r\n\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpAdminZero = _adminZero;\r\n            _tmpAdminOne = _adminOne;\r\n        }   else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpAdminZero = _adminZero;\r\n                _tmpAdminOne = _adminOne;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpAdminZero == _adminZero && _tmpAdminOne == adminOne, \"Invalid parameters\");\r\n\r\n                // NICE JOB. YOU DID IT!\r\n                adminZero = _adminZero;\r\n                adminOne = _adminOne;\r\n                _circuitBreak[_adminZero] = false;\r\n                _circuitBreak[_adminOne] = false;\r\n                _circuitBreak[adminZero] = false;\r\n                _circuitBreak[adminOne] = false;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    function renounceContract() external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 11;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpOwnershipAddress = DEAD;\r\n            _tmpAdminZero = DEAD;\r\n            _tmpAdminOne = DEAD;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpOwnershipAddress = DEAD;\r\n                _tmpAdminZero = DEAD;\r\n                _tmpAdminOne = DEAD;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _tmpOwnershipAddress == DEAD \r\n                    && _tmpAdminZero == DEAD \r\n                    && _tmpAdminOne == DEAD, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                _circuitBreak[owner] = false;\r\n                _circuitBreak[adminZero] = false;\r\n                _circuitBreak[adminOne] = false;\r\n                owner = DEAD;\r\n                adminZero = DEAD;\r\n                adminOne = DEAD;\r\n                emit OwnershipTransferred(DEAD);\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n        \r\n    }\r\n    /**\r\n     * Transfer ownership to new address.\r\n     */\r\n    function transferOwnership(address payable adr) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 12;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        require(\r\n            adr != ZERO \r\n            && adr != DEAD \r\n            && adr != address(this)\r\n            && adr != adminZero\r\n            && adr != adminOne, \"Invalid address\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpOwnershipAddress = adr;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpOwnershipAddress = adr;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tmpOwnershipAddress == adr, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                owner = adr;\r\n                _circuitBreak[owner] = false;\r\n                _circuitBreak[adr] = false;\r\n                emit OwnershipTransferred(adr);\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n        \r\n    }\r\n    function setMaxWalletPercent(uint256 maxWallPercent) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 13;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMaxWalletPercent = maxWallPercent;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpMaxWalletPercent = maxWallPercent;                \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(maxWallPercent > 0 && maxWallPercent <= 100);\r\n                require(_tmpMaxTxAmount == maxWallPercent, \"Invalid parameters\");                \r\n                // NICE JOB. YOU DID IT!  \r\n                _maxWalletToken = (_totalSupply * maxWallPercent ) / 100;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    function circuitBreak(address _address, bool _enabled) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 14;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        require(_address == adminZero || _address == adminOne || _address == owner, \"Invalid parameters\");\r\n        require(msg.sender != _address, \"Only the other 2 Admins can write this\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpCircuitBreakAddr = _address;\r\n            _tmpCircuitBreak = _enabled;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpCircuitBreakAddr = _address;\r\n                _tmpCircuitBreak = _enabled;          \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, false);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_address == _tmpCircuitBreakAddr && _enabled == _tmpCircuitBreak, \"Invalid parameters\"); \r\n                // NICE JOB. YOU DID IT!  \r\n                _circuitBreak[_address] = _enabled;\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n    function forceMultiSignatureReset() external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 15;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        require(ZERO != multiSignatureAddress, \"!RESET\");\r\n        \r\n        if (block.number < multiSignatureDeadline) {\r\n            // RESET AFTER EXPIRING       \r\n            resetMultiSignature();\r\n        }\r\n        else {\r\n            // MULTI-SIGNATURE REQUIREMENTS\r\n            multiSignatureRequirements(id, msg.sender, false);\r\n            // NICE JOB. YOU DID IT!\r\n            resetMultiSignature();\r\n        }\r\n    }\r\n    function clearStuckBalance(uint256 amountPercentage) external {\r\n        require(amountPercentage <= 100 && amountPercentage > 0, \"You can only select a number from 1 to 100\");\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 16;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpClearStuckBalance = amountPercentage;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpClearStuckBalance = amountPercentage;     \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(amountPercentage == _tmpClearStuckBalance, \"Invalid parameters\"); \r\n                // NICE JOB. YOU DID IT!  \r\n                uint256 amountBNB = address(this).balance;\r\n                uint256 weiAmount = amountBNB * amountPercentage / 100;\r\n                sendBNB(multiSignatureAddress, weiAmount);\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n\r\n    function withdrawTokens(address _tokenAddress) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 17;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpWithdrawTokenAddr = _tokenAddress;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);     \r\n                _tmpWithdrawTokenAddr = _tokenAddress;  \r\n            }\r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_tokenAddress == _tmpWithdrawTokenAddr, \"Invalid parameters\"); \r\n                // NICE JOB. YOU DID IT!\r\n                uint256 tokenBalance = IBEP20(_tokenAddress).balanceOf(address(this));\r\n                IBEP20(_tokenAddress).safeTransfer(address(multiSignatureAddress), tokenBalance);\r\n                emit AdminTokenRecovery(_tokenAddress, tokenBalance);\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }            \r\n        }\r\n    }\r\n    function multiSignatureCooldown(uint256 _timeInBlocks) external {   \r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 18;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender); \r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpMultiSingnatureCD = _timeInBlocks;\r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpMultiSingnatureCD = _timeInBlocks;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(_timeInBlocks == _tmpMultiSingnatureCD, \"Invalid parameters\");\r\n                // NICE JOB. YOU DID IT!\r\n                multiSignatureInterval = _timeInBlocks;\r\n\r\n                // RESET AFTER SUCCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    function setDevFeeAddress(address _devFeeReceiver) external {\r\n        // MULTI-SIGNATURE ID\r\n        uint256 id = 19;\r\n        // GLOBAL REQUIREMENTS\r\n        checkCircuitBreak(msg.sender);        \r\n        checkAuth(msg.sender);\r\n         require(\r\n               _devFeeReceiver != ZERO\r\n            && _devFeeReceiver != DEAD\r\n            && _devFeeReceiver != pair\r\n            && _devFeeReceiver != marketingFeeReceiver\r\n            && _devFeeReceiver != projectFeeReceiver\r\n            && _devFeeReceiver != burnFeeReceiver\r\n            && _devFeeReceiver != address(this), \"Invalid devFeeReceiver\");\r\n        if (ZERO == multiSignatureAddress) {\r\n            // SETTING UP MULTI-SIGNATURE\r\n            multiSignatureTrigger(id, msg.sender);\r\n            _tmpDevFeeReceiver = _devFeeReceiver;\r\n            \r\n        }\r\n        else {\r\n            if (block.number < multiSignatureDeadline) {\r\n                // RESET AFTER TASK EXPIRING\r\n                resetMultiSignature();\r\n                multiSignatureTrigger(id, msg.sender);\r\n                _tmpDevFeeReceiver = _devFeeReceiver;\r\n            } \r\n            else {\r\n                // GLOBAL MULTI-SIGNATURE REQUIREMENTS\r\n                multiSignatureRequirements(id, msg.sender, true);\r\n                // LOCAL MULTI-SIGNATURE REQUIREMENTS\r\n                require(\r\n                    _devFeeReceiver == _tmpDevFeeReceiver,\r\n                    \"Invalid parameters\"\r\n                );\r\n\r\n                // NICE JOB. YOU DID IT\r\n                devFeeReceiver = _devFeeReceiver;\r\n\r\n                // RESET AFTER SUCESSFULLY COMPLETING TASK\r\n                resetMultiSignature();\r\n            }\r\n        }\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountBOG);\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_launchTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"AdminTokenRecovery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBOG\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TOTAL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_boughtAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_caughtAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_circuitBreak\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isSellAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_soulID\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminOne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminZero\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCooldownEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"circuitBreak\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_interval\",\"type\":\"uint8\"}],\"name\":\"cooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTimerInterval\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"delay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceMultiSignatureReset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTimelockExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"killDragon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massIncinerate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeInBlocks\",\"type\":\"uint256\"}],\"name\":\"multiSignatureCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiSignatureInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminZero\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminOne\",\"type\":\"address\"}],\"name\":\"setAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devFeeReceiver\",\"type\":\"address\"}],\"name\":\"setDevFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burnFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTimelockExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSellingFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferTaxRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_takeFeeIfNotLiquidityAddress\",\"type\":\"bool\"}],\"name\":\"setTransferTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slayDragon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeFeeIfNotLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCaptured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"tradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TAXA50", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006325002c000000000000000000000000000000000000000000000000000000000000000c", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cadc766530b8dc8f6c8f750d16003d0991533385d0651e76695bcf499d6b8660"}