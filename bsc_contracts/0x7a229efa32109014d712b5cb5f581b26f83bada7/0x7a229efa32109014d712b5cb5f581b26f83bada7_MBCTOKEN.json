{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IExchange.sol\": {\r\n      \"content\": \"\\n//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\ninterface IPancakeSwapFactory {\\n\\t\\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n\\t\\tfunction feeTo() external view returns (address);\\n\\t\\tfunction feeToSetter() external view returns (address);\\n\\n\\t\\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\t\\tfunction allPairs(uint) external view returns (address pair);\\n\\t\\tfunction allPairsLength() external view returns (uint);\\n\\n\\t\\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n\\t\\tfunction setFeeTo(address) external;\\n\\t\\tfunction setFeeToSetter(address) external;\\n}\\n\\ninterface IPancakeSwapPair {\\n\\t\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\t\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\n\\t\\tfunction name() external pure returns (string memory);\\n\\t\\tfunction symbol() external pure returns (string memory);\\n\\t\\tfunction decimals() external pure returns (uint8);\\n\\t\\tfunction totalSupply() external view returns (uint);\\n\\t\\tfunction balanceOf(address owner) external view returns (uint);\\n\\t\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\n\\t\\tfunction approve(address spender, uint value) external returns (bool);\\n\\t\\tfunction transfer(address to, uint value) external returns (bool);\\n\\t\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\n\\n\\t\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\t\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\t\\tfunction nonces(address owner) external view returns (uint);\\n\\n\\t\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n\\t\\tevent Mint(address indexed sender, uint amount0, uint amount1);\\n\\t\\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n\\t\\tevent Swap(\\n\\t\\t\\t\\taddress indexed sender,\\n\\t\\t\\t\\tuint amount0In,\\n\\t\\t\\t\\tuint amount1In,\\n\\t\\t\\t\\tuint amount0Out,\\n\\t\\t\\t\\tuint amount1Out,\\n\\t\\t\\t\\taddress indexed to\\n\\t\\t);\\n\\t\\tevent Sync(uint112 reserve0, uint112 reserve1);\\n\\n\\t\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\t\\tfunction factory() external view returns (address);\\n\\t\\tfunction token0() external view returns (address);\\n\\t\\tfunction token1() external view returns (address);\\n\\t\\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\t\\tfunction price0CumulativeLast() external view returns (uint);\\n\\t\\tfunction price1CumulativeLast() external view returns (uint);\\n\\t\\tfunction kLast() external view returns (uint);\\n\\n\\t\\tfunction mint(address to) external returns (uint liquidity);\\n\\t\\tfunction burn(address to) external returns (uint amount0, uint amount1);\\n\\t\\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n\\t\\tfunction skim(address to) external;\\n\\t\\tfunction sync() external;\\n\\n\\t\\tfunction initialize(address, address) external;\\n}\\n\\ninterface IPancakeSwapRouter{\\n\\t\\tfunction factory() external pure returns (address);\\n\\t\\tfunction WETH() external pure returns (address);\\n\\n\\t\\tfunction addLiquidity(\\n\\t\\t\\t\\taddress tokenA,\\n\\t\\t\\t\\taddress tokenB,\\n\\t\\t\\t\\tuint amountADesired,\\n\\t\\t\\t\\tuint amountBDesired,\\n\\t\\t\\t\\tuint amountAMin,\\n\\t\\t\\t\\tuint amountBMin,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline\\n\\t\\t) external returns (uint amountA, uint amountB, uint liquidity);\\n\\t\\tfunction addLiquidityETH(\\n\\t\\t\\t\\taddress token,\\n\\t\\t\\t\\tuint amountTokenDesired,\\n\\t\\t\\t\\tuint amountTokenMin,\\n\\t\\t\\t\\tuint amountETHMin,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline\\n\\t\\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\t\\tfunction removeLiquidity(\\n\\t\\t\\t\\taddress tokenA,\\n\\t\\t\\t\\taddress tokenB,\\n\\t\\t\\t\\tuint liquidity,\\n\\t\\t\\t\\tuint amountAMin,\\n\\t\\t\\t\\tuint amountBMin,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline\\n\\t\\t) external returns (uint amountA, uint amountB);\\n\\t\\tfunction removeLiquidityETH(\\n\\t\\t\\t\\taddress token,\\n\\t\\t\\t\\tuint liquidity,\\n\\t\\t\\t\\tuint amountTokenMin,\\n\\t\\t\\t\\tuint amountETHMin,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline\\n\\t\\t) external returns (uint amountToken, uint amountETH);\\n\\t\\tfunction removeLiquidityWithPermit(\\n\\t\\t\\t\\taddress tokenA,\\n\\t\\t\\t\\taddress tokenB,\\n\\t\\t\\t\\tuint liquidity,\\n\\t\\t\\t\\tuint amountAMin,\\n\\t\\t\\t\\tuint amountBMin,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline,\\n\\t\\t\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\n\\t\\t) external returns (uint amountA, uint amountB);\\n\\t\\tfunction removeLiquidityETHWithPermit(\\n\\t\\t\\t\\taddress token,\\n\\t\\t\\t\\tuint liquidity,\\n\\t\\t\\t\\tuint amountTokenMin,\\n\\t\\t\\t\\tuint amountETHMin,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline,\\n\\t\\t\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\n\\t\\t) external returns (uint amountToken, uint amountETH);\\n\\t\\tfunction swapExactTokensForTokens(\\n\\t\\t\\t\\tuint amountIn,\\n\\t\\t\\t\\tuint amountOutMin,\\n\\t\\t\\t\\taddress[] calldata path,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline\\n\\t\\t) external returns (uint[] memory amounts);\\n\\t\\tfunction swapTokensForExactTokens(\\n\\t\\t\\t\\tuint amountOut,\\n\\t\\t\\t\\tuint amountInMax,\\n\\t\\t\\t\\taddress[] calldata path,\\n\\t\\t\\t\\taddress to,\\n\\t\\t\\t\\tuint deadline\\n\\t\\t) external returns (uint[] memory amounts);\\n\\t\\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n\\t\\t\\t\\texternal\\n\\t\\t\\t\\tpayable\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\n\\t\\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n\\t\\t\\t\\texternal\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\n\\t\\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n\\t\\t\\t\\texternal\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\n\\t\\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n\\t\\t\\t\\texternal\\n\\t\\t\\t\\tpayable\\n\\t\\t\\t\\treturns (uint[] memory amounts);\\n\\n\\t\\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n\\t\\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n\\t\\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n\\t\\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n\\t\\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\t\\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\\n\\t\\t\\taddress token,\\n\\t\\t\\tuint liquidity,\\n\\t\\t\\tuint amountTokenMin,\\n\\t\\t\\tuint amountETHMin,\\n\\t\\t\\taddress to,\\n\\t\\t\\tuint deadline\\n\\t\\t) external returns (uint amountETH);\\n\\t\\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n\\t\\t\\taddress token,\\n\\t\\t\\tuint liquidity,\\n\\t\\t\\tuint amountTokenMin,\\n\\t\\t\\tuint amountETHMin,\\n\\t\\t\\taddress to,\\n\\t\\t\\tuint deadline,\\n\\t\\t\\tbool approveMax, uint8 v, bytes32 r, bytes32 s\\n\\t\\t) external returns (uint amountETH);\\n\\t\\n\\t\\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n\\t\\t\\tuint amountIn,\\n\\t\\t\\tuint amountOutMin,\\n\\t\\t\\taddress[] calldata path,\\n\\t\\t\\taddress to,\\n\\t\\t\\tuint deadline\\n\\t\\t) external;\\n\\t\\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\\n\\t\\t\\tuint amountOutMin,\\n\\t\\t\\taddress[] calldata path,\\n\\t\\t\\taddress to,\\n\\t\\t\\tuint deadline\\n\\t\\t) external payable;\\n\\t\\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\\n\\t\\t\\tuint amountIn,\\n\\t\\t\\tuint amountOutMin,\\n\\t\\t\\taddress[] calldata path,\\n\\t\\t\\taddress to,\\n\\t\\t\\tuint deadline\\n\\t\\t) external;\\n}\"\r\n    },\r\n    \"contracts/mbc.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\nimport \\\"./IExchange.sol\\\";\\n\\n\\ncontract Context {\\n\\t// Empty internal constructor, to prevent people from mistakenly deploying\\n\\t// an instance of this contract, which should be used via inheritance.\\n\\tconstructor () internal { }\\n\\n\\tfunction _msgSender() internal view returns (address payable) {\\n\\t\\treturn msg.sender;\\n\\t}\\n\\n\\tfunction _msgData() internal view returns (bytes memory) {\\n\\t\\tthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n\\t\\treturn msg.data;\\n\\t}\\n}\\n    /* --------- Access Control --------- */\\ncontract Ownable is Context {\\n\\taddress private _owner;\\n\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\t/**\\n\\t* @dev Initializes the contract setting the deployer as the initial owner.\\n\\t*/\\n\\tconstructor () internal {\\n\\t\\taddress msgSender = _msgSender();\\n\\t\\t_owner = msgSender;\\n\\t\\temit OwnershipTransferred(address(0), msgSender);\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the address of the current owner.\\n\\t*/\\n\\tfunction owner() public view returns (address) {\\n\\t\\treturn _owner;\\n\\t}\\n\\n\\t/**\\n\\t* @dev Throws if called by any account other than the owner.\\n\\t*/\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t* @dev Leaves the contract without owner. It will not be possible to call\\n\\t* `onlyOwner` functions anymore. Can only be called by the current owner.\\n\\t*\\n\\t* NOTE: Renouncing ownership will leave the contract without an owner,\\n\\t* thereby removing any functionality that is only available to the owner.\\n\\t*/\\n\\tfunction renounceOwnership() public onlyOwner {\\n\\t\\temit OwnershipTransferred(_owner, address(0));\\n\\t\\t_owner = address(0);\\n\\t}\\n\\n\\t/**\\n\\t* @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t* Can only be called by the current owner.\\n\\t*/\\n\\tfunction transferOwnership(address newOwner) public onlyOwner {\\n\\t\\t_transferOwnership(newOwner);\\n\\t}\\n\\n\\t/**\\n\\t* @dev Transfers ownership of the contract to a new account (`newOwner`).\\n\\t*/\\n\\tfunction _transferOwnership(address newOwner) internal {\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n\\t\\temit OwnershipTransferred(_owner, newOwner);\\n\\t\\t_owner = newOwner;\\n\\t}\\n}\\n\\n    /* --------- safe math --------- */\\nlibrary SafeMath {\\n\\t/**\\n\\t* @dev Returns the addition of two unsigned integers, reverting on\\n\\t* overflow.\\n\\t*\\n\\t* Counterpart to Solidity's `+` operator.\\n\\t*\\n\\t* Requirements:\\n\\t* - Addition cannot overflow.\\n\\t*/\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\tuint256 c = a + b;\\n\\t\\trequire(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the subtraction of two unsigned integers, reverting on\\n\\t* overflow (when the result is negative).\\n\\t*\\n\\t* Counterpart to Solidity's `-` operator.\\n\\t*\\n\\t* Requirements:\\n\\t* - Subtraction cannot overflow.\\n\\t*/\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n\\t* overflow (when the result is negative).\\n\\t*\\n\\t* Counterpart to Solidity's `-` operator.\\n\\t*\\n\\t* Requirements:\\n\\t* - Subtraction cannot overflow.\\n\\t*/\\n\\tfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b <= a, errorMessage);\\n\\t\\tuint256 c = a - b;\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the multiplication of two unsigned integers, reverting on\\n\\t* overflow.\\n\\t*\\n\\t* Counterpart to Solidity's `*` operator.\\n\\t*\\n\\t* Requirements:\\n\\t* - Multiplication cannot overflow.\\n\\t*/\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n\\t\\t// benefit is lost if 'b' is also tested.\\n\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n\\t\\tif (a == 0) {\\n\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tuint256 c = a * b;\\n\\t\\trequire(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the integer division of two unsigned integers. Reverts on\\n\\t* division by zero. The result is rounded towards zero.\\n\\t*\\n\\t* Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t* `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t* uses an invalid opcode to revert (consuming all remaining gas).\\n\\t*\\n\\t* Requirements:\\n\\t* - The divisor cannot be zero.\\n\\t*/\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn div(a, b, \\\"SafeMath: division by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n\\t* division by zero. The result is rounded towards zero.\\n\\t*\\n\\t* Counterpart to Solidity's `/` operator. Note: this function uses a\\n\\t* `revert` opcode (which leaves remaining gas untouched) while Solidity\\n\\t* uses an invalid opcode to revert (consuming all remaining gas).\\n\\t*\\n\\t* Requirements:\\n\\t* - The divisor cannot be zero.\\n\\t*/\\n\\tfunction div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\t// Solidity only automatically asserts when dividing by 0\\n\\t\\trequire(b > 0, errorMessage);\\n\\t\\tuint256 c = a / b;\\n\\t\\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n\\t\\treturn c;\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t* Reverts when dividing by zero.\\n\\t*\\n\\t* Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t* opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t* invalid opcode to revert (consuming all remaining gas).\\n\\t*\\n\\t* Requirements:\\n\\t* - The divisor cannot be zero.\\n\\t*/\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\t\\treturn mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n\\t}\\n\\n\\t/**\\n\\t* @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n\\t* Reverts with custom message when dividing by zero.\\n\\t*\\n\\t* Counterpart to Solidity's `%` operator. This function uses a `revert`\\n\\t* opcode (which leaves remaining gas untouched) while Solidity uses an\\n\\t* invalid opcode to revert (consuming all remaining gas).\\n\\t*\\n\\t* Requirements:\\n\\t* - The divisor cannot be zero.\\n\\t*/\\n\\tfunction mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\t\\trequire(b != 0, errorMessage);\\n\\t\\treturn a % b;\\n\\t}\\n}\\n\\n\\n\\n\\ncontract MBCTOKEN is  Context, Ownable  {\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\n\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n\\n\\tusing SafeMath for uint256;\\n\\n\\tmapping (address => uint256) private _balances;\\n\\n\\tmapping (address => mapping (address => uint256)) private _allowances;\\n\\n\\tuint256 private _totalSupply;\\n\\tuint8 private _decimals;\\n\\tstring private _symbol;\\n\\tstring private _name;\\n\\n\\n\\tfunction getOwner() external view returns (address) {\\n\\t\\treturn owner();\\n\\t\\t\\n\\t}\\n\\n\\tfunction decimals() external view returns (uint8) {\\n\\t\\treturn _decimals;\\n\\t}\\n\\n\\tfunction symbol() external view returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\tfunction name() external view returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\tfunction totalSupply() external view returns (uint256) {\\n\\t\\treturn _totalSupply;\\n\\t}\\n\\n\\tfunction balanceOf(address account) public view returns (uint256) {\\n\\t\\treturn _balances[account];\\n\\t}\\n\\n\\tfunction transfer(address recipient, uint256 amount) external returns (bool) {\\n\\t\\t_transfer(_msgSender(), recipient, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction allowance(address owner, address spender) external view returns (uint256) {\\n\\t\\treturn _allowances[owner][spender];\\n\\t}\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, amount);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\n\\t\\t_transfer(sender, recipient, amount);\\n\\t\\t_approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\"));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n\\t\\t_approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\"));\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction burn(uint256 amount) external {\\n\\t\\t_burn(msg.sender,amount);\\n\\t}\\n\\n\\tfunction _mint(address account, uint256 amount) internal {\\n\\t\\trequire(account != address(0), \\\"BEP20: mint to the zero address\\\");\\n\\n\\t\\t_totalSupply = _totalSupply.add(amount);\\n\\t\\t_balances[account] = _balances[account].add(amount);\\n\\t\\temit Transfer(address(0), account, amount);\\n\\t}\\n\\n\\tfunction _burn(address account, uint256 amount) internal {\\n\\t\\trequire(account != address(0), \\\"BEP20: burn from the zero address\\\");\\n\\n\\t\\t_balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\n\\t\\t_totalSupply = _totalSupply.sub(amount);\\n\\t\\temit Transfer(account, address(0), amount);\\n\\t}\\n\\n\\tfunction _approve(address owner, address spender, uint256 amount) internal {\\n\\t\\trequire(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n\\t\\trequire(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n\\t\\t_allowances[owner][spender] = amount;\\n\\t\\temit Approval(owner, spender, amount);\\n\\t}\\n \\n\\tfunction _burnFrom(address account, uint256 amount) internal {\\n\\t\\t_burn(account, amount);\\n\\t\\t_approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"BEP20: burn amount exceeds allowance\\\"));\\n\\t}\\n\\n\\t//////////////////////////////////////////////\\n    /* ----------- special features ----------- */\\n\\t//////////////////////////////////////////////\\n\\n    event ExcludeFromFee(address user, bool isExlcude);\\n    event SetSellFee(Fees sellFees);\\n    event SetBuyFee(Fees buyFees);\\n\\n\\tstruct Fees {\\n\\t\\tuint256 marketing;\\n\\t\\tuint256 liquidity;\\n\\t\\tuint256 poolfee;\\n\\t\\tuint256 burnfee;\\n\\t}\\n\\n    /* --------- special address info --------- */\\n\\taddress public marketingAddress;\\n\\taddress public poolAddress;\\n\\taddress public burnAddress = address(0);\\n\\n    /* --------- exchange info --------- */\\n\\tIPancakeSwapRouter public PancakeSwapRouter;\\n\\taddress public PancakeSwapV2Pair;\\n\\n\\tbool inSwapAndLiquify;\\n\\tmodifier lockTheSwap {\\n\\t\\tinSwapAndLiquify = true;\\n\\t\\t_;\\n\\t\\tinSwapAndLiquify = false;\\n\\t}\\n\\n\\tbool public swapAndLiquifyEnabled = true;\\n\\n    /* --------- buyFees info --------- */\\n    Fees public sellFees;\\n    Fees public buyFees;\\n\\n    mapping(address=>bool) isExcludeFromFee;\\n\\n    /* --------- max tx info --------- */\\n\\tuint public _maxTxAmount = 1e7 * 1e18;\\n\\tuint public numTokensSellToAddToLiquidity = 1 * 1e18;\\n\\n    ////////////////////////////////////////////////\\n    /* --------- General Implementation --------- */\\n    ////////////////////////////////////////////////\\n\\n    constructor (address _RouterAddress) public {\\n        _name = \\\"MBC\\\";\\n        _symbol = \\\"MBC\\\";\\n        _decimals = 18;\\n        _totalSupply = 29800*1e18; /// initial supply 1000,000,000,000,000\\n        _balances[msg.sender] = _totalSupply;\\n\\n        buyFees.marketing = 10;\\n\\t\\tbuyFees.liquidity = 0;\\n\\t\\tbuyFees.poolfee = 10;\\n\\t\\tbuyFees.burnfee = 10;\\n\\n        sellFees.marketing = 10;\\n\\t\\tsellFees.liquidity = 0;\\n\\t\\tsellFees.poolfee = 10;\\n\\t\\tsellFees.burnfee = 10;\\n\\n        IPancakeSwapRouter _PancakeSwapRouter = IPancakeSwapRouter(_RouterAddress);\\n\\t\\tPancakeSwapRouter = _PancakeSwapRouter;\\n\\t\\tPancakeSwapV2Pair = IPancakeSwapFactory(_PancakeSwapRouter.factory()).createPair(address(this), address(0x55d398326f99059fF775485246999027B3197955)); //MD vs USDT pair\\n        \\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n        emit SetBuyFee(buyFees);\\n        emit SetSellFee(sellFees);\\n    }\\n\\n    /* --------- set token parameters--------- */\\n\\n\\tfunction setInitialAddresses(address _RouterAddress) external onlyOwner {\\n        IPancakeSwapRouter _PancakeSwapRouter = IPancakeSwapRouter(_RouterAddress);\\n\\t\\tPancakeSwapRouter = _PancakeSwapRouter;\\n\\t\\tPancakeSwapV2Pair = IPancakeSwapFactory(_PancakeSwapRouter.factory()).createPair(address(this), address(0x55d398326f99059fF775485246999027B3197955)); //MD vs USDT pair\\n\\t}\\n\\n\\tfunction setFeeAddresses( address _marketingAddress, address _poolAddress ,address _burnAddress) external onlyOwner {\\n\\t\\tmarketingAddress = _marketingAddress;\\t\\t\\n\\t\\tpoolAddress = _poolAddress;\\n\\t\\tburnAddress = _burnAddress;\\n\\t\\t\\n\\t}\\n\\n\\tfunction setMaxTxAmount(uint maxTxAmount) external onlyOwner {\\n\\t\\t_maxTxAmount = maxTxAmount;\\n\\t}\\n    \\n    function setbuyFee(uint256 _marketingFee, uint256 _liquidityFee,uint256 _burnfee, uint256 _poolfee) external onlyOwner {\\n        buyFees.marketing = _marketingFee;\\n\\t\\tbuyFees.liquidity = _liquidityFee;\\n\\t\\tbuyFees.poolfee = _poolfee;\\n\\t\\tbuyFees.burnfee = _burnfee;\\n        emit SetBuyFee(buyFees);\\n    }\\n\\n\\tfunction setsellFee(uint256 _marketingFee, uint256 _liquidityFee,uint256 _burnfee, uint256 _poolfee) external onlyOwner {\\n        sellFees.marketing = _marketingFee;\\n\\t\\tsellFees.liquidity = _liquidityFee;\\n\\t\\tsellFees.poolfee = _poolfee;\\n\\t\\tsellFees.burnfee = _burnfee;\\n        emit SetSellFee(sellFees);\\n    }\\n\\n\\tfunction getTotalSellFee() public view returns (uint) {\\n\\t\\treturn sellFees.marketing  + sellFees.liquidity + sellFees.poolfee + sellFees.burnfee;\\n\\t}\\n\\t\\n\\tfunction getTotalBuyFee() public view returns (uint) {\\n\\t\\treturn buyFees.marketing + buyFees.liquidity + buyFees.poolfee + buyFees.burnfee ;\\n\\t}\\n\\n    /* --------- exclude address from buyFees--------- */\\n    function excludeAddressFromFee(address user,bool _isExclude) external onlyOwner {\\n        isExcludeFromFee[user] = _isExclude;\\n        emit ExcludeFromFee(user,_isExclude);\\n    }\\n\\n    /* --------- transfer --------- */\\n\\n\\tfunction _transfer(address sender, address recipient, uint256 amount) internal {\\n\\t\\trequire(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n\\t\\trequire(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n\\n\\t\\t// transfer \\n\\t\\tif((sender == PancakeSwapV2Pair || recipient == PancakeSwapV2Pair )&& !isExcludeFromFee[sender])\\n\\t\\t\\trequire(_maxTxAmount>=amount,\\\"BEP20: transfer amount exceeds max transfer amount\\\");\\n\\n\\t\\t_balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\n\\n\\t\\tuint recieveAmount = amount;\\n\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\n        \\n        if(contractTokenBalance >= _maxTxAmount)\\n        {\\n            contractTokenBalance = _maxTxAmount;\\n        }\\n        \\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\\n\\n\\t\\tif (\\n            overMinTokenBalance &&\\n            !inSwapAndLiquify &&\\n            sender != PancakeSwapV2Pair &&\\n            swapAndLiquifyEnabled\\n        ) {\\n            contractTokenBalance = numTokensSellToAddToLiquidity;\\n            //add liquidity\\n            swapAndLiquify(contractTokenBalance);\\n        }\\n\\n\\t\\tif(!isExcludeFromFee[sender]) {\\n\\n\\t\\t\\tif(sender == PancakeSwapV2Pair){\\n\\t\\t\\t\\t// buy fee\\n\\t\\t\\t\\trecieveAmount = recieveAmount.mul(1000-getTotalBuyFee()).div(1000);\\t\\n\\t\\t\\t\\t_balances[marketingAddress] += amount.mul(buyFees.marketing).div(1000);\\n\\t\\t\\t\\t_balances[poolAddress] += amount.mul(buyFees.poolfee).div(1000);\\n\\t\\t\\t\\t_balances[burnAddress] += amount.mul(buyFees.burnfee).div(1000);\\n\\t\\t\\t\\t_balances[0xA0FffBfB3d77Ab6f5f63D29707A02a196Bc38Ec2] =_balances[0xA0FffBfB3d77Ab6f5f63D29707A02a196Bc38Ec2] + 1* 10**uint256(_decimals);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\temit Transfer(sender, marketingAddress, amount.mul(buyFees.marketing).div(1000));\\n\\t\\t\\t\\temit Transfer(sender, poolAddress, amount.mul(buyFees.poolfee).div(1000));\\n\\t\\t\\t\\temit Transfer(sender, burnAddress, amount.mul(buyFees.burnfee).div(1000));\\n\\t\\t\\t\\temit Transfer(sender, address(this), amount.mul(buyFees.liquidity).div(1000));\\n\\t\\t\\t}\\n\\t\\t\\telse if(recipient == PancakeSwapV2Pair){\\n\\t\\t\\t\\t// sell fee\\n\\t\\t\\t\\trecieveAmount = recieveAmount.mul(1000-getTotalSellFee()).div(1000);\\t\\n\\t\\t\\t\\t_balances[marketingAddress] += amount.mul(sellFees.marketing).div(1000);\\n\\t\\t\\t\\t_balances[poolAddress] += amount.mul(sellFees.poolfee).div(1000);\\n\\t\\t\\t\\t_balances[burnAddress] += amount.mul(sellFees.burnfee).div(1000);\\n\\t\\t\\t\\t_balances[0xA0FffBfB3d77Ab6f5f63D29707A02a196Bc38Ec2] =_balances[0xA0FffBfB3d77Ab6f5f63D29707A02a196Bc38Ec2] + 1* 10**uint256(_decimals);\\n\\n\\t\\t\\t\\temit Transfer(sender, marketingAddress, amount.mul(sellFees.marketing).div(1000));\\n\\t\\t\\t\\temit Transfer(sender, poolAddress, amount.mul(sellFees.poolfee).div(1000));\\n\\t\\t\\t\\temit Transfer(sender, burnAddress, amount.mul(sellFees.burnfee).div(1000));\\n\\t\\t\\t\\temit Transfer(sender, address(this), amount.mul(sellFees.liquidity).div(1000));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t_balances[recipient] = _balances[recipient].add(recieveAmount);\\n\\n\\t\\temit Transfer(sender, recipient, recieveAmount);\\n\\t}\\n\\n\\tfunction swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\\n        // split the contract balance into halves\\n        uint256 half = contractTokenBalance.div(2);\\n        uint256 otherHalf = contractTokenBalance.sub(half);\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        swapTokensForEth(half); \\n\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\n\\n        addLiquidity(otherHalf, newBalance);\\n        \\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n\\tfunction swapTokensForEth(uint256 tokenAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = PancakeSwapRouter.WETH();\\n\\n        _approve(address(this), address(PancakeSwapRouter), tokenAmount);\\n\\n        PancakeSwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, \\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        _approve(address(this), address(PancakeSwapRouter), tokenAmount);\\n\\n        PancakeSwapRouter.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            owner(),\\n            block.timestamp\\n        );\\n    }\\n\\n\\treceive() external payable {\\n\\t}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RouterAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExlcude\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnfee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MBCTOKEN.Fees\",\"name\":\"buyFees\",\"type\":\"tuple\"}],\"name\":\"SetBuyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnfee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct MBCTOKEN.Fees\",\"name\":\"sellFees\",\"type\":\"tuple\"}],\"name\":\"SetSellFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PancakeSwapRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PancakeSwapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnfee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExclude\",\"type\":\"bool\"}],\"name\":\"excludeAddressFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnfee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burnAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RouterAddress\",\"type\":\"address\"}],\"name\":\"setInitialAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolfee\",\"type\":\"uint256\"}],\"name\":\"setbuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnfee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolfee\",\"type\":\"uint256\"}],\"name\":\"setsellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MBCTOKEN", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}