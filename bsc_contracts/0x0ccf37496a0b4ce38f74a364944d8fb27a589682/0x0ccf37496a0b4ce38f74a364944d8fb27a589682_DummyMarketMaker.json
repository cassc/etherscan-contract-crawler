{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DummyMarketMaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\nimport {InitializableOwnable} from \\\"./lib/InitializableOwnable.sol\\\";\\nimport {IDODOV2} from \\\"./interfaces/IDODOV2.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {BooracleV1} from \\\"./BooracleV1.sol\\\";\\nimport {AutomationCompatibleInterface} from \\\"./interfaces/AutomationCompatibleInterface.sol\\\";\\n\\ncontract AutomationBase {\\n  error OnlySimulatedBackend();\\n\\n  /**\\n   * @notice method that allows it to be simulated via eth_call by checking that\\n   * the sender is the zero address.\\n   */\\n  function preventExecution() internal view {\\n    if (tx.origin != address(0)) {\\n      revert OnlySimulatedBackend();\\n    }\\n  }\\n\\n  /**\\n   * @notice modifier that allows it to be simulated via eth_call by checking\\n   * that the sender is the zero address.\\n   */\\n  modifier cannotExecute() {\\n    preventExecution();\\n    _;\\n  }\\n}\\n\\nabstract contract AutomationCompatible is AutomationBase, AutomationCompatibleInterface {}\\n\\n\\ncontract DummyMarketMaker is InitializableOwnable, AutomationCompatibleInterface {\\n    address holder;\\n    IDODOV2 public pool;\\n    BooracleV1 public oracle;\\n\\n    mapping (address => bool) public isAdminListed;\\n\\n    event AddAdmin(address indexed admin);\\n    event RemoveAdmin(address indexed admin);\\n\\n    function init(address owner, address newPool, address newHolder, address newOracle) external {\\n        initOwner(owner);\\n        pool = IDODOV2(newPool);\\n        oracle = BooracleV1(newOracle);\\n        holder = newHolder;\\n    }\\n\\n    function randomInRange(uint256 min, uint256 max) public view returns (uint256) {\\n        require(max > min, \\\"Max must be greater than min\\\");\\n        uint256 randomHash = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, block.prevrandao)));\\n        uint256 range = max - min + 1;\\n        uint256 scaledRandom = (randomHash % range) + min;\\n        return scaledRandom;\\n    }\\n\\n    function addAdminList(address admin) external onlyOwner {\\n        isAdminListed[admin] = true;\\n        emit AddAdmin(admin);\\n    }\\n\\n    function removeAdminList(address admin) external onlyOwner {\\n        isAdminListed[admin] = false;\\n        emit RemoveAdmin(admin);\\n    }\\n\\n    function getRandomAmount(uint256 maxAmount, uint256 minDecimals, uint256 maxDecimals) view public returns (uint256) {\\n        uint256 amount = randomInRange(1, maxAmount);\\n        uint256 decimals = randomInRange(minDecimals, maxDecimals);\\n        uint256 decimalsAmount = amount * 10**decimals;\\n        return decimalsAmount;\\n    }\\n\\n    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {\\n        upkeepNeeded = oracle.isBoFeasible(pool._BASE_TOKEN_());\\n    }\\n\\n    function performUpkeep(bytes calldata) external override {\\n        swap();\\n    }\\n\\n    function swap() public {\\n        require(isAdminListed[msg.sender] || msg.sender == _OWNER_, \\\"MarketMaker: not admin\\\");\\n        if (block.timestamp % 2 == 0) {\\n            uint256 amount = getRandomAmount(1, 12, 15); // from 0.001 to 0.000001\\n            IERC20(pool._BASE_TOKEN_()).transferFrom(holder, address(pool), amount);\\n            pool.sellBase(holder);\\n        } else {\\n            uint256 amount = getRandomAmount(50, 16, 18); // from 50 to 0.01\\n            IERC20(pool._QUOTE_TOKEN_()).transferFrom(holder, address(pool), amount);\\n            pool.sellQuote(holder);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"src/lib/InitializableOwnable.sol\": {\r\n      \"content\": \"/*\\n\\n    Copyright 2020 DODO ZOO.\\n    SPDX-License-Identifier: Apache-2.0\\n\\n*/\\n\\npragma solidity =0.8.20;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Ownable\\n * @author DODO Breeder\\n *\\n * @notice Ownership related functions\\n */\\ncontract InitializableOwnable {\\n    address public _OWNER_;\\n    address public _NEW_OWNER_;\\n    bool internal _INITIALIZED_;\\n\\n    // ============ Events ============\\n\\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    // ============ Modifiers ============\\n\\n    modifier notInitialized() {\\n        require(!_INITIALIZED_, \\\"DODO_INITIALIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _OWNER_, \\\"NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    // ============ Functions ============\\n\\n    function initOwner(address newOwner) public notInitialized {\\n        _INITIALIZED_ = true;\\n        _OWNER_ = newOwner;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\\n        _NEW_OWNER_ = newOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(msg.sender == _NEW_OWNER_, \\\"INVALID_CLAIM\\\");\\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\\n        _OWNER_ = _NEW_OWNER_;\\n        _NEW_OWNER_ = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDODOV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n\\ninterface IDODOV2 {\\n\\n    //========== Common ==================\\n\\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\\n\\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\\n\\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\\n\\n    function _BASE_TOKEN_() external view returns (address);\\n\\n    function _QUOTE_TOKEN_() external view returns (address);\\n\\n    function getPMMStateForCall() external view returns (\\n            uint256 i,\\n            uint256 K,\\n            uint256 B,\\n            uint256 Q,\\n            uint256 B0,\\n            uint256 Q0,\\n            uint256 R\\n    );\\n\\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\\n\\n\\n    function getDODOPoolBidirection(address token0, address token1) external view returns (address[] memory, address[] memory);\\n\\n    //========== DODOVendingMachine ========\\n\\n    function createDODOVendingMachine(\\n        address baseToken,\\n        address quoteToken,\\n        uint256 lpFeeRate,\\n        uint256 i,\\n        uint256 k,\\n        bool isOpenTWAP\\n    ) external returns (address newVendingMachine);\\n\\n    function buyShares(address to) external returns (uint256,uint256,uint256);\\n\\n\\n    //========== DODOPrivatePool ===========\\n\\n    function createDODOPrivatePool() external returns (address newPrivatePool);\\n\\n    function initDODOPrivatePool(\\n        address dppAddress,\\n        address creator,\\n        address baseToken,\\n        address quoteToken,\\n        uint256 lpFeeRate,\\n        uint256 k,\\n        uint256 i,\\n        address o,\\n        bool isOpenTwap,\\n        bool isOracleEnabled\\n    ) external;\\n\\n    function reset(\\n        address operator,\\n        uint256 newLpFeeRate,\\n        uint256 newI,\\n        uint256 newK,\\n        uint256 baseOutAmount,\\n        uint256 quoteOutAmount,\\n        uint256 minBaseReserve,\\n        uint256 minQuoteReserve\\n    ) external returns (bool);\\n\\n\\n    function _OWNER_() external returns (address);\\n\\n    //========== CrowdPooling ===========\\n\\n    function createCrowdPooling() external returns (address payable newCrowdPooling);\\n\\n    function initCrowdPooling(\\n        address cpAddress,\\n        address creator,\\n        address[] memory tokens,\\n        uint256[] memory timeLine,\\n        uint256[] memory valueList,\\n        bool[] memory switches,\\n        int globalQuota\\n    ) external;\\n\\n    function bid(address to) external;\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/BooracleV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n\\nimport \\\"./interfaces/IBooracleV1.sol\\\";\\nimport \\\"./interfaces/AggregatorV3Interface.sol\\\";\\n\\n// OpenZeppelin contracts\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract BooracleV1 is Ownable, IBooracleV1 {\\n    /* ----- State variables ----- */\\n\\n    // 128 + 64 + 64 = 256 bits (slot size)\\n    struct TokenInfo {\\n        uint128 price; // as chainlink oracle (e.g. decimal = 8)\\n        uint64 coeff; // k: decimal = 18.    18.4 * 1e18\\n        uint64 spread; // s: decimal = 18.   spread <= 2e18   18.4 * 1e18\\n    }\\n\\n    struct CLOracle {\\n        address oracle;\\n        uint8 decimal;\\n        bool cloPreferred;\\n    }\\n\\n    mapping(address => TokenInfo) public infos;\\n\\n    mapping(address => CLOracle) public clOracles;\\n\\n    uint256 public timestamp;\\n\\n    uint256 public staleDuration;\\n    uint64 public bound;\\n\\n    bool public isActive;\\n\\n    mapping(address => bool) public isAdmin;\\n    mapping(address => bool) public isKillSwitcher;\\n\\n\\n    constructor() Ownable(msg.sender) {\\n        staleDuration = uint256(90);\\n        bound = uint64(1e16); // 1%\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(owner() == msg.sender || isAdmin[msg.sender], \\\"Booracle: !Admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyKillSwitcher() {\\n        require(owner() == msg.sender || isKillSwitcher[msg.sender], \\\"Booracle: !Kill Switcher\\\");\\n        _;\\n    }\\n\\n    /* ----- External Functions ----- */\\n\\n    function setAdmin(address addr, bool flag) external onlyOwner {\\n        isAdmin[addr] = flag;\\n    }\\n\\n    function setKillSwitcher(address addr, bool flag) external onlyOwner {\\n        isKillSwitcher[addr] = flag;\\n    }\\n\\n    function setBound(uint64 _bound) external onlyOwner {\\n        bound = _bound;\\n    }\\n\\n    function setCLOracle(\\n        address token,\\n        address _oracle,\\n        bool _cloPreferred\\n    ) external onlyOwner {\\n        CLOracle storage cloRef = clOracles[token];\\n        cloRef.oracle = _oracle;\\n        cloRef.decimal = AggregatorV3Interface(_oracle).decimals();\\n        cloRef.cloPreferred = _cloPreferred;\\n    }\\n\\n    /// @dev Set the cloPreferred flag for the given base token.\\n    /// @param token baseToken address\\n    /// @param _cloPreferred true: use cloPrice, false: use woPrice\\n    function setCloPreferred(address token, bool _cloPreferred) external onlyOwner {\\n        CLOracle storage cloRef = clOracles[token];\\n        cloRef.cloPreferred = _cloPreferred;\\n    }\\n\\n    /// @dev Set the staleDuration.\\n    /// @param newStaleDuration the new stale duration\\n    function setStaleDuration(uint256 newStaleDuration) external onlyOwner {\\n        staleDuration = newStaleDuration;\\n    }\\n\\n    /// @dev Stop the price providing.\\n    function halt() external onlyKillSwitcher {\\n        isActive = false;\\n    }\\n\\n    /// @dev Resume the price providing.\\n    function resume() external onlyKillSwitcher {\\n        isActive = true;\\n    }\\n\\n    /// @dev Update the base token prices.\\n    /// @param base the baseToken address\\n    /// @param newPrice the new prices for the base token\\n    function postPrice(address base, uint128 newPrice) external onlyAdmin {\\n        infos[base].price = newPrice;\\n        timestamp = block.timestamp;\\n    }\\n\\n    /// @dev batch update baseTokens prices\\n    /// @param bases list of baseToken address\\n    /// @param newPrices the updated prices list\\n    function postPriceList(address[] calldata bases, uint128[] calldata newPrices) external onlyAdmin {\\n        uint256 length = bases.length;\\n        require(length == newPrices.length, \\\"Booracle: length_INVALID\\\");\\n\\n        // TODO: gas optimization:\\n        // https://ethereum.stackexchange.com/questions/113221/what-is-the-purpose-of-unchecked-in-solidity\\n        // https://forum.openzeppelin.com/t/a-collection-of-gas-optimisation-tricks/19966\\n        unchecked {\\n            for (uint256 i = 0; i < length; i++) {\\n                infos[bases[i]].price = newPrices[i];\\n            }\\n        }\\n\\n        timestamp = block.timestamp;\\n    }\\n\\n    /// @dev update the spreads info.\\n    /// @param base baseToken address\\n    /// @param newSpread the new spreads\\n    function postSpread(address base, uint64 newSpread) external onlyAdmin {\\n        infos[base].spread = newSpread;\\n        timestamp = block.timestamp;\\n    }\\n\\n    /// @dev batch update the spreads info.\\n    /// @param bases list of baseToken address\\n    /// @param newSpreads list of spreads info\\n    function postSpreadList(address[] calldata bases, uint64[] calldata newSpreads) external onlyAdmin {\\n        uint256 length = bases.length;\\n        require(length == newSpreads.length, \\\"Booracle: length_INVALID\\\");\\n\\n        unchecked {\\n            for (uint256 i = 0; i < length; i++) {\\n                infos[bases[i]].spread = newSpreads[i];\\n            }\\n        }\\n\\n        timestamp = block.timestamp;\\n    }\\n\\n    /// @dev update the state of the given base token.\\n    /// @param base baseToken address\\n    /// @param newPrice the new prices\\n    /// @param newSpread the new spreads\\n    /// @param newCoeff the new slippage coefficent\\n    function postState(\\n        address base,\\n        uint128 newPrice,\\n        uint64 newSpread,\\n        uint64 newCoeff\\n    ) external onlyAdmin {\\n        _setState(base, newPrice, newSpread, newCoeff);\\n        timestamp = block.timestamp;\\n    }\\n\\n    /// @dev batch update the prices, spreads and slipagge coeffs info.\\n    /// @param bases list of baseToken address\\n    /// @param newPrices the prices list\\n    /// @param newSpreads the spreads list\\n    /// @param newCoeffs the slippage coefficent list\\n    function postStateList(\\n        address[] calldata bases,\\n        uint128[] calldata newPrices,\\n        uint64[] calldata newSpreads,\\n        uint64[] calldata newCoeffs\\n    ) external onlyAdmin {\\n        uint256 length = bases.length;\\n        unchecked {\\n            for (uint256 i = 0; i < length; i++) {\\n                _setState(bases[i], newPrices[i], newSpreads[i], newCoeffs[i]);\\n            }\\n        }\\n        timestamp = block.timestamp;\\n    }\\n\\n    /*\\n        Price logic:\\n        - boPrice: booracle price\\n        - cloPrice: chainlink price\\n\\n        boFeasible is, price > 0 and price timestamp NOT stale\\n\\n        when\\n        when boFeasible && priceWithinBound     -> boPrice, feasible\\n        when boFeasible && !priceWithinBound    -> boPrice, infeasible\\n        when !boFeasible && clo_preferred       -> cloPrice, feasible\\n        when !boFeasible && !clo_preferred      -> cloPrice, infeasible\\n    */\\n    function price(address base) public view override returns (uint256 priceOut, bool feasible) {\\n        require(isActive, \\\"Booracle: !Active\\\");\\n        uint256 boPrice_ = uint256(infos[base].price);\\n        uint256 boPriceTimestamp = timestamp;\\n\\n        (uint256 cloPrice_, ) = _cloPrice(base);\\n\\n        bool boFeasible = boPrice_ != 0 && block.timestamp <= (boPriceTimestamp + staleDuration);\\n        bool boPriceInBound = cloPrice_ == 0 ||\\n            ((cloPrice_ * (1e18 - bound)) / 1e18 <= boPrice_ && boPrice_ <= (cloPrice_ * (1e18 + bound)) / 1e18);\\n\\n        if (boFeasible) {\\n            priceOut = boPrice_;\\n            feasible = boPriceInBound;\\n        } else {\\n            priceOut = clOracles[base].cloPreferred ? cloPrice_ : 0;\\n            feasible = priceOut != 0;\\n        }\\n\\n        // if (!isActive) {\\n        //     return (priceOut, false);\\n        // }\\n    }\\n\\n    /// @notice the price decimal for the specified base token\\n    function decimals(address base) external view override returns (uint8) {\\n        uint8 d = clOracles[base].decimal;\\n        return d != 0 ? d : 8;\\n    }\\n\\n    function cloPrice(address base) external view override returns (uint256 refPrice, uint256 refTimestamp) {\\n        return _cloPrice(base);\\n    }\\n\\n    function isBoFeasible(address base) external view override returns (bool) {\\n        return infos[base].price != 0 && block.timestamp <= (timestamp + staleDuration);\\n    }\\n\\n    function boSpread(address base) external view override returns (uint64) {\\n        return infos[base].spread;\\n    }\\n\\n    function boCoeff(address base) external view override returns (uint64) {\\n        return infos[base].coeff;\\n    }\\n\\n    // Wooracle price of the base token\\n    function boPrice(address base) external view override returns (uint128 priceOut, uint256 priceTimestampOut) {\\n        priceOut = infos[base].price;\\n        priceTimestampOut = timestamp;\\n    }\\n\\n    function boState(address base) external view override returns (State memory) {\\n        TokenInfo memory info = infos[base];\\n        return\\n            State({\\n                price: info.price,\\n                spread: info.spread,\\n                coeff: info.coeff,\\n                boFeasible: (info.price != 0 && block.timestamp <= (timestamp + staleDuration))\\n            });\\n    }\\n\\n    function state(address base) external view override returns (State memory) {\\n        TokenInfo memory info = infos[base];\\n        (uint256 basePrice, bool feasible) = price(base);\\n        return State({price: uint128(basePrice), spread: info.spread, coeff: info.coeff, boFeasible: feasible});\\n    }\\n\\n    function cloAddress(address base) external view override returns (address clo) {\\n        clo = clOracles[base].oracle;\\n    }\\n\\n    /* ----- Internal & Private Functions ----- */\\n    function _setState(\\n        address base,\\n        uint128 newPrice,\\n        uint64 newSpread,\\n        uint64 newCoeff\\n    ) internal {\\n        TokenInfo storage info = infos[base];\\n        info.price = newPrice;\\n        info.spread = newSpread;\\n        info.coeff = newCoeff;\\n    }\\n\\n    function _cloPrice(address token) private view returns (uint256 refPrice, uint256 refTimestamp) {\\n        address baseOracle = clOracles[token].oracle;\\n        if (baseOracle == address(0)) {\\n            return (0, 0);\\n        }\\n\\n        (, int256 rawBaseRefPrice, , uint256 baseUpdatedAt, ) = AggregatorV3Interface(baseOracle).latestRoundData();\\n        refPrice = uint256(rawBaseRefPrice);\\n        refTimestamp = baseUpdatedAt;\\n    }\\n}\\n\\n\\n// 33321673\\n\"\r\n    },\r\n    \"src/interfaces/AutomationCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBooracleV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\n\\n/// @title The oracle V1 interface by Bolide Dex.\\n/// @notice update and posted the latest price info by Woo.\\ninterface IBooracleV1 {\\n    struct State {\\n        uint128 price;\\n        uint64 spread;\\n        uint64 coeff;\\n        bool boFeasible;\\n    }\\n\\n    /// @notice Booracle spread value\\n    function boSpread(address base) external view returns (uint64);\\n\\n    /// @notice Booracle coeff value\\n    function boCoeff(address base) external view returns (uint64);\\n\\n    /// @notice Booracle state for the specified base token\\n    function boState(address base) external view returns (State memory);\\n\\n    /// @notice Chainlink oracle address for the specified base token\\n    function cloAddress(address base) external view returns (address clo);\\n\\n    /// @notice ChainLink price of the base token\\n    function cloPrice(address base) external view returns (uint256 price, uint256 timestamp);\\n\\n    /// @notice Booracle price of the base token\\n    function boPrice(address base) external view returns (uint128 price, uint256 timestamp);\\n\\n    /// @notice Returns Booracle price if available, otherwise fallback to ChainLink\\n    function price(address base) external view returns (uint256 priceNow, bool feasible);\\n\\n    /// @notice Updates the Booracle price for the specified base token\\n    function postPrice(address base, uint128 newPrice) external;\\n\\n    function postState(\\n        address base,\\n        uint128 newPrice,\\n        uint64 newSpread,\\n        uint64 newCoeff\\n    ) external;\\n\\n    /// @notice State of the specified base token.\\n    function state(address base) external view returns (State memory);\\n\\n    /// @notice The price decimal for the specified base token (e.g. 8)\\n    function decimals(address base) external view returns (uint8);\\n\\n    /// @notice last updated timestamp\\n    function timestamp() external view returns (uint256);\\n\\n    /// @notice Flag for Wooracle price feasible\\n    function isBoFeasible(address base) external view returns (bool);\\n\\n    /// @notice Flag for account admin\\n    function isAdmin(address account) external view returns (bool);\\n\\n    /// @notice Flag for kill switcher\\n    function isKillSwitcher(address account) external view returns (bool);\\n}\"\r\n    },\r\n    \"src/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\n\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    /// getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n    /// if they do not have data to report, instead of returning unset values\\n    /// which could be misinterpreted as actual reported values.\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AddAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"RemoveAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdminList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDecimals\",\"type\":\"uint256\"}],\"name\":\"getRandomAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAdminListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"contract BooracleV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IDODOV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"randomInRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdminList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DummyMarketMaker", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}